{"home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.None.train.main": [[13, 34], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "config.settings.Settings", "training.trainer.DenseObjectDetModel.train", "training.trainer.FBSparseVGGModel", "training.trainer.DenseVGGModel", "training.trainer.SparseObjectDetModel", "training.trainer.DenseObjectDetModel", "ValueError"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.train"], ["def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train network.'", ")", "\n", "parser", ".", "add_argument", "(", "'--settings_file'", ",", "help", "=", "'Path to settings yaml'", ",", "required", "=", "True", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "settings_filepath", "=", "args", ".", "settings_file", "\n", "\n", "settings", "=", "Settings", "(", "settings_filepath", ",", "generate_log", "=", "True", ")", "\n", "\n", "if", "settings", ".", "model_name", "==", "'fb_sparse_vgg'", ":", "\n", "        ", "trainer", "=", "FBSparseVGGModel", "(", "settings", ")", "\n", "", "elif", "settings", ".", "model_name", "==", "'dense_vgg'", ":", "\n", "        ", "trainer", "=", "DenseVGGModel", "(", "settings", ")", "\n", "", "elif", "settings", ".", "model_name", "==", "'fb_sparse_object_det'", ":", "\n", "        ", "trainer", "=", "SparseObjectDetModel", "(", "settings", ")", "\n", "", "elif", "settings", ".", "model_name", "==", "'dense_object_det'", ":", "\n", "        ", "trainer", "=", "DenseObjectDetModel", "(", "settings", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Model name %s specified in the settings file is not implemented'", "%", "settings", ".", "model_name", ")", "\n", "\n", "", "trainer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_test.TestConv2DSync.test_fb_sparse_convolution1d": [[17, 43], ["numpy.array", "numpy.array", "numpy.squeeze().nonzero", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sparseconvnet.InputLayer", "sparseconvnet.SubmanifoldConvolution", "sparseconvnet.SparseToDense", "sparseconvnet.InputLayer.", "sparseconvnet.SubmanifoldConvolution.", "sparseconvnet.SparseToDense.", "numpy.array", "sparse_conv2D_test.TestConv2DSync.assertListEqual", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "numpy.array.flatten().squeeze().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "numpy.squeeze", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "numpy.array.flatten", "numpy.concatenate", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array.flatten().squeeze", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "numpy.array.flatten", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "scn.SparseToDense.flatten"], "methods", ["None"], ["    ", "def", "test_fb_sparse_convolution1d", "(", "self", ")", ":", "\n", "        ", "dense_input", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "2", ",", "4", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", "]", "]", ")", "\n", "kernel", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "-", "1", ",", "2", "]", ",", "\n", "[", "1", ",", "1", ",", "-", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", "]", "]", "]", ")", "\n", "locations_x", ",", "locations_y", "=", "np", ".", "squeeze", "(", "dense_input", ")", ".", "nonzero", "(", ")", "\n", "features", "=", "dense_input", "[", "0", ",", "locations_x", ",", "locations_y", "]", "\n", "spatial_size", "=", "torch", ".", "LongTensor", "(", "[", "3", ",", "4", "]", ")", "\n", "input_layer", "=", "scn", ".", "InputLayer", "(", "2", ",", "spatial_size", ",", "mode", "=", "3", ")", "\n", "sparse_conv_layer", "=", "scn", ".", "SubmanifoldConvolution", "(", "dimension", "=", "2", ",", "nIn", "=", "1", ",", "nOut", "=", "1", ",", "filter_size", "=", "3", ",", "bias", "=", "False", ")", "\n", "sparse_conv_layer", ".", "weight", ".", "data", "=", "torch", ".", "squeeze", "(", "torch", ".", "tensor", "(", "kernel", ".", "flatten", "(", ")", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "output_layer", "=", "scn", ".", "SparseToDense", "(", "dimension", "=", "2", ",", "nPlanes", "=", "1", ")", "\n", "\n", "x", "=", "input_layer", "(", "[", "torch", ".", "LongTensor", "(", "np", ".", "concatenate", "(", "(", "locations_x", "[", ":", ",", "None", "]", ",", "locations_y", "[", ":", ",", "None", "]", ")", ",", "axis", "=", "-", "1", ")", ")", ",", "\n", "torch", ".", "FloatTensor", "(", "features", ")", "[", ":", ",", "None", "]", "]", ")", "\n", "x", "=", "sparse_conv_layer", "(", "x", ")", "\n", "x", "=", "output_layer", "(", "x", ")", "\n", "\n", "dense_output", "=", "np", ".", "array", "(", "[", "[", "[", "0", ",", "0", ",", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "5", "]", ",", "\n", "[", "1", ",", "0", ",", "0", ",", "0", "]", "]", "]", ")", "\n", "\n", "self", ".", "assertListEqual", "(", "dense_output", ".", "flatten", "(", ")", ".", "squeeze", "(", ")", ".", "tolist", "(", ")", ",", "torch", ".", "squeeze", "(", "x", ".", "flatten", "(", ")", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_test.TestConv2DSync.test_fb_sparse_convolution1d_comparison": [[44, 94], ["numpy.random.uniform", "utils.createInput", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sparseconvnet.InputLayer", "sparseconvnet.SubmanifoldConvolution", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "sparseconvnet.SparseToDense", "tuple", "sparseconvnet.InputLayer.", "sparseconvnet.SubmanifoldConvolution.", "sparseconvnet.SparseToDense.", "layers.asynSparseConvolution2D", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "layers.asynSparseConvolution2D.forward", "numpy.testing.assert_almost_equal", "numpy.random.uniform", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.squeeze().data.cpu().numpy().transpose", "torch.squeeze().data.cpu().numpy().transpose", "torch.squeeze().data.cpu().numpy().transpose", "torch.squeeze().data.cpu().numpy().transpose", "asyn_output[].float().data.cpu().numpy", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu().numpy", "asyn_output[].float().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "asyn_output[].float", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "def", "test_fb_sparse_convolution1d_comparison", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if the output of one layer asynchronous CNN in one time step is equal to the facebook implementation\"\"\"", "\n", "# Create Input", "\n", "nIn", "=", "5", "\n", "nOut", "=", "8", "\n", "use_bias", "=", "True", "\n", "dimension", "=", "2", "\n", "filter_size", "=", "3", "\n", "spatial_dimensions", "=", "[", "250", ",", "250", "]", "\n", "\n", "kernel", "=", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "filter_size", "**", "dimension", ",", "1", ",", "nIn", ",", "nOut", "]", ")", "\n", "if", "use_bias", ":", "\n", "            ", "bias", "=", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "nOut", "]", ")", "\n", "", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nIn", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "asynchronous_input", "=", "False", ",", "\n", "sequence_length", "=", "1", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", "=", "out", "\n", "\n", "# Facebook Implementation", "\n", "spatial_size", "=", "torch", ".", "LongTensor", "(", "batch_input", ".", "shape", "[", ":", "dimension", "]", ")", "\n", "input_layer", "=", "scn", ".", "InputLayer", "(", "dimension", ",", "spatial_size", ",", "mode", "=", "3", ")", "\n", "sparse_conv_layer", "=", "scn", ".", "SubmanifoldConvolution", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nIn", ",", "nOut", "=", "nOut", ",", "\n", "filter_size", "=", "filter_size", ",", "bias", "=", "use_bias", ")", "\n", "sparse_conv_layer", ".", "weight", ".", "data", "=", "torch", ".", "tensor", "(", "kernel", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "if", "use_bias", ":", "\n", "            ", "sparse_conv_layer", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "output_layer", "=", "scn", ".", "SparseToDense", "(", "dimension", "=", "dimension", ",", "nPlanes", "=", "nOut", ")", "\n", "\n", "select_indices", "=", "tuple", "(", "batch_update_locations", ".", "T", ")", "\n", "features", "=", "batch_input", "[", "select_indices", "]", "\n", "\n", "fb_output", "=", "input_layer", "(", "[", "torch", ".", "LongTensor", "(", "batch_update_locations", ")", ",", "torch", ".", "FloatTensor", "(", "features", ")", "]", ")", "\n", "fb_output", "=", "sparse_conv_layer", "(", "fb_output", ")", "\n", "fb_output", "=", "output_layer", "(", "fb_output", ")", "\n", "\n", "# Asynchronous Sparse Convolution", "\n", "asyn_conv_layer_1", "=", "ascn", ".", "asynSparseConvolution2D", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nIn", ",", "nOut", "=", "nOut", ",", "\n", "filter_size", "=", "filter_size", ",", "first_layer", "=", "True", ",", "use_bias", "=", "use_bias", ")", "\n", "asyn_conv_layer_1", ".", "weight", ".", "data", "=", "torch", ".", "squeeze", "(", "torch", ".", "tensor", "(", "kernel", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "dim", "=", "1", ")", "\n", "if", "use_bias", ":", "\n", "            ", "asyn_conv_layer_1", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "", "asyn_output", "=", "asyn_conv_layer_1", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "batch_update_locations", ")", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "batch_input", ")", ",", "\n", "active_sites_map", "=", "None", ",", "\n", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "torch", ".", "squeeze", "(", "fb_output", ",", "dim", "=", "0", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "[", "1", ",", "2", ",", "0", "]", ")", ",", "\n", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_test.TestConv2DSync.test_sparse_convolution1d_asynchronous": [[95, 144], ["print", "tqdm.tqdm", "range", "utils.createInput", "utils.createConvBatchNormLayers", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "batch_conv_layer.forward", "range", "sparse_conv2D_test.TestConv2DSync.assertListEqual", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "asyn_conv_layer.forward", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "torch.tensor.long", "torch.tensor.long", "torch.tensor.float", "torch.tensor.float", "batch_output[].clone", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "torch.tensor.long", "torch.tensor.long", "torch.tensor.float", "torch.tensor.float", "asyn_output[].clone", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvBatchNormLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "def", "test_sparse_convolution1d_asynchronous", "(", "self", ")", ":", "\n", "        ", "\"\"\"Test for 1D convolution with one layer in a asynchronous update\"\"\"", "\n", "print", "(", "'Asynchronous 1-Layer Test'", ")", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "10", ")", ")", ":", "\n", "# print('Test: %s' % i_test)", "\n", "# print('#######################')", "\n", "# print('#       New Test      #')", "\n", "# print('#######################')", "\n", "            ", "nIn", "=", "4", "\n", "nOut", "=", "20", "\n", "sequence_length", "=", "13", "\n", "use_bias", "=", "True", "\n", "use_batch_norm", "=", "True", "\n", "spatial_dimensions", "=", "[", "260", ",", "250", "]", "\n", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nIn", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "asynchronous_input", "=", "True", ",", "\n", "sequence_length", "=", "sequence_length", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", ",", "asyn_input", ",", "asyn_update_locations", "=", "out", "\n", "\n", "out", "=", "test_util", ".", "createConvBatchNormLayers", "(", "1", ",", "[", "nIn", ",", "nOut", "]", ",", "use_bias", ",", "use_batch_norm", ",", "dimension", "=", "2", ",", "\n", "facebook_layer", "=", "False", ")", "\n", "batch_conv_layers", ",", "batch_conv_bn_layers", ",", "asyn_conv_layers", ",", "asyn_bn_layers", "=", "out", "\n", "batch_conv_layer", "=", "batch_conv_layers", "[", "0", "]", "\n", "asyn_conv_layer", "=", "asyn_conv_layers", "[", "0", "]", "\n", "\n", "# Batch Computation", "\n", "batch_input", "=", "torch", ".", "tensor", "(", "batch_input", ")", "\n", "locations_batch", "=", "torch", ".", "tensor", "(", "batch_update_locations", ")", "\n", "batch_output", "=", "batch_conv_layer", ".", "forward", "(", "update_location", "=", "locations_batch", ".", "long", "(", ")", ",", "\n", "feature_map", "=", "batch_input", ".", "float", "(", ")", ",", "\n", "active_sites_map", "=", "None", ",", "rule_book_input", "=", "None", ",", "rule_book_output", "=", "None", ")", "\n", "if", "use_batch_norm", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "batch_conv_bn_layers", "[", "0", "]", ",", "batch_output", "[", "2", "]", ".", "clone", "(", ")", ",", "batch_output", "[", "1", "]", ")", "\n", "\n", "# Asynchronous Update", "\n", "", "for", "time_i", "in", "range", "(", "len", "(", "asyn_input", ")", ")", ":", "\n", "                ", "asyn_input_i", "=", "torch", ".", "tensor", "(", "asyn_input", "[", "time_i", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "asyn_locations_i", "=", "torch", ".", "tensor", "(", "asyn_update_locations", "[", "time_i", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "asyn_output", "=", "asyn_conv_layer", ".", "forward", "(", "update_location", "=", "asyn_locations_i", ".", "long", "(", ")", ",", "\n", "feature_map", "=", "asyn_input_i", ".", "float", "(", ")", ",", "\n", "active_sites_map", "=", "None", ",", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "\n", "if", "use_batch_norm", ":", "\n", "                    ", "self", ".", "applyBatchNorm", "(", "asyn_bn_layers", "[", "0", "]", ",", "asyn_output", "[", "2", "]", ".", "clone", "(", ")", ",", "asyn_output", "[", "1", "]", ")", "\n", "\n", "", "", "self", ".", "assertListEqual", "(", "torch", ".", "squeeze", "(", "batch_output", "[", "1", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ",", "\n", "torch", ".", "squeeze", "(", "asyn_output", "[", "1", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_test.TestConv2DSync.test_sparse_convolution1d_multiple_layers": [[145, 199], ["print", "tqdm.tqdm", "range", "utils.createInput", "utils.createConvBatchNormLayers", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "tuple", "sparseconvnet.InputLayer", "sparseconvnet.SparseToDense", "sparseconvnet.InputLayer.", "range", "sparseconvnet.SparseToDense.", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "asyn_conv_layers[].forward", "range", "numpy.testing.assert_almost_equal", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "asyn_conv_layers[].forward", "torch.squeeze().data.cpu().numpy().transpose", "torch.squeeze().data.cpu().numpy().transpose", "torch.squeeze().data.cpu().numpy().transpose", "torch.squeeze().data.cpu().numpy().transpose", "x[].float().data.cpu().numpy", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.tensor.long", "torch.tensor.long", "torch.tensor.float", "torch.tensor.float", "x[].clone", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "x[].clone", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu().numpy", "x[].float().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "x[].float", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvBatchNormLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "", "def", "test_sparse_convolution1d_multiple_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if multiple layers of asynchronous CNN result in the same output as the facebook implementation\"\"\"", "\n", "print", "(", "'Batch N-Layer Test'", ")", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "10", ")", ")", ":", "\n", "            ", "dimension", "=", "2", "\n", "nLayers", "=", "3", "\n", "nChannels", "=", "[", "3", ",", "5", ",", "10", ",", "10", "]", "\n", "spatial_dimensions", "=", "[", "260", ",", "250", "]", "\n", "use_bias", "=", "True", "\n", "use_batch_norm", "=", "True", "\n", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nChannels", "[", "0", "]", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "\n", "asynchronous_input", "=", "False", ",", "sequence_length", "=", "1", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", "=", "out", "\n", "\n", "out", "=", "test_util", ".", "createConvBatchNormLayers", "(", "nLayers", ",", "nChannels", ",", "use_bias", ",", "use_batch_norm", ",", "dimension", "=", "2", ",", "\n", "facebook_layer", "=", "True", ")", "\n", "sparse_conv_layers", ",", "sparse_bn_layers", ",", "asyn_conv_layers", ",", "asyn_bn_layers", "=", "out", "\n", "\n", "# Sparse convolution layer implementation by facebook", "\n", "spatial_size", "=", "torch", ".", "LongTensor", "(", "batch_input", ".", "shape", "[", ":", "dimension", "]", ")", "\n", "select_indices", "=", "tuple", "(", "batch_update_locations", ".", "T", ")", "\n", "features", "=", "batch_input", "[", "select_indices", "]", "\n", "input_layer", "=", "scn", ".", "InputLayer", "(", "dimension", ",", "spatial_size", ",", "mode", "=", "3", ")", "\n", "output_layer", "=", "scn", ".", "SparseToDense", "(", "dimension", "=", "dimension", ",", "nPlanes", "=", "nChannels", "[", "-", "1", "]", ")", "\n", "\n", "fb_output", "=", "input_layer", "(", "[", "torch", ".", "LongTensor", "(", "batch_update_locations", ")", ",", "torch", ".", "FloatTensor", "(", "features", ")", "]", ")", "\n", "for", "i_layer", "in", "range", "(", "0", ",", "nLayers", ")", ":", "\n", "                ", "fb_output", "=", "sparse_conv_layers", "[", "i_layer", "]", "(", "fb_output", ")", "\n", "if", "use_batch_norm", ":", "\n", "                    ", "fb_output", "=", "sparse_bn_layers", "[", "i_layer", "]", "(", "fb_output", ")", "\n", "\n", "", "", "fb_output", "=", "output_layer", "(", "fb_output", ")", "\n", "\n", "# Batch Asynchronous Sparse Convolution", "\n", "locations_1", "=", "torch", ".", "tensor", "(", "batch_update_locations", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "dense_input", "=", "torch", ".", "tensor", "(", "batch_input", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "# Layer 1", "\n", "x", "=", "asyn_conv_layers", "[", "0", "]", ".", "forward", "(", "update_location", "=", "locations_1", ".", "long", "(", ")", ",", "\n", "feature_map", "=", "dense_input", ".", "float", "(", ")", ",", "\n", "active_sites_map", "=", "None", ",", "rule_book_input", "=", "None", ",", "rule_book_output", "=", "None", ")", "\n", "if", "use_batch_norm", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "asyn_bn_layers", "[", "0", "]", ",", "x", "[", "2", "]", ".", "clone", "(", ")", ",", "x", "[", "1", "]", ")", "\n", "\n", "", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", ")", ":", "\n", "                ", "x", "=", "asyn_conv_layers", "[", "i_layer", "]", ".", "forward", "(", "update_location", "=", "x", "[", "0", "]", ",", "feature_map", "=", "x", "[", "1", "]", ",", "active_sites_map", "=", "x", "[", "2", "]", ",", "\n", "rule_book_input", "=", "x", "[", "3", "]", ",", "rule_book_output", "=", "x", "[", "4", "]", ")", "\n", "\n", "if", "use_batch_norm", ":", "\n", "                    ", "self", ".", "applyBatchNorm", "(", "asyn_bn_layers", "[", "i_layer", "]", ",", "x", "[", "2", "]", ".", "clone", "(", ")", ",", "x", "[", "1", "]", ")", "\n", "\n", "", "", "np", ".", "testing", ".", "assert_almost_equal", "(", "torch", ".", "squeeze", "(", "fb_output", ",", "dim", "=", "0", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "[", "1", ",", "2", ",", "0", "]", ")", ",", "\n", "x", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_test.TestConv2DSync.test_sparse_convolution1d_multiple_layers_asynchronous": [[200, 285], ["print", "tqdm.tqdm", "range", "utils.createInput", "utils.createConvBatchNormLayers", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "batch_asyn_conv_layers[].forward", "range", "range", "numpy.testing.assert_almost_equal", "batch_asyn_conv_layers[].forward", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "asyn_conv_layers[].forward", "range", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "x_batch[].float().data.cpu().numpy", "x_asyn[].float().data.cpu().numpy", "torch.tensor.long", "torch.tensor.long", "torch.tensor.float", "torch.tensor.float", "torch.relu", "torch.relu", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "x_batch[].clone", "asyn_conv_layers[].forward", "x_asyn[].clone", "x_batch[].clone", "torch.tensor.long", "torch.tensor.long", "torch.tensor.float", "torch.tensor.float", "torch.relu", "torch.relu", "sparse_conv2D_test.TestConv2DSync.applyBatchNorm", "x_batch[].float().data.cpu", "x_asyn[].float().data.cpu", "x_asyn[].clone", "x_batch[].float", "x_asyn[].float"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvBatchNormLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "", "def", "test_sparse_convolution1d_multiple_layers_asynchronous", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if multiple layers of asynchronous CNN result in the same output as the facebook implementation\"\"\"", "\n", "print", "(", "'Asynchronous N-Layer Test'", ")", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "10", ")", ")", ":", "\n", "# print('Test: %s' % i_test)", "\n", "# print('#######################')", "\n", "# print('#       New Test      #')", "\n", "# print('#######################')", "\n", "            ", "use_relu", "=", "True", "\n", "use_bias", "=", "True", "\n", "use_batch_norm", "=", "True", "\n", "nLayers", "=", "4", "\n", "nChannels", "=", "[", "1", ",", "5", ",", "7", ",", "5", ",", "10", "]", "\n", "sequence_length", "=", "10", "\n", "spatial_dimensions", "=", "[", "260", ",", "250", "]", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nChannels", "[", "0", "]", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "\n", "asynchronous_input", "=", "True", ",", "sequence_length", "=", "sequence_length", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", ",", "asyn_input", ",", "asyn_update_locations", "=", "out", "\n", "\n", "out", "=", "test_util", ".", "createConvBatchNormLayers", "(", "nLayers", ",", "nChannels", ",", "use_bias", ",", "use_batch_norm", ",", "dimension", "=", "2", ",", "\n", "facebook_layer", "=", "False", ")", "\n", "batch_asyn_conv_layers", ",", "batch_asyn_bn_layers", ",", "asyn_conv_layers", ",", "asyn_bn_layers", "=", "out", "\n", "\n", "# ---- Batch Asynchronous Sparse Convolution ----", "\n", "batch_locations", "=", "torch", ".", "tensor", "(", "batch_update_locations", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "batch_dense_input", "=", "torch", ".", "tensor", "(", "batch_input", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "# Layer 1", "\n", "x_batch", "=", "batch_asyn_conv_layers", "[", "0", "]", ".", "forward", "(", "update_location", "=", "batch_locations", ".", "long", "(", ")", ",", "\n", "feature_map", "=", "batch_dense_input", ".", "float", "(", ")", ",", "\n", "active_sites_map", "=", "None", ",", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", ")", ":", "\n", "                ", "if", "use_relu", ":", "\n", "                    ", "feature_input", "=", "F", ".", "relu", "(", "x_batch", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "feature_input", "=", "x_batch", "[", "1", "]", "\n", "", "if", "use_batch_norm", ":", "\n", "                    ", "self", ".", "applyBatchNorm", "(", "batch_asyn_bn_layers", "[", "i_layer", "-", "1", "]", ",", "x_batch", "[", "2", "]", ".", "clone", "(", ")", ",", "x_batch", "[", "1", "]", ")", "\n", "\n", "", "x_batch", "=", "batch_asyn_conv_layers", "[", "i_layer", "]", ".", "forward", "(", "update_location", "=", "x_batch", "[", "0", "]", ",", "feature_map", "=", "feature_input", ",", "\n", "active_sites_map", "=", "x_batch", "[", "2", "]", ",", "\n", "rule_book_input", "=", "x_batch", "[", "3", "]", ",", "\n", "rule_book_output", "=", "x_batch", "[", "4", "]", ")", "\n", "\n", "", "if", "use_batch_norm", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "batch_asyn_bn_layers", "[", "-", "1", "]", ",", "x_batch", "[", "2", "]", ".", "clone", "(", ")", ",", "x_batch", "[", "1", "]", ")", "\n", "\n", "# ---- Asynchronous Sparse Convolution ----", "\n", "\n", "", "for", "i_sequence", "in", "range", "(", "sequence_length", ")", ":", "\n", "# Layer 1 Input", "\n", "                ", "asyn_locations", "=", "torch", ".", "tensor", "(", "asyn_update_locations", "[", "i_sequence", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "asyn_dense_input", "=", "torch", ".", "tensor", "(", "asyn_input", "[", "i_sequence", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "x_asyn", "=", "asyn_conv_layers", "[", "0", "]", ".", "forward", "(", "update_location", "=", "asyn_locations", ".", "long", "(", ")", ",", "\n", "feature_map", "=", "asyn_dense_input", ".", "float", "(", ")", ",", "\n", "active_sites_map", "=", "None", ",", "\n", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "\n", "# x_asyn: new_update_events, output_feature_map, active_sites_map, rule_book_input, rule_book_output", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", ")", ":", "\n", "                    ", "if", "use_relu", ":", "\n", "                        ", "feature_input", "=", "F", ".", "relu", "(", "x_asyn", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                        ", "feature_input", "=", "x_asyn", "[", "1", "]", "\n", "\n", "", "if", "use_batch_norm", ":", "\n", "                        ", "self", ".", "applyBatchNorm", "(", "asyn_bn_layers", "[", "i_layer", "-", "1", "]", ",", "x_asyn", "[", "2", "]", ".", "clone", "(", ")", ",", "x_asyn", "[", "1", "]", ")", "\n", "\n", "", "x_asyn", "=", "asyn_conv_layers", "[", "i_layer", "]", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ",", "\n", "feature_map", "=", "feature_input", ",", "\n", "active_sites_map", "=", "x_asyn", "[", "2", "]", ",", "\n", "rule_book_input", "=", "x_asyn", "[", "3", "]", ",", "\n", "rule_book_output", "=", "x_asyn", "[", "4", "]", ")", "\n", "\n", "", "", "if", "use_batch_norm", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "asyn_bn_layers", "[", "-", "1", "]", ",", "x_asyn", "[", "2", "]", ".", "clone", "(", ")", ",", "x_asyn", "[", "1", "]", ")", "\n", "\n", "# self.assertListEqual(torch.squeeze(x_batch[1]).data.cpu().tolist(),", "\n", "#                      torch.squeeze(x_asyn[1]).data.cpu().tolist())", "\n", "", "np", ".", "testing", ".", "assert_almost_equal", "(", "x_batch", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "x_asyn", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "6", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_test.TestConv2DSync.applyBatchNorm": [[287, 302], ["torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "layer", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "bn_active_sites.nonzero", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze.split", "torch.squeeze.split", "torch.squeeze.split", "torch.squeeze.split"], "methods", ["None"], ["", "", "def", "applyBatchNorm", "(", "self", ",", "layer", ",", "bn_active_sites", ",", "feature_map_to_update", ")", ":", "\n", "        ", "\"\"\"\n        Applies the batch norm layer to the the sparse features.\n\n        :param layer: torch.nn.BatchNorm1d layer\n        :param bn_active_sites: location of the active sites\n        :param feature_map_to_update: feature map, result is stored in place to the tensor\n        \"\"\"", "\n", "bn_active_sites", "[", "bn_active_sites", "==", "Sites", ".", "NEW_INACTIVE_SITE", ".", "value", "]", "=", "0", "\n", "active_sites", "=", "torch", ".", "squeeze", "(", "bn_active_sites", ".", "nonzero", "(", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "bn_input", "=", "torch", ".", "squeeze", "(", "feature_map_to_update", "[", "active_sites", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "1", ")", ".", "T", "[", "None", ",", ":", ",", ":", "]", "\n", "sparse_bn_features", "=", "layer", "(", "bn_input", ")", "\n", "sparse_bn_features", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "squeeze", "(", "sparse_bn_features", ",", "dim", "=", "0", ")", ".", "T", ",", "dim", "=", "1", ")", "\n", "feature_map_to_update", "[", "active_sites", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "sparse_bn_features", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_VGG_test.TestSparseVGG.test_sparse_VGG_artificial_input": [[20, 78], ["print", "tqdm.tqdm", "range", "models.facebook_sparse_vgg.FBSparseVGG().eval", "models.facebook_sparse_vgg.FBSparseVGG().eval.load_state_dict", "utils.createInput", "models.asyn_sparse_vgg.asynSparseVGG", "models.asyn_sparse_vgg.asynSparseVGG.setWeightsEqual", "tuple", "torch.tensor", "torch.tensor", "models.facebook_sparse_vgg.FBSparseVGG().eval.", "torch.no_grad", "range", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "models.facebook_sparse_vgg.FBSparseVGG", "torch.load", "torch.tensor().to", "torch.tensor().to", "models.asyn_sparse_vgg.asynSparseVGG.forward", "print", "asyn_output[].float().data.cpu().numpy", "FBSparseVGG().eval.squeeze().detach().numpy().transpose", "asyn_output[].float().data.cpu().numpy", "FBSparseVGG().eval.squeeze().detach().numpy", "torch.tensor", "torch.tensor", "asyn_output[].float().data.cpu", "FBSparseVGG().eval.squeeze().detach().numpy", "asyn_output[].float().data.cpu", "FBSparseVGG().eval.squeeze().detach", "FBSparseVGG().eval.squeeze().detach", "FBSparseVGG().eval.squeeze", "asyn_output[].float", "asyn_output[].float", "FBSparseVGG().eval.squeeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.setWeightsEqual", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["    ", "def", "test_sparse_VGG_artificial_input", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if output of sparse VGG is equivalent to the facebook implementation\"\"\"", "\n", "print", "(", "'Asynchronous N-Layer Test'", ")", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "1", ")", ")", ":", "\n", "# print('Test: %s' % i_test)", "\n", "# print('#######################')", "\n", "# print('#       New Test      #')", "\n", "# print('#######################')", "\n", "            ", "nr_classes", "=", "101", "\n", "sequence_length", "=", "10", "\n", "\n", "# ---- Facebook VGG ----", "\n", "fb_model", "=", "FBSparseVGG", "(", "nr_classes", ")", ".", "eval", "(", ")", "\n", "\n", "pth", "=", "'PATH_TO_MODEL'", "\n", "fb_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "pth", ",", "map_location", "=", "{", "'cuda:0'", ":", "'cpu'", "}", ")", "[", "'model'", "]", ")", "\n", "\n", "# ---- Create Input ----", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "2", ",", "spatial_dimensions", "=", "[", "191", ",", "255", "]", ",", "\n", "asynchronous_input", "=", "True", ",", "sequence_length", "=", "sequence_length", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", ",", "asyn_input", ",", "asyn_update_locations", "=", "out", "\n", "\n", "# ---- Asynchronous VGG ----", "\n", "layer_list", "=", "[", "[", "'C'", ",", "2", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "256", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "256", ",", "512", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "512", ",", "256", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "[", "'ClassicFC'", ",", "256", "*", "3", "*", "2", ",", "2", "]", "]", "\n", "\n", "asyn_model", "=", "asynSparseVGG", "(", "nr_classes", "=", "101", ",", "layer_list", "=", "layer_list", ",", "device", "=", "DEVICE", ")", "\n", "asyn_model", ".", "setWeightsEqual", "(", "fb_model", ")", "\n", "\n", "# ---- Facebook VGG ----", "\n", "select_indices", "=", "tuple", "(", "batch_update_locations", ".", "T", ")", "\n", "features", "=", "batch_input", "[", "select_indices", "]", "\n", "batch_locations", "=", "torch", ".", "tensor", "(", "batch_update_locations", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "features", "=", "torch", ".", "tensor", "(", "features", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "fb_output", "=", "fb_model", "(", "[", "batch_locations", ",", "features", "]", ")", "\n", "\n", "# ---- Asynchronous VGG ----", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "for", "i_sequence", "in", "range", "(", "sequence_length", ")", ":", "\n", "                    ", "x_asyn", "=", "[", "None", "]", "*", "5", "\n", "x_asyn", "[", "0", "]", "=", "torch", ".", "tensor", "(", "asyn_update_locations", "[", "i_sequence", "]", ",", "dtype", "=", "torch", ".", "long", ")", ".", "to", "(", "DEVICE", ")", "\n", "x_asyn", "[", "1", "]", "=", "torch", ".", "tensor", "(", "asyn_input", "[", "i_sequence", "]", ",", "dtype", "=", "torch", ".", "float", ")", ".", "to", "(", "DEVICE", ")", "\n", "\n", "asyn_output", "=", "asyn_model", ".", "forward", "(", "x_asyn", ")", "\n", "print", "(", "'--------Sequence %s----------'", "%", "i_sequence", ")", "\n", "\n", "", "", "if", "fb_output", ".", "ndim", "==", "4", ":", "\n", "                ", "np", ".", "testing", ".", "assert_almost_equal", "(", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "fb_output", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", ",", "decimal", "=", "5", ")", "\n", "", "else", ":", "\n", "                ", "np", ".", "testing", ".", "assert_almost_equal", "(", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "fb_output", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_VGG_test.TestSparseVGG.test_sparse_VGG_event_input": [[79, 144], ["print", "models.facebook_sparse_vgg.FBSparseVGG().eval", "dataloader.dataset.NCaltech101", "dataloader.dataset.NCaltech101.__getitem__", "torch.from_numpy", "torch.nn.functional.interpolate", "histogram.permute.permute.permute", "training.trainer.AbstractTrainer.denseToSparse", "models.facebook_sparse_vgg.FBSparseVGG().eval.load_state_dict", "models.facebook_sparse_vgg.FBSparseVGG().eval.", "models.asyn_sparse_vgg.asynSparseVGG", "models.asyn_sparse_vgg.asynSparseVGG.setWeightsEqual", "torch.zeros", "histogram.permute.permute.permute", "torch.Size", "torch.no_grad", "range", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "models.facebook_sparse_vgg.FBSparseVGG", "torch.load", "spatial_dimensions.cpu().numpy", "spatial_dimensions.cpu().numpy", "models.asyn_sparse_vgg.asynSparseVGG.generateAsynInput", "update_locations[].to", "torch.zeros.to", "models.asyn_sparse_vgg.asynSparseVGG.forward", "print", "asyn_output[].float().data.cpu().numpy", "FBSparseVGG().eval.squeeze().detach().numpy().transpose", "asyn_output[].float().data.cpu().numpy", "FBSparseVGG().eval.squeeze().detach().numpy", "spatial_dimensions.cpu", "spatial_dimensions.cpu", "asyn_output[].float().data.cpu", "FBSparseVGG().eval.squeeze().detach().numpy", "asyn_output[].float().data.cpu", "FBSparseVGG().eval.squeeze().detach", "FBSparseVGG().eval.squeeze().detach", "FBSparseVGG().eval.squeeze", "asyn_output[].float", "asyn_output[].float", "FBSparseVGG().eval.squeeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCars.__getitem__", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.setWeightsEqual", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.generateAsynInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "", "", "def", "test_sparse_VGG_event_input", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if output of sparse VGG is equivalent to the facebook implementation\"\"\"", "\n", "print", "(", "'Asynchronous N-Layer Test'", ")", "\n", "nr_classes", "=", "101", "\n", "nr_last_events", "=", "1000", "\n", "sequence_length", "=", "10", "\n", "\n", "# ---- Facebook VGG ----", "\n", "fb_model", "=", "FBSparseVGG", "(", "nr_classes", ")", ".", "eval", "(", ")", "\n", "spatial_dimensions", "=", "fb_model", ".", "spatial_size", "\n", "\n", "# ---- Create Input ----", "\n", "dataset_path", "=", "'PATH_TO_DATA/N-Caltech101'", "\n", "height", "=", "180", "\n", "width", "=", "240", "\n", "train_dataset", "=", "NCaltech101", "(", "dataset_path", ",", "[", "'Motorbikes'", "]", ",", "height", ",", "width", ",", "augmentation", "=", "False", ",", "\n", "mode", "=", "'validation'", ",", "nr_events_window", "=", "nr_last_events", ")", "\n", "\n", "events", ",", "labels", ",", "histogram", "=", "train_dataset", ".", "__getitem__", "(", "0", ")", "\n", "\n", "histogram", "=", "torch", ".", "from_numpy", "(", "histogram", "[", "np", ".", "newaxis", ",", ":", ",", ":", "]", ")", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "torch", ".", "Size", "(", "spatial_dimensions", ")", ")", "\n", "histogram", "=", "histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "locations", ",", "features", "=", "AbstractTrainer", ".", "denseToSparse", "(", "histogram", ")", "\n", "\n", "# ---- Facebook VGG ----", "\n", "pth", "=", "'PATH_TO_MODEL'", "\n", "fb_model", ".", "load_state_dict", "(", "torch", ".", "load", "(", "pth", ",", "map_location", "=", "{", "'cuda:0'", ":", "'cpu'", "}", ")", "[", "'model'", "]", ")", "\n", "\n", "fb_output", "=", "fb_model", "(", "[", "locations", ",", "features", "]", ")", "\n", "\n", "# ---- Asynchronous VGG ----", "\n", "layer_list", "=", "[", "[", "'C'", ",", "2", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "256", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "256", ",", "512", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "512", ",", "256", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "[", "'ClassicFC'", ",", "256", "*", "3", "*", "2", ",", "2", "]", "]", "\n", "asyn_model", "=", "asynSparseVGG", "(", "nr_classes", "=", "101", ",", "layer_list", "=", "layer_list", ",", "device", "=", "DEVICE", ")", "\n", "asyn_model", ".", "setWeightsEqual", "(", "fb_model", ")", "\n", "\n", "list_spatial_dimensions", "=", "[", "spatial_dimensions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ",", "spatial_dimensions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "1", "]", "]", "\n", "input_histogram", "=", "torch", ".", "zeros", "(", "list_spatial_dimensions", "+", "[", "2", "]", ")", "\n", "step_size", "=", "nr_last_events", "//", "sequence_length", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "i_sequence", "in", "range", "(", "sequence_length", ")", ":", "\n", "                ", "new_batch_events", "=", "events", "[", "(", "step_size", "*", "i_sequence", ")", ":", "(", "step_size", "*", "(", "i_sequence", "+", "1", ")", ")", ",", ":", "]", "\n", "update_locations", ",", "new_histogram", "=", "asyn_model", ".", "generateAsynInput", "(", "new_batch_events", ",", "spatial_dimensions", ",", "\n", "original_shape", "=", "[", "height", ",", "width", "]", ")", "\n", "input_histogram", "=", "input_histogram", "+", "new_histogram", "\n", "x_asyn", "=", "[", "None", "]", "*", "5", "\n", "x_asyn", "[", "0", "]", "=", "update_locations", "[", ":", ",", ":", "2", "]", ".", "to", "(", "DEVICE", ")", "\n", "x_asyn", "[", "1", "]", "=", "input_histogram", ".", "to", "(", "DEVICE", ")", "\n", "\n", "asyn_output", "=", "asyn_model", ".", "forward", "(", "x_asyn", ")", "\n", "print", "(", "'--------Sequence %s----------'", "%", "i_sequence", ")", "\n", "\n", "", "", "if", "fb_output", ".", "ndim", "==", "4", ":", "\n", "            ", "np", ".", "testing", ".", "assert_almost_equal", "(", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "fb_output", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", ",", "decimal", "=", "5", ")", "\n", "", "else", ":", "\n", "            ", "np", ".", "testing", ".", "assert_almost_equal", "(", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "fb_output", ".", "squeeze", "(", "0", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_cpp_test.TestConv2DSync.test_fb_sparse_convolution1d_comparison": [[20, 65], ["numpy.random.uniform", "utils.createInput", "layers.asynSparseConvolution2D", "layers.asynSparseConvolution2D", "torch.squeeze", "layers.asynSparseConvolution2D.forward", "layers.asynSparseConvolution2Dcpp", "layers.asynSparseConvolution2Dcpp", "layers.asynSparseConvolution2Dcpp.setParameters", "layers.asynSparseConvolution2Dcpp.forward", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "numpy.random.uniform", "torch.tensor", "torch.tensor", "asyn_output[].float().data.cpu().numpy", "asyn_output[].float().data.cpu().numpy", "asyn_output[].float().data.cpu().numpy", "torch.tensor", "torch.tensor", "asyn_output[].float().data.cpu", "asyn_output[].float().data.cpu", "asyn_output[].float().data.cpu", "asyn_output[].float", "asyn_output[].float", "asyn_output[].float"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.setParameters", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["    ", "def", "test_fb_sparse_convolution1d_comparison", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if the output of one layer asynchronous CNN in one time step is equal to the python implementation\"\"\"", "\n", "debug", "=", "False", "\n", "# Create Input", "\n", "nIn", "=", "5", "\n", "nOut", "=", "8", "\n", "use_bias", "=", "True", "\n", "dimension", "=", "2", "\n", "filter_size", "=", "3", "\n", "spatial_dimensions", "=", "[", "250", ",", "250", "]", "\n", "\n", "kernel", "=", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "filter_size", "**", "dimension", ",", "1", ",", "nIn", ",", "nOut", "]", ")", "\n", "if", "use_bias", ":", "\n", "            ", "bias", "=", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "nOut", "]", ")", "\n", "", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nIn", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "asynchronous_input", "=", "False", ",", "\n", "sequence_length", "=", "1", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", "=", "out", "\n", "\n", "# Asynchronous Sparse Convolution", "\n", "asyn_conv_layer_1", "=", "ascn", ".", "asynSparseConvolution2D", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nIn", ",", "nOut", "=", "nOut", ",", "\n", "filter_size", "=", "filter_size", ",", "first_layer", "=", "True", ",", "use_bias", "=", "use_bias", ")", "\n", "asyn_conv_layer_1", ".", "weight", ".", "data", "=", "torch", ".", "squeeze", "(", "torch", ".", "tensor", "(", "kernel", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "dim", "=", "1", ")", "\n", "if", "use_bias", ":", "\n", "            ", "asyn_conv_layer_1", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "# t1 = perf_counter()", "\n", "\n", "", "asyn_output", "=", "asyn_conv_layer_1", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "batch_update_locations", ")", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "batch_input", ")", ",", "\n", "active_sites_map", "=", "None", ",", "\n", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "\n", "# dt_py = perf_counter() - t1", "\n", "# print(\"Python implementation: \", dt_py)", "\n", "\n", "# Asynchronous Sparse Convolution cpp", "\n", "conv_cpp", "=", "ascn_cpp", ".", "asynSparseConvolution2Dcpp", "(", "dimension", ",", "nIn", ",", "nOut", ",", "filter_size", ",", "True", ",", "use_bias", ",", "debug", ")", "\n", "conv_cpp", ".", "setParameters", "(", "kernel", ",", "bias", ")", "\n", "\n", "out", "=", "conv_cpp", ".", "forward", "(", "batch_update_locations", ",", "feature_map", "=", "batch_input", ")", "\n", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "out", "[", "1", "]", ",", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "4", ")", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "out", "[", "0", "]", ",", "asyn_output", "[", "0", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "4", ")", "\n", "np", ".", "testing", ".", "assert_almost_equal", "(", "out", "[", "2", "]", ",", "asyn_output", "[", "2", "]", ".", "float", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "decimal", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_cpp_test.TestConv2DSync.test_sparse_convolution_multiple_layers": [[66, 115], ["print", "tqdm.tqdm", "range", "utils.createInput", "utils.createConvCPPmLayers", "torch.LongTensor", "tuple", "sparseconvnet.InputLayer", "sparseconvnet.SparseToDense", "sparseconvnet.InputLayer.", "range", "sparseconvnet.SparseToDense.", "asyn_conv_layers[].forward", "range", "numpy.testing.assert_almost_equal", "asyn_conv_layers[].forward", "torch.squeeze().data.cpu().numpy().transpose", "torch.LongTensor", "torch.FloatTensor", "torch.tensor", "torch.tensor", "numpy.max", "torch.squeeze().data.cpu().numpy", "torch.squeeze().data.cpu", "torch.squeeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvCPPmLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "def", "test_sparse_convolution_multiple_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if multiple layers of asynchronous CNN result in the same output as the facebook implementation\"\"\"", "\n", "print", "(", "'Batch N-Layer Test'", ")", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "100", ")", ")", ":", "\n", "# print('Test: %s' % i_test)", "\n", "# print('#######################')", "\n", "# print('#       New Test      #')", "\n", "# print('#######################')", "\n", "            ", "use_relu", "=", "False", "\n", "use_bias", "=", "True", "\n", "nLayers", "=", "4", "# 4", "\n", "dimension", "=", "2", "\n", "nChannels", "=", "[", "1", ",", "5", ",", "7", ",", "5", ",", "10", "]", "\n", "spatial_dimensions", "=", "[", "250", ",", "250", "]", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nChannels", "[", "0", "]", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "asynchronous_input", "=", "False", ",", "\n", "sequence_length", "=", "1", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", "=", "out", "\n", "\n", "out", "=", "test_util", ".", "createConvCPPmLayers", "(", "nLayers", ",", "nChannels", ",", "use_bias", ",", "facebook_layer", "=", "True", ")", "\n", "sparse_conv_layers", ",", "asyn_conv_layers", "=", "out", "\n", "\n", "# Sparse convolution layer implementation by facebook", "\n", "spatial_size", "=", "torch", ".", "LongTensor", "(", "batch_input", ".", "shape", "[", ":", "dimension", "]", ")", "\n", "select_indices", "=", "tuple", "(", "batch_update_locations", ".", "T", ")", "\n", "features", "=", "batch_input", "[", "select_indices", "]", "\n", "input_layer", "=", "scn", ".", "InputLayer", "(", "dimension", ",", "spatial_size", ",", "mode", "=", "3", ")", "\n", "output_layer", "=", "scn", ".", "SparseToDense", "(", "dimension", "=", "dimension", ",", "nPlanes", "=", "nChannels", "[", "-", "1", "]", ")", "\n", "\n", "fb_output", "=", "input_layer", "(", "[", "torch", ".", "LongTensor", "(", "batch_update_locations", ")", ",", "torch", ".", "FloatTensor", "(", "features", ")", "]", ")", "\n", "for", "i_layer", "in", "range", "(", "0", ",", "nLayers", ")", ":", "\n", "                ", "fb_output", "=", "sparse_conv_layers", "[", "i_layer", "]", "(", "fb_output", ")", "\n", "\n", "", "fb_output", "=", "output_layer", "(", "fb_output", ")", "\n", "\n", "# Layer 1", "\n", "x_cpp", "=", "asyn_conv_layers", "[", "0", "]", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "batch_update_locations", ")", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "batch_input", ")", ")", "\n", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", ")", ":", "\n", "                ", "if", "use_relu", ":", "\n", "                    ", "feature_input", "=", "np", ".", "max", "(", "x_cpp", "[", "1", "]", ",", "0", ")", "\n", "", "else", ":", "\n", "                    ", "feature_input", "=", "x_cpp", "[", "1", "]", "\n", "\n", "", "x_cpp", "=", "asyn_conv_layers", "[", "i_layer", "]", ".", "forward", "(", "update_location", "=", "x_cpp", "[", "0", "]", ",", "feature_map", "=", "feature_input", ",", "\n", "active_sites_map", "=", "x_cpp", "[", "2", "]", ",", "rule_book", "=", "x_cpp", "[", "3", "]", ")", "\n", "\n", "", "np", ".", "testing", ".", "assert_almost_equal", "(", "torch", ".", "squeeze", "(", "fb_output", ",", "dim", "=", "0", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "[", "1", ",", "2", ",", "0", "]", ")", ",", "\n", "x_cpp", "[", "1", "]", ",", "decimal", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_conv2D_cpp_test.TestConv2DSync.test_sparse_convolution1d_multiple_layers_asynchronous": [[117, 181], ["print", "tqdm.tqdm", "range", "utils.createInput", "utils.createConvCPPmLayers", "batch_asyn_conv_layers[].forward", "range", "range", "numpy.testing.assert_almost_equal", "batch_asyn_conv_layers[].forward", "torch.tensor", "torch.tensor", "asyn_conv_layers[].forward", "range", "numpy.maximum", "asyn_conv_layers[].forward", "torch.tensor.long", "torch.tensor.float", "numpy.maximum"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvCPPmLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "", "def", "test_sparse_convolution1d_multiple_layers_asynchronous", "(", "self", ")", ":", "\n", "        ", "\"\"\"Tests if multiple layers of asynchronous CNN result in the same output as the facebook implementation\"\"\"", "\n", "print", "(", "'Asynchronous N-Layer Test'", ")", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "100", ")", ")", ":", "\n", "# print('Test: %s' % i_test)", "\n", "# print('#######################')", "\n", "# print('#       New Test      #')", "\n", "# print('#######################')", "\n", "            ", "use_relu", "=", "False", "\n", "use_bias", "=", "True", "\n", "nLayers", "=", "4", "\n", "nChannels", "=", "[", "1", ",", "5", ",", "7", ",", "5", ",", "10", "]", "\n", "sequence_length", "=", "10", "\n", "spatial_dimensions", "=", "[", "250", ",", "300", "]", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nChannels", "[", "0", "]", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "\n", "asynchronous_input", "=", "True", ",", "sequence_length", "=", "sequence_length", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", ",", "asyn_input", ",", "asyn_update_locations", "=", "out", "\n", "\n", "out", "=", "test_util", ".", "createConvCPPmLayers", "(", "nLayers", ",", "nChannels", ",", "use_bias", ",", "facebook_layer", "=", "False", ")", "\n", "batch_asyn_conv_layers", ",", "asyn_conv_layers", "=", "out", "\n", "\n", "# ---- Batch Asynchronous Sparse Convolution ----", "\n", "batch_locations", "=", "batch_update_locations", "\n", "batch_dense_input", "=", "batch_input", "\n", "\n", "# Layer 1", "\n", "x_batch", "=", "batch_asyn_conv_layers", "[", "0", "]", ".", "forward", "(", "update_location", "=", "batch_locations", ",", "\n", "feature_map", "=", "batch_dense_input", ",", "\n", "active_sites_map", "=", "None", ",", "rule_book", "=", "None", ")", "\n", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", ")", ":", "\n", "                ", "if", "use_relu", ":", "\n", "                    ", "feature_input", "=", "np", ".", "maximum", "(", "x_batch", "[", "1", "]", ",", "0", ")", "\n", "", "else", ":", "\n", "                    ", "feature_input", "=", "x_batch", "[", "1", "]", "\n", "\n", "", "x_batch", "=", "batch_asyn_conv_layers", "[", "i_layer", "]", ".", "forward", "(", "update_location", "=", "x_batch", "[", "0", "]", ",", "feature_map", "=", "feature_input", ",", "\n", "active_sites_map", "=", "x_batch", "[", "2", "]", ",", "\n", "rule_book", "=", "x_batch", "[", "3", "]", ")", "\n", "\n", "# ---- Asynchronous Sparse Convolution ----", "\n", "", "for", "i_sequence", "in", "range", "(", "sequence_length", ")", ":", "\n", "# print('Time in Sequence: %s ' % i_sequence)", "\n", "# Layer 1 Input", "\n", "                ", "asyn_locations", "=", "torch", ".", "tensor", "(", "asyn_update_locations", "[", "i_sequence", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "asyn_dense_input", "=", "torch", ".", "tensor", "(", "asyn_input", "[", "i_sequence", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "x_asyn", "=", "asyn_conv_layers", "[", "0", "]", ".", "forward", "(", "update_location", "=", "asyn_locations", ".", "long", "(", ")", ",", "\n", "feature_map", "=", "asyn_dense_input", ".", "float", "(", ")", ",", "\n", "active_sites_map", "=", "None", ",", "\n", "rule_book", "=", "None", ")", "\n", "\n", "# x_asyn: new_update_events, output_feature_map, active_sites_map, rule_book_input, rule_book_output", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", ")", ":", "\n", "                    ", "if", "use_relu", ":", "\n", "                        ", "feature_input", "=", "np", ".", "maximum", "(", "x_asyn", "[", "1", "]", ",", "0", ")", "\n", "", "else", ":", "\n", "                        ", "feature_input", "=", "x_asyn", "[", "1", "]", "\n", "", "x_asyn", "=", "asyn_conv_layers", "[", "i_layer", "]", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ",", "\n", "feature_map", "=", "feature_input", ",", "\n", "active_sites_map", "=", "x_asyn", "[", "2", "]", ",", "\n", "rule_book", "=", "x_asyn", "[", "3", "]", ")", "\n", "\n", "", "", "np", ".", "testing", ".", "assert_almost_equal", "(", "x_batch", "[", "1", "]", ",", "x_asyn", "[", "1", "]", ",", "decimal", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_max_pooling_test.TestMaxPoolSync.test_fb_maxpool": [[15, 46], ["numpy.asarray().astype", "batch_input[].copy.copy().nonzero", "numpy.concatenate", "batch_input[].copy", "torch.LongTensor", "tuple", "sparseconvnet.InputLayer", "sparseconvnet.MaxPooling", "sparseconvnet.SparseToDense", "sparseconvnet.InputLayer.", "sparseconvnet.MaxPooling.", "sparseconvnet.SparseToDense.", "numpy.asarray().astype", "sparse_max_pooling_test.TestMaxPoolSync.assertListEqual", "numpy.asarray().astype.tolist", "torch.squeeze().data.cpu().tolist", "numpy.asarray", "batch_input[].copy.copy", "torch.LongTensor", "torch.FloatTensor", "numpy.asarray", "torch.squeeze().data.cpu", "torch.squeeze"], "methods", ["None"], ["    ", "def", "test_fb_maxpool", "(", "self", ")", ":", "\n", "        ", "dimension", "=", "2", "\n", "pool_size", "=", "3", "\n", "pool_stride", "=", "2", "\n", "\n", "batch_input", "=", "np", ".", "asarray", "(", "[", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "1", ",", "0", ",", "2", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "2", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "2", ",", "8", "]", ",", "\n", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "]", ")", ".", "astype", "(", "float", ")", "\n", "indices", "=", "batch_input", ".", "copy", "(", ")", ".", "nonzero", "(", ")", "\n", "locations", "=", "np", ".", "concatenate", "(", "[", "indices", "[", "0", "]", "[", ":", ",", "None", "]", ",", "indices", "[", "1", "]", "[", ":", ",", "None", "]", "]", ",", "axis", "=", "1", ")", "\n", "batch_input", "=", "batch_input", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ".", "copy", "(", ")", "\n", "\n", "spatial_size", "=", "torch", ".", "LongTensor", "(", "batch_input", ".", "shape", "[", ":", "dimension", "]", ")", "\n", "select_indices", "=", "tuple", "(", "locations", ".", "T", ")", "\n", "features", "=", "batch_input", "[", "select_indices", "]", "\n", "\n", "input_layer", "=", "scn", ".", "InputLayer", "(", "dimension", ",", "spatial_size", ",", "mode", "=", "3", ")", "\n", "# Facebook implementation applies only valid padding", "\n", "max_pool_layer", "=", "scn", ".", "MaxPooling", "(", "dimension", ",", "pool_size", ",", "pool_stride", ")", "\n", "\n", "output_layer", "=", "scn", ".", "SparseToDense", "(", "dimension", "=", "dimension", ",", "nPlanes", "=", "1", ")", "\n", "\n", "x", "=", "input_layer", "(", "[", "torch", ".", "LongTensor", "(", "locations", ")", ",", "torch", ".", "FloatTensor", "(", "features", ")", "]", ")", "\n", "x", "=", "max_pool_layer", "(", "x", ")", "\n", "x", "=", "output_layer", "(", "x", ")", "\n", "\n", "correct_output", "=", "np", ".", "asarray", "(", "[", "[", "1", ",", "2", "]", ",", "\n", "[", "0", ",", "8", "]", "]", ")", ".", "astype", "(", "float", ")", "\n", "self", ".", "assertListEqual", "(", "correct_output", ".", "tolist", "(", ")", ",", "torch", ".", "squeeze", "(", "x", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_max_pooling_test.TestMaxPoolSync.test_sparse_maxpool": [[47, 68], ["numpy.array", "layers.asynMaxPool", "layers.asynMaxPool.forward", "sparse_max_pooling_test.TestMaxPoolSync.assertListEqual", "sparse_max_pooling_test.TestMaxPoolSync.assertListEqual", "numpy.squeeze().nonzero", "torch.squeeze().data.cpu().tolist", "torch.squeeze().data.cpu().tolist", "numpy.squeeze", "torch.tensor", "torch.tensor", "torch.squeeze().data.cpu", "torch.squeeze().data.cpu", "torch.squeeze", "torch.squeeze", "asyn_output[].float", "asyn_output[].float"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "def", "test_sparse_maxpool", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Tests if the output of one layer asynchronous Max Pooling outputs expected values.\n        \"\"\"", "\n", "# Create Input", "\n", "dimension", "=", "1", "\n", "pool_size", "=", "3", "\n", "pool_stride", "=", "2", "\n", "dense_input", "=", "np", ".", "array", "(", "[", "0", ",", "-", "1", ",", "0", ",", "1", ",", "2", ",", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "0", "]", ")", "\n", "locations", "=", "np", ".", "squeeze", "(", "dense_input", ")", ".", "nonzero", "(", ")", "[", "0", "]", "\n", "\n", "# Test with padding='valid'", "\n", "asyn_max_pool_layer_1", "=", "ascn", ".", "asynMaxPool", "(", "dimension", "=", "dimension", ",", "filter_size", "=", "pool_size", ",", "filter_stride", "=", "pool_stride", ",", "\n", "padding_mode", "=", "'valid'", ")", "\n", "asyn_output", "=", "asyn_max_pool_layer_1", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "locations", ")", "[", ":", ",", "None", "]", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "dense_input", ")", "[", ":", ",", "None", "]", ")", "\n", "correct_output", "=", "[", "0", ",", "2", ",", "2", ",", "3", ",", "4", "]", "\n", "correct_indices", "=", "[", "2", ",", "4", ",", "4", ",", "8", ",", "9", "]", "\n", "\n", "self", ".", "assertListEqual", "(", "correct_output", ",", "torch", ".", "squeeze", "(", "asyn_output", "[", "1", "]", ".", "float", "(", ")", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "self", ".", "assertListEqual", "(", "correct_indices", ",", "torch", ".", "squeeze", "(", "asyn_output", "[", "2", "]", ".", "float", "(", ")", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_max_pooling_test.TestMaxPoolSync.test_fb_sparse_maxpool": [[69, 110], ["tqdm.tqdm", "range", "len", "utils.createInput", "utils.createMaxLayers", "torch.LongTensor", "tuple", "sparseconvnet.InputLayer", "sparseconvnet.SparseToDense", "sparseconvnet.InputLayer.", "fb_max_layer", "sparseconvnet.SparseToDense.", "asyn_max_layer.forward", "numpy.squeeze", "np_fb_output.transpose.transpose.transpose", "sparse_max_pooling_test.TestMaxPoolSync.assertListEqual", "scn.SparseToDense.cpu().numpy", "numpy.squeeze().tolist", "numpy.squeeze().tolist", "torch.LongTensor", "torch.FloatTensor", "torch.tensor", "torch.tensor", "scn.SparseToDense.cpu", "numpy.squeeze", "numpy.squeeze", "range", "asyn_output[].numpy"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createMaxLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "def", "test_fb_sparse_maxpool", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Tests if the output of one layer asynchronous Max Pooling outputs expected values.\n        \"\"\"", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "100", ")", ")", ":", "\n", "# Create Input", "\n", "            ", "nIn", "=", "4", "\n", "pool_size", "=", "3", "\n", "pool_stride", "=", "2", "\n", "spatial_dimensions", "=", "[", "5", ",", "5", "]", "\n", "padding_mode", "=", "'valid'", "\n", "dimension", "=", "len", "(", "spatial_dimensions", ")", "\n", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nIn", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "asynchronous_input", "=", "False", ",", "\n", "sequence_length", "=", "1", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", "=", "out", "\n", "\n", "fb_max_layer", ",", "asyn_max_layer", "=", "test_util", ".", "createMaxLayers", "(", "dimension", ",", "facebook_layer", "=", "True", ",", "\n", "pool_size", "=", "pool_size", ",", "pool_stride", "=", "pool_stride", ",", "\n", "padding_mode", "=", "padding_mode", ")", "\n", "spatial_size", "=", "torch", ".", "LongTensor", "(", "batch_input", ".", "shape", "[", ":", "dimension", "]", ")", "\n", "select_indices", "=", "tuple", "(", "batch_update_locations", ".", "T", ")", "\n", "features", "=", "batch_input", "[", "select_indices", "]", "\n", "input_layer", "=", "scn", ".", "InputLayer", "(", "dimension", ",", "spatial_size", ",", "mode", "=", "3", ")", "\n", "output_layer", "=", "scn", ".", "SparseToDense", "(", "dimension", "=", "dimension", ",", "nPlanes", "=", "nIn", ")", "\n", "\n", "# Facebook implementation", "\n", "fb_output", "=", "input_layer", "(", "[", "torch", ".", "LongTensor", "(", "batch_update_locations", ")", ",", "torch", ".", "FloatTensor", "(", "features", ")", "]", ")", "\n", "fb_output", "=", "fb_max_layer", "(", "fb_output", ")", "\n", "fb_output", "=", "output_layer", "(", "fb_output", ")", "\n", "\n", "# Asynchronous sparse implementation", "\n", "asyn_output", "=", "asyn_max_layer", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "batch_update_locations", ")", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "batch_input", ")", ")", "\n", "\n", "np_fb_output", "=", "np", ".", "squeeze", "(", "fb_output", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "axis", "=", "0", ")", "\n", "fb_dim", "=", "np_fb_output", ".", "ndim", "\n", "np_fb_output", "=", "np_fb_output", ".", "transpose", "(", "[", "i", "for", "i", "in", "range", "(", "1", ",", "fb_dim", ")", "]", "+", "[", "0", "]", ")", "\n", "\n", "self", ".", "assertListEqual", "(", "np", ".", "squeeze", "(", "asyn_output", "[", "1", "]", ".", "numpy", "(", ")", ")", ".", "tolist", "(", ")", ",", "\n", "np", ".", "squeeze", "(", "np_fb_output", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.unittests.sparse_max_pooling_test.TestMaxPoolSync.test_asyn_sparse_maxpool": [[111, 161], ["tqdm.tqdm", "range", "len", "utils.createInput", "utils.createMaxLayers", "batch_max_layer.forward", "range", "asyn_max_layer.forward", "sparse_max_pooling_test.TestMaxPoolSync.assertListEqual", "sparse_max_pooling_test.TestMaxPoolSync.assertListEqual", "torch.tensor", "torch.tensor", "numpy.squeeze().tolist", "numpy.squeeze().tolist", "numpy.squeeze().tolist", "numpy.squeeze().tolist", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "torch.tensor", "torch.tensor", "numpy.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "numpy.squeeze", "numpy.squeeze", "numpy.squeeze", "numpy.squeeze", "batch_output[].numpy", "asyn_output[].numpy", "batch_output[].numpy", "asyn_output[].numpy"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createMaxLayers", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "", "def", "test_asyn_sparse_maxpool", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Tests if the output of one layer asynchronous Max Pooling outputs expected values.\n        \"\"\"", "\n", "for", "i_test", "in", "tqdm", ".", "tqdm", "(", "range", "(", "100", ")", ")", ":", "\n", "# Create Input", "\n", "            ", "nIn", "=", "128", "\n", "pool_size", "=", "3", "\n", "pool_stride", "=", "2", "\n", "sequence_length", "=", "20", "\n", "spatial_dimensions", "=", "[", "50", ",", "50", "]", "\n", "padding_mode", "=", "'valid'", "\n", "dimension", "=", "len", "(", "spatial_dimensions", ")", "\n", "\n", "out", "=", "test_util", ".", "createInput", "(", "nIn", "=", "nIn", ",", "spatial_dimensions", "=", "spatial_dimensions", ",", "asynchronous_input", "=", "True", ",", "\n", "sequence_length", "=", "sequence_length", ",", "simplified", "=", "False", ")", "\n", "batch_input", ",", "batch_update_locations", ",", "asyn_input", ",", "asyn_update_locations", "=", "out", "\n", "\n", "batch_max_layer", ",", "asyn_max_layer", "=", "test_util", ".", "createMaxLayers", "(", "dimension", ",", "facebook_layer", "=", "False", ",", "\n", "pool_size", "=", "pool_size", ",", "pool_stride", "=", "pool_stride", ",", "\n", "padding_mode", "=", "padding_mode", ")", "\n", "\n", "# Batch input", "\n", "batch_output", "=", "batch_max_layer", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "batch_update_locations", ")", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "batch_input", ")", ")", "\n", "\n", "# Asynchronous sparse implementation", "\n", "for", "i_seq", "in", "range", "(", "sequence_length", ")", ":", "\n", "                ", "asyn_output", "=", "asyn_max_layer", ".", "forward", "(", "update_location", "=", "torch", ".", "tensor", "(", "asyn_update_locations", "[", "i_seq", "]", ")", ",", "\n", "feature_map", "=", "torch", ".", "tensor", "(", "asyn_input", "[", "i_seq", "]", ")", ")", "\n", "\n", "", "try", ":", "\n", "                ", "self", ".", "assertListEqual", "(", "np", ".", "squeeze", "(", "batch_output", "[", "1", "]", ".", "numpy", "(", ")", ")", ".", "tolist", "(", ")", ",", "\n", "np", ".", "squeeze", "(", "asyn_output", "[", "1", "]", ".", "numpy", "(", ")", ")", ".", "tolist", "(", ")", ")", "\n", "self", ".", "assertListEqual", "(", "np", ".", "squeeze", "(", "batch_output", "[", "2", "]", ".", "numpy", "(", ")", ")", ".", "tolist", "(", ")", ",", "\n", "np", ".", "squeeze", "(", "asyn_output", "[", "2", "]", ".", "numpy", "(", ")", ")", ".", "tolist", "(", ")", ")", "\n", "", "except", "AssertionError", ":", "\n", "                ", "print", "(", "\"Input\"", ")", "\n", "print", "(", "np", ".", "squeeze", "(", "batch_input", ")", ")", "\n", "print", "(", "\"Batch Output\"", ")", "\n", "print", "(", "torch", ".", "squeeze", "(", "batch_output", "[", "1", "]", ")", ")", "\n", "print", "(", "\"Batch Indices\"", ")", "\n", "print", "(", "torch", ".", "squeeze", "(", "batch_output", "[", "2", "]", ")", ")", "\n", "print", "(", "\"-----\"", ")", "\n", "print", "(", "\"Asyn Output\"", ")", "\n", "print", "(", "torch", ".", "squeeze", "(", "asyn_output", "[", "1", "]", ")", ")", "\n", "print", "(", "\"Asyn Indices\"", ")", "\n", "print", "(", "torch", ".", "squeeze", "(", "asyn_output", "[", "2", "]", ")", ")", "\n", "\n", "raise", "AssertionError", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createInput": [[14, 53], ["numpy.zeros", "numpy.prod", "range", "numpy.stack", "ValueError", "numpy.ones", "[].astype", "numpy.zeros", "asyn_input_i.reshape.reshape", "asyn_input.append", "numpy.stack", "asyn_update_locations.append", "numpy.random.randint", "min", "numpy.random.randint", "numpy.random.randint", "np.zeros.copy", "numpy.unravel_index", "np.stack.copy", "max", "numpy.random.permutation", "numpy.sum"], "function", ["None"], ["def", "createInput", "(", "nIn", "=", "1", ",", "spatial_dimensions", "=", "[", "10", ",", "20", "]", ",", "asynchronous_input", "=", "True", ",", "sequence_length", "=", "3", ",", "\n", "simplified", "=", "False", ")", ":", "\n", "    ", "\"\"\"Creates an input for asynchronous or batch sparse network\"\"\"", "\n", "# np.random.seed(3)", "\n", "\n", "if", "not", "asynchronous_input", "and", "sequence_length", "!=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "'Expected the sequence length to be 1 for batch input Got sequence length %s'", "%", "\n", "sequence_length", ")", "\n", "", "asyn_input", "=", "[", "]", "\n", "asyn_update_locations", "=", "[", "]", "\n", "batch_input", "=", "np", ".", "zeros", "(", "spatial_dimensions", "+", "[", "nIn", "]", ")", "\n", "spatial_volume", "=", "np", ".", "prod", "(", "spatial_dimensions", ")", "\n", "for", "i", "in", "range", "(", "sequence_length", ")", ":", "\n", "        ", "if", "simplified", ":", "\n", "            ", "nr_cell_updates", "=", "1", "\n", "random_features", "=", "np", ".", "random", ".", "randint", "(", "-", "1", ",", "1", ",", "[", "nr_cell_updates", ",", "nIn", "]", ")", "\n", "", "else", ":", "\n", "            ", "high_threshold", "=", "min", "(", "spatial_volume", "/", "2", ",", "200", ")", "\n", "nr_cell_updates", "=", "np", ".", "random", ".", "randint", "(", "low", "=", "1", ",", "high", "=", "max", "(", "high_threshold", ",", "2", ")", ")", "\n", "random_features", "=", "np", ".", "random", ".", "randint", "(", "-", "10", ",", "10", ",", "[", "nr_cell_updates", ",", "nIn", "]", ")", "\n", "\n", "# Exclude feature updates for difference of zero", "\n", "", "random_features", "[", "np", ".", "sum", "(", "random_features", "**", "2", ",", "axis", "=", "-", "1", ")", "==", "0", ",", ":", "]", "=", "np", ".", "ones", "(", "[", "1", ",", "nIn", "]", ")", "\n", "random_permutation", "=", "np", ".", "random", ".", "permutation", "(", "spatial_volume", ")", "[", ":", "nr_cell_updates", "]", ".", "astype", "(", "np", ".", "int", ")", "\n", "asyn_input_i", "=", "np", ".", "zeros", "(", "[", "spatial_volume", ",", "nIn", "]", ")", "\n", "asyn_input_i", "[", "random_permutation", ",", ":", "]", "=", "random_features", "\n", "asyn_input_i", "=", "asyn_input_i", ".", "reshape", "(", "spatial_dimensions", "+", "[", "nIn", "]", ")", "\n", "\n", "batch_input", "=", "batch_input", "+", "asyn_input_i", "\n", "asyn_input", ".", "append", "(", "batch_input", ".", "copy", "(", ")", ")", "\n", "asyn_locations_i", "=", "np", ".", "stack", "(", "np", ".", "unravel_index", "(", "random_permutation", ",", "dims", "=", "spatial_dimensions", ")", ",", "axis", "=", "-", "1", ")", "\n", "asyn_update_locations", ".", "append", "(", "asyn_locations_i", ".", "copy", "(", ")", ")", "\n", "\n", "", "batch_update_locations", "=", "np", ".", "stack", "(", "(", "(", "batch_input", "**", "2", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "!=", "0", ")", ".", "nonzero", "(", ")", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "asynchronous_input", ":", "\n", "        ", "return", "batch_input", ",", "batch_update_locations", ",", "asyn_input", ",", "asyn_update_locations", "\n", "", "else", ":", "\n", "        ", "return", "batch_input", ",", "batch_update_locations", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvBatchNormLayers": [[55, 157], ["range", "range", "kernels.append", "asyn_conv_layers.append", "torch.squeeze", "range", "range", "numpy.random.uniform", "bias.append", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "numpy.random.uniform", "batch_norm_param.append", "asyn_conv_layer", "torch.tensor", "torch.tensor", "asyn_bn_layers.append", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "asyn_bn_layers[].eval", "sparse_conv_layers.append", "torch.tensor", "batch_asyn_conv_layers.append", "torch.squeeze", "numpy.random.uniform", "torch.nn.BatchNorm1d", "scn.SubmanifoldConvolution", "torch.tensor", "sparse_bn_layers.append", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "sparse_bn_layers[].eval", "asyn_conv_layer", "torch.tensor", "torch.tensor", "batch_asyn_bn_layers.append", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "batch_asyn_bn_layers[].eval", "scn.BatchNormalization", "torch.nn.BatchNorm1d"], "function", ["None"], ["", "", "def", "createConvBatchNormLayers", "(", "nLayers", ",", "nChannels", ",", "use_bias", ",", "use_batch_norm", ",", "dimension", "=", "2", ",", "facebook_layer", "=", "True", ",", "kernel_size", "=", "3", ")", ":", "\n", "    ", "\"\"\"Creates sparse layers\"\"\"", "\n", "kernels", "=", "[", "]", "\n", "if", "dimension", "==", "1", ":", "\n", "        ", "asyn_conv_layer", "=", "ascn1", ".", "asynSparseConvolution1D", "\n", "", "elif", "dimension", "==", "2", ":", "\n", "        ", "asyn_conv_layer", "=", "ascn2", ".", "asynSparseConvolution2D", "\n", "\n", "", "if", "use_bias", ":", "\n", "        ", "bias", "=", "[", "]", "\n", "", "if", "use_batch_norm", ":", "\n", "        ", "batch_norm_param", "=", "[", "]", "\n", "", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "        ", "kernels", ".", "append", "(", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "kernel_size", "**", "dimension", ",", "1", ",", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nChannels", "[", "i_layer", "]", "]", ")", ")", "\n", "if", "use_bias", ":", "\n", "            ", "bias", ".", "append", "(", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "nChannels", "[", "i_layer", "]", "]", ")", ")", "\n", "", "if", "use_batch_norm", ":", "\n", "            ", "learned_scale", "=", "np", ".", "random", ".", "uniform", "(", "-", "1.0", ",", "1.0", ",", "[", "nChannels", "[", "i_layer", "]", "]", ")", "\n", "learned_shift", "=", "np", ".", "random", ".", "uniform", "(", "-", "1.0", ",", "1.0", ",", "[", "nChannels", "[", "i_layer", "]", "]", ")", "\n", "running_mean", "=", "np", ".", "random", ".", "uniform", "(", "-", "1.0", ",", "1.0", ",", "[", "nChannels", "[", "i_layer", "]", "]", ")", "\n", "running_var", "=", "np", ".", "random", ".", "uniform", "(", "0.1", ",", "1.0", ",", "[", "nChannels", "[", "i_layer", "]", "]", ")", "\n", "batch_norm_param", ".", "append", "(", "[", "learned_scale", ",", "learned_shift", ",", "running_mean", ",", "running_var", "]", ")", "\n", "\n", "", "", "asyn_conv_layers", "=", "[", "]", "\n", "asyn_bn_layers", "=", "[", "]", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "        ", "asyn_conv_layers", ".", "append", "(", "asyn_conv_layer", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nOut", "=", "nChannels", "[", "i_layer", "]", ",", "\n", "filter_size", "=", "kernel_size", ",", "\n", "first_layer", "=", "(", "i_layer", "==", "1", ")", ",", "\n", "use_bias", "=", "use_bias", ")", ")", "\n", "asyn_conv_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "squeeze", "(", "torch", ".", "tensor", "(", "kernels", "[", "i_layer", "-", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", ",", "dim", "=", "1", ")", "\n", "if", "use_bias", ":", "\n", "            ", "asyn_conv_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", "[", "i_layer", "-", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "if", "use_batch_norm", ":", "\n", "            ", "asyn_bn_layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm1d", "(", "nChannels", "[", "i_layer", "-", "1", "]", ",", "eps", "=", "1e-4", ",", "momentum", "=", "0.9", ")", ")", "\n", "asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "0", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "running_mean", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "2", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "running_var", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "3", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "eval", "(", ")", "\n", "\n", "", "", "if", "facebook_layer", ":", "\n", "        ", "sparse_conv_layers", "=", "[", "]", "\n", "sparse_bn_layers", "=", "[", "]", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "            ", "sparse_conv_layers", ".", "append", "(", "scn", ".", "SubmanifoldConvolution", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nOut", "=", "nChannels", "[", "i_layer", "]", ",", "\n", "filter_size", "=", "kernel_size", ",", "\n", "bias", "=", "use_bias", ")", ")", "\n", "sparse_conv_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "tensor", "(", "kernels", "[", "i_layer", "-", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "if", "use_bias", ":", "\n", "                ", "sparse_conv_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", "[", "i_layer", "-", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "if", "use_batch_norm", ":", "\n", "                ", "sparse_bn_layers", ".", "append", "(", "scn", ".", "BatchNormalization", "(", "nChannels", "[", "i_layer", "]", ")", ")", "\n", "sparse_bn_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "0", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "sparse_bn_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "sparse_bn_layers", "[", "i_layer", "-", "1", "]", ".", "running_mean", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "2", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "sparse_bn_layers", "[", "i_layer", "-", "1", "]", ".", "running_var", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "3", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "sparse_bn_layers", "[", "i_layer", "-", "1", "]", ".", "eval", "(", ")", "\n", "\n", "", "", "return", "sparse_conv_layers", ",", "sparse_bn_layers", ",", "asyn_conv_layers", ",", "asyn_bn_layers", "\n", "", "else", ":", "\n", "        ", "batch_asyn_conv_layers", "=", "[", "]", "\n", "batch_asyn_bn_layers", "=", "[", "]", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "            ", "batch_asyn_conv_layers", ".", "append", "(", "asyn_conv_layer", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nOut", "=", "nChannels", "[", "i_layer", "]", ",", "\n", "filter_size", "=", "kernel_size", ",", "\n", "first_layer", "=", "(", "i_layer", "==", "1", ")", ",", "\n", "use_bias", "=", "use_bias", ")", ",", ")", "\n", "batch_asyn_conv_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "squeeze", "(", "torch", ".", "tensor", "(", "kernels", "[", "i_layer", "-", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", ",", "dim", "=", "1", ")", "\n", "\n", "if", "use_bias", ":", "\n", "                ", "batch_asyn_conv_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", "[", "i_layer", "-", "1", "]", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "", "if", "use_batch_norm", ":", "\n", "                ", "batch_asyn_bn_layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm1d", "(", "nChannels", "[", "i_layer", "-", "1", "]", ",", "eps", "=", "1e-4", ",", "momentum", "=", "0.9", ")", ")", "\n", "batch_asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "0", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "batch_asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "batch_asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "running_mean", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "2", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "batch_asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "running_var", ".", "data", "=", "torch", ".", "tensor", "(", "batch_norm_param", "[", "i_layer", "-", "1", "]", "[", "3", "]", ",", "\n", "dtype", "=", "torch", ".", "float64", ")", "\n", "batch_asyn_bn_layers", "[", "i_layer", "-", "1", "]", ".", "eval", "(", ")", "\n", "\n", "", "", "return", "batch_asyn_conv_layers", ",", "batch_asyn_bn_layers", ",", "asyn_conv_layers", ",", "asyn_bn_layers", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createConvCPPmLayers": [[159, 213], ["range", "range", "kernels.append", "asyn_conv_layers.append", "asyn_conv_layers[].setParameters", "range", "range", "numpy.random.uniform", "bias.append", "asyn_conv_layer", "sparse_conv_layers.append", "torch.tensor", "batch_asyn_conv_layers.append", "batch_asyn_conv_layers[].setParameters", "numpy.random.uniform", "scn.SubmanifoldConvolution", "torch.tensor", "asyn_conv_layer"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.setParameters", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.setParameters"], ["", "", "def", "createConvCPPmLayers", "(", "nLayers", ",", "nChannels", ",", "use_bias", ",", "facebook_layer", "=", "True", ",", "kernel_size", "=", "3", ")", ":", "\n", "    ", "\"\"\"Creates sparse layers\"\"\"", "\n", "import", "layers", ".", "conv_layer_2D_cpp", "as", "ascn_cpp", "\n", "\n", "dimension", "=", "2", "\n", "kernels", "=", "[", "]", "\n", "asyn_conv_layer", "=", "ascn_cpp", ".", "asynSparseConvolution2Dcpp", "\n", "\n", "if", "use_bias", ":", "\n", "        ", "bias", "=", "[", "]", "\n", "\n", "", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "        ", "kernels", ".", "append", "(", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "kernel_size", "**", "dimension", ",", "1", ",", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nChannels", "[", "i_layer", "]", "]", ")", ")", "\n", "if", "use_bias", ":", "\n", "            ", "bias", ".", "append", "(", "np", ".", "random", ".", "uniform", "(", "-", "10.0", ",", "10.0", ",", "[", "nChannels", "[", "i_layer", "]", "]", ")", ")", "\n", "\n", "", "", "asyn_conv_layers", "=", "[", "]", "\n", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "        ", "asyn_conv_layers", ".", "append", "(", "asyn_conv_layer", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nOut", "=", "nChannels", "[", "i_layer", "]", ",", "\n", "filter_size", "=", "kernel_size", ",", "\n", "first_layer", "=", "(", "i_layer", "==", "1", ")", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "debug", "=", "False", ")", ")", "\n", "asyn_conv_layers", "[", "i_layer", "-", "1", "]", ".", "setParameters", "(", "kernels", "[", "i_layer", "-", "1", "]", ",", "bias", "[", "i_layer", "-", "1", "]", ")", "\n", "\n", "", "if", "facebook_layer", ":", "\n", "        ", "sparse_conv_layers", "=", "[", "]", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "            ", "sparse_conv_layers", ".", "append", "(", "scn", ".", "SubmanifoldConvolution", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nOut", "=", "nChannels", "[", "i_layer", "]", ",", "\n", "filter_size", "=", "kernel_size", ",", "\n", "bias", "=", "use_bias", ")", ")", "\n", "sparse_conv_layers", "[", "i_layer", "-", "1", "]", ".", "weight", ".", "data", "=", "torch", ".", "tensor", "(", "kernels", "[", "i_layer", "-", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "if", "use_bias", ":", "\n", "                ", "sparse_conv_layers", "[", "i_layer", "-", "1", "]", ".", "bias", ".", "data", "=", "torch", ".", "tensor", "(", "bias", "[", "i_layer", "-", "1", "]", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "", "", "return", "sparse_conv_layers", ",", "asyn_conv_layers", "\n", "", "else", ":", "\n", "        ", "batch_asyn_conv_layers", "=", "[", "]", "\n", "for", "i_layer", "in", "range", "(", "1", ",", "nLayers", "+", "1", ")", ":", "\n", "            ", "batch_asyn_conv_layers", ".", "append", "(", "asyn_conv_layer", "(", "dimension", "=", "dimension", ",", "nIn", "=", "nChannels", "[", "i_layer", "-", "1", "]", ",", "\n", "nOut", "=", "nChannels", "[", "i_layer", "]", ",", "\n", "filter_size", "=", "kernel_size", ",", "\n", "first_layer", "=", "(", "i_layer", "==", "1", ")", ",", "\n", "use_bias", "=", "use_bias", ",", "\n", "debug", "=", "False", ")", ",", ")", "\n", "batch_asyn_conv_layers", "[", "i_layer", "-", "1", "]", ".", "setParameters", "(", "kernels", "[", "i_layer", "-", "1", "]", ",", "bias", "[", "i_layer", "-", "1", "]", ")", "\n", "\n", "", "return", "batch_asyn_conv_layers", ",", "asyn_conv_layers", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.test_util.createMaxLayers": [[215, 230], ["layers.asynMaxPool", "scn.MaxPooling", "layers.asynMaxPool", "ValueError"], "function", ["None"], ["", "", "def", "createMaxLayers", "(", "dimension", "=", "2", ",", "facebook_layer", "=", "True", ",", "pool_size", "=", "3", ",", "pool_stride", "=", "1", ",", "padding_mode", "=", "'valid'", ")", ":", "\n", "    ", "\"\"\"Creates max pooling layers\"\"\"", "\n", "asyn_max_layer", "=", "ascn_max", ".", "asynMaxPool", "(", "dimension", "=", "dimension", ",", "filter_size", "=", "pool_size", ",", "filter_stride", "=", "pool_stride", ",", "\n", "padding_mode", "=", "padding_mode", ")", "\n", "\n", "if", "facebook_layer", ":", "\n", "        ", "if", "padding_mode", "!=", "'valid'", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected padding mode valid for facebook implementation. Got mode: %s'", "%", "padding_mode", ")", "\n", "", "sparse_max_layer", "=", "scn", ".", "MaxPooling", "(", "dimension", ",", "pool_size", ",", "pool_stride", ")", "\n", "\n", "return", "sparse_max_layer", ",", "asyn_max_layer", "\n", "", "else", ":", "\n", "        ", "batch_asyn_max_layer", "=", "ascn_max", ".", "asynMaxPool", "(", "dimension", "=", "dimension", ",", "filter_size", "=", "pool_size", ",", "\n", "filter_stride", "=", "pool_stride", ",", "padding_mode", "=", "padding_mode", ")", "\n", "return", "batch_asyn_max_layer", ",", "asyn_max_layer", "", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.__init__": [[36, 82], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "imageName", ",", "\n", "classId", ",", "\n", "x", ",", "\n", "y", ",", "\n", "w", ",", "\n", "h", ",", "\n", "imgSize", "=", "None", ",", "\n", "bbType", "=", "BBType", ".", "GroundTruth", ",", "\n", "classConfidence", "=", "None", ")", ":", "\n", "        ", "\"\"\"Constructor.\n        Args:\n            imageName: String representing the image name.\n            classId: String value representing class id.\n            x: Float value representing the X upper-left coordinate of the bounding box.\n            y: Float value representing the Y upper-left coordinate of the bounding box.\n            w: Float value representing the width bounding box.\n            h: Float value representing the height bounding box.\n            coordinates (x,y,w,h) are absolute or relative to size of the image. Default:'Absolute'.\n            imgSize: (optional) 2D vector (width, height)=>(int, int) represents the size of the\n            image of the bounding box. If typeCoordinates is 'Relative', imgSize is required.\n            bbType: (optional) Enum (Groundtruth or Detection) identifies if the bounding box\n            represents a ground truth or a detection. If it is a detection, the classConfidence has\n            to be informed.\n            classConfidence: (optional) Float value representing the confidence of the detected\n            class. If detectionType is Detection, classConfidence needs to be informed.\n        \"\"\"", "\n", "self", ".", "_imageName", "=", "imageName", "\n", "self", ".", "_classConfidence", "=", "classConfidence", "\n", "self", ".", "_bbType", "=", "bbType", "\n", "self", ".", "_classId", "=", "classId", "\n", "self", ".", "_format", "=", "format", "\n", "\n", "self", ".", "_x", "=", "x", "\n", "self", ".", "_y", "=", "y", "\n", "self", ".", "_w", "=", "w", "\n", "self", ".", "_h", "=", "h", "\n", "self", ".", "_x2", "=", "self", ".", "_x", "+", "self", ".", "_w", "\n", "self", ".", "_y2", "=", "self", ".", "_y", "+", "self", ".", "_h", "\n", "\n", "if", "imgSize", "is", "None", ":", "\n", "            ", "self", ".", "_width_img", "=", "None", "\n", "self", ".", "_height_img", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "_width_img", "=", "imgSize", "[", "0", "]", "\n", "self", ".", "_height_img", "=", "imgSize", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox": [[83, 85], ["None"], "methods", ["None"], ["", "", "def", "getAbsoluteBoundingBox", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "_x", ",", "self", ".", "_y", ",", "self", ".", "_x2", ",", "self", ".", "_y2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageName": [[86, 88], ["None"], "methods", ["None"], ["", "def", "getImageName", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_imageName", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getConfidence": [[89, 91], ["None"], "methods", ["None"], ["", "def", "getConfidence", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_classConfidence", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getFormat": [[92, 94], ["None"], "methods", ["None"], ["", "def", "getFormat", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_format", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId": [[95, 97], ["None"], "methods", ["None"], ["", "def", "getClassId", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_classId", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageSize": [[98, 100], ["None"], "methods", ["None"], ["", "def", "getImageSize", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "_width_img", ",", "self", ".", "_height_img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getBBType": [[101, 103], ["None"], "methods", ["None"], ["", "def", "getBBType", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_bbType", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.compare": [[104, 121], ["det1.getAbsoluteBoundingBox", "det1.getImageSize", "det2.getAbsoluteBoundingBox", "det2.getImageSize", "det1.getClassId", "det2.getClassId", "det2.classConfidenc"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageSize", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageSize", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId"], ["", "@", "staticmethod", "\n", "def", "compare", "(", "det1", ",", "det2", ")", ":", "\n", "        ", "det1BB", "=", "det1", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "det1ImgSize", "=", "det1", ".", "getImageSize", "(", ")", "\n", "det2BB", "=", "det2", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "det2ImgSize", "=", "det2", ".", "getImageSize", "(", ")", "\n", "\n", "if", "det1", ".", "getClassId", "(", ")", "==", "det2", ".", "getClassId", "(", ")", "and", "det1", ".", "classConfidence", "==", "det2", ".", "classConfidenc", "(", ")", "and", "det1BB", "[", "0", "]", "==", "det2BB", "[", "0", "]", "and", "det1BB", "[", "1", "]", "==", "det2BB", "[", "1", "]", "and", "det1BB", "[", "2", "]", "==", "det2BB", "[", "2", "]", "and", "det1BB", "[", "3", "]", "==", "det2BB", "[", "3", "]", "and", "det1ImgSize", "[", "0", "]", "==", "det1ImgSize", "[", "0", "]", "and", "det2ImgSize", "[", "1", "]", "==", "det2ImgSize", "[", "1", "]", ":", "\n", "            ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.clone": [[122, 137], ["boundingBox.getAbsoluteBoundingBox", "statistics_pascalvoc.BoundingBox", "boundingBox.getImageName", "boundingBox.getClassId", "boundingBox.getImageSize", "boundingBox.getBBType", "boundingBox.getConfidence"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageName", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageSize", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getBBType", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getConfidence"], ["", "@", "staticmethod", "\n", "def", "clone", "(", "boundingBox", ")", ":", "\n", "        ", "absBB", "=", "boundingBox", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "# return (self._x,self._y,self._x2,self._y2)", "\n", "newBoundingBox", "=", "BoundingBox", "(", "\n", "boundingBox", ".", "getImageName", "(", ")", ",", "\n", "boundingBox", ".", "getClassId", "(", ")", ",", "\n", "absBB", "[", "0", "]", ",", "\n", "absBB", "[", "1", "]", ",", "\n", "absBB", "[", "2", "]", ",", "\n", "absBB", "[", "3", "]", ",", "\n", "imgSize", "=", "boundingBox", ".", "getImageSize", "(", ")", ",", "\n", "bbType", "=", "boundingBox", ".", "getBBType", "(", ")", ",", "\n", "classConfidence", "=", "boundingBox", ".", "getConfidence", "(", ")", ")", "\n", "return", "newBoundingBox", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.__init__": [[140, 142], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_boundingBoxes", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.addBoundingBox": [[143, 145], ["statistics_pascalvoc.BoundingBoxes._boundingBoxes.append"], "methods", ["None"], ["", "def", "addBoundingBox", "(", "self", ",", "bb", ")", ":", "\n", "        ", "self", ".", "_boundingBoxes", ".", "append", "(", "bb", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.removeBoundingBox": [[146, 151], ["statistics_pascalvoc.BoundingBox.compare"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.compare"], ["", "def", "removeBoundingBox", "(", "self", ",", "_boundingBox", ")", ":", "\n", "        ", "for", "d", "in", "self", ".", "_boundingBoxes", ":", "\n", "            ", "if", "BoundingBox", ".", "compare", "(", "d", ",", "_boundingBox", ")", ":", "\n", "                ", "del", "self", ".", "_boundingBoxes", "[", "d", "]", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.removeAllBoundingBoxes": [[152, 154], ["None"], "methods", ["None"], ["", "", "", "def", "removeAllBoundingBoxes", "(", "self", ")", ":", "\n", "        ", "self", ".", "_boundingBoxes", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.getBoundingBoxes": [[155, 157], ["None"], "methods", ["None"], ["", "def", "getBoundingBoxes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_boundingBoxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.getBoundingBoxByClass": [[158, 164], ["d.getClassId", "boundingBoxes.append"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId"], ["", "def", "getBoundingBoxByClass", "(", "self", ",", "classId", ")", ":", "\n", "        ", "boundingBoxes", "=", "[", "]", "\n", "for", "d", "in", "self", ".", "_boundingBoxes", ":", "\n", "            ", "if", "d", ".", "getClassId", "(", ")", "==", "classId", ":", "# get only specified bounding box type", "\n", "                ", "boundingBoxes", ".", "append", "(", "d", ")", "\n", "", "", "return", "boundingBoxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.getClasses": [[165, 172], ["d.getClassId", "classes.append"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId"], ["", "def", "getClasses", "(", "self", ")", ":", "\n", "        ", "classes", "=", "[", "]", "\n", "for", "d", "in", "self", ".", "_boundingBoxes", ":", "\n", "            ", "c", "=", "d", ".", "getClassId", "(", ")", "\n", "if", "c", "not", "in", "classes", ":", "\n", "                ", "classes", ".", "append", "(", "c", ")", "\n", "", "", "return", "classes", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.getBoundingBoxesByType": [[173, 176], ["d.getBBType"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getBBType"], ["", "def", "getBoundingBoxesByType", "(", "self", ",", "bbType", ")", ":", "\n", "# get only specified bb type", "\n", "        ", "return", "[", "d", "for", "d", "in", "self", ".", "_boundingBoxes", "if", "d", ".", "getBBType", "(", ")", "==", "bbType", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.getBoundingBoxesByImageName": [[177, 180], ["d.getImageName"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageName"], ["", "def", "getBoundingBoxesByImageName", "(", "self", ",", "imageName", ")", ":", "\n", "# get only specified bb type", "\n", "        ", "return", "[", "d", "for", "d", "in", "self", ".", "_boundingBoxes", "if", "d", ".", "getImageName", "(", ")", "==", "imageName", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.count": [[181, 189], ["len", "d.getBBType"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getBBType"], ["", "def", "count", "(", "self", ",", "bbType", "=", "None", ")", ":", "\n", "        ", "if", "bbType", "is", "None", ":", "# Return all bounding boxes", "\n", "            ", "return", "len", "(", "self", ".", "_boundingBoxes", ")", "\n", "", "count", "=", "0", "\n", "for", "d", "in", "self", ".", "_boundingBoxes", ":", "\n", "            ", "if", "d", ".", "getBBType", "(", ")", "==", "bbType", ":", "# get only specified bb type", "\n", "                ", "count", "+=", "1", "\n", "", "", "return", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone": [[190, 196], ["statistics_pascalvoc.BoundingBoxes", "statistics_pascalvoc.BoundingBox.clone", "statistics_pascalvoc.BoundingBoxes.addBoundingBox"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.addBoundingBox"], ["", "def", "clone", "(", "self", ")", ":", "\n", "        ", "newBoundingBoxes", "=", "BoundingBoxes", "(", ")", "\n", "for", "d", "in", "self", ".", "_boundingBoxes", ":", "\n", "            ", "det", "=", "BoundingBox", ".", "clone", "(", "d", ")", "\n", "newBoundingBoxes", ".", "addBoundingBox", "(", "det", ")", "\n", "", "return", "newBoundingBoxes", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.GetPascalVOCMetrics": [[199, 322], ["boundingboxes.getBoundingBoxes", "sorted", "len", "sorted", "numpy.zeros", "numpy.zeros", "collections.Counter", "collections.Counter.items", "range", "numpy.cumsum", "numpy.cumsum", "numpy.divide", "ret.append", "bb.getBBType", "groundTruths.append", "detections.append", "bb.getClassId", "sorted.append", "sorted.append", "gts.append", "len", "len", "numpy.zeros", "len", "range", "statistics_pascalvoc.VOC_Evaluator.CalculateAveragePrecision", "statistics_pascalvoc.VOC_Evaluator.ElevenPointInterpolatedAP", "numpy.sum", "numpy.sum", "bb.getClassId", "len", "statistics_pascalvoc.VOC_Evaluator.iou", "bb.getImageName", "bb.getClassId", "bb.getAbsoluteBoundingBox", "bb.getImageName", "bb.getClassId", "bb.getConfidence", "bb.getAbsoluteBoundingBox"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.getBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getBBType", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.CalculateAveragePrecision", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.ElevenPointInterpolatedAP", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.iou", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageName", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getImageName", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getClassId", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getConfidence", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox"], ["    ", "def", "GetPascalVOCMetrics", "(", "self", ",", "\n", "boundingboxes", ",", "\n", "IOUThreshold", "=", "0.5", ",", "\n", "method", "=", "MethodAveragePrecision", ".", "EveryPointInterpolation", ")", ":", "\n", "        ", "\"\"\"Get the metrics used by the VOC Pascal 2012 challenge.\n        Get\n        Args:\n            boundingboxes: Object of the class BoundingBoxes representing ground truth and detected\n            bounding boxes;\n            IOUThreshold: IOU threshold indicating which detections will be considered TP or FP\n            (default value = 0.5);\n            method (default = EveryPointInterpolation): It can be calculated as the implementation\n            in the official PASCAL VOC toolkit (EveryPointInterpolation), or applying the 11-point\n            interpolatio as described in the paper \"The PASCAL Visual Object Classes(VOC) Challenge\"\n            or EveryPointInterpolation\"  (ElevenPointInterpolation);\n        Returns:\n            A list of dictionaries. Each dictionary contains information and metrics of each class.\n            The keys of each dictionary are:\n            dict['class']: class representing the current dictionary;\n            dict['precision']: array with the precision values;\n            dict['recall']: array with the recall values;\n            dict['AP']: average precision;\n            dict['interpolated precision']: interpolated precision values;\n            dict['interpolated recall']: interpolated recall values;\n            dict['total positives']: total number of ground truth positives;\n            dict['total TP']: total number of True Positive detections;\n            dict['total FP']: total number of False Negative detections;\n        \"\"\"", "\n", "ret", "=", "[", "]", "# list containing metrics (precision, recall, average precision) of each class", "\n", "# List with all ground truths (Ex: [imageName,class,confidence=1, (bb coordinates XYX2Y2)])", "\n", "groundTruths", "=", "[", "]", "\n", "# List with all detections (Ex: [imageName,class,confidence,(bb coordinates XYX2Y2)])", "\n", "detections", "=", "[", "]", "\n", "# Get all classes", "\n", "classes", "=", "[", "]", "\n", "# Loop through all bounding boxes and separate them into GTs and detections", "\n", "for", "bb", "in", "boundingboxes", ".", "getBoundingBoxes", "(", ")", ":", "\n", "# [imageName, class, confidence, (bb coordinates XYX2Y2)]", "\n", "            ", "if", "bb", ".", "getBBType", "(", ")", "==", "BBType", ".", "GroundTruth", ":", "\n", "                ", "groundTruths", ".", "append", "(", "[", "\n", "bb", ".", "getImageName", "(", ")", ",", "\n", "bb", ".", "getClassId", "(", ")", ",", "1", ",", "\n", "bb", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "]", ")", "\n", "", "else", ":", "\n", "                ", "detections", ".", "append", "(", "[", "\n", "bb", ".", "getImageName", "(", ")", ",", "\n", "bb", ".", "getClassId", "(", ")", ",", "\n", "bb", ".", "getConfidence", "(", ")", ",", "\n", "bb", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "]", ")", "\n", "# get class", "\n", "", "if", "bb", ".", "getClassId", "(", ")", "not", "in", "classes", ":", "\n", "                ", "classes", ".", "append", "(", "bb", ".", "getClassId", "(", ")", ")", "\n", "", "", "classes", "=", "sorted", "(", "classes", ")", "\n", "# Precision x Recall is obtained individually by each class", "\n", "# Loop through by classes", "\n", "for", "c", "in", "classes", ":", "\n", "# Get only detection of class c", "\n", "            ", "dects", "=", "[", "]", "\n", "[", "dects", ".", "append", "(", "d", ")", "for", "d", "in", "detections", "if", "d", "[", "1", "]", "==", "c", "]", "\n", "# Get only ground truths of class c", "\n", "gts", "=", "[", "]", "\n", "[", "gts", ".", "append", "(", "g", ")", "for", "g", "in", "groundTruths", "if", "g", "[", "1", "]", "==", "c", "]", "\n", "npos", "=", "len", "(", "gts", ")", "\n", "# sort detections by decreasing confidence", "\n", "dects", "=", "sorted", "(", "dects", ",", "key", "=", "lambda", "conf", ":", "conf", "[", "2", "]", ",", "reverse", "=", "True", ")", "\n", "TP", "=", "np", ".", "zeros", "(", "len", "(", "dects", ")", ")", "\n", "FP", "=", "np", ".", "zeros", "(", "len", "(", "dects", ")", ")", "\n", "# create dictionary with amount of gts for each image", "\n", "det", "=", "Counter", "(", "[", "cc", "[", "0", "]", "for", "cc", "in", "gts", "]", ")", "\n", "for", "key", ",", "val", "in", "det", ".", "items", "(", ")", ":", "\n", "                ", "det", "[", "key", "]", "=", "np", ".", "zeros", "(", "val", ")", "\n", "# print(\"Evaluating class: %s (%d detections)\" % (str(c), len(dects)))", "\n", "# Loop through detections", "\n", "", "for", "d", "in", "range", "(", "len", "(", "dects", ")", ")", ":", "\n", "# print('dect %s => %s' % (dects[d][0], dects[d][3],))", "\n", "# Find ground truth image", "\n", "                ", "gt", "=", "[", "gt", "for", "gt", "in", "gts", "if", "gt", "[", "0", "]", "==", "dects", "[", "d", "]", "[", "0", "]", "]", "\n", "iouMax", "=", "sys", ".", "float_info", ".", "min", "\n", "for", "j", "in", "range", "(", "len", "(", "gt", ")", ")", ":", "\n", "# print('Ground truth gt => %s' % (gt[j][3],))", "\n", "                    ", "iou", "=", "VOC_Evaluator", ".", "iou", "(", "dects", "[", "d", "]", "[", "3", "]", ",", "gt", "[", "j", "]", "[", "3", "]", ")", "\n", "if", "iou", ">", "iouMax", ":", "\n", "                        ", "iouMax", "=", "iou", "\n", "jmax", "=", "j", "\n", "# Assign detection as true positive/don't care/false positive", "\n", "", "", "if", "iouMax", ">=", "IOUThreshold", ":", "\n", "                    ", "if", "det", "[", "dects", "[", "d", "]", "[", "0", "]", "]", "[", "jmax", "]", "==", "0", ":", "\n", "                        ", "TP", "[", "d", "]", "=", "1", "# count as true positive", "\n", "det", "[", "dects", "[", "d", "]", "[", "0", "]", "]", "[", "jmax", "]", "=", "1", "# flag as already 'seen'", "\n", "# print(\"TP\")", "\n", "", "else", ":", "\n", "                        ", "FP", "[", "d", "]", "=", "1", "# count as false positive", "\n", "# print(\"FP\")", "\n", "# - A detected \"cat\" is overlaped with a GT \"cat\" with IOU >= IOUThreshold.", "\n", "", "", "else", ":", "\n", "                    ", "FP", "[", "d", "]", "=", "1", "# count as false positive", "\n", "# print(\"FP\")", "\n", "# compute precision, recall and average precision", "\n", "", "", "acc_FP", "=", "np", ".", "cumsum", "(", "FP", ")", "\n", "acc_TP", "=", "np", ".", "cumsum", "(", "TP", ")", "\n", "rec", "=", "acc_TP", "/", "npos", "\n", "prec", "=", "np", ".", "divide", "(", "acc_TP", ",", "(", "acc_FP", "+", "acc_TP", ")", ")", "\n", "# Depending on the method, call the right implementation", "\n", "if", "method", "==", "MethodAveragePrecision", ".", "EveryPointInterpolation", ":", "\n", "                ", "[", "ap", ",", "mpre", ",", "mrec", ",", "ii", "]", "=", "VOC_Evaluator", ".", "CalculateAveragePrecision", "(", "rec", ",", "prec", ")", "\n", "", "else", ":", "\n", "                ", "[", "ap", ",", "mpre", ",", "mrec", ",", "_", "]", "=", "VOC_Evaluator", ".", "ElevenPointInterpolatedAP", "(", "rec", ",", "prec", ")", "\n", "# add class result in the dictionary to be returned", "\n", "", "r", "=", "{", "\n", "'class'", ":", "c", ",", "\n", "'precision'", ":", "prec", ",", "\n", "'recall'", ":", "rec", ",", "\n", "'AP'", ":", "ap", ",", "\n", "'interpolated precision'", ":", "mpre", ",", "\n", "'interpolated recall'", ":", "mrec", ",", "\n", "'total positives'", ":", "npos", ",", "\n", "'total TP'", ":", "np", ".", "sum", "(", "TP", ")", ",", "\n", "'total FP'", ":", "np", ".", "sum", "(", "FP", ")", "\n", "}", "\n", "ret", ".", "append", "(", "r", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.PlotPrecisionRecallCurve": [[323, 414], ["statistics_pascalvoc.VOC_Evaluator.GetPascalVOCMetrics", "matplotlib.close", "matplotlib.close", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.legend", "matplotlib.grid", "matplotlib.grid", "IOError", "matplotlib.title", "matplotlib.title", "matplotlib.title", "matplotlib.title", "matplotlib.savefig", "matplotlib.savefig", "matplotlib.show", "matplotlib.show", "matplotlib.pause", "matplotlib.pause", "matplotlib.plot", "matplotlib.plot", "os.path.join", "range", "matplotlib.plot", "matplotlib.plot", "str", "len", "str", "numpy.argwhere", "nrec.append", "nprec.append", "max", "int"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.GetPascalVOCMetrics"], ["", "def", "PlotPrecisionRecallCurve", "(", "self", ",", "\n", "boundingBoxes", ",", "\n", "IOUThreshold", "=", "0.5", ",", "\n", "method", "=", "MethodAveragePrecision", ".", "EveryPointInterpolation", ",", "\n", "showAP", "=", "False", ",", "\n", "showInterpolatedPrecision", "=", "False", ",", "\n", "savePath", "=", "None", ",", "\n", "showGraphic", "=", "True", ")", ":", "\n", "        ", "\"\"\"PlotPrecisionRecallCurve\n        Plot the Precision x Recall curve for a given class.\n        Args:\n            boundingBoxes: Object of the class BoundingBoxes representing ground truth and detected\n            bounding boxes;\n            IOUThreshold (optional): IOU threshold indicating which detections will be considered\n            TP or FP (default value = 0.5);\n            method (default = EveryPointInterpolation): It can be calculated as the implementation\n            in the official PASCAL VOC toolkit (EveryPointInterpolation), or applying the 11-point\n            interpolatio as described in the paper \"The PASCAL Visual Object Classes(VOC) Challenge\"\n            or EveryPointInterpolation\"  (ElevenPointInterpolation).\n            showAP (optional): if True, the average precision value will be shown in the title of\n            the graph (default = False);\n            showInterpolatedPrecision (optional): if True, it will show in the plot the interpolated\n             precision (default = False);\n            savePath (optional): if informed, the plot will be saved as an image in this path\n            (ex: /home/mywork/ap.png) (default = None);\n            showGraphic (optional): if True, the plot will be shown (default = True)\n        Returns:\n            A list of dictionaries. Each dictionary contains information and metrics of each class.\n            The keys of each dictionary are:\n            dict['class']: class representing the current dictionary;\n            dict['precision']: array with the precision values;\n            dict['recall']: array with the recall values;\n            dict['AP']: average precision;\n            dict['interpolated precision']: interpolated precision values;\n            dict['interpolated recall']: interpolated recall values;\n            dict['total positives']: total number of ground truth positives;\n            dict['total TP']: total number of True Positive detections;\n            dict['total FP']: total number of False Negative detections;\n        \"\"\"", "\n", "results", "=", "self", ".", "GetPascalVOCMetrics", "(", "boundingBoxes", ",", "IOUThreshold", ",", "method", ")", "\n", "result", "=", "None", "\n", "# Each resut represents a class", "\n", "for", "result", "in", "results", ":", "\n", "            ", "if", "result", "is", "None", ":", "\n", "                ", "raise", "IOError", "(", "'Error: Class %d could not be found.'", "%", "classId", ")", "\n", "\n", "", "classId", "=", "result", "[", "'class'", "]", "\n", "precision", "=", "result", "[", "'precision'", "]", "\n", "recall", "=", "result", "[", "'recall'", "]", "\n", "average_precision", "=", "result", "[", "'AP'", "]", "\n", "mpre", "=", "result", "[", "'interpolated precision'", "]", "\n", "mrec", "=", "result", "[", "'interpolated recall'", "]", "\n", "npos", "=", "result", "[", "'total positives'", "]", "\n", "total_tp", "=", "result", "[", "'total TP'", "]", "\n", "total_fp", "=", "result", "[", "'total FP'", "]", "\n", "\n", "plt", ".", "close", "(", ")", "\n", "if", "showInterpolatedPrecision", ":", "\n", "                ", "if", "method", "==", "MethodAveragePrecision", ".", "EveryPointInterpolation", ":", "\n", "                    ", "plt", ".", "plot", "(", "mrec", ",", "mpre", ",", "'--r'", ",", "label", "=", "'Interpolated precision (every point)'", ")", "\n", "", "elif", "method", "==", "MethodAveragePrecision", ".", "ElevenPointInterpolation", ":", "\n", "# Uncomment the line below if you want to plot the area", "\n", "# plt.plot(mrec, mpre, 'or', label='11-point interpolated precision')", "\n", "# Remove duplicates, getting only the highest precision of each recall value", "\n", "                    ", "nrec", "=", "[", "]", "\n", "nprec", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "mrec", ")", ")", ":", "\n", "                        ", "r", "=", "mrec", "[", "idx", "]", "\n", "if", "r", "not", "in", "nrec", ":", "\n", "                            ", "idxEq", "=", "np", ".", "argwhere", "(", "mrec", "==", "r", ")", "\n", "nrec", ".", "append", "(", "r", ")", "\n", "nprec", ".", "append", "(", "max", "(", "[", "mpre", "[", "int", "(", "id", ")", "]", "for", "id", "in", "idxEq", "]", ")", ")", "\n", "", "", "plt", ".", "plot", "(", "nrec", ",", "nprec", ",", "'or'", ",", "label", "=", "'11-point interpolated precision'", ")", "\n", "", "", "plt", ".", "plot", "(", "recall", ",", "precision", ",", "label", "=", "'Precision'", ")", "\n", "plt", ".", "xlabel", "(", "'recall'", ")", "\n", "plt", ".", "ylabel", "(", "'precision'", ")", "\n", "if", "showAP", ":", "\n", "                ", "ap_str", "=", "\"{0:.2f}%\"", ".", "format", "(", "average_precision", "*", "100", ")", "\n", "# ap_str = \"{0:.4f}%\".format(average_precision * 100)", "\n", "plt", ".", "title", "(", "'Precision x Recall curve \\nClass: %s, AP: %s'", "%", "(", "str", "(", "classId", ")", ",", "ap_str", ")", ")", "\n", "", "else", ":", "\n", "                ", "plt", ".", "title", "(", "'Precision x Recall curve \\nClass: %s'", "%", "str", "(", "classId", ")", ")", "\n", "", "plt", ".", "legend", "(", "shadow", "=", "True", ")", "\n", "plt", ".", "grid", "(", ")", "\n", "if", "savePath", "is", "not", "None", ":", "\n", "                ", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "savePath", ",", "classId", "+", "'.png'", ")", ")", "\n", "", "if", "showGraphic", "is", "True", ":", "\n", "                ", "plt", ".", "show", "(", ")", "\n", "# plt.waitforbuttonpress()", "\n", "plt", ".", "pause", "(", "0.05", ")", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.CalculateAveragePrecision": [[415, 436], ["mrec.append", "mrec.append", "mpre.append", "mpre.append", "range", "range", "mrec.append", "mpre.append", "max", "len", "len", "ii.append", "numpy.sum", "len", "len"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "CalculateAveragePrecision", "(", "rec", ",", "prec", ")", ":", "\n", "        ", "mrec", "=", "[", "]", "\n", "mrec", ".", "append", "(", "0", ")", "\n", "[", "mrec", ".", "append", "(", "e", ")", "for", "e", "in", "rec", "]", "\n", "mrec", ".", "append", "(", "1", ")", "\n", "mpre", "=", "[", "]", "\n", "mpre", ".", "append", "(", "0", ")", "\n", "[", "mpre", ".", "append", "(", "e", ")", "for", "e", "in", "prec", "]", "\n", "mpre", ".", "append", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "mpre", ")", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", "i", "-", "1", "]", "=", "max", "(", "mpre", "[", "i", "-", "1", "]", ",", "mpre", "[", "i", "]", ")", "\n", "", "ii", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "mrec", ")", "-", "1", ")", ":", "\n", "            ", "if", "mrec", "[", "1", ":", "]", "[", "i", "]", "!=", "mrec", "[", "0", ":", "-", "1", "]", "[", "i", "]", ":", "\n", "                ", "ii", ".", "append", "(", "i", "+", "1", ")", "\n", "", "", "ap", "=", "0", "\n", "for", "i", "in", "ii", ":", "\n", "            ", "ap", "=", "ap", "+", "np", ".", "sum", "(", "(", "mrec", "[", "i", "]", "-", "mrec", "[", "i", "-", "1", "]", ")", "*", "mpre", "[", "i", "]", ")", "\n", "# return [ap, mpre[1:len(mpre)-1], mrec[1:len(mpre)-1], ii]", "\n", "", "return", "[", "ap", ",", "mpre", "[", "0", ":", "len", "(", "mpre", ")", "-", "1", "]", ",", "mrec", "[", "0", ":", "len", "(", "mpre", ")", "-", "1", "]", ",", "ii", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.ElevenPointInterpolatedAP": [[437, 486], ["numpy.linspace", "list", "rvals.append", "rvals.append", "pvals.append", "pvals.append", "range", "mrec.append", "mpre.append", "numpy.argwhere", "recallValid.append", "rhoInterp.append", "sum", "rvals.append", "pvals.append", "len", "max", "cc.append", "cc.append", "numpy.argwhere.min"], "methods", ["None"], ["", "@", "staticmethod", "\n", "# 11-point interpolated average precision", "\n", "def", "ElevenPointInterpolatedAP", "(", "rec", ",", "prec", ")", ":", "\n", "# def CalculateAveragePrecision2(rec, prec):", "\n", "        ", "mrec", "=", "[", "]", "\n", "# mrec.append(0)", "\n", "[", "mrec", ".", "append", "(", "e", ")", "for", "e", "in", "rec", "]", "\n", "# mrec.append(1)", "\n", "mpre", "=", "[", "]", "\n", "# mpre.append(0)", "\n", "[", "mpre", ".", "append", "(", "e", ")", "for", "e", "in", "prec", "]", "\n", "# mpre.append(0)", "\n", "recallValues", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "11", ")", "\n", "recallValues", "=", "list", "(", "recallValues", "[", ":", ":", "-", "1", "]", ")", "\n", "rhoInterp", "=", "[", "]", "\n", "recallValid", "=", "[", "]", "\n", "# For each recallValues (0, 0.1, 0.2, ... , 1)", "\n", "for", "r", "in", "recallValues", ":", "\n", "# Obtain all recall values higher or equal than r", "\n", "            ", "argGreaterRecalls", "=", "np", ".", "argwhere", "(", "mrec", "[", ":", "]", ">=", "r", ")", "\n", "pmax", "=", "0", "\n", "# If there are recalls above r", "\n", "if", "argGreaterRecalls", ".", "size", "!=", "0", ":", "\n", "                ", "pmax", "=", "max", "(", "mpre", "[", "argGreaterRecalls", ".", "min", "(", ")", ":", "]", ")", "\n", "", "recallValid", ".", "append", "(", "r", ")", "\n", "rhoInterp", ".", "append", "(", "pmax", ")", "\n", "# By definition AP = sum(max(precision whose recall is above r))/11", "\n", "", "ap", "=", "sum", "(", "rhoInterp", ")", "/", "11", "\n", "# Generating values for the plot", "\n", "rvals", "=", "[", "]", "\n", "rvals", ".", "append", "(", "recallValid", "[", "0", "]", ")", "\n", "[", "rvals", ".", "append", "(", "e", ")", "for", "e", "in", "recallValid", "]", "\n", "rvals", ".", "append", "(", "0", ")", "\n", "pvals", "=", "[", "]", "\n", "pvals", ".", "append", "(", "0", ")", "\n", "[", "pvals", ".", "append", "(", "e", ")", "for", "e", "in", "rhoInterp", "]", "\n", "pvals", ".", "append", "(", "0", ")", "\n", "# rhoInterp = rhoInterp[::-1]", "\n", "cc", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "rvals", ")", ")", ":", "\n", "            ", "p", "=", "(", "rvals", "[", "i", "]", ",", "pvals", "[", "i", "-", "1", "]", ")", "\n", "if", "p", "not", "in", "cc", ":", "\n", "                ", "cc", ".", "append", "(", "p", ")", "\n", "", "p", "=", "(", "rvals", "[", "i", "]", ",", "pvals", "[", "i", "]", ")", "\n", "if", "p", "not", "in", "cc", ":", "\n", "                ", "cc", ".", "append", "(", "p", ")", "\n", "", "", "recallValues", "=", "[", "i", "[", "0", "]", "for", "i", "in", "cc", "]", "\n", "rhoInterp", "=", "[", "i", "[", "1", "]", "for", "i", "in", "cc", "]", "\n", "return", "[", "ap", ",", "rhoInterp", ",", "recallValues", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getAllIOUs": [[488, 504], ["reference.getAbsoluteBoundingBox", "sorted", "d.getAbsoluteBoundingBox", "statistics_pascalvoc.VOC_Evaluator.iou", "ret.append"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBox.getAbsoluteBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.iou"], ["", "@", "staticmethod", "\n", "def", "_getAllIOUs", "(", "reference", ",", "detections", ")", ":", "\n", "        ", "ret", "=", "[", "]", "\n", "bbReference", "=", "reference", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "# img = np.zeros((200,200,3), np.uint8)", "\n", "for", "d", "in", "detections", ":", "\n", "            ", "bb", "=", "d", ".", "getAbsoluteBoundingBox", "(", ")", "\n", "iou", "=", "VOC_Evaluator", ".", "iou", "(", "bbReference", ",", "bb", ")", "\n", "# Show blank image with the bounding boxes", "\n", "# img = add_bb_into_image(img, d, color=(255,0,0), thickness=2, label=None)", "\n", "# img = add_bb_into_image(img, reference, color=(0,255,0), thickness=2, label=None)", "\n", "ret", ".", "append", "(", "(", "iou", ",", "reference", ",", "d", ")", ")", "# iou, reference, detection", "\n", "# cv2.imshow(\"comparing\",img)", "\n", "# cv2.waitKey(0)", "\n", "# cv2.destroyWindow(\"comparing\")", "\n", "", "return", "sorted", "(", "ret", ",", "key", "=", "lambda", "i", ":", "i", "[", "0", "]", ",", "reverse", "=", "True", ")", "# sort by iou (from highest to lowest)", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.iou": [[505, 516], ["statistics_pascalvoc.VOC_Evaluator._getIntersectionArea", "statistics_pascalvoc.VOC_Evaluator._getUnionAreas", "statistics_pascalvoc.VOC_Evaluator._boxesIntersect"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getIntersectionArea", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getUnionAreas", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._boxesIntersect"], ["", "@", "staticmethod", "\n", "def", "iou", "(", "boxA", ",", "boxB", ")", ":", "\n", "# if boxes dont intersect", "\n", "        ", "if", "VOC_Evaluator", ".", "_boxesIntersect", "(", "boxA", ",", "boxB", ")", "is", "False", ":", "\n", "            ", "return", "0", "\n", "", "interArea", "=", "VOC_Evaluator", ".", "_getIntersectionArea", "(", "boxA", ",", "boxB", ")", "\n", "union", "=", "VOC_Evaluator", ".", "_getUnionAreas", "(", "boxA", ",", "boxB", ",", "interArea", "=", "interArea", ")", "\n", "# intersection over union", "\n", "iou", "=", "interArea", "/", "union", "\n", "assert", "iou", ">=", "0", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._boxesIntersect": [[519, 530], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_boxesIntersect", "(", "boxA", ",", "boxB", ")", ":", "\n", "        ", "if", "boxA", "[", "0", "]", ">", "boxB", "[", "2", "]", ":", "\n", "            ", "return", "False", "# boxA is right of boxB", "\n", "", "if", "boxB", "[", "0", "]", ">", "boxA", "[", "2", "]", ":", "\n", "            ", "return", "False", "# boxA is left of boxB", "\n", "", "if", "boxA", "[", "3", "]", "<", "boxB", "[", "1", "]", ":", "\n", "            ", "return", "False", "# boxA is above boxB", "\n", "", "if", "boxA", "[", "1", "]", ">", "boxB", "[", "3", "]", ":", "\n", "            ", "return", "False", "# boxA is below boxB", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getIntersectionArea": [[531, 539], ["max", "max", "min", "min"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_getIntersectionArea", "(", "boxA", ",", "boxB", ")", ":", "\n", "        ", "xA", "=", "max", "(", "boxA", "[", "0", "]", ",", "boxB", "[", "0", "]", ")", "\n", "yA", "=", "max", "(", "boxA", "[", "1", "]", ",", "boxB", "[", "1", "]", ")", "\n", "xB", "=", "min", "(", "boxA", "[", "2", "]", ",", "boxB", "[", "2", "]", ")", "\n", "yB", "=", "min", "(", "boxA", "[", "3", "]", ",", "boxB", "[", "3", "]", ")", "\n", "# intersection area", "\n", "return", "(", "xB", "-", "xA", "+", "1", ")", "*", "(", "yB", "-", "yA", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getUnionAreas": [[540, 547], ["statistics_pascalvoc.VOC_Evaluator._getArea", "statistics_pascalvoc.VOC_Evaluator._getArea", "float", "statistics_pascalvoc.VOC_Evaluator._getIntersectionArea"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getArea", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getArea", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getIntersectionArea"], ["", "@", "staticmethod", "\n", "def", "_getUnionAreas", "(", "boxA", ",", "boxB", ",", "interArea", "=", "None", ")", ":", "\n", "        ", "area_A", "=", "VOC_Evaluator", ".", "_getArea", "(", "boxA", ")", "\n", "area_B", "=", "VOC_Evaluator", ".", "_getArea", "(", "boxB", ")", "\n", "if", "interArea", "is", "None", ":", "\n", "            ", "interArea", "=", "VOC_Evaluator", ".", "_getIntersectionArea", "(", "boxA", ",", "boxB", ")", "\n", "", "return", "float", "(", "area_A", "+", "area_B", "-", "interArea", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator._getArea": [[548, 551], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_getArea", "(", "box", ")", ":", "\n", "        ", "return", "(", "box", "[", "2", "]", "-", "box", "[", "0", "]", "+", "1", ")", "*", "(", "box", "[", "3", "]", "-", "box", "[", "1", "]", "+", "1", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeEventsTime": [[8, 35], ["numpy.zeros", "numpy.argsort", "numpy.arange", "sorted_events[].round().astype", "sorted_events[].round().astype", "float", "matplotlib.subplots", "ax.imshow", "ax.axis", "fig.savefig", "matplotlib.close", "sorted_events[].round", "sorted_events[].round", "numpy.logical_not", "np.zeros.astype", "numpy.logical_not"], "function", ["None"], ["def", "visualizeEventsTime", "(", "events", ",", "height", ",", "width", ",", "path_name", "=", "None", ",", "last_k_events", "=", "None", ")", ":", "\n", "    ", "\"\"\"Visualizes the input events. Different saturation depending on arrival time of the event.\"\"\"", "\n", "np_image", "=", "np", ".", "zeros", "(", "[", "height", ",", "width", ",", "3", "]", ")", "\n", "\n", "sorted_indices", "=", "np", ".", "argsort", "(", "events", "[", ":", ",", "-", "2", "]", ")", "\n", "sorted_events", "=", "events", "[", "sorted_indices", ",", ":", "]", "\n", "\n", "if", "last_k_events", "is", "not", "None", ":", "\n", "        ", "sorted_events", "=", "sorted_events", "[", "-", "last_k_events", ":", ",", ":", "]", "\n", "\n", "", "event_order", "=", "np", ".", "arange", "(", "sorted_events", ".", "shape", "[", "0", "]", ",", "dtype", "=", "np", ".", "float", ")", "\n", "temporal_color", "=", "event_order", "/", "float", "(", "sorted_events", ".", "shape", "[", "0", "]", ")", "\n", "mask_positive_events", "=", "sorted_events", "[", ":", ",", "-", "1", "]", "==", "1", "\n", "positive_events", "=", "sorted_events", "[", "mask_positive_events", ",", ":", "3", "]", ".", "round", "(", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "negative_events", "=", "sorted_events", "[", "np", ".", "logical_not", "(", "mask_positive_events", ")", ",", ":", "3", "]", ".", "round", "(", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "np_image", "[", "positive_events", "[", ":", ",", "1", "]", ",", "positive_events", "[", ":", ",", "0", "]", ",", "1", "]", "=", "temporal_color", "[", "mask_positive_events", "]", "\n", "np_image", "[", "negative_events", "[", ":", ",", "1", "]", ",", "negative_events", "[", ":", ",", "0", "]", ",", "0", "]", "=", "temporal_color", "[", "np", ".", "logical_not", "(", "mask_positive_events", ")", "]", "\n", "\n", "if", "path_name", "is", "None", ":", "\n", "        ", "return", "np_image", "\n", "", "else", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "imshow", "(", "np_image", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "fig", ".", "savefig", "(", "path_name", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeLocations": [[37, 65], ["numpy.zeros", "[].copy", "numpy.zeros", "numpy.array", "numpy.concatenate", "visualizations.drawBoundingBoxes", "matplotlib.subplots", "ax.imshow", "ax.axis", "fig.savefig", "matplotlib.close", "drawBoundingBoxes.astype", "numpy.zeros", "np.zeros.reshape"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes"], ["", "", "def", "visualizeLocations", "(", "locations", ",", "shape", ",", "path_name", "=", "None", ",", "features", "=", "None", ",", "bounding_box", "=", "None", ",", "class_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"Visualizes changing locations in a histogram. No time dependency\"\"\"", "\n", "np_image", "=", "np", ".", "zeros", "(", "[", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ",", "3", "]", ")", "\n", "\n", "if", "features", ".", "shape", "[", "-", "1", "]", "!=", "2", ":", "\n", "# If features are not 2 dimensional, the event representation is a even queue", "\n", "        ", "feature_copy", "=", "features", ".", "reshape", "(", "[", "features", ".", "shape", "[", "0", "]", ",", "2", ",", "-", "1", "]", ")", "[", ":", ",", "1", ",", ":", "]", ".", "copy", "(", ")", "\n", "features", "=", "np", ".", "zeros", "(", "[", "feature_copy", ".", "shape", "[", "0", "]", ",", "2", "]", ")", "\n", "features", "[", ":", ",", "0", "]", "=", "(", "feature_copy", "==", "-", "1", ")", ".", "sum", "(", "-", "1", ")", "\n", "features", "[", ":", ",", "1", "]", "=", "(", "feature_copy", "==", "1", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "", "if", "features", "is", "None", ":", "\n", "        ", "np_image", "[", "locations", "[", ":", ",", "0", "]", ",", "locations", "[", ":", ",", "1", "]", ",", ":", "]", "=", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "np_image", "[", "locations", "[", ":", ",", "0", "]", ",", "locations", "[", ":", ",", "1", "]", ",", ":", "]", "=", "np", ".", "concatenate", "(", "(", "features", ",", "np", ".", "zeros", "(", "[", "features", ".", "shape", "[", "0", "]", ",", "1", "]", ")", ")", ",", "\n", "axis", "=", "-", "1", ")", "\n", "\n", "", "if", "bounding_box", "is", "not", "None", ":", "\n", "        ", "np_image", "=", "drawBoundingBoxes", "(", "np_image", ",", "bounding_box", ",", "class_name", ")", "\n", "\n", "", "if", "path_name", "is", "None", ":", "\n", "        ", "return", "np_image", "\n", "", "else", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "imshow", "(", "np_image", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "fig", ".", "savefig", "(", "path_name", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeHistogram": [[67, 92], ["numpy.zeros", "np_image.clip.clip", "histogram[].copy", "numpy.zeros", "numpy.abs", "matplotlib.subplots", "ax.imshow", "ax.axis", "fig.savefig", "matplotlib.close", "numpy.array", "numpy.array", "np_image.clip.astype"], "function", ["None"], ["", "", "def", "visualizeHistogram", "(", "histogram", ",", "path_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"Visualizes the input histogram\"\"\"", "\n", "height", ",", "width", ",", "_", "=", "histogram", ".", "shape", "\n", "np_image", "=", "np", ".", "zeros", "(", "[", "height", ",", "width", ",", "3", "]", ")", "\n", "\n", "if", "histogram", ".", "shape", "[", "-", "1", "]", "!=", "2", ":", "\n", "        ", "height", ",", "width", ",", "nr_channels", "=", "histogram", ".", "shape", "\n", "# If histogram has not 2 channels, the event representation is a event queue. Get polarity", "\n", "polarity_histogram", "=", "histogram", "[", ":", ",", ":", ",", "-", "(", "nr_channels", "//", "2", ")", ":", "]", ".", "copy", "(", ")", "\n", "histogram", "=", "np", ".", "zeros", "(", "[", "height", ",", "width", ",", "2", "]", ")", "\n", "histogram", "[", ":", ",", ":", ",", "0", "]", "=", "np", ".", "abs", "(", "(", "polarity_histogram", "*", "(", "polarity_histogram", "==", "-", "1", ")", ")", ".", "sum", "(", "-", "1", ")", ")", "\n", "histogram", "[", ":", ",", ":", ",", "1", "]", "=", "(", "polarity_histogram", "*", "(", "polarity_histogram", "==", "1", ")", ")", ".", "sum", "(", "-", "1", ")", "\n", "\n", "", "np_image", "+=", "(", "histogram", "[", ":", ",", ":", ",", "1", "]", ")", "[", ":", ",", ":", ",", "None", "]", "*", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "[", "None", ",", "None", ",", ":", "]", "\n", "np_image", "+=", "(", "histogram", "[", ":", ",", ":", ",", "0", "]", ")", "[", ":", ",", ":", ",", "None", "]", "*", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", "[", "None", ",", "None", ",", ":", "]", "\n", "np_image", "=", "np_image", ".", "clip", "(", "0", ",", "1", ")", "\n", "\n", "if", "path_name", "is", "None", ":", "\n", "        ", "return", "np_image", "\n", "", "else", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "ax", ".", "imshow", "(", "np_image", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "ax", ".", "axis", "(", "'off'", ")", "\n", "fig", ".", "savefig", "(", "path_name", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeConfusionMatrix": [[94, 120], ["matplotlib.subplots", "ax.matshow", "ax.plot", "ax.set_xlabel", "ax.set_ylabel", "fig.tight_layout", "fig.canvas.draw", "numpy.fromstring", "data.reshape.reshape", "matplotlib.close", "fig.savefig", "matplotlib.close", "fig.canvas.tostring_rgb", "fig.canvas.get_width_height"], "function", ["None"], ["", "", "def", "visualizeConfusionMatrix", "(", "confusion_matrix", ",", "path_name", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Visualizes the confustion matrix using matplotlib.\n\n    :param confusion_matrix: NxN numpy array\n    :param path_name: if no path name is given, just an image is returned\n    \"\"\"", "\n", "nr_classes", "=", "confusion_matrix", ".", "shape", "[", "0", "]", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "figsize", "=", "(", "16", ",", "16", ")", ")", "\n", "ax", ".", "matshow", "(", "confusion_matrix", ")", "\n", "ax", ".", "plot", "(", "[", "-", "0.5", ",", "nr_classes", "-", "0.5", "]", ",", "[", "-", "0.5", ",", "nr_classes", "-", "0.5", "]", ",", "'-'", ",", "color", "=", "'grey'", ")", "\n", "ax", ".", "set_xlabel", "(", "'Labels'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Predicted'", ")", "\n", "\n", "if", "path_name", "is", "None", ":", "\n", "        ", "fig", ".", "tight_layout", "(", "pad", "=", "0", ")", "\n", "fig", ".", "canvas", ".", "draw", "(", ")", "\n", "data", "=", "np", ".", "fromstring", "(", "fig", ".", "canvas", ".", "tostring_rgb", "(", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "sep", "=", "''", ")", "\n", "data", "=", "data", ".", "reshape", "(", "fig", ".", "canvas", ".", "get_width_height", "(", ")", "[", ":", ":", "-", "1", "]", "+", "(", "3", ",", ")", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n", "return", "data", "\n", "\n", "", "else", ":", "\n", "        ", "fig", ".", "savefig", "(", "path_name", ")", "\n", "plt", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes": [[122, 136], ["enumerate", "cv2.resize", "visualizations.drawBoundingBox", "numpy.array", "tuple", "bounding_box.sum", "bounding_boxes.astype", "new_dim.astype", "numpy.np.float"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBox"], ["", "", "def", "drawBoundingBoxes", "(", "np_image", ",", "bounding_boxes", ",", "class_name", ",", "ground_truth", "=", "True", ",", "rescale_image", "=", "True", ")", ":", "\n", "    ", "\"\"\"Draws the bounding boxes in the image\"\"\"", "\n", "resize_scale", "=", "1.5", "\n", "bounding_boxes", "[", ":", ",", ":", "4", "]", "=", "(", "bounding_boxes", ".", "astype", "(", "np", ".", "float64", ")", "[", ":", ",", ":", "4", "]", "*", "resize_scale", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "if", "rescale_image", ":", "\n", "        ", "new_dim", "=", "np", ".", "array", "(", "np_image", ".", "shape", "[", ":", "2", "]", ",", "dtype", "=", "np", ".", "float", ")", "*", "resize_scale", "\n", "np_image", "=", "cv2", ".", "resize", "(", "np_image", ",", "tuple", "(", "new_dim", ".", "astype", "(", "int", ")", "[", ":", ":", "-", "1", "]", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "\n", "", "for", "i", ",", "bounding_box", "in", "enumerate", "(", "bounding_boxes", ")", ":", "\n", "        ", "if", "bounding_box", ".", "sum", "(", ")", "==", "0", ":", "\n", "            ", "break", "\n", "", "np_image", "=", "drawBoundingBox", "(", "np_image", ",", "bounding_box", ",", "class_name", "[", "i", "]", ",", "ground_truth", ")", "\n", "\n", "", "return", "np_image", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBox": [[138, 173], ["numpy.array", "numpy.array", "tuple", "cv2.rectangle", "cv2.putText", "cv2.getTextSize", "int", "int", "int", "numpy.array"], "function", ["None"], ["", "def", "drawBoundingBox", "(", "np_image", ",", "bounding_box", ",", "class_name", "=", "None", ",", "ground_truth", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Draws a bounding box in the image.\n\n    :param np_image: [H, W, C]\n    :param bounding_box: [u, v, width, height]. (u, v) is bottom top point\n    :param class_name: string\n    \"\"\"", "\n", "if", "ground_truth", ":", "\n", "        ", "bbox_color", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "bbox_color", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "1", "]", ")", "\n", "", "width", ",", "height", "=", "bounding_box", "[", "2", ":", "4", "]", "\n", "np_image", "[", "bounding_box", "[", "1", "]", ",", "bounding_box", "[", "0", "]", ":", "(", "bounding_box", "[", "0", "]", "+", "width", ")", "]", "=", "bbox_color", "\n", "np_image", "[", "bounding_box", "[", "1", "]", ":", "(", "bounding_box", "[", "1", "]", "+", "height", ")", ",", "(", "bounding_box", "[", "0", "]", "+", "width", ")", "]", "=", "bbox_color", "\n", "np_image", "[", "(", "bounding_box", "[", "1", "]", "+", "height", ")", ",", "bounding_box", "[", "0", "]", ":", "(", "bounding_box", "[", "0", "]", "+", "width", ")", "]", "=", "bbox_color", "\n", "np_image", "[", "bounding_box", "[", "1", "]", ":", "(", "bounding_box", "[", "1", "]", "+", "height", ")", ",", "bounding_box", "[", "0", "]", "]", "=", "bbox_color", "\n", "\n", "if", "class_name", "is", "not", "None", ":", "\n", "        ", "font", "=", "cv2", ".", "FONT_HERSHEY_SIMPLEX", "\n", "font_color", "=", "(", "0", ",", "0", ",", "0", ")", "\n", "font_scale", "=", "0.5", "\n", "thickness", "=", "1", "\n", "bottom_left", "=", "tuple", "(", "(", "(", "bounding_box", "[", ":", "2", "]", "+", "np", ".", "array", "(", "[", "+", "1", ",", "height", "-", "2", "]", ")", ")", ")", ".", "astype", "(", "int", ")", ")", "\n", "\n", "# Draw Box", "\n", "(", "text_width", ",", "text_height", ")", "=", "cv2", ".", "getTextSize", "(", "class_name", ",", "font", ",", "fontScale", "=", "font_scale", ",", "thickness", "=", "thickness", ")", "[", "0", "]", "\n", "box_coords", "=", "(", "(", "bottom_left", "[", "0", "]", ",", "bottom_left", "[", "1", "]", "+", "2", ")", ",", "\n", "(", "bottom_left", "[", "0", "]", "+", "text_width", "+", "2", ",", "bottom_left", "[", "1", "]", "-", "text_height", "-", "2", "+", "2", ")", ")", "\n", "color_format", "=", "(", "int", "(", "bbox_color", "[", "0", "]", ")", ",", "int", "(", "bbox_color", "[", "1", "]", ")", ",", "int", "(", "bbox_color", "[", "2", "]", ")", ")", "\n", "cv2", ".", "rectangle", "(", "np_image", ",", "box_coords", "[", "0", "]", ",", "box_coords", "[", "1", "]", ",", "color_format", ",", "cv2", ".", "FILLED", ")", "\n", "\n", "cv2", ".", "putText", "(", "np_image", ",", "class_name", ",", "bottom_left", ",", "font", ",", "font_scale", ",", "font_color", ",", "thickness", ",", "cv2", ".", "LINE_AA", ")", "\n", "\n", "", "return", "np_image", "\n", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.__init__": [[63, 106], ["os.path.join", "len", "enumerate", "len", "os.listdir", "list", "random.seed", "random.shuffle", "zip", "os.path.join", "len", "zip", "os.listdir", "os.path.join"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "object_classes", ",", "height", ",", "width", ",", "nr_events_window", "=", "-", "1", ",", "augmentation", "=", "False", ",", "mode", "=", "'training'", ",", "\n", "event_representation", "=", "'histogram'", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Creates an iterator over the N_Caltech101 dataset.\n\n        :param root: path to dataset root\n        :param object_classes: list of string containing objects or 'all' for all classes\n        :param height: height of dataset image\n        :param width: width of dataset image\n        :param nr_events_window: number of events in a sliding window histogram, -1 corresponds to all events\n        :param augmentation: flip, shift and random window start for training\n        :param mode: 'training', 'testing' or 'validation'\n        :param event_representation: 'histogram' or 'event_queue'\n        \"\"\"", "\n", "root", "=", "os", ".", "path", ".", "join", "(", "root", ",", "mode", ")", "\n", "\n", "if", "object_classes", "==", "'all'", ":", "\n", "            ", "self", ".", "object_classes", "=", "listdir", "(", "root", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "object_classes", "=", "object_classes", "\n", "\n", "", "self", ".", "width", "=", "width", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "augmentation", "=", "augmentation", "\n", "self", ".", "nr_events_window", "=", "nr_events_window", "\n", "self", ".", "nr_classes", "=", "len", "(", "self", ".", "object_classes", ")", "\n", "self", ".", "event_representation", "=", "event_representation", "\n", "\n", "self", ".", "files", "=", "[", "]", "\n", "self", ".", "labels", "=", "[", "]", "\n", "\n", "for", "i", ",", "object_class", "in", "enumerate", "(", "self", ".", "object_classes", ")", ":", "\n", "            ", "new_files", "=", "[", "join", "(", "root", ",", "object_class", ",", "f", ")", "for", "f", "in", "listdir", "(", "join", "(", "root", ",", "object_class", ")", ")", "]", "\n", "self", ".", "files", "+=", "new_files", "\n", "self", ".", "labels", "+=", "[", "i", "]", "*", "len", "(", "new_files", ")", "\n", "\n", "", "self", ".", "nr_samples", "=", "len", "(", "self", ".", "labels", ")", "\n", "\n", "if", "shuffle", ":", "\n", "            ", "zipped_lists", "=", "list", "(", "zip", "(", "self", ".", "files", ",", "self", ".", "labels", ")", ")", "\n", "random", ".", "seed", "(", "7", ")", "\n", "random", ".", "shuffle", "(", "zipped_lists", ")", "\n", "self", ".", "files", ",", "self", ".", "labels", "=", "zip", "(", "*", "zipped_lists", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.__len__": [[107, 109], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.__getitem__": [[110, 137], ["numpy.load().astype", "dataset.NCaltech101.generate_input_representation", "dataset.random_shift_events", "dataset.random_flip_events_along_x", "random.randrange", "min", "numpy.load", "max"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_input_representation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_shift_events", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_flip_events_along_x"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        returns events and label, loading events from aedat\n        :param idx:\n        :return: x,y,t,p,  label\n        \"\"\"", "\n", "label", "=", "self", ".", "labels", "[", "idx", "]", "\n", "filename", "=", "self", ".", "files", "[", "idx", "]", "\n", "events", "=", "np", ".", "load", "(", "filename", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "nr_events", "=", "events", ".", "shape", "[", "0", "]", "\n", "\n", "window_start", "=", "0", "\n", "window_end", "=", "nr_events", "\n", "if", "self", ".", "augmentation", ":", "\n", "            ", "events", "=", "random_shift_events", "(", "events", ")", "\n", "events", "=", "random_flip_events_along_x", "(", "events", ")", "\n", "window_start", "=", "random", ".", "randrange", "(", "0", ",", "max", "(", "1", ",", "nr_events", "-", "self", ".", "nr_events_window", ")", ")", "\n", "\n", "", "if", "self", ".", "nr_events_window", "!=", "-", "1", ":", "\n", "# Catch case if number of events in batch is lower than number of events in window.", "\n", "            ", "window_end", "=", "min", "(", "nr_events", ",", "window_start", "+", "self", ".", "nr_events_window", ")", "\n", "\n", "", "events", "=", "events", "[", "window_start", ":", "window_end", ",", ":", "]", "\n", "\n", "histogram", "=", "self", ".", "generate_input_representation", "(", "events", ",", "(", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "\n", "return", "events", ",", "label", ",", "histogram", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_input_representation": [[138, 147], ["dataset.NCaltech101.generate_event_histogram", "dataset.NCaltech101.generate_event_queue"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_event_histogram", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_event_queue"], ["", "def", "generate_input_representation", "(", "self", ",", "events", ",", "shape", ")", ":", "\n", "        ", "\"\"\"\n        Events: N x 4, where cols are x, y, t, polarity, and polarity is in {0,1}. x and y correspond to image\n        coordinates u and v.\n        \"\"\"", "\n", "if", "self", ".", "event_representation", "==", "'histogram'", ":", "\n", "            ", "return", "self", ".", "generate_event_histogram", "(", "events", ",", "shape", ")", "\n", "", "elif", "self", ".", "event_representation", "==", "'event_queue'", ":", "\n", "            ", "return", "self", ".", "generate_event_queue", "(", "events", ",", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_event_histogram": [[148, 168], ["x.astype.astype.astype", "y.astype.astype.astype", "numpy.zeros", "numpy.zeros", "numpy.add.at", "numpy.add.at", "numpy.stack().reshape", "numpy.stack"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "generate_event_histogram", "(", "events", ",", "shape", ")", ":", "\n", "        ", "\"\"\"\n        Events: N x 4, where cols are x, y, t, polarity, and polarity is in {0,1}. x and y correspond to image\n        coordinates u and v.\n        \"\"\"", "\n", "H", ",", "W", "=", "shape", "\n", "x", ",", "y", ",", "t", ",", "p", "=", "events", ".", "T", "\n", "x", "=", "x", ".", "astype", "(", "np", ".", "int", ")", "\n", "y", "=", "y", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "img_pos", "=", "np", ".", "zeros", "(", "(", "H", "*", "W", ",", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "img_neg", "=", "np", ".", "zeros", "(", "(", "H", "*", "W", ",", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "np", ".", "add", ".", "at", "(", "img_pos", ",", "x", "[", "p", "==", "1", "]", "+", "W", "*", "y", "[", "p", "==", "1", "]", ",", "1", ")", "\n", "np", ".", "add", ".", "at", "(", "img_neg", ",", "x", "[", "p", "==", "-", "1", "]", "+", "W", "*", "y", "[", "p", "==", "-", "1", "]", ",", "1", ")", "\n", "\n", "histogram", "=", "np", ".", "stack", "(", "[", "img_neg", ",", "img_pos", "]", ",", "-", "1", ")", ".", "reshape", "(", "(", "H", ",", "W", ",", "2", ")", ")", "\n", "\n", "return", "histogram", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_event_queue": [[169, 192], ["events.astype.astype.astype", "event_representations.event_queue_tensor().astype", "numpy.amax", "event_representations.event_queue_tensor().astype.reshape().transpose", "numpy.zeros", "event_representations.event_queue_tensor", "event_representations.event_queue_tensor().astype.reshape"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "generate_event_queue", "(", "events", ",", "shape", ",", "K", "=", "15", ")", ":", "\n", "        ", "\"\"\"\n        Events: N x 4, where cols are x, y, t, polarity, and polarity is in {0,1}. x and y correspond to image\n        coordinates u and v.\n        \"\"\"", "\n", "H", ",", "W", "=", "shape", "\n", "events", "=", "events", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "if", "events", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "np", ".", "zeros", "(", "[", "H", ",", "W", ",", "2", "*", "K", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# [2, K, height, width],  [0, ...] time, [:, 0, :, :] newest events", "\n", "", "four_d_tensor", "=", "er", ".", "event_queue_tensor", "(", "events", ",", "K", ",", "H", ",", "W", ",", "-", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Normalize", "\n", "four_d_tensor", "[", "0", ",", "...", "]", "=", "four_d_tensor", "[", "0", ",", "0", ",", "None", ",", ":", ",", ":", "]", "-", "four_d_tensor", "[", "0", ",", ":", ",", ":", ",", ":", "]", "\n", "max_timestep", "=", "np", ".", "amax", "(", "four_d_tensor", "[", "0", ",", ":", ",", ":", ",", ":", "]", ",", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "\n", "# four_d_tensor[0, ...] = np.divide(four_d_tensor[0, ...], max_timestep, where=max_timestep.astype(np.bool))", "\n", "four_d_tensor", "[", "0", ",", "...", "]", "=", "four_d_tensor", "[", "0", ",", "...", "]", "/", "(", "max_timestep", "+", "(", "max_timestep", "==", "0", ")", ".", "astype", "(", "np", ".", "float", ")", ")", "\n", "\n", "return", "four_d_tensor", ".", "reshape", "(", "[", "2", "*", "K", ",", "H", ",", "W", "]", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.__init__": [[195, 235], ["dataset.NCaltech101_ObjectDetection.object_classes.sort", "len", "dataset.NCaltech101_ObjectDetection.createDataset", "len", "os.listdir", "list", "random.shuffle", "zip", "os.path.join", "zip"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.createDataset"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "object_classes", ",", "height", ",", "width", ",", "nr_events_window", "=", "-", "1", ",", "augmentation", "=", "False", ",", "mode", "=", "'training'", ",", "\n", "event_representation", "=", "'histogram'", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Creates an iterator over the N_Caltech101 object recognition dataset.\n\n        :param root: path to dataset root\n        :param object_classes: list of string containing objects or 'all' for all classes\n        :param height: height of dataset image\n        :param width: width of dataset image\n        :param nr_events_window: number of events in a sliding window histogram, -1 corresponds to all events\n        :param augmentation: flip, shift and random window start for training\n        :param mode: 'training', 'testing' or 'validation'\n        :param event_representation: 'histogram' or 'event_queue'\n        \"\"\"", "\n", "if", "object_classes", "==", "'all'", ":", "\n", "            ", "self", ".", "object_classes", "=", "listdir", "(", "os", ".", "path", ".", "join", "(", "root", ",", "'Caltech101'", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "object_classes", "=", "object_classes", "\n", "", "self", ".", "object_classes", ".", "sort", "(", ")", "\n", "\n", "self", ".", "root", "=", "root", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "augmentation", "=", "augmentation", "\n", "self", ".", "nr_events_window", "=", "nr_events_window", "\n", "self", ".", "nr_classes", "=", "len", "(", "self", ".", "object_classes", ")", "\n", "self", ".", "event_representation", "=", "event_representation", "\n", "\n", "self", ".", "files", "=", "[", "]", "\n", "self", ".", "class_labels", "=", "[", "]", "\n", "self", ".", "bounding_box_list", "=", "[", "]", "\n", "\n", "self", ".", "createDataset", "(", ")", "\n", "self", ".", "nr_samples", "=", "len", "(", "self", ".", "files", ")", "\n", "\n", "if", "shuffle", ":", "\n", "            ", "zipped_lists", "=", "list", "(", "zip", "(", "self", ".", "files", ",", "self", ".", "class_labels", ",", "self", ".", "bounding_box_list", ")", ")", "\n", "random", ".", "shuffle", "(", "zipped_lists", ")", "\n", "self", ".", "files", ",", "self", ".", "class_labels", ",", "self", ".", "bounding_box_list", "=", "zip", "(", "*", "zipped_lists", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.createDataset": [[236, 269], ["numpy.random.RandomState", "enumerate", "os.path.join", "os.listdir", "len", "numpy.random.RandomState.permutation", "int", "int", "dataset.NCaltech101_ObjectDetection.files.append", "dataset.NCaltech101_ObjectDetection.readBoundingBox", "dataset.NCaltech101_ObjectDetection.class_labels.append", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.readBoundingBox"], ["", "", "def", "createDataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"Does a stratified training, testing, validation split\"\"\"", "\n", "np_random_state", "=", "np", ".", "random", ".", "RandomState", "(", "42", ")", "\n", "training_ratio", "=", "0.7", "\n", "testing_ratio", "=", "0.2", "\n", "# Validation Ratio will be 0.1", "\n", "\n", "for", "i_class", ",", "object_class", "in", "enumerate", "(", "self", ".", "object_classes", ")", ":", "\n", "            ", "if", "object_class", "==", "'BACKGROUND_Google'", ":", "\n", "                ", "continue", "\n", "", "dir_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "'Caltech101'", ",", "object_class", ")", "\n", "image_files", "=", "listdir", "(", "dir_path", ")", "\n", "nr_samples", "=", "len", "(", "image_files", ")", "\n", "\n", "random_permutation", "=", "np_random_state", ".", "permutation", "(", "nr_samples", ")", "\n", "nr_samples_train", "=", "int", "(", "nr_samples", "*", "training_ratio", ")", "\n", "nr_samples_test", "=", "int", "(", "nr_samples", "*", "testing_ratio", ")", "\n", "\n", "if", "self", ".", "mode", "==", "'training'", ":", "\n", "                ", "start_idx", "=", "0", "\n", "end_idx", "=", "nr_samples_train", "\n", "", "elif", "self", ".", "mode", "==", "'testing'", ":", "\n", "                ", "start_idx", "=", "nr_samples_train", "\n", "end_idx", "=", "nr_samples_train", "+", "nr_samples_test", "\n", "", "elif", "self", ".", "mode", "==", "'validation'", ":", "\n", "                ", "start_idx", "=", "nr_samples_train", "+", "nr_samples_test", "\n", "end_idx", "=", "nr_samples", "\n", "\n", "", "for", "idx", "in", "random_permutation", "[", "start_idx", ":", "end_idx", "]", ":", "\n", "                ", "self", ".", "files", ".", "append", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "'Caltech101'", ",", "object_class", ",", "image_files", "[", "idx", "]", ")", ")", "\n", "annotation_file", "=", "'annotation'", "+", "image_files", "[", "idx", "]", "[", "5", ":", "]", "\n", "self", ".", "readBoundingBox", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "'Caltech101_annotations'", ",", "object_class", ",", "annotation_file", ")", ")", "\n", "self", ".", "class_labels", ".", "append", "(", "i_class", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.readBoundingBox": [[270, 275], ["open", "numpy.fromfile", "open.close", "dataset.NCaltech101_ObjectDetection.bounding_box_list.append"], "methods", ["None"], ["", "", "", "def", "readBoundingBox", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "f", "=", "open", "(", "file_path", ")", "\n", "annotations", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "np", ".", "int16", ")", "\n", "f", ".", "close", "(", ")", "\n", "self", ".", "bounding_box_list", ".", "append", "(", "annotations", "[", "2", ":", "10", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.loadEventsFile": [[276, 291], ["open", "numpy.fromfile", "open.close", "numpy.uint32", "all_p.astype.astype.astype", "numpy.column_stack"], "methods", ["None"], ["", "def", "loadEventsFile", "(", "self", ",", "file_name", ")", ":", "\n", "        ", "f", "=", "open", "(", "file_name", ",", "'rb'", ")", "\n", "raw_data", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "f", ".", "close", "(", ")", "\n", "raw_data", "=", "np", ".", "uint32", "(", "raw_data", ")", "\n", "\n", "all_y", "=", "raw_data", "[", "1", ":", ":", "5", "]", "\n", "all_x", "=", "raw_data", "[", "0", ":", ":", "5", "]", "\n", "all_p", "=", "(", "raw_data", "[", "2", ":", ":", "5", "]", "&", "128", ")", ">>", "7", "# bit 7", "\n", "all_ts", "=", "(", "(", "raw_data", "[", "2", ":", ":", "5", "]", "&", "127", ")", "<<", "16", ")", "|", "(", "raw_data", "[", "3", ":", ":", "5", "]", "<<", "8", ")", "|", "(", "raw_data", "[", "4", ":", ":", "5", "]", ")", "\n", "\n", "all_p", "=", "all_p", ".", "astype", "(", "np", ".", "float64", ")", "\n", "all_p", "[", "all_p", "==", "0", "]", "=", "-", "1", "\n", "\n", "return", "np", ".", "column_stack", "(", "(", "all_x", ",", "all_y", ",", "all_ts", ",", "all_p", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.__len__": [[292, 294], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.__getitem__": [[295, 334], ["dataset.NCaltech101_ObjectDetection.reshape", "numpy.maximum", "dataset.NCaltech101_ObjectDetection.loadEventsFile().astype", "dataset.NCaltech101_ObjectDetection.moveBoundingBox", "numpy.concatenate", "dataset.NCaltech101_ObjectDetection.generate_input_representation", "numpy.zeros_like", "random.randrange", "min", "dataset.random_flip_events_along_x", "dataset.random_shift_events", "dataset.NCaltech101_ObjectDetection.loadEventsFile", "max", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.moveBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_input_representation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_flip_events_along_x", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_shift_events", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.loadEventsFile"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        returns events and label, loading events from aedat\n        :param idx:\n        :return: x,y,t,p,  label\n        \"\"\"", "\n", "class_label", "=", "self", ".", "class_labels", "[", "idx", "]", "\n", "bounding_box", "=", "self", ".", "bounding_box_list", "[", "idx", "]", "\n", "bounding_box", "=", "bounding_box", ".", "reshape", "(", "[", "4", ",", "2", "]", ")", "\n", "# Set negative corners to zero", "\n", "bounding_box", "=", "np", ".", "maximum", "(", "bounding_box", ",", "np", ".", "zeros_like", "(", "bounding_box", ")", ")", "\n", "filename", "=", "self", ".", "files", "[", "idx", "]", "\n", "events", "=", "self", ".", "loadEventsFile", "(", "filename", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "nr_events", "=", "events", ".", "shape", "[", "0", "]", "\n", "\n", "window_start", "=", "0", "\n", "window_end", "=", "nr_events", "\n", "if", "self", ".", "augmentation", ":", "\n", "            ", "window_start", "=", "random", ".", "randrange", "(", "0", ",", "max", "(", "1", ",", "nr_events", "-", "self", ".", "nr_events_window", ")", ")", "\n", "", "if", "self", ".", "nr_events_window", "!=", "-", "1", ":", "\n", "# Catch case if number of events in batch is lower than number of events in window.", "\n", "            ", "window_end", "=", "min", "(", "nr_events", ",", "window_start", "+", "self", ".", "nr_events_window", ")", "\n", "", "events", "=", "events", "[", "window_start", ":", "window_end", ",", ":", "]", "\n", "\n", "bounding_box", "=", "self", ".", "moveBoundingBox", "(", "bounding_box", ",", "events", "[", "-", "1", ",", "2", "]", ")", "\n", "\n", "if", "self", ".", "augmentation", ":", "\n", "            ", "events", ",", "bounding_box", "=", "random_flip_events_along_x", "(", "events", ",", "resolution", "=", "(", "self", ".", "height", ",", "self", ".", "width", ")", ",", "\n", "bounding_box", "=", "bounding_box", ")", "\n", "events", ",", "bounding_box", "=", "random_shift_events", "(", "events", ",", "resolution", "=", "(", "self", ".", "height", ",", "self", ".", "width", ")", ",", "\n", "bounding_box", "=", "bounding_box", ")", "\n", "\n", "# Required Format: ['x', 'y', 'w', 'h', 'class_id'].  (x, y) is top left point\\", "\n", "", "new_format_bbox", "=", "np", ".", "concatenate", "(", "[", "bounding_box", "[", "0", ",", ":", "]", ",", "bounding_box", "[", "2", ",", ":", "]", "-", "bounding_box", "[", "0", ",", ":", "]", ",", "\n", "np", ".", "array", "(", "[", "class_label", "]", ")", "]", ")", "\n", "\n", "histogram", "=", "self", ".", "generate_input_representation", "(", "events", ",", "(", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "\n", "return", "events", ",", "new_format_bbox", "[", "np", ".", "newaxis", ",", ":", "]", ",", "histogram", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101_ObjectDetection.moveBoundingBox": [[335, 359], ["float", "numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.zeros_like", "numpy.ones_like", "numpy.ones_like"], "methods", ["None"], ["", "def", "moveBoundingBox", "(", "self", ",", "bounding_box", ",", "current_time", ")", ":", "\n", "        ", "\"\"\"\n        Move bounding box according the motion of the event camera. Code was adopted from the matlab code provided by\n        the dataset authors.\n        \"\"\"", "\n", "current_time", "=", "float", "(", "current_time", ")", "\n", "if", "current_time", "<", "100e3", ":", "\n", "            ", "bounding_box", "[", ":", ",", "0", "]", "=", "bounding_box", "[", ":", ",", "0", "]", "+", "3.5", "*", "current_time", "/", "100e3", "\n", "bounding_box", "[", ":", ",", "1", "]", "=", "bounding_box", "[", ":", ",", "1", "]", "+", "7", "*", "current_time", "/", "100e3", "\n", "", "elif", "current_time", "<", "200e3", ":", "\n", "            ", "bounding_box", "[", ":", ",", "0", "]", "=", "bounding_box", "[", ":", ",", "0", "]", "+", "3.5", "+", "3.5", "*", "(", "current_time", "-", "100e3", ")", "/", "100e3", "\n", "bounding_box", "[", ":", ",", "1", "]", "=", "bounding_box", "[", ":", ",", "1", "]", "+", "7", "-", "7", "*", "(", "current_time", "-", "100e3", ")", "/", "100e3", "\n", "", "elif", "current_time", "<", "300e3", ":", "\n", "            ", "bounding_box", "[", ":", ",", "0", "]", "=", "bounding_box", "[", ":", ",", "0", "]", "+", "7", "-", "7", "*", "(", "current_time", "-", "200e3", ")", "/", "100e3", "\n", "bounding_box", "[", ":", ",", "1", "]", "=", "bounding_box", "[", ":", ",", "1", "]", "\n", "", "else", ":", "\n", "            ", "bounding_box", "[", ":", ",", "0", "]", "=", "bounding_box", "[", ":", ",", "0", "]", "\n", "bounding_box", "[", ":", ",", "1", "]", "=", "bounding_box", "[", ":", ",", "1", "]", "\n", "\n", "", "bounding_box", "=", "np", ".", "maximum", "(", "bounding_box", ",", "np", ".", "zeros_like", "(", "bounding_box", ")", ")", "\n", "bounding_box", "[", ":", ",", "0", "]", "=", "np", ".", "minimum", "(", "bounding_box", "[", ":", ",", "0", "]", ",", "np", ".", "ones_like", "(", "bounding_box", "[", ":", ",", "0", "]", ")", "*", "self", ".", "width", "-", "1", ")", "\n", "bounding_box", "[", ":", ",", "1", "]", "=", "np", ".", "minimum", "(", "bounding_box", "[", ":", ",", "1", "]", ",", "np", ".", "ones_like", "(", "bounding_box", "[", ":", ",", "1", "]", ")", "*", "self", ".", "height", "-", "1", ")", "\n", "\n", "return", "bounding_box", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.__init__": [[362, 418], ["os.path.join", "os.listdir", "dataset.Prophesee.createAllBBoxDataset", "len", "os.path.join", "os.path.join", "len", "list", "random.seed", "random.shuffle", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.createAllBBoxDataset"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "object_classes", ",", "height", ",", "width", ",", "nr_events_window", "=", "-", "1", ",", "augmentation", "=", "False", ",", "mode", "=", "'training'", ",", "\n", "event_representation", "=", "'histogram'", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Creates an iterator over the Prophesee object recognition dataset.\n\n        :param root: path to dataset root\n        :param object_classes: list of string containing objects or 'all' for all classes\n        :param height: height of dataset image\n        :param width: width of dataset image\n        :param nr_events_window: number of events in a sliding window histogram, -1 corresponds to all events\n        :param augmentation: flip, shift and random window start for training\n        :param mode: 'training', 'testing' or 'validation'\n        :param event_representation: 'histogram' or 'event_queue'\n        \"\"\"", "\n", "if", "mode", "==", "'training'", ":", "\n", "            ", "mode", "=", "'train'", "\n", "", "elif", "mode", "==", "'validation'", ":", "\n", "            ", "mode", "=", "'val'", "\n", "", "elif", "mode", "==", "'testing'", ":", "\n", "            ", "mode", "=", "'test'", "\n", "\n", "", "file_dir", "=", "os", ".", "path", ".", "join", "(", "'detection_dataset_duration_60s_ratio_1.0'", ",", "mode", ")", "\n", "self", ".", "files", "=", "listdir", "(", "os", ".", "path", ".", "join", "(", "root", ",", "file_dir", ")", ")", "\n", "# Remove duplicates (.npy and .dat)", "\n", "self", ".", "files", "=", "[", "os", ".", "path", ".", "join", "(", "file_dir", ",", "time_seq_name", "[", ":", "-", "9", "]", ")", "for", "time_seq_name", "in", "self", ".", "files", "\n", "if", "time_seq_name", "[", "-", "3", ":", "]", "==", "'npy'", "]", "\n", "\n", "self", ".", "root", "=", "root", "\n", "self", ".", "mode", "=", "mode", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "augmentation", "=", "augmentation", "\n", "self", ".", "event_representation", "=", "event_representation", "\n", "if", "nr_events_window", "==", "-", "1", ":", "\n", "            ", "self", ".", "nr_events_window", "=", "250000", "\n", "", "else", ":", "\n", "            ", "self", ".", "nr_events_window", "=", "nr_events_window", "\n", "\n", "", "self", ".", "max_nr_bbox", "=", "15", "\n", "\n", "if", "object_classes", "==", "'all'", ":", "\n", "            ", "self", ".", "nr_classes", "=", "2", "\n", "self", ".", "object_classes", "=", "[", "'Car'", ",", "\"Pedestrian\"", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "nr_classes", "=", "len", "(", "object_classes", ")", "\n", "self", ".", "object_classes", "=", "object_classes", "\n", "\n", "", "self", ".", "sequence_start", "=", "[", "]", "\n", "self", ".", "createAllBBoxDataset", "(", ")", "\n", "self", ".", "nr_samples", "=", "len", "(", "self", ".", "files", ")", "\n", "\n", "if", "shuffle", ":", "\n", "            ", "zipped_lists", "=", "list", "(", "zip", "(", "self", ".", "files", ",", "self", ".", "sequence_start", ")", ")", "\n", "random", ".", "seed", "(", "7", ")", "\n", "random", ".", "shuffle", "(", "zipped_lists", ")", "\n", "self", ".", "files", ",", "self", ".", "sequence_start", "=", "zip", "(", "*", "zipped_lists", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.createAllBBoxDataset": [[419, 447], ["print", "tqdm.tqdm", "enumerate", "tqdm.tqdm.close", "os.path.join", "os.path.join", "open", "dataloader.prophesee.npy_events_tools.parse_header", "numpy.fromfile", "open.close", "numpy.unique", "tqdm.tqdm.update", "len", "dataset.Prophesee.searchEventSequence", "dataset.Prophesee.sequence_start.append", "range", "len"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.parse_header", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.searchEventSequence"], ["", "", "def", "createAllBBoxDataset", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Iterates over the files and stores for each unique bounding box timestep the file name and the index of the\n         unique indices file.\n        \"\"\"", "\n", "file_name_bbox_id", "=", "[", "]", "\n", "print", "(", "'Building the Dataset'", ")", "\n", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "len", "(", "self", ".", "files", ")", ",", "unit", "=", "'File'", ",", "unit_scale", "=", "True", ")", "\n", "\n", "for", "i_file", ",", "file_name", "in", "enumerate", "(", "self", ".", "files", ")", ":", "\n", "            ", "bbox_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "file_name", "+", "'_bbox.npy'", ")", "\n", "event_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "file_name", "+", "'_td.dat'", ")", "\n", "f_bbox", "=", "open", "(", "bbox_file", ",", "\"rb\"", ")", "\n", "start", ",", "v_type", ",", "ev_size", ",", "size", "=", "npy_events_tools", ".", "parse_header", "(", "f_bbox", ")", "\n", "dat_bbox", "=", "np", ".", "fromfile", "(", "f_bbox", ",", "dtype", "=", "v_type", ",", "count", "=", "-", "1", ")", "\n", "f_bbox", ".", "close", "(", ")", "\n", "\n", "unique_ts", ",", "unique_indices", "=", "np", ".", "unique", "(", "dat_bbox", "[", "'ts'", "]", ",", "return_index", "=", "True", ")", "\n", "\n", "for", "unique_time", "in", "unique_ts", ":", "\n", "                ", "sequence_start", "=", "self", ".", "searchEventSequence", "(", "event_file", ",", "unique_time", ",", "nr_window_events", "=", "250000", ")", "\n", "self", ".", "sequence_start", ".", "append", "(", "sequence_start", ")", "\n", "\n", "", "file_name_bbox_id", "+=", "[", "[", "file_name", ",", "i", "]", "for", "i", "in", "range", "(", "len", "(", "unique_indices", ")", ")", "]", "\n", "pbar", ".", "update", "(", "1", ")", "\n", "\n", "", "pbar", ".", "close", "(", ")", "\n", "self", ".", "files", "=", "file_name_bbox_id", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.__getitem__": [[448, 491], ["os.path.join", "os.path.join", "open", "dataloader.prophesee.npy_events_tools.parse_header", "numpy.fromfile", "open.close", "numpy.unique", "dataset.Prophesee.cropToFrame", "numpy.zeros", "dataset.Prophesee.readEventFile", "dataset.Prophesee.generate_input_representation", "numpy.lib.recfunctions.structured_to_unstructured", "numpy.zeros.astype"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.parse_header", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.cropToFrame", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.readEventFile", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_input_representation"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        returns events and label, loading events from aedat\n        :param idx:\n        :return: x,y,t,p,  label\n        \"\"\"", "\n", "bbox_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "files", "[", "idx", "]", "[", "0", "]", "+", "'_bbox.npy'", ")", "\n", "event_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "files", "[", "idx", "]", "[", "0", "]", "+", "'_td.dat'", ")", "\n", "\n", "# Bounding Box", "\n", "f_bbox", "=", "open", "(", "bbox_file", ",", "\"rb\"", ")", "\n", "# dat_bbox types (v_type):", "\n", "# [('ts', 'uint64'), ('x', 'float32'), ('y', 'float32'), ('w', 'float32'), ('h', 'float32'), (", "\n", "# 'class_id', 'uint8'), ('confidence', 'float32'), ('track_id', 'uint32')]", "\n", "start", ",", "v_type", ",", "ev_size", ",", "size", "=", "npy_events_tools", ".", "parse_header", "(", "f_bbox", ")", "\n", "dat_bbox", "=", "np", ".", "fromfile", "(", "f_bbox", ",", "dtype", "=", "v_type", ",", "count", "=", "-", "1", ")", "\n", "f_bbox", ".", "close", "(", ")", "\n", "\n", "unique_ts", ",", "unique_indices", "=", "np", ".", "unique", "(", "dat_bbox", "[", "'ts'", "]", ",", "return_index", "=", "True", ")", "\n", "nr_unique_ts", "=", "unique_ts", ".", "shape", "[", "0", "]", "\n", "\n", "bbox_time_idx", "=", "self", ".", "files", "[", "idx", "]", "[", "1", "]", "\n", "\n", "# Get bounding boxes at current timestep", "\n", "if", "bbox_time_idx", "==", "(", "nr_unique_ts", "-", "1", ")", ":", "\n", "            ", "end_idx", "=", "dat_bbox", "[", "'ts'", "]", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "end_idx", "=", "unique_indices", "[", "bbox_time_idx", "+", "1", "]", "\n", "\n", "", "bboxes", "=", "dat_bbox", "[", "unique_indices", "[", "bbox_time_idx", "]", ":", "end_idx", "]", "\n", "\n", "# Required Information ['x', 'y', 'w', 'h', 'class_id']", "\n", "np_bbox", "=", "rfn", ".", "structured_to_unstructured", "(", "bboxes", ")", "[", ":", ",", "[", "1", ",", "2", ",", "3", ",", "4", ",", "5", "]", "]", "\n", "np_bbox", "=", "self", ".", "cropToFrame", "(", "np_bbox", ")", "\n", "\n", "const_size_bbox", "=", "np", ".", "zeros", "(", "[", "self", ".", "max_nr_bbox", ",", "5", "]", ")", "\n", "const_size_bbox", "[", ":", "np_bbox", ".", "shape", "[", "0", "]", ",", ":", "]", "=", "np_bbox", "\n", "\n", "# Events", "\n", "events", "=", "self", ".", "readEventFile", "(", "event_file", ",", "self", ".", "sequence_start", "[", "idx", "]", ",", "nr_window_events", "=", "self", ".", "nr_events_window", ")", "\n", "histogram", "=", "self", ".", "generate_input_representation", "(", "events", ",", "(", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "\n", "return", "events", ",", "const_size_bbox", ".", "astype", "(", "np", ".", "int64", ")", ",", "histogram", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.searchEventSequence": [[492, 528], ["dataloader.prophesee.dat_events_tools.count_events", "open", "dataloader.prophesee.dat_events_tools.parse_header", "open.close", "open.seek", "numpy.fromfile", "open.seek"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.count_events", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.parse_header"], ["", "def", "searchEventSequence", "(", "self", ",", "event_file", ",", "bbox_time", ",", "nr_window_events", "=", "250000", ")", ":", "\n", "        ", "\"\"\"\n        Code adapted from:\n        https://github.com/prophesee-ai/prophesee-automotive-dataset-toolbox/blob/master/src/io/psee_loader.py\n\n        go to the time final_time inside the file. This is implemented using a binary search algorithm\n        :param final_time: expected time\n        :param term_cirterion: (nb event) binary search termination criterion\n        it will load those events in a buffer and do a numpy searchsorted so the result is always exact\n        \"\"\"", "\n", "term_criterion", "=", "nr_window_events", "//", "2", "\n", "nr_events", "=", "dat_events_tools", ".", "count_events", "(", "event_file", ")", "\n", "file_handle", "=", "open", "(", "event_file", ",", "\"rb\"", ")", "\n", "ev_start", ",", "ev_type", ",", "ev_size", ",", "img_size", "=", "dat_events_tools", ".", "parse_header", "(", "file_handle", ")", "\n", "low", "=", "0", "\n", "high", "=", "nr_events", "\n", "\n", "# binary search", "\n", "while", "high", "-", "low", ">", "term_criterion", ":", "\n", "            ", "middle", "=", "(", "low", "+", "high", ")", "//", "2", "\n", "\n", "# self.seek_event(file_handle, middle)", "\n", "file_handle", ".", "seek", "(", "ev_start", "+", "middle", "*", "ev_size", ")", "\n", "mid", "=", "np", ".", "fromfile", "(", "file_handle", ",", "dtype", "=", "[", "(", "'ts'", ",", "'u4'", ")", ",", "(", "'_'", ",", "'i4'", ")", "]", ",", "count", "=", "1", ")", "[", "\"ts\"", "]", "[", "0", "]", "\n", "\n", "if", "mid", ">", "bbox_time", ":", "\n", "                ", "high", "=", "middle", "\n", "", "elif", "mid", "<", "bbox_time", ":", "\n", "                ", "low", "=", "middle", "+", "1", "\n", "", "else", ":", "\n", "                ", "file_handle", ".", "seek", "(", "ev_start", "+", "(", "middle", "-", "(", "term_criterion", "//", "2", ")", "*", "ev_size", ")", ")", "\n", "break", "\n", "\n", "", "", "file_handle", ".", "close", "(", ")", "\n", "# we now know that it is between low and high", "\n", "return", "ev_start", "+", "low", "*", "ev_size", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.readEventFile": [[529, 544], ["open", "open.seek", "numpy.fromfile", "open.close", "numpy.bitwise_and", "numpy.right_shift", "numpy.right_shift", "numpy.stack", "numpy.bitwise_and", "numpy.bitwise_and"], "methods", ["None"], ["", "def", "readEventFile", "(", "self", ",", "event_file", ",", "file_position", ",", "nr_window_events", "=", "250000", ")", ":", "\n", "        ", "file_handle", "=", "open", "(", "event_file", ",", "\"rb\"", ")", "\n", "# file_position = ev_start + low * ev_size", "\n", "file_handle", ".", "seek", "(", "file_position", ")", "\n", "dat_event", "=", "np", ".", "fromfile", "(", "file_handle", ",", "dtype", "=", "[", "(", "'ts'", ",", "'u4'", ")", ",", "(", "'_'", ",", "'i4'", ")", "]", ",", "count", "=", "nr_window_events", ")", "\n", "file_handle", ".", "close", "(", ")", "\n", "\n", "x", "=", "np", ".", "bitwise_and", "(", "dat_event", "[", "\"_\"", "]", ",", "16383", ")", "\n", "y", "=", "np", ".", "right_shift", "(", "\n", "np", ".", "bitwise_and", "(", "dat_event", "[", "\"_\"", "]", ",", "268419072", ")", ",", "14", ")", "\n", "p", "=", "np", ".", "right_shift", "(", "np", ".", "bitwise_and", "(", "dat_event", "[", "\"_\"", "]", ",", "268435456", ")", ",", "28", ")", "\n", "p", "[", "p", "==", "0", "]", "=", "-", "1", "\n", "events_np", "=", "np", ".", "stack", "(", "[", "x", ",", "y", ",", "dat_event", "[", "'ts'", "]", ",", "p", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n", "return", "events_np", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.Prophesee.cropToFrame": [[545, 558], ["numpy.maximum", "numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.minimum", "numpy.zeros_like", "numpy.ones_like", "numpy.ones_like"], "methods", ["None"], ["", "def", "cropToFrame", "(", "self", ",", "np_bbox", ")", ":", "\n", "        ", "\"\"\"Checks if bounding boxes are inside frame. If not crop to border\"\"\"", "\n", "array_width", "=", "np", ".", "ones_like", "(", "np_bbox", "[", ":", ",", "0", "]", ")", "*", "self", ".", "width", "-", "1", "\n", "array_height", "=", "np", ".", "ones_like", "(", "np_bbox", "[", ":", ",", "1", "]", ")", "*", "self", ".", "height", "-", "1", "\n", "\n", "np_bbox", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "np_bbox", "[", ":", ",", ":", "2", "]", ",", "np", ".", "zeros_like", "(", "np_bbox", "[", ":", ",", ":", "2", "]", ")", ")", "\n", "np_bbox", "[", ":", ",", "0", "]", "=", "np", ".", "minimum", "(", "np_bbox", "[", ":", ",", "0", "]", ",", "array_width", ")", "\n", "np_bbox", "[", ":", ",", "1", "]", "=", "np", ".", "minimum", "(", "np_bbox", "[", ":", ",", "1", "]", ",", "array_height", ")", "\n", "\n", "np_bbox", "[", ":", ",", "2", "]", "=", "np", ".", "minimum", "(", "np_bbox", "[", ":", ",", "2", "]", ",", "array_width", "-", "np_bbox", "[", ":", ",", "0", "]", ")", "\n", "np_bbox", "[", ":", ",", "3", "]", "=", "np", ".", "minimum", "(", "np_bbox", "[", ":", ",", "3", "]", ",", "array_height", "-", "np_bbox", "[", ":", ",", "1", "]", ")", "\n", "\n", "return", "np_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCars.__init__": [[561, 595], ["os.path.join", "len", "os.listdir", "len", "random.shuffle"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "object_classes", ",", "height", ",", "width", ",", "nr_events_window", "=", "-", "1", ",", "augmentation", "=", "False", ",", "mode", "=", "'training'", ",", "\n", "event_representation", "=", "'histogram'", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Creates an iterator over the N_Caltech101 dataset.\n\n        :param root: path to dataset root\n        :param object_classes: list of string containing objects or 'all' for all classes\n        :param height: height of dataset image\n        :param width: width of dataset image\n        :param nr_events_window: number of events in a sliding window histogram, -1 corresponds to all events\n        :param augmentation: flip, shift and random window start for training\n        :param mode: 'training', 'testing' or 'validation'\n        :param event_representation: 'histogram' or 'event_queue'\n        \"\"\"", "\n", "if", "mode", "==", "'training'", ":", "\n", "            ", "mode", "=", "'train'", "\n", "", "elif", "mode", "==", "'testing'", ":", "\n", "            ", "mode", "=", "'test'", "\n", "", "if", "mode", "==", "'validation'", ":", "\n", "            ", "mode", "=", "'val'", "\n", "", "self", ".", "root", "=", "os", ".", "path", ".", "join", "(", "root", ",", "mode", ")", "\n", "self", ".", "object_classes", "=", "object_classes", "\n", "self", ".", "width", "=", "width", "\n", "self", ".", "height", "=", "height", "\n", "self", ".", "augmentation", "=", "augmentation", "\n", "self", ".", "nr_events_window", "=", "nr_events_window", "\n", "self", ".", "nr_classes", "=", "len", "(", "self", ".", "object_classes", ")", "\n", "self", ".", "event_representation", "=", "event_representation", "\n", "\n", "self", ".", "files", "=", "listdir", "(", "self", ".", "root", ")", "\n", "self", ".", "nr_samples", "=", "len", "(", "self", ".", "files", ")", "\n", "\n", "if", "shuffle", ":", "\n", "            ", "random", ".", "shuffle", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCars.__len__": [[596, 598], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCars.__getitem__": [[599, 626], ["numpy.loadtxt().astype", "numpy.loadtxt", "dataset.NCars.generate_input_representation", "os.path.join", "dataset.random_shift_events", "dataset.random_flip_events_along_x", "random.randrange", "min", "numpy.loadtxt", "max", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_input_representation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_shift_events", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_flip_events_along_x"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"\n        returns events and label, loading events from aedat\n        :param idx:\n        :return: x,y,t,p,  label\n        \"\"\"", "\n", "label", "=", "np", ".", "loadtxt", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "files", "[", "idx", "]", ",", "'is_car.txt'", ")", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "events", "=", "np", ".", "loadtxt", "(", "os", ".", "path", ".", "join", "(", "self", ".", "root", ",", "self", ".", "files", "[", "idx", "]", ",", "'events.txt'", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "events", "[", "events", "[", ":", ",", "-", "1", "]", "==", "0", ",", "-", "1", "]", "=", "-", "1", "\n", "nr_events", "=", "events", ".", "shape", "[", "0", "]", "\n", "\n", "window_start", "=", "0", "\n", "window_end", "=", "nr_events", "\n", "if", "self", ".", "augmentation", ":", "\n", "            ", "events", "=", "random_shift_events", "(", "events", ",", "max_shift", "=", "10", ",", "resolution", "=", "(", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "events", "=", "random_flip_events_along_x", "(", "events", ",", "resolution", "=", "(", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "window_start", "=", "random", ".", "randrange", "(", "0", ",", "max", "(", "1", ",", "nr_events", "-", "self", ".", "nr_events_window", ")", ")", "\n", "\n", "", "if", "self", ".", "nr_events_window", "!=", "-", "1", ":", "\n", "# Catch case if number of events in batch is lower than number of events in window.", "\n", "            ", "window_end", "=", "min", "(", "nr_events", ",", "window_start", "+", "self", ".", "nr_events_window", ")", "\n", "\n", "", "events", "=", "events", "[", "window_start", ":", "window_end", ",", ":", "]", "\n", "\n", "histogram", "=", "self", ".", "generate_input_representation", "(", "events", ",", "(", "self", ".", "height", ",", "self", ".", "width", ")", ")", "\n", "\n", "return", "events", ",", "label", ",", "histogram", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_shift_events": [[14, 36], ["numpy.random.randint", "numpy.random.randint", "numpy.random.randint", "min", "min", "min", "min"], "function", ["None"], ["def", "random_shift_events", "(", "events", ",", "max_shift", "=", "20", ",", "resolution", "=", "(", "180", ",", "240", ")", ",", "bounding_box", "=", "None", ")", ":", "\n", "    ", "H", ",", "W", "=", "resolution", "\n", "if", "bounding_box", "is", "not", "None", ":", "\n", "        ", "x_shift", "=", "np", ".", "random", ".", "randint", "(", "-", "min", "(", "bounding_box", "[", "0", ",", "0", "]", ",", "max_shift", ")", ",", "\n", "min", "(", "W", "-", "bounding_box", "[", "2", ",", "0", "]", ",", "max_shift", ")", ",", "size", "=", "(", "1", ",", ")", ")", "\n", "y_shift", "=", "np", ".", "random", ".", "randint", "(", "-", "min", "(", "bounding_box", "[", "0", ",", "1", "]", ",", "max_shift", ")", ",", "\n", "min", "(", "H", "-", "bounding_box", "[", "2", ",", "1", "]", ",", "max_shift", ")", ",", "size", "=", "(", "1", ",", ")", ")", "\n", "bounding_box", "[", ":", ",", "0", "]", "+=", "x_shift", "\n", "bounding_box", "[", ":", ",", "1", "]", "+=", "y_shift", "\n", "", "else", ":", "\n", "        ", "x_shift", ",", "y_shift", "=", "np", ".", "random", ".", "randint", "(", "-", "max_shift", ",", "max_shift", "+", "1", ",", "size", "=", "(", "2", ",", ")", ")", "\n", "\n", "", "events", "[", ":", ",", "0", "]", "+=", "x_shift", "\n", "events", "[", ":", ",", "1", "]", "+=", "y_shift", "\n", "\n", "valid_events", "=", "(", "events", "[", ":", ",", "0", "]", ">=", "0", ")", "&", "(", "events", "[", ":", ",", "0", "]", "<", "W", ")", "&", "(", "events", "[", ":", ",", "1", "]", ">=", "0", ")", "&", "(", "events", "[", ":", ",", "1", "]", "<", "H", ")", "\n", "events", "=", "events", "[", "valid_events", "]", "\n", "\n", "if", "bounding_box", "is", "None", ":", "\n", "        ", "return", "events", "\n", "\n", "", "return", "events", ",", "bounding_box", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.random_flip_events_along_x": [[38, 52], ["numpy.random.random"], "function", ["None"], ["", "def", "random_flip_events_along_x", "(", "events", ",", "resolution", "=", "(", "180", ",", "240", ")", ",", "p", "=", "0.5", ",", "bounding_box", "=", "None", ")", ":", "\n", "    ", "H", ",", "W", "=", "resolution", "\n", "flipped", "=", "False", "\n", "if", "np", ".", "random", ".", "random", "(", ")", "<", "p", ":", "\n", "        ", "events", "[", ":", ",", "0", "]", "=", "W", "-", "1", "-", "events", "[", ":", ",", "0", "]", "\n", "flipped", "=", "True", "\n", "\n", "", "if", "bounding_box", "is", "None", ":", "\n", "        ", "return", "events", "\n", "\n", "", "if", "flipped", ":", "\n", "        ", "bounding_box", "[", ":", ",", "0", "]", "=", "W", "-", "1", "-", "bounding_box", "[", ":", ",", "0", "]", "\n", "bounding_box", "=", "bounding_box", "[", "[", "1", ",", "0", ",", "3", ",", "2", "]", "]", "\n", "", "return", "events", ",", "bounding_box", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.getDataloader": [[54, 60], ["dataset_dict.get"], "function", ["None"], ["", "def", "getDataloader", "(", "name", ")", ":", "\n", "    ", "dataset_dict", "=", "{", "'NCaltech101'", ":", "NCaltech101", ",", "\n", "'NCaltech101_ObjectDetection'", ":", "NCaltech101_ObjectDetection", ",", "\n", "'Prophesee'", ":", "Prophesee", ",", "\n", "'NCars'", ":", "NCars", "}", "\n", "return", "dataset_dict", ".", "get", "(", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.loader.Loader.__init__": [[8, 20], ["list", "range", "torch.utils.data.sampler.SubsetRandomSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "batch_size", ",", "num_workers", ",", "pin_memory", ",", "device", ",", "shuffle", "=", "True", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "split_indices", "=", "list", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "if", "shuffle", ":", "\n", "            ", "sampler", "=", "torch", ".", "utils", ".", "data", ".", "sampler", ".", "SubsetRandomSampler", "(", "split_indices", ")", "\n", "self", ".", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "batch_size", ",", "sampler", "=", "sampler", ",", "\n", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "pin_memory", ",", "\n", "collate_fn", "=", "collate_events", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "batch_size", "=", "batch_size", ",", "\n", "num_workers", "=", "num_workers", ",", "pin_memory", "=", "pin_memory", ",", "\n", "collate_fn", "=", "collate_events", ")", "\n", "", "", "def", "__iter__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.loader.Loader.__iter__": [[20, 24], ["d.to"], "methods", ["None"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "data", "in", "self", ".", "loader", ":", "\n", "            ", "data", "=", "[", "d", ".", "to", "(", "self", ".", "device", ")", "for", "d", "in", "data", "]", "\n", "yield", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.loader.Loader.__len__": [[25, 27], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.loader.collate_events": [[29, 44], ["enumerate", "torch.from_numpy", "torch.utils.data.dataloader.default_collate", "torch.utils.data.dataloader.default_collate", "torch.utils.data.dataloader.default_collate.append", "torch.utils.data.dataloader.default_collate.append", "numpy.concatenate", "torch.from_numpy.append", "numpy.concatenate", "numpy.ones", "len"], "function", ["None"], ["", "", "def", "collate_events", "(", "data", ")", ":", "\n", "    ", "labels", "=", "[", "]", "\n", "events", "=", "[", "]", "\n", "histograms", "=", "[", "]", "\n", "for", "i", ",", "d", "in", "enumerate", "(", "data", ")", ":", "\n", "        ", "labels", ".", "append", "(", "d", "[", "1", "]", ")", "\n", "histograms", ".", "append", "(", "d", "[", "2", "]", ")", "\n", "ev", "=", "np", ".", "concatenate", "(", "[", "d", "[", "0", "]", ",", "i", "*", "np", ".", "ones", "(", "(", "len", "(", "d", "[", "0", "]", ")", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "]", ",", "1", ")", "\n", "events", ".", "append", "(", "ev", ")", "\n", "", "events", "=", "torch", ".", "from_numpy", "(", "np", ".", "concatenate", "(", "events", ",", "0", ")", ")", "\n", "labels", "=", "default_collate", "(", "labels", ")", "\n", "\n", "histograms", "=", "default_collate", "(", "histograms", ")", "\n", "\n", "return", "events", ",", "labels", ",", "histograms", "\n", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.npy_events_tools.stream_td_data": [[15, 28], ["numpy.fromfile", "len"], "function", ["None"], ["def", "stream_td_data", "(", "file_handle", ",", "buffer", ",", "dtype", ",", "ev_count", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"\n    Streams data from opened file_handle\n    args :\n        - file_handle: file object\n        - buffer: pre-allocated buffer to fill with events\n        - dtype:  expected fields\n        - ev_count: number of events\n    \"\"\"", "\n", "dat", "=", "np", ".", "fromfile", "(", "file_handle", ",", "dtype", "=", "dtype", ",", "count", "=", "ev_count", ")", "\n", "count", "=", "len", "(", "dat", "[", "'ts'", "]", ")", "\n", "for", "name", ",", "_", "in", "dtype", ":", "\n", "        ", "buffer", "[", "name", "]", "[", ":", "count", "]", "=", "dat", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.npy_events_tools.parse_header": [[30, 58], ["numpy.lib.format.read_magic", "numpy.lib.format._read_array_header", "fhandle.tell", "len", "numpy.multiply.reduce", "str"], "function", ["None"], ["", "", "def", "parse_header", "(", "fhandle", ")", ":", "\n", "    ", "\"\"\"\n    Parses the header of a .npy file\n    Args:\n        - f file handle to a .npy file\n    return :\n        - int position of the file cursor after the header\n        - int type of event\n        - int size of event in bytes\n        - size (height, width) tuple of int or (None, None)\n    \"\"\"", "\n", "version", "=", "np", ".", "lib", ".", "format", ".", "read_magic", "(", "fhandle", ")", "\n", "shape", ",", "fortran", ",", "dtype", "=", "np", ".", "lib", ".", "format", ".", "_read_array_header", "(", "fhandle", ",", "version", ")", "\n", "assert", "not", "fortran", ",", "\"Fortran order arrays not supported\"", "\n", "# Get the number of elements in one 'row' by taking", "\n", "# a product over all other dimensions.", "\n", "if", "len", "(", "shape", ")", "==", "0", ":", "\n", "        ", "count", "=", "1", "\n", "", "else", ":", "\n", "        ", "count", "=", "np", ".", "multiply", ".", "reduce", "(", "shape", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "", "ev_size", "=", "dtype", ".", "itemsize", "\n", "assert", "ev_size", "!=", "0", "\n", "start", "=", "fhandle", ".", "tell", "(", ")", "\n", "# turn numpy.dtype into an iterable list", "\n", "ev_type", "=", "[", "(", "x", ",", "str", "(", "dtype", ".", "fields", "[", "x", "]", "[", "0", "]", ")", ")", "for", "x", "in", "dtype", ".", "names", "]", "\n", "size", "=", "(", "None", ",", "None", ")", "\n", "\n", "return", "start", ",", "ev_type", ",", "ev_size", ",", "size", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.load_td_data": [[20, 47], ["open", "dat_events_tools.parse_header", "numpy.fromfile", "dat_events_tools._dat_transfer", "f.seek", "numpy.bitwise_and", "numpy.right_shift", "numpy.right_shift", "numpy.bitwise_and", "numpy.bitwise_and"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.parse_header", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools._dat_transfer"], ["def", "load_td_data", "(", "filename", ",", "ev_count", "=", "-", "1", ",", "ev_start", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Loads TD data from files generated by the StreamLogger consumer for Event2D\n    events [ts,x,y,p]. The type ID in the file header must be 0.\n    args :\n        - path to a dat file\n        - number of event (all if set to the default -1)\n        - index of the first event\n    return :\n        - dat, a dictionary like structure containing the fields ts, x, y, p\n    \"\"\"", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "_", ",", "ev_type", ",", "ev_size", ",", "_", "=", "parse_header", "(", "f", ")", "\n", "if", "ev_start", ">", "0", ":", "\n", "            ", "f", ".", "seek", "(", "ev_start", "*", "ev_size", ",", "1", ")", "\n", "\n", "", "dtype", "=", "EV_TYPE", "\n", "dat", "=", "np", ".", "fromfile", "(", "f", ",", "dtype", "=", "dtype", ",", "count", "=", "ev_count", ")", "\n", "xyp", "=", "None", "\n", "if", "(", "'_'", ",", "'i4'", ")", "in", "dtype", ":", "\n", "            ", "x", "=", "np", ".", "bitwise_and", "(", "dat", "[", "\"_\"", "]", ",", "16383", ")", "\n", "y", "=", "np", ".", "right_shift", "(", "\n", "np", ".", "bitwise_and", "(", "dat", "[", "\"_\"", "]", ",", "268419072", ")", ",", "14", ")", "\n", "p", "=", "np", ".", "right_shift", "(", "np", ".", "bitwise_and", "(", "dat", "[", "\"_\"", "]", ",", "268435456", ")", ",", "28", ")", "\n", "xyp", "=", "(", "x", ",", "y", ",", "p", ")", "\n", "\n", "", "return", "_dat_transfer", "(", "dat", ",", "dtype", ",", "xyp", "=", "xyp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools._dat_transfer": [[49, 79], ["enumerate", "numpy.empty", "variables.append", "print", "xyp[].astype", "xyp[].astype", "xyp[].astype"], "function", ["None"], ["", "", "def", "_dat_transfer", "(", "dat", ",", "dtype", ",", "xyp", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Transfers the fields present in dtype from an old datastructure to a new datastructure\n    xyp should be passed as a tuple\n    args :\n        - dat vector as directly read from file\n        - dtype _numpy dtype_ as a list of couple of field name/ type eg [('x','i4'), ('y','f2')]\n        - xyp optional tuple containing x,y,p etracted from a field '_'and untangled by bitshift and masking\n    \"\"\"", "\n", "variables", "=", "[", "]", "\n", "xyp_index", "=", "-", "1", "\n", "for", "i", ",", "(", "name", ",", "_", ")", "in", "enumerate", "(", "dtype", ")", ":", "\n", "        ", "if", "name", "==", "'_'", ":", "\n", "            ", "xyp_index", "=", "i", "\n", "continue", "\n", "", "variables", ".", "append", "(", "(", "name", ",", "dat", "[", "name", "]", ")", ")", "\n", "", "if", "xyp", "and", "xyp_index", "==", "-", "1", ":", "\n", "        ", "print", "(", "\"Error dat didn't contain a '_' field !\"", ")", "\n", "return", "\n", "", "if", "xyp_index", ">=", "0", ":", "\n", "        ", "dtype", "=", "dtype", "[", ":", "xyp_index", "]", "+", "[", "(", "'x'", ",", "'i2'", ")", ",", "(", "'y'", ",", "'i2'", ")", ",", "(", "'p'", ",", "'i2'", ")", "]", "+", "dtype", "[", "xyp_index", "+", "1", ":", "]", "\n", "", "new_dat", "=", "np", ".", "empty", "(", "dat", ".", "shape", "[", "0", "]", ",", "dtype", "=", "dtype", ")", "\n", "if", "xyp", ":", "\n", "        ", "new_dat", "[", "\"x\"", "]", "=", "xyp", "[", "0", "]", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "new_dat", "[", "\"y\"", "]", "=", "xyp", "[", "1", "]", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "new_dat", "[", "\"p\"", "]", "=", "xyp", "[", "2", "]", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "\n", "", "for", "(", "name", ",", "arr", ")", "in", "variables", ":", "\n", "        ", "new_dat", "[", "name", "]", "=", "arr", "\n", "", "return", "new_dat", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.count_events": [[81, 94], ["open", "dat_events_tools.parse_header", "f.seek", "f.tell", "Exception"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.parse_header"], ["", "def", "count_events", "(", "filename", ")", ":", "\n", "    ", "\"\"\"\n    Returns the number of events in a dat file\n    args :\n        - path to a dat file\n    \"\"\"", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "bod", ",", "_", ",", "ev_size", ",", "_", "=", "parse_header", "(", "f", ")", "\n", "f", ".", "seek", "(", "0", ",", "os", ".", "SEEK_END", ")", "\n", "eod", "=", "f", ".", "tell", "(", ")", "\n", "if", "(", "eod", "-", "bod", ")", "%", "ev_size", "!=", "0", ":", "\n", "            ", "raise", "Exception", "(", "\"unexpected format !\"", ")", "\n", "", "return", "(", "eod", "-", "bod", ")", "//", "ev_size", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.prophesee.dat_events_tools.parse_header": [[96, 152], ["f.seek", "f.seek", "f.tell", "f.tell", "f.readline", "sum", "f.readline.split", "numpy.frombuffer", "numpy.frombuffer", "f.readline.decode", "len", "f.read", "f.read", "int", "int", "int"], "function", ["None"], ["", "", "def", "parse_header", "(", "f", ")", ":", "\n", "    ", "\"\"\"\n    Parses the header of a dat file\n    Args:\n        - f file handle to a dat file\n    return :\n        - int position of the file cursor after the header\n        - int type of event\n        - int size of event in bytes\n        - size (height, width) tuple of int or None\n    \"\"\"", "\n", "f", ".", "seek", "(", "0", ",", "os", ".", "SEEK_SET", ")", "\n", "bod", "=", "None", "\n", "end_of_header", "=", "False", "\n", "header", "=", "[", "]", "\n", "num_comment_line", "=", "0", "\n", "size", "=", "[", "None", ",", "None", "]", "\n", "# parse header", "\n", "while", "not", "end_of_header", ":", "\n", "        ", "bod", "=", "f", ".", "tell", "(", ")", "\n", "line", "=", "f", ".", "readline", "(", ")", "\n", "if", "sys", ".", "version_info", ">", "(", "3", ",", "0", ")", ":", "\n", "            ", "first_item", "=", "line", ".", "decode", "(", "\"latin-1\"", ")", "[", ":", "2", "]", "\n", "", "else", ":", "\n", "            ", "first_item", "=", "line", "[", ":", "2", "]", "\n", "\n", "", "if", "first_item", "!=", "'% '", ":", "\n", "            ", "end_of_header", "=", "True", "\n", "", "else", ":", "\n", "            ", "words", "=", "line", ".", "split", "(", ")", "\n", "if", "len", "(", "words", ")", ">", "1", ":", "\n", "                ", "if", "words", "[", "1", "]", "==", "'Date'", ":", "\n", "                    ", "header", "+=", "[", "'Date'", ",", "words", "[", "2", "]", "+", "' '", "+", "words", "[", "3", "]", "]", "\n", "", "if", "words", "[", "1", "]", "==", "'Height'", "or", "words", "[", "1", "]", "==", "b'Height'", ":", "# compliant with python 3 (and python2)", "\n", "                    ", "size", "[", "0", "]", "=", "int", "(", "words", "[", "2", "]", ")", "\n", "header", "+=", "[", "'Height'", ",", "words", "[", "2", "]", "]", "\n", "", "if", "words", "[", "1", "]", "==", "'Width'", "or", "words", "[", "1", "]", "==", "b'Width'", ":", "# compliant with python 3 (and python2)", "\n", "                    ", "size", "[", "1", "]", "=", "int", "(", "words", "[", "2", "]", ")", "\n", "header", "+=", "[", "'Width'", ",", "words", "[", "2", "]", "]", "\n", "", "", "else", ":", "\n", "                ", "header", "+=", "words", "[", "1", ":", "3", "]", "\n", "", "num_comment_line", "+=", "1", "\n", "# parse data", "\n", "", "", "f", ".", "seek", "(", "bod", ",", "os", ".", "SEEK_SET", ")", "\n", "\n", "if", "num_comment_line", ">", "0", ":", "# Ensure compatibility with previous files.", "\n", "# Read event type", "\n", "        ", "ev_type", "=", "np", ".", "frombuffer", "(", "f", ".", "read", "(", "1", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "[", "0", "]", "\n", "# Read event size", "\n", "ev_size", "=", "np", ".", "frombuffer", "(", "f", ".", "read", "(", "1", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "ev_type", "=", "0", "\n", "ev_size", "=", "sum", "(", "[", "int", "(", "n", "[", "-", "1", "]", ")", "for", "_", ",", "n", "in", "EV_TYPE", "]", ")", "\n", "\n", "", "bod", "=", "f", ".", "tell", "(", ")", "\n", "return", "bod", ",", "ev_type", ",", "ev_size", ",", "size", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.config.settings.Settings.__init__": [[9, 83], ["os.path.isfile", "open", "yaml.load", "os.path.isdir", "isinstance", "float", "float", "torch.device", "torch.device", "os.cpu_count", "time.strftime", "os.path.join", "os.makedirs", "os.path.join", "shutil.copyfile", "os.path.join", "os.mkdir", "os.path.join", "os.mkdir", "os.path.join", "os.path.join", "str"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "settings_yaml", ",", "generate_log", "=", "True", ")", ":", "\n", "        ", "assert", "os", ".", "path", ".", "isfile", "(", "settings_yaml", ")", ",", "settings_yaml", "\n", "\n", "with", "open", "(", "settings_yaml", ",", "'r'", ")", "as", "stream", ":", "\n", "            ", "settings", "=", "yaml", ".", "load", "(", "stream", ",", "yaml", ".", "Loader", ")", "\n", "\n", "# --- hardware ---", "\n", "hardware", "=", "settings", "[", "'hardware'", "]", "\n", "gpu_device", "=", "hardware", "[", "'gpu_device'", "]", "\n", "\n", "self", ".", "gpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "if", "gpu_device", "==", "\"cpu\"", "else", "torch", ".", "device", "(", "\"cuda:\"", "+", "str", "(", "gpu_device", ")", ")", "\n", "\n", "self", ".", "num_cpu_workers", "=", "hardware", "[", "'num_cpu_workers'", "]", "\n", "if", "self", ".", "num_cpu_workers", "<", "0", ":", "\n", "                ", "self", ".", "num_cpu_workers", "=", "os", ".", "cpu_count", "(", ")", "\n", "\n", "# --- Model ---", "\n", "", "model", "=", "settings", "[", "'model'", "]", "\n", "self", ".", "model_name", "=", "model", "[", "'model_name'", "]", "\n", "\n", "# --- dataset ---", "\n", "dataset", "=", "settings", "[", "'dataset'", "]", "\n", "self", ".", "dataset_name", "=", "dataset", "[", "'name'", "]", "\n", "self", ".", "event_representation", "=", "dataset", "[", "'event_representation'", "]", "\n", "if", "self", ".", "dataset_name", "==", "'NCaltech101'", ":", "\n", "                ", "dataset_specs", "=", "dataset", "[", "'ncaltech101'", "]", "\n", "", "elif", "self", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", ":", "\n", "                ", "dataset_specs", "=", "dataset", "[", "'ncaltech101_objectdetection'", "]", "\n", "", "elif", "self", ".", "dataset_name", "==", "'Prophesee'", ":", "\n", "                ", "dataset_specs", "=", "dataset", "[", "'prophesee'", "]", "\n", "", "elif", "self", ".", "dataset_name", "==", "'NCars'", ":", "\n", "                ", "dataset_specs", "=", "dataset", "[", "'ncars'", "]", "\n", "\n", "", "self", ".", "dataset_path", "=", "dataset_specs", "[", "'dataset_path'", "]", "\n", "assert", "os", ".", "path", ".", "isdir", "(", "self", ".", "dataset_path", ")", "\n", "self", ".", "object_classes", "=", "dataset_specs", "[", "'object_classes'", "]", "\n", "self", ".", "height", "=", "dataset_specs", "[", "'height'", "]", "\n", "self", ".", "width", "=", "dataset_specs", "[", "'width'", "]", "\n", "self", ".", "nr_events_window", "=", "dataset_specs", "[", "'nr_events_window'", "]", "\n", "\n", "# --- checkpoint ---", "\n", "checkpoint", "=", "settings", "[", "'checkpoint'", "]", "\n", "self", ".", "resume_training", "=", "checkpoint", "[", "'resume_training'", "]", "\n", "assert", "isinstance", "(", "self", ".", "resume_training", ",", "bool", ")", "\n", "self", ".", "resume_ckpt_file", "=", "checkpoint", "[", "'resume_file'", "]", "\n", "self", ".", "use_pretrained", "=", "checkpoint", "[", "'use_pretrained'", "]", "\n", "self", ".", "pretrained_dense_vgg", "=", "checkpoint", "[", "'pretrained_dense_vgg'", "]", "\n", "self", ".", "pretrained_sparse_vgg", "=", "checkpoint", "[", "'pretrained_sparse_vgg'", "]", "\n", "\n", "# --- directories ---", "\n", "directories", "=", "settings", "[", "'dir'", "]", "\n", "log_dir", "=", "directories", "[", "'log'", "]", "\n", "\n", "# --- logs ---", "\n", "if", "generate_log", ":", "\n", "                ", "timestr", "=", "time", ".", "strftime", "(", "\"%Y%m%d-%H%M%S\"", ")", "\n", "log_dir", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "timestr", ")", "\n", "os", ".", "makedirs", "(", "log_dir", ")", "\n", "settings_copy_filepath", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'settings.yaml'", ")", "\n", "shutil", ".", "copyfile", "(", "settings_yaml", ",", "settings_copy_filepath", ")", "\n", "self", ".", "ckpt_dir", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'checkpoints'", ")", "\n", "os", ".", "mkdir", "(", "self", ".", "ckpt_dir", ")", "\n", "self", ".", "vis_dir", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'visualization'", ")", "\n", "os", ".", "mkdir", "(", "self", ".", "vis_dir", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "ckpt_dir", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'checkpoints'", ")", "\n", "self", ".", "vis_dir", "=", "os", ".", "path", ".", "join", "(", "log_dir", ",", "'visualization'", ")", "\n", "\n", "# --- optimization ---", "\n", "", "optimization", "=", "settings", "[", "'optim'", "]", "\n", "self", ".", "batch_size", "=", "optimization", "[", "'batch_size'", "]", "\n", "self", ".", "init_lr", "=", "float", "(", "optimization", "[", "'init_lr'", "]", ")", "\n", "self", ".", "steps_lr", "=", "optimization", "[", "'steps_lr'", "]", "\n", "self", ".", "factor_lr", "=", "float", "(", "optimization", "[", "'factor_lr'", "]", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.__init__": [[5, 33], ["torch.device", "torch.LongTensor().fill_().to", "torch.stack", "max_pool.asynMaxPool.filter_size_tensor.prod().item", "torch.stack.reshape().to", "torch.meshgrid", "torch.LongTensor().fill_", "max_pool.asynMaxPool.filter_size_tensor.prod", "torch.stack.reshape", "torch.arange", "torch.LongTensor", "range"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dimension", ",", "filter_size", ",", "filter_stride", ",", "padding_mode", "=", "'same'", ",", "first_layer", "=", "False", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "\"\"\"\n        Constructs a max pooling layer.\n\n        :param dimension: spatial dimension of the max pooling layer [1, 2, ...]\n        :param filter_size: size of the pooling kernel\n        :param filter_stride: stride of the kernel\n        :param padding: 'same' or 'valid'. Identical behaviour to tensorflow max pooling\n        \"\"\"", "\n", "self", ".", "dimension", "=", "dimension", "\n", "self", ".", "filter_size", "=", "filter_size", "\n", "self", ".", "filter_stride", "=", "filter_stride", "\n", "self", ".", "padding_mode", "=", "padding_mode", "\n", "self", ".", "first_layer", "=", "first_layer", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "padding", "=", "[", "filter_size", "//", "2", "]", "*", "dimension", "*", "2", "\n", "self", ".", "filter_size_tensor", "=", "torch", ".", "LongTensor", "(", "dimension", ")", ".", "fill_", "(", "self", ".", "filter_size", ")", ".", "to", "(", "device", ")", "\n", "# Construct lookup table for 1d kernel position to position in nd", "\n", "kernel_indices", "=", "torch", ".", "stack", "(", "torch", ".", "meshgrid", "(", "[", "torch", ".", "arange", "(", "filter_size", ")", "for", "_", "in", "range", "(", "dimension", ")", "]", ")", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "filter_volume", "=", "self", ".", "filter_size_tensor", ".", "prod", "(", ")", ".", "item", "(", ")", "\n", "self", ".", "kernel_indices", "=", "kernel_indices", ".", "reshape", "(", "[", "self", ".", "filter_volume", ",", "dimension", "]", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "border_dist", "=", "filter_size", "//", "2", "if", "padding_mode", "==", "'valid'", "else", "0", "\n", "\n", "self", ".", "output_feature_map", "=", "None", "\n", "self", ".", "old_max_indices_map", "=", "None", "\n", "self", ".", "output_arguments_map", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.forward": [[34, 88], ["max_pool.asynMaxPool.checkInputArguments", "update_location.split", "torch.ceil().long", "max_pool.asynMaxPool.computeOutputLocations", "torch.arange", "dummy_kernel_indices.repeat.repeat.repeat", "torch.cat().long().split", "update_location[].repeat", "feature_map[].float", "torch.cat", "torch.max", "max_pool.asynMaxPool.computeMaxIndices", "torch.zeros", "torch.zeros.nonzero", "torch.zeros", "torch.zeros", "update_location[].repeat.view", "torch.Size", "max_pool.asynMaxPool.output_feature_map.clone", "max_pool.asynMaxPool.old_max_indices_map.clone", "torch.tensor().float", "torch.ceil", "torch.Size", "torch.ones().long", "torch.cat().long", "torch.zeros", "output_locations.long().split", "list", "list", "torch.tensor", "torch.ones", "torch.cat", "update_location[].repeat.split", "list", "output_locations.long", "list"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.checkInputArguments", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.computeOutputLocations", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.computeMaxIndices", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "def", "forward", "(", "self", ",", "update_location", ",", "feature_map", ")", ":", "\n", "        ", "\"\"\"\n        Computes the a asynchronous sparse convolution layer based on the update_location\n\n        :param update_location: tensor with shape [N_active, dimension]\n        :param feature_map: tensor with shape [N, nIn]\n        :return:\n        \"\"\"", "\n", "self", ".", "checkInputArguments", "(", "update_location", ",", "feature_map", ")", "\n", "update_location_indices", "=", "update_location", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "output_spatial_shape", "=", "(", "torch", ".", "tensor", "(", "feature_map", ".", "shape", "[", ":", "-", "1", "]", ",", "device", "=", "self", ".", "device", ")", ".", "float", "(", ")", "-", "\n", "self", ".", "border_dist", "*", "2", ")", "/", "self", ".", "filter_stride", "\n", "output_spatial_shape", "=", "torch", ".", "ceil", "(", "output_spatial_shape", ")", ".", "long", "(", ")", "\n", "if", "self", ".", "output_arguments_map", "is", "None", ":", "\n", "            ", "out_arg_shape", "=", "list", "(", "output_spatial_shape", ")", "+", "[", "self", ".", "filter_volume", "]", "+", "[", "feature_map", ".", "shape", "[", "-", "1", "]", "]", "\n", "self", ".", "output_arguments_map", "=", "torch", ".", "zeros", "(", "torch", ".", "Size", "(", "out_arg_shape", ")", ",", "device", "=", "self", ".", "device", ")", "\n", "", "if", "self", ".", "output_feature_map", "is", "None", ":", "\n", "            ", "self", ".", "output_feature_map", "=", "torch", ".", "zeros", "(", "list", "(", "output_spatial_shape", ")", "+", "[", "feature_map", ".", "shape", "[", "-", "1", "]", "]", ",", "\n", "device", "=", "self", ".", "device", ")", "\n", "", "if", "self", ".", "old_max_indices_map", "is", "None", ":", "\n", "            ", "self", ".", "old_max_indices_map", "=", "torch", ".", "ones", "(", "list", "(", "output_spatial_shape", ")", "+", "[", "feature_map", ".", "shape", "[", "-", "1", "]", ",", "self", ".", "dimension", "]", ",", "\n", "device", "=", "self", ".", "device", ")", ".", "long", "(", ")", "*", "-", "1", "\n", "\n", "# Find output locations", "\n", "", "out", "=", "self", ".", "computeOutputLocations", "(", "update_location", ",", "output_spatial_shape", ")", "\n", "output_locations", ",", "valid_locations", ",", "nr_update_locations", "=", "out", "\n", "\n", "# Kernel indices relative to output position (reversed kernel index)", "\n", "dummy_kernel_indices", "=", "torch", ".", "arange", "(", "self", ".", "filter_volume", "-", "1", ",", "-", "1", ",", "step", "=", "-", "1", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "self", ".", "device", ")", "\n", "dummy_kernel_indices", "=", "dummy_kernel_indices", ".", "repeat", "(", "nr_update_locations", ")", "\n", "dummy_kernel_indices", "=", "dummy_kernel_indices", "[", "valid_locations", "]", "\n", "\n", "# Update arguments in output argument map", "\n", "argument_indices", "=", "torch", ".", "cat", "(", "(", "output_locations", ",", "dummy_kernel_indices", "[", ":", ",", "None", "]", ")", ",", "dim", "=", "-", "1", ")", ".", "long", "(", ")", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "input_locations", "=", "update_location", "[", ":", ",", "None", ",", ":", "]", ".", "repeat", "(", "[", "1", ",", "self", ".", "filter_volume", ",", "1", "]", ")", "\n", "input_locations", "=", "input_locations", ".", "view", "(", "-", "1", ",", "self", ".", "dimension", ")", "[", "valid_locations", ",", ":", "]", "\n", "self", ".", "output_arguments_map", "[", "argument_indices", "]", "=", "feature_map", "[", "input_locations", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", ".", "float", "(", ")", "\n", "\n", "n_Channels", "=", "self", ".", "output_arguments_map", ".", "shape", "[", "-", "1", "]", "\n", "zero_added_output_arguments_map", "=", "torch", ".", "cat", "(", "(", "torch", ".", "zeros", "(", "list", "(", "output_spatial_shape", ")", "+", "[", "1", ",", "n_Channels", "]", ",", "\n", "device", "=", "self", ".", "device", ")", ",", "\n", "self", ".", "output_arguments_map", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "output_indices", "=", "argument_indices", "[", ":", "1", "]", "\n", "out", "=", "torch", ".", "max", "(", "zero_added_output_arguments_map", "[", "output_indices", "]", ",", "dim", "=", "-", "2", ")", "\n", "self", ".", "output_feature_map", "[", "output_indices", "]", ",", "max_indices", "=", "out", "\n", "self", ".", "old_max_indices_map", "[", "output_indices", "]", "=", "self", ".", "computeMaxIndices", "(", "max_indices", ",", "output_spatial_shape", ",", "\n", "output_indices", ")", "\n", "\n", "new_updates_map", "=", "torch", ".", "zeros", "(", "torch", ".", "Size", "(", "output_spatial_shape", ")", ")", "\n", "new_updates_map", "[", "output_locations", ".", "long", "(", ")", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "1", "\n", "new_update_events", "=", "new_updates_map", ".", "nonzero", "(", ")", "\n", "\n", "return", "new_update_events", ",", "self", ".", "output_feature_map", ".", "clone", "(", ")", ",", "self", ".", "old_max_indices_map", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.computeOutputLocations": [[89, 105], ["output_locations.view.view.view", "torch.eq().sum", "torch.eq", "output_locations.view.view.int().float", "output_locations.view.view.int"], "methods", ["None"], ["", "def", "computeOutputLocations", "(", "self", ",", "update_location", ",", "output_spatial_shape", ")", ":", "\n", "        ", "\"\"\"Computes the outpout location based on the input shape, stride and padding mode\"\"\"", "\n", "output_locations", "=", "update_location", "[", ":", ",", "None", ",", ":", "]", "+", "self", ".", "kernel_indices", "[", "None", ",", ":", ",", ":", "]", "-", "self", ".", "filter_size", "//", "2", "\n", "# Adjust for padding mode and stride", "\n", "output_locations", "=", "(", "output_locations", "-", "self", ".", "border_dist", ")", ".", "float", "(", ")", "/", "self", ".", "filter_stride", "\n", "nr_update_locations", "=", "output_locations", ".", "shape", "[", "0", "]", "\n", "output_locations", "=", "output_locations", ".", "view", "(", "-", "1", ",", "self", ".", "dimension", ")", "\n", "\n", "# Check the conditions for a valid index: even and inside frame", "\n", "valid_locations_even", "=", "torch", ".", "eq", "(", "output_locations", ".", "int", "(", ")", ".", "float", "(", ")", ",", "output_locations", ")", ".", "sum", "(", "-", "1", ")", "==", "self", ".", "dimension", "\n", "spatial_dimension", "=", "(", "output_spatial_shape", "-", "1", ")", ".", "unsqueeze", "(", "0", ")", ".", "float", "(", ")", "\n", "\n", "valid_locations_frame", "=", "~", "(", "(", "output_locations", "<", "0", ")", ".", "sum", "(", "-", "1", ")", "+", "(", "output_locations", ">", "spatial_dimension", ")", ".", "sum", "(", "-", "1", ")", ")", ".", "bool", "(", ")", "\n", "valid_locations", "=", "valid_locations_even", "&", "valid_locations_frame", "\n", "\n", "return", "output_locations", "[", "valid_locations", ",", ":", "]", ",", "valid_locations", ",", "nr_update_locations", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.computeMaxIndices": [[106, 121], ["torch.stack", "torch.meshgrid", "torch.arange", "grid_map.unsqueeze", "range"], "methods", ["None"], ["", "def", "computeMaxIndices", "(", "self", ",", "max_indices", ",", "output_spatial_shape", ",", "output_indices", ")", ":", "\n", "        ", "\"\"\"Compute the maximum indices\"\"\"", "\n", "# Shift index by -1, current 0 index corresponds to zero feature value, which will be changed to -1", "\n", "max_indices", "=", "max_indices", "-", "1", "\n", "kernel_position", "=", "self", ".", "kernel_indices", "[", "max_indices", ",", ":", "]", "\n", "\n", "grid_map", "=", "torch", ".", "stack", "(", "torch", ".", "meshgrid", "(", "[", "torch", ".", "arange", "(", "output_spatial_shape", "[", "i", "]", ",", "device", "=", "self", ".", "device", ")", "for", "i", "in", "\n", "range", "(", "self", ".", "dimension", ")", "]", ")", ",", "dim", "=", "-", "1", ")", "[", "output_indices", "]", "\n", "\n", "max_position", "=", "grid_map", ".", "unsqueeze", "(", "dim", "=", "-", "2", ")", "*", "self", ".", "filter_stride", "+", "self", ".", "border_dist", "-", "self", ".", "filter_size", "//", "2", "+", "kernel_position", "\n", "max_indices", "=", "max_position", "\n", "max_indices", "[", "max_indices", "==", "-", "1", "]", "=", "-", "1", "\n", "\n", "return", "max_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.max_pool.asynMaxPool.checkInputArguments": [[122, 130], ["ValueError", "ValueError", "list", "list"], "methods", ["None"], ["", "def", "checkInputArguments", "(", "self", ",", "update_location", ",", "feature_map", ")", ":", "\n", "        ", "\"\"\"Checks if the input arguments have the correct shape\"\"\"", "\n", "if", "update_location", ".", "ndim", "!=", "2", "or", "update_location", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "dimension", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected update_location to have shape [N, %s]. Got size %s'", "%", "\n", "(", "self", ".", "dimension", ",", "list", "(", "update_location", ".", "shape", ")", ")", ")", "\n", "", "if", "feature_map", ".", "ndim", "!=", "self", ".", "dimension", "+", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected feature_map to have shape [Spatial_1, Spatial_2, ..., C]. Got size %s'", "%", "\n", "list", "(", "feature_map", ".", "shape", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.__init__": [[7, 40], ["torch.device", "torch.LongTensor().fill_().to", "conv_layer_2D.asynSparseConvolution2D.filter_size_tensor.prod().item", "torch.nn.Parameter().to", "torch.stack", "torch.stack.reshape().to", "torch.nn.Parameter().to", "torch.meshgrid", "torch.LongTensor().fill_", "conv_layer_2D.asynSparseConvolution2D.filter_size_tensor.prod", "torch.nn.Parameter", "torch.stack.reshape", "torch.Tensor().normal_", "torch.nn.Parameter", "torch.arange", "torch.LongTensor", "torch.Tensor().normal_", "range", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dimension", ",", "nIn", ",", "nOut", ",", "filter_size", ",", "first_layer", "=", "False", ",", "use_bias", "=", "False", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "\"\"\"\n        Constructs a convolution layer.\n\n        :param dimension: spatial dimension of the convolution e.g. dimension=2 leads to kxk kernel\n        :param nIn: number of channels in the input features\n        :param nOut: number of output channels\n        :param filter_size: kernel size\n        :param first_layer: bool indicating if it is the first layer. Used for computing new inactive sites.\n        \"\"\"", "\n", "self", ".", "dimension", "=", "dimension", "\n", "self", ".", "nIn", "=", "nIn", "\n", "self", ".", "nOut", "=", "nOut", "\n", "self", ".", "filter_size", "=", "filter_size", "\n", "self", ".", "device", "=", "device", "\n", "\n", "self", ".", "filter_size_tensor", "=", "torch", ".", "LongTensor", "(", "dimension", ")", ".", "fill_", "(", "self", ".", "filter_size", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "filter_volume", "=", "self", ".", "filter_size_tensor", ".", "prod", "(", ")", ".", "item", "(", ")", "\n", "std", "=", "(", "2.0", "/", "nIn", "/", "self", ".", "filter_volume", ")", "**", "0.5", "\n", "self", ".", "weight", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "filter_volume", ",", "nIn", ",", "nOut", ")", ".", "normal_", "(", "0", ",", "std", ")", ")", ".", "to", "(", "device", ")", "\n", "self", ".", "first_layer", "=", "first_layer", "\n", "self", ".", "use_bias", "=", "use_bias", "\n", "if", "use_bias", ":", "\n", "            ", "self", ".", "bias", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "nOut", ")", ".", "normal_", "(", "0", ",", "std", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "self", ".", "padding", "=", "[", "filter_size", "//", "2", "]", "*", "dimension", "*", "2", "\n", "# Construct lookup table for 1d kernel position to position in nd", "\n", "kernel_indices", "=", "torch", ".", "stack", "(", "torch", ".", "meshgrid", "(", "[", "torch", ".", "arange", "(", "filter_size", ")", "for", "_", "in", "range", "(", "dimension", ")", "]", ")", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "kernel_indices", "=", "kernel_indices", ".", "reshape", "(", "[", "self", ".", "filter_volume", ",", "dimension", "]", ")", ".", "to", "(", "device", ")", "\n", "\n", "self", ".", "output_feature_map", "=", "None", "\n", "self", ".", "old_input_feature_map", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.forward": [[41, 138], ["conv_layer_2D.asynSparseConvolution2D.checkInputArguments", "list", "update_location.split", "feature_map.double.double.double", "conv_layer_2D.asynSparseConvolution2D.old_input_feature_map.double", "conv_layer_2D.asynSparseConvolution2D.output_feature_map.double", "torch.tensor", "torch.cat", "range", "feature_map.double.double.clone", "output_feature_map.view.view.clone", "torch.zeros().to", "torch.zeros().to", "torch.squeeze().to", "torch.squeeze", "torch.zeros().bool", "update_location.nelement", "conv_layer_2D.asynSparseConvolution2D.updateRuleBooks", "torch.empty", "torch.stack().long().split", "torch.stack().long().split", "torch.matmul().squeeze", "torch.cat", "flattend_indices.sum.sum.sum", "output_feature_map.view.view.view", "output_feature_map.view.view.index_add_", "output_feature_map.view.view.view", "torch.unsqueeze", "len", "torch.empty", "torch.stack", "torch.ones", "len", "torch.squeeze", "torch.unsqueeze", "range", "range", "torch.zeros", "torch.zeros", "torch.squeeze", "torch.sum", "torch.zeros", "torch.stack().long", "torch.stack().long", "torch.squeeze", "torch.matmul", "conv_layer_2D.asynSparseConvolution2D.weight[].double", "torch.stack", "torch.stack", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.checkInputArguments", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.updateRuleBooks"], ["", "def", "forward", "(", "self", ",", "update_location", ",", "feature_map", ",", "active_sites_map", "=", "None", ",", "rule_book_input", "=", "None", ",", "rule_book_output", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Computes the a asynchronous sparse convolution layer based on the update_location\n\n        :param update_location: tensor with shape [N_active, dimension]\n        :param feature_map: tensor with shape [N, nIn]\n        :param active_sites_map: tensor with shape [N]. Includes 1 - active side and 2 - location stored in Rulebooks,\n                                  3 - new active site in input. 4 - new inactive site\n        :param rule_book_input: list containing #(kernel_size) lists with locations in the input\n        :param rule_book_output: list containing #(kernel_size) lists with locations in the output\n        :return:\n        \"\"\"", "\n", "self", ".", "checkInputArguments", "(", "update_location", ",", "feature_map", ",", "active_sites_map", ")", "\n", "spatial_dimension", "=", "list", "(", "feature_map", ".", "shape", "[", ":", "-", "1", "]", ")", "\n", "update_location_indices", "=", "update_location", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "\n", "if", "rule_book_input", "is", "None", ":", "\n", "            ", "rule_book_input", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "filter_size", "**", "self", ".", "dimension", ")", "]", "\n", "rule_book_output", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "filter_size", "**", "self", ".", "dimension", ")", "]", "\n", "", "if", "self", ".", "output_feature_map", "is", "None", ":", "\n", "            ", "self", ".", "output_feature_map", "=", "torch", ".", "zeros", "(", "spatial_dimension", "+", "[", "self", ".", "nOut", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "self", ".", "old_input_feature_map", "is", "None", ":", "\n", "            ", "self", ".", "old_input_feature_map", "=", "torch", ".", "zeros", "(", "spatial_dimension", "+", "[", "self", ".", "nIn", "]", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "active_sites_map", "is", "None", ":", "\n", "            ", "active_sites_map", "=", "torch", ".", "squeeze", "(", "(", "torch", ".", "sum", "(", "feature_map", "**", "2", ",", "dim", "=", "-", "1", ")", "!=", "0", ")", ".", "float", "(", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# Catch case if input feature is reduced to zero", "\n", "active_sites_map", "[", "update_location_indices", "]", "=", "Sites", ".", "ACTIVE_SITE", ".", "value", "\n", "\n", "", "if", "self", ".", "first_layer", ":", "\n", "# Set new deactivate sites to Sites.NEW_INACTIVE_SITE", "\n", "            ", "zero_input_update", "=", "torch", ".", "squeeze", "(", "torch", ".", "sum", "(", "feature_map", "[", "update_location_indices", "]", "**", "2", ",", "dim", "=", "-", "1", ")", "==", "0", ",", "dim", "=", "-", "1", ")", "\n", "bool_new_active_site", "=", "(", "self", ".", "old_input_feature_map", "[", "update_location_indices", "]", "**", "2", ")", ".", "sum", "(", "-", "1", ")", ".", "squeeze", "(", "-", "1", ")", "==", "0", "\n", "", "else", ":", "\n", "            ", "zero_input_update", "=", "None", "\n", "bool_new_active_site", "=", "torch", ".", "zeros", "(", "[", "update_location", ".", "shape", "[", "0", "]", "]", ")", ".", "bool", "(", ")", "\n", "\n", "", "if", "update_location", ".", "nelement", "(", ")", "!=", "0", ":", "\n", "            ", "out", "=", "self", ".", "updateRuleBooks", "(", "active_sites_map", ",", "update_location", ",", "bool_new_active_site", ",", "zero_input_update", ",", "\n", "rule_book_input", ",", "rule_book_output", ",", "update_location_indices", ")", "\n", "rule_book_input", ",", "rule_book_output", ",", "new_update_events", ",", "active_sites_map", "=", "out", "\n", "\n", "# New update sites for next layer", "\n", "if", "len", "(", "new_update_events", ")", "==", "0", ":", "\n", "                ", "new_update_events", "=", "torch", ".", "empty", "(", "[", "0", ",", "self", ".", "dimension", "]", ")", "\n", "", "else", ":", "\n", "                ", "new_update_events", "=", "torch", ".", "stack", "(", "new_update_events", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "new_update_events", "=", "torch", ".", "empty", "(", "[", "0", ",", "self", ".", "dimension", "]", ")", "\n", "\n", "# Compute update step with the rule book", "\n", "# Change to float64 for numerical stability", "\n", "", "feature_map", "=", "feature_map", ".", "double", "(", ")", "\n", "old_input_feature_map", "=", "self", ".", "old_input_feature_map", ".", "double", "(", ")", "\n", "output_feature_map", "=", "self", ".", "output_feature_map", ".", "double", "(", ")", "\n", "\n", "# Create vector for ravel the 2D indices to 1D flattened indices", "\n", "# Only valid for 2D", "\n", "flattened_indices_dim", "=", "torch", ".", "tensor", "(", "feature_map", ".", "shape", "[", ":", "-", "1", "]", ",", "device", "=", "self", ".", "device", ")", "\n", "flattened_indices_dim", "=", "torch", ".", "cat", "(", "(", "flattened_indices_dim", "[", "1", ":", "]", ",", "\n", "torch", ".", "ones", "(", "[", "1", "]", ",", "dtype", "=", "torch", ".", "long", ",", "device", "=", "self", ".", "device", ")", ")", ")", "\n", "\n", "for", "i_kernel", "in", "range", "(", "self", ".", "filter_volume", ")", ":", "\n", "            ", "if", "len", "(", "rule_book_input", "[", "i_kernel", "]", ")", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "input_indices", "=", "torch", ".", "stack", "(", "rule_book_input", "[", "i_kernel", "]", ",", "dim", "=", "0", ")", ".", "long", "(", ")", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "output_indices", "=", "torch", ".", "stack", "(", "rule_book_output", "[", "i_kernel", "]", ",", "dim", "=", "0", ")", ".", "long", "(", ")", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "\n", "bool_not_new_sites", "=", "(", "active_sites_map", "[", "output_indices", "]", "!=", "Sites", ".", "NEW_ACTIVE_SITE", ".", "value", ")", ".", "float", "(", ")", "\n", "\n", "delta_feature", "=", "torch", ".", "squeeze", "(", "feature_map", "[", "input_indices", "]", ",", "1", ")", "-", "torch", ".", "squeeze", "(", "old_input_feature_map", "[", "input_indices", "]", ",", "1", ")", "*", "bool_not_new_sites", "\n", "update_term", "=", "torch", ".", "matmul", "(", "delta_feature", "[", ":", ",", "None", ",", ":", "]", ",", "\n", "self", ".", "weight", "[", "None", ",", "i_kernel", ",", ":", ",", ":", "]", ".", "double", "(", ")", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "\n", "flattend_indices", "=", "torch", ".", "cat", "(", "output_indices", ",", "dim", "=", "-", "1", ")", "\n", "flattend_indices", "=", "flattend_indices", "*", "torch", ".", "unsqueeze", "(", "flattened_indices_dim", ",", "dim", "=", "0", ")", "\n", "flattend_indices", "=", "flattend_indices", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n", "output_feature_map", "=", "output_feature_map", ".", "view", "(", "[", "-", "1", ",", "self", ".", "nOut", "]", ")", "\n", "# .index_add_ might not work if gradients are needed", "\n", "output_feature_map", ".", "index_add_", "(", "dim", "=", "0", ",", "index", "=", "flattend_indices", ",", "source", "=", "update_term", ")", "\n", "output_feature_map", "=", "output_feature_map", ".", "view", "(", "spatial_dimension", "+", "[", "self", ".", "nOut", "]", ")", "\n", "\n", "# Set deactivated update sites in the output to zero, but keep it in the rulebook for the next layers", "\n", "", "output_feature_map", "=", "output_feature_map", "*", "torch", ".", "unsqueeze", "(", "(", "active_sites_map", "!=", "Sites", ".", "NEW_INACTIVE_SITE", ".", "value", ")", ".", "float", "(", ")", ",", "-", "1", ")", "\n", "if", "self", ".", "use_bias", ":", "\n", "            ", "output_feature_map", "[", "active_sites_map", "==", "Sites", ".", "NEW_ACTIVE_SITE", ".", "value", "]", "+=", "self", ".", "bias", "\n", "\n", "", "del", "self", ".", "old_input_feature_map", "\n", "del", "self", ".", "output_feature_map", "\n", "self", ".", "old_input_feature_map", "=", "feature_map", ".", "clone", "(", ")", "\n", "self", ".", "output_feature_map", "=", "output_feature_map", ".", "clone", "(", ")", "\n", "\n", "return", "new_update_events", ",", "output_feature_map", ",", "active_sites_map", ",", "rule_book_input", ",", "rule_book_output", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.updateRuleBooks": [[139, 213], ["torch.nn.functional.pad", "torch.squeeze", "active_sites_to_update.nonzero.nonzero.nonzero", "update_location[].clone", "output_locations.split", "torch.arange", "rule_book_output[].append", "rule_book_input[].append", "bool_new_active_site.nelement", "kernel_update_location[].split", "new_active_sites_influence.nonzero.nonzero.nonzero", "range", "new_update_events.append", "update_location[].split", "shifted_update_location.split", "bool_new_active_site.sum", "rule_book_output[].append", "rule_book_input[].append", "kernel_update_location.split", "update_location[].split", "output_location.clone"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "def", "updateRuleBooks", "(", "self", ",", "active_sites_map", ",", "update_location", ",", "bool_new_active_site", ",", "zero_input_update", ",", "\n", "rule_book_input", ",", "rule_book_output", ",", "update_location_indices", ")", ":", "\n", "        ", "\"\"\"Updates the rule books used for the weight multiplication\"\"\"", "\n", "\n", "# Pad input to index with kernel", "\n", "padded_active_sites_map", "=", "torch", ".", "nn", ".", "functional", ".", "pad", "(", "active_sites_map", ",", "self", ".", "padding", ",", "mode", "=", "'constant'", ",", "value", "=", "0", ")", "\n", "shifted_update_location", "=", "update_location", "+", "(", "self", ".", "filter_size_tensor", "//", "2", ")", "[", "None", ",", ":", "]", "\n", "\n", "# Compute indices corresponding to the receptive fields of the update location", "\n", "kernel_update_location", "=", "shifted_update_location", "[", ":", ",", "None", ",", ":", "]", "+", "self", ".", "kernel_indices", "[", "None", ",", ":", ",", ":", "]", "-", "self", ".", "filter_size", "//", "2", "\n", "\n", "active_sites_to_update", "=", "torch", ".", "squeeze", "(", "padded_active_sites_map", "[", "kernel_update_location", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "active_sites_to_update", "=", "active_sites_to_update", ".", "nonzero", "(", ")", "\n", "\n", "# Set updated sites to 2", "\n", "active_sites_map", "[", "update_location_indices", "]", "=", "Sites", ".", "UPDATED_SITE", ".", "value", "\n", "\n", "if", "self", ".", "first_layer", ":", "\n", "# Set new deactivate sites to Sites.NEW_INACTIVE_SITE", "\n", "            ", "active_sites_map", "[", "update_location", "[", "zero_input_update", "]", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "Sites", ".", "NEW_INACTIVE_SITE", ".", "value", "\n", "\n", "", "new_update_events", "=", "[", "]", "\n", "\n", "position_kernels", "=", "self", ".", "filter_volume", "-", "1", "-", "active_sites_to_update", "[", ":", ",", "1", "]", "\n", "input_locations", "=", "update_location", "[", "active_sites_to_update", "[", ":", ",", "0", "]", ",", ":", "]", ".", "clone", "(", ")", "\n", "nd_kernel_positions", "=", "self", ".", "kernel_indices", "[", "position_kernels", "]", "\n", "output_locations", "=", "input_locations", "+", "self", ".", "filter_size", "//", "2", "-", "nd_kernel_positions", "\n", "output_location_indices_i", ",", "output_location_indices_j", "=", "output_locations", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "output_active_sites", "=", "active_sites_map", "[", "output_locations", "[", "...", ",", "0", "]", ",", "output_locations", "[", "...", ",", "1", "]", "]", "\n", "\n", "# Compute Rule Book", "\n", "i_active_sites", "=", "torch", ".", "arange", "(", "active_sites_to_update", ".", "shape", "[", "0", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "i_active_sites", "=", "i_active_sites", "[", "(", "output_active_sites", "!=", "Sites", ".", "NEW_ACTIVE_SITE", ".", "value", ")", "&", "(", "output_active_sites", "!=", "Sites", ".", "NEW_INACTIVE_SITE", ".", "value", ")", "]", "\n", "for", "i_active_site", "in", "i_active_sites", ":", "\n", "            ", "output_active_site", "=", "active_sites_map", "[", "output_location_indices_i", "[", "i_active_site", "]", ",", "\n", "output_location_indices_j", "[", "i_active_site", "]", "]", "\n", "\n", "rule_book_output", "[", "position_kernels", "[", "i_active_site", "]", "]", ".", "append", "(", "output_locations", "[", "i_active_site", "]", ")", "\n", "rule_book_input", "[", "position_kernels", "[", "i_active_site", "]", "]", ".", "append", "(", "input_locations", "[", "i_active_site", "]", ")", "\n", "\n", "if", "output_active_site", "==", "Sites", ".", "ACTIVE_SITE", ".", "value", ":", "\n", "                ", "new_update_events", ".", "append", "(", "output_locations", "[", "i_active_site", "]", ")", "\n", "active_sites_map", "[", "output_location_indices_i", "[", "i_active_site", "]", ",", "\n", "output_location_indices_j", "[", "i_active_site", "]", "]", "=", "Sites", ".", "UPDATED_SITE", ".", "value", "\n", "active_sites_map", "[", "output_locations", "[", "i_active_site", ",", "...", ",", "0", "]", ",", "\n", "output_locations", "[", "i_active_site", ",", "...", ",", "1", "]", "]", "=", "Sites", ".", "UPDATED_SITE", ".", "value", "\n", "\n", "# Set newly initialised sites to 3 equal to Sites.NEW_ACTIVE_SITE", "\n", "", "", "active_sites_map", "[", "update_location", "[", "bool_new_active_site", "]", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "Sites", ".", "NEW_ACTIVE_SITE", ".", "value", "\n", "\n", "# Update neuron if it is first time active. Exclude points, which influence is propagated at same time step", "\n", "padded_active_sites_map", "[", "shifted_update_location", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "0", "\n", "\n", "# Update the influence from the active sites in the receptive field, if the site is newly active", "\n", "if", "bool_new_active_site", ".", "nelement", "(", ")", "!=", "0", ":", "\n", "# Return if no new activate site are given as input", "\n", "            ", "if", "bool_new_active_site", ".", "sum", "(", ")", "==", "0", ":", "\n", "                ", "return", "rule_book_input", ",", "rule_book_output", ",", "new_update_events", ",", "active_sites_map", "\n", "\n", "", "new_active_site_influence_indices", "=", "kernel_update_location", "[", "bool_new_active_site", ",", ":", "]", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "new_active_sites_influence", "=", "padded_active_sites_map", "[", "new_active_site_influence_indices", "]", "\n", "new_active_sites_influence", "=", "new_active_sites_influence", ".", "nonzero", "(", ")", "\n", "\n", "for", "i_new_active_site", "in", "range", "(", "new_active_sites_influence", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "position_kernel", "=", "new_active_sites_influence", "[", "i_new_active_site", ",", "1", "]", "\n", "output_location", "=", "update_location", "[", "bool_new_active_site", "]", "[", "new_active_sites_influence", "[", "i_new_active_site", ",", "0", "]", ",", ":", "]", "\n", "input_location", "=", "output_location", "-", "self", ".", "filter_size", "//", "2", "+", "self", ".", "kernel_indices", "[", "position_kernel", "]", "\n", "\n", "rule_book_output", "[", "position_kernel", "]", ".", "append", "(", "output_location", ".", "clone", "(", ")", ")", "\n", "rule_book_input", "[", "position_kernel", "]", ".", "append", "(", "input_location", ")", "\n", "\n", "", "", "return", "rule_book_input", ",", "rule_book_output", ",", "new_update_events", ",", "active_sites_map", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D.asynSparseConvolution2D.checkInputArguments": [[214, 227], ["ValueError", "ValueError", "ValueError", "list", "list", "list"], "methods", ["None"], ["", "def", "checkInputArguments", "(", "self", ",", "update_location", ",", "feature_map", ",", "active_sites_map", ")", ":", "\n", "        ", "\"\"\"Checks if the input arguments have the correct shape\"\"\"", "\n", "if", "update_location", ".", "ndim", "!=", "2", "or", "update_location", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "dimension", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected update_location to have shape [N, %s]. Got size %s'", "%", "\n", "(", "self", ".", "dimension", ",", "list", "(", "update_location", ".", "shape", ")", ")", ")", "\n", "", "if", "feature_map", ".", "ndim", "!=", "self", ".", "dimension", "+", "1", "or", "feature_map", ".", "shape", "[", "-", "1", "]", "!=", "self", ".", "nIn", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected feature_map to have shape [Spatial_1, Spatial_2, ..., %s]. Got size %s'", "%", "\n", "(", "self", ".", "nIn", ",", "list", "(", "feature_map", ".", "shape", ")", ")", ")", "\n", "", "if", "active_sites_map", "is", "None", ":", "\n", "            ", "return", "\n", "", "if", "active_sites_map", ".", "ndim", "!=", "self", ".", "dimension", ":", "\n", "            ", "raise", "ValueError", "(", "'Expected active_sites_map to have %s dimensions. Got size %s'", "%", "\n", "(", "self", ".", "dimension", ",", "list", "(", "active_sites_map", ".", "shape", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.__init__": [[7, 15], ["async_sparse.AsynSparseConvolution2D"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dimension", ",", "nIn", ",", "nOut", ",", "filter_size", ",", "first_layer", "=", "False", ",", "use_bias", "=", "False", ",", "debug", "=", "False", ")", ":", "\n", "        ", "self", ".", "conv", "=", "AsynSparseConvolution2D", "(", "dimension", ",", "nIn", ",", "nOut", ",", "filter_size", ",", "first_layer", ",", "use_bias", ",", "debug", ")", "\n", "\n", "self", ".", "nIn", "=", "nIn", "\n", "self", ".", "nOut", "=", "nOut", "\n", "self", ".", "filter_size", "=", "filter_size", "\n", "self", ".", "dimension", "=", "dimension", "\n", "self", ".", "first_layer", "=", "first_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.setParameters": [[16, 20], ["weights.reshape().astype.reshape().astype.reshape().astype", "bias.reshape().astype.reshape().astype.reshape().astype", "conv_layer_2D_cpp.asynSparseConvolution2Dcpp.conv.setParameters", "weights.reshape().astype.reshape().astype.reshape", "bias.reshape().astype.reshape().astype.reshape"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.setParameters"], ["", "def", "setParameters", "(", "self", ",", "weights", ",", "bias", ")", ":", "\n", "        ", "weights", "=", "weights", ".", "reshape", "(", "self", ".", "filter_size", "**", "self", ".", "dimension", ",", "self", ".", "nIn", "*", "self", ".", "nOut", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "bias", "=", "bias", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "self", ".", "conv", ".", "setParameters", "(", "bias", ",", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.forward": [[21, 59], ["tuple", "numpy.array", "numpy.asfortranarray", "numpy.asfortranarray", "feature_map.reshape().astype.reshape().astype.reshape().astype", "conv_layer_2D_cpp.asynSparseConvolution2Dcpp.conv.forward", "output_map.reshape.reshape.reshape", "active_sites_map.flatten.flatten.reshape", "numpy.zeros", "conv_layer_2D_cpp.asynSparseConvolution2Dcpp.conv.initMaps", "conv_layer_2D_cpp.asynSparseConvolution2Dcpp.conv.initActiveMap", "async_sparse.RuleBook", "conv_layer_2D_cpp.asynSparseConvolution2Dcpp.conv.initMaps", "active_sites_map.flatten.flatten.flatten", "feature_map.reshape().astype.reshape().astype.reshape"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward"], ["", "def", "forward", "(", "self", ",", "update_location", ",", "feature_map", ",", "active_sites_map", "=", "None", ",", "rule_book", "=", "None", ")", ":", "\n", "        ", "spatial_dimension", "=", "tuple", "(", "feature_map", ".", "shape", "[", ":", "2", "]", ")", "\n", "H", ",", "W", "=", "spatial_dimension", "\n", "\n", "no_updates", "=", "False", "\n", "if", "update_location", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "no_updates", "=", "True", "\n", "update_location", "=", "np", ".", "zeros", "(", "[", "1", ",", "2", "]", ")", "\n", "# wrap update locations in fortran array", "\n", "", "update_location", "=", "np", ".", "array", "(", "update_location", ",", "dtype", "=", "\"int32\"", ")", "\n", "update_location", "=", "np", ".", "asfortranarray", "(", "update_location", ")", "\n", "\n", "# prepare input feature map", "\n", "feature_map", "=", "np", ".", "asfortranarray", "(", "feature_map", ")", "\n", "feature_map", "=", "feature_map", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "nIn", ")", ")", ".", "astype", "(", "\"float32\"", ")", "\n", "\n", "if", "self", ".", "first_layer", ":", "\n", "            ", "self", ".", "conv", ".", "initMaps", "(", "H", ",", "W", ")", "\n", "active_sites_map", "=", "self", ".", "conv", ".", "initActiveMap", "(", "feature_map", ",", "update_location", ")", "\n", "rule_book", "=", "RuleBook", "(", "H", ",", "W", ",", "self", ".", "filter_size", ",", "self", ".", "dimension", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv", ".", "initMaps", "(", "H", ",", "W", ")", "\n", "# active_sites_map = self.conv.initActiveMap(feature_map, update_location)", "\n", "active_sites_map", "=", "active_sites_map", ".", "flatten", "(", ")", "\n", "\n", "# t1 = perf_counter()", "\n", "", "new_update_locations", ",", "output_map", ",", "active_sites_map", "=", "self", ".", "conv", ".", "forward", "(", "update_location", ",", "\n", "feature_map", ",", "\n", "active_sites_map", ",", "\n", "rule_book", ",", "\n", "no_updates", ")", "\n", "# dt = perf_counter() - t1", "\n", "# print(\"CPP implementation: \", dt)", "\n", "\n", "output_map", "=", "output_map", ".", "reshape", "(", "(", "H", ",", "W", ",", "self", ".", "nOut", ")", ")", "\n", "active_sites_map", "=", "active_sites_map", ".", "reshape", "(", "spatial_dimension", ")", "\n", "\n", "return", "new_update_locations", ",", "output_map", ",", "active_sites_map", ",", "rule_book", "", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.get_pybind_include.__init__": [[16, 18], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "user", "=", "False", ")", ":", "\n", "        ", "self", ".", "user", "=", "user", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.get_pybind_include.__str__": [[19, 22], ["pybind11.get_include"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "import", "pybind11", "\n", "return", "pybind11", ".", "get_include", "(", "self", ".", "user", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.BuildExt.build_extensions": [[84, 99], ["setuptools.setup.BuildExt.c_opts.get", "setuptools.setup.BuildExt.l_opts.get", "setuptools.command.build_ext.build_ext.build_extensions", "setuptools.setup.BuildExt.append", "setuptools.setup.BuildExt.append", "setup.has_flag", "setup.cpp_flag", "setuptools.setup.BuildExt.append", "setuptools.setup.BuildExt.append", "setuptools.setup.BuildExt.distribution.get_version", "setuptools.setup.BuildExt.distribution.get_version"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.BuildExt.build_extensions", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.has_flag", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.cpp_flag"], ["", "def", "build_extensions", "(", "self", ")", ":", "\n", "        ", "ct", "=", "self", ".", "compiler", ".", "compiler_type", "\n", "opts", "=", "self", ".", "c_opts", ".", "get", "(", "ct", ",", "[", "]", ")", "\n", "link_opts", "=", "self", ".", "l_opts", ".", "get", "(", "ct", ",", "[", "]", ")", "\n", "if", "ct", "==", "'unix'", ":", "\n", "            ", "opts", ".", "append", "(", "'-DVERSION_INFO=\"%s\"'", "%", "self", ".", "distribution", ".", "get_version", "(", ")", ")", "\n", "opts", ".", "append", "(", "cpp_flag", "(", "self", ".", "compiler", ")", ")", "\n", "if", "has_flag", "(", "self", ".", "compiler", ",", "'-fvisibility=hidden'", ")", ":", "\n", "                ", "opts", ".", "append", "(", "'-fvisibility=hidden'", ")", "\n", "", "", "elif", "ct", "==", "'msvc'", ":", "\n", "            ", "opts", ".", "append", "(", "'/DVERSION_INFO=\\\\\"%s\\\\\"'", "%", "self", ".", "distribution", ".", "get_version", "(", ")", ")", "\n", "", "for", "ext", "in", "self", ".", "extensions", ":", "\n", "            ", "ext", ".", "extra_compile_args", "=", "opts", "\n", "ext", ".", "extra_link_args", "=", "link_opts", "\n", "", "build_ext", ".", "build_extensions", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.has_flag": [[40, 52], ["tempfile.NamedTemporaryFile", "f.write", "compiler.compile"], "function", ["None"], ["def", "has_flag", "(", "compiler", ",", "flagname", ")", ":", "\n", "    ", "\"\"\"Return a boolean indicating whether a flag name is supported on\n    the specified compiler.\n    \"\"\"", "\n", "import", "tempfile", "\n", "with", "tempfile", ".", "NamedTemporaryFile", "(", "'w'", ",", "suffix", "=", "'.cpp'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'int main (int argc, char **argv) { return 0; }'", ")", "\n", "try", ":", "\n", "            ", "compiler", ".", "compile", "(", "[", "f", ".", "name", "]", ",", "extra_postargs", "=", "[", "flagname", "]", ")", "\n", "", "except", "setuptools", ".", "distutils", ".", "errors", ".", "CompileError", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.cpp_flag": [[54, 65], ["RuntimeError", "setup.has_flag"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.event_representation_tool.setup.has_flag"], ["", "def", "cpp_flag", "(", "compiler", ")", ":", "\n", "    ", "\"\"\"Return the -std=c++[11/14/17] compiler flag.\n\n    The newer version is prefered over c++11 (when it is available).\n    \"\"\"", "\n", "flags", "=", "[", "'-std=c++17'", ",", "'-std=c++14'", ",", "'-std=c++11'", "]", "\n", "\n", "for", "flag", "in", "flags", ":", "\n", "        ", "if", "has_flag", "(", "compiler", ",", "flag", ")", ":", "return", "flag", "\n", "\n", "", "raise", "RuntimeError", "(", "'Unsupported compiler -- at least C++11 support '", "\n", "'is needed!'", ")", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.tests.test.virtual_events": [[6, 32], ["numpy.sort().reshape", "numpy.concatenate", "numpy.sort", "numpy.random.random", "numpy.random.random", "numpy.random.random", "numpy.cos", "numpy.sin"], "function", ["None"], ["def", "virtual_events", "(", "optical_flow", ",", "N", ",", "circle_radius", ",", "starting_point", ",", "resolution", ")", ":", "\n", "    ", "\"\"\"\n    optical flow: 2 numbers, vx, vy denoting the flow in x and y direction.\n    N: Number of events\n    Example:\n        events = optical_flow([5, 6], 10000)\n    \"\"\"", "\n", "vx", ",", "vy", "=", "optical_flow", "\n", "\n", "# sample t and angle from uniform distribution", "\n", "time", "=", "np", ".", "sort", "(", "np", ".", "random", ".", "random", "(", "(", "N", ",", ")", ")", ")", ".", "reshape", "(", "(", "N", ",", "1", ")", ")", "\n", "angle", "=", "np", ".", "random", ".", "random", "(", "(", "N", ",", "1", ")", ")", "*", "2", "*", "np", ".", "pi", "\n", "polarity", "=", "2", "*", "(", "np", ".", "random", ".", "random", "(", "(", "N", ",", "1", ")", ")", ">", ".5", ")", "-", "1", "\n", "\n", "# compute coordinates", "\n", "u0", ",", "v0", "=", "starting_point", "\n", "x", "=", "(", "u0", "+", "time", "*", "vx", "+", "np", ".", "cos", "(", "angle", ")", "*", "circle_radius", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "y", "=", "(", "v0", "+", "time", "*", "vy", "+", "np", ".", "sin", "(", "angle", ")", "*", "circle_radius", ")", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n", "# compute mask for events that are within image", "\n", "H", ",", "W", "=", "resolution", "\n", "mask", "=", "(", "x", "[", ":", ",", "0", "]", ">=", "0", ")", "&", "(", "y", "[", ":", ",", "0", "]", ">=", "0", ")", "&", "(", "x", "[", ":", ",", "0", "]", "<", "W", ")", "&", "(", "y", "[", ":", ",", "0", "]", "<", "H", ")", "\n", "\n", "events", "=", "np", ".", "concatenate", "(", "[", "x", "[", "mask", ",", ":", "]", ",", "y", "[", "mask", ",", ":", "]", ",", "time", "[", "mask", ",", ":", "]", ",", "polarity", "[", "mask", ",", ":", "]", "]", ",", "1", ")", "\n", "\n", "return", "events", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.__init__": [[24, 71], ["dataloader.dataset.getDataloader", "torch.utils.tensorboard.SummaryWriter", "torch.utils.tensorboard.SummaryWriter", "torch.utils.tensorboard.SummaryWriter", "trainer.AbstractTrainer.createDatasets", "trainer.AbstractTrainer.buildModel", "torch.Adam", "torch.Adam", "torch.Adam", "numpy.zeros", "filter", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "torch.optim.lr_scheduler.MultiStepLR", "trainer.AbstractTrainer.loadCheckpoint", "trainer.AbstractTrainer.model.parameters"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.getDataloader", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.createDatasets", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.buildModel", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.loadCheckpoint"], ["    ", "def", "__init__", "(", "self", ",", "settings", ")", ":", "\n", "        ", "self", ".", "settings", "=", "settings", "\n", "\n", "self", ".", "model", "=", "None", "\n", "self", ".", "scheduler", "=", "None", "\n", "self", ".", "nr_classes", "=", "None", "\n", "self", ".", "val_loader", "=", "None", "\n", "self", ".", "train_loader", "=", "None", "\n", "self", ".", "nr_val_epochs", "=", "None", "\n", "self", ".", "bounding_boxes", "=", "None", "\n", "self", ".", "object_classes", "=", "None", "\n", "self", ".", "nr_train_epochs", "=", "None", "\n", "self", ".", "model_input_size", "=", "None", "\n", "\n", "if", "self", ".", "settings", ".", "event_representation", "==", "'histogram'", ":", "\n", "            ", "self", ".", "nr_input_channels", "=", "2", "\n", "", "elif", "self", ".", "settings", ".", "event_representation", "==", "'event_queue'", ":", "\n", "            ", "self", ".", "nr_input_channels", "=", "30", "\n", "\n", "", "self", ".", "dataset_builder", "=", "dataloader", ".", "dataset", ".", "getDataloader", "(", "self", ".", "settings", ".", "dataset_name", ")", "\n", "self", ".", "dataset_loader", "=", "Loader", "\n", "\n", "self", ".", "writer", "=", "SummaryWriter", "(", "self", ".", "settings", ".", "ckpt_dir", ")", "\n", "self", ".", "createDatasets", "(", ")", "\n", "\n", "self", ".", "buildModel", "(", ")", "\n", "self", ".", "optimizer", "=", "optim", ".", "Adam", "(", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ",", "\n", "lr", "=", "self", ".", "settings", ".", "init_lr", ")", "\n", "\n", "if", "settings", ".", "steps_lr", "is", "not", "None", ":", "\n", "            ", "self", ".", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "MultiStepLR", "(", "self", ".", "optimizer", ",", "milestones", "=", "settings", ".", "steps_lr", ",", "\n", "gamma", "=", "settings", ".", "factor_lr", ")", "\n", "", "if", "settings", ".", "resume_training", ":", "\n", "            ", "self", ".", "loadCheckpoint", "(", "self", ".", "settings", ".", "resume_ckpt_file", ")", "\n", "\n", "", "self", ".", "batch_step", "=", "0", "\n", "self", ".", "epoch_step", "=", "0", "\n", "self", ".", "training_loss", "=", "0", "\n", "self", ".", "val_batch_step", "=", "0", "\n", "self", ".", "validation_loss", "=", "0", "\n", "self", ".", "training_accuracy", "=", "0", "\n", "self", ".", "validation_accuracy", "=", "0", "\n", "self", ".", "max_validation_accuracy", "=", "0", "\n", "self", ".", "val_confusion_matrix", "=", "np", ".", "zeros", "(", "[", "self", ".", "nr_classes", ",", "self", ".", "nr_classes", "]", ")", "\n", "\n", "# tqdm progress bar", "\n", "self", ".", "pbar", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.buildModel": [[72, 76], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Model is constructed in child class\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.createDatasets": [[77, 109], ["trainer.AbstractTrainer.dataset_builder", "trainer.AbstractTrainer.dataset_builder", "trainer.AbstractTrainer.dataset_loader", "trainer.AbstractTrainer.dataset_loader", "int", "int"], "methods", ["None"], ["", "def", "createDatasets", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Creates the validation and the training data based on the lists specified in the config/settings.yaml file.\n        \"\"\"", "\n", "train_dataset", "=", "self", ".", "dataset_builder", "(", "self", ".", "settings", ".", "dataset_path", ",", "\n", "self", ".", "settings", ".", "object_classes", ",", "\n", "self", ".", "settings", ".", "height", ",", "\n", "self", ".", "settings", ".", "width", ",", "\n", "self", ".", "settings", ".", "nr_events_window", ",", "\n", "augmentation", "=", "True", ",", "\n", "mode", "=", "'training'", ",", "\n", "event_representation", "=", "self", ".", "settings", ".", "event_representation", ")", "\n", "\n", "self", ".", "nr_train_epochs", "=", "int", "(", "train_dataset", ".", "nr_samples", "/", "self", ".", "settings", ".", "batch_size", ")", "+", "1", "\n", "self", ".", "nr_classes", "=", "train_dataset", ".", "nr_classes", "\n", "self", ".", "object_classes", "=", "train_dataset", ".", "object_classes", "\n", "\n", "val_dataset", "=", "self", ".", "dataset_builder", "(", "self", ".", "settings", ".", "dataset_path", ",", "\n", "self", ".", "settings", ".", "object_classes", ",", "\n", "self", ".", "settings", ".", "height", ",", "\n", "self", ".", "settings", ".", "width", ",", "\n", "self", ".", "settings", ".", "nr_events_window", ",", "\n", "mode", "=", "'validation'", ",", "\n", "event_representation", "=", "self", ".", "settings", ".", "event_representation", ")", "\n", "self", ".", "nr_val_epochs", "=", "int", "(", "val_dataset", ".", "nr_samples", "/", "self", ".", "settings", ".", "batch_size", ")", "+", "1", "\n", "\n", "self", ".", "train_loader", "=", "self", ".", "dataset_loader", "(", "train_dataset", ",", "batch_size", "=", "self", ".", "settings", ".", "batch_size", ",", "\n", "device", "=", "self", ".", "settings", ".", "gpu_device", ",", "\n", "num_workers", "=", "self", ".", "settings", ".", "num_cpu_workers", ",", "pin_memory", "=", "False", ")", "\n", "self", ".", "val_loader", "=", "self", ".", "dataset_loader", "(", "val_dataset", ",", "batch_size", "=", "self", ".", "settings", ".", "batch_size", ",", "\n", "device", "=", "self", ".", "settings", ".", "gpu_device", ",", "\n", "num_workers", "=", "self", ".", "settings", ".", "num_cpu_workers", ",", "pin_memory", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse": [[110, 126], ["torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.nonzero.split", "torch.nonzero.split", "torch.nonzero.split", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "denseToSparse", "(", "dense_tensor", ")", ":", "\n", "        ", "\"\"\"\n        Converts a dense tensor to a sparse vector.\n\n        :param dense_tensor: BatchSize x SpatialDimension_1 x SpatialDimension_2 x ... x FeatureDimension\n        :return locations: NumberOfActive x (SumSpatialDimensions + 1). The + 1 includes the batch index\n        :return features: NumberOfActive x FeatureDimension\n        \"\"\"", "\n", "non_zero_indices", "=", "torch", ".", "nonzero", "(", "torch", ".", "abs", "(", "dense_tensor", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", ")", "\n", "locations", "=", "torch", ".", "cat", "(", "(", "non_zero_indices", "[", ":", ",", "1", ":", "]", ",", "non_zero_indices", "[", ":", ",", "0", ",", "None", "]", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "select_indices", "=", "non_zero_indices", ".", "split", "(", "1", ",", "dim", "=", "1", ")", "\n", "features", "=", "torch", ".", "squeeze", "(", "dense_tensor", "[", "select_indices", "]", ",", "dim", "=", "-", "2", ")", "\n", "\n", "return", "locations", ",", "features", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.resetValidation": [[127, 133], ["numpy.zeros"], "methods", ["None"], ["", "def", "resetValidation", "(", "self", ")", ":", "\n", "        ", "\"\"\"Resets all the validation statistics to zero\"\"\"", "\n", "self", ".", "val_batch_step", "=", "0", "\n", "self", ".", "validation_loss", "=", "0", "\n", "self", ".", "validation_accuracy", "=", "0", "\n", "self", ".", "val_confusion_matrix", "=", "np", ".", "zeros", "(", "[", "self", ".", "nr_classes", ",", "self", ".", "nr_classes", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveValidationStatistics": [[134, 144], ["trainer.AbstractTrainer.writer.add_scalar", "trainer.AbstractTrainer.writer.add_scalar", "utils.visualizeConfusionMatrix", "trainer.AbstractTrainer.writer.add_image", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeConfusionMatrix"], ["", "def", "saveValidationStatistics", "(", "self", ")", ":", "\n", "        ", "\"\"\"Saves the recorded validation statistics to an event file (tensorboard)\"\"\"", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Validation/Validation_Loss'", ",", "self", ".", "validation_loss", ",", "self", ".", "epoch_step", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Validation/Validation_Accuracy'", ",", "self", ".", "validation_accuracy", ",", "self", ".", "epoch_step", ")", "\n", "\n", "self", ".", "val_confusion_matrix", "=", "self", ".", "val_confusion_matrix", "/", "(", "np", ".", "sum", "(", "self", ".", "val_confusion_matrix", ",", "axis", "=", "-", "1", ",", "\n", "keepdims", "=", "True", ")", "+", "1e-9", ")", "\n", "plot_confusion_matrix", "=", "visualizations", ".", "visualizeConfusionMatrix", "(", "self", ".", "val_confusion_matrix", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Validation/Confusion_Matrix'", ",", "plot_confusion_matrix", ",", "self", ".", "epoch_step", ",", "\n", "dataformats", "=", "'HWC'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.storeLossesObjectDetection": [[145, 153], ["range", "len", "loss_list[].data.cpu().numpy", "trainer.AbstractTrainer.writer.add_scalar", "loss_list[].data.cpu"], "methods", ["None"], ["", "def", "storeLossesObjectDetection", "(", "self", ",", "loss_list", ")", ":", "\n", "        ", "\"\"\"Writes the different losses to tensorboard\"\"\"", "\n", "loss_names", "=", "[", "'Overall_Loss'", ",", "'Offset_Loss'", ",", "'Shape_Loss'", ",", "'Confidence_Loss'", ",", "'Confidence_NoObject_Loss'", ",", "\n", "'Class_Loss'", "]", "\n", "\n", "for", "i_loss", "in", "range", "(", "len", "(", "loss_list", ")", ")", ":", "\n", "            ", "loss_value", "=", "loss_list", "[", "i_loss", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'TrainingLoss/'", "+", "loss_names", "[", "i_loss", "]", ",", "loss_value", ",", "self", ".", "batch_step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveBoundingBoxes": [[154, 181], ["trainer.AbstractTrainer.model_input_size.cpu().numpy", "range", "range", "range", "utils.statistics_pascalvoc.BoundingBox", "trainer.AbstractTrainer.bounding_boxes.addBoundingBox", "trainer.AbstractTrainer.model_input_size.cpu", "utils.statistics_pascalvoc.BoundingBox", "trainer.AbstractTrainer.bounding_boxes.addBoundingBox", "gt_bbox[].sum"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.addBoundingBox", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.addBoundingBox"], ["", "", "def", "saveBoundingBoxes", "(", "self", ",", "gt_bbox", ",", "detected_bbox", ")", ":", "\n", "        ", "\"\"\"\n        Saves the bounding boxes in the evaluation format\n\n        :param gt_bbox: gt_bbox[0, 0, :]: ['u', 'v', 'w', 'h', 'class_id']\n        :param detected_bbox[0, :]: [batch_idx, u, v, w, h, pred_class_id, pred_class_score, object score]\n        \"\"\"", "\n", "image_size", "=", "self", ".", "model_input_size", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "i_batch", "in", "range", "(", "gt_bbox", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "i_gt", "in", "range", "(", "gt_bbox", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "gt_bbox_sample", "=", "gt_bbox", "[", "i_batch", ",", "i_gt", ",", ":", "]", "\n", "id_image", "=", "self", ".", "val_batch_step", "*", "self", ".", "settings", ".", "batch_size", "+", "i_batch", "\n", "if", "gt_bbox", "[", "i_batch", ",", "i_gt", ",", ":", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "                    ", "break", "\n", "\n", "", "bb_gt", "=", "BoundingBox", "(", "id_image", ",", "gt_bbox_sample", "[", "-", "1", "]", ",", "gt_bbox_sample", "[", "0", "]", ",", "gt_bbox_sample", "[", "1", "]", ",", "\n", "gt_bbox_sample", "[", "2", "]", ",", "gt_bbox_sample", "[", "3", "]", ",", "image_size", ",", "BBType", ".", "GroundTruth", ")", "\n", "self", ".", "bounding_boxes", ".", "addBoundingBox", "(", "bb_gt", ")", "\n", "\n", "", "", "for", "i_det", "in", "range", "(", "detected_bbox", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "det_bbox_sample", "=", "detected_bbox", "[", "i_det", ",", ":", "]", "\n", "id_image", "=", "self", ".", "val_batch_step", "*", "self", ".", "settings", ".", "batch_size", "+", "det_bbox_sample", "[", "0", "]", "\n", "\n", "bb_det", "=", "BoundingBox", "(", "id_image", ",", "det_bbox_sample", "[", "5", "]", ",", "det_bbox_sample", "[", "1", "]", ",", "det_bbox_sample", "[", "2", "]", ",", "\n", "det_bbox_sample", "[", "3", "]", ",", "det_bbox_sample", "[", "4", "]", ",", "image_size", ",", "BBType", ".", "Detected", ",", "\n", "det_bbox_sample", "[", "6", "]", ")", "\n", "self", ".", "bounding_boxes", ".", "addBoundingBox", "(", "bb_det", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveValidationStatisticsObjectDetection": [[182, 198], ["utils.statistics_pascalvoc.VOC_Evaluator", "utils.statistics_pascalvoc.VOC_Evaluator.GetPascalVOCMetrics", "trainer.AbstractTrainer.writer.add_scalar", "trainer.AbstractTrainer.writer.add_scalar"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.VOC_Evaluator.GetPascalVOCMetrics"], ["", "", "def", "saveValidationStatisticsObjectDetection", "(", "self", ")", ":", "\n", "        ", "\"\"\"Saves the statistice relevant for object detection\"\"\"", "\n", "evaluator", "=", "VOC_Evaluator", "(", ")", "\n", "metrics", "=", "evaluator", ".", "GetPascalVOCMetrics", "(", "self", ".", "bounding_boxes", ",", "\n", "IOUThreshold", "=", "0.5", ",", "\n", "method", "=", "MethodAveragePrecision", ".", "EveryPointInterpolation", ")", "\n", "acc_AP", "=", "0", "\n", "total_positives", "=", "0", "\n", "for", "metricsPerClass", "in", "metrics", ":", "\n", "            ", "acc_AP", "+=", "metricsPerClass", "[", "'AP'", "]", "\n", "total_positives", "+=", "metricsPerClass", "[", "'total positives'", "]", "\n", "", "mAP", "=", "acc_AP", "/", "self", ".", "nr_classes", "\n", "self", ".", "validation_accuracy", "=", "mAP", "\n", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Validation/Validation_Loss'", ",", "self", ".", "validation_loss", ",", "self", ".", "epoch_step", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Validation/Validation_mAP'", ",", "self", ".", "validation_accuracy", ",", "self", ".", "epoch_step", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.getLearningRate": [[199, 202], ["None"], "methods", ["None"], ["", "def", "getLearningRate", "(", "self", ")", ":", "\n", "        ", "for", "param_group", "in", "self", ".", "optimizer", ".", "param_groups", ":", "\n", "            ", "return", "param_group", "[", "'lr'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.loadCheckpoint": [[203, 213], ["os.path.isfile", "print", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "trainer.AbstractTrainer.model.load_state_dict", "trainer.AbstractTrainer.optimizer.load_state_dict", "print", "print"], "methods", ["None"], ["", "", "def", "loadCheckpoint", "(", "self", ",", "filename", ")", ":", "\n", "        ", "if", "os", ".", "path", ".", "isfile", "(", "filename", ")", ":", "\n", "            ", "print", "(", "\"=> loading checkpoint '{}'\"", ".", "format", "(", "filename", ")", ")", "\n", "checkpoint", "=", "torch", ".", "load", "(", "filename", ")", "\n", "self", ".", "epoch_step", "=", "checkpoint", "[", "'epoch'", "]", "\n", "self", ".", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'state_dict'", "]", ")", "\n", "self", ".", "optimizer", ".", "load_state_dict", "(", "checkpoint", "[", "'optimizer'", "]", ")", "\n", "print", "(", "\"=> loaded checkpoint '{}' (epoch {})\"", ".", "format", "(", "filename", ",", "checkpoint", "[", "'epoch'", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"=> no checkpoint found at '{}'\"", ".", "format", "(", "filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveCheckpoint": [[214, 218], ["os.path.join", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "trainer.AbstractTrainer.model.state_dict", "trainer.AbstractTrainer.optimizer.state_dict", "str"], "methods", ["None"], ["", "", "def", "saveCheckpoint", "(", "self", ")", ":", "\n", "        ", "file_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "settings", ".", "ckpt_dir", ",", "'model_step_'", "+", "str", "(", "self", ".", "epoch_step", ")", "+", "'.pth'", ")", "\n", "torch", ".", "save", "(", "{", "'state_dict'", ":", "self", ".", "model", ".", "state_dict", "(", ")", ",", "'optimizer'", ":", "self", ".", "optimizer", ".", "state_dict", "(", ")", ",", "\n", "'epoch'", ":", "self", ".", "epoch_step", "}", ",", "file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.FBSparseVGGModel.buildModel": [[221, 227], ["models.facebook_sparse_vgg.FBSparseVGG", "trainer.FBSparseVGGModel.model.to"], "methods", ["None"], ["    ", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates the specified model\"\"\"", "\n", "self", ".", "model", "=", "FBSparseVGG", "(", "self", ".", "nr_classes", ",", "self", ".", "nr_input_channels", ",", "\n", "vgg_12", "=", "(", "self", ".", "settings", ".", "dataset_name", "==", "'NCars'", ")", ")", "\n", "self", ".", "model", ".", "to", "(", "self", ".", "settings", ".", "gpu_device", ")", "\n", "self", ".", "model_input_size", "=", "self", ".", "model", ".", "spatial_size", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.FBSparseVGGModel.train": [[228, 237], ["trainer.FBSparseVGGModel.trainEpoch", "trainer.FBSparseVGGModel.scheduler.step", "trainer.FBSparseVGGModel.validationEpoch"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.trainEpoch", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.validationEpoch"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"Main training and validation loop\"\"\"", "\n", "while", "True", ":", "\n", "            ", "if", "(", "self", ".", "epoch_step", "%", "5", ")", "==", "0", ":", "\n", "                ", "self", ".", "validationEpoch", "(", ")", "\n", "", "self", ".", "trainEpoch", "(", ")", "\n", "\n", "self", ".", "epoch_step", "+=", "1", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.FBSparseVGGModel.trainEpoch": [[238, 295], ["tqdm.tqdm", "trainer.FBSparseVGGModel.model.train", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "enumerate", "trainer.FBSparseVGGModel.writer.add_scalar", "trainer.FBSparseVGGModel.writer.add_scalar", "trainer.FBSparseVGGModel.writer.add_scalar", "trainer.FBSparseVGGModel.pbar.close", "trainer.FBSparseVGGModel.optimizer.zero_grad", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "histogram.permute.permute.permute", "trainer.FBSparseVGGModel.denseToSparse", "trainer.FBSparseVGGModel.model", "torch.CrossEntropyLoss.", "trainer.FBSparseVGGModel.argmax", "accuracy.data.cpu().numpy", "nn.CrossEntropyLoss.data.cpu().numpy", "nn.CrossEntropyLoss.backward", "trainer.FBSparseVGGModel.optimizer.step", "trainer.FBSparseVGGModel.pbar.set_postfix", "trainer.FBSparseVGGModel.pbar.update", "trainer.FBSparseVGGModel.getLearningRate", "histogram.permute.permute.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "utils.visualizeLocations", "trainer.FBSparseVGGModel.writer.add_image", "float", "float", "accuracy.data.cpu", "nn.CrossEntropyLoss.data.cpu", "vis_locations.cpu().int().numpy", "nn.CrossEntropyLoss.data.cpu().numpy", "features.cpu().numpy", "vis_locations.cpu().int", "nn.CrossEntropyLoss.data.cpu", "features.cpu", "vis_locations.cpu"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.train", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.getLearningRate", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeLocations"], ["", "", "def", "trainEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_train_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "training_loss", "=", "0", "\n", "self", ".", "training_accuracy", "=", "0", "\n", "loss_function", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "train_loader", ")", ":", "\n", "            ", "_", ",", "labels", ",", "histogram", "=", "sample_batched", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# Change size to input size of sparse VGG", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "histogram", "=", "histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "locations", ",", "features", "=", "self", ".", "denseToSparse", "(", "histogram", ")", "\n", "\n", "model_output", "=", "self", ".", "model", "(", "[", "locations", ",", "features", ",", "histogram", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n", "loss", "=", "loss_function", "(", "model_output", ",", "target", "=", "labels", ")", "\n", "\n", "# Save training statistics", "\n", "predicted_classes", "=", "model_output", ".", "argmax", "(", "1", ")", "\n", "accuracy", "=", "(", "predicted_classes", "==", "labels", ")", ".", "float", "(", ")", ".", "mean", "(", ")", "\n", "self", ".", "training_accuracy", "+=", "accuracy", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "training_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "# Visualization", "\n", "# events_sample1 = events[events[:, -1] == 0, :-1]", "\n", "# file_path = os.path.join(self.settings.vis_dir, 'image_' + str(self.batch_step) + '.png')", "\n", "# visualizations.visualizeEventsTime(events_sample1.data.cpu().numpy(), self.settings.height,", "\n", "#                                    self.settings.width, path_name=file_path, last_k_events=None)", "\n", "if", "self", ".", "batch_step", "%", "(", "self", ".", "nr_train_epochs", "*", "50", ")", "==", "0", ":", "\n", "                ", "batch_one_mask", "=", "locations", "[", ":", ",", "-", "1", "]", "==", "0", "\n", "vis_locations", "=", "locations", "[", "batch_one_mask", ",", ":", "2", "]", "\n", "features", "=", "features", "[", "batch_one_mask", ",", ":", "]", "\n", "\n", "# file_path = os.path.join(self.settings.vis_dir, 'image_' + str(self.batch_step) + '.png')", "\n", "# visualizations.visualizeLocations(vis_locations.cpu().int().numpy(), self.model_input_size,", "\n", "#                                   features=features.cpu().numpy(), path_name=file_path)", "\n", "\n", "image", "=", "visualizations", ".", "visualizeLocations", "(", "vis_locations", ".", "cpu", "(", ")", ".", "int", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "model_input_size", ",", "\n", "features", "=", "features", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Training/Input Histogram'", ",", "image", ",", "self", ".", "epoch_step", ",", "dataformats", "=", "'HWC'", ")", "\n", "\n", "", "self", ".", "pbar", ".", "set_postfix", "(", "TrainLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "batch_step", "+=", "1", "\n", "\n", "", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Training_Accuracy'", ",", "self", ".", "training_accuracy", "/", "float", "(", "self", ".", "nr_train_epochs", ")", ",", "\n", "self", ".", "epoch_step", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Training_Loss'", ",", "self", ".", "training_loss", "/", "float", "(", "self", ".", "nr_train_epochs", ")", ",", "\n", "self", ".", "epoch_step", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Learning_Rate'", ",", "self", ".", "getLearningRate", "(", ")", ",", "self", ".", "epoch_step", ")", "\n", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.FBSparseVGGModel.validationEpoch": [[296, 341], ["tqdm.tqdm", "trainer.FBSparseVGGModel.resetValidation", "trainer.FBSparseVGGModel.model.eval", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "enumerate", "trainer.FBSparseVGGModel.saveValidationStatistics", "trainer.FBSparseVGGModel.pbar.close", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "histogram.permute.permute.permute", "trainer.FBSparseVGGModel.denseToSparse", "torch.CrossEntropyLoss.", "trainer.FBSparseVGGModel.argmax", "nn.CrossEntropyLoss.data.cpu().numpy", "accuracy.data.cpu().numpy", "numpy.add.at", "trainer.FBSparseVGGModel.pbar.set_postfix", "trainer.FBSparseVGGModel.pbar.update", "float", "float", "trainer.FBSparseVGGModel.saveCheckpoint", "histogram.permute.permute.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.FBSparseVGGModel.model", "nn.CrossEntropyLoss.data.cpu", "accuracy.data.cpu", "trainer.FBSparseVGGModel.argmax.data.cpu().numpy", "labels.data.cpu().numpy", "nn.CrossEntropyLoss.data.cpu().numpy", "trainer.FBSparseVGGModel.argmax.data.cpu", "labels.data.cpu", "nn.CrossEntropyLoss.data.cpu"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.resetValidation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveValidationStatistics", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveCheckpoint"], ["", "def", "validationEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_val_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "resetValidation", "(", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "eval", "(", ")", "\n", "loss_function", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "val_loader", ")", ":", "\n", "            ", "_", ",", "labels", ",", "histogram", "=", "sample_batched", "\n", "\n", "# Convert spatial dimension to model input size", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "histogram", "=", "histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "locations", ",", "features", "=", "self", ".", "denseToSparse", "(", "histogram", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "model_output", "=", "self", ".", "model", "(", "[", "locations", ",", "features", ",", "histogram", ".", "shape", "[", "0", "]", "]", ")", "\n", "\n", "", "loss", "=", "loss_function", "(", "model_output", ",", "target", "=", "labels", ")", "\n", "\n", "# Save validation statistics", "\n", "predicted_classes", "=", "model_output", ".", "argmax", "(", "1", ")", "\n", "accuracy", "=", "(", "predicted_classes", "==", "labels", ")", ".", "float", "(", ")", ".", "mean", "(", ")", "\n", "self", ".", "validation_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "validation_accuracy", "+=", "accuracy", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "np", ".", "add", ".", "at", "(", "self", ".", "val_confusion_matrix", ",", "(", "predicted_classes", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "labels", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "1", ")", "\n", "\n", "# Visualization", "\n", "# events_sample1 = events[events[:, -1] == 0, :-1]", "\n", "# file_path = os.path.join(self.settings.vis_dir, 'image_' + str(self.batch_step) + '.png')", "\n", "# visualizations.visualizeEventsTime(events_sample1.data.cpu().numpy(), self.settings.height,", "\n", "#                                    self.settings.width, path_name=file_path, last_k_events=None)", "\n", "\n", "self", ".", "pbar", ".", "set_postfix", "(", "ValLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "val_batch_step", "+=", "1", "\n", "\n", "", "self", ".", "validation_loss", "=", "self", ".", "validation_loss", "/", "float", "(", "self", ".", "val_batch_step", ")", "\n", "self", ".", "validation_accuracy", "=", "self", ".", "validation_accuracy", "/", "float", "(", "self", ".", "val_batch_step", ")", "\n", "self", ".", "saveValidationStatistics", "(", ")", "\n", "\n", "if", "self", ".", "max_validation_accuracy", "<", "self", ".", "validation_accuracy", ":", "\n", "            ", "self", ".", "max_validation_accuracy", "=", "self", ".", "validation_accuracy", "\n", "self", ".", "saveCheckpoint", "(", ")", "\n", "\n", "", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseVGGModel.buildModel": [[344, 354], ["models.dense_VGG.DenseVGG", "trainer.DenseVGGModel.model.to"], "methods", ["None"], ["    ", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates the specified model\"\"\"", "\n", "self", ".", "model", "=", "DenseVGG", "(", "self", ".", "nr_classes", ",", "in_c", "=", "self", ".", "nr_input_channels", ",", "\n", "vgg_12", "=", "(", "self", ".", "settings", ".", "dataset_name", "==", "'NCars'", ")", ")", "\n", "self", ".", "model", ".", "to", "(", "self", ".", "settings", ".", "gpu_device", ")", "\n", "# Input size is determined by architecture", "\n", "if", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101'", ":", "\n", "            ", "self", ".", "model_input_size", "=", "[", "191", ",", "255", "]", "\n", "", "elif", "self", ".", "settings", ".", "dataset_name", "==", "'NCars'", ":", "\n", "            ", "self", ".", "model_input_size", "=", "[", "95", ",", "127", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseVGGModel.train": [[355, 364], ["trainer.DenseVGGModel.trainEpoch", "trainer.DenseVGGModel.scheduler.step", "trainer.DenseVGGModel.validationEpoch"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.trainEpoch", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.validationEpoch"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"Main training and validation loop\"\"\"", "\n", "while", "self", ".", "epoch_step", "<=", "6507", ":", "\n", "            ", "if", "(", "self", ".", "epoch_step", "%", "50", ")", "==", "0", ":", "\n", "                ", "self", ".", "validationEpoch", "(", ")", "\n", "", "self", ".", "trainEpoch", "(", ")", "\n", "\n", "self", ".", "epoch_step", "+=", "1", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseVGGModel.trainEpoch": [[365, 409], ["tqdm.tqdm", "trainer.DenseVGGModel.model.train", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "enumerate", "trainer.DenseVGGModel.writer.add_scalar", "trainer.DenseVGGModel.writer.add_scalar", "trainer.DenseVGGModel.writer.add_scalar", "trainer.DenseVGGModel.pbar.close", "trainer.DenseVGGModel.optimizer.zero_grad", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "trainer.DenseVGGModel.model", "torch.CrossEntropyLoss.", "trainer.DenseVGGModel.argmax", "accuracy.data.cpu().numpy", "nn.CrossEntropyLoss.data.cpu().numpy", "nn.CrossEntropyLoss.backward", "trainer.DenseVGGModel.optimizer.step", "trainer.DenseVGGModel.pbar.set_postfix", "trainer.DenseVGGModel.pbar.update", "trainer.DenseVGGModel.getLearningRate", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "utils.visualizeHistogram", "trainer.DenseVGGModel.writer.add_image", "float", "float", "accuracy.data.cpu", "nn.CrossEntropyLoss.data.cpu", "histogram[].permute().cpu().int().numpy", "nn.CrossEntropyLoss.data.cpu().numpy", "histogram[].permute().cpu().int", "nn.CrossEntropyLoss.data.cpu", "histogram[].permute().cpu", "histogram[].permute"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.train", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.getLearningRate", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeHistogram"], ["", "", "def", "trainEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_train_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "training_loss", "=", "0", "\n", "self", ".", "training_accuracy", "=", "0", "\n", "loss_function", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "train_loader", ")", ":", "\n", "            ", "events", ",", "labels", ",", "histogram", "=", "sample_batched", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# Change size to input size of sparse VGG", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "\n", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "model_output", "=", "self", ".", "model", "(", "histogram", ")", "\n", "\n", "loss", "=", "loss_function", "(", "model_output", ",", "target", "=", "labels", ")", "\n", "\n", "# Save training statistics", "\n", "predicted_classes", "=", "model_output", ".", "argmax", "(", "1", ")", "\n", "accuracy", "=", "(", "predicted_classes", "==", "labels", ")", ".", "float", "(", ")", ".", "mean", "(", ")", "\n", "self", ".", "training_accuracy", "+=", "accuracy", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "training_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "self", ".", "batch_step", "%", "(", "self", ".", "nr_train_epochs", "*", "50", ")", "==", "0", ":", "\n", "# file_path = os.path.join(self.settings.vis_dir, 'image_' + str(self.batch_step) + '.png')", "\n", "# visualizations.visualizeLocations(vis_locations.cpu().int().numpy(), self.model_input_size,", "\n", "#                                   features=features.cpu().numpy(), path_name=file_path)", "\n", "                ", "image", "=", "visualizations", ".", "visualizeHistogram", "(", "histogram", "[", "0", ",", ":", ",", ":", ",", ":", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "int", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Training/Input Histogram'", ",", "image", ",", "self", ".", "epoch_step", ",", "dataformats", "=", "'HWC'", ")", "\n", "\n", "", "self", ".", "pbar", ".", "set_postfix", "(", "TrainLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "batch_step", "+=", "1", "\n", "\n", "", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Training_Accuracy'", ",", "self", ".", "training_accuracy", "/", "float", "(", "self", ".", "nr_train_epochs", ")", ",", "\n", "self", ".", "epoch_step", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Training_Loss'", ",", "self", ".", "training_loss", "/", "float", "(", "self", ".", "nr_train_epochs", ")", ",", "\n", "self", ".", "epoch_step", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Learning_Rate'", ",", "self", ".", "getLearningRate", "(", ")", ",", "self", ".", "epoch_step", ")", "\n", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseVGGModel.validationEpoch": [[410, 447], ["tqdm.tqdm", "trainer.DenseVGGModel.resetValidation", "trainer.DenseVGGModel.model.eval", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "enumerate", "trainer.DenseVGGModel.saveValidationStatistics", "trainer.DenseVGGModel.pbar.close", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.CrossEntropyLoss.", "trainer.DenseVGGModel.argmax", "nn.CrossEntropyLoss.data.cpu().numpy", "accuracy.data.cpu().numpy", "numpy.add.at", "trainer.DenseVGGModel.pbar.set_postfix", "trainer.DenseVGGModel.pbar.update", "float", "float", "trainer.DenseVGGModel.saveCheckpoint", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.DenseVGGModel.model", "nn.CrossEntropyLoss.data.cpu", "accuracy.data.cpu", "trainer.DenseVGGModel.argmax.data.cpu().numpy", "labels.data.cpu().numpy", "nn.CrossEntropyLoss.data.cpu().numpy", "trainer.DenseVGGModel.argmax.data.cpu", "labels.data.cpu", "nn.CrossEntropyLoss.data.cpu"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.resetValidation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveValidationStatistics", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveCheckpoint"], ["", "def", "validationEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_val_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "resetValidation", "(", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "eval", "(", ")", "\n", "loss_function", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "val_loader", ")", ":", "\n", "            ", "events", ",", "labels", ",", "histogram", "=", "sample_batched", "\n", "\n", "# Convert spatial dimension to model input size", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "model_output", "=", "self", ".", "model", "(", "histogram", ")", "\n", "\n", "", "loss", "=", "loss_function", "(", "model_output", ",", "target", "=", "labels", ")", "\n", "\n", "# Save validation statistics", "\n", "predicted_classes", "=", "model_output", ".", "argmax", "(", "1", ")", "\n", "accuracy", "=", "(", "predicted_classes", "==", "labels", ")", ".", "float", "(", ")", ".", "mean", "(", ")", "\n", "self", ".", "validation_loss", "+=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "self", ".", "validation_accuracy", "+=", "accuracy", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "np", ".", "add", ".", "at", "(", "self", ".", "val_confusion_matrix", ",", "(", "predicted_classes", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "labels", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "1", ")", "\n", "\n", "self", ".", "pbar", ".", "set_postfix", "(", "ValLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "val_batch_step", "+=", "1", "\n", "\n", "", "self", ".", "validation_loss", "=", "self", ".", "validation_loss", "/", "float", "(", "self", ".", "val_batch_step", ")", "\n", "self", ".", "validation_accuracy", "=", "self", ".", "validation_accuracy", "/", "float", "(", "self", ".", "val_batch_step", ")", "\n", "self", ".", "saveValidationStatistics", "(", ")", "\n", "\n", "if", "self", ".", "max_validation_accuracy", "<", "self", ".", "validation_accuracy", ":", "\n", "            ", "self", ".", "max_validation_accuracy", "=", "self", ".", "validation_accuracy", "\n", "self", ".", "saveCheckpoint", "(", ")", "\n", "\n", "", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.SparseObjectDetModel.buildModel": [[450, 460], ["models.facebook_sparse_object_det.FBSparseObjectDet", "trainer.SparseObjectDetModel.model.to", "trainer.SparseObjectDetModel.loadPretrainedWeights"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.loadPretrainedWeights"], ["    ", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates the specified model\"\"\"", "\n", "self", ".", "model", "=", "FBSparseObjectDet", "(", "self", ".", "nr_classes", ",", "nr_input_channels", "=", "self", ".", "nr_input_channels", ",", "\n", "small_out_map", "=", "(", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", ")", ")", "\n", "self", ".", "model", ".", "to", "(", "self", ".", "settings", ".", "gpu_device", ")", "\n", "self", ".", "model_input_size", "=", "self", ".", "model", ".", "spatial_size", "# [191, 255]", "\n", "\n", "if", "self", ".", "settings", ".", "use_pretrained", "and", "(", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", "or", "\n", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ")", ":", "\n", "            ", "self", ".", "loadPretrainedWeights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.SparseObjectDetModel.loadPretrainedWeights": [[461, 476], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "pretrained_dict.items", "trainer.SparseObjectDetModel.model.load_state_dict"], "methods", ["None"], ["", "", "def", "loadPretrainedWeights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Loads pretrained model weights\"\"\"", "\n", "checkpoint", "=", "torch", ".", "load", "(", "self", ".", "settings", ".", "pretrained_sparse_vgg", ")", "\n", "try", ":", "\n", "            ", "pretrained_dict", "=", "checkpoint", "[", "'state_dict'", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "pretrained_dict", "=", "checkpoint", "[", "'model'", "]", "\n", "\n", "", "pretrained_dict_short", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "pretrained_dict", ".", "items", "(", ")", ":", "\n", "            ", "if", "'sparseModel.25'", "in", "k", ":", "\n", "                ", "break", "\n", "", "pretrained_dict_short", "[", "k", "]", "=", "v", "\n", "\n", "", "self", ".", "model", ".", "load_state_dict", "(", "pretrained_dict_short", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.SparseObjectDetModel.train": [[477, 488], ["trainer.SparseObjectDetModel.trainEpoch", "trainer.SparseObjectDetModel.scheduler.step", "trainer.SparseObjectDetModel.validationEpoch"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.trainEpoch", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.validationEpoch"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"Main training and validation loop\"\"\"", "\n", "validation_step", "=", "50", "-", "48", "*", "(", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ")", "\n", "\n", "while", "True", ":", "\n", "            ", "self", ".", "trainEpoch", "(", ")", "\n", "if", "(", "self", ".", "epoch_step", "%", "validation_step", ")", "==", "(", "validation_step", "-", "1", ")", ":", "\n", "                ", "self", ".", "validationEpoch", "(", ")", "\n", "\n", "", "self", ".", "epoch_step", "+=", "1", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.SparseObjectDetModel.trainEpoch": [[489, 554], ["tqdm.tqdm", "trainer.SparseObjectDetModel.model.train", "enumerate", "trainer.SparseObjectDetModel.writer.add_scalar", "trainer.SparseObjectDetModel.pbar.close", "trainer.SparseObjectDetModel.optimizer.zero_grad", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "histogram.permute.permute.permute", "trainer.SparseObjectDetModel.denseToSparse", "trainer.SparseObjectDetModel.model", "loss_function", "trainer.SparseObjectDetModel.storeLossesObjectDetection", "loss.backward", "trainer.SparseObjectDetModel.optimizer.step", "trainer.SparseObjectDetModel.pbar.set_postfix", "trainer.SparseObjectDetModel.pbar.update", "trainer.SparseObjectDetModel.getLearningRate", "histogram.permute.permute.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "utils.visualizeLocations", "utils.drawBoundingBoxes", "trainer.SparseObjectDetModel.writer.add_image", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "models.yolo_detection.yoloDetect().long().cpu().numpy", "vis_locations.cpu().int().numpy", "loss.data.cpu().numpy", "features.cpu().numpy", "bounding_box[].cpu().numpy", "trainer.SparseObjectDetModel.model_input_size[].float", "trainer.SparseObjectDetModel.model_input_size[].float", "models.yolo_detection.yoloDetect().long().cpu", "vis_locations.cpu().int", "loss.data.cpu", "features.cpu", "bounding_box[].cpu", "models.yolo_detection.yoloDetect().long", "vis_locations.cpu", "models.yolo_detection.yoloDetect", "trainer.SparseObjectDetModel.model_input_size.to"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.train", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.storeLossesObjectDetection", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.getLearningRate", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeLocations", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloDetect"], ["", "", "def", "trainEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_train_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "train", "(", ")", "\n", "loss_function", "=", "yoloLoss", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "train_loader", ")", ":", "\n", "            ", "event", ",", "bounding_box", ",", "histogram", "=", "sample_batched", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# Change size to input size of sparse VGG", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "\n", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "histogram", "=", "histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "# Change x, width and y, height", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "*", "self", ".", "model_input_size", "[", "1", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "width", ")", ".", "long", "(", ")", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "*", "self", ".", "model_input_size", "[", "0", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "height", ")", ".", "long", "(", ")", "\n", "locations", ",", "features", "=", "self", ".", "denseToSparse", "(", "histogram", ")", "\n", "\n", "# Deep Learning Magic", "\n", "model_output", "=", "self", ".", "model", "(", "[", "locations", ",", "features", ",", "histogram", ".", "shape", "[", "0", "]", "]", ")", "\n", "out", "=", "loss_function", "(", "model_output", ",", "bounding_box", ",", "self", ".", "model_input_size", ")", "\n", "loss", "=", "out", "[", "0", "]", "\n", "\n", "# Write losses statistics", "\n", "self", ".", "storeLossesObjectDetection", "(", "out", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "self", ".", "batch_step", "%", "(", "self", ".", "nr_train_epochs", "*", "50", ")", "==", "0", ":", "\n", "                ", "batch_one_mask", "=", "locations", "[", ":", ",", "-", "1", "]", "==", "0", "\n", "vis_locations", "=", "locations", "[", "batch_one_mask", ",", ":", "2", "]", "\n", "features", "=", "features", "[", "batch_one_mask", ",", ":", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "detected_bbox", "=", "yoloDetect", "(", "model_output", ",", "self", ".", "model_input_size", ".", "to", "(", "model_output", ".", "device", ")", ",", "\n", "threshold", "=", "0.3", ")", ".", "long", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "detected_bbox", "=", "detected_bbox", "[", "detected_bbox", "[", ":", ",", "0", "]", "==", "0", ",", "1", ":", "-", "2", "]", "\n", "\n", "# Visualization", "\n", "# file_path = os.path.join(self.settings.vis_dir, 'image_' + str(self.batch_step) + '.png')", "\n", "# visualizations.visualizeLocations(vis_locations.cpu().int().numpy(), self.model_input_size,", "\n", "#                                   features=features.cpu().numpy(), path_name=file_path,", "\n", "#                                   bounding_box=bounding_box[0, :, :].cpu().numpy(),", "\n", "#                                   class_name=[self.object_classes[i] for i in bounding_box[0, :, -1]])", "\n", "\n", "", "image", "=", "visualizations", ".", "visualizeLocations", "(", "vis_locations", ".", "cpu", "(", ")", ".", "int", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "model_input_size", ",", "\n", "features", "=", "features", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "bounding_box", "=", "bounding_box", "[", "0", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "bounding_box", "[", "0", ",", ":", ",", "-", "1", "]", "]", ")", "\n", "image", "=", "visualizations", ".", "drawBoundingBoxes", "(", "image", ",", "detected_bbox", "[", ":", ",", ":", "-", "1", "]", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "detected_bbox", "[", ":", ",", "-", "1", "]", "]", ",", "\n", "ground_truth", "=", "False", ",", "rescale_image", "=", "False", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Training/Input Histogram'", ",", "image", ",", "self", ".", "epoch_step", ",", "dataformats", "=", "'HWC'", ")", "\n", "\n", "", "self", ".", "pbar", ".", "set_postfix", "(", "TrainLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "batch_step", "+=", "1", "\n", "\n", "", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Learning_Rate'", ",", "self", ".", "getLearningRate", "(", ")", ",", "self", ".", "epoch_step", ")", "\n", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.SparseObjectDetModel.validationEpoch": [[555, 621], ["tqdm.tqdm", "trainer.SparseObjectDetModel.resetValidation", "trainer.SparseObjectDetModel.model.eval", "utils.statistics_pascalvoc.BoundingBoxes", "numpy.zeros", "enumerate", "trainer.SparseObjectDetModel.saveValidationStatisticsObjectDetection", "trainer.SparseObjectDetModel.writer.add_image", "trainer.SparseObjectDetModel.pbar.close", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "histogram.permute.permute.permute", "trainer.SparseObjectDetModel.denseToSparse", "trainer.SparseObjectDetModel.saveBoundingBoxes", "trainer.SparseObjectDetModel.pbar.set_postfix", "trainer.SparseObjectDetModel.pbar.update", "float", "trainer.SparseObjectDetModel.saveCheckpoint", "int", "int", "histogram.permute.permute.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.SparseObjectDetModel.model", "models.yolo_detection.yoloDetect", "models.yolo_detection.nonMaxSuppression", "detected_bbox.cpu().numpy.cpu().numpy.cpu().numpy", "bounding_box.cpu().numpy", "detected_bbox[].astype", "utils.visualizeLocations", "utils.drawBoundingBoxes", "loss_function", "trainer.SparseObjectDetModel.model_input_size.to", "vis_locations.cpu().int().numpy", "loss.data.cpu().numpy", "detected_bbox.cpu().numpy.cpu().numpy.cpu", "bounding_box.cpu", "features.cpu().numpy", "bounding_box[].cpu().numpy", "int", "trainer.SparseObjectDetModel.model_input_size[].float", "trainer.SparseObjectDetModel.model_input_size[].float", "vis_locations.cpu().int", "loss.data.cpu", "features.cpu", "bounding_box[].cpu", "vis_locations.cpu"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.resetValidation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveValidationStatisticsObjectDetection", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveCheckpoint", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloDetect", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.nonMaxSuppression", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeLocations", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes"], ["", "def", "validationEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_val_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "resetValidation", "(", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "bounding_boxes", "=", "BoundingBoxes", "(", ")", "\n", "loss_function", "=", "yoloLoss", "\n", "# Images are upsampled for visualization", "\n", "val_images", "=", "np", ".", "zeros", "(", "[", "2", ",", "int", "(", "self", ".", "model_input_size", "[", "0", "]", "*", "1.5", ")", ",", "int", "(", "self", ".", "model_input_size", "[", "1", "]", "*", "1.5", ")", ",", "3", "]", ")", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "val_loader", ")", ":", "\n", "            ", "event", ",", "bounding_box", ",", "histogram", "=", "sample_batched", "\n", "\n", "# Convert spatial dimension to model input size", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "\n", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "histogram", "=", "histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "\n", "# Change x, width and y, height", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "*", "self", ".", "model_input_size", "[", "1", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "width", ")", ".", "long", "(", ")", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "*", "self", ".", "model_input_size", "[", "0", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "height", ")", ".", "long", "(", ")", "\n", "locations", ",", "features", "=", "self", ".", "denseToSparse", "(", "histogram", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "model_output", "=", "self", ".", "model", "(", "[", "locations", ",", "features", ",", "histogram", ".", "shape", "[", "0", "]", "]", ")", "\n", "loss", "=", "loss_function", "(", "model_output", ",", "bounding_box", ",", "self", ".", "model_input_size", ")", "[", "0", "]", "\n", "detected_bbox", "=", "yoloDetect", "(", "model_output", ",", "self", ".", "model_input_size", ".", "to", "(", "model_output", ".", "device", ")", ",", "\n", "threshold", "=", "0.3", ")", "\n", "detected_bbox", "=", "nonMaxSuppression", "(", "detected_bbox", ",", "iou", "=", "0.6", ")", "\n", "detected_bbox", "=", "detected_bbox", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# Save validation statistics", "\n", "", "self", ".", "saveBoundingBoxes", "(", "bounding_box", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "detected_bbox", ")", "\n", "\n", "if", "self", ".", "val_batch_step", "%", "(", "self", ".", "nr_val_epochs", "-", "2", ")", "==", "0", ":", "\n", "                ", "batch_one_mask", "=", "locations", "[", ":", ",", "-", "1", "]", "==", "0", "\n", "vis_locations", "=", "locations", "[", "batch_one_mask", ",", ":", "2", "]", "\n", "features", "=", "features", "[", "batch_one_mask", ",", ":", "]", "\n", "vis_detected_bbox", "=", "detected_bbox", "[", "detected_bbox", "[", ":", ",", "0", "]", "==", "0", ",", "1", ":", "-", "2", "]", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "image", "=", "visualizations", ".", "visualizeLocations", "(", "vis_locations", ".", "cpu", "(", ")", ".", "int", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "model_input_size", ",", "\n", "features", "=", "features", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "bounding_box", "=", "bounding_box", "[", "0", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "bounding_box", "[", "0", ",", ":", ",", "-", "1", "]", "]", ")", "\n", "image", "=", "visualizations", ".", "drawBoundingBoxes", "(", "image", ",", "vis_detected_bbox", "[", ":", ",", ":", "-", "1", "]", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "vis_detected_bbox", "[", ":", ",", "-", "1", "]", "]", ",", "\n", "ground_truth", "=", "False", ",", "rescale_image", "=", "False", ")", "\n", "val_images", "[", "int", "(", "self", ".", "val_batch_step", "//", "(", "self", ".", "nr_val_epochs", "-", "2", ")", ")", "]", "=", "image", "\n", "\n", "", "self", ".", "pbar", ".", "set_postfix", "(", "ValLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "val_batch_step", "+=", "1", "\n", "self", ".", "validation_loss", "+=", "loss", "\n", "\n", "", "self", ".", "validation_loss", "=", "self", ".", "validation_loss", "/", "float", "(", "self", ".", "val_batch_step", ")", "\n", "self", ".", "saveValidationStatisticsObjectDetection", "(", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Validation/Input Histogram'", ",", "val_images", ",", "self", ".", "epoch_step", ",", "dataformats", "=", "'NHWC'", ")", "\n", "\n", "if", "self", ".", "max_validation_accuracy", "<", "self", ".", "validation_accuracy", ":", "\n", "            ", "self", ".", "max_validation_accuracy", "=", "self", ".", "validation_accuracy", "\n", "self", ".", "saveCheckpoint", "(", ")", "\n", "\n", "", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.buildModel": [[624, 638], ["models.dense_object_det.DenseObjectDet", "trainer.DenseObjectDetModel.model.to", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "trainer.DenseObjectDetModel.loadPretrainedWeights", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.loadPretrainedWeights"], ["    ", "def", "buildModel", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates the specified model\"\"\"", "\n", "self", ".", "model", "=", "DenseObjectDet", "(", "self", ".", "nr_classes", ",", "in_c", "=", "self", ".", "nr_input_channels", ",", "\n", "small_out_map", "=", "(", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", ")", ")", "\n", "self", ".", "model", ".", "to", "(", "self", ".", "settings", ".", "gpu_device", ")", "\n", "\n", "if", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", ":", "\n", "            ", "self", ".", "model_input_size", "=", "torch", ".", "tensor", "(", "[", "191", ",", "255", "]", ")", "\n", "", "elif", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ":", "\n", "            ", "self", ".", "model_input_size", "=", "torch", ".", "tensor", "(", "[", "223", ",", "287", "]", ")", "\n", "\n", "", "if", "self", ".", "settings", ".", "use_pretrained", "and", "(", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", "or", "\n", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ")", ":", "\n", "            ", "self", ".", "loadPretrainedWeights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.loadPretrainedWeights": [[639, 649], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "trainer.DenseObjectDetModel.model.load_state_dict", "pretrained_dict.items", "int"], "methods", ["None"], ["", "", "def", "loadPretrainedWeights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Loads pretrained model weights\"\"\"", "\n", "checkpoint", "=", "torch", ".", "load", "(", "self", ".", "settings", ".", "pretrained_dense_vgg", ")", "\n", "try", ":", "\n", "            ", "pretrained_dict", "=", "checkpoint", "[", "'state_dict'", "]", "\n", "", "except", "KeyError", ":", "\n", "            ", "pretrained_dict", "=", "checkpoint", "[", "'model'", "]", "\n", "\n", "", "pretrained_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "pretrained_dict", ".", "items", "(", ")", "if", "'conv_layers.'", "in", "k", "and", "int", "(", "k", "[", "12", "]", ")", "<=", "4", "}", "\n", "self", ".", "model", ".", "load_state_dict", "(", "pretrained_dict", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.train": [[650, 661], ["trainer.DenseObjectDetModel.trainEpoch", "trainer.DenseObjectDetModel.scheduler.step", "trainer.DenseObjectDetModel.validationEpoch"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.trainEpoch", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.validationEpoch"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"Main training and validation loop\"\"\"", "\n", "validation_step", "=", "50", "-", "40", "*", "(", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ")", "\n", "\n", "while", "True", ":", "\n", "            ", "self", ".", "trainEpoch", "(", ")", "\n", "if", "(", "self", ".", "epoch_step", "%", "validation_step", ")", "==", "(", "validation_step", "-", "1", ")", ":", "\n", "                ", "self", ".", "validationEpoch", "(", ")", "\n", "\n", "", "self", ".", "epoch_step", "+=", "1", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.trainEpoch": [[662, 715], ["tqdm.tqdm", "trainer.DenseObjectDetModel.model.train", "enumerate", "trainer.DenseObjectDetModel.writer.add_scalar", "trainer.DenseObjectDetModel.pbar.close", "trainer.DenseObjectDetModel.optimizer.zero_grad", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "trainer.DenseObjectDetModel.model", "loss_function", "trainer.DenseObjectDetModel.storeLossesObjectDetection", "loss.backward", "trainer.DenseObjectDetModel.optimizer.step", "trainer.DenseObjectDetModel.pbar.set_postfix", "trainer.DenseObjectDetModel.pbar.update", "trainer.DenseObjectDetModel.getLearningRate", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "utils.visualizeHistogram", "utils.drawBoundingBoxes", "utils.drawBoundingBoxes", "trainer.DenseObjectDetModel.writer.add_image", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "models.yolo_detection.yoloDetect().long().cpu().numpy", "histogram[].permute().cpu().int().numpy", "bounding_box[].cpu().numpy", "loss.data.cpu().numpy", "trainer.DenseObjectDetModel.model_input_size[].float", "trainer.DenseObjectDetModel.model_input_size[].float", "models.yolo_detection.yoloDetect().long().cpu", "histogram[].permute().cpu().int", "bounding_box[].cpu", "loss.data.cpu", "models.yolo_detection.yoloDetect().long", "histogram[].permute().cpu", "models.yolo_detection.yoloDetect", "histogram[].permute", "trainer.DenseObjectDetModel.model_input_size.to"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.train", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.storeLossesObjectDetection", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.getLearningRate", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeHistogram", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloDetect"], ["", "", "def", "trainEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_train_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "train", "(", ")", "\n", "loss_function", "=", "yoloLoss", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "train_loader", ")", ":", "\n", "            ", "event", ",", "bounding_box", ",", "histogram", "=", "sample_batched", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# Change size to input size of sparse VGG", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "\n", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "\n", "# Change x, width and y, height", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "*", "self", ".", "model_input_size", "[", "1", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "width", ")", ".", "long", "(", ")", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "*", "self", ".", "model_input_size", "[", "0", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "height", ")", ".", "long", "(", ")", "\n", "\n", "# Deep Learning Magic", "\n", "model_output", "=", "self", ".", "model", "(", "histogram", ")", "\n", "out", "=", "loss_function", "(", "model_output", ",", "bounding_box", ",", "self", ".", "model_input_size", ")", "\n", "loss", "=", "out", "[", "0", "]", "\n", "\n", "# Write losses statistics", "\n", "self", ".", "storeLossesObjectDetection", "(", "out", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "self", ".", "batch_step", "%", "(", "self", ".", "nr_train_epochs", "*", "50", ")", "==", "0", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "detected_bbox", "=", "yoloDetect", "(", "model_output", ",", "self", ".", "model_input_size", ".", "to", "(", "model_output", ".", "device", ")", ",", "\n", "threshold", "=", "0.3", ")", ".", "long", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "detected_bbox", "=", "detected_bbox", "[", "detected_bbox", "[", ":", ",", "0", "]", "==", "0", ",", "1", ":", "-", "2", "]", "\n", "\n", "", "image", "=", "visualizations", ".", "visualizeHistogram", "(", "histogram", "[", "0", ",", ":", ",", ":", ",", ":", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "int", "(", ")", ".", "numpy", "(", ")", ")", "\n", "image", "=", "visualizations", ".", "drawBoundingBoxes", "(", "image", ",", "bounding_box", "[", "0", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "bounding_box", "[", "0", ",", ":", ",", "-", "1", "]", "]", ",", "\n", "ground_truth", "=", "True", ",", "rescale_image", "=", "True", ")", "\n", "image", "=", "visualizations", ".", "drawBoundingBoxes", "(", "image", ",", "detected_bbox", "[", ":", ",", ":", "-", "1", "]", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "detected_bbox", "[", ":", ",", "-", "1", "]", "]", ",", "\n", "ground_truth", "=", "False", ",", "rescale_image", "=", "False", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Training/Input Histogram'", ",", "image", ",", "self", ".", "epoch_step", ",", "dataformats", "=", "'HWC'", ")", "\n", "\n", "", "self", ".", "pbar", ".", "set_postfix", "(", "TrainLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "batch_step", "+=", "1", "\n", "\n", "", "self", ".", "writer", ".", "add_scalar", "(", "'Training/Learning_Rate'", ",", "self", ".", "getLearningRate", "(", ")", ",", "self", ".", "epoch_step", ")", "\n", "self", ".", "pbar", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.DenseObjectDetModel.validationEpoch": [[716, 777], ["tqdm.tqdm", "trainer.DenseObjectDetModel.resetValidation", "trainer.DenseObjectDetModel.model.eval", "utils.statistics_pascalvoc.BoundingBoxes", "numpy.zeros", "enumerate", "trainer.DenseObjectDetModel.saveValidationStatisticsObjectDetection", "trainer.DenseObjectDetModel.writer.add_image", "trainer.DenseObjectDetModel.pbar.close", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "trainer.DenseObjectDetModel.saveBoundingBoxes", "trainer.DenseObjectDetModel.pbar.set_postfix", "trainer.DenseObjectDetModel.pbar.update", "float", "trainer.DenseObjectDetModel.saveCheckpoint", "int", "int", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.nn.functional.interpolate.permute", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.Size", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "trainer.DenseObjectDetModel.model", "models.yolo_detection.yoloDetect", "models.yolo_detection.nonMaxSuppression", "detected_bbox.cpu().numpy.cpu().numpy.cpu().numpy", "bounding_box.cpu().numpy", "detected_bbox[].astype", "utils.visualizeHistogram", "utils.drawBoundingBoxes", "utils.drawBoundingBoxes", "loss_function", "trainer.DenseObjectDetModel.model_input_size.to", "histogram[].permute().cpu().int().numpy", "bounding_box[].cpu().numpy", "loss.data.cpu().numpy", "detected_bbox.cpu().numpy.cpu().numpy.cpu", "bounding_box.cpu", "int", "trainer.DenseObjectDetModel.model_input_size[].float", "trainer.DenseObjectDetModel.model_input_size[].float", "histogram[].permute().cpu().int", "bounding_box[].cpu", "loss.data.cpu", "histogram[].permute().cpu", "histogram[].permute"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.resetValidation", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveValidationStatisticsObjectDetection", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.saveCheckpoint", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloDetect", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.nonMaxSuppression", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.visualizeHistogram", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.visualizations.drawBoundingBoxes"], ["", "def", "validationEpoch", "(", "self", ")", ":", "\n", "        ", "self", ".", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "self", ".", "nr_val_epochs", ",", "unit", "=", "'Batch'", ",", "unit_scale", "=", "True", ")", "\n", "self", ".", "resetValidation", "(", ")", "\n", "self", ".", "model", "=", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "bounding_boxes", "=", "BoundingBoxes", "(", ")", "\n", "loss_function", "=", "yoloLoss", "\n", "# Images are upsampled for visualization", "\n", "val_images", "=", "np", ".", "zeros", "(", "[", "2", ",", "int", "(", "self", ".", "model_input_size", "[", "0", "]", "*", "1.5", ")", ",", "int", "(", "self", ".", "model_input_size", "[", "1", "]", "*", "1.5", ")", ",", "3", "]", ")", "\n", "\n", "for", "i_batch", ",", "sample_batched", "in", "enumerate", "(", "self", ".", "val_loader", ")", ":", "\n", "            ", "event", ",", "bounding_box", ",", "histogram", "=", "sample_batched", "\n", "\n", "# Convert spatial dimension to model input size", "\n", "histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "\n", "torch", ".", "Size", "(", "self", ".", "model_input_size", ")", ")", "\n", "\n", "# Change x, width and y, height", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "0", ",", "2", "]", "]", "*", "self", ".", "model_input_size", "[", "1", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "width", ")", ".", "long", "(", ")", "\n", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "=", "(", "bounding_box", "[", ":", ",", ":", ",", "[", "1", ",", "3", "]", "]", "*", "self", ".", "model_input_size", "[", "0", "]", ".", "float", "(", ")", "\n", "/", "self", ".", "settings", ".", "height", ")", ".", "long", "(", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "model_output", "=", "self", ".", "model", "(", "histogram", ")", "\n", "loss", "=", "loss_function", "(", "model_output", ",", "bounding_box", ",", "self", ".", "model_input_size", ")", "[", "0", "]", "\n", "detected_bbox", "=", "yoloDetect", "(", "model_output", ",", "self", ".", "model_input_size", ".", "to", "(", "model_output", ".", "device", ")", ",", "\n", "threshold", "=", "0.3", ")", "\n", "detected_bbox", "=", "nonMaxSuppression", "(", "detected_bbox", ",", "iou", "=", "0.6", ")", "\n", "detected_bbox", "=", "detected_bbox", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# Save validation statistics", "\n", "", "self", ".", "saveBoundingBoxes", "(", "bounding_box", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "detected_bbox", ")", "\n", "\n", "if", "self", ".", "val_batch_step", "%", "(", "self", ".", "nr_val_epochs", "-", "2", ")", "==", "0", ":", "\n", "                ", "vis_detected_bbox", "=", "detected_bbox", "[", "detected_bbox", "[", ":", ",", "0", "]", "==", "0", ",", "1", ":", "-", "2", "]", ".", "astype", "(", "np", ".", "int", ")", "\n", "\n", "image", "=", "visualizations", ".", "visualizeHistogram", "(", "histogram", "[", "0", ",", ":", ",", ":", ",", ":", "]", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "cpu", "(", ")", ".", "int", "(", ")", ".", "numpy", "(", ")", ")", "\n", "image", "=", "visualizations", ".", "drawBoundingBoxes", "(", "image", ",", "bounding_box", "[", "0", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "bounding_box", "[", "0", ",", ":", ",", "-", "1", "]", "]", ",", "\n", "ground_truth", "=", "True", ",", "rescale_image", "=", "True", ")", "\n", "image", "=", "visualizations", ".", "drawBoundingBoxes", "(", "image", ",", "vis_detected_bbox", "[", ":", ",", ":", "-", "1", "]", ",", "\n", "class_name", "=", "[", "self", ".", "object_classes", "[", "i", "]", "\n", "for", "i", "in", "vis_detected_bbox", "[", ":", ",", "-", "1", "]", "]", ",", "\n", "ground_truth", "=", "False", ",", "rescale_image", "=", "False", ")", "\n", "val_images", "[", "int", "(", "self", ".", "val_batch_step", "//", "(", "self", ".", "nr_val_epochs", "-", "2", ")", ")", "]", "=", "image", "\n", "\n", "", "self", ".", "pbar", ".", "set_postfix", "(", "ValLoss", "=", "loss", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "self", ".", "pbar", ".", "update", "(", "1", ")", "\n", "self", ".", "val_batch_step", "+=", "1", "\n", "self", ".", "validation_loss", "+=", "loss", "\n", "\n", "", "self", ".", "validation_loss", "=", "self", ".", "validation_loss", "/", "float", "(", "self", ".", "val_batch_step", ")", "\n", "self", ".", "saveValidationStatisticsObjectDetection", "(", ")", "\n", "self", ".", "writer", ".", "add_image", "(", "'Validation/Input Histogram'", ",", "val_images", ",", "self", ".", "epoch_step", ",", "dataformats", "=", "'NHWC'", ")", "\n", "\n", "if", "self", ".", "max_validation_accuracy", "<", "self", ".", "validation_accuracy", ":", "\n", "            ", "self", ".", "max_validation_accuracy", "=", "self", ".", "validation_accuracy", "\n", "self", ".", "saveCheckpoint", "(", ")", "\n", "\n", "", "self", ".", "pbar", ".", "close", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg_cpp.asynSparseVGGCPP.__init__": [[14, 34], ["torch.device", "torch.device", "torch.device", "torch.device", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.createAsynVGG"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.createAsynVGG"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", "=", "101", ",", "input_channels", "=", "2", ",", "layer_list", "=", "None", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "use_bias", "=", "False", "\n", "self", ".", "asyn_layers", "=", "[", "]", "\n", "if", "layer_list", "is", "not", "None", ":", "\n", "            ", "self", ".", "layer_list", "=", "layer_list", "\n", "", "else", ":", "\n", "            ", "self", ".", "layer_list", "=", "[", "[", "'C'", ",", "2", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "256", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "256", ",", "512", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "512", ",", "256", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "[", "'ClassicFC'", ",", "256", "*", "3", "*", "2", ",", "101", "]", "]", "\n", "", "self", ".", "layer_list", "[", "0", "]", "[", "1", "]", "=", "input_channels", "\n", "self", ".", "layer_list", "[", "-", "1", "]", "[", "2", "]", "=", "nr_classes", "\n", "\n", "self", ".", "rule_book_start", "=", "[", "True", "]", "\n", "\n", "self", ".", "createAsynVGG", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg_cpp.asynSparseVGGCPP.forward": [[35, 81], ["enumerate", "list", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().double().to", "torch.tensor().double().to", "torch.tensor().double().to", "torch.tensor().double().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "torch.tensor().float().to", "layer.forward", "layer.forward", "x_asyn[].unsqueeze().permute", "layer", "layer.squeeze().permute", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().double", "torch.tensor().double", "torch.tensor().double", "torch.tensor().double", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "torch.tensor().float", "layer.forward", "x_asyn[].cpu", "x_asyn[].cpu", "x_asyn[].cpu", "x_asyn[].cpu", "x_asyn[].cpu().numpy().astype", "x_asyn[].unsqueeze", "layer.squeeze", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.applyBatchNorm", "torch.relu", "torch.relu", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "changed_locations.long", "x_asyn[].clone", "x_asyn[].permute().unsqueeze", "torch.relu", "torch.relu", "torch.relu.squeeze().permute", "x_asyn[].cpu().numpy", "x_asyn[].astype", "layer", "layer", "layer.squeeze", "x_asyn[].permute", "torch.relu.squeeze", "x_asyn[].permute().flatten().unsqueeze", "x_asyn[].cpu", "x_asyn[].permute().flatten", "x_asyn[].permute"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "def", "forward", "(", "self", ",", "x_asyn", ")", ":", "\n", "        ", "\"\"\"Apply asynchronous layers\"\"\"", "\n", "for", "j", ",", "layer", "in", "enumerate", "(", "self", ".", "asyn_layers", ")", ":", "\n", "# print('Layer Name: %s' % self.layer_list[j][0])", "\n", "# t1 = perf_counter()", "\n", "\n", "            ", "if", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'C'", ":", "\n", "                ", "if", "self", ".", "rule_book_start", "[", "j", "]", ":", "\n", "                    ", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ".", "cpu", "(", ")", ",", "\n", "feature_map", "=", "x_asyn", "[", "1", "]", ".", "cpu", "(", ")", ")", "\n", "", "else", ":", "\n", "                    ", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ".", "cpu", "(", ")", ",", "\n", "feature_map", "=", "x_asyn", "[", "1", "]", ".", "cpu", "(", ")", ",", "\n", "active_sites_map", "=", "x_asyn", "[", "2", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint32", ")", ",", "\n", "rule_book", "=", "x_asyn", "[", "3", "]", ")", "\n", "\n", "", "x_asyn", "=", "list", "(", "x_asyn", ")", "\n", "x_asyn", "[", "0", "]", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "0", "]", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "x_asyn", "[", "1", "]", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "1", "]", ")", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "x_asyn", "[", "2", "]", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "2", "]", ".", "astype", "(", "np", ".", "float32", ")", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicC'", ":", "\n", "                ", "conv_input", "=", "x_asyn", "[", "1", "]", ".", "unsqueeze", "(", "0", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "conv_output", "=", "layer", "(", "conv_input", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "2", "\n", "x_asyn", "[", "1", "]", "=", "conv_output", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'MP'", ":", "\n", "# Get all the updated/changed locations", "\n", "                ", "changed_locations", "=", "(", "x_asyn", "[", "2", "]", ">", "Sites", ".", "ACTIVE_SITE", ".", "value", ")", ".", "nonzero", "(", ")", "\n", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "changed_locations", ".", "long", "(", ")", ",", "feature_map", "=", "x_asyn", "[", "1", "]", ")", "\n", "# rule_book_time += x_asyn[-1]", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'BNRelu'", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "layer", ",", "x_asyn", "[", "2", "]", ".", "clone", "(", ")", ",", "x_asyn", "[", "1", "]", ")", "\n", "x_asyn", "[", "1", "]", "=", "F", ".", "relu", "(", "x_asyn", "[", "1", "]", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "bn_input", "=", "x_asyn", "[", "1", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "bn_output", "=", "F", ".", "relu", "(", "layer", "(", "bn_input", ")", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "2", "\n", "x_asyn", "[", "1", "]", "=", "bn_output", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "fc_output", "=", "layer", "(", "x_asyn", "[", "1", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "flatten", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "2", "\n", "x_asyn", "[", "1", "]", "=", "fc_output", ".", "squeeze", "(", "0", ")", "\n", "# print('Layer Name: %s     Time: %.3f' % (self.layer_list[j][0].ljust(15), (perf_counter() - t1) * 1000))", "\n", "\n", "", "", "return", "x_asyn", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg_cpp.asynSparseVGGCPP.createAsynVGG": [[82, 110], ["enumerate", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers.append", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.rule_book_start.append", "layers.asynSparseConvolution2Dcpp", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers.append", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.rule_book_start.append", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers.append", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.rule_book_start.append", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers.append", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.rule_book_start.append", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers.append", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.rule_book_start.append", "layers.max_pool.asynMaxPool", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers.append", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.rule_book_start.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["None"], ["", "def", "createAsynVGG", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates a asynchronous VGG\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "if", "i_layer", "[", "0", "]", "==", "'C'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "ascn_cpp", ".", "asynSparseConvolution2Dcpp", "(", "dimension", "=", "2", ",", "\n", "nIn", "=", "i_layer", "[", "1", "]", ",", "nOut", "=", "i_layer", "[", "2", "]", ",", "\n", "filter_size", "=", "3", ",", "\n", "first_layer", "=", "self", ".", "rule_book_start", "[", "-", "1", "]", ",", "\n", "use_bias", "=", "self", ".", "use_bias", ",", "debug", "=", "False", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "False", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicC'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "Conv2d", "(", "in_channels", "=", "i_layer", "[", "1", "]", ",", "out_channels", "=", "i_layer", "[", "2", "]", ",", "\n", "kernel_size", "=", "i_layer", "[", "3", "]", ",", "stride", "=", "i_layer", "[", "4", "]", ",", "bias", "=", "False", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "True", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'BNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm1d", "(", "self", ".", "layer_list", "[", "j", "-", "1", "]", "[", "2", "]", ",", "eps", "=", "1e-4", ",", "momentum", "=", "0.9", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "self", ".", "rule_book_start", "[", "-", "1", "]", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm2d", "(", "self", ".", "layer_list", "[", "j", "-", "1", "]", "[", "2", "]", ",", "eps", "=", "1e-4", ",", "momentum", "=", "0.9", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "self", ".", "rule_book_start", "[", "-", "1", "]", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'MP'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "asynMaxPool", "(", "dimension", "=", "2", ",", "filter_size", "=", "3", ",", "filter_stride", "=", "2", ",", "padding_mode", "=", "'valid'", ",", "\n", "device", "=", "self", ".", "device", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "True", ")", "\n", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "in_features", "=", "i_layer", "[", "1", "]", ",", "out_features", "=", "i_layer", "[", "2", "]", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg_cpp.asynSparseVGGCPP.setWeightsEqual": [[111, 133], ["enumerate", "fb_model.sparseModel[].weight.detach().squeeze().cpu().numpy", "numpy.zeros", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers[].setParameters", "fb_model.sparseModel[].weight.squeeze().to().permute", "fb_model.sparseModel[].weight.squeeze().to().permute.reshape().double", "fb_model.sparseModel[].weight.data.double().to", "fb_model.sparseModel[].bias.data.double().to", "fb_model.sparseModel[].running_mean.data.double().to", "fb_model.sparseModel[].running_var.data.double().to", "asyn_sparse_vgg_cpp.asynSparseVGGCPP.asyn_layers[].eval", "fb_model.sparseModel[].eval", "fb_model.linear.weight.data.double().to", "fb_model.linear.bias.data.double().to", "fb_model.sparseModel[].weight.detach().squeeze().cpu", "fb_model.sparseModel[].weight.squeeze().to", "fb_model.sparseModel[].weight.squeeze().to().permute.reshape", "fb_model.sparseModel[].weight.data.double", "fb_model.sparseModel[].bias.data.double", "fb_model.sparseModel[].running_mean.data.double", "fb_model.sparseModel[].running_var.data.double", "fb_model.linear.weight.data.double", "fb_model.linear.bias.data.double", "fb_model.sparseModel[].weight.detach().squeeze", "fb_model.sparseModel[].weight.squeeze", "fb_model.sparseModel[].weight.detach"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.layers.conv_layer_2D_cpp.asynSparseConvolution2Dcpp.setParameters"], ["", "", "", "def", "setWeightsEqual", "(", "self", ",", "fb_model", ")", ":", "\n", "        ", "\"\"\"Sets the different weights and biases equal\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "layer_name", "=", "i_layer", "[", "0", "]", "\n", "if", "layer_name", "==", "'C'", ":", "\n", "                ", "kernel", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "weight", ".", "detach", "(", ")", ".", "squeeze", "(", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "bias", "=", "np", ".", "zeros", "(", "kernel", ".", "shape", "[", "1", "]", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "setParameters", "(", "kernel", ",", "bias", ")", "\n", "", "if", "layer_name", "==", "'ClassicC'", ":", "\n", "                ", "weight_fb", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "weight", ".", "squeeze", "(", "1", ")", ".", "to", "(", "self", ".", "device", ")", ".", "permute", "(", "2", ",", "1", ",", "0", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "weight_fb", ".", "reshape", "(", "[", "weight_fb", ".", "shape", "[", "0", "]", ",", "\n", "weight_fb", ".", "shape", "[", "1", "]", ",", "3", ",", "3", "]", ")", ".", "double", "(", ")", "\n", "", "if", "layer_name", "==", "'BNRelu'", "or", "layer_name", "==", "'ClassicBNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "bias", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_mean", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "running_mean", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_var", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "running_var", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "eval", "(", ")", "\n", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "eval", "(", ")", "\n", "", "if", "layer_name", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "fb_model", ".", "linear", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", "=", "fb_model", ".", "linear", ".", "bias", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg_cpp.asynSparseVGGCPP.generateAsynInput": [[134, 146], ["dataloader.dataset.NCaltech101.generate_event_histogram", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "new_histogram.permute.permute.permute", "training.trainer.AbstractTrainer.denseToSparse", "new_histogram.permute.permute.permute", "new_histogram.permute.permute.squeeze", "spatial_dimensions.cpu().numpy", "spatial_dimensions.cpu().numpy", "spatial_dimensions.cpu", "spatial_dimensions.cpu"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_event_histogram", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse"], ["", "", "", "def", "generateAsynInput", "(", "self", ",", "new_batch_events", ",", "spatial_dimensions", ",", "original_shape", ")", ":", "\n", "        ", "\"\"\"Generates the asynchronous input for the sparse VGG, which is consistent with training input\"\"\"", "\n", "list_spatial_dimensions", "=", "[", "spatial_dimensions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ",", "spatial_dimensions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "1", "]", "]", "\n", "new_histogram", "=", "NCaltech101", ".", "generate_event_histogram", "(", "new_batch_events", ",", "original_shape", ")", "\n", "new_histogram", "=", "torch", ".", "from_numpy", "(", "new_histogram", "[", "np", ".", "newaxis", ",", ":", ",", ":", "]", ")", "\n", "\n", "new_histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "new_histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "list_spatial_dimensions", ")", "\n", "new_histogram", "=", "new_histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "\n", "update_locations", ",", "features", "=", "AbstractTrainer", ".", "denseToSparse", "(", "new_histogram", ")", "\n", "\n", "return", "update_locations", ",", "new_histogram", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg_cpp.asynSparseVGGCPP.applyBatchNorm": [[147, 163], ["torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze().T[].double", "torch.squeeze().T[].double", "torch.squeeze().T[].double", "torch.squeeze().T[].double", "layer", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "bn_active_sites.nonzero", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze.split", "torch.squeeze.split", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze.split", "torch.squeeze.split"], "methods", ["None"], ["", "def", "applyBatchNorm", "(", "self", ",", "layer", ",", "bn_active_sites", ",", "feature_map_to_update", ")", ":", "\n", "        ", "\"\"\"\n        Applies the batch norm layer to the the sparse features.\n\n        :param layer: torch.nn.BatchNorm1d layer\n        :param bn_active_sites: location of the active sites\n        :param feature_map_to_update: feature map, result is stored in place to the tensor\n        \"\"\"", "\n", "bn_active_sites", "[", "bn_active_sites", "==", "Sites", ".", "NEW_INACTIVE_SITE", ".", "value", "]", "=", "0", "\n", "active_sites", "=", "torch", ".", "squeeze", "(", "bn_active_sites", ".", "nonzero", "(", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "bn_input", "=", "torch", ".", "squeeze", "(", "feature_map_to_update", "[", "active_sites", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "1", ")", ".", "T", "[", "None", ",", ":", ",", ":", "]", ".", "double", "(", ")", "\n", "sparse_bn_features", "=", "layer", "(", "bn_input", ")", "\n", "\n", "sparse_bn_features", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "squeeze", "(", "sparse_bn_features", ",", "dim", "=", "0", ")", ".", "T", ",", "dim", "=", "1", ")", "\n", "feature_map_to_update", "[", "active_sites", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "sparse_bn_features", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseVGG.__init__": [[7, 39], ["torch.Module.__init__", "facebook_sparse_vgg.FBSparseVGG.sparseModel.input_spatial_size", "sparseconvnet.InputLayer", "torch.Linear", "torch.Linear", "sparseconvnet.SparseVggNet().add().add().add", "sparseconvnet.SparseVggNet().add().add().add", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sparseconvnet.SparseToDense", "sparseconvnet.SparseToDense", "sparseconvnet.SparseVggNet().add().add", "sparseconvnet.SparseVggNet().add().add", "sparseconvnet.BatchNormReLU", "sparseconvnet.BatchNormReLU", "sparseconvnet.SparseVggNet().add", "sparseconvnet.SparseVggNet().add", "sparseconvnet.Convolution", "sparseconvnet.Convolution", "sparseconvnet.SparseVggNet", "sparseconvnet.SparseVggNet"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", ",", "input_channels", "=", "2", ",", "vgg_12", "=", "False", ")", ":", "\n", "        ", "super", "(", "FBSparseVGG", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "vgg_12", ":", "\n", "            ", "sparse_out_channels", "=", "128", "\n", "self", ".", "sparseModel", "=", "scn", ".", "SparseVggNet", "(", "2", ",", "nInputPlanes", "=", "input_channels", ",", "layers", "=", "[", "\n", "[", "'C'", ",", "16", "]", ",", "[", "'C'", ",", "16", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "32", "]", ",", "[", "'C'", ",", "32", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "64", "]", ",", "[", "'C'", ",", "64", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "128", "]", ",", "[", "'C'", ",", "128", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "256", "]", "]", "\n", ")", ".", "add", "(", "scn", ".", "Convolution", "(", "2", ",", "256", ",", "sparse_out_channels", ",", "3", ",", "filter_stride", "=", "2", ",", "bias", "=", "False", ")", "\n", ")", ".", "add", "(", "scn", ".", "BatchNormReLU", "(", "sparse_out_channels", ")", "\n", ")", ".", "add", "(", "scn", ".", "SparseToDense", "(", "2", ",", "sparse_out_channels", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "sparse_out_channels", "=", "256", "\n", "self", ".", "sparseModel", "=", "scn", ".", "SparseVggNet", "(", "2", ",", "nInputPlanes", "=", "input_channels", ",", "layers", "=", "[", "\n", "[", "'C'", ",", "16", "]", ",", "[", "'C'", ",", "16", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "32", "]", ",", "[", "'C'", ",", "32", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "64", "]", ",", "[", "'C'", ",", "64", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "128", "]", ",", "[", "'C'", ",", "128", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "256", "]", ",", "[", "'C'", ",", "256", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "512", "]", "]", "\n", ")", ".", "add", "(", "scn", ".", "Convolution", "(", "2", ",", "512", ",", "sparse_out_channels", ",", "3", ",", "filter_stride", "=", "2", ",", "bias", "=", "False", ")", "\n", ")", ".", "add", "(", "scn", ".", "BatchNormReLU", "(", "sparse_out_channels", ")", "\n", ")", ".", "add", "(", "scn", ".", "SparseToDense", "(", "2", ",", "sparse_out_channels", ")", ")", "\n", "\n", "", "cnn_spatial_output_size", "=", "[", "2", ",", "3", "]", "\n", "self", ".", "spatial_size", "=", "self", ".", "sparseModel", ".", "input_spatial_size", "(", "torch", ".", "LongTensor", "(", "cnn_spatial_output_size", ")", ")", "\n", "self", ".", "inputLayer", "=", "scn", ".", "InputLayer", "(", "dimension", "=", "2", ",", "spatial_size", "=", "self", ".", "spatial_size", ",", "mode", "=", "2", ")", "\n", "self", ".", "linear_input_features", "=", "cnn_spatial_output_size", "[", "0", "]", "*", "cnn_spatial_output_size", "[", "1", "]", "*", "sparse_out_channels", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "self", ".", "linear_input_features", ",", "nr_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseVGG.forward": [[40, 47], ["facebook_sparse_vgg.FBSparseVGG.inputLayer", "facebook_sparse_vgg.FBSparseVGG.sparseModel", "facebook_sparse_vgg.FBSparseVGG.view", "facebook_sparse_vgg.FBSparseVGG.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "inputLayer", "(", "x", ")", "\n", "x", "=", "self", ".", "sparseModel", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "linear_input_features", ")", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseSparsityInvVGG.__init__": [[50, 62], ["facebook_sparse_vgg.FBSparseVGG.__init__", "facebook_sparse_vgg.FBSparseSparsityInvVGG.sparseModel._modules.items", "torch.ModuleList", "torch.ModuleList", "type", "torch.Conv2d", "torch.Conv2d", "mod.filter_size[].item", "mod.filter_size[].item"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", ",", "input_channels", "=", "2", ")", ":", "\n", "        ", "FBSparseVGG", ".", "__init__", "(", "self", ",", "nr_classes", ",", "input_channels", ")", "\n", "\n", "# generate dense convolutions with only 1s and sparse to dense transforms", "\n", "self", ".", "ones_transforms", "=", "[", "]", "\n", "\n", "for", "name", ",", "mod", "in", "self", ".", "sparseModel", ".", "_modules", ".", "items", "(", ")", ":", "\n", "            ", "if", "type", "(", "mod", ")", "is", "scn", ".", "SubmanifoldConvolution", ":", "\n", "                ", "self", ".", "ones_transforms", "+=", "[", "nn", ".", "Conv2d", "(", "1", ",", "1", ",", "kernel_size", "=", "mod", ".", "filter_size", "[", "0", "]", ".", "item", "(", ")", ",", "padding", "=", "mod", ".", "filter_size", "[", "0", "]", ".", "item", "(", ")", "//", "2", ",", "bias", "=", "False", ")", "]", "\n", "self", ".", "ones_transforms", "[", "-", "1", "]", ".", "weight", ".", "use_grad", "=", "False", "\n", "\n", "", "", "self", ".", "ones_transforms", "=", "nn", ".", "ModuleList", "(", "self", ".", "ones_transforms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseSparsityInvVGG.normalize_input": [[63, 80], ["sparseconvnet.DenseToSparse", "sparseconvnet.SparseToDense", "sparseconvnet.SparseToDense.", "sparseconvnet.DenseToSparse.", "ones_conv", "scn.SparseToDense.abs().sum", "scn.SparseToDense.abs"], "methods", ["None"], ["", "def", "normalize_input", "(", "self", ",", "x", ",", "ones_conv", ")", ":", "\n", "# implements sparsity invariant convolutions: http://www.cvlibs.net/publications/Uhrig2017THREEDV.pdf", "\n", "# unfortunately, now works by bringing activation to dense representation, normalizing and then back to sparse", "\n", "        ", "eps", "=", "1e-5", "\n", "dense_to_sparse", "=", "scn", ".", "DenseToSparse", "(", "2", ")", "\n", "sparse_to_dense", "=", "scn", ".", "SparseToDense", "(", "2", ",", "x", ".", "features", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "dense_x", "=", "sparse_to_dense", "(", "x", ")", "\n", "\n", "# compute active sites and normalization factors", "\n", "active_sites", "=", "(", "dense_x", ".", "abs", "(", ")", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", ">", "0", ")", ".", "float", "(", ")", "\n", "dense_x_normalized", "=", "dense_x", "/", "(", "ones_conv", "(", "active_sites", ")", "+", "eps", ")", "\n", "\n", "# back to sparse", "\n", "x_normalized", "=", "dense_to_sparse", "(", "dense_x_normalized", ")", "\n", "\n", "return", "x_normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseSparsityInvVGG.forward": [[81, 95], ["facebook_sparse_vgg.FBSparseSparsityInvVGG.inputLayer", "enumerate", "facebook_sparse_vgg.FBSparseSparsityInvVGG.view", "facebook_sparse_vgg.FBSparseSparsityInvVGG.linear", "facebook_sparse_vgg.FBSparseSparsityInvVGG.sparseModel._modules.items", "mod", "type", "facebook_sparse_vgg.FBSparseSparsityInvVGG.normalize_input"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseSparsityInvVGG.normalize_input"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "inputLayer", "(", "x", ")", "\n", "counter", "=", "-", "1", "\n", "for", "idx", ",", "(", "name", ",", "mod", ")", "in", "enumerate", "(", "self", ".", "sparseModel", ".", "_modules", ".", "items", "(", ")", ")", ":", "\n", "# if there is a submanifold convolution add sparsity invariant conv", "\n", "            ", "if", "type", "(", "mod", ")", "is", "scn", ".", "SubmanifoldConvolution", ":", "\n", "                ", "counter", "+=", "1", "\n", "x", "=", "self", ".", "normalize_input", "(", "x", ",", "self", ".", "ones_transforms", "[", "counter", "]", ")", "\n", "", "x", "=", "mod", "(", "x", ")", "\n", "\n", "", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "linear_input_features", ")", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseVGGTest.__init__": [[98, 116], ["torch.Module.__init__", "sparseconvnet.SparseVggNet().add().add().add", "facebook_sparse_vgg.FBSparseVGGTest.sparseModel.input_spatial_size", "sparseconvnet.InputLayer", "torch.Linear", "torch.Linear", "sparseconvnet.SparseToDense", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sparseconvnet.SparseVggNet().add().add", "sparseconvnet.BatchNormReLU", "sparseconvnet.SparseVggNet().add", "sparseconvnet.Convolution", "sparseconvnet.SparseVggNet"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", ")", ":", "\n", "        ", "super", "(", "FBSparseVGGTest", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "sparseModel", "=", "scn", ".", "SparseVggNet", "(", "2", ",", "nInputPlanes", "=", "2", ",", "layers", "=", "[", "\n", "[", "'C'", ",", "16", "]", ",", "[", "'C'", ",", "16", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "32", "]", ",", "[", "'C'", ",", "32", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "64", "]", ",", "[", "'C'", ",", "64", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "128", "]", ",", "[", "'C'", ",", "128", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "256", "]", ",", "[", "'C'", ",", "256", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "512", "]", "]", "\n", ")", ".", "add", "(", "scn", ".", "Convolution", "(", "2", ",", "512", ",", "256", ",", "3", ",", "filter_stride", "=", "2", ",", "bias", "=", "False", ")", "\n", ")", ".", "add", "(", "scn", ".", "BatchNormReLU", "(", "256", ")", "\n", ")", ".", "add", "(", "scn", ".", "SparseToDense", "(", "2", ",", "256", ")", ")", "\n", "\n", "cnn_spatial_output_size", "=", "[", "2", ",", "3", "]", "\n", "self", ".", "spatial_size", "=", "self", ".", "sparseModel", ".", "input_spatial_size", "(", "torch", ".", "LongTensor", "(", "cnn_spatial_output_size", ")", ")", "\n", "self", ".", "inputLayer", "=", "scn", ".", "InputLayer", "(", "dimension", "=", "2", ",", "spatial_size", "=", "self", ".", "spatial_size", ",", "mode", "=", "2", ")", "\n", "self", ".", "linear_input_features", "=", "cnn_spatial_output_size", "[", "0", "]", "*", "cnn_spatial_output_size", "[", "1", "]", "*", "256", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "self", ".", "linear_input_features", ",", "nr_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_vgg.FBSparseVGGTest.forward": [[117, 124], ["facebook_sparse_vgg.FBSparseVGGTest.inputLayer", "facebook_sparse_vgg.FBSparseVGGTest.sparseModel", "facebook_sparse_vgg.FBSparseVGGTest.view", "facebook_sparse_vgg.FBSparseVGGTest.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "inputLayer", "(", "x", ")", "\n", "x", "=", "self", ".", "sparseModel", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "linear_input_features", ")", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.__init__": [[14, 34], ["torch.device", "torch.device", "torch.device", "torch.device", "asyn_sparse_vgg.asynSparseVGG.createAsynVGG"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.createAsynVGG"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", "=", "101", ",", "input_channels", "=", "2", ",", "layer_list", "=", "None", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "use_bias", "=", "False", "\n", "self", ".", "asyn_layers", "=", "[", "]", "\n", "if", "layer_list", "is", "not", "None", ":", "\n", "            ", "self", ".", "layer_list", "=", "layer_list", "\n", "", "else", ":", "\n", "            ", "self", ".", "layer_list", "=", "[", "[", "'C'", ",", "2", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "256", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "256", ",", "512", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "512", ",", "256", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "[", "'ClassicFC'", ",", "256", "*", "3", "*", "2", ",", "101", "]", "]", "\n", "", "self", ".", "layer_list", "[", "0", "]", "[", "1", "]", "=", "input_channels", "\n", "self", ".", "layer_list", "[", "-", "1", "]", "[", "2", "]", "=", "nr_classes", "\n", "\n", "self", ".", "rule_book_start", "=", "[", "True", "]", "\n", "\n", "self", ".", "createAsynVGG", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.forward": [[35, 78], ["enumerate", "list", "layer.forward", "layer.forward", "x_asyn[].unsqueeze().permute", "layer", "layer.squeeze().permute", "layer.forward", "x_asyn[].to", "x_asyn[].to", "x_asyn[].to", "x_asyn[].to", "x_asyn[].unsqueeze", "layer.squeeze", "asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "torch.relu", "torch.relu", "changed_locations.long", "x_asyn[].clone", "x_asyn[].permute().unsqueeze", "torch.relu", "torch.relu", "torch.relu.squeeze().permute", "layer", "layer", "layer.squeeze", "x_asyn[].permute", "torch.relu.squeeze", "x_asyn[].permute().flatten().unsqueeze", "x_asyn[].permute().flatten", "x_asyn[].permute"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "def", "forward", "(", "self", ",", "x_asyn", ")", ":", "\n", "        ", "\"\"\"Apply asynchronous layers\"\"\"", "\n", "for", "j", ",", "layer", "in", "enumerate", "(", "self", ".", "asyn_layers", ")", ":", "\n", "# print('Layer Name: %s' % layer_list[j][0])", "\n", "            ", "if", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'C'", ":", "\n", "                ", "if", "self", ".", "rule_book_start", "[", "j", "]", ":", "\n", "                    ", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "feature_map", "=", "x_asyn", "[", "1", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "active_sites_map", "=", "None", ",", "\n", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "", "else", ":", "\n", "                    ", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "feature_map", "=", "x_asyn", "[", "1", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "active_sites_map", "=", "x_asyn", "[", "2", "]", ",", "\n", "rule_book_input", "=", "x_asyn", "[", "3", "]", ",", "\n", "rule_book_output", "=", "x_asyn", "[", "4", "]", ")", "\n", "", "x_asyn", "=", "list", "(", "x_asyn", ")", "\n", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicC'", ":", "\n", "                ", "conv_input", "=", "x_asyn", "[", "1", "]", ".", "unsqueeze", "(", "0", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "conv_output", "=", "layer", "(", "conv_input", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "2", "\n", "x_asyn", "[", "1", "]", "=", "conv_output", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'MP'", ":", "\n", "# Get all the updated/changed locations", "\n", "                ", "changed_locations", "=", "(", "x_asyn", "[", "2", "]", ">", "Sites", ".", "ACTIVE_SITE", ".", "value", ")", ".", "nonzero", "(", ")", "\n", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "changed_locations", ".", "long", "(", ")", ",", "feature_map", "=", "x_asyn", "[", "1", "]", ")", "\n", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'BNRelu'", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "layer", ",", "x_asyn", "[", "2", "]", ".", "clone", "(", ")", ",", "x_asyn", "[", "1", "]", ")", "\n", "x_asyn", "[", "1", "]", "=", "F", ".", "relu", "(", "x_asyn", "[", "1", "]", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "bn_input", "=", "x_asyn", "[", "1", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "bn_output", "=", "F", ".", "relu", "(", "layer", "(", "bn_input", ")", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "2", "\n", "x_asyn", "[", "1", "]", "=", "bn_output", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "fc_output", "=", "layer", "(", "x_asyn", "[", "1", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "flatten", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "2", "\n", "x_asyn", "[", "1", "]", "=", "fc_output", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "", "return", "x_asyn", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.createAsynVGG": [[79, 105], ["enumerate", "asyn_sparse_vgg.asynSparseVGG.asyn_layers.append", "asyn_sparse_vgg.asynSparseVGG.rule_book_start.append", "layers.conv_layer_2D.asynSparseConvolution2D", "asyn_sparse_vgg.asynSparseVGG.asyn_layers.append", "asyn_sparse_vgg.asynSparseVGG.rule_book_start.append", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "asyn_sparse_vgg.asynSparseVGG.asyn_layers.append", "asyn_sparse_vgg.asynSparseVGG.rule_book_start.append", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "asyn_sparse_vgg.asynSparseVGG.asyn_layers.append", "asyn_sparse_vgg.asynSparseVGG.rule_book_start.append", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "asyn_sparse_vgg.asynSparseVGG.asyn_layers.append", "asyn_sparse_vgg.asynSparseVGG.rule_book_start.append", "layers.max_pool.asynMaxPool", "asyn_sparse_vgg.asynSparseVGG.asyn_layers.append", "asyn_sparse_vgg.asynSparseVGG.rule_book_start.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["None"], ["", "def", "createAsynVGG", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates a asynchronous VGG\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "if", "i_layer", "[", "0", "]", "==", "'C'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "asynSparseConvolution2D", "(", "dimension", "=", "2", ",", "nIn", "=", "i_layer", "[", "1", "]", ",", "nOut", "=", "i_layer", "[", "2", "]", ",", "\n", "filter_size", "=", "3", ",", "first_layer", "=", "self", ".", "rule_book_start", "[", "-", "1", "]", ",", "\n", "use_bias", "=", "self", ".", "use_bias", ",", "device", "=", "self", ".", "device", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "False", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicC'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "Conv2d", "(", "in_channels", "=", "i_layer", "[", "1", "]", ",", "out_channels", "=", "i_layer", "[", "2", "]", ",", "\n", "kernel_size", "=", "i_layer", "[", "3", "]", ",", "stride", "=", "i_layer", "[", "4", "]", ",", "bias", "=", "False", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "True", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'BNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm1d", "(", "self", ".", "layer_list", "[", "j", "-", "1", "]", "[", "2", "]", ",", "eps", "=", "1e-4", ",", "momentum", "=", "0.9", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "self", ".", "rule_book_start", "[", "-", "1", "]", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "BatchNorm2d", "(", "self", ".", "layer_list", "[", "j", "-", "1", "]", "[", "2", "]", ",", "eps", "=", "1e-4", ",", "momentum", "=", "0.9", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "self", ".", "rule_book_start", "[", "-", "1", "]", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'MP'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "asynMaxPool", "(", "dimension", "=", "2", ",", "filter_size", "=", "3", ",", "filter_stride", "=", "2", ",", "padding_mode", "=", "'valid'", ",", "\n", "device", "=", "self", ".", "device", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "True", ")", "\n", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "asyn_layers", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "in_features", "=", "i_layer", "[", "1", "]", ",", "out_features", "=", "i_layer", "[", "2", "]", ")", ")", "\n", "self", ".", "rule_book_start", ".", "append", "(", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.setWeightsEqual": [[106, 126], ["enumerate", "fb_model.sparseModel[].weight.squeeze().to", "fb_model.sparseModel[].weight.squeeze().to().permute", "fb_model.sparseModel[].weight.squeeze().to().permute.reshape().double", "fb_model.sparseModel[].weight.data.double().to", "fb_model.sparseModel[].bias.data.double().to", "fb_model.sparseModel[].running_mean.data.double().to", "fb_model.sparseModel[].running_var.data.double().to", "asyn_sparse_vgg.asynSparseVGG.asyn_layers[].eval", "fb_model.sparseModel[].eval", "fb_model.linear.weight.data.double().to", "fb_model.linear.bias.data.double().to", "fb_model.sparseModel[].weight.squeeze", "fb_model.sparseModel[].weight.squeeze().to", "fb_model.sparseModel[].weight.squeeze().to().permute.reshape", "fb_model.sparseModel[].weight.data.double", "fb_model.sparseModel[].bias.data.double", "fb_model.sparseModel[].running_mean.data.double", "fb_model.sparseModel[].running_var.data.double", "fb_model.linear.weight.data.double", "fb_model.linear.bias.data.double", "fb_model.sparseModel[].weight.squeeze"], "methods", ["None"], ["", "", "", "def", "setWeightsEqual", "(", "self", ",", "fb_model", ")", ":", "\n", "        ", "\"\"\"Sets the different weights and biases equal\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "layer_name", "=", "i_layer", "[", "0", "]", "\n", "if", "layer_name", "==", "'C'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "weight", ".", "squeeze", "(", "1", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "layer_name", "==", "'ClassicC'", ":", "\n", "                ", "weight_fb", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "weight", ".", "squeeze", "(", "1", ")", ".", "to", "(", "self", ".", "device", ")", ".", "permute", "(", "2", ",", "1", ",", "0", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "weight_fb", ".", "reshape", "(", "[", "weight_fb", ".", "shape", "[", "0", "]", ",", "\n", "weight_fb", ".", "shape", "[", "1", "]", ",", "3", ",", "3", "]", ")", ".", "double", "(", ")", "\n", "", "if", "layer_name", "==", "'BNRelu'", "or", "layer_name", "==", "'ClassicBNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "bias", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_mean", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "running_mean", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_var", ".", "data", "=", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "running_var", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "eval", "(", ")", "\n", "fb_model", ".", "sparseModel", "[", "j", "]", ".", "eval", "(", ")", "\n", "", "if", "layer_name", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "fb_model", ".", "linear", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", "=", "fb_model", ".", "linear", ".", "bias", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.generateAsynInput": [[127, 139], ["dataloader.dataset.NCaltech101.generate_event_histogram", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "torch.nn.functional.interpolate", "new_histogram.permute.permute.permute", "training.trainer.AbstractTrainer.denseToSparse", "new_histogram.permute.permute.permute", "new_histogram.permute.permute.squeeze", "spatial_dimensions.cpu().numpy", "spatial_dimensions.cpu().numpy", "spatial_dimensions.cpu", "spatial_dimensions.cpu"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCaltech101.generate_event_histogram", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse"], ["", "", "", "def", "generateAsynInput", "(", "self", ",", "new_batch_events", ",", "spatial_dimensions", ",", "original_shape", ")", ":", "\n", "        ", "\"\"\"Generates the asynchronous input for the sparse VGG, which is consistent with training input\"\"\"", "\n", "list_spatial_dimensions", "=", "[", "spatial_dimensions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "0", "]", ",", "spatial_dimensions", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", "1", "]", "]", "\n", "new_histogram", "=", "NCaltech101", ".", "generate_event_histogram", "(", "new_batch_events", ",", "original_shape", ")", "\n", "new_histogram", "=", "torch", ".", "from_numpy", "(", "new_histogram", "[", "np", ".", "newaxis", ",", ":", ",", ":", "]", ")", "\n", "\n", "new_histogram", "=", "torch", ".", "nn", ".", "functional", ".", "interpolate", "(", "new_histogram", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", ",", "list_spatial_dimensions", ")", "\n", "new_histogram", "=", "new_histogram", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "\n", "update_locations", ",", "features", "=", "AbstractTrainer", ".", "denseToSparse", "(", "new_histogram", ")", "\n", "\n", "return", "update_locations", ",", "new_histogram", ".", "squeeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm": [[140, 156], ["torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze().T[].double", "torch.squeeze().T[].double", "torch.squeeze().T[].double", "torch.squeeze().T[].double", "layer", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "torch.unsqueeze", "bn_active_sites.nonzero", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze.split", "torch.squeeze.split", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze.split", "torch.squeeze.split"], "methods", ["None"], ["", "def", "applyBatchNorm", "(", "self", ",", "layer", ",", "bn_active_sites", ",", "feature_map_to_update", ")", ":", "\n", "        ", "\"\"\"\n        Applies the batch norm layer to the the sparse features.\n\n        :param layer: torch.nn.BatchNorm1d layer\n        :param bn_active_sites: location of the active sites\n        :param feature_map_to_update: feature map, result is stored in place to the tensor\n        \"\"\"", "\n", "bn_active_sites", "[", "bn_active_sites", "==", "Sites", ".", "NEW_INACTIVE_SITE", ".", "value", "]", "=", "0", "\n", "active_sites", "=", "torch", ".", "squeeze", "(", "bn_active_sites", ".", "nonzero", "(", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "bn_input", "=", "torch", ".", "squeeze", "(", "feature_map_to_update", "[", "active_sites", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", ",", "dim", "=", "1", ")", ".", "T", "[", "None", ",", ":", ",", ":", "]", ".", "double", "(", ")", "\n", "sparse_bn_features", "=", "layer", "(", "bn_input", ")", "\n", "\n", "sparse_bn_features", "=", "torch", ".", "unsqueeze", "(", "torch", ".", "squeeze", "(", "sparse_bn_features", ",", "dim", "=", "0", ")", ".", "T", ",", "dim", "=", "1", ")", "\n", "feature_map_to_update", "[", "active_sites", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "]", "=", "sparse_bn_features", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.forward": [[159, 210], ["enumerate", "asyn_sparse_vgg.EvalAsynSparseVGGModel.storeStatistics", "list", "layer.forward", "layer.forward", "asyn_sparse_vgg.EvalAsynSparseVGGModel.computeNumberRules", "x_asyn[].unsqueeze().permute", "layer", "layer.squeeze().permute", "layer.forward", "x_asyn[].to", "x_asyn[].to", "x_asyn[].to", "x_asyn[].to", "x_asyn[].unsqueeze", "layer.squeeze", "asyn_sparse_vgg.EvalAsynSparseVGGModel.applyBatchNorm", "torch.relu", "torch.relu", "changed_locations.long", "x_asyn[].clone", "x_asyn[].permute().unsqueeze", "torch.relu", "torch.relu", "torch.relu.squeeze().permute", "layer", "layer.squeeze", "x_asyn[].permute", "torch.relu.squeeze", "layer", "layer", "x_asyn[].permute().flatten().unsqueeze", "x_asyn[].unsqueeze", "x_asyn[].permute().flatten", "x_asyn[].permute"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.storeStatistics", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.computeNumberRules", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.asynSparseVGG.applyBatchNorm", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["    ", "def", "forward", "(", "self", ",", "x_asyn", ",", "active_sum", "=", "None", ",", "nr_sites", "=", "None", ",", "active_sites_vis", "=", "None", ",", "flop_calculation", "=", "False", ")", ":", "\n", "        ", "\"\"\"Apply asynchronous layers\"\"\"", "\n", "for", "j", ",", "layer", "in", "enumerate", "(", "self", ".", "asyn_layers", ")", ":", "\n", "# print('Layer Name: %s' % self.layer_list[j][0])", "\n", "            ", "self", ".", "storeStatistics", "(", "active_sum", ",", "nr_sites", ",", "active_sites_vis", ",", "x_asyn", ",", "j", ")", "\n", "\n", "if", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'C'", ":", "\n", "                ", "if", "self", ".", "rule_book_start", "[", "j", "]", ":", "\n", "                    ", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "feature_map", "=", "x_asyn", "[", "1", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "active_sites_map", "=", "None", ",", "\n", "rule_book_input", "=", "None", ",", "\n", "rule_book_output", "=", "None", ")", "\n", "", "else", ":", "\n", "                    ", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "x_asyn", "[", "0", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "feature_map", "=", "x_asyn", "[", "1", "]", ".", "to", "(", "self", ".", "device", ")", ",", "\n", "active_sites_map", "=", "x_asyn", "[", "2", "]", ",", "\n", "rule_book_input", "=", "x_asyn", "[", "3", "]", ",", "\n", "rule_book_output", "=", "x_asyn", "[", "4", "]", ")", "\n", "", "x_asyn", "=", "list", "(", "x_asyn", ")", "\n", "\n", "if", "flop_calculation", ":", "\n", "# Store number of rules to get number of FLOP", "\n", "                    ", "active_sum", "[", "j", "]", "=", "self", ".", "computeNumberRules", "(", "x_asyn", "[", "3", "]", ")", "\n", "\n", "", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicC'", ":", "\n", "                ", "conv_input", "=", "x_asyn", "[", "1", "]", ".", "unsqueeze", "(", "0", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "conv_output", "=", "layer", "(", "conv_input", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "5", "\n", "x_asyn", "[", "1", "]", "=", "conv_output", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'MP'", ":", "\n", "# Get all the updated and changed locations", "\n", "                ", "changed_locations", "=", "(", "x_asyn", "[", "2", "]", ">", "Sites", ".", "ACTIVE_SITE", ".", "value", ")", ".", "nonzero", "(", ")", "\n", "x_asyn", "=", "layer", ".", "forward", "(", "update_location", "=", "changed_locations", ".", "long", "(", ")", ",", "feature_map", "=", "x_asyn", "[", "1", "]", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'BNRelu'", ":", "\n", "                ", "self", ".", "applyBatchNorm", "(", "layer", ",", "x_asyn", "[", "2", "]", ".", "clone", "(", ")", ",", "x_asyn", "[", "1", "]", ")", "\n", "x_asyn", "[", "1", "]", "=", "F", ".", "relu", "(", "x_asyn", "[", "1", "]", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "bn_input", "=", "x_asyn", "[", "1", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "bn_output", "=", "F", ".", "relu", "(", "layer", "(", "bn_input", ")", ")", "\n", "x_asyn", "=", "[", "None", "]", "*", "5", "\n", "x_asyn", "[", "1", "]", "=", "bn_output", ".", "squeeze", "(", "0", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "if", "x_asyn", "[", "1", "]", ".", "ndim", "==", "3", ":", "\n", "                    ", "fc_output", "=", "layer", "(", "x_asyn", "[", "1", "]", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "flatten", "(", ")", ".", "unsqueeze", "(", "0", ")", ")", "\n", "", "else", ":", "\n", "                    ", "fc_output", "=", "layer", "(", "x_asyn", "[", "1", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "", "x_asyn", "=", "[", "None", "]", "*", "5", "\n", "x_asyn", "[", "1", "]", "=", "fc_output", ".", "squeeze", "(", "0", ")", "\n", "\n", "", "", "return", "x_asyn", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.storeStatistics": [[211, 233], ["asyn_sparse_vgg.EvalAsynSparseVGGModel.visualizeActiveSites", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu().numpy", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod().cpu", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor().prod", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.visualizeActiveSites"], ["", "def", "storeStatistics", "(", "self", ",", "active_sum", ",", "nr_sites", ",", "active_sites_vis", ",", "x_asyn", ",", "j", ")", ":", "\n", "        ", "\"\"\"Stores several model statistics\"\"\"", "\n", "# Count number of active and overall sites", "\n", "if", "active_sum", "is", "not", "None", ":", "\n", "            ", "if", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "[", ":", "7", "]", "==", "'Classic'", ":", "\n", "                ", "nr_active_sites_classic", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "1", "]", ".", "shape", "[", ":", "2", "]", ")", ".", "prod", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "active_sum", "[", "j", "]", "=", "nr_active_sites_classic", "\n", "nr_sites", "[", "j", "]", "=", "nr_active_sites_classic", "\n", "", "elif", "x_asyn", "[", "2", "]", "is", "None", ":", "\n", "                ", "active_sum", "[", "j", "]", "=", "x_asyn", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "nr_sites", "[", "j", "]", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "1", "]", "[", ":", ",", ":", ",", "0", "]", ".", "shape", ")", ".", "prod", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "-", "1", "]", "[", "0", "]", "==", "'MP'", ":", "\n", "# If sparse MaxPool was the layer before, x_asyn[2] includes the max indices and not activity map", "\n", "                ", "active_sum", "[", "j", "]", "=", "x_asyn", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "nr_sites", "[", "j", "]", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "1", "]", "[", ":", ",", ":", ",", "0", "]", ".", "shape", ")", ".", "prod", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "                ", "active_sum", "[", "j", "]", "=", "(", "x_asyn", "[", "2", "]", ">", "Sites", ".", "ACTIVE_SITE", ".", "value", ")", ".", "sum", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "nr_sites", "[", "j", "]", "=", "torch", ".", "tensor", "(", "x_asyn", "[", "1", "]", "[", ":", ",", ":", ",", "0", "]", ".", "shape", ")", ".", "prod", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "# Visualization of input and active sites", "\n", "", "", "if", "active_sites_vis", "is", "not", "None", "and", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "[", ":", "7", "]", "!=", "'Classic'", ":", "\n", "            ", "self", ".", "visualizeActiveSites", "(", "x_asyn", ",", "active_sites_vis", ",", "j", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.computeNumberRules": [[234, 241], ["len"], "methods", ["None"], ["", "", "def", "computeNumberRules", "(", "self", ",", "rule_book_input", ")", ":", "\n", "        ", "\"\"\"Calculates the number of rules stored in the input_rulebook\"\"\"", "\n", "nr_rules", "=", "0", "\n", "for", "kernel_list", "in", "rule_book_input", ":", "\n", "            ", "nr_rules", "+=", "len", "(", "kernel_list", ")", "\n", "\n", "", "return", "nr_rules", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.convertWeightsDouble": [[242, 259], ["enumerate", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].bias.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].running_mean.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].running_var.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].eval", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].bias.data.double().to", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].bias.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].running_mean.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].running_var.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].weight.data.double", "asyn_sparse_vgg.EvalAsynSparseVGGModel.asyn_layers[].bias.data.double"], "methods", ["None"], ["", "def", "convertWeightsDouble", "(", "self", ")", ":", "\n", "        ", "\"\"\"Is required if the weights are randomly initialised and not copied from another model by setWeightsEqual.\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "layer_name", "=", "i_layer", "[", "0", "]", "\n", "if", "layer_name", "==", "'C'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "layer_name", "==", "'ClassicC'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "", "if", "layer_name", "==", "'BNRelu'", "or", "layer_name", "==", "'ClassicBNRelu'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_mean", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_mean", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_var", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "running_var", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "eval", "(", ")", "\n", "", "if", "layer_name", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "weight", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", "=", "self", ".", "asyn_layers", "[", "j", "]", ".", "bias", ".", "data", ".", "double", "(", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.visualizeActiveSites": [[260, 281], ["numpy.uint8", "PIL.Image.fromarray", "numpy.asarray", "numpy.uint8", "PIL.Image.fromarray", "numpy.asarray", "PIL.Image.fromarray.resize", "numpy.array", "PIL.Image.fromarray.resize", "numpy.array", "numpy.array", "numpy.array"], "methods", ["None"], ["", "", "", "def", "visualizeActiveSites", "(", "self", ",", "x_asyn", ",", "active_sites_vis", ",", "j_layer", ")", ":", "\n", "        ", "\"\"\"Visualizes the active sites and the input events\"\"\"", "\n", "sites_map", "=", "(", "(", "x_asyn", "[", "1", "]", "**", "2", ")", ".", "sum", "(", "-", "1", ",", "keepdim", "=", "True", ")", ">", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "o_height", ",", "o_width", "=", "active_sites_vis", ".", "shape", "[", "2", ":", "4", "]", "\n", "np_img", "=", "sites_map", "*", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "[", "None", ",", "None", ",", ":", "]", "\n", "np_img", "=", "np", ".", "uint8", "(", "np_img", ")", "\n", "img", "=", "Image", ".", "fromarray", "(", "np_img", ")", "\n", "active_sites_vis", "[", "0", ",", "j_layer", ",", ":", ",", ":", ",", ":", "]", "=", "np", ".", "asarray", "(", "img", ".", "resize", "(", "[", "o_width", ",", "o_height", "]", ",", "resample", "=", "0", ")", ")", "\n", "\n", "if", "x_asyn", "[", "2", "]", "is", "None", ":", "\n", "            ", "np_img", "[", "x_asyn", "[", "0", "]", "[", ":", ",", "0", "]", ",", "x_asyn", "[", "0", "]", "[", ":", ",", "1", "]", ",", ":", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j_layer", "-", "1", "]", "[", "0", "]", "==", "'MP'", ":", "\n", "# If sparse MaxPool was the layer before, x_asyn[2] includes the max indices and not activity map", "\n", "            ", "np_img", "[", "x_asyn", "[", "0", "]", "[", ":", ",", "0", "]", ",", "x_asyn", "[", "0", "]", "[", ":", ",", "1", "]", ",", ":", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "", "else", ":", "\n", "            ", "active_indices", "=", "(", "(", "x_asyn", "[", "2", "]", ">", "Sites", ".", "ACTIVE_SITE", ".", "value", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ".", "nonzero", "(", ")", "\n", "np_img", "[", "active_indices", "[", "0", "]", ",", "active_indices", "[", "1", "]", ",", ":", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "\n", "", "np_img", "=", "np", ".", "uint8", "(", "np_img", ")", "\n", "img", "=", "Image", ".", "fromarray", "(", "np_img", ")", "\n", "active_sites_vis", "[", "1", ",", "j_layer", ",", ":", ",", ":", ",", ":", "]", "=", "np", ".", "asarray", "(", "img", ".", "resize", "(", "[", "o_width", ",", "o_height", "]", ",", "resample", "=", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_VGG.DenseVGG.__init__": [[5, 43], ["torch.Module.__init__", "torch.Linear", "torch.Sequential", "torch.Sequential", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "dense_VGG.DenseVGG.conv_block", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", ",", "in_c", "=", "2", ",", "vgg_12", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "kernel_size", "=", "3", "\n", "if", "vgg_12", ":", "\n", "            ", "sparse_out_channels", "=", "128", "\n", "self", ".", "conv_layers", "=", "nn", ".", "Sequential", "(", "\n", "self", ".", "conv_block", "(", "in_c", "=", "in_c", ",", "out_c", "=", "16", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "16", ",", "out_c", "=", "32", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "32", ",", "out_c", "=", "64", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "64", ",", "out_c", "=", "128", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "128", ",", "out_channels", "=", "256", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "256", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "256", ",", "out_channels", "=", "sparse_out_channels", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "sparse_out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "\n", "", "else", ":", "\n", "            ", "sparse_out_channels", "=", "256", "\n", "self", ".", "conv_layers", "=", "nn", ".", "Sequential", "(", "\n", "self", ".", "conv_block", "(", "in_c", "=", "in_c", ",", "out_c", "=", "16", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "16", ",", "out_c", "=", "32", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "32", ",", "out_c", "=", "64", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "64", ",", "out_c", "=", "128", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "128", ",", "out_c", "=", "256", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "256", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "512", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "512", ",", "out_channels", "=", "sparse_out_channels", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "\n", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "sparse_out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n", "\n", "", "self", ".", "linear_input_features", "=", "2", "*", "3", "*", "sparse_out_channels", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "self", ".", "linear_input_features", ",", "nr_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_VGG.DenseVGG.conv_block": [[44, 53], ["torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.Conv2d", "torch.BatchNorm2d", "torch.ReLU", "torch.MaxPool2d"], "methods", ["None"], ["", "def", "conv_block", "(", "self", ",", "in_c", ",", "out_c", ")", ":", "\n", "        ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_c", ",", "out_c", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_c", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "out_c", ",", "out_c", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_c", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "self", ".", "kernel_size", ",", "stride", "=", "2", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_VGG.DenseVGG.forward": [[55, 61], ["dense_VGG.DenseVGG.conv_layers", "dense_VGG.DenseVGG.view", "dense_VGG.DenseVGG.linear", "dense_VGG.DenseVGG.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv_layers", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "linear_input_features", ")", "# flat", "\n", "x", "=", "self", ".", "linear", "(", "x", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_loss.yoloLoss": [[8, 81], ["input_shape.to.to", "torch.tensor", "models.yolo_detection.yoloParseOutput", "yolo_loss.processGroundTruth", "models.yolo_detection.yoloDetect", "[].repeat", "computeIoU().detach", "torch.max", "torch.stack", "[].mean", "torch.stack", "[].mean", "[].mean", "torch.ones_like", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss.", "bounding_box.sum", "yolo_loss.computeIoU", "torch.arange", "torch.ones_like.bool"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloParseOutput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_loss.processGroundTruth", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloDetect", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_loss.computeIoU"], ["def", "yoloLoss", "(", "model_output", ",", "bounding_box", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"Computes the loss used in YOLO: https://arxiv.org/pdf/1506.02640.pdf\"\"\"", "\n", "lambda_coord", "=", "5", "\n", "lambda_no_object", "=", "0.5", "\n", "lambda_class", "=", "1", "\n", "\n", "batch_s", ",", "gt_nr_bbox", ",", "_", "=", "bounding_box", ".", "shape", "\n", "input_shape", "=", "input_shape", ".", "to", "(", "model_output", ".", "device", ")", "\n", "cell_map_shape", "=", "torch", ".", "tensor", "(", "model_output", ".", "shape", "[", "1", ":", "3", "]", ",", "device", "=", "model_output", ".", "device", ")", "\n", "\n", "x_offset_norm", ",", "y_offset_norm", ",", "h_norm_sqrt", ",", "w_norm_sqrt", ",", "pred_conf", ",", "pred_cls", "=", "yoloParseOutput", "(", "model_output", ")", "\n", "\n", "out", "=", "processGroundTruth", "(", "bounding_box", ",", "input_shape", ",", "cell_map_shape", ")", "\n", "gt_cell_corner_offset_norm", ",", "gt_bbox_shape_norm_sqrt", ",", "gt_cell_x", ",", "gt_cell_y", "=", "out", "\n", "\n", "# Get IoU at gt_bbox_position", "\n", "bbox_detection", "=", "yoloDetect", "(", "model_output", ",", "input_shape", ")", "\n", "batch_indices", "=", "torch", ".", "arange", "(", "batch_s", ")", "[", ":", ",", "None", "]", ".", "repeat", "(", "[", "1", ",", "gt_nr_bbox", "]", ")", "\n", "bbox_detection", "=", "bbox_detection", "[", "batch_indices", ",", "gt_cell_x", ",", "gt_cell_y", ",", ":", ",", ":", "]", "\n", "\n", "iou", "=", "computeIoU", "(", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", ":", "4", "]", ",", "bounding_box", "[", ":", ",", ":", ",", ":", "4", "]", ")", ".", "detach", "(", ")", "\n", "confidence_score", ",", "responsible_pred_bbox_idx", "=", "torch", ".", "max", "(", "iou", ",", "dim", "=", "-", "1", ")", "\n", "\n", "valid_gt_bbox_mask", "=", "bounding_box", ".", "sum", "(", "-", "1", ")", ">", "0", "\n", "\n", "# ----- Offset Loss -----", "\n", "pred_cell_offset_norm", "=", "torch", ".", "stack", "(", "[", "x_offset_norm", ",", "y_offset_norm", "]", ",", "dim", "=", "-", "1", ")", "\n", "# Get the predictions, which include a object and correspond to the responsible cell", "\n", "pred_cell_offset_norm", "=", "pred_cell_offset_norm", "[", "batch_indices", ",", "gt_cell_x", ",", "gt_cell_y", ",", "responsible_pred_bbox_idx", ",", ":", "]", "\n", "\n", "offset_delta", "=", "pred_cell_offset_norm", "-", "gt_cell_corner_offset_norm", "\n", "offset_loss", "=", "(", "offset_delta", "**", "2", ")", ".", "sum", "(", "-", "1", ")", "[", "valid_gt_bbox_mask", "]", ".", "mean", "(", ")", "\n", "\n", "# ----- Height&Width Loss -----", "\n", "pred_cell_shape_norm_sqrt", "=", "torch", ".", "stack", "(", "[", "h_norm_sqrt", ",", "w_norm_sqrt", "]", ",", "dim", "=", "-", "1", ")", "\n", "# Get the predictions, which include a object and correspond to the responsible cell", "\n", "pred_cell_shape_norm_sqrt", "=", "pred_cell_shape_norm_sqrt", "[", "batch_indices", ",", "gt_cell_x", ",", "gt_cell_y", ",", "\n", "responsible_pred_bbox_idx", ",", ":", "]", "\n", "\n", "shape_delta", "=", "pred_cell_shape_norm_sqrt", "-", "gt_bbox_shape_norm_sqrt", "\n", "shape_loss", "=", "(", "shape_delta", "**", "2", ")", ".", "sum", "(", "-", "1", ")", "[", "valid_gt_bbox_mask", "]", ".", "mean", "(", ")", "\n", "\n", "# ----- Object Confidence Loss -----", "\n", "# Get the predictions, which include a object and correspond to the responsible cell", "\n", "pred_conf_object", "=", "pred_conf", "[", "batch_indices", ",", "gt_cell_x", ",", "gt_cell_y", ",", "responsible_pred_bbox_idx", "]", "\n", "\n", "confidence_delta", "=", "pred_conf_object", "-", "confidence_score", "\n", "confidence_loss", "=", "(", "confidence_delta", "**", "2", ")", "[", "valid_gt_bbox_mask", "]", ".", "mean", "(", ")", "\n", "\n", "# ----- No Object Confidence Loss -----", "\n", "# Get the predictions, which do not include a object", "\n", "no_object_mask", "=", "torch", ".", "ones_like", "(", "pred_conf", ")", "\n", "no_object_mask", "[", "batch_indices", "[", "valid_gt_bbox_mask", "]", ",", "gt_cell_x", "[", "valid_gt_bbox_mask", "]", ",", "gt_cell_y", "[", "valid_gt_bbox_mask", "]", ",", "\n", "responsible_pred_bbox_idx", "[", "valid_gt_bbox_mask", "]", "]", "=", "0", "\n", "confidence_no_object_loss", "=", "(", "pred_conf", "[", "no_object_mask", ".", "bool", "(", ")", "]", "**", "2", ")", ".", "mean", "(", ")", "\n", "\n", "# ----- Class Prediction Loss -----", "\n", "loss_function", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "pred_class_bbox", "=", "pred_cls", "[", "batch_indices", ",", "gt_cell_x", ",", "gt_cell_y", ",", ":", "]", "\n", "class_label", "=", "bounding_box", "[", ":", ",", ":", ",", "-", "1", "]", "\n", "\n", "pred_class_bbox", "=", "pred_class_bbox", "[", "valid_gt_bbox_mask", "]", "\n", "class_label", "=", "class_label", "[", "valid_gt_bbox_mask", "]", "\n", "class_loss", "=", "loss_function", "(", "pred_class_bbox", ",", "target", "=", "class_label", ")", "\n", "\n", "offset_loss", "=", "lambda_coord", "*", "offset_loss", "\n", "shape_loss", "=", "lambda_coord", "*", "shape_loss", "\n", "confidence_no_object_loss", "=", "lambda_no_object", "*", "confidence_no_object_loss", "\n", "class_loss", "=", "lambda_class", "*", "class_loss", "\n", "\n", "loss", "=", "offset_loss", "+", "shape_loss", "+", "confidence_loss", "+", "confidence_no_object_loss", "+", "class_loss", "\n", "\n", "return", "loss", ",", "offset_loss", ",", "shape_loss", ",", "confidence_loss", ",", "confidence_no_object_loss", ",", "class_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_loss.processGroundTruth": [[83, 107], ["models.yolo_detection.getGrid", "torch.min", "torch.min", "torch.stack", "torch.stack", "torch.sqrt", "cell_shape[].float", "input_shape.float"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.getGrid"], ["", "def", "processGroundTruth", "(", "bounding_box", ",", "input_shape", ",", "cell_map_shape", ")", ":", "\n", "    ", "\"\"\"Normalizes and computes the offset to the grid corner\"\"\"", "\n", "# Construct normalized, relative ground truth", "\n", "cell_corners", "=", "getGrid", "(", "input_shape", ",", "cell_map_shape", ")", "\n", "cell_shape", "=", "input_shape", "/", "cell_map_shape", "\n", "# bounding_box[0, 0, :]: ['u', 'v', 'w', 'h', 'class_id'].  (u, v) is top left point", "\n", "gt_bbox_center", "=", "bounding_box", "[", ":", ",", ":", ",", ":", "2", "]", "+", "bounding_box", "[", ":", ",", ":", ",", "2", ":", "4", "]", "//", "2", "\n", "# (u, v) -> (x, y)", "\n", "gt_cell_corner_offset_x", "=", "gt_bbox_center", "[", ":", ",", ":", ",", "1", ",", "None", "]", "-", "cell_corners", "[", "None", ",", "None", ",", ":", ",", "0", ",", "0", "]", "\n", "gt_cell_corner_offset_x", "[", "gt_cell_corner_offset_x", "<", "0", "]", "=", "999999", "\n", "gt_cell_corner_offset_x", ",", "gt_cell_x", "=", "torch", ".", "min", "(", "gt_cell_corner_offset_x", ",", "dim", "=", "-", "1", ")", "\n", "\n", "gt_cell_corner_offset_y", "=", "gt_bbox_center", "[", ":", ",", ":", ",", "0", ",", "None", "]", "-", "cell_corners", "[", "None", ",", "None", ",", "0", ",", ":", ",", "1", "]", "\n", "gt_cell_corner_offset_y", "[", "gt_cell_corner_offset_y", "<", "0", "]", "=", "999999", "\n", "gt_cell_corner_offset_y", ",", "gt_cell_y", "=", "torch", ".", "min", "(", "gt_cell_corner_offset_y", ",", "dim", "=", "-", "1", ")", "\n", "\n", "gt_cell_corner_offset", "=", "torch", ".", "stack", "(", "[", "gt_cell_corner_offset_x", ",", "gt_cell_corner_offset_y", "]", ",", "dim", "=", "-", "1", ")", "\n", "gt_cell_corner_offset_norm", "=", "gt_cell_corner_offset", "/", "cell_shape", "[", "None", ",", "None", ",", ":", "]", ".", "float", "(", ")", "\n", "\n", "# (width, height) -> (height, width)", "\n", "gt_bbox_shape", "=", "torch", ".", "stack", "(", "[", "bounding_box", "[", ":", ",", ":", ",", "3", "]", ",", "bounding_box", "[", ":", ",", ":", ",", "2", "]", "]", ",", "dim", "=", "-", "1", ")", "\n", "gt_bbox_shape_norm_sqrt", "=", "torch", ".", "sqrt", "(", "gt_bbox_shape", "/", "input_shape", ".", "float", "(", ")", ")", "\n", "\n", "return", "gt_cell_corner_offset_norm", ",", "gt_bbox_shape_norm_sqrt", ",", "gt_cell_x", ",", "gt_cell_y", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_loss.computeIoU": [[109, 136], ["bbox_detection.long().float.long().float", "gt_bbox.float.float", "torch.max", "torch.max", "torch.min", "torch.min", "torch.max", "torch.zeros_like", "torch.max.float", "bbox_detection.long().float.long", "bbox_detection[].prod", "gt_bbox[].prod", "union_area.float"], "function", ["None"], ["", "def", "computeIoU", "(", "bbox_detection", ",", "gt_bbox", ")", ":", "\n", "    ", "\"\"\"\n    Computes for bounding boxes in bbox_detection the IoU with the gt_bbox.\n\n    :param bbox_detection: [batch_size, bounding_box_to_compare, nr_pred_bbox, 4]\n    :param gt_bbox: [batch_size, bounding_box_to_compare, 4]\n    \"\"\"", "\n", "bbox_detection", "=", "bbox_detection", ".", "long", "(", ")", ".", "float", "(", ")", "\n", "gt_bbox", "=", "gt_bbox", ".", "float", "(", ")", "\n", "\n", "# bbox_detection: bounding_box[0, 0, :]: ['u', 'v', 'w', 'h'].  (u, v) is top left point", "\n", "# (u, v) -> (x, y)", "\n", "intersection_left_x", "=", "torch", ".", "max", "(", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "0", "]", ",", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "1", "]", ")", "\n", "intersection_left_y", "=", "torch", ".", "max", "(", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "1", "]", ",", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "0", "]", ")", "\n", "intersection_right_x", "=", "torch", ".", "min", "(", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "0", "]", "+", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "2", "]", ",", "\n", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "1", "]", "+", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "3", "]", ")", "\n", "intersection_right_y", "=", "torch", ".", "min", "(", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "1", "]", "+", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "3", "]", ",", "\n", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "0", "]", "+", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "2", "]", ")", "\n", "\n", "intersection_area", "=", "(", "intersection_right_x", "-", "intersection_left_x", ")", "*", "(", "intersection_right_y", "-", "intersection_left_y", ")", "\n", "intersection_area", "=", "torch", ".", "max", "(", "intersection_area", ",", "torch", ".", "zeros_like", "(", "intersection_area", ")", ")", "\n", "\n", "union_area", "=", "bbox_detection", "[", ":", ",", ":", ",", ":", ",", "2", ":", "4", "]", ".", "prod", "(", "axis", "=", "-", "1", ")", "+", "gt_bbox", "[", ":", ",", ":", ",", "None", ",", "2", ":", "4", "]", ".", "prod", "(", "axis", "=", "-", "1", ")", "-", "intersection_area", "\n", "intersection_over_union", "=", "intersection_area", ".", "float", "(", ")", "/", "(", "union_area", ".", "float", "(", ")", "+", "1e-9", ")", "\n", "\n", "return", "intersection_over_union", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloParseOutput": [[5, 16], ["torch.sigmoid"], "function", ["None"], ["def", "yoloParseOutput", "(", "model_output", ",", "nr_bbox", "=", "2", ")", ":", "\n", "    ", "\"\"\"Parses the dense ouput to the predicted values\"\"\"", "\n", "# Get outputs", "\n", "x_norm_rel", "=", "model_output", "[", "...", ",", "0", ":", "nr_bbox", "]", "# Center x", "\n", "y_norm_rel", "=", "model_output", "[", "...", ",", "nr_bbox", ":", "nr_bbox", "*", "2", "]", "# Center y", "\n", "h_norm_sqrt", "=", "model_output", "[", "...", ",", "nr_bbox", "*", "2", ":", "nr_bbox", "*", "3", "]", "# Height", "\n", "w_norm_sqrt", "=", "model_output", "[", "...", ",", "nr_bbox", "*", "3", ":", "nr_bbox", "*", "4", "]", "# Width", "\n", "pred_conf", "=", "torch", ".", "sigmoid", "(", "model_output", "[", "...", ",", "nr_bbox", "*", "4", ":", "nr_bbox", "*", "5", "]", ")", "# Object Confidence", "\n", "pred_cls", "=", "model_output", "[", "...", ",", "nr_bbox", "*", "5", ":", "]", "# Class Score", "\n", "\n", "return", "x_norm_rel", ",", "y_norm_rel", ",", "h_norm_sqrt", ",", "w_norm_sqrt", ",", "pred_conf", ",", "pred_cls", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloDetect": [[18, 58], ["torch.tensor", "yolo_detection.yoloParseOutput", "yolo_detection.getGrid", "bbox_top_left_corner[].squeeze", "torch.argmax", "pred_cls_conf[].squeeze", "torch.cat", "yolo_detection.cropToFrame", "torch.stack", "torch.cat", "torch.zeros", "torch.stack", "batch_idx.float", "detected_top_left_corner[].float", "detected_top_left_corner[].float", "detected_w.float", "detected_h.float", "torch.argmax.float", "pred_cls_conf[].float", "h.unsqueeze", "w.unsqueeze", "pred_conf.unsqueeze", "torch.arange", "torch.argmax.squeeze"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.yoloParseOutput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.getGrid", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.cropToFrame"], ["", "def", "yoloDetect", "(", "model_output", ",", "input_shape", ",", "threshold", "=", "None", ")", ":", "\n", "    ", "\"\"\"Computes the detections used in YOLO: https://arxiv.org/pdf/1506.02640.pdf\"\"\"", "\n", "cell_map_shape", "=", "torch", ".", "tensor", "(", "model_output", ".", "shape", "[", "1", ":", "3", "]", ",", "device", "=", "model_output", ".", "device", ")", "\n", "cell_shape", "=", "input_shape", "/", "cell_map_shape", "\n", "x_norm_rel", ",", "y_norm_rel", ",", "h_norm_sqrt", ",", "w_norm_sqrt", ",", "pred_conf", ",", "pred_cls_conf", "=", "yoloParseOutput", "(", "model_output", ")", "\n", "\n", "h", "=", "h_norm_sqrt", "**", "2", "*", "input_shape", "[", "0", "]", "\n", "w", "=", "w_norm_sqrt", "**", "2", "*", "input_shape", "[", "1", "]", "\n", "\n", "x_rel", "=", "x_norm_rel", "*", "cell_shape", "[", "0", "]", "\n", "y_rel", "=", "y_norm_rel", "*", "cell_shape", "[", "1", "]", "\n", "cell_top_left", "=", "getGrid", "(", "input_shape", ",", "cell_map_shape", ")", "\n", "\n", "bbox_center", "=", "cell_top_left", "[", "None", ",", ":", ",", ":", ",", "None", ",", ":", "]", "+", "torch", ".", "stack", "(", "[", "x_rel", ",", "y_rel", "]", ",", "dim", "=", "-", "1", ")", "\n", "bbox_top_left_corner", "=", "bbox_center", "-", "torch", ".", "stack", "(", "[", "h", ",", "w", "]", ",", "dim", "=", "-", "1", ")", "//", "2", "\n", "\n", "if", "threshold", "is", "None", ":", "\n", "        ", "return", "torch", ".", "cat", "(", "[", "bbox_top_left_corner", ",", "h", ".", "unsqueeze", "(", "-", "1", ")", ",", "w", ".", "unsqueeze", "(", "-", "1", ")", ",", "pred_conf", ".", "unsqueeze", "(", "-", "1", ")", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "detected_bbox_idx", "=", "(", "pred_conf", ">", "threshold", ")", ".", "nonzero", "(", ")", ".", "split", "(", "1", ",", "dim", "=", "-", "1", ")", "\n", "batch_idx", "=", "detected_bbox_idx", "[", "0", "]", "\n", "\n", "if", "batch_idx", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "torch", ".", "zeros", "(", "[", "0", ",", "7", "]", ")", "\n", "\n", "", "detected_top_left_corner", "=", "bbox_top_left_corner", "[", "detected_bbox_idx", "]", ".", "squeeze", "(", "1", ")", "\n", "detected_h", "=", "h", "[", "detected_bbox_idx", "]", "\n", "detected_w", "=", "w", "[", "detected_bbox_idx", "]", "\n", "pred_conf", "=", "pred_conf", "[", "detected_bbox_idx", "]", "\n", "\n", "pred_cls", "=", "torch", ".", "argmax", "(", "pred_cls_conf", "[", "detected_bbox_idx", "[", ":", "-", "1", "]", "]", ",", "dim", "=", "-", "1", ")", "\n", "pred_cls_conf", "=", "pred_cls_conf", "[", "detected_bbox_idx", "[", ":", "-", "1", "]", "]", ".", "squeeze", "(", "1", ")", "\n", "pred_cls_conf", "=", "pred_cls_conf", "[", "torch", ".", "arange", "(", "pred_cls", ".", "shape", "[", "0", "]", ")", ",", "pred_cls", ".", "squeeze", "(", "-", "1", ")", "]", "\n", "\n", "# Convert from x, y to u, v", "\n", "det_bbox", "=", "torch", ".", "cat", "(", "[", "batch_idx", ".", "float", "(", ")", ",", "detected_top_left_corner", "[", ":", ",", "1", ",", "None", "]", ".", "float", "(", ")", ",", "\n", "detected_top_left_corner", "[", ":", ",", "0", ",", "None", "]", ".", "float", "(", ")", ",", "detected_w", ".", "float", "(", ")", ",", "detected_h", ".", "float", "(", ")", ",", "\n", "pred_cls", ".", "float", "(", ")", ",", "pred_cls_conf", "[", ":", ",", "None", "]", ".", "float", "(", ")", ",", "pred_conf", "]", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "cropToFrame", "(", "det_bbox", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.getGrid": [[60, 68], ["torch.meshgrid", "torch.stack", "torch.arange", "torch.arange"], "function", ["None"], ["", "def", "getGrid", "(", "input_shape", ",", "cell_map_shape", ")", ":", "\n", "    ", "\"\"\"Constructs a 2D grid with the cell center coordinates.\"\"\"", "\n", "cell_shape", "=", "input_shape", "/", "cell_map_shape", "\n", "cell_top_left", "=", "torch", ".", "meshgrid", "(", "[", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "cell_map_shape", "[", "0", "]", "*", "cell_shape", "[", "0", "]", ",", "step", "=", "cell_shape", "[", "0", "]", ",", "\n", "device", "=", "cell_shape", ".", "device", ")", ",", "\n", "torch", ".", "arange", "(", "start", "=", "0", ",", "end", "=", "cell_map_shape", "[", "1", "]", "*", "cell_shape", "[", "1", "]", ",", "step", "=", "cell_shape", "[", "1", "]", ",", "\n", "device", "=", "cell_shape", ".", "device", ")", "]", ")", "\n", "return", "torch", ".", "stack", "(", "cell_top_left", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.cropToFrame": [[70, 83], ["torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.zeros_like", "torch.ones_like", "torch.ones_like"], "function", ["None"], ["", "def", "cropToFrame", "(", "bbox", ",", "image_shape", ")", ":", "\n", "    ", "\"\"\"Checks if bounding boxes are inside frame. If not crop to border\"\"\"", "\n", "array_width", "=", "torch", ".", "ones_like", "(", "bbox", "[", ":", ",", "1", "]", ")", "*", "image_shape", "[", "1", "]", "-", "1", "\n", "array_height", "=", "torch", ".", "ones_like", "(", "bbox", "[", ":", ",", "2", "]", ")", "*", "image_shape", "[", "0", "]", "-", "1", "\n", "\n", "bbox", "[", ":", ",", "1", ":", "3", "]", "=", "torch", ".", "max", "(", "bbox", "[", ":", ",", "1", ":", "3", "]", ",", "torch", ".", "zeros_like", "(", "bbox", "[", ":", ",", "1", ":", "3", "]", ")", ")", "\n", "bbox", "[", ":", ",", "1", "]", "=", "torch", ".", "min", "(", "bbox", "[", ":", ",", "1", "]", ",", "array_width", ")", "\n", "bbox", "[", ":", ",", "2", "]", "=", "torch", ".", "min", "(", "bbox", "[", ":", ",", "2", "]", ",", "array_height", ")", "\n", "\n", "bbox", "[", ":", ",", "3", "]", "=", "torch", ".", "min", "(", "bbox", "[", ":", ",", "3", "]", ",", "array_width", "-", "bbox", "[", ":", ",", "1", "]", ")", "\n", "bbox", "[", ":", ",", "4", "]", "=", "torch", ".", "min", "(", "bbox", "[", ":", ",", "4", "]", ",", "array_height", "-", "bbox", "[", ":", ",", "2", "]", ")", "\n", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.yolo_detection.nonMaxSuppression": [[85, 112], ["[].clone", "torchvision.ops.nms", "keep_bbox.append", "same_batch_mask.sum", "len", "torch.cat", "torch.zeros"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.utils.statistics_pascalvoc.BoundingBoxes.clone"], ["", "def", "nonMaxSuppression", "(", "detected_bbox", ",", "iou", "=", "0.6", ")", ":", "\n", "    ", "\"\"\"\n    Iterates over the bboxes to peform non maximum suppression within each batch.\n\n    :param detected_bbox[0, :]: [batch_idx, top_left_corner_u,  top_left_corner_v, width, height, predicted_class,\n                                 predicted class confidence, object_score])\n    :param iou: intersection over union, threshold for which the bbox are considered overlapping\n    \"\"\"", "\n", "i_sample", "=", "0", "\n", "keep_bbox", "=", "[", "]", "\n", "\n", "while", "i_sample", "<", "detected_bbox", ".", "shape", "[", "0", "]", ":", "\n", "        ", "same_batch_mask", "=", "detected_bbox", "[", ":", ",", "0", "]", "==", "detected_bbox", "[", "i_sample", ",", "0", "]", "\n", "nms_input", "=", "detected_bbox", "[", "same_batch_mask", "]", "[", ":", ",", "[", "1", ",", "2", ",", "3", ",", "4", ",", "7", "]", "]", ".", "clone", "(", ")", "\n", "nms_input", "[", ":", ",", "[", "2", ",", "3", "]", "]", "+=", "nms_input", "[", ":", ",", "[", "0", ",", "1", "]", "]", "\n", "\n", "# (u, v) or (x, y) should not matter", "\n", "keep_idx", "=", "torchvision", ".", "ops", ".", "nms", "(", "nms_input", "[", ":", ",", ":", "4", "]", ",", "nms_input", "[", ":", ",", "4", "]", ",", "iou", ")", "\n", "keep_bbox", ".", "append", "(", "detected_bbox", "[", "same_batch_mask", "]", "[", "keep_idx", "]", ")", "\n", "i_sample", "+=", "same_batch_mask", ".", "sum", "(", ")", "\n", "\n", "", "if", "len", "(", "keep_bbox", ")", "!=", "0", ":", "\n", "        ", "filtered_bbox", "=", "torch", ".", "cat", "(", "keep_bbox", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "filtered_bbox", "=", "torch", ".", "zeros", "(", "[", "0", ",", "8", "]", ")", "\n", "\n", "", "return", "filtered_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_object_det.FBSparseObjectDet.__init__": [[7, 34], ["torch.Module.__init__", "sparseconvnet.SparseVggNet().add().add().add", "facebook_sparse_object_det.FBSparseObjectDet.sparseModel.input_spatial_size", "sparseconvnet.InputLayer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "sparseconvnet.SparseToDense", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sparseconvnet.SparseVggNet().add().add", "sparseconvnet.BatchNormReLU", "sparseconvnet.SparseVggNet().add", "sparseconvnet.Convolution", "sparseconvnet.SparseVggNet"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", ",", "nr_box", "=", "2", ",", "nr_input_channels", "=", "2", ",", "small_out_map", "=", "True", ")", ":", "\n", "        ", "super", "(", "FBSparseObjectDet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nr_classes", "=", "nr_classes", "\n", "self", ".", "nr_box", "=", "nr_box", "\n", "\n", "sparse_out_channels", "=", "256", "\n", "self", ".", "sparseModel", "=", "scn", ".", "SparseVggNet", "(", "2", ",", "nInputPlanes", "=", "nr_input_channels", ",", "layers", "=", "[", "\n", "[", "'C'", ",", "16", "]", ",", "[", "'C'", ",", "16", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "32", "]", ",", "[", "'C'", ",", "32", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "64", "]", ",", "[", "'C'", ",", "64", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "128", "]", ",", "[", "'C'", ",", "128", "]", ",", "'MP'", ",", "\n", "[", "'C'", ",", "256", "]", ",", "[", "'C'", ",", "256", "]", "]", "\n", ")", ".", "add", "(", "scn", ".", "Convolution", "(", "2", ",", "256", ",", "sparse_out_channels", ",", "3", ",", "filter_stride", "=", "2", ",", "bias", "=", "False", ")", "\n", ")", ".", "add", "(", "scn", ".", "BatchNormReLU", "(", "sparse_out_channels", ")", "\n", ")", ".", "add", "(", "scn", ".", "SparseToDense", "(", "2", ",", "sparse_out_channels", ")", ")", "\n", "\n", "if", "small_out_map", ":", "\n", "            ", "self", ".", "cnn_spatial_output_size", "=", "[", "5", ",", "7", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "cnn_spatial_output_size", "=", "[", "6", ",", "8", "]", "\n", "\n", "", "spatial_size_product", "=", "self", ".", "cnn_spatial_output_size", "[", "0", "]", "*", "self", ".", "cnn_spatial_output_size", "[", "1", "]", "\n", "self", ".", "spatial_size", "=", "self", ".", "sparseModel", ".", "input_spatial_size", "(", "torch", ".", "LongTensor", "(", "self", ".", "cnn_spatial_output_size", ")", ")", "\n", "self", ".", "inputLayer", "=", "scn", ".", "InputLayer", "(", "dimension", "=", "2", ",", "spatial_size", "=", "self", ".", "spatial_size", ",", "mode", "=", "2", ")", "\n", "self", ".", "linear_input_features", "=", "spatial_size_product", "*", "256", "\n", "self", ".", "linear_1", "=", "nn", ".", "Linear", "(", "self", ".", "linear_input_features", ",", "1024", ")", "\n", "self", ".", "linear_2", "=", "nn", ".", "Linear", "(", "1024", ",", "spatial_size_product", "*", "(", "nr_classes", "+", "5", "*", "self", ".", "nr_box", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.facebook_sparse_object_det.FBSparseObjectDet.forward": [[35, 45], ["facebook_sparse_object_det.FBSparseObjectDet.inputLayer", "facebook_sparse_object_det.FBSparseObjectDet.sparseModel", "x.view.view.view", "facebook_sparse_object_det.FBSparseObjectDet.linear_1", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "facebook_sparse_object_det.FBSparseObjectDet.linear_2", "x.view.view.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "inputLayer", "(", "x", ")", "\n", "x", "=", "self", ".", "sparseModel", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "linear_input_features", ")", "\n", "x", "=", "self", ".", "linear_1", "(", "x", ")", "\n", "x", "=", "torch", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "linear_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "[", "-", "1", "]", "+", "self", ".", "cnn_spatial_output_size", "+", "[", "(", "self", ".", "nr_classes", "+", "5", "*", "self", ".", "nr_box", ")", "]", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.__init__": [[6, 33], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "dense_object_det.DenseObjectDet.conv_block", "dense_object_det.DenseObjectDet.conv_block", "dense_object_det.DenseObjectDet.conv_block", "dense_object_det.DenseObjectDet.conv_block", "dense_object_det.DenseObjectDet.conv_block", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block"], ["    ", "def", "__init__", "(", "self", ",", "nr_classes", ",", "in_c", "=", "2", ",", "nr_box", "=", "2", ",", "small_out_map", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nr_box", "=", "nr_box", "\n", "self", ".", "nr_classes", "=", "nr_classes", "\n", "\n", "self", ".", "kernel_size", "=", "3", "\n", "self", ".", "conv_layers", "=", "nn", ".", "Sequential", "(", "\n", "self", ".", "conv_block", "(", "in_c", "=", "in_c", ",", "out_c", "=", "16", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "16", ",", "out_c", "=", "32", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "32", ",", "out_c", "=", "64", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "64", ",", "out_c", "=", "128", ")", ",", "\n", "self", ".", "conv_block", "(", "in_c", "=", "128", ",", "out_c", "=", "256", ",", "max_pool", "=", "False", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", "=", "256", ",", "out_channels", "=", "512", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "512", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", ")", "\n", "\n", "if", "small_out_map", ":", "\n", "            ", "self", ".", "cnn_spatial_output_size", "=", "[", "5", ",", "7", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "cnn_spatial_output_size", "=", "[", "6", ",", "8", "]", "\n", "\n", "", "spatial_size_product", "=", "self", ".", "cnn_spatial_output_size", "[", "0", "]", "*", "self", ".", "cnn_spatial_output_size", "[", "1", "]", "\n", "\n", "self", ".", "linear_input_features", "=", "spatial_size_product", "*", "512", "\n", "self", ".", "linear_1", "=", "nn", ".", "Linear", "(", "self", ".", "linear_input_features", ",", "1024", ")", "\n", "self", ".", "linear_2", "=", "nn", ".", "Linear", "(", "1024", ",", "spatial_size_product", "*", "(", "nr_classes", "+", "5", "*", "self", ".", "nr_box", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.conv_block": [[34, 53], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU"], "methods", ["None"], ["", "def", "conv_block", "(", "self", ",", "in_c", ",", "out_c", ",", "max_pool", "=", "True", ")", ":", "\n", "        ", "if", "max_pool", ":", "\n", "            ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_c", ",", "out_c", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_c", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "out_c", ",", "out_c", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_c", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "self", ".", "kernel_size", ",", "stride", "=", "2", ")", "\n", ")", "\n", "", "else", ":", "\n", "            ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_c", ",", "out_c", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_c", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "out_c", ",", "out_c", ",", "kernel_size", "=", "self", ".", "kernel_size", ",", "padding", "=", "(", "1", ",", "1", ")", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_c", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.dense_object_det.DenseObjectDet.forward": [[55, 64], ["dense_object_det.DenseObjectDet.conv_layers", "x.view.view.view", "dense_object_det.DenseObjectDet.linear_1", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "dense_object_det.DenseObjectDet.linear_2", "x.view.view.view"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv_layers", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "-", "1", ",", "self", ".", "linear_input_features", ")", "\n", "x", "=", "self", ".", "linear_1", "(", "x", ")", "\n", "x", "=", "torch", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "linear_2", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "[", "-", "1", "]", "+", "self", ".", "cnn_spatial_output_size", "+", "[", "(", "self", ".", "nr_classes", "+", "5", "*", "self", ".", "nr_box", ")", "]", ")", "\n", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.async_sparse_py.setup.CMakeExtension.__init__": [[12, 15], ["setuptools.Extension.__init__", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__"], ["\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.async_sparse_py.setup.CMakeBuild.run": [[18, 32], ["subprocess.check_output", "platform.system", "distutils.version.LooseVersion", "setuptools.setup.CMakeBuild.build_extension", "RuntimeError", "re.search().group", "RuntimeError", "re.search", "subprocess.check_output.decode"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.async_sparse_py.setup.CMakeBuild.build_extension"], ["\n", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "import", "pybind11", "\n", "return", "pybind11", ".", "get_include", "(", "self", ".", "user", ")", "\n", "\n", "\n", "", "", "ext_modules", "=", "[", "\n", "Extension", "(", "\n", "'event_representations'", ",", "\n", "[", "'src/event_queue_tensor.cpp'", "]", ",", "\n", "include_dirs", "=", "[", "\n", "# Path to pybind11 headers", "\n", "get_pybind_include", "(", ")", ",", "\n", "get_pybind_include", "(", "user", "=", "True", ")", "\n", "]", ",", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.async_sparse_py.setup.CMakeBuild.build_extension": [[33, 51], ["os.path.abspath", "os.environ.copy", "subprocess.check_call", "subprocess.check_call", "os.path.dirname", "os.environ.copy.get", "setuptools.setup.CMakeBuild.distribution.get_version", "os.path.exists", "os.makedirs", "setuptools.setup.CMakeBuild.get_ext_fullpath"], "methods", ["None"], ["language", "=", "'c++'", "\n", ")", ",", "\n", "]", "\n", "\n", "\n", "# As of Python 3.6, CCompiler has a `has_flag` method.", "\n", "# cf http://bugs.python.org/issue26689", "\n", "def", "has_flag", "(", "compiler", ",", "flagname", ")", ":", "\n", "    ", "\"\"\"Return a boolean indicating whether a flag name is supported on\n    the specified compiler.\n    \"\"\"", "\n", "import", "tempfile", "\n", "with", "tempfile", ".", "NamedTemporaryFile", "(", "'w'", ",", "suffix", "=", "'.cpp'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'int main (int argc, char **argv) { return 0; }'", ")", "\n", "try", ":", "\n", "            ", "compiler", ".", "compile", "(", "[", "f", ".", "name", "]", ",", "extra_postargs", "=", "[", "flagname", "]", ")", "\n", "", "except", "setuptools", ".", "distutils", ".", "errors", ".", "CompileError", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.__init__": [[25, 82], ["dataloader.dataset.getDataloader", "torch.device", "NotImplementedError", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.getDataloader"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "settings", ",", "save_dir", "=", "'log/N_Caltech_FLOPs'", ",", ")", ":", "\n", "        ", "self", ".", "settings", "=", "settings", "\n", "self", ".", "save_dir", "=", "save_dir", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "multi_processing", "=", "args", ".", "use_multiprocessing", "\n", "self", ".", "compute_active_sites", "=", "args", ".", "compute_active_sites", "\n", "\n", "representation", "=", "args", ".", "representation", "or", "settings", ".", "event_representation", "\n", "if", "representation", "==", "'histogram'", ":", "\n", "            ", "self", ".", "nr_input_channels", "=", "2", "\n", "", "elif", "representation", "==", "'event_queue'", ":", "\n", "            ", "self", ".", "nr_input_channels", "=", "30", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Representation is not implemented'", ")", "\n", "\n", "", "if", "settings", ".", "dataset_name", "==", "'NCaltech101'", ":", "\n", "            ", "self", ".", "layer_list", "=", "[", "[", "'C'", ",", "self", ".", "nr_input_channels", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "256", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "256", ",", "512", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "512", ",", "256", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "[", "'ClassicFC'", ",", "256", "*", "3", "*", "2", ",", "101", "]", "]", "\n", "self", ".", "nr_classes", "=", "101", "\n", "", "elif", "settings", ".", "dataset_name", "==", "'NCars'", ":", "\n", "            ", "self", ".", "layer_list", "=", "[", "[", "'C'", ",", "self", ".", "nr_input_channels", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "256", ",", "128", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "[", "'ClassicFC'", ",", "128", "*", "3", "*", "2", ",", "101", "]", "]", "\n", "self", ".", "nr_classes", "=", "2", "\n", "", "elif", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", "or", "settings", ".", "dataset_name", "==", "'Prophesee'", ":", "\n", "            ", "if", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", ":", "\n", "                ", "out_put_map", "=", "5", "*", "7", "\n", "self", ".", "nr_classes", "=", "101", "\n", "", "else", ":", "\n", "                ", "out_put_map", "=", "6", "*", "8", "\n", "self", ".", "nr_classes", "=", "2", "\n", "", "self", ".", "layer_list", "=", "[", "[", "'C'", ",", "self", ".", "nr_input_channels", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "16", ",", "16", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "16", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "32", ",", "32", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "32", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "64", ",", "64", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "64", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "128", ",", "128", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'MP'", "]", ",", "\n", "[", "'C'", ",", "128", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "[", "'C'", ",", "256", ",", "256", "]", ",", "[", "'BNRelu'", "]", ",", "\n", "[", "'ClassicC'", ",", "256", ",", "256", ",", "3", ",", "2", "]", ",", "[", "'ClassicBNRelu'", "]", ",", "\n", "[", "'ClassicFC'", ",", "256", "*", "out_put_map", ",", "1024", "]", ",", "[", "'ClassicFC'", ",", "1024", ",", "self", ".", "nr_classes", "]", "]", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'The specified dataset is not supported'", ")", "\n", "\n", "", "self", ".", "train_loader", "=", "None", "\n", "self", ".", "nr_sampling_runs", "=", "None", "\n", "self", ".", "nr_events_timestep", "=", "None", "\n", "self", ".", "sliding_window_size", "=", "None", "\n", "self", ".", "dataloader", "=", "getDataloader", "(", "self", ".", "settings", ".", "dataset_name", ")", "\n", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.evaluateFLOP": [[83, 130], ["len", "numpy.zeros", "flops_overall.mean.mean.sum().std", "flops_overall.mean.mean.mean", "numpy.array", "tqdm.tqdm", "multiprocessing.Pool", "multiprocessing.Pool.map", "numpy.asarray().transpose", "os.path.isdir", "os.makedirs", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "len", "range", "sliding_window_flops.FlopEvaluation.evaluateSamplingRun", "print", "range", "flops_overall.mean.mean.sum", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "numpy.asarray", "os.cpu_count", "asyn_flops.sum", "ref_flops.sum", "sparse_flops.sum", "batch_flops.sum"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.evaluateSamplingRun"], ["", "def", "evaluateFLOP", "(", "self", ")", ":", "\n", "        ", "\"\"\"Evaluate asynchronous spare VGG\"\"\"", "\n", "# nr_events_timestep = [i*1000 for i in range(1, 26)]", "\n", "self", ".", "nr_events_timestep", "=", "[", "25000", ",", "25000", "+", "self", ".", "args", ".", "num_events", "]", "\n", "self", ".", "sliding_window_size", "=", "25000", "\n", "self", ".", "nr_sampling_runs", "=", "self", ".", "args", ".", "num_samples", "\n", "\n", "nr_timesteps", "=", "len", "(", "self", ".", "nr_events_timestep", ")", "\n", "flops_overall", "=", "np", ".", "zeros", "(", "[", "self", ".", "nr_sampling_runs", ",", "nr_timesteps", ",", "5", ",", "len", "(", "self", ".", "layer_list", ")", "]", ")", "\n", "flops_overall", "[", ":", ",", ":", ",", "4", ",", ":", "]", "=", "np", ".", "array", "(", "self", ".", "nr_events_timestep", ")", "[", "np", ".", "newaxis", ",", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "if", "not", "self", ".", "multi_processing", ":", "\n", "            ", "for", "i_run", "in", "tqdm", ".", "tqdm", "(", "range", "(", "self", ".", "nr_sampling_runs", ")", ")", ":", "\n", "                ", "out", "=", "self", ".", "evaluateSamplingRun", "(", "i_run", ")", "\n", "asyn_flops", ",", "ref_flops", ",", "sparse_flops", ",", "batch_flops", "=", "out", "\n", "flops_overall", "[", "i_run", ",", ":", ",", "0", ",", ":", "]", "=", "asyn_flops", "\n", "flops_overall", "[", "i_run", ",", ":", ",", "1", ",", ":", "]", "=", "ref_flops", "\n", "flops_overall", "[", "i_run", ",", ":", ",", "2", ",", ":", "]", "=", "sparse_flops", "\n", "flops_overall", "[", "i_run", ",", ":", ",", "3", ",", ":", "]", "=", "batch_flops", "\n", "\n", "string", "=", "\"FLOPS: \\n\\tasyn sparse: %s  \\n\\tasyn dense: %s    \\n\\tbatch sparse: %s    \\n\\tdense batch: %s\"", "\n", "print", "(", "string", "%", "(", "\n", "asyn_flops", ".", "sum", "(", "-", "1", ")", "[", "-", "1", "]", ",", "\n", "ref_flops", ".", "sum", "(", "-", "1", ")", "[", "-", "1", "]", ",", "\n", "sparse_flops", ".", "sum", "(", "-", "1", ")", "[", "-", "1", "]", ",", "\n", "batch_flops", ".", "sum", "(", "-", "1", ")", "[", "-", "1", "]", ",", "\n", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "import", "multiprocessing", "\n", "pool", "=", "multiprocessing", ".", "Pool", "(", "processes", "=", "(", "os", ".", "cpu_count", "(", ")", "-", "2", ")", ")", "\n", "# pool = multiprocessing.Pool(processes=2)", "\n", "result", "=", "pool", ".", "map", "(", "self", ".", "evaluateSamplingRun", ",", "range", "(", "self", ".", "nr_sampling_runs", ")", ")", "\n", "result", "=", "np", ".", "asarray", "(", "result", ")", ".", "transpose", "(", "[", "0", ",", "2", ",", "1", ",", "3", "]", ")", "\n", "flops_overall", "[", ":", ",", ":", ",", ":", "4", ",", ":", "]", "=", "result", "\n", "\n", "", "flops_overall_std", "=", "flops_overall", ".", "sum", "(", "-", "1", ")", ".", "std", "(", "0", ")", "\n", "flops_overall", "=", "flops_overall", ".", "mean", "(", "0", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "save_dir", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "self", ".", "save_dir", ")", "\n", "", "if", "self", ".", "compute_active_sites", ":", "\n", "            ", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'ActiveSites'", ")", ",", "flops_overall", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'ActiveSites_std'", ")", ",", "flops_overall_std", ")", "\n", "", "else", ":", "\n", "\n", "            ", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'NCaltech_FLOPs'", ")", ",", "flops_overall", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'NCaltech_FLOPs_std'", ")", ",", "flops_overall_std", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.evaluateSamplingRun": [[131, 232], ["models.asyn_sparse_vgg.EvalAsynSparseVGGModel", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel.convertWeightsDouble", "evaluation.reference_vgg_model.ReferenceVGGModel", "len", "sliding_window_flops.FlopEvaluation.dataloader", "int", "print", "sliding_window_flops.FlopEvaluation.__getitem__", "random.seed", "random.randrange", "sliding_window_flops.FlopEvaluation.createInputs", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "max", "tqdm.tqdm", "torch.no_grad", "enumerate", "tqdm.tqdm.close", "numpy.tile", "numpy.concatenate", "numpy.save", "sliding_window_flops.FlopEvaluation.__len__", "len", "len", "len", "len", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel.convertWeightsDouble", "[].to", "[].to", "len", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "sliding_window_flops.FlopEvaluation.createSparseInput", "evaluation.reference_vgg_model.ReferenceVGGModel.forward", "os.path.isdir", "os.makedirs", "os.path.join", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel.forward", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel.forward", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel.forward", "evaluation.compute_flops.computeFLOPS", "evaluation.compute_flops.computeFLOPS", "models.asyn_sparse_vgg.EvalAsynSparseVGGModel.forward", "evaluation.compute_flops.computeFLOPS", "evaluation.compute_flops.computeFLOPS", "tqdm.tqdm.update", "numpy.array", "len", "os.cpu_count", "os.cpu_count", "str", "os.cpu_count"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.convertWeightsDouble", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.dataset.NCars.__getitem__", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.createInputs", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.dataloader.loader.Loader.__len__", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.models.asyn_sparse_vgg.EvalAsynSparseVGGModel.convertWeightsDouble", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.createSparseInput", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.compute_flops.computeFLOPS", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.compute_flops.computeFLOPS", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.compute_flops.computeFLOPS", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.compute_flops.computeFLOPS"], ["", "", "def", "evaluateSamplingRun", "(", "self", ",", "i_run", ")", ":", "\n", "        ", "if", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101'", ":", "\n", "            ", "spatial_dimensions", "=", "[", "191", ",", "255", "]", "\n", "", "elif", "self", ".", "settings", ".", "dataset_name", "==", "'NCars'", ":", "\n", "            ", "spatial_dimensions", "=", "[", "95", ",", "127", "]", "\n", "", "elif", "self", ".", "settings", ".", "dataset_name", "==", "'NCaltech101_ObjectDetection'", ":", "\n", "            ", "spatial_dimensions", "=", "[", "191", ",", "255", "]", "\n", "", "elif", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ":", "\n", "            ", "spatial_dimensions", "=", "[", "223", ",", "287", "]", "\n", "\n", "# ---- Create Models ----", "\n", "", "asyn_model", "=", "EvalAsynSparseVGGModel", "(", "nr_classes", "=", "self", ".", "nr_classes", ",", "layer_list", "=", "self", ".", "layer_list", ",", "device", "=", "self", ".", "device", ",", "\n", "input_channels", "=", "self", ".", "nr_input_channels", ")", "\n", "asyn_model", ".", "convertWeightsDouble", "(", ")", "\n", "ref_model", "=", "ReferenceVGGModel", "(", "self", ".", "layer_list", ",", "device", "=", "self", ".", "device", ")", "\n", "\n", "# ---- Create Input -----", "\n", "nr_timestep", "=", "len", "(", "self", ".", "nr_events_timestep", ")", "\n", "train_dataset", "=", "self", ".", "dataloader", "(", "self", ".", "settings", ".", "dataset_path", ",", "'all'", ",", "self", ".", "settings", ".", "height", ",", "\n", "self", ".", "settings", ".", "width", ",", "augmentation", "=", "False", ",", "mode", "=", "'validation'", ",", "\n", "nr_events_window", "=", "-", "1", ",", "shuffle", "=", "True", ")", "\n", "data_idx", "=", "int", "(", "i_run", "%", "train_dataset", ".", "__len__", "(", ")", ")", "\n", "print", "(", "\"using data index: %s\"", "%", "data_idx", ")", "\n", "events", ",", "labels", ",", "histogram", "=", "train_dataset", ".", "__getitem__", "(", "data_idx", ")", "\n", "nr_events", "=", "events", ".", "shape", "[", "0", "]", "\n", "random", ".", "seed", "(", "7", ")", "\n", "start_point", "=", "random", ".", "randrange", "(", "0", ",", "max", "(", "1", ",", "nr_events", "-", "self", ".", "nr_events_timestep", "[", "-", "1", "]", ")", ")", "\n", "events", "=", "events", "[", "start_point", ":", ",", ":", "]", "\n", "input_timesteps", "=", "self", ".", "createInputs", "(", "events", ",", "self", ".", "nr_events_timestep", ",", "spatial_dimensions", ",", "\n", "self", ".", "sliding_window_size", ",", "asyn_model", ".", "generateAsynInput", ")", "\n", "\n", "asyn_flops", "=", "np", ".", "zeros", "(", "[", "nr_timestep", ",", "len", "(", "self", ".", "layer_list", ")", "]", ")", "\n", "ref_flops", "=", "np", ".", "zeros", "(", "[", "nr_timestep", ",", "len", "(", "self", ".", "layer_list", ")", "]", ")", "\n", "sparse_flops", "=", "np", ".", "zeros", "(", "[", "nr_timestep", ",", "len", "(", "self", ".", "layer_list", ")", "]", ")", "\n", "batch_flops", "=", "np", ".", "zeros", "(", "[", "nr_timestep", ",", "len", "(", "self", ".", "layer_list", ")", "]", ")", "\n", "\n", "if", "self", ".", "multi_processing", "and", "i_run", "%", "(", "os", ".", "cpu_count", "(", ")", "+", "2", ")", "==", "0", ":", "\n", "            ", "pbar", "=", "tqdm", ".", "tqdm", "(", "total", "=", "nr_timestep", ",", "unit", "=", "'Batch Event'", ",", "unit_scale", "=", "True", ")", "\n", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "i_sequence", ",", "nr_events", "in", "enumerate", "(", "self", ".", "nr_events_timestep", ")", ":", "\n", "# Batch sparse model needs to be reinitialised", "\n", "                ", "sparse_model", "=", "EvalAsynSparseVGGModel", "(", "nr_classes", "=", "self", ".", "nr_classes", ",", "layer_list", "=", "self", ".", "layer_list", ",", "\n", "device", "=", "self", ".", "device", ",", "input_channels", "=", "self", ".", "nr_input_channels", ")", "\n", "sparse_model", ".", "convertWeightsDouble", "(", ")", "\n", "\n", "x_asyn", "=", "[", "None", "]", "*", "5", "\n", "x_asyn", "[", "0", "]", "=", "input_timesteps", "[", "1", "]", "[", "i_sequence", "]", "[", ":", ",", ":", "2", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "x_asyn", "[", "1", "]", "=", "input_timesteps", "[", "0", "]", "[", "i_sequence", ",", ":", ",", ":", ",", ":", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "nr_layers", "=", "len", "(", "self", ".", "layer_list", ")", "\n", "asyn_active_sites", "=", "np", ".", "zeros", "(", "[", "nr_layers", "]", ")", "\n", "asyn_nr_sites", "=", "np", ".", "zeros", "(", "[", "nr_layers", "]", ")", "\n", "\n", "sparse_active_sites", "=", "np", ".", "zeros", "(", "[", "nr_layers", "]", ")", "\n", "sparse_nr_sites", "=", "np", ".", "zeros", "(", "[", "nr_layers", "]", ")", "\n", "ref_active_sites", "=", "np", ".", "zeros", "(", "[", "nr_layers", "]", ")", "\n", "x_sparse", "=", "self", ".", "createSparseInput", "(", "input_timesteps", "[", "0", "]", "[", "i_sequence", ",", ":", ",", ":", ",", ":", "]", ")", "\n", "ref_model", ".", "forward", "(", "(", "input_timesteps", "[", "2", "]", "[", "i_sequence", ",", ":", ",", ":", ",", ":", "]", "**", "2", ")", ".", "to", "(", "self", ".", "device", ")", ",", "ref_active_sites", ")", "\n", "\n", "if", "self", ".", "compute_active_sites", ":", "\n", "                    ", "_", "=", "asyn_model", ".", "forward", "(", "x_asyn", ",", "asyn_active_sites", ",", "asyn_nr_sites", ",", "flop_calculation", "=", "False", ")", "\n", "asyn_flops", "[", "i_sequence", "]", "=", "asyn_active_sites", "\n", "batch_flops", "[", "i_sequence", "]", "=", "asyn_nr_sites", "\n", "_", "=", "sparse_model", ".", "forward", "(", "x_sparse", ",", "sparse_active_sites", ",", "sparse_nr_sites", ",", "flop_calculation", "=", "False", ")", "\n", "ref_flops", "[", "i_sequence", "]", "=", "ref_active_sites", "\n", "sparse_flops", "[", "i_sequence", "]", "=", "sparse_active_sites", "\n", "", "else", ":", "\n", "                    ", "_", "=", "asyn_model", ".", "forward", "(", "x_asyn", ",", "asyn_active_sites", ",", "asyn_nr_sites", ",", "flop_calculation", "=", "True", ")", "\n", "\n", "asyn_flops", "[", "i_sequence", "]", "=", "computeFLOPS", "(", "asyn_active_sites", ",", "self", ".", "layer_list", ",", "sparse_model", "=", "True", ",", "\n", "layerwise", "=", "True", ")", "\n", "batch_flops", "[", "i_sequence", "]", "=", "computeFLOPS", "(", "asyn_nr_sites", ",", "self", ".", "layer_list", ",", "sparse_model", "=", "False", ",", "\n", "layerwise", "=", "True", ")", "\n", "\n", "_", "=", "sparse_model", ".", "forward", "(", "x_sparse", ",", "sparse_active_sites", ",", "sparse_nr_sites", ",", "flop_calculation", "=", "True", ")", "\n", "ref_flops", "[", "i_sequence", "]", "=", "computeFLOPS", "(", "ref_active_sites", ",", "self", ".", "layer_list", ",", "sparse_model", "=", "False", ",", "\n", "layerwise", "=", "True", ")", "\n", "sparse_flops", "[", "i_sequence", "]", "=", "computeFLOPS", "(", "sparse_active_sites", ",", "self", ".", "layer_list", ",", "sparse_model", "=", "True", ",", "\n", "layerwise", "=", "True", ")", "\n", "\n", "", "if", "self", ".", "multi_processing", "and", "i_run", "%", "(", "os", ".", "cpu_count", "(", ")", "+", "2", ")", "==", "0", ":", "\n", "                    ", "pbar", ".", "update", "(", "1", ")", "\n", "\n", "# print('--------Sequence %s----------' % i_sequence)", "\n", "", "", "", "if", "self", ".", "multi_processing", "and", "i_run", "%", "(", "os", ".", "cpu_count", "(", ")", "+", "2", ")", "==", "0", ":", "\n", "            ", "pbar", ".", "close", "(", ")", "\n", "\n", "", "if", "self", ".", "multi_processing", ":", "\n", "            ", "if", "not", "os", ".", "path", ".", "isdir", "(", "self", ".", "save_dir", ")", ":", "\n", "                ", "os", ".", "makedirs", "(", "self", ".", "save_dir", ")", "\n", "", "timestep_array", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "self", ".", "nr_events_timestep", ")", "[", ":", ",", "np", ".", "newaxis", ",", "np", ".", "newaxis", "]", ",", "\n", "[", "1", ",", "1", ",", "len", "(", "self", ".", "layer_list", ")", "]", ")", "\n", "container", "=", "np", ".", "concatenate", "(", "[", "asyn_flops", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "ref_flops", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "sparse_flops", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "batch_flops", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", ",", "\n", "timestep_array", "]", ",", "axis", "=", "1", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'NCaltech_FLOPs_run_'", "+", "str", "(", "i_run", ")", ")", ",", "container", ")", "\n", "\n", "", "return", "asyn_flops", ",", "ref_flops", ",", "sparse_flops", ",", "batch_flops", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.createInputs": [[233, 292], ["changing_timesteps.sort", "torch.tensor", "torch.zeros", "range", "torch.zeros", "torch.zeros", "range", "fn_generateAsynInput", "numpy.random.seed", "numpy.random.permutation", "torch.tensor().float", "len", "changing_timesteps.index", "changing_timesteps.index", "change_histogram[].sum", "training.trainer.AbstractTrainer.denseToSparse", "input_update_locations.append", "len", "ValueError", "torch.tensor", "events[].astype", "numpy.floor().astype", "torch.cat", "torch.from_numpy", "torch.from_numpy", "torch.tensor", "len", "len", "new_histogram[].unsqueeze", "numpy.floor", "torch.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse"], ["", "def", "createInputs", "(", "self", ",", "events", ",", "nr_events_timestep", ",", "spatial_dimensions", ",", "sliding_window_size", ",", "fn_generateAsynInput", ")", ":", "\n", "        ", "\"\"\"Creates for each timestep the input according to sliding window histogram\"\"\"", "\n", "start_windows", "=", "[", "nr_events", "-", "sliding_window_size", "for", "nr_events", "in", "nr_events_timestep", "]", "\n", "changing_timesteps", "=", "start_windows", "+", "nr_events_timestep", "\n", "changing_timesteps", ".", "sort", "(", ")", "\n", "\n", "tensor_spatial_dimensions", "=", "torch", ".", "tensor", "(", "spatial_dimensions", ")", "\n", "change_histogram", "=", "torch", ".", "zeros", "(", "[", "len", "(", "changing_timesteps", ")", "-", "1", "]", "+", "spatial_dimensions", "+", "[", "self", ".", "nr_input_channels", "]", ")", "\n", "\n", "for", "i_change", "in", "range", "(", "len", "(", "changing_timesteps", ")", "-", "1", ")", ":", "\n", "            ", "nr_changing_events", "=", "changing_timesteps", "[", "i_change", "+", "1", "]", "-", "changing_timesteps", "[", "i_change", "]", "\n", "batch_events", "=", "events", "[", "changing_timesteps", "[", "i_change", "]", ":", "changing_timesteps", "[", "i_change", "+", "1", "]", "]", "\n", "update_locations", ",", "new_histogram", "=", "fn_generateAsynInput", "(", "batch_events", ",", "tensor_spatial_dimensions", ",", "\n", "original_shape", "=", "[", "self", ".", "settings", ".", "height", ",", "\n", "self", ".", "settings", ".", "width", "]", ")", "\n", "# As input image dimension is upsampled, the number of new events can be increased as well.", "\n", "np", ".", "random", ".", "seed", "(", "7", ")", "\n", "random_permutation", "=", "np", ".", "random", ".", "permutation", "(", "update_locations", ".", "shape", "[", "0", "]", ")", "\n", "idx_discard", "=", "random_permutation", "[", ":", "-", "nr_changing_events", "]", "\n", "new_histogram", "[", "update_locations", "[", "idx_discard", ",", "0", "]", ",", "\n", "update_locations", "[", "idx_discard", ",", "1", "]", ",", ":", "]", "=", "torch", ".", "tensor", "(", "[", "0", ",", "0", "]", ")", ".", "float", "(", ")", "\n", "# update_locations = update_locations[random_permutation[-nr_changing_events:], :]", "\n", "\n", "change_histogram", "[", "i_change", ",", ":", ",", ":", ",", ":", "2", "]", "=", "new_histogram", "\n", "\n", "", "new_histogram", "=", "torch", ".", "zeros", "(", "[", "len", "(", "nr_events_timestep", ")", "]", "+", "spatial_dimensions", "+", "[", "self", ".", "nr_input_channels", "]", ")", "\n", "input_histogram", "=", "torch", ".", "zeros", "(", "[", "len", "(", "nr_events_timestep", ")", "]", "+", "spatial_dimensions", "+", "[", "self", ".", "nr_input_channels", "]", ")", "\n", "input_update_locations", "=", "[", "]", "\n", "\n", "for", "i_timestep", "in", "range", "(", "len", "(", "nr_events_timestep", ")", ")", ":", "\n", "            ", "if", "nr_events_timestep", "[", "i_timestep", "]", "-", "start_windows", "[", "i_timestep", "]", "<", "0", ":", "\n", "                ", "raise", "ValueError", "(", "'Sliding window is not full. Change nr_events_timestep'", ")", "\n", "", "start_idx_changing", "=", "changing_timesteps", ".", "index", "(", "start_windows", "[", "i_timestep", "]", ")", "\n", "end_idx_changing", "=", "changing_timesteps", ".", "index", "(", "nr_events_timestep", "[", "i_timestep", "]", ")", "\n", "\n", "input_histogram", "[", "i_timestep", "]", "=", "change_histogram", "[", "start_idx_changing", ":", "end_idx_changing", ",", ":", ",", ":", ",", ":", "]", ".", "sum", "(", "0", ")", "\n", "# if i_timestep=0, the input_histogram[i_timestep - 1] = input_histogram[-1], which is zero", "\n", "new_histogram", "[", "i_timestep", "]", "=", "input_histogram", "[", "i_timestep", "]", "-", "input_histogram", "[", "i_timestep", "-", "1", "]", "\n", "\n", "update_locations", ",", "_", "=", "AbstractTrainer", ".", "denseToSparse", "(", "torch", ".", "tensor", "(", "new_histogram", "[", "i_timestep", "]", ".", "unsqueeze", "(", "0", ")", "**", "2", ",", "\n", "requires_grad", "=", "False", ")", ")", "\n", "\n", "# Catch cases, where the input is downsampled and no update locations are found", "\n", "if", "update_locations", ".", "shape", "[", "0", "]", "<=", "1", "and", "self", ".", "settings", ".", "dataset_name", "==", "'Prophesee'", ":", "\n", "# Use final event as location", "\n", "                ", "nr_events_insert", "=", "2", "-", "update_locations", ".", "shape", "[", "0", "]", "\n", "end_event_idx", "=", "nr_events_timestep", "[", "i_timestep", "]", "+", "2", "\n", "add_events", "=", "events", "[", "end_event_idx", ":", "(", "end_event_idx", "+", "nr_events_insert", ")", "]", ".", "astype", "(", "np", ".", "float", ")", "\n", "add_events", "[", ":", ",", "0", "]", "*=", "spatial_dimensions", "[", "1", "]", "/", "self", ".", "settings", ".", "width", "\n", "add_events", "[", ":", ",", "1", "]", "*=", "spatial_dimensions", "[", "0", "]", "/", "self", ".", "settings", ".", "height", "\n", "add_events", "=", "np", ".", "floor", "(", "add_events", ")", ".", "astype", "(", "np", ".", "int", ")", "\n", "update_locations", "=", "torch", ".", "cat", "(", "[", "update_locations", ",", "torch", ".", "zeros", "(", "[", "nr_events_insert", ",", "3", "]", ",", "dtype", "=", "torch", ".", "long", ")", "]", ",", "\n", "dim", "=", "0", ")", "\n", "update_locations", "[", "-", "nr_events_insert", ":", ",", "0", "]", "=", "torch", ".", "from_numpy", "(", "add_events", "[", ":", ",", "1", "]", ")", "\n", "update_locations", "[", "-", "nr_events_insert", ":", ",", "1", "]", "=", "torch", ".", "from_numpy", "(", "add_events", "[", ":", ",", "0", "]", ")", "\n", "\n", "", "input_update_locations", ".", "append", "(", "update_locations", ")", "\n", "\n", "", "return", "input_histogram", ",", "input_update_locations", ",", "new_histogram", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.createSparseInput": [[293, 300], ["training.trainer.AbstractTrainer.denseToSparse", "update_locations[].to", "input_histogram.to", "input_histogram.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.training.trainer.AbstractTrainer.denseToSparse"], ["", "def", "createSparseInput", "(", "self", ",", "input_histogram", ")", ":", "\n", "        ", "update_locations", ",", "features", "=", "AbstractTrainer", ".", "denseToSparse", "(", "input_histogram", ".", "unsqueeze", "(", "0", ")", ")", "\n", "x_sparse", "=", "[", "None", "]", "*", "5", "\n", "x_sparse", "[", "0", "]", "=", "update_locations", "[", ":", ",", ":", "2", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "x_sparse", "[", "1", "]", "=", "input_histogram", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "return", "x_sparse", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.printLastStepFLOPs": [[301, 331], ["print", "enumerate", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "flops_overall.sum.sum.sum", "print", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "string.format"], "methods", ["None"], ["", "def", "printLastStepFLOPs", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "compute_active_sites", ":", "\n", "            ", "flops_overall", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'ActiveSites.npy'", ")", ")", "\n", "flops_overall_std", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'ActiveSites_std.npy'", ")", ")", "\n", "", "else", ":", "\n", "            ", "flops_overall", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'NCaltech_FLOPs.npy'", ")", ")", "\n", "flops_overall_std", "=", "np", ".", "load", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'NCaltech_FLOPs_std.npy'", ")", ")", "\n", "\n", "", "nr_layers", "=", "flops_overall", ".", "shape", "[", "-", "1", "]", "\n", "if", "flops_overall", ".", "ndim", "==", "3", ":", "\n", "            ", "flops_overall", "=", "flops_overall", ".", "sum", "(", "-", "1", ")", "\n", "", "flops_overall", "[", ":", ",", "-", "1", "]", "/=", "nr_layers", "\n", "modes", "=", "[", "'Asyn Sparse'", ",", "'Asyn Conventional'", ",", "'Batch Sparse'", ",", "'Batch Conventional'", "]", "\n", "\n", "string", "=", "'#Total Length Window          :   {:.0f}\\n'", "'#Events for Update            :   {:.0f}\\n'", "'===================================='", ".", "format", "(", "flops_overall", "[", "0", ",", "-", "1", "]", ",", "\n", "flops_overall", "[", "1", ",", "-", "1", "]", "-", "flops_overall", "[", "0", ",", "-", "1", "]", ")", "\n", "print", "(", "string", ")", "\n", "\n", "if", "self", ".", "compute_active_sites", ":", "\n", "            ", "string", "=", "'Mode:  {}                               \\n'", "'#FLOPs for Update :   {:.0f} +- {:.0f}  \\n'", "'====================================\\n'", "\n", "", "else", ":", "\n", "            ", "string", "=", "'Mode:  {}                               \\n'", "'#Active Sites      :   {:.0f} +- {:.0f}  \\n'", "'====================================\\n'", "\n", "", "for", "i", ",", "mode", "in", "enumerate", "(", "modes", ")", ":", "\n", "            ", "print", "(", "string", ".", "format", "(", "mode", ",", "flops_overall", "[", "1", ",", "i", "]", ",", "flops_overall_std", "[", "1", ",", "i", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.main": [[333, 352], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "config.settings.Settings", "sliding_window_flops.FlopEvaluation", "sliding_window_flops.FlopEvaluation.evaluateFLOP", "sliding_window_flops.FlopEvaluation.printLastStepFLOPs"], "function", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.evaluateFLOP", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.sliding_window_flops.FlopEvaluation.printLastStepFLOPs"], ["", "", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Evaluate network.'", ")", "\n", "parser", ".", "add_argument", "(", "'--settings_file'", ",", "help", "=", "'Path to settings yaml'", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'--save_dir'", ",", "help", "=", "'Path to save location'", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "'--num_events'", ",", "default", "=", "1", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--num_samples'", ",", "default", "=", "500", ",", "type", "=", "int", ")", "\n", "parser", ".", "add_argument", "(", "'--representation'", ",", "default", "=", "\"\"", ")", "\n", "parser", ".", "add_argument", "(", "'--use_multiprocessing'", ",", "help", "=", "'If multiprocessing should be used'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--compute_active_sites'", ",", "help", "=", "'If active sites should be calculated'", ",", "action", "=", "'store_true'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "settings_filepath", "=", "args", ".", "settings_file", "\n", "save_dir", "=", "args", ".", "save_dir", "\n", "\n", "settings", "=", "Settings", "(", "settings_filepath", ",", "generate_log", "=", "False", ")", "\n", "\n", "evaluator", "=", "FlopEvaluation", "(", "args", ",", "settings", ",", "save_dir", "=", "save_dir", ")", "\n", "evaluator", ".", "evaluateFLOP", "(", ")", "\n", "evaluator", ".", "printLastStepFLOPs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.__init__": [[7, 14], ["torch.device", "reference_vgg_model.ReferenceVGGModel.createReferenceVGG", "reference_vgg_model.ReferenceVGGModel.setIdentityWeights"], "methods", ["home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.createReferenceVGG", "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.setIdentityWeights"], ["    ", "def", "__init__", "(", "self", ",", "layer_list", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "self", ".", "device", "=", "device", "\n", "self", ".", "layers", "=", "[", "]", "\n", "self", ".", "layer_list", "=", "layer_list", "\n", "\n", "self", ".", "createReferenceVGG", "(", ")", "\n", "self", ".", "setIdentityWeights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.forward": [[15, 42], ["x_inter.permute().unsqueeze.permute().unsqueeze.permute().unsqueeze", "enumerate", "x_inter.permute().unsqueeze.permute().unsqueeze.permute", "numpy.uint8", "PIL.Image.fromarray", "numpy.asarray", "numpy.asarray.nonzero", "numpy.array", "[].cpu().numpy", "PIL.Image.fromarray.resize", "x_inter.permute().unsqueeze.permute().unsqueeze.view", "numpy.array", "x_inter.permute().unsqueeze.permute().unsqueeze.sum", "[].cpu", "x_inter.permute().unsqueeze.permute().unsqueeze.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x_inter", ",", "active_sum", "=", "None", ",", "active_sites_vis", "=", "None", ")", ":", "\n", "        ", "\"\"\"Apply asynchronous layers\"\"\"", "\n", "x_inter", "=", "x_inter", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "for", "j", ",", "layer", "in", "enumerate", "(", "self", ".", "layers", ")", ":", "\n", "# print('Layer Name: %s' % self.layer_list[j][0])", "\n", "# if active_sum is not None and self.layer_list[j][0][:7] != 'Classic':", "\n", "            ", "if", "active_sum", "is", "not", "None", ":", "\n", "                ", "active_sum", "[", "j", "]", "=", "(", "(", "x_inter", ".", "sum", "(", "1", ")", ")", ">", "0", ")", ".", "sum", "(", ")", "\n", "\n", "", "if", "active_sites_vis", "is", "not", "None", "and", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "[", ":", "7", "]", "!=", "'Classic'", ":", "\n", "                ", "o_height", ",", "o_width", "=", "active_sites_vis", ".", "shape", "[", "2", ":", "4", "]", "\n", "\n", "np_img", "=", "(", "(", "x_inter", ".", "sum", "(", "1", ")", ">", "0", ")", ".", "float", "(", ")", "[", "0", ",", ":", ",", ":", ",", "None", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", "[", "None", ",", "None", ",", ":", "]", ")", "\n", "np_img", "=", "np", ".", "uint8", "(", "np_img", ")", "\n", "img", "=", "Image", ".", "fromarray", "(", "np_img", ")", "\n", "np_img", "=", "np", ".", "asarray", "(", "img", ".", "resize", "(", "[", "o_width", ",", "o_height", "]", ",", "resample", "=", "0", ")", ")", "\n", "\n", "x_idx", "=", "np_img", ".", "nonzero", "(", ")", "\n", "active_sites_vis", "[", "0", ",", "j", ",", "x_idx", "[", "0", "]", ",", "x_idx", "[", "1", "]", ",", ":", "]", "=", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", "\n", "\n", "", "if", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "x_inter", "=", "self", ".", "layers", "[", "j", "]", "(", "x_inter", ".", "view", "(", "1", ",", "-", "1", ")", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'BNRelu'", "or", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "x_inter", "=", "self", ".", "layers", "[", "j", "]", "(", "x_inter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.setIdentityWeights": [[43, 49], ["enumerate", "reference_vgg_model.ReferenceVGGModel.layers[].weight.data.fill_"], "methods", ["None"], ["", "", "", "def", "setIdentityWeights", "(", "self", ")", ":", "\n", "        ", "\"\"\"Sets the different weights and biases equal\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "layer_name", "=", "i_layer", "[", "0", "]", "\n", "if", "layer_name", "==", "'C'", "or", "layer_name", "==", "'ClassicC'", "or", "layer_name", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "layers", "[", "j", "]", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.reference_vgg_model.ReferenceVGGModel.createReferenceVGG": [[50, 67], ["enumerate", "reference_vgg_model.ReferenceVGGModel.layers.append", "torch.nn.Conv2d", "reference_vgg_model.ReferenceVGGModel.layers.append", "torch.nn.Conv2d", "reference_vgg_model.ReferenceVGGModel.layers.append", "torch.nn.MaxPool2d", "reference_vgg_model.ReferenceVGGModel.layers.append", "torch.nn.Linear", "reference_vgg_model.ReferenceVGGModel.layers.append"], "methods", ["None"], ["", "", "", "def", "createReferenceVGG", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates a asynchronous VGG\"\"\"", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "self", ".", "layer_list", ")", ":", "\n", "            ", "if", "i_layer", "[", "0", "]", "==", "'C'", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Conv2d", "(", "in_channels", "=", "i_layer", "[", "1", "]", ",", "out_channels", "=", "i_layer", "[", "2", "]", ",", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ",", "padding_mode", "=", "'zeros'", ")", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicC'", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Conv2d", "(", "in_channels", "=", "i_layer", "[", "1", "]", ",", "out_channels", "=", "i_layer", "[", "2", "]", ",", "\n", "kernel_size", "=", "i_layer", "[", "3", "]", ",", "stride", "=", "i_layer", "[", "4", "]", ",", "bias", "=", "False", ",", ")", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'MP'", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "torch", ".", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", ")", "\n", "", "elif", "i_layer", "[", "0", "]", "==", "'ClassicFC'", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "torch", ".", "nn", ".", "Linear", "(", "in_features", "=", "i_layer", "[", "1", "]", ",", "out_features", "=", "i_layer", "[", "2", "]", ",", "bias", "=", "False", ")", ")", "\n", "", "elif", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'BNRelu'", "or", "self", ".", "layer_list", "[", "j", "]", "[", "0", "]", "==", "'ClassicBNRelu'", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "None", ")", "\n", "\n", "", "", "return", "self", ".", "layers", "", "", "", ""]], "home.repos.pwc.inspect_result.uzh-rpg_rpg_asynet.evaluation.compute_flops.computeFLOPS": [[4, 33], ["numpy.zeros", "enumerate", "np.zeros.sum", "len", "NotImplementedError"], "function", ["None"], ["def", "computeFLOPS", "(", "active_sites", ",", "layer_list", ",", "sparse_model", "=", "False", ",", "layerwise", "=", "False", ")", ":", "\n", "    ", "\"\"\"Compute the number floating point operation for the network specified by the layer list\"\"\"", "\n", "number_flops", "=", "np", ".", "zeros", "(", "[", "len", "(", "layer_list", ")", "]", ")", "\n", "kernel_size", "=", "3", "\n", "for", "j", ",", "i_layer", "in", "enumerate", "(", "layer_list", ")", ":", "\n", "        ", "layer_name", "=", "i_layer", "[", "0", "]", "\n", "if", "layer_name", "==", "'C'", ":", "\n", "            ", "if", "sparse_model", ":", "\n", "                ", "number_flops", "[", "j", "]", "=", "active_sites", "[", "j", "]", "*", "(", "2", "*", "i_layer", "[", "1", "]", ")", "*", "i_layer", "[", "2", "]", "+", "active_sites", "[", "j", "]", "*", "i_layer", "[", "1", "]", "\n", "", "else", ":", "\n", "                ", "number_flops", "[", "j", "]", "=", "active_sites", "[", "j", "+", "1", "]", "*", "(", "2", "*", "kernel_size", "*", "kernel_size", "*", "i_layer", "[", "1", "]", "-", "1", ")", "*", "i_layer", "[", "2", "]", "\n", "", "", "elif", "layer_name", "==", "'ClassicC'", ":", "\n", "            ", "number_flops", "[", "j", "]", "=", "active_sites", "[", "j", "+", "1", "]", "*", "(", "2", "*", "kernel_size", "*", "kernel_size", "*", "i_layer", "[", "1", "]", "-", "1", ")", "*", "i_layer", "[", "2", "]", "\n", "", "elif", "layer_name", "==", "'BNRelu'", "or", "layer_name", "==", "'ClassicBNRelu'", ":", "\n", "# BatchNorm can be merged with previous convolution layer", "\n", "# ReLu:", "\n", "            ", "number_flops", "[", "j", "]", "=", "active_sites", "[", "j", "]", "*", "layer_list", "[", "j", "-", "1", "]", "[", "2", "]", "\n", "", "elif", "layer_name", "==", "'ClassicFC'", ":", "\n", "            ", "number_flops", "[", "j", "]", "=", "2", "*", "i_layer", "[", "1", "]", "*", "i_layer", "[", "2", "]", "\n", "", "elif", "layer_name", "==", "'MP'", ":", "\n", "            ", "if", "layer_list", "[", "j", "+", "2", "]", "[", "0", "]", "!=", "'BNRelu'", ":", "\n", "                ", "raise", "NotImplementedError", "(", "'FLOP calculation for MaxPooling not followed by ConvLayer and BN is not'", "\n", "'implemented'", ")", "\n", "", "number_flops", "[", "j", "]", "=", "kernel_size", "*", "kernel_size", "*", "active_sites", "[", "j", "+", "2", "]", "*", "layer_list", "[", "j", "+", "1", "]", "[", "1", "]", "\n", "\n", "", "", "if", "layerwise", ":", "\n", "        ", "return", "number_flops", "\n", "", "else", ":", "\n", "        ", "return", "number_flops", ".", "sum", "(", ")", "\n", "", "", ""]]}