{"home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.Identity.__call__": [[8, 10], ["None"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.RandomSamplePixels.__init__": [[21, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "num_pixels", ")", ":", "\n", "        ", "self", ".", "num_pixels", "=", "num_pixels", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.RandomSamplePixels.__call__": [[24, 44], ["numpy.repeat", "random.sample", "numpy.ones", "valid_pixels[].astype", "range", "numpy.zeros", "numpy.stack", "numpy.array", "numpy.ones", "range", "range", "range"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "pixels", "=", "sample", "[", "'pixels'", "]", "\n", "T", ",", "C", ",", "S", "=", "pixels", ".", "shape", "\n", "if", "S", ">", "self", ".", "num_pixels", ":", "\n", "            ", "indices", "=", "random", ".", "sample", "(", "range", "(", "S", ")", ",", "self", ".", "num_pixels", ")", "\n", "x", "=", "pixels", "[", ":", ",", ":", ",", "indices", "]", "\n", "valid_pixels", "=", "np", ".", "ones", "(", "self", ".", "num_pixels", ")", "\n", "", "elif", "S", "<", "self", ".", "num_pixels", ":", "\n", "            ", "x", "=", "np", ".", "zeros", "(", "(", "T", ",", "C", ",", "self", ".", "num_pixels", ")", ")", "\n", "x", "[", "...", ",", ":", "S", "]", "=", "pixels", "\n", "x", "[", "...", ",", "S", ":", "]", "=", "np", ".", "stack", "(", "[", "x", "[", ":", ",", ":", ",", "0", "]", "for", "_", "in", "range", "(", "S", ",", "self", ".", "num_pixels", ")", "]", ",", "axis", "=", "-", "1", ")", "\n", "valid_pixels", "=", "np", ".", "array", "(", "[", "1", "for", "_", "in", "range", "(", "S", ")", "]", "+", "[", "0", "for", "_", "in", "range", "(", "S", ",", "self", ".", "num_pixels", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "pixels", "\n", "valid_pixels", "=", "np", ".", "ones", "(", "self", ".", "num_pixels", ")", "\n", "# Repeat valid_pixels across time", "\n", "", "valid_pixels", "=", "np", ".", "repeat", "(", "valid_pixels", "[", "np", ".", "newaxis", "]", ".", "astype", "(", "np", ".", "float32", ")", ",", "x", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "sample", "[", "'pixels'", "]", "=", "x", "\n", "sample", "[", "'valid_pixels'", "]", "=", "valid_pixels", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.RandomSampleTimeSteps.__init__": [[53, 55], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "seq_length", ")", ":", "\n", "        ", "self", ".", "seq_length", "=", "seq_length", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.RandomSampleTimeSteps.__call__": [[56, 70], ["sorted", "random.sample", "range"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "if", "self", ".", "seq_length", "==", "-", "1", ":", "\n", "            ", "return", "sample", "\n", "", "pixels", ",", "date_positions", ",", "valid_pixels", "=", "sample", "[", "'pixels'", "]", ",", "sample", "[", "'positions'", "]", ",", "sample", "[", "'valid_pixels'", "]", "\n", "t", "=", "pixels", ".", "shape", "[", "0", "]", "\n", "if", "t", ">", "self", ".", "seq_length", ":", "\n", "            ", "indices", "=", "sorted", "(", "random", ".", "sample", "(", "range", "(", "t", ")", ",", "self", ".", "seq_length", ")", ")", "\n", "sample", "[", "'pixels'", "]", "=", "pixels", "[", "indices", "]", "\n", "sample", "[", "'positions'", "]", "=", "date_positions", "[", "indices", "]", "\n", "sample", "[", "'valid_pixels'", "]", "=", "valid_pixels", "[", "indices", "]", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.RandomTemporalShift.__init__": [[78, 81], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_shift", "=", "60", ",", "p", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "max_shift", "=", "max_shift", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.RandomTemporalShift.__call__": [[82, 89], ["random.random", "random.randint"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "if", "random", ".", "random", "(", ")", "<", "self", ".", "p", ":", "\n", "            ", "shift", "=", "random", ".", "randint", "(", "-", "self", ".", "max_shift", ",", "self", ".", "max_shift", ")", "\n", "sample", "[", "'positions'", "]", "=", "sample", "[", "'positions'", "]", "+", "shift", "\n", "\n", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.Normalize.__init__": [[98, 108], ["numpy.array"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "max_pixel_value", "=", "65535", ")", ":", "\n", "        ", "self", ".", "max_pixel_value", "=", "max_pixel_value", "\n", "\n", "# approximate max values", "\n", "max_parcel_box_m", "=", "10000", "\n", "max_perimeter", "=", "max_parcel_box_m", "*", "4", "\n", "max_area", "=", "max_parcel_box_m", "**", "2", "\n", "max_perimeter_area_ratio", "=", "max_perimeter", "\n", "max_cover_ratio", "=", "1.0", "\n", "self", ".", "max_extra_values", "=", "np", ".", "array", "(", "[", "max_perimeter", ",", "max_area", ",", "max_perimeter_area_ratio", ",", "max_cover_ratio", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.Normalize.__call__": [[109, 114], ["numpy.clip().astype", "sample[].astype", "numpy.clip"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "sample", "[", "'pixels'", "]", "=", "np", ".", "clip", "(", "sample", "[", "'pixels'", "]", ",", "0", ",", "self", ".", "max_pixel_value", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "self", ".", "max_pixel_value", "\n", "if", "'extra'", "in", "sample", ":", "\n", "            ", "sample", "[", "'extra'", "]", "=", "sample", "[", "'extra'", "]", ".", "astype", "(", "np", ".", "float32", ")", "/", "self", ".", "max_extra_values", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.transforms.ToTensor.__call__": [[116, 125], ["torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "isinstance", "sample[].astype", "sample[].astype", "sample[].astype", "torch.from_numpy", "torch.tensor().long", "sample[].astype", "torch.tensor"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "sample", ")", ":", "\n", "        ", "sample", "[", "'pixels'", "]", "=", "torch", ".", "from_numpy", "(", "sample", "[", "'pixels'", "]", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "sample", "[", "'valid_pixels'", "]", "=", "torch", ".", "from_numpy", "(", "sample", "[", "'valid_pixels'", "]", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "sample", "[", "'positions'", "]", "=", "torch", ".", "from_numpy", "(", "sample", "[", "'positions'", "]", ".", "astype", "(", "np", ".", "long", ")", ")", "\n", "if", "'extra'", "in", "sample", ":", "\n", "            ", "sample", "[", "'extra'", "]", "=", "torch", ".", "from_numpy", "(", "sample", "[", "'extra'", "]", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "", "if", "isinstance", "(", "sample", "[", "'label'", "]", ",", "int", ")", ":", "\n", "            ", "sample", "[", "'label'", "]", "=", "torch", ".", "tensor", "(", "sample", "[", "'label'", "]", ")", ".", "long", "(", ")", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.TupleDataset.__init__": [[272, 278], ["torch.utils.data.Dataset.__init__", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dataset1", ",", "dataset2", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "weak", "=", "dataset1", "\n", "self", ".", "strong", "=", "dataset2", "\n", "assert", "len", "(", "dataset1", ")", "==", "len", "(", "dataset2", ")", "\n", "self", ".", "len", "=", "len", "(", "dataset1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.TupleDataset.__len__": [[279, 281], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "len", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.TupleDataset.__getitem__": [[282, 284], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "(", "self", ".", "weak", "[", "index", "]", ",", "self", ".", "strong", "[", "index", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.train_timematch": [[28, 178], ["timematch.get_data_loaders", "student.load_state_dict", "copy.deepcopy", "student.to", "copy.deepcopy.to", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "iter", "iter", "target_loader_no_aug.dataset.get_labels", "timematch.estimate_class_distribution", "range", "torch.load", "torch.load", "utils.focal_loss.FocalLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "student.parameters", "utils.train_utils.cycle", "utils.train_utils.cycle", "timematch.estimate_temporal_shift", "timematch.get_pseudo_labels", "tqdm.tqdm", "utils.train_utils.AverageMeter", "student.train", "copy.deepcopy.eval", "tqdm.tqdm.close", "all_pseudo_mask.sum", "sklearn.metrics.f1_score", "print", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "torch.save", "torch.save", "torch.save", "torch.save", "torch.max", "torch.max", "range", "timematch.estimate_class_distribution", "writer.add_scalar", "timematch.estimate_temporal_shift", "writer.add_scalar", "utils.train_utils.to_cuda", "torch.max", "torch.max", "utils.train_utils.to_cuda", "sample_source[].cuda", "utils.train_utils.to_cuda", "torch.nn.CrossEntropyLoss.", "torch.optim.Adam.zero_grad", "loss.backward", "torch.optim.Adam.step", "timematch.update_ema_variables", "utils.train_utils.AverageMeter.update", "tqdm.tqdm.set_postfix", "all_labels.extend", "all_pseudo_labels.extend", "all_pseudo_mask.extend", "numpy.array", "numpy.array", "numpy.array", "timematch.kl_divergence", "next", "next", "torch.no_grad", "torch.no_grad", "torch.softmax", "student.forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "student.forward", "torch.nn.CrossEntropyLoss.", "torch.optim.lr_scheduler.CosineAnnealingLR.step", "loss.item", "sample_target_weak[].tolist", "pseudo_targets.tolist", "pseudo_mask.tolist", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "student.eval", "evaluation.validation", "copy.deepcopy.eval", "evaluation.validation", "student.state_dict", "copy.deepcopy.state_dict", "min", "max", "copy.deepcopy.forward", "len", "student.forward", "len", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.get_data_loaders", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_labels", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.estimate_class_distribution", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.estimate_temporal_shift", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.get_pseudo_labels", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.f1_score", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.estimate_class_distribution", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.estimate_temporal_shift", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.update_ema_variables", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.kl_divergence", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward"], ["def", "train_timematch", "(", "student", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", ":", "\n", "    ", "source_loader", ",", "target_loader_no_aug", ",", "target_loader", "=", "get_data_loaders", "(", "splits", ",", "config", ",", "config", ".", "balance_source", ")", "\n", "\n", "# Setup model", "\n", "pretrained_path", "=", "f\"{config.weights}/fold_{fold_num}\"", "\n", "pretrained_weights", "=", "torch", ".", "load", "(", "f\"{pretrained_path}/model.pt\"", ")", "[", "\"state_dict\"", "]", "\n", "student", ".", "load_state_dict", "(", "pretrained_weights", ")", "\n", "teacher", "=", "deepcopy", "(", "student", ")", "\n", "student", ".", "to", "(", "device", ")", "\n", "teacher", ".", "to", "(", "device", ")", "\n", "\n", "# Training setup", "\n", "global_step", ",", "best_f1", "=", "0", ",", "0", "\n", "if", "config", ".", "use_focal_loss", ":", "\n", "        ", "criterion", "=", "FocalLoss", "(", "gamma", "=", "config", ".", "focal_loss_gamma", ")", "\n", "", "else", ":", "\n", "        ", "criterion", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "", "steps_per_epoch", "=", "config", ".", "steps_per_epoch", "\n", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "student", ".", "parameters", "(", ")", ",", "lr", "=", "config", ".", "lr", ",", "weight_decay", "=", "config", ".", "weight_decay", ")", "\n", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "optimizer", ",", "T_max", "=", "config", ".", "epochs", "*", "steps_per_epoch", ",", "eta_min", "=", "0", ")", "\n", "\n", "source_iter", "=", "iter", "(", "cycle", "(", "source_loader", ")", ")", "\n", "target_iter", "=", "iter", "(", "cycle", "(", "target_loader", ")", ")", "\n", "min_shift", ",", "max_shift", "=", "-", "config", ".", "max_temporal_shift", ",", "config", ".", "max_temporal_shift", "\n", "target_to_source_shift", "=", "0", "\n", "\n", "# To evaluate how well we estimate class distribution", "\n", "target_labels", "=", "target_loader_no_aug", ".", "dataset", ".", "get_labels", "(", ")", "\n", "actual_class_distr", "=", "estimate_class_distribution", "(", "target_labels", ",", "config", ".", "num_classes", ")", "\n", "\n", "# estimate an initial guess for shift using Inception Score", "\n", "if", "config", ".", "estimate_shift", ":", "\n", "        ", "shift_estimator", "=", "'IS'", "if", "config", ".", "shift_estimator", "==", "'AM'", "else", "config", ".", "shift_estimator", "\n", "target_to_source_shift", "=", "estimate_temporal_shift", "(", "teacher", ",", "target_loader_no_aug", ",", "device", ",", "min_shift", "=", "min_shift", ",", "max_shift", "=", "max_shift", ",", "sample_size", "=", "config", ".", "sample_size", ",", "shift_estimator", "=", "shift_estimator", ")", "\n", "if", "target_to_source_shift", ">=", "0", ":", "\n", "            ", "min_shift", "=", "0", "\n", "", "else", ":", "\n", "            ", "max_shift", "=", "0", "\n", "\n", "# Use estimated shift to get initial pseudo labels", "\n", "", "pseudo_softmaxes", "=", "get_pseudo_labels", "(", "teacher", ",", "target_loader_no_aug", ",", "device", ",", "target_to_source_shift", ",", "n", "=", "None", ")", "\n", "all_pseudo_labels", "=", "torch", ".", "max", "(", "pseudo_softmaxes", ",", "dim", "=", "1", ")", "[", "1", "]", "\n", "\n", "", "source_to_target_shift", "=", "0", "\n", "for", "epoch", "in", "range", "(", "config", ".", "epochs", ")", ":", "\n", "        ", "progress_bar", "=", "tqdm", "(", "range", "(", "steps_per_epoch", ")", ",", "desc", "=", "f\"TimeMatch Epoch {epoch + 1}/{config.epochs}\"", ")", "\n", "loss_meter", "=", "AverageMeter", "(", ")", "\n", "\n", "if", "config", ".", "estimate_shift", ":", "\n", "            ", "estimated_class_distr", "=", "estimate_class_distribution", "(", "all_pseudo_labels", ",", "config", ".", "num_classes", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/kl_d\"", ",", "kl_divergence", "(", "actual_class_distr", ",", "estimated_class_distr", ")", ",", "epoch", ")", "\n", "target_to_source_shift", "=", "estimate_temporal_shift", "(", "teacher", ",", "\n", "target_loader_no_aug", ",", "device", ",", "estimated_class_distr", ",", "\n", "min_shift", "=", "min_shift", ",", "max_shift", "=", "max_shift", ",", "sample_size", "=", "config", ".", "sample_size", ",", "\n", "shift_estimator", "=", "config", ".", "shift_estimator", ")", "\n", "if", "epoch", "==", "0", ":", "\n", "                ", "if", "config", ".", "shift_source", ":", "\n", "                    ", "source_to_target_shift", "=", "-", "target_to_source_shift", "\n", "", "else", ":", "\n", "                    ", "source_to_target_shift", "=", "0", "\n", "", "min_shift", ",", "max_shift", "=", "min", "(", "target_to_source_shift", ",", "0", ")", ",", "max", "(", "0", ",", "target_to_source_shift", ")", "\n", "", "writer", ".", "add_scalar", "(", "\"train/temporal_shift\"", ",", "target_to_source_shift", ",", "epoch", ")", "\n", "\n", "", "student", ".", "train", "(", ")", "\n", "teacher", ".", "eval", "(", ")", "# don't update BN or use dropout for teacher", "\n", "\n", "all_labels", ",", "all_pseudo_labels", ",", "all_pseudo_mask", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "step", "in", "progress_bar", ":", "\n", "            ", "sample_source", ",", "(", "sample_target_weak", ",", "sample_target_strong", ")", "=", "next", "(", "source_iter", ")", ",", "next", "(", "target_iter", ")", "\n", "\n", "# Get pseudo labels from teacher", "\n", "pixels_t_weak", ",", "mask_t_weak", ",", "position_t_weak", ",", "extra_t_weak", "=", "to_cuda", "(", "sample_target_weak", ",", "device", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                ", "teacher_preds", "=", "F", ".", "softmax", "(", "teacher", ".", "forward", "(", "pixels_t_weak", ",", "mask_t_weak", ",", "position_t_weak", "+", "target_to_source_shift", ",", "extra_t_weak", ")", ",", "dim", "=", "1", ")", "\n", "", "pseudo_conf", ",", "pseudo_targets", "=", "torch", ".", "max", "(", "teacher_preds", ",", "dim", "=", "1", ")", "\n", "pseudo_mask", "=", "pseudo_conf", ">", "config", ".", "pseudo_threshold", "\n", "\n", "# Update student on shifted source data and pseudo-labeled target data", "\n", "pixels_s", ",", "mask_s", ",", "position_s", ",", "extra_s", "=", "to_cuda", "(", "sample_source", ",", "device", ")", "\n", "source_labels", "=", "sample_source", "[", "'label'", "]", ".", "cuda", "(", "device", ",", "non_blocking", "=", "True", ")", "\n", "pixels_t", ",", "mask_t", ",", "position_t", ",", "extra_t", "=", "to_cuda", "(", "sample_target_strong", ",", "device", ")", "\n", "logits_target", "=", "None", "\n", "loss_target", "=", "0.0", "\n", "if", "config", ".", "domain_specific_bn", ":", "\n", "                ", "logits_source", "=", "student", ".", "forward", "(", "pixels_s", ",", "mask_s", ",", "position_s", "+", "source_to_target_shift", ",", "extra_s", ")", "\n", "if", "len", "(", "torch", ".", "nonzero", "(", "pseudo_mask", ")", ")", ">=", "2", ":", "# at least 2 examples required for BN", "\n", "                    ", "logits_target", "=", "student", ".", "forward", "(", "pixels_t", "[", "pseudo_mask", "]", ",", "mask_t", "[", "pseudo_mask", "]", ",", "position_t", "[", "pseudo_mask", "]", ",", "extra_t", "[", "pseudo_mask", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "pixels", "=", "torch", ".", "cat", "(", "[", "pixels_s", ",", "pixels_t", "[", "pseudo_mask", "]", "]", ")", "\n", "mask", "=", "torch", ".", "cat", "(", "[", "mask_s", ",", "mask_t", "[", "pseudo_mask", "]", "]", ")", "\n", "position", "=", "torch", ".", "cat", "(", "[", "position_s", "+", "source_to_target_shift", ",", "position_t", "[", "pseudo_mask", "]", "]", ")", "\n", "extra", "=", "torch", ".", "cat", "(", "[", "extra_s", ",", "extra_t", "[", "pseudo_mask", "]", "]", ")", "\n", "logits", "=", "student", ".", "forward", "(", "pixels", ",", "mask", ",", "position", ",", "extra", ")", "\n", "logits_source", ",", "logits_target", "=", "logits", "[", ":", "config", ".", "batch_size", "]", ",", "logits", "[", "config", ".", "batch_size", ":", "]", "\n", "\n", "", "loss_source", "=", "criterion", "(", "logits_source", ",", "source_labels", ")", "\n", "if", "logits_target", "is", "not", "None", ":", "\n", "                ", "loss_target", "=", "criterion", "(", "logits_target", ",", "pseudo_targets", "[", "pseudo_mask", "]", ")", "\n", "", "loss", "=", "loss_source", "+", "config", ".", "trade_off", "*", "loss_target", "\n", "\n", "# compute loss and backprop", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "if", "scheduler", "is", "not", "None", ":", "\n", "                ", "scheduler", ".", "step", "(", ")", "\n", "", "update_ema_variables", "(", "student", ",", "teacher", ",", "config", ".", "ema_decay", ")", "\n", "\n", "# Metrics", "\n", "loss_meter", ".", "update", "(", "loss", ".", "item", "(", ")", ")", "\n", "progress_bar", ".", "set_postfix", "(", "loss", "=", "f\"{loss_meter.avg:.3f}\"", ")", "\n", "all_labels", ".", "extend", "(", "sample_target_weak", "[", "'label'", "]", ".", "tolist", "(", ")", ")", "\n", "all_pseudo_labels", ".", "extend", "(", "pseudo_targets", ".", "tolist", "(", ")", ")", "\n", "all_pseudo_mask", ".", "extend", "(", "pseudo_mask", ".", "tolist", "(", ")", ")", "\n", "\n", "if", "step", "%", "config", ".", "log_step", "==", "0", ":", "\n", "                ", "writer", ".", "add_scalar", "(", "\"train/loss\"", ",", "loss_meter", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/target_updates\"", ",", "len", "(", "torch", ".", "nonzero", "(", "pseudo_mask", ")", ")", ",", "global_step", ")", "\n", "\n", "", "global_step", "+=", "1", "\n", "\n", "", "progress_bar", ".", "close", "(", ")", "\n", "\n", "# Evaluate pseudo labels", "\n", "all_labels", ",", "all_pseudo_labels", ",", "all_pseudo_mask", "=", "np", ".", "array", "(", "all_labels", ")", ",", "np", ".", "array", "(", "all_pseudo_labels", ")", ",", "np", ".", "array", "(", "all_pseudo_mask", ")", "\n", "pseudo_count", "=", "all_pseudo_mask", ".", "sum", "(", ")", "\n", "conf_pseudo_f1", "=", "sklearn", ".", "metrics", ".", "f1_score", "(", "all_labels", "[", "all_pseudo_mask", "]", ",", "all_pseudo_labels", "[", "all_pseudo_mask", "]", ",", "average", "=", "'macro'", ",", "zero_division", "=", "0", ")", "\n", "print", "(", "f\"Teacher pseudo label F1 {conf_pseudo_f1:.3f} (n={pseudo_count})\"", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/pseudo_f1\"", ",", "conf_pseudo_f1", ",", "epoch", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/pseudo_count\"", ",", "pseudo_count", ",", "epoch", ")", "\n", "\n", "writer", ".", "add_scalar", "(", "\"train/pseudo_f1\"", ",", "conf_pseudo_f1", ",", "epoch", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/pseudo_count\"", ",", "pseudo_count", ",", "epoch", ")", "\n", "\n", "if", "config", ".", "run_validation", ":", "\n", "            ", "if", "config", ".", "output_student", ":", "\n", "                ", "student", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "best_f1", ",", "None", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "student", ",", "val_loader", ",", "writer", ")", "\n", "", "else", ":", "\n", "                ", "teacher", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "best_f1", ",", "None", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "teacher", ",", "val_loader", ",", "writer", ")", "\n", "\n", "# Save model final model ", "\n", "", "", "", "if", "config", ".", "output_student", ":", "\n", "        ", "torch", ".", "save", "(", "{", "'state_dict'", ":", "student", ".", "state_dict", "(", ")", "}", ",", "best_model_path", ")", "\n", "", "else", ":", "\n", "        ", "torch", ".", "save", "(", "{", "'state_dict'", ":", "teacher", ".", "state_dict", "(", ")", "}", ",", "best_model_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.estimate_class_distribution": [[179, 181], ["numpy.bincount", "len"], "function", ["None"], ["", "", "def", "estimate_class_distribution", "(", "labels", ",", "num_classes", ")", ":", "\n", "    ", "return", "np", ".", "bincount", "(", "labels", ",", "minlength", "=", "num_classes", ")", "/", "len", "(", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.kl_divergence": [[182, 184], ["numpy.sum", "numpy.log", "numpy.log"], "function", ["None"], ["", "def", "kl_divergence", "(", "actual", ",", "estimated", ")", ":", "\n", "    ", "return", "np", ".", "sum", "(", "actual", "*", "(", "np", ".", "log", "(", "actual", "+", "1e-5", ")", "-", "np", ".", "log", "(", "estimated", "+", "1e-5", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.update_ema_variables": [[185, 189], ["torch.no_grad", "torch.no_grad", "zip", "ema.state_dict().values", "model.state_dict().values", "ema_v.copy_", "ema.state_dict", "model.state_dict"], "function", ["None"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "update_ema_variables", "(", "model", ",", "ema", ",", "decay", "=", "0.99", ")", ":", "\n", "    ", "for", "ema_v", ",", "model_v", "in", "zip", "(", "ema", ".", "state_dict", "(", ")", ".", "values", "(", ")", ",", "model", ".", "state_dict", "(", ")", ".", "values", "(", ")", ")", ":", "\n", "        ", "ema_v", ".", "copy_", "(", "decay", "*", "ema_v", "+", "(", "1.", "-", "decay", ")", "*", "model_v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.get_data_loaders": [[191, 269], ["torchvision.transforms.Compose", "torchvision.transforms.Compose", "dataset.PixelSetData", "dataset.PixelSetData", "copy.deepcopy", "copy.deepcopy", "timematch.TupleDataset", "copy.deepcopy", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "print", "dataset.PixelSetData.get_labels", "collections.Counter", "torch.utils.data.sampler.WeightedRandomSampler", "print", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "transforms.RandomSamplePixels", "transforms.Normalize", "transforms.ToTensor", "transforms.RandomSamplePixels", "transforms.RandomSampleTimeSteps", "transforms.Normalize", "transforms.ToTensor", "len", "transforms.RandomTemporalShift", "transforms.Identity", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_labels"], ["", "", "def", "get_data_loaders", "(", "splits", ",", "config", ",", "balance_source", "=", "True", ")", ":", "\n", "    ", "weak_aug", "=", "transforms", ".", "Compose", "(", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", ")", "\n", "\n", "strong_aug", "=", "transforms", ".", "Compose", "(", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", ",", "\n", "RandomTemporalShift", "(", "max_shift", "=", "config", ".", "max_shift_aug", ",", "p", "=", "config", ".", "shift_aug_p", ")", "if", "config", ".", "with_shift_aug", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", ")", "\n", "\n", "source_dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "source", ",", "\n", "config", ".", "classes", ",", "strong_aug", ",", "\n", "indices", "=", "splits", "[", "config", ".", "source", "]", "[", "'train'", "]", ",", ")", "\n", "\n", "if", "balance_source", ":", "\n", "        ", "source_labels", "=", "source_dataset", ".", "get_labels", "(", ")", "\n", "freq", "=", "Counter", "(", "source_labels", ")", "\n", "class_weight", "=", "{", "x", ":", "1.0", "/", "freq", "[", "x", "]", "for", "x", "in", "freq", "}", "\n", "source_weights", "=", "[", "class_weight", "[", "x", "]", "for", "x", "in", "source_labels", "]", "\n", "sampler", "=", "WeightedRandomSampler", "(", "source_weights", ",", "len", "(", "source_labels", ")", ")", "\n", "print", "(", "\"using balanced loader for source\"", ")", "\n", "source_loader", "=", "data", ".", "DataLoader", "(", "\n", "source_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "sampler", "=", "sampler", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "source_loader", "=", "data", ".", "DataLoader", "(", "\n", "source_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "", "target_dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "target", ",", "\n", "config", ".", "classes", ",", "None", ",", "\n", "indices", "=", "splits", "[", "config", ".", "target", "]", "[", "'train'", "]", ")", "\n", "\n", "strong_dataset", "=", "deepcopy", "(", "target_dataset", ")", "\n", "strong_dataset", ".", "transform", "=", "strong_aug", "\n", "weak_dataset", "=", "deepcopy", "(", "target_dataset", ")", "\n", "weak_dataset", ".", "transform", "=", "weak_aug", "\n", "target_dataset_weak_strong", "=", "TupleDataset", "(", "weak_dataset", ",", "strong_dataset", ")", "\n", "\n", "no_aug_dataset", "=", "deepcopy", "(", "target_dataset", ")", "\n", "no_aug_dataset", ".", "transform", "=", "weak_aug", "\n", "# For shift estimation", "\n", "target_loader_no_aug", "=", "data", ".", "DataLoader", "(", "\n", "no_aug_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", ")", "\n", "\n", "# For mean teacher training", "\n", "target_loader_weak_strong", "=", "data", ".", "DataLoader", "(", "\n", "target_dataset_weak_strong", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "pin_memory", "=", "True", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "print", "(", "f'size of source dataset: {len(source_dataset)} ({len(source_loader)} batches)'", ")", "\n", "print", "(", "f'size of target dataset: {len(target_dataset)} ({len(target_loader_weak_strong)} batches)'", ")", "\n", "\n", "return", "source_loader", ",", "target_loader_no_aug", ",", "target_loader_weak_strong", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.estimate_temporal_shift": [[286, 358], ["torch.no_grad", "torch.no_grad", "list", "model.eval", "iter", "tqdm.tqdm", "torch.cat().cpu().numpy", "torch.cat().cpu().numpy", "numpy.array", "numpy.argmax", "print", "torch.cat().cpu().numpy.mean", "range", "len", "range", "next", "np.array.extend", "utils.train_utils.to_cuda", "model.spatial_encoder.forward", "torch.stack", "torch.stack", "torch.softmax", "torch.cat().cpu().numpy.append", "numpy.mean", "print", "sample[].tolist", "torch.cat().cpu", "torch.cat().cpu", "numpy.moveaxis", "numpy.sum", "numpy.argsort", "numpy.argsort", "print", "model.decoder", "numpy.max", "numpy.mean", "numpy.zeros_like", "range", "numpy.sum", "numpy.mean", "numpy.argsort", "print", "model.temporal_encoder", "torch.cat", "torch.cat", "numpy.sum", "len", "numpy.zeros", "np.zeros.mean", "numpy.sum", "numpy.argmax", "numpy.log", "numpy.log", "numpy.argsort", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.argmax", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "estimate_temporal_shift", "(", "model", ",", "target_loader", ",", "device", ",", "class_distribution", "=", "None", ",", "min_shift", "=", "-", "60", ",", "max_shift", "=", "60", ",", "sample_size", "=", "100", ",", "shift_estimator", "=", "'IS'", ")", ":", "\n", "    ", "shifts", "=", "list", "(", "range", "(", "min_shift", ",", "max_shift", "+", "1", ")", ")", "\n", "model", ".", "eval", "(", ")", "\n", "if", "sample_size", "is", "None", ":", "\n", "        ", "sample_size", "=", "len", "(", "target_loader", ")", "\n", "\n", "", "target_iter", "=", "iter", "(", "target_loader", ")", "\n", "shift_softmaxes", ",", "labels", "=", "[", "]", ",", "[", "]", "\n", "for", "_", "in", "tqdm", "(", "range", "(", "sample_size", ")", ",", "desc", "=", "f'Estimating shift between [{min_shift}, {max_shift}]'", ")", ":", "\n", "        ", "sample", "=", "next", "(", "target_iter", ")", "\n", "labels", ".", "extend", "(", "sample", "[", "'label'", "]", ".", "tolist", "(", ")", ")", "\n", "pixels", ",", "valid_pixels", ",", "positions", ",", "extra", "=", "to_cuda", "(", "sample", ",", "device", ")", "\n", "spatial_feats", "=", "model", ".", "spatial_encoder", ".", "forward", "(", "pixels", ",", "valid_pixels", ",", "extra", ")", "\n", "shift_logits", "=", "torch", ".", "stack", "(", "[", "model", ".", "decoder", "(", "model", ".", "temporal_encoder", "(", "spatial_feats", ",", "positions", "+", "shift", ")", ")", "for", "shift", "in", "shifts", "]", ",", "dim", "=", "1", ")", "\n", "shift_probs", "=", "F", ".", "softmax", "(", "shift_logits", ",", "dim", "=", "2", ")", "\n", "shift_softmaxes", ".", "append", "(", "shift_probs", ")", "\n", "", "shift_softmaxes", "=", "torch", ".", "cat", "(", "shift_softmaxes", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "# (N, n_shifts, n_classes)", "\n", "labels", "=", "np", ".", "array", "(", "labels", ")", "\n", "shift_predictions", "=", "np", ".", "argmax", "(", "shift_softmaxes", ",", "axis", "=", "2", ")", "# (N, n_shifts)", "\n", "\n", "# shift_f1_scores = [f1_score(labels, shift_predictions, num_classes) for shift_predictions in all_shift_predictions]", "\n", "shift_acc_scores", "=", "[", "(", "labels", "==", "predictions", ")", ".", "mean", "(", ")", "for", "predictions", "in", "np", ".", "moveaxis", "(", "shift_predictions", ",", "0", ",", "1", ")", "]", "\n", "print", "(", "f\"Most accurate shift {shifts[np.argmax(shift_acc_scores)]} with {np.max(shift_acc_scores):.3f}\"", ")", "\n", "\n", "p_yx", "=", "shift_softmaxes", "# (N, n_shifts, n_classes)", "\n", "p_y", "=", "shift_softmaxes", ".", "mean", "(", "axis", "=", "0", ")", "# (n_shifts, n_classes)", "\n", "\n", "\n", "if", "shift_estimator", "==", "'IS'", ":", "\n", "        ", "inception_score", "=", "np", ".", "mean", "(", "np", ".", "sum", "(", "p_yx", "*", "(", "np", ".", "log", "(", "p_yx", "+", "1e-5", ")", "-", "np", ".", "log", "(", "p_y", "[", "np", ".", "newaxis", "]", "+", "1e-5", ")", ")", ",", "axis", "=", "2", ")", ",", "axis", "=", "0", ")", "# (n_shifts)", "\n", "\n", "shift_indices_ranked", "=", "np", ".", "argsort", "(", "inception_score", ")", "[", ":", ":", "-", "1", "]", "# max is best", "\n", "best_shift_idx", "=", "shift_indices_ranked", "[", "0", "]", "\n", "best_shift", "=", "shifts", "[", "best_shift_idx", "]", "\n", "print", "(", "f\"Best Inception Score shift {best_shift} with accuracy {shift_acc_scores[best_shift_idx]:.3f}\"", ")", "\n", "return", "best_shift", "\n", "\n", "", "elif", "shift_estimator", "==", "'ENT'", ":", "\n", "        ", "entropy_score", "=", "-", "np", ".", "mean", "(", "np", ".", "sum", "(", "p_yx", "*", "np", ".", "log", "(", "p_yx", "+", "1e-5", ")", ",", "axis", "=", "2", ")", ",", "axis", "=", "0", ")", "# (n_shifts)", "\n", "shift_indices_ranked", "=", "np", ".", "argsort", "(", "entropy_score", ")", "# min is best", "\n", "best_shift_idx", "=", "shift_indices_ranked", "[", "0", "]", "\n", "best_shift", "=", "shifts", "[", "best_shift_idx", "]", "\n", "print", "(", "f\"Best Entropy Score shift {best_shift} with accuracy {shift_acc_scores[best_shift_idx]:.3f}\"", ")", "\n", "return", "best_shift", "\n", "\n", "", "elif", "shift_estimator", "==", "'AM'", ":", "\n", "        ", "assert", "class_distribution", "is", "not", "None", ",", "'Target class distribution required to compute AM score'", "\n", "\n", "# estimate class distribution", "\n", "one_hot_p_y", "=", "np", ".", "zeros_like", "(", "p_y", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "shifts", ")", ")", ":", "\n", "            ", "one_hot", "=", "np", ".", "zeros", "(", "(", "shift_softmaxes", ".", "shape", "[", "0", "]", ",", "shift_softmaxes", ".", "shape", "[", "-", "1", "]", ")", ")", "# (n, classes)", "\n", "one_hot", "[", "np", ".", "arange", "(", "one_hot", ".", "shape", "[", "0", "]", ")", ",", "shift_predictions", "[", ":", ",", "i", "]", "]", "=", "1", "\n", "one_hot_p_y", "[", "i", "]", "=", "one_hot", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "", "c_train", "=", "class_distribution", "\n", "# kl_d = np.sum(c_train * (np.log(c_train + 1e-5) - np.log(p_y + 1e-5)), axis=1) # soft class distr", "\n", "kl_d", "=", "np", ".", "sum", "(", "c_train", "*", "(", "np", ".", "log", "(", "c_train", "+", "1e-5", ")", "-", "np", ".", "log", "(", "one_hot_p_y", "+", "1e-5", ")", ")", ",", "axis", "=", "1", ")", "\n", "entropy", "=", "np", ".", "mean", "(", "np", ".", "sum", "(", "-", "p_yx", "*", "np", ".", "log", "(", "p_yx", "+", "1e-5", ")", ",", "axis", "=", "2", ")", ",", "axis", "=", "0", ")", "\n", "am", "=", "kl_d", "+", "entropy", "\n", "shift_indices_ranked", "=", "np", ".", "argsort", "(", "am", ")", "# min is best", "\n", "best_shift_idx", "=", "shift_indices_ranked", "[", "0", "]", "\n", "best_shift", "=", "shifts", "[", "best_shift_idx", "]", "\n", "print", "(", "f\"Best AM Score shift {best_shift} with accuracy {shift_acc_scores[best_shift_idx]:.3f}\"", ")", "\n", "\n", "return", "best_shift", "\n", "", "elif", "shift_estimator", "==", "'ACC'", ":", "# for upperbound comparison", "\n", "        ", "shift_indices_ranked", "=", "np", ".", "argsort", "(", "shift_acc_scores", ")", "[", ":", ":", "-", "1", "]", "# max is best", "\n", "return", "shifts", "[", "np", ".", "argmax", "(", "shift_acc_scores", ")", "]", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.get_pseudo_labels": [[362, 382], ["torch.no_grad", "torch.no_grad", "model.eval", "enumerate", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "torch.as_tensor", "tqdm.tqdm", "torch.as_tensor.extend", "utils.train_utils.to_cuda", "model.forward", "torch.softmax().cpu", "torch.as_tensor.extend", "sample[].tolist", "F.softmax().cpu.tolist", "torch.argsort", "torch.argsort", "torch.softmax"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward"], ["", "", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "get_pseudo_labels", "(", "model", ",", "data_loader", ",", "device", ",", "best_shift", ",", "n", "=", "500", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "pseudo_softmaxes", "=", "[", "]", "\n", "indices", "=", "[", "]", "\n", "for", "i", ",", "sample", "in", "enumerate", "(", "tqdm", "(", "data_loader", ",", "\"computing pseudo labels\"", ")", ")", ":", "\n", "        ", "if", "n", "is", "not", "None", "and", "i", "==", "n", ":", "\n", "            ", "break", "\n", "", "indices", ".", "extend", "(", "sample", "[", "\"index\"", "]", ".", "tolist", "(", ")", ")", "\n", "\n", "pixels", ",", "valid_pixels", ",", "positions", ",", "extra", "=", "to_cuda", "(", "sample", ",", "device", ")", "\n", "logits", "=", "model", ".", "forward", "(", "pixels", ",", "valid_pixels", ",", "positions", "+", "best_shift", ",", "extra", ")", "\n", "probs", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "1", ")", ".", "cpu", "(", ")", "\n", "pseudo_softmaxes", ".", "extend", "(", "probs", ".", "tolist", "(", ")", ")", "\n", "\n", "", "indices", "=", "torch", ".", "as_tensor", "(", "indices", ")", "\n", "pseudo_softmaxes", "=", "torch", ".", "as_tensor", "(", "pseudo_softmaxes", ")", "\n", "pseudo_softmaxes", "=", "pseudo_softmaxes", "[", "torch", ".", "argsort", "(", "indices", ")", "]", "\n", "\n", "return", "pseudo_softmaxes", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.main": [[33, 118], ["random.seed", "numpy.random.seed", "torch.manual_seed", "torch.manual_seed", "torch.device", "torch.device", "utils.label_utils.get_classes", "dataset.PixelSetData", "numpy.unique", "print", "len", "train.create_train_val_test_folds", "enumerate", "train.overall_performance", "dataset.PixelSetData.get_labels", "len", "len", "train.overall_performance", "print", "os.path.join", "dataset.create_evaluation_loaders", "models.stclassifier.PseGru.to", "os.path.join", "print", "models.stclassifier.PseGru.load_state_dict", "evaluation.evaluation", "print", "print", "train.save_results", "cfg.source.split", "dataset.PixelSetData", "models.stclassifier.PseLTae", "print", "print", "os.path.isfile", "torch.utils.tensorboard.SummaryWriter", "torch.load", "torch.load", "models.stclassifier.PseTae", "train.get_num_trainable_params", "input", "timematch.train_timematch", "models.stclassifier.PseTempCNN", "distutils.util.strtobool", "print", "competitors.dann.dann.train_dann", "models.stclassifier.PseGru", "NotImplementedError", "len", "competitors.mmd.train_mmd.train_mmd", "competitors.jumbot.jumbot.train_jumbot", "competitors.alda.train_alda.train_alda", "train.train_supervised"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_classes", "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.create_train_val_test_folds", "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.overall_performance", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_labels", "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.overall_performance", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.create_evaluation_loaders", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.evaluation", "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.save_results", "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.get_num_trainable_params", "home.repos.pwc.inspect_result.jnyborg_timematch.None.timematch.train_timematch", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.train_dann", "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.train_mmd.train_mmd", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.train_jumbot", "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.train_alda", "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.train_supervised"], ["def", "main", "(", "config", ")", ":", "\n", "    ", "random", ".", "seed", "(", "config", ".", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "config", ".", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "config", ".", "seed", ")", "\n", "device", "=", "torch", ".", "device", "(", "config", ".", "device", ")", "\n", "\n", "# Select classes that appear at least 200 times source", "\n", "source_classes", "=", "label_utils", ".", "get_classes", "(", "cfg", ".", "source", ".", "split", "(", "'/'", ")", "[", "0", "]", ",", "combine_spring_and_winter", "=", "cfg", ".", "combine_spring_and_winter", ")", "\n", "source_data", "=", "PixelSetData", "(", "cfg", ".", "data_root", ",", "cfg", ".", "source", ",", "source_classes", ")", "\n", "labels", ",", "counts", "=", "np", ".", "unique", "(", "source_data", ".", "get_labels", "(", ")", ",", "return_counts", "=", "True", ")", "\n", "source_classes", "=", "[", "source_classes", "[", "i", "]", "for", "i", "in", "labels", "[", "counts", ">=", "200", "]", "]", "\n", "print", "(", "'Using classes:'", ",", "source_classes", ")", "\n", "cfg", ".", "classes", "=", "source_classes", "\n", "cfg", ".", "num_classes", "=", "len", "(", "source_classes", ")", "\n", "\n", "# Randomly assign parcels to train/val/test", "\n", "indices", "=", "{", "config", ".", "source", ":", "len", "(", "source_data", ")", ",", "config", ".", "target", ":", "len", "(", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "target", ",", "source_classes", ")", ")", "}", "\n", "folds", "=", "create_train_val_test_folds", "(", "[", "config", ".", "source", ",", "config", ".", "target", "]", ",", "config", ".", "num_folds", ",", "indices", ",", "config", ".", "val_ratio", ",", "config", ".", "test_ratio", ")", "\n", "\n", "if", "config", ".", "overall", ":", "\n", "        ", "overall_performance", "(", "config", ")", "\n", "return", "\n", "\n", "", "for", "fold_num", ",", "splits", "in", "enumerate", "(", "folds", ")", ":", "\n", "        ", "print", "(", "f'Starting fold {fold_num}...'", ")", "\n", "\n", "config", ".", "fold_dir", "=", "os", ".", "path", ".", "join", "(", "config", ".", "output_dir", ",", "f'fold_{fold_num}'", ")", "\n", "config", ".", "fold_num", "=", "fold_num", "\n", "\n", "sample_pixels_val", "=", "config", ".", "sample_pixels_val", "or", "(", "config", ".", "eval", "and", "config", ".", "temporal_shift", ")", "\n", "val_loader", ",", "test_loader", "=", "create_evaluation_loaders", "(", "config", ".", "target", ",", "splits", ",", "config", ",", "sample_pixels_val", ")", "\n", "\n", "if", "config", ".", "model", "==", "'pseltae'", ":", "\n", "            ", "model", "=", "PseLTae", "(", "input_dim", "=", "config", ".", "input_dim", ",", "num_classes", "=", "config", ".", "num_classes", ",", "with_extra", "=", "config", ".", "with_extra", ")", "\n", "", "elif", "config", ".", "model", "==", "'psetae'", ":", "\n", "            ", "model", "=", "PseTae", "(", "input_dim", "=", "config", ".", "input_dim", ",", "num_classes", "=", "config", ".", "num_classes", ",", "with_extra", "=", "config", ".", "with_extra", ")", "\n", "", "elif", "config", ".", "model", "==", "'psetcnn'", ":", "\n", "            ", "model", "=", "PseTempCNN", "(", "input_dim", "=", "config", ".", "input_dim", ",", "num_classes", "=", "config", ".", "num_classes", ",", "with_extra", "=", "config", ".", "with_extra", ")", "\n", "", "elif", "config", ".", "model", "==", "'psegru'", ":", "\n", "            ", "model", "=", "PseGru", "(", "input_dim", "=", "config", ".", "input_dim", ",", "num_classes", "=", "config", ".", "num_classes", ",", "with_extra", "=", "config", ".", "with_extra", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", ")", "\n", "\n", "", "model", ".", "to", "(", "config", ".", "device", ")", "\n", "\n", "best_model_path", "=", "os", ".", "path", ".", "join", "(", "config", ".", "fold_dir", ",", "'model.pt'", ")", "\n", "\n", "if", "not", "config", ".", "eval", ":", "\n", "            ", "print", "(", "model", ")", "\n", "print", "(", "'Number of trainable parameters:'", ",", "get_num_trainable_params", "(", "model", ")", ")", "\n", "\n", "if", "os", ".", "path", ".", "isfile", "(", "best_model_path", ")", ":", "\n", "                ", "answer", "=", "input", "(", "f'Model already exists at {best_model_path}! Override y/[n]? '", ")", "\n", "override", "=", "strtobool", "(", "answer", ")", "if", "len", "(", "answer", ")", ">", "0", "else", "False", "\n", "if", "not", "override", ":", "\n", "                    ", "print", "(", "'Skipping fold'", ",", "fold_num", ")", "\n", "continue", "\n", "\n", "", "", "writer", "=", "SummaryWriter", "(", "log_dir", "=", "f'{config.tensorboard_log_dir}_fold{fold_num}'", ",", "purge_step", "=", "0", ")", "\n", "if", "config", ".", "method", "==", "'timematch'", ":", "\n", "                ", "train_timematch", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", "\n", "", "elif", "config", ".", "method", "==", "'dann'", ":", "\n", "                ", "train_dann", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", "\n", "", "elif", "config", ".", "method", "==", "'mmd'", ":", "\n", "                ", "train_mmd", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", "\n", "", "elif", "config", ".", "method", "==", "'jumbot'", ":", "\n", "                ", "train_jumbot", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", "\n", "", "elif", "config", ".", "method", "==", "'alda'", ":", "\n", "                ", "train_alda", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", "\n", "", "else", ":", "\n", "                ", "train_supervised", "(", "model", ",", "config", ",", "writer", ",", "splits", ",", "val_loader", ",", "device", ",", "best_model_path", ")", "\n", "\n", "", "", "print", "(", "'Restoring best model weights for testing...'", ")", "\n", "\n", "state_dict", "=", "torch", ".", "load", "(", "best_model_path", ")", "[", "'state_dict'", "]", "\n", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "\n", "test_metrics", "=", "evaluation", "(", "model", ",", "test_loader", ",", "device", ",", "config", ".", "classes", ",", "mode", "=", "'test'", ")", "\n", "\n", "print", "(", "f\"Test result for {config.experiment_name}: accuracy={test_metrics['accuracy']:.4f}, f1={test_metrics['macro_f1']:.4f}\"", ")", "\n", "print", "(", "test_metrics", "[", "'classification_report'", "]", ")", "\n", "\n", "save_results", "(", "test_metrics", ",", "config", ")", "\n", "\n", "", "overall_performance", "(", "config", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.get_num_trainable_params": [[120, 122], ["sum", "p.numel", "model.parameters"], "function", ["None"], ["", "def", "get_num_trainable_params", "(", "model", ")", ":", "\n", "    ", "return", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.get_dataset_size": [[123, 126], ["os.path.join", "len", "os.listdir", "name.endswith", "os.path.join"], "function", ["None"], ["", "def", "get_dataset_size", "(", "data_root", ",", "dataset", ")", ":", "\n", "    ", "dir", "=", "os", ".", "path", ".", "join", "(", "data_root", ",", "dataset", ")", "\n", "return", "len", "(", "[", "name", "for", "name", "in", "os", ".", "listdir", "(", "os", ".", "path", ".", "join", "(", "dir", ",", "'data'", ")", ")", "if", "name", ".", "endswith", "(", "'.zarr'", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.train_supervised": [[127, 183], ["model.to", "torch.optim.Adam", "torch.optim.Adam", "torchvision.transforms.transforms.Compose", "dataset.PixelSetData", "dataset.create_train_loader", "print", "utils.focal_loss.FocalLoss", "len", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "range", "model.parameters", "model.train", "utils.train_utils.AverageMeter", "tqdm.tqdm", "tqdm.tqdm.close", "model.eval", "evaluation.validation", "transforms.RandomSamplePixels", "transforms.RandomSampleTimeSteps", "transforms.Normalize", "transforms.ToTensor", "enumerate", "len", "sample[].cuda", "utils.train_utils.to_cuda", "model.forward", "utils.focal_loss.FocalLoss.", "torch.optim.Adam.zero_grad", "criterion.backward", "torch.optim.Adam.step", "torch.optim.lr_scheduler.CosineAnnealingLR.step", "utils.train_utils.AverageMeter.update", "transforms.RandomTemporalShift", "transforms.Identity", "len", "len", "len", "criterion.item", "tqdm.tqdm.set_postfix", "writer.add_scalar", "writer.add_scalar"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.create_train_loader", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update"], ["", "def", "train_supervised", "(", "model", ",", "config", ",", "writer", ",", "splits", ",", "val_loader", ",", "device", ",", "best_model_path", ")", ":", "\n", "    ", "model", ".", "to", "(", "device", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "config", ".", "lr", ",", "weight_decay", "=", "config", ".", "weight_decay", ")", "\n", "\n", "best_f1", "=", "0", "\n", "\n", "train_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", ",", "\n", "RandomTemporalShift", "(", "max_shift", "=", "config", ".", "max_shift_aug", ",", "p", "=", "config", ".", "shift_aug_p", ")", "if", "config", ".", "with_shift_aug", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", ")", "\n", "dataset_name", "=", "config", ".", "source", "\n", "if", "config", ".", "train_on_target", ":", "\n", "        ", "dataset_name", "=", "config", ".", "target", "\n", "\n", "", "dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "dataset_name", ",", "config", ".", "classes", ",", "train_transform", ",", "splits", "[", "dataset_name", "]", "[", "'train'", "]", ")", "\n", "data_loader", "=", "create_train_loader", "(", "dataset", ",", "config", ".", "batch_size", ",", "config", ".", "num_workers", ")", "\n", "print", "(", "f'training dataset: {dataset_name}, n={len(dataset)}, batches={len(data_loader)}'", ")", "\n", "\n", "criterion", "=", "FocalLoss", "(", "gamma", "=", "config", ".", "focal_loss_gamma", ")", "\n", "steps_per_epoch", "=", "len", "(", "data_loader", ")", "\n", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "optimizer", ",", "T_max", "=", "config", ".", "epochs", "*", "steps_per_epoch", ",", "eta_min", "=", "0", ")", "\n", "\n", "best_f1", "=", "0", "\n", "for", "epoch", "in", "range", "(", "config", ".", "epochs", ")", ":", "\n", "        ", "model", ".", "train", "(", ")", "\n", "loss_meter", "=", "AverageMeter", "(", ")", "\n", "\n", "progress_bar", "=", "tqdm", "(", "enumerate", "(", "data_loader", ")", ",", "total", "=", "len", "(", "data_loader", ")", ",", "desc", "=", "f'Epoch {epoch + 1}/{config.epochs}'", ")", "\n", "global_step", "=", "epoch", "*", "len", "(", "data_loader", ")", "\n", "for", "step", ",", "sample", "in", "progress_bar", ":", "\n", "            ", "targets", "=", "sample", "[", "'label'", "]", ".", "cuda", "(", "device", "=", "device", ",", "non_blocking", "=", "True", ")", "\n", "\n", "pixels", ",", "mask", ",", "positions", ",", "extra", "=", "to_cuda", "(", "sample", ",", "device", ")", "\n", "outputs", "=", "model", ".", "forward", "(", "pixels", ",", "mask", ",", "positions", ",", "extra", ")", "\n", "loss", "=", "criterion", "(", "outputs", ",", "targets", ")", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "scheduler", ".", "step", "(", ")", "\n", "\n", "loss_meter", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "n", "=", "config", ".", "batch_size", ")", "\n", "\n", "if", "step", "%", "config", ".", "log_step", "==", "0", ":", "\n", "                ", "lr", "=", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", "\n", "progress_bar", ".", "set_postfix", "(", "lr", "=", "f'{lr:.1E}'", ",", "loss", "=", "f\"{loss_meter.avg:.3f}\"", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/loss\"", ",", "loss_meter", ".", "val", ",", "global_step", "+", "step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/lr\"", ",", "lr", ",", "global_step", "+", "step", ")", "\n", "\n", "", "", "progress_bar", ".", "close", "(", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "best_f1", ",", "best_model_path", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "model", ",", "val_loader", ",", "writer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.create_train_val_test_folds": [[185, 210], ["range", "folds.append", "len", "int", "int", "random.shuffle", "set", "set", "set", "type", "list", "list", "set.intersection", "set", "range", "range", "len", "len", "len"], "function", ["None"], ["", "", "def", "create_train_val_test_folds", "(", "datasets", ",", "num_folds", ",", "num_indices", ",", "val_ratio", "=", "0.1", ",", "test_ratio", "=", "0.2", ")", ":", "\n", "    ", "folds", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_folds", ")", ":", "\n", "        ", "splits", "=", "{", "}", "\n", "for", "dataset", "in", "datasets", ":", "\n", "            ", "if", "type", "(", "num_indices", ")", "==", "dict", ":", "\n", "                ", "indices", "=", "list", "(", "range", "(", "num_indices", "[", "dataset", "]", ")", ")", "\n", "", "else", ":", "\n", "                ", "indices", "=", "list", "(", "range", "(", "num_indices", ")", ")", "\n", "", "n", "=", "len", "(", "indices", ")", "\n", "n_test", "=", "int", "(", "test_ratio", "*", "n", ")", "\n", "n_val", "=", "int", "(", "val_ratio", "*", "n", ")", "\n", "n_train", "=", "n", "-", "n_test", "-", "n_val", "\n", "\n", "random", ".", "shuffle", "(", "indices", ")", "\n", "\n", "train_indices", "=", "set", "(", "indices", "[", ":", "n_train", "]", ")", "\n", "val_indices", "=", "set", "(", "indices", "[", "n_train", ":", "n_train", "+", "n_val", "]", ")", "\n", "test_indices", "=", "set", "(", "indices", "[", "-", "n_test", ":", "]", ")", "\n", "assert", "set", ".", "intersection", "(", "train_indices", ",", "val_indices", ",", "test_indices", ")", "==", "set", "(", ")", "\n", "assert", "len", "(", "train_indices", ")", "+", "len", "(", "val_indices", ")", "+", "len", "(", "test_indices", ")", "==", "n", "\n", "\n", "splits", "[", "dataset", "]", "=", "{", "'train'", ":", "train_indices", ",", "'val'", ":", "val_indices", ",", "'test'", ":", "test_indices", "}", "\n", "", "folds", ".", "append", "(", "splits", ")", "\n", "", "return", "folds", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.save_results": [[212, 224], ["copy.deepcopy", "copy.deepcopy.pop", "copy.deepcopy.pop", "str().replace", "pickle.dump", "open", "json.dump", "open", "outfile.write", "open", "str", "os.path.join", "os.path.join", "str", "os.path.join"], "function", ["None"], ["", "def", "save_results", "(", "metrics", ",", "config", ")", ":", "\n", "    ", "out_dir", "=", "config", ".", "fold_dir", "\n", "metrics", "=", "deepcopy", "(", "metrics", ")", "\n", "conf_mat", "=", "metrics", ".", "pop", "(", "'confusion_matrix'", ")", "\n", "class_report", "=", "metrics", ".", "pop", "(", "'classification_report'", ")", "\n", "target_name", "=", "str", "(", "config", ".", "target", ")", ".", "replace", "(", "'/'", ",", "'_'", ")", "\n", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "f'test_metrics_{target_name}.json'", ")", ",", "'w'", ")", "as", "outfile", ":", "\n", "        ", "json", ".", "dump", "(", "metrics", ",", "outfile", ",", "indent", "=", "4", ")", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "f'class_report_{target_name}.txt'", ")", ",", "'w'", ")", "as", "outfile", ":", "\n", "        ", "outfile", ".", "write", "(", "str", "(", "class_report", ")", ")", "\n", "", "pkl", ".", "dump", "(", "conf_mat", ",", "open", "(", "os", ".", "path", ".", "join", "(", "out_dir", ",", "f'conf_mat_{target_name}.pkl'", ")", ",", "'wb'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.train.overall_performance": [[226, 254], ["collections.defaultdict", "str().replace", "range", "enumerate", "print", "print", "collections.defaultdict.items", "os.path.join", "json.load", "json.load.items", "pickle.load", "cms.append", "numpy.mean", "print", "utils.metrics.overall_classification_report", "numpy.array", "open", "file.write", "str", "open", "overall_metrics[].append", "open", "row.astype", "print", "print", "os.path.join", "json.dumps", "os.path.join", "os.path.join", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.overall_classification_report"], ["", "def", "overall_performance", "(", "config", ")", ":", "\n", "    ", "overall_metrics", "=", "defaultdict", "(", "list", ")", "\n", "target_name", "=", "str", "(", "config", ".", "target", ")", ".", "replace", "(", "\"/\"", ",", "\"_\"", ")", "\n", "\n", "cms", "=", "[", "]", "\n", "for", "fold", "in", "range", "(", "config", ".", "num_folds", ")", ":", "\n", "        ", "fold_dir", "=", "os", ".", "path", ".", "join", "(", "config", ".", "output_dir", ",", "f'fold_{fold}'", ")", "\n", "test_metrics", "=", "json", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "fold_dir", ",", "f'test_metrics_{target_name}.json'", ")", ")", ")", "\n", "for", "metric", ",", "value", "in", "test_metrics", ".", "items", "(", ")", ":", "\n", "            ", "overall_metrics", "[", "metric", "]", ".", "append", "(", "value", ")", "\n", "", "cm", "=", "pkl", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "fold_dir", ",", "f'conf_mat_{target_name}.pkl'", ")", ",", "'rb'", ")", ")", "\n", "cms", ".", "append", "(", "cm", ")", "\n", "\n", "", "for", "i", ",", "row", "in", "enumerate", "(", "np", ".", "mean", "(", "cms", ",", "axis", "=", "0", ")", ")", ":", "\n", "        ", "print", "(", "config", ".", "classes", "[", "i", "]", ",", "row", ".", "astype", "(", "int", ")", ")", "\n", "\n", "", "print", "(", "f'Overall result across {config.num_folds} folds:'", ")", "\n", "print", "(", "overall_classification_report", "(", "cms", ",", "config", ".", "classes", ")", ")", "\n", "for", "metric", ",", "values", "in", "overall_metrics", ".", "items", "(", ")", ":", "\n", "        ", "values", "=", "np", ".", "array", "(", "values", ")", "\n", "if", "metric", "==", "'loss'", ":", "\n", "            ", "print", "(", "f\"{metric}: {np.mean(values):.4}\u00b1{np.std(values):.4}\"", ")", "\n", "", "else", ":", "\n", "            ", "values", "*=", "100", "\n", "print", "(", "f\"{metric}: {np.mean(values):.1f}\u00b1{np.std(values):.1f}\"", ")", "\n", "\n", "", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "config", ".", "output_dir", ",", "f'overall_{target_name}.json'", ")", ",", "'w'", ")", "as", "file", ":", "\n", "        ", "file", ".", "write", "(", "json", ".", "dumps", "(", "overall_metrics", ",", "indent", "=", "4", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.__init__": [[25, 55], ["torch.utils.data.Dataset.__init__", "os.path.join", "os.path.join", "os.path.join", "dataset.PixelSetData.make_dataset", "dataset.PixelSetData.days_after", "numpy.arange", "dataset_name.split", "dataset_name.split", "len", "enumerate"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.make_dataset", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.days_after"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "data_root", ",", "\n", "dataset_name", ",", "\n", "classes", ",", "\n", "transform", "=", "None", ",", "\n", "indices", "=", "None", ",", "\n", "with_extra", "=", "False", ",", "\n", ")", ":", "\n", "        ", "super", "(", "PixelSetData", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "folder", "=", "os", ".", "path", ".", "join", "(", "data_root", ",", "dataset_name", ")", "\n", "self", ".", "dataset_name", "=", "dataset_name", "# country/tile/year", "\n", "self", ".", "country", "=", "dataset_name", ".", "split", "(", "\"/\"", ")", "[", "-", "3", "]", "\n", "self", ".", "tile", "=", "dataset_name", ".", "split", "(", "\"/\"", ")", "[", "-", "2", "]", "\n", "self", ".", "data_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "folder", ",", "\"data\"", ")", "\n", "self", ".", "meta_folder", "=", "os", ".", "path", ".", "join", "(", "self", ".", "folder", ",", "\"meta\"", ")", "\n", "self", ".", "transform", "=", "transform", "\n", "self", ".", "with_extra", "=", "with_extra", "\n", "\n", "self", ".", "classes", "=", "classes", "\n", "self", ".", "class_to_idx", "=", "{", "cls", ":", "idx", "for", "idx", ",", "cls", "in", "enumerate", "(", "classes", ")", "}", "\n", "\n", "self", ".", "samples", ",", "self", ".", "metadata", "=", "self", ".", "make_dataset", "(", "\n", "self", ".", "data_folder", ",", "self", ".", "meta_folder", ",", "self", ".", "class_to_idx", ",", "indices", ",", "self", ".", "country", "\n", ")", "\n", "\n", "self", ".", "dates", "=", "self", ".", "metadata", "[", "\"dates\"", "]", "\n", "self", ".", "date_positions", "=", "self", ".", "days_after", "(", "self", ".", "metadata", "[", "\"start_date\"", "]", ",", "self", ".", "dates", ")", "\n", "self", ".", "date_indices", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "date_positions", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_shapes": [[56, 60], ["len"], "methods", ["None"], ["", "def", "get_shapes", "(", "self", ")", ":", "\n", "        ", "return", "[", "\n", "(", "len", "(", "self", ".", "dates", ")", ",", "10", ",", "parcel", "[", "\"n_pixels\"", "]", ")", "\n", "for", "parcel", "in", "self", ".", "metadata", "[", "\"parcels\"", "]", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_labels": [[62, 64], ["numpy.array"], "methods", ["None"], ["", "def", "get_labels", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "x", "[", "2", "]", "for", "x", "in", "self", ".", "samples", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.__len__": [[65, 67], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.__getitem__": [[68, 87], ["zarr.load", "numpy.ones", "numpy.array", "numpy.array", "dataset.PixelSetData.transform"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "path", ",", "parcel_idx", ",", "y", ",", "extra", "=", "self", ".", "samples", "[", "index", "]", "\n", "pixels", "=", "zarr", ".", "load", "(", "path", ")", "# (T, C, S)", "\n", "\n", "sample", "=", "{", "\n", "\"index\"", ":", "index", ",", "\n", "\"parcel_index\"", ":", "parcel_idx", ",", "# mapping to metadata", "\n", "\"pixels\"", ":", "pixels", ",", "\n", "\"valid_pixels\"", ":", "np", ".", "ones", "(", "\n", "(", "pixels", ".", "shape", "[", "0", "]", ",", "pixels", ".", "shape", "[", "-", "1", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "\"positions\"", ":", "np", ".", "array", "(", "self", ".", "date_positions", ")", ",", "\n", "\"extra\"", ":", "np", ".", "array", "(", "extra", ")", ",", "\n", "\"label\"", ":", "y", ",", "\n", "}", "\n", "\n", "if", "self", ".", "transform", "is", "not", "None", ":", "\n", "            ", "sample", "=", "self", ".", "transform", "(", "sample", ")", "\n", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.make_dataset": [[88, 126], ["pickle.load", "utils.label_utils.get_code_to_class", "set", "enumerate", "open", "os.path.join", "utils.label_utils.get_code_to_class.get", "class_to_idx.get", "instances.append", "new_parcel_metadata.append", "print", "len", "len", "os.path.join", "int", "set.add"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_code_to_class", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get"], ["", "def", "make_dataset", "(", "self", ",", "data_folder", ",", "meta_folder", ",", "class_to_idx", ",", "indices", ",", "country", ")", ":", "\n", "        ", "metadata", "=", "pkl", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "meta_folder", ",", "\"metadata.pkl\"", ")", ",", "\"rb\"", ")", ")", "\n", "\n", "instances", "=", "[", "]", "\n", "new_parcel_metadata", "=", "[", "]", "\n", "\n", "code_to_class_name", "=", "label_utils", ".", "get_code_to_class", "(", "country", ")", "\n", "\n", "unknown_crop_codes", "=", "set", "(", ")", "\n", "\n", "for", "parcel_idx", ",", "parcel", "in", "enumerate", "(", "metadata", "[", "\"parcels\"", "]", ")", ":", "\n", "            ", "if", "indices", "is", "not", "None", ":", "\n", "                ", "if", "not", "parcel_idx", "in", "indices", ":", "\n", "                    ", "continue", "\n", "", "", "crop_code", "=", "parcel", "[", "\"label\"", "]", "\n", "if", "country", "==", "\"austria\"", ":", "\n", "                ", "crop_code", "=", "int", "(", "crop_code", ")", "\n", "", "parcel_path", "=", "os", ".", "path", ".", "join", "(", "data_folder", ",", "f\"{parcel_idx}.zarr\"", ")", "\n", "if", "crop_code", "not", "in", "code_to_class_name", ":", "\n", "                ", "unknown_crop_codes", ".", "add", "(", "crop_code", ")", "\n", "", "class_name", "=", "code_to_class_name", ".", "get", "(", "crop_code", ",", "\"unknown\"", ")", "\n", "class_index", "=", "class_to_idx", ".", "get", "(", "class_name", ",", "class_to_idx", "[", "\"unknown\"", "]", ")", "\n", "extra", "=", "parcel", "[", "'geometric_features'", "]", "\n", "\n", "item", "=", "(", "parcel_path", ",", "parcel_idx", ",", "class_index", ",", "extra", ")", "\n", "instances", ".", "append", "(", "item", ")", "\n", "new_parcel_metadata", ".", "append", "(", "parcel", ")", "\n", "\n", "", "for", "crop_code", "in", "unknown_crop_codes", ":", "\n", "            ", "print", "(", "\n", "f\"Parcels with crop code {crop_code} was not found in .yml class mapping and was assigned to unknown.\"", "\n", ")", "\n", "\n", "", "metadata", "[", "\"parcels\"", "]", "=", "new_parcel_metadata", "\n", "\n", "assert", "len", "(", "metadata", "[", "\"parcels\"", "]", ")", "==", "len", "(", "instances", ")", "\n", "\n", "return", "instances", ",", "metadata", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.days_after": [[127, 137], ["str", "abs", "dataset.PixelSetData.days_after.interval_days"], "methods", ["None"], ["", "def", "days_after", "(", "self", ",", "start_date", ",", "dates", ")", ":", "\n", "        ", "def", "parse", "(", "date", ")", ":", "\n", "            ", "d", "=", "str", "(", "date", ")", "\n", "return", "int", "(", "d", "[", ":", "4", "]", ")", ",", "int", "(", "d", "[", "4", ":", "6", "]", ")", ",", "int", "(", "d", "[", "6", ":", "]", ")", "\n", "\n", "", "def", "interval_days", "(", "date1", ",", "date2", ")", ":", "\n", "            ", "return", "abs", "(", "(", "dt", ".", "datetime", "(", "*", "parse", "(", "date1", ")", ")", "-", "dt", ".", "datetime", "(", "*", "parse", "(", "date2", ")", ")", ")", ".", "days", ")", "\n", "\n", "", "date_positions", "=", "[", "interval_days", "(", "d", ",", "start_date", ")", "for", "d", "in", "dates", "]", "\n", "return", "date_positions", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_unknown_labels": [[138, 183], ["collections.defaultdict", "collections.defaultdict", "utils.label_utils.get_code_to_class", "utils.label_utils.get_codification_table", "collections.defaultdict", "collections.defaultdict.items", "print", "collections.defaultdict.items", "reversed", "print", "sum", "print", "reversed", "sorted", "print", "collections.defaultdict.items", "int", "known[].append", "reversed.append", "sum", "len", "sorted", "print", "str"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_code_to_class", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_codification_table"], ["", "def", "get_unknown_labels", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Reports the categorization of crop codes for this dataset\n        \"\"\"", "\n", "class_count", "=", "defaultdict", "(", "int", ")", "\n", "class_parcel_size", "=", "defaultdict", "(", "float", ")", "\n", "# metadata = pkl.load(open(os.path.join(self.meta_folder, 'metadata.pkl'), 'rb'))", "\n", "metadata", "=", "self", ".", "metadata", "\n", "for", "meta", "in", "metadata", "[", "\"parcels\"", "]", ":", "\n", "            ", "class_count", "[", "meta", "[", "\"label\"", "]", "]", "+=", "1", "\n", "class_parcel_size", "[", "meta", "[", "\"label\"", "]", "]", "+=", "meta", "[", "\"n_pixels\"", "]", "\n", "\n", "", "class_avg_parcel_size", "=", "{", "\n", "cls", ":", "total_px", "/", "class_count", "[", "cls", "]", "\n", "for", "cls", ",", "total_px", "in", "class_parcel_size", ".", "items", "(", ")", "\n", "}", "\n", "\n", "code_to_class_name", "=", "label_utils", ".", "get_code_to_class", "(", "self", ".", "country", ")", "\n", "codification_table", "=", "label_utils", ".", "get_codification_table", "(", "self", ".", "country", ")", "\n", "unknown", "=", "[", "]", "\n", "known", "=", "defaultdict", "(", "list", ")", "\n", "for", "code", ",", "count", "in", "class_count", ".", "items", "(", ")", ":", "\n", "            ", "avg_pixels", "=", "class_avg_parcel_size", "[", "code", "]", "\n", "if", "self", ".", "country", "==", "\"denmark\"", ":", "\n", "                ", "code", "=", "int", "(", "code", ")", "\n", "", "code_name", "=", "codification_table", "[", "str", "(", "code", ")", "]", "\n", "if", "code", "in", "code_to_class_name", ":", "\n", "                ", "known", "[", "code_to_class_name", "[", "code", "]", "]", ".", "append", "(", "\n", "(", "code", ",", "code_name", ",", "count", ",", "avg_pixels", ")", "\n", ")", "\n", "", "else", ":", "\n", "                ", "unknown", ".", "append", "(", "(", "code", ",", "code_name", ",", "count", ",", "avg_pixels", ")", ")", "\n", "\n", "", "", "print", "(", "\"\\nCategorized crop codes:\"", ")", "\n", "for", "class_name", ",", "codes", "in", "known", ".", "items", "(", ")", ":", "\n", "            ", "total_parcels", "=", "sum", "(", "x", "[", "2", "]", "for", "x", "in", "codes", ")", "\n", "avg_parcel_size", "=", "sum", "(", "x", "[", "3", "]", "for", "x", "in", "codes", ")", "/", "len", "(", "codes", ")", "\n", "print", "(", "f\"{class_name} (n={total_parcels}, avg size={avg_parcel_size:.3f}):\"", ")", "\n", "codes", "=", "reversed", "(", "sorted", "(", "codes", ",", "key", "=", "lambda", "x", ":", "x", "[", "2", "]", ")", ")", "\n", "for", "code", ",", "code_name", ",", "count", ",", "avg_pixels", "in", "codes", ":", "\n", "                ", "print", "(", "f\"  {code}: {code_name} (n={count}, avg pixels={avg_pixels:.1f})\"", ")", "\n", "", "", "unknown", "=", "reversed", "(", "sorted", "(", "unknown", ",", "key", "=", "lambda", "x", ":", "x", "[", "2", "]", ")", ")", "\n", "print", "(", "\"\\nUncategorized crop codes:\"", ")", "\n", "for", "code", ",", "code_name", ",", "count", ",", "avg_pixels", "in", "unknown", ":", "\n", "            ", "print", "(", "f\"  {code}: {code_name} (n={count}, avg pixels={avg_pixels:.1f})\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.GroupByShapesBatchSampler.__init__": [[265, 325], ["isinstance", "collections.defaultdict", "enumerate", "collections.defaultdict.values", "data_source.get_shapes", "isinstance", "shp_to_indices[].append", "isinstance", "key.append", "key.append", "len", "batches.extend", "batches.append", "isinstance", "d.get_shapes", "tuple", "range", "d.get_shapes", "enumerate", "enumerate", "len", "data_source.dataset.get_shapes"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_shapes", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_shapes", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_shapes", "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_shapes"], ["def", "__init__", "(", "self", ",", "data_source", ",", "batch_size", ",", "by_time", "=", "True", ",", "by_pixel_dim", "=", "True", ")", ":", "\n", "        ", "self", ".", "batches", "=", "[", "]", "\n", "self", ".", "data_source", "=", "data_source", "\n", "\n", "datasets", ":", "List", "[", "PixelSetData", "]", "=", "[", "]", "\n", "# shapes[index] contains data_source[index] (seq_length, n_channels, n_pixels)", "\n", "if", "isinstance", "(", "data_source", ",", "PixelSetData", ")", ":", "\n", "            ", "datasets", "=", "[", "data_source", "]", "\n", "shapes", "=", "data_source", ".", "get_shapes", "(", ")", "\n", "", "elif", "isinstance", "(", "data_source", ",", "ConcatDataset", ")", ":", "\n", "            ", "datasets", "=", "data_source", ".", "datasets", "\n", "shapes", "=", "[", "shape", "for", "d", "in", "datasets", "for", "shape", "in", "d", ".", "get_shapes", "(", ")", "]", "\n", "", "elif", "isinstance", "(", "data_source", ",", "Subset", ")", ":", "\n", "            ", "datasets", "=", "[", "data_source", "]", "\n", "if", "isinstance", "(", "data_source", ".", "dataset", ",", "ConcatDataset", ")", ":", "\n", "                ", "shapes", "=", "[", "\n", "shape", "\n", "for", "d", "in", "data_source", ".", "dataset", ".", "datasets", "\n", "for", "shape", "in", "d", ".", "get_shapes", "(", ")", "\n", "]", "\n", "shapes", "=", "[", "\n", "shape", "\n", "for", "idx", ",", "shape", "in", "enumerate", "(", "shapes", ")", "\n", "if", "idx", "in", "data_source", ".", "indices", "\n", "]", "\n", "", "else", ":", "\n", "                ", "shapes", "=", "[", "\n", "shape", "\n", "for", "idx", ",", "shape", "in", "enumerate", "(", "data_source", ".", "dataset", ".", "get_shapes", "(", ")", ")", "\n", "if", "idx", "in", "data_source", ".", "indices", "\n", "]", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "# group indices by (seq_length, n_pixels)", "\n", "", "shp_to_indices", "=", "defaultdict", "(", "list", ")", "# unique shape -> sample indices", "\n", "for", "idx", ",", "shp", "in", "enumerate", "(", "shapes", ")", ":", "\n", "            ", "key", "=", "[", "]", "\n", "if", "by_time", ":", "\n", "                ", "key", ".", "append", "(", "shp", "[", "0", "]", ")", "\n", "", "if", "by_pixel_dim", ":", "\n", "                ", "key", ".", "append", "(", "shp", "[", "2", "]", ")", "\n", "", "shp_to_indices", "[", "tuple", "(", "key", ")", "]", ".", "append", "(", "idx", ")", "\n", "\n", "# create batches grouped by shape", "\n", "", "batches", "=", "[", "]", "\n", "for", "indices", "in", "shp_to_indices", ".", "values", "(", ")", ":", "\n", "            ", "if", "len", "(", "indices", ")", ">", "batch_size", ":", "\n", "                ", "batches", ".", "extend", "(", "\n", "[", "\n", "indices", "[", "i", ":", "i", "+", "batch_size", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "indices", ")", ",", "batch_size", ")", "\n", "]", "\n", ")", "\n", "", "else", ":", "\n", "                ", "batches", ".", "append", "(", "indices", ")", "\n", "\n", "", "", "self", ".", "batches", "=", "batches", "\n", "self", ".", "datasets", "=", "datasets", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "# self._unit_test()", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.GroupByShapesBatchSampler.__iter__": [[327, 330], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "batch", "in", "self", ".", "batches", ":", "\n", "            ", "yield", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.GroupByShapesBatchSampler.__len__": [[331, 333], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "batches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.GroupByShapesBatchSampler._unit_test": [[334, 347], ["all", "sum", "sum", "set", "set", "range", "len", "len", "sum", "len", "len"], "methods", ["None"], ["", "def", "_unit_test", "(", "self", ")", ":", "\n", "# make sure that we iterate across all items", "\n", "# 1) no duplicates", "\n", "        ", "assert", "sum", "(", "len", "(", "batch", ")", "for", "batch", "in", "self", ".", "batches", ")", "==", "sum", "(", "\n", "len", "(", "d", ")", "for", "d", "in", "self", ".", "datasets", "\n", ")", "\n", "# 2) all indices are present", "\n", "assert", "set", "(", "[", "idx", "for", "indices", "in", "self", ".", "batches", "for", "idx", "in", "indices", "]", ")", "==", "set", "(", "\n", "range", "(", "sum", "(", "len", "(", "d", ")", "for", "d", "in", "self", ".", "datasets", ")", ")", "\n", ")", "\n", "\n", "# make sure that no batch is larger than batch size", "\n", "assert", "all", "(", "len", "(", "batch", ")", "<=", "self", ".", "batch_size", "for", "batch", "in", "self", ".", "batches", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.BalancedBatchSampler.__init__": [[356, 378], ["sorted", "len", "len", "print", "set", "ValueError", "dataset.InfiniteSliceIterator", "ValueError", "numpy.where"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "labels", ",", "batch_size", ")", ":", "\n", "        ", "classes", "=", "sorted", "(", "set", "(", "labels", ")", ")", "\n", "n_classes", "=", "len", "(", "classes", ")", "\n", "self", ".", "_n_samples", "=", "batch_size", "//", "n_classes", "\n", "if", "self", ".", "_n_samples", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"batch_size should be bigger than the number of classes, got {batch_size}\"", "\n", ")", "\n", "\n", "", "self", ".", "_class_iters", "=", "[", "\n", "InfiniteSliceIterator", "(", "np", ".", "where", "(", "labels", "==", "class_", ")", "[", "0", "]", ",", "class_", "=", "class_", ")", "\n", "for", "class_", "in", "classes", "\n", "]", "\n", "\n", "batch_size", "=", "self", ".", "_n_samples", "*", "n_classes", "\n", "self", ".", "n_dataset", "=", "len", "(", "labels", ")", "\n", "self", ".", "_n_batches", "=", "self", ".", "n_dataset", "//", "batch_size", "\n", "if", "self", ".", "_n_batches", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Dataset is not big enough to generate batches with size {batch_size}\"", "\n", ")", "\n", "", "print", "(", "f\"using batch size={batch_size} for balanced batch sampler\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.BalancedBatchSampler.__iter__": [[379, 389], ["range", "numpy.random.shuffle", "class_iter.reset", "indices.extend", "class_iter.get"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "self", ".", "_n_batches", ")", ":", "\n", "            ", "indices", "=", "[", "]", "\n", "for", "class_iter", "in", "self", ".", "_class_iters", ":", "\n", "                ", "indices", ".", "extend", "(", "class_iter", ".", "get", "(", "self", ".", "_n_samples", ")", ")", "\n", "", "np", ".", "random", ".", "shuffle", "(", "indices", ")", "\n", "yield", "indices", "\n", "\n", "", "for", "class_iter", "in", "self", ".", "_class_iters", ":", "\n", "            ", "class_iter", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.BalancedBatchSampler.__len__": [[390, 392], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.InfiniteSliceIterator.__init__": [[395, 400], ["type"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "array", ",", "class_", ")", ":", "\n", "        ", "assert", "type", "(", "array", ")", "is", "np", ".", "ndarray", "\n", "self", ".", "array", "=", "array", "\n", "self", ".", "i", "=", "0", "\n", "self", ".", "class_", "=", "class_", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.InfiniteSliceIterator.reset": [[401, 403], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "i", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.InfiniteSliceIterator.get": [[404, 424], ["len", "print", "dataset.InfiniteSliceIterator.reset", "numpy.random.shuffle", "numpy.concatenate", "dataset.InfiniteSliceIterator.reset", "numpy.random.shuffle", "numpy.tile"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset"], ["", "def", "get", "(", "self", ",", "n", ")", ":", "\n", "        ", "len_", "=", "len", "(", "self", ".", "array", ")", "\n", "# not enough element in 'array'", "\n", "if", "len_", "<", "n", ":", "\n", "            ", "print", "(", "f\"there are really few items in class {self.class_}\"", ")", "\n", "self", ".", "reset", "(", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "self", ".", "array", ")", "\n", "mul", "=", "n", "//", "len_", "\n", "rest", "=", "n", "-", "mul", "*", "len_", "\n", "return", "np", ".", "concatenate", "(", "(", "np", ".", "tile", "(", "self", ".", "array", ",", "mul", ")", ",", "self", ".", "array", "[", ":", "rest", "]", ")", ")", "\n", "\n", "# not enough element in array's tail", "\n", "", "if", "len_", "-", "self", ".", "i", "<", "n", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "if", "self", ".", "i", "==", "0", ":", "\n", "            ", "np", ".", "random", ".", "shuffle", "(", "self", ".", "array", ")", "\n", "", "i", "=", "self", ".", "i", "\n", "self", ".", "i", "+=", "n", "\n", "return", "self", ".", "array", "[", "i", ":", "self", ".", "i", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.worker_init_fn": [[185, 187], ["numpy.random.seed", "numpy.random.get_state"], "function", ["None"], ["", "", "", "def", "worker_init_fn", "(", "worker_id", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "np", ".", "random", ".", "get_state", "(", ")", "[", "1", "]", "[", "0", "]", "+", "worker_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.create_train_loader": [[189, 198], ["torch.utils.data.DataLoader", "torch.cuda.is_available"], "function", ["None"], ["", "def", "create_train_loader", "(", "ds", ",", "batch_size", ",", "num_workers", ")", ":", "\n", "    ", "return", "DataLoader", "(", "\n", "dataset", "=", "ds", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "drop_last", "=", "True", ",", "\n", "pin_memory", "=", "torch", ".", "cuda", ".", "is_available", "(", ")", ",", "\n", "worker_init_fn", "=", "worker_init_fn", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.create_evaluation_loaders": [[201, 257], ["torchvision.transforms.transforms.Compose", "dataset.PixelSetData", "torch.utils.data.DataLoader", "torchvision.transforms.transforms.Compose", "dataset.PixelSetData", "torch.utils.data.DataLoader", "print", "print", "print", "transforms.Normalize", "transforms.ToTensor", "dataset.GroupByShapesBatchSampler", "transforms.Normalize", "transforms.ToTensor", "dataset.GroupByShapesBatchSampler", "transforms.RandomSamplePixels", "transforms.Identity", "transforms.RandomSampleTimeSteps", "transforms.Identity", "transforms.RandomSampleTimeSteps", "transforms.Identity", "len", "len", "len", "len"], "function", ["None"], ["", "def", "create_evaluation_loaders", "(", "dataset_name", ",", "splits", ",", "config", ",", "sample_pixels_val", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Create data loaders for unsupervised domain adaptation\n    \"\"\"", "\n", "\n", "is_tsnet", "=", "config", ".", "model", "==", "\"tsnet\"", "\n", "# Validation dataset", "\n", "val_transform", "=", "transforms", ".", "Compose", "(", "\n", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", "if", "sample_pixels_val", "else", "Identity", "(", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", "if", "is_tsnet", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", "\n", ")", "\n", "val_dataset", "=", "PixelSetData", "(", "\n", "config", ".", "data_root", ",", "\n", "dataset_name", ",", "\n", "config", ".", "classes", ",", "\n", "val_transform", ",", "\n", "indices", "=", "splits", "[", "dataset_name", "]", "[", "\"val\"", "]", ",", "\n", ")", "\n", "val_loader", "=", "data", ".", "DataLoader", "(", "\n", "val_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "batch_sampler", "=", "GroupByShapesBatchSampler", "(", "\n", "val_dataset", ",", "config", ".", "batch_size", ",", "by_pixel_dim", "=", "not", "sample_pixels_val", "\n", ")", ",", "\n", ")", "\n", "\n", "# Test dataset", "\n", "test_transform", "=", "transforms", ".", "Compose", "(", "\n", "[", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", "if", "is_tsnet", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", "\n", ")", "\n", "test_dataset", "=", "PixelSetData", "(", "\n", "config", ".", "data_root", ",", "\n", "dataset_name", ",", "\n", "config", ".", "classes", ",", "\n", "test_transform", ",", "\n", "indices", "=", "splits", "[", "dataset_name", "]", "[", "\"test\"", "]", ",", "\n", ")", "\n", "test_loader", "=", "data", ".", "DataLoader", "(", "\n", "test_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "batch_sampler", "=", "GroupByShapesBatchSampler", "(", "test_dataset", ",", "config", ".", "batch_size", ")", ",", "\n", ")", "\n", "\n", "print", "(", "f\"evaluation dataset:\"", ",", "dataset_name", ")", "\n", "print", "(", "f\"val target data: {len(val_dataset)} ({len(val_loader)} batches)\"", ")", "\n", "print", "(", "f\"test taget data: {len(test_dataset)} ({len(test_loader)} batches)\"", ")", "\n", "\n", "return", "val_loader", ",", "test_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation": [[11, 28], ["evaluation.evaluation", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "print", "print", "print", "print", "torch.save", "torch.save", "torch.save", "model.state_dict"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.evaluation"], ["def", "validation", "(", "best_f1", ",", "best_model_path", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "model", ",", "val_loader", ",", "writer", ",", "temporal_shift", "=", "None", ")", ":", "\n", "    ", "val_metrics", "=", "evaluation", "(", "model", ",", "val_loader", ",", "device", ",", "config", ".", "classes", ",", "criterion", ",", "mode", "=", "'val'", ",", "temporal_shift", "=", "temporal_shift", ")", "\n", "val_loss", ",", "val_acc", ",", "val_f1", ",", "val_kappa", "=", "val_metrics", "[", "'loss'", "]", ",", "val_metrics", "[", "'accuracy'", "]", ",", "val_metrics", "[", "'macro_f1'", "]", ",", "val_metrics", "[", "'kappa'", "]", "\n", "writer", ".", "add_scalar", "(", "'val/loss'", ",", "val_loss", ",", "global_step", "=", "epoch", ")", "\n", "writer", ".", "add_scalar", "(", "'val/accuracy'", ",", "val_acc", ",", "global_step", "=", "epoch", ")", "\n", "writer", ".", "add_scalar", "(", "'val/f1'", ",", "val_f1", ",", "global_step", "=", "epoch", ")", "\n", "writer", ".", "add_scalar", "(", "'val/kappa'", ",", "val_kappa", ",", "global_step", "=", "epoch", ")", "\n", "print", "(", "f\"Validation result: loss={val_loss:.4f}, acc={val_acc:.2f}, f1={val_f1:.4f}\"", ")", "\n", "if", "val_f1", ">", "best_f1", ":", "\n", "        ", "print", "(", "f'Validation F1 improved from {best_f1:.4f} to {val_f1:.4f}!'", ")", "\n", "best_f1", "=", "val_f1", "\n", "if", "best_model_path", "is", "not", "None", ":", "\n", "            ", "print", "(", "f'Saving best model to {best_model_path}'", ")", "\n", "torch", ".", "save", "(", "{", "'epoch'", ":", "epoch", ",", "'state_dict'", ":", "model", ".", "state_dict", "(", ")", ",", "'best_f1'", ":", "best_f1", "}", ",", "best_model_path", ")", "\n", "", "", "else", ":", "\n", "        ", "print", "(", "f'Validation F1 did not improve from {best_f1:.4f}.'", ")", "\n", "", "return", "best_f1", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.evaluation": [[30, 68], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "utils.train_utils.AverageMeter", "model.eval", "tqdm.tqdm", "y_true.extend", "target.cuda.cuda", "utils.train_utils.to_cuda", "model.forward.argmax", "y_pred.extend", "numpy.array", "numpy.array", "sklearn.metrics.accuracy_score", "sklearn.metrics.f1_score", "sklearn.metrics.f1_score", "sklearn.metrics.cohen_kappa_score", "sklearn.metrics.classification_report", "sklearn.metrics.confusion_matrix", "target.cuda.tolist", "model.forward", "model.forward", "criterion", "utils.train_utils.AverageMeter.update", "logits.argmax.tolist", "criterion.item", "list", "list", "list", "pixels.size", "range", "range", "range", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.f1_score", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.f1_score", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.classification_report", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "evaluation", "(", "model", ",", "data_loader", ",", "device", ",", "class_names", ",", "criterion", "=", "None", ",", "mode", "=", "'val'", ",", "temporal_shift", "=", "None", ")", ":", "\n", "    ", "y_true", ",", "y_pred", "=", "[", "]", ",", "[", "]", "\n", "\n", "loss_meter", "=", "AverageMeter", "(", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "for", "sample", "in", "tqdm", "(", "data_loader", ",", "desc", "=", "'Validating'", "if", "mode", "==", "'val'", "else", "'Testing'", ")", ":", "\n", "        ", "target", "=", "sample", "[", "'label'", "]", "\n", "y_true", ".", "extend", "(", "target", ".", "tolist", "(", ")", ")", "\n", "target", "=", "target", ".", "cuda", "(", "device", "=", "device", ",", "non_blocking", "=", "True", ")", "\n", "\n", "pixels", ",", "valid_pixels", ",", "positions", ",", "extra", "=", "to_cuda", "(", "sample", ",", "device", ")", "\n", "if", "temporal_shift", "is", "not", "None", ":", "\n", "            ", "logits", "=", "model", ".", "forward", "(", "pixels", ",", "valid_pixels", ",", "positions", "+", "temporal_shift", ",", "extra", ")", "\n", "", "else", ":", "\n", "            ", "logits", "=", "model", ".", "forward", "(", "pixels", ",", "valid_pixels", ",", "positions", ",", "extra", ")", "\n", "\n", "", "predictions", "=", "logits", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "\n", "if", "criterion", "is", "not", "None", ":", "\n", "            ", "loss", "=", "criterion", "(", "logits", ",", "target", ")", "\n", "loss_meter", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "n", "=", "pixels", ".", "size", "(", "0", ")", ")", "\n", "", "y_pred", ".", "extend", "(", "predictions", ".", "tolist", "(", ")", ")", "\n", "\n", "", "y_true", ",", "y_pred", "=", "np", ".", "array", "(", "y_true", ")", ",", "np", ".", "array", "(", "y_pred", ")", "\n", "\n", "metrics", "=", "{", "\n", "'accuracy'", ":", "sklearn", ".", "metrics", ".", "accuracy_score", "(", "y_true", ",", "y_pred", ")", ",", "\n", "'loss'", ":", "loss_meter", ".", "avg", ",", "\n", "'macro_f1'", ":", "sklearn", ".", "metrics", ".", "f1_score", "(", "y_true", ",", "y_pred", ",", "average", "=", "'macro'", ",", "zero_division", "=", "0", ")", ",", "\n", "'weighted_f1'", ":", "sklearn", ".", "metrics", ".", "f1_score", "(", "y_true", ",", "y_pred", ",", "average", "=", "'weighted'", ",", "zero_division", "=", "0", ")", ",", "\n", "'kappa'", ":", "sklearn", ".", "metrics", ".", "cohen_kappa_score", "(", "y_true", ",", "y_pred", ",", "labels", "=", "list", "(", "range", "(", "len", "(", "class_names", ")", ")", ")", ")", ",", "\n", "'classification_report'", ":", "sklearn", ".", "metrics", ".", "classification_report", "(", "y_true", ",", "y_pred", ",", "labels", "=", "list", "(", "range", "(", "len", "(", "class_names", ")", ")", ")", ",", "target_names", "=", "class_names", ",", "zero_division", "=", "0", ")", ",", "\n", "'confusion_matrix'", ":", "sklearn", ".", "metrics", ".", "confusion_matrix", "(", "y_true", ",", "y_pred", ",", "labels", "=", "list", "(", "range", "(", "len", "(", "class_names", ")", ")", ")", ")", ",", "\n", "}", "\n", "\n", "return", "metrics", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.S2Image.__init__": [[21, 38], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "yyyymmdd", ",", "cloudy_pct", ",", "coverage", ",", "aws_path", ",", "local_path", ",", "data_collection", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "yyyymmdd", "=", "yyyymmdd", "\n", "self", ".", "cloudy_pct", "=", "cloudy_pct", "\n", "self", ".", "coverage", "=", "coverage", "\n", "self", ".", "aws_path", "=", "aws_path", "\n", "self", ".", "local_path", "=", "local_path", "\n", "if", "data_collection", "==", "'l1c'", ":", "\n", "            ", "self", ".", "bands_10m", "=", "[", "local_path", "/", "\"{}.jp2\"", ".", "format", "(", "x", ")", "for", "x", "in", "[", "'B02'", ",", "'B03'", ",", "'B04'", ",", "'B08'", "]", "]", "\n", "self", ".", "bands_20m", "=", "[", "local_path", "/", "\"{}.jp2\"", ".", "format", "(", "x", ")", "for", "x", "in", "[", "'B05'", ",", "'B06'", ",", "'B07'", ",", "'B8A'", ",", "'B11'", ",", "'B12'", "]", "]", "\n", "self", ".", "bands_60m", "=", "[", "local_path", "/", "\"{}.jp2\"", ".", "format", "(", "x", ")", "for", "x", "in", "[", "'B01'", ",", "'B09'", ",", "'B10'", "]", "]", "\n", "self", ".", "cloud_mask", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "bands_10m", "=", "[", "local_path", "/", "'R10m'", "/", "\"{}.jp2\"", ".", "format", "(", "x", ")", "for", "x", "in", "[", "'B02'", ",", "'B03'", ",", "'B04'", ",", "'B08'", "]", "]", "\n", "self", ".", "bands_20m", "=", "[", "local_path", "/", "'R20m'", "/", "\"{}.jp2\"", ".", "format", "(", "x", ")", "for", "x", "in", "[", "'B05'", ",", "'B06'", ",", "'B07'", ",", "'B8A'", ",", "'B11'", ",", "'B12'", "]", "]", "\n", "self", ".", "bands_60m", "=", "[", "local_path", "/", "'R60m'", "/", "\"{}.jp2\"", ".", "format", "(", "x", ")", "for", "x", "in", "[", "'B01'", ",", "'B09'", ",", "'B10'", "]", "]", "\n", "self", ".", "cloud_mask", "=", "local_path", "/", "'qi'", "/", "'MSK_CLOUDS_B00.gml'", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.S2Image.get_date": [[40, 42], ["datetime.datetime.datetime.strptime"], "methods", ["None"], ["", "", "def", "get_date", "(", "self", ")", ":", "\n", "        ", "return", "datetime", ".", "strptime", "(", "self", ".", "yyyymmdd", ",", "'%Y%m%d'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.S2Image.__repr__": [[43, 45], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "f\"S2Image(tile={self.name}, date={self.yyyymmdd}, clouds={self.cloudy_pct}, coverage={self.coverage})\"", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.s2_download": [[47, 102], ["os.path.exists", "print", "len", "list", "list", "print", "os.path.join", "os.makedirs", "os.listdir", "print", "type", "tuple", "date_start.date", "date_end.date", "downloader.get_available_s2_images", "sorted", "filter", "filter", "len", "print", "len", "input", "tqdm.tqdm", "map", "open", "pickle.load", "open", "pickle.dump", "len", "date_start.date", "date_end.date", "len", "len", "len", "date_start.date", "date_end.date", "os.path.exists", "os.makedirs", "downloader.download_previews", "print", "downloader.download_tile", "len", "x.get_date"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.get_available_s2_images", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.download_previews", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.download_tile", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.S2Image.get_date"], ["", "", "def", "s2_download", "(", "tile_name", ",", "date_start", ",", "date_end", ",", "download_dir", ",", "min_coverage", "=", "100.0", ",", "max_cloudy_pct", "=", "100.0", ",", "\n", "previews", "=", "False", ",", "sort_by_date", "=", "True", ",", "bands", "=", "None", ",", "data_collection", "=", "'l1c'", ")", ":", "\n", "    ", "if", "type", "(", "date_start", ")", "==", "str", ":", "\n", "        ", "date_start", ",", "date_end", "=", "tuple", "(", "map", "(", "_yyyymmdd_to_date", ",", "(", "date_start", ",", "date_end", ")", ")", ")", "\n", "\n", "", "assert", "data_collection", "in", "[", "'l1c'", ",", "'l2a'", "]", "\n", "\n", "if", "bands", "is", "None", ":", "\n", "        ", "if", "data_collection", "==", "'l1c'", ":", "\n", "            ", "bands", "=", "[", "'B02'", ",", "'B03'", ",", "'B04'", ",", "'B05'", ",", "'B06'", ",", "'B07'", ",", "'B08'", ",", "'B8A'", ",", "'B11'", ",", "'B12'", "]", "\n", "", "else", ":", "\n", "            ", "bands", "=", "[", "'R10m/B02'", ",", "'R10m/B03'", ",", "'R10m/B04'", ",", "'R20m/B05'", ",", "'R20m/B06'", ",", "'R20m/B07'", ",", "'R10m/B08'", ",", "'R20m/B8A'", ",", "'R20m/B11'", ",", "'R20m/B12'", "]", "\n", "\n", "", "", "cache_file", "=", "\"/tmp/{}_{}_{}_{}.pkl\"", ".", "format", "(", "data_collection", ",", "tile_name", ",", "date_start", ".", "date", "(", ")", ",", "date_end", ".", "date", "(", ")", ")", "\n", "if", "os", ".", "path", ".", "exists", "(", "cache_file", ")", ":", "\n", "        ", "with", "open", "(", "cache_file", ",", "'rb'", ")", "as", "f", ":", "\n", "            ", "s2_images", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "        ", "s2_images", "=", "get_available_s2_images", "(", "tile_name", ",", "(", "date_start", ",", "date_end", ")", ",", "download_dir", ",", "data_collection", ")", "\n", "with", "open", "(", "cache_file", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "s2_images", ",", "f", ")", "\n", "\n", "", "", "print", "(", "\"Found {} images from tile {} between {} and {}\"", ".", "format", "(", "len", "(", "s2_images", ")", ",", "tile_name", ",", "date_start", ".", "date", "(", ")", ",", "\n", "date_end", ".", "date", "(", ")", ")", ")", "\n", "n_before_filter", "=", "len", "(", "s2_images", ")", "\n", "if", "sort_by_date", ":", "\n", "        ", "s2_images", "=", "sorted", "(", "s2_images", ",", "key", "=", "lambda", "x", ":", "x", ".", "get_date", "(", ")", ")", "\n", "", "s2_images", "=", "list", "(", "filter", "(", "lambda", "x", ":", "x", ".", "coverage", ">=", "min_coverage", ",", "s2_images", ")", ")", "\n", "s2_images", "=", "list", "(", "filter", "(", "lambda", "x", ":", "x", ".", "cloudy_pct", "<=", "max_cloudy_pct", ",", "s2_images", ")", ")", "\n", "print", "(", "\"Number of images with coverage >= {} and cloudy pct. <= {}: {}/{}\"", ".", "format", "(", "min_coverage", ",", "max_cloudy_pct", ",", "\n", "len", "(", "s2_images", ")", ",", "\n", "n_before_filter", ")", ")", "\n", "\n", "tile_dir", "=", "os", ".", "path", ".", "join", "(", "download_dir", ",", "tile_name", ")", "\n", "os", ".", "makedirs", "(", "tile_dir", ",", "exist_ok", "=", "True", ")", "\n", "existing", "=", "os", ".", "listdir", "(", "tile_dir", ")", "\n", "not_downloaded", "=", "[", "x", "for", "x", "in", "s2_images", "if", "x", ".", "local_path", ".", "parts", "[", "-", "1", "]", "not", "in", "existing", "]", "\n", "print", "(", "\"Number of images not downloaded: {}/{}\"", ".", "format", "(", "len", "(", "not_downloaded", ")", ",", "len", "(", "s2_images", ")", ")", ")", "\n", "if", "len", "(", "not_downloaded", ")", ">", "0", ":", "\n", "        ", "print", "(", "not_downloaded", ")", "\n", "\n", "", "if", "previews", ":", "\n", "        ", "preview_folder", "=", "\"data/previews_{}_{}_{}\"", ".", "format", "(", "tile_name", ",", "date_start", ".", "date", "(", ")", ",", "date_end", ".", "date", "(", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "preview_folder", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "preview_folder", ")", "\n", "download_previews", "(", "s2_images", ",", "preview_folder", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'Preview folder {} already exists, skipping'", ".", "format", "(", "preview_folder", ")", ")", "\n", "\n", "", "", "if", "len", "(", "not_downloaded", ")", "!=", "0", ":", "\n", "        ", "input", "(", "\"Will download {} S2 images. OK?\"", ".", "format", "(", "len", "(", "not_downloaded", ")", ")", ")", "\n", "for", "s2_tile", "in", "tqdm", "(", "not_downloaded", ",", "'Downloading S2 tiles'", ")", ":", "\n", "            ", "download_tile", "(", "s2_tile", ",", "data_folder", "=", "tile_dir", ",", "bands", "=", "bands", ",", "data_collection", "=", "data_collection", ")", "\n", "\n", "", "", "return", "s2_images", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader._yyyymmdd_to_date": [[104, 106], ["datetime.datetime.strptime"], "function", ["None"], ["", "def", "_yyyymmdd_to_date", "(", "yyyymmdd", ")", ":", "\n", "    ", "return", "datetime", ".", "strptime", "(", "yyyymmdd", ",", "\"%Y%m%d\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.download_previews": [[108, 119], ["boto3.client", "tqdm.tqdm", "os.path.join", "int", "os.path.exists", "boto3.client.download_file", "print"], "function", ["None"], ["", "def", "download_previews", "(", "s2_images", ":", "List", "[", "S2Image", "]", ",", "preview_folder", ")", ":", "\n", "    ", "s3", "=", "boto3", ".", "client", "(", "'s3'", ")", "\n", "for", "s2_tile", "in", "tqdm", "(", "s2_images", ",", "desc", "=", "'downloading previews'", ")", ":", "\n", "        ", "key", "=", "s2_tile", ".", "aws_path", "+", "'/preview.jpg'", "\n", "file_name", "=", "\"{}_{}pct.jpg\"", ".", "format", "(", "s2_tile", ".", "yyyymmdd", ",", "int", "(", "s2_tile", ".", "cloudy_pct", ")", ")", "\n", "file_name", "=", "os", ".", "path", ".", "join", "(", "preview_folder", ",", "file_name", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "file_name", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "s3", ".", "download_file", "(", "'sentinel-s2-l1c'", ",", "key", ",", "file_name", ",", "ExtraArgs", "=", "{", "'RequestPayer'", ":", "'requester'", "}", ")", "\n", "", "except", "Exception", ":", "\n", "                ", "print", "(", "'preview not found'", ",", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.download_tile": [[121, 137], ["sentinelhub.AwsTileRequest", "sentinelhub.AwsTileRequest.save_data"], "function", ["None"], ["", "", "", "", "def", "download_tile", "(", "s2_tile", ":", "S2Image", ",", "data_folder", ",", "bands", "=", "None", ",", "data_collection", "=", "'l1c'", ")", ":", "\n", "    ", "data_collection", "=", "DataCollection", ".", "SENTINEL2_L1C", "if", "data_collection", "==", "'l1c'", "else", "DataCollection", ".", "SENTINEL2_L2A", "\n", "if", "data_collection", "==", "DataCollection", ".", "SENTINEL2_L1C", ":", "\n", "        ", "metafiles", "=", "[", "'metadata'", ",", "'tileInfo'", "]", "\n", "", "else", ":", "\n", "        ", "metafiles", "=", "[", "'metadata'", ",", "'tileInfo'", ",", "'qi/MSK_CLOUDS_B00'", "]", "# also download cloud masks for L2A data", "\n", "", "req", "=", "sentinelhub", ".", "AwsTileRequest", "(", "\n", "tile", "=", "s2_tile", ".", "name", ",", "\n", "time", "=", "s2_tile", ".", "yyyymmdd", ",", "\n", "aws_index", "=", "0", ",", "\n", "data_folder", "=", "data_folder", ",", "\n", "metafiles", "=", "metafiles", ",", "\n", "bands", "=", "bands", ",", "\n", "data_collection", "=", "data_collection", ",", "\n", ")", "\n", "req", ".", "save_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.get_available_s2_images": [[139, 167], ["tqdm.tqdm", "requests.get().json", "dateutil.rrule.rrule", "requests.get().json", "downloader.get_date_from_prefix", "str", "str", "requests.get", "downloader._yyyymmdd_to_date", "result.append", "requests.get", "date_prefix.replace", "downloader.S2Image", "print", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.get_date_from_prefix", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader._yyyymmdd_to_date", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get"], ["", "def", "get_available_s2_images", "(", "tile_name", ",", "date_interval", ",", "download_dir", ",", "data_collection", ")", ":", "\n", "# api = L1C_API if data_collection == DataCollection.SENTINEL2_L1C else L2A_API", "\n", "    ", "api", "=", "L1C_API", "# use l1c api for l2a data as l2a cloudy percentage is buggy", "\n", "start_date", ",", "end_date", "=", "date_interval", "\n", "months_between", "=", "[", "x", "for", "x", "in", "rrule", "(", "MONTHLY", ",", "dtstart", "=", "start_date", ",", "until", "=", "end_date", ")", "]", "\n", "result", "=", "[", "]", "\n", "for", "dt", "in", "tqdm", "(", "months_between", ",", "desc", "=", "f'Browsing S2 {data_collection} inventory for available images'", ")", ":", "\n", "        ", "tile_path", "=", "\"{}/{}/{}\"", ".", "format", "(", "tile_name", "[", ":", "2", "]", ",", "tile_name", "[", "2", "]", ",", "tile_name", "[", "3", ":", "]", ")", "\n", "url", "=", "\"/\"", ".", "join", "(", "[", "api", ",", "\"tiles\"", ",", "tile_path", ",", "str", "(", "dt", ".", "year", ")", ",", "str", "(", "dt", ".", "month", ")", ",", "\"\"", "]", ")", "\n", "js", "=", "requests", ".", "get", "(", "url", ")", ".", "json", "(", ")", "\n", "date_prefixes", "=", "[", "api", "+", "\"/\"", "+", "x", "[", "'Prefix'", "]", "for", "x", "in", "js", "[", "'CommonPrefixes'", "]", "]", "\n", "for", "date_prefix", "in", "date_prefixes", ":", "\n", "            ", "tileinfo", "=", "requests", ".", "get", "(", "date_prefix", "+", "\"0/tileInfo.json\"", ")", ".", "json", "(", ")", "\n", "aws_path", "=", "date_prefix", ".", "replace", "(", "api", ",", "\"\"", ")", "[", "1", ":", "]", "+", "'0'", "\n", "date", "=", "get_date_from_prefix", "(", "date_prefix", ")", "\n", "if", "start_date", "<=", "_yyyymmdd_to_date", "(", "date", ")", "<=", "end_date", ":", "\n", "                ", "try", ":", "\n", "                    ", "cloudy_pct", "=", "tileinfo", "[", "'cloudyPixelPercentage'", "]", "\n", "coverage", "=", "tileinfo", "[", "'dataCoveragePercentage'", "]", "\n", "", "except", "KeyError", "as", "e", ":", "\n", "                    ", "print", "(", "e", ")", "\n", "continue", "\n", "\n", "", "local_path", "=", "Path", "(", "download_dir", ")", "/", "tile_name", "/", "\"{},{}-{}-{},0\"", ".", "format", "(", "tile_name", ",", "date", "[", ":", "4", "]", ",", "date", "[", "4", ":", "6", "]", ",", "\n", "date", "[", "6", ":", "]", ")", "\n", "result", ".", "append", "(", "S2Image", "(", "tile_name", ",", "date", ",", "cloudy_pct", ",", "coverage", ",", "aws_path", ",", "local_path", ",", "data_collection", ")", ")", "\n", "\n", "", "", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.get_date_from_prefix": [[169, 176], ["prefix.split", "list", "filter", "len", "len"], "function", ["None"], ["", "def", "get_date_from_prefix", "(", "prefix", ")", ":", "\n", "    ", "parts", "=", "prefix", ".", "split", "(", "'/'", ")", "\n", "parts", "=", "list", "(", "filter", "(", "None", ",", "parts", ")", ")", "\n", "yyyy", "=", "parts", "[", "-", "3", "]", "\n", "mm", "=", "\"0\"", "+", "parts", "[", "-", "2", "]", "if", "len", "(", "parts", "[", "-", "2", "]", ")", "==", "1", "else", "parts", "[", "-", "2", "]", "\n", "dd", "=", "\"0\"", "+", "parts", "[", "-", "1", "]", "if", "len", "(", "parts", "[", "-", "1", "]", ")", "==", "1", "else", "parts", "[", "-", "1", "]", "\n", "return", "yyyy", "+", "mm", "+", "dd", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.prepare_pixels": [[26, 97], ["preprocessing.downloader.s2_download", "prepare_pixels.create_blocks", "prepare_pixels.get_ground_truth_parcels", "prepare_pixels.compute_bboxes_and_masks", "print", "parcels.reset_index.reset_index", "prepare_pixels.write_metadata", "print", "range", "tqdm.tqdm", "rasterio.open", "rasterio.open", "rasterio.open", "geopandas.GeoSeries", "mask.sum().astype", "len", "len", "len", "len", "int", "len", "str", "len", "zarr.open", "zarr_files.append", "range", "numpy.stack", "tqdm.tqdm", "shapely.geometry.box", "enumerate", "len", "len", "range", "mask.sum", "len", "len", "prepare_pixels.read_s2_image", "len", "tqdm.tqdm"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.downloader.s2_download", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.create_blocks", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.get_ground_truth_parcels", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.compute_bboxes_and_masks", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.write_metadata", "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.read_s2_image"], ["def", "prepare_pixels", "(", "config", ")", ":", "\n", "    ", "s2_images", ":", "List", "[", "S2Image", "]", "=", "s2_download", "(", "\n", "config", ".", "tile", ",", "\n", "config", ".", "start_date", ",", "\n", "config", ".", "end_date", ",", "\n", "config", ".", "download_dir", ",", "\n", "min_coverage", "=", "config", ".", "min_coverage", ",", "\n", "max_cloudy_pct", "=", "config", ".", "max_cloudy_percentage", ",", "\n", "sort_by_date", "=", "True", ",", "\n", "bands", "=", "config", ".", "bands", ",", "\n", "data_collection", "=", "config", ".", "data_collection", ",", "\n", "# previews=True,", "\n", ")", "\n", "# Load bounding box and transform information for chosen S2 tile", "\n", "with", "rasterio", ".", "open", "(", "s2_images", "[", "0", "]", ".", "bands_10m", "[", "0", "]", ")", "as", "f", ":", "\n", "        ", "tile_bbox", "=", "gpd", ".", "GeoSeries", "(", "box", "(", "*", "f", ".", "bounds", ")", ")", "\n", "tile_bbox", ".", "crs", "=", "f", ".", "crs", "\n", "tile_transform", "=", "f", ".", "transform", "\n", "tile_crs", "=", "f", ".", "crs", "\n", "\n", "", "cloudy_percentages", "=", "[", "s2_image", ".", "cloudy_pct", "for", "s2_image", "in", "s2_images", "]", "\n", "\n", "# Group parcels by spatial blocks to ensure independence across years", "\n", "blocks", "=", "create_blocks", "(", "tile_bbox", ",", "config", ")", "\n", "\n", "# Load parcels from shapefile", "\n", "parcels", "=", "get_ground_truth_parcels", "(", "tile_bbox", ",", "config", ",", "blocks", ")", "\n", "# top_100_labels(parcels, config)", "\n", "\n", "# Create bounding boxes and masks for each parcel", "\n", "bboxes", ",", "masks", "=", "compute_bboxes_and_masks", "(", "parcels", ",", "tile_transform", ")", "\n", "n_pixels", "=", "[", "mask", ".", "sum", "(", ")", ".", "astype", "(", "np", ".", "int32", ")", "for", "mask", "in", "masks", "]", "\n", "\n", "# Remove polygons with 0 pixels, if any", "\n", "valid_indices", "=", "[", "idx", "for", "idx", ",", "S", "in", "enumerate", "(", "n_pixels", ")", "if", "S", "!=", "0", "]", "\n", "print", "(", "f'Remaining parcels after removing parcels with no pixels: {len(valid_indices)}/{len(masks)}'", ")", "\n", "parcels", "=", "parcels", ".", "iloc", "[", "valid_indices", "]", "\n", "parcels", "=", "parcels", ".", "reset_index", "(", ")", "\n", "bboxes", "=", "[", "bboxes", "[", "i", "]", "for", "i", "in", "valid_indices", "]", "\n", "masks", "=", "[", "masks", "[", "i", "]", "for", "i", "in", "valid_indices", "]", "\n", "n_pixels", "=", "[", "n_pixels", "[", "i", "]", "for", "i", "in", "valid_indices", "]", "\n", "assert", "len", "(", "parcels", ")", "==", "len", "(", "bboxes", ")", "==", "len", "(", "masks", ")", "==", "len", "(", "n_pixels", ")", "\n", "\n", "# Write various metadata", "\n", "dates", "=", "[", "int", "(", "tile", ".", "yyyymmdd", ")", "for", "tile", "in", "s2_images", "]", "\n", "write_metadata", "(", "parcels", ",", "bboxes", ",", "masks", ",", "dates", ",", "n_pixels", ",", "config", ",", "tile_transform", ",", "tile_crs", ",", "cloudy_percentages", ")", "\n", "\n", "# Setup zarr files", "\n", "print", "(", "'Initializing .zarr files...'", ")", "\n", "zarr_files", "=", "[", "]", "\n", "is_l2a", "=", "config", ".", "data_collection", "==", "'l2a'", "\n", "for", "parcel_idx", "in", "range", "(", "len", "(", "parcels", ")", ")", ":", "\n", "        ", "parcel_file", "=", "str", "(", "config", ".", "data_dir", "/", "f\"{parcel_idx}.zarr\"", ")", "\n", "n_bands", "=", "len", "(", "config", ".", "bands", ")", "\n", "if", "is_l2a", ":", "# append cloud mask as last band", "\n", "            ", "n_bands", "+=", "1", "\n", "", "pixel_set_shape", "=", "(", "len", "(", "dates", ")", ",", "n_bands", ",", "n_pixels", "[", "parcel_idx", "]", ")", "# (T, C, S)", "\n", "z", "=", "zarr", ".", "open", "(", "parcel_file", ",", "mode", "=", "'a'", ",", "shape", "=", "pixel_set_shape", ",", "dtype", "=", "np", ".", "uint16", ")", "\n", "zarr_files", ".", "append", "(", "z", ")", "\n", "\n", "# Load step_size S2 samples at a time, extract pixels for each parcel and write to zarr files.", "\n", "", "step_size", "=", "config", ".", "buffer_size", "\n", "for", "img_idx", "in", "tqdm", "(", "range", "(", "0", ",", "len", "(", "s2_images", ")", ",", "step_size", ")", ",", "desc", "=", "'processing s2 image'", ")", ":", "\n", "        ", "t0", ",", "t1", "=", "img_idx", ",", "img_idx", "+", "step_size", "\n", "image", "=", "np", ".", "stack", "(", "[", "read_s2_image", "(", "s2_image", ",", "tile_transform", ",", "is_l2a", "=", "is_l2a", ")", "for", "s2_image", "in", "tqdm", "(", "s2_images", "[", "t0", ":", "t1", "]", ",", "desc", "=", "'reading S2 images to memory'", ",", "leave", "=", "False", ")", "]", ")", "\n", "\n", "for", "parcel_idx", "in", "tqdm", "(", "range", "(", "len", "(", "parcels", ")", ")", ",", "desc", "=", "'writing parcel pixels sets'", ",", "leave", "=", "False", ")", ":", "\n", "            ", "bbox", ",", "mask", "=", "bboxes", "[", "parcel_idx", "]", ",", "masks", "[", "parcel_idx", "]", "\n", "pixels", "=", "image", "[", "...", ",", "bbox", "[", "0", "]", ",", "bbox", "[", "1", "]", "]", "[", "...", ",", "mask", "]", "# (C, S)", "\n", "zarr_files", "[", "parcel_idx", "]", "[", "t0", ":", "t1", "]", "=", "pixels", "\n", "", "del", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.compute_bboxes_and_masks": [[99, 107], ["print", "rasterio.features.rasterize", "print", "mahotas.labeled.bbox", "enumerate", "enumerate"], "function", ["None"], ["", "", "def", "compute_bboxes_and_masks", "(", "parcels", ",", "transform", ")", ":", "\n", "    ", "print", "(", "'Rasterizing polygons...'", ")", "\n", "polygon_index", "=", "[", "(", "polygon", ",", "idx", ")", "for", "idx", ",", "polygon", "in", "enumerate", "(", "parcels", ".", "geometry", ",", "start", "=", "1", ")", "]", "# 0 = background", "\n", "labeled", "=", "rasterize", "(", "polygon_index", ",", "out_shape", "=", "(", "10980", ",", "10980", ")", ",", "transform", "=", "transform", ")", "\n", "print", "(", "'Computing bounding boxes and masks for each polygon...'", ")", "\n", "bboxes", "=", "mh", ".", "labeled", ".", "bbox", "(", "labeled", ",", "as_slice", "=", "True", ")", "[", "1", ":", "]", "# remove background bbox", "\n", "masks", "=", "[", "(", "labeled", "[", "bbox", "]", "==", "idx", ")", ".", "astype", "(", "bool", ")", "for", "idx", ",", "bbox", "in", "enumerate", "(", "bboxes", ",", "start", "=", "1", ")", "]", "\n", "return", "bboxes", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.write_metadata": [[109, 143], ["print", "pickle.dump", "print", "open", "pickle.dump", "open", "int", "prepare_pixels.get_geometric_features", "parcels.iterrows", "parcels.iterrows"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.get_geometric_features"], ["", "def", "write_metadata", "(", "parcels", ",", "bboxes", ",", "masks", ",", "dates", ",", "n_pixels", ",", "config", ",", "tile_transform", ",", "tile_crs", ",", "cloudy_pct", ",", "write_geometry", "=", "False", ")", ":", "\n", "    ", "print", "(", "'Writing metadata...'", ")", "\n", "metadata", "=", "{", "\n", "'start_date'", ":", "config", ".", "start_date", ",", "\n", "'end_date'", ":", "config", ".", "end_date", ",", "\n", "'dates'", ":", "dates", ",", "\n", "'cloudy_pct'", ":", "cloudy_pct", ",", "\n", "'parcels'", ":", "[", "\n", "{", "\n", "'id'", ":", "int", "(", "p", "[", "config", ".", "id_column", "]", ")", ",", "\n", "'label'", ":", "p", "[", "config", ".", "crop_code_column", "]", ",", "\n", "'n_pixels'", ":", "n_pixels", "[", "idx", "]", ",", "\n", "'block'", ":", "p", "[", "'block'", "]", ",", "\n", "'geometric_features'", ":", "get_geometric_features", "(", "p", ",", "masks", "[", "idx", "]", ")", ",", "\n", "}", "for", "idx", ",", "p", "in", "parcels", ".", "iterrows", "(", ")", "\n", "]", ",", "\n", "}", "\n", "pickle", ".", "dump", "(", "metadata", ",", "open", "(", "config", ".", "meta_dir", "/", "'metadata.pkl'", ",", "'wb'", ")", ")", "\n", "\n", "if", "write_geometry", ":", "\n", "        ", "geometry", "=", "{", "\n", "'tile'", ":", "config", ".", "tile", ",", "\n", "'tile_transform'", ":", "tile_transform", ",", "\n", "'tile_crs'", ":", "tile_crs", ",", "\n", "'parcels'", ":", "[", "\n", "{", "\n", "'id'", ":", "p", "[", "config", ".", "id_column", "]", ",", "\n", "'bbox'", ":", "bboxes", "[", "idx", "]", ",", "\n", "'mask'", ":", "masks", "[", "idx", "]", ",", "\n", "}", "for", "idx", ",", "p", "in", "parcels", ".", "iterrows", "(", ")", "\n", "]", ",", "\n", "}", "\n", "pickle", ".", "dump", "(", "geometry", ",", "open", "(", "config", ".", "meta_dir", "/", "'geometry.pkl'", ",", "'wb'", ")", ")", "\n", "", "print", "(", "'Done writing metadata.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.get_geometric_features": [[145, 152], ["mask.sum"], "function", ["None"], ["", "def", "get_geometric_features", "(", "parcel", ",", "mask", ")", ":", "\n", "# Compute geometric features", "\n", "    ", "perimeter", "=", "parcel", ".", "geometry", ".", "length", "# Parcel Perimeter (meters)", "\n", "area", "=", "parcel", ".", "geometry", ".", "area", "# Parcel Area (squared meters)", "\n", "perimeter_area_ratio", "=", "perimeter", "/", "area", "# Perimeter / Area", "\n", "cover_ratio", "=", "mask", ".", "sum", "(", ")", "/", "mask", ".", "size", "# n pixels in parcel / n pixels in bounding box", "\n", "return", "[", "perimeter", ",", "area", ",", "perimeter_area_ratio", ",", "cover_ratio", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.read_s2_image": [[154, 187], ["numpy.empty", "numpy.empty", "enumerate", "enumerate", "cv2.resize", "numpy.moveaxis", "cloud_mask[].astype", "numpy.concatenate", "numpy.concatenate", "geopandas.read_file", "rasterio.features.rasterize", "rasterio.open", "rasterio.open", "rasterio.open", "numpy.squeeze", "rasterio.open", "rasterio.open", "rasterio.open", "numpy.squeeze", "len", "len", "numpy.zeros", "f.read", "f.read"], "function", ["None"], ["", "def", "read_s2_image", "(", "s2_image", ":", "S2Image", ",", "tile_transform", "=", "None", ",", "is_l2a", "=", "False", ")", ":", "\n", "    ", "x10", "=", "np", ".", "empty", "(", "shape", "=", "(", "10980", ",", "10980", ",", "len", "(", "s2_image", ".", "bands_10m", ")", ")", ",", "dtype", "=", "np", ".", "uint16", ")", "\n", "x20", "=", "np", ".", "empty", "(", "shape", "=", "(", "10980", "//", "2", ",", "10980", "//", "2", ",", "len", "(", "s2_image", ".", "bands_20m", ")", ")", ",", "dtype", "=", "np", ".", "uint16", ")", "\n", "\n", "if", "is_l2a", ":", "\n", "        ", "try", ":", "\n", "            ", "cloud_mask", "=", "gpd", ".", "read_file", "(", "s2_image", ".", "cloud_mask", ")", "\n", "cloud_mask", "=", "rasterize", "(", "cloud_mask", ".", "geometry", ",", "out_shape", "=", "(", "10980", ",", "10980", ")", ",", "transform", "=", "tile_transform", ")", "# clouds will be set to 1", "\n", "", "except", ":", "# there sometimes is no cloud mask if no clouds", "\n", "            ", "assert", "s2_image", ".", "cloudy_pct", "==", "0.0", "\n", "cloud_mask", "=", "np", ".", "zeros", "(", "(", "10980", ",", "10980", ")", ",", "dtype", "=", "np", ".", "uint16", ")", "\n", "", "cloud_mask", "=", "cloud_mask", "*", "(", "2", "**", "16", "-", "1", ")", "# set clouds as max pixel value", "\n", "cloud_mask", "=", "cloud_mask", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ".", "astype", "(", "np", ".", "uint16", ")", "\n", "", "else", ":", "\n", "        ", "cloud_mask", "=", "None", "\n", "\n", "", "for", "band_idx", ",", "path", "in", "enumerate", "(", "s2_image", ".", "bands_10m", ")", ":", "\n", "        ", "with", "rasterio", ".", "open", "(", "path", ")", "as", "f", ":", "\n", "            ", "x10", "[", "...", ",", "band_idx", "]", "=", "np", ".", "squeeze", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "", "", "for", "band_idx", ",", "path", "in", "enumerate", "(", "s2_image", ".", "bands_20m", ")", ":", "\n", "        ", "with", "rasterio", ".", "open", "(", "path", ")", "as", "f", ":", "\n", "            ", "x20", "[", "...", ",", "band_idx", "]", "=", "np", ".", "squeeze", "(", "f", ".", "read", "(", ")", ")", "\n", "\n", "", "", "x20", "=", "cv2", ".", "resize", "(", "x20", ",", "x10", ".", "shape", "[", ":", "2", "]", ",", "interpolation", "=", "cv2", ".", "INTER_LINEAR", ")", "\n", "if", "is_l2a", ":", "\n", "        ", "image", "=", "np", ".", "concatenate", "(", "[", "x10", ",", "x20", ",", "cloud_mask", "]", ",", "axis", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "        ", "image", "=", "np", ".", "concatenate", "(", "[", "x10", ",", "x20", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n", "", "image", "=", "np", ".", "moveaxis", "(", "image", ",", "-", "1", ",", "0", ")", "# channels first", "\n", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.top_100_labels": [[189, 205], ["shapefile.copy", "utils.label_utils.get_codification_table", "print", "df[].value_counts().head().to_string", "utils.label_utils.get_codification_table", "print", "print", "exit", "utils.label_utils.get_codification_table", "print", "df[].value_counts().head().to_string", "df[].value_counts().head().to_string", "df[].value_counts().head", "config.crop_code_column.lower", "str", "df[].value_counts().head", "str", "df[].value_counts().head", "df[].value_counts", "int", "config.crop_code_column.lower", "int", "config.crop_code_column.lower", "df[].value_counts", "df[].value_counts"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_codification_table", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_codification_table", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_codification_table"], ["", "def", "top_100_labels", "(", "shapefile", ",", "config", ")", ":", "\n", "    ", "df", "=", "shapefile", ".", "copy", "(", ")", "\n", "if", "config", ".", "country", "==", "'france'", ":", "\n", "        ", "crop_codes", "=", "label_utils", ".", "get_codification_table", "(", "'france'", ")", "\n", "df", "[", "'label'", "]", "=", "[", "crop_codes", "[", "code", "]", "for", "code", "in", "df", "[", "config", ".", "crop_code_column", ".", "lower", "(", ")", "]", "]", "\n", "print", "(", "df", "[", "'label'", "]", ".", "value_counts", "(", ")", ".", "head", "(", "100", ")", ".", "to_string", "(", ")", ")", "\n", "", "elif", "config", ".", "country", "==", "'austria'", ":", "\n", "        ", "crop_codes", "=", "label_utils", ".", "get_codification_table", "(", "'austria'", ")", "\n", "df", "[", "'label'", "]", "=", "[", "crop_codes", "[", "str", "(", "int", "(", "code", ")", ")", "]", "for", "code", "in", "df", "[", "config", ".", "crop_code_column", ".", "lower", "(", ")", "]", "]", "\n", "print", "(", "df", ".", "columns", ")", "\n", "print", "(", "df", "[", "[", "'snar_code'", ",", "'snar_bezei'", "]", "]", ".", "value_counts", "(", ")", ".", "head", "(", "1000", ")", ".", "to_string", "(", ")", ")", "\n", "exit", "(", ")", "\n", "", "else", ":", "\n", "        ", "crop_codes", "=", "label_utils", ".", "get_codification_table", "(", "'denmark'", ")", "\n", "df", "[", "'label'", "]", "=", "[", "crop_codes", "[", "str", "(", "int", "(", "code", ")", ")", "]", "for", "code", "in", "df", "[", "config", ".", "crop_code_column", ".", "lower", "(", ")", "]", "]", "\n", "print", "(", "df", "[", "'label'", "]", ".", "value_counts", "(", ")", ".", "head", "(", "100", ")", ".", "to_string", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.get_ground_truth_parcels": [[207, 260], ["output_dir.mkdir", "print", "os.path.join", "output_file.exists", "print", "geopandas.read_file", "df.drop.to_crs", "df.drop.columns.str.lower", "print", "len", "df.drop.geometry.buffer", "print", "print", "print", "df.drop.to_file", "print", "geopandas.read_file", "glob.glob", "df.drop.drop", "tqdm.tqdm", "print", "os.path.join", "len", "blocks.iterrows", "df.drop.geometry.within", "len", "len", "len", "len"], "function", ["None"], ["", "", "def", "get_ground_truth_parcels", "(", "tile_bbox", ",", "config", ",", "blocks", "=", "None", ",", "erosion_m", "=", "20", ",", "min_area_sqm", "=", "10000", ")", ":", "\n", "    ", "output_dir", "=", "config", ".", "meta_dir", "/", "'parcels'", "\n", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ",", "parents", "=", "True", ")", "\n", "print", "(", "'Creating new label shape file...'", ")", "\n", "gt_path", "=", "os", ".", "path", ".", "join", "(", "config", ".", "ground_truth_dir", ",", "config", ".", "country", ",", "config", ".", "year", ")", "\n", "gt_shape_file", "=", "None", "\n", "output_file", "=", "output_dir", "/", "f'parcels_{config.country}_{config.tile}_{config.year}.shp'", "\n", "if", "output_file", ".", "exists", "(", ")", ":", "\n", "        ", "print", "(", "'Loading cached label shapefile'", ")", "\n", "return", "gpd", ".", "read_file", "(", "output_file", ")", "\n", "\n", "", "for", "filetype", "in", "[", "'shp'", ",", "'gpkg'", "]", ":", "\n", "        ", "res", "=", "glob", "(", "os", ".", "path", ".", "join", "(", "gt_path", ",", "f\"*.{filetype}\"", ")", ")", "\n", "if", "len", "(", "res", ")", ">", "0", ":", "\n", "            ", "gt_shape_file", "=", "res", "[", "0", "]", "\n", "out_filetype", "=", "filetype", "\n", "break", "\n", "\n", "", "", "print", "(", "'reading ground truth file...'", ",", "gt_shape_file", ")", "\n", "df", "=", "gpd", ".", "read_file", "(", "gt_shape_file", ",", "bbox", "=", "tile_bbox", ")", "\n", "df", "=", "df", ".", "to_crs", "(", "tile_bbox", ".", "crs", ")", "\n", "# remove binary column in austria dataset", "\n", "if", "config", ".", "country", "==", "'austria'", ":", "\n", "        ", "df", "=", "df", ".", "drop", "(", "columns", "=", "'GML_GEOM'", ",", "errors", "=", "'ignore'", ")", "\n", "", "df", ".", "columns", "=", "df", ".", "columns", ".", "str", ".", "lower", "(", ")", "\n", "print", "(", "df", ".", "columns", ")", "\n", "available_fields", "=", "len", "(", "df", ")", "\n", "\n", "\n", "\n", "if", "blocks", "is", "not", "None", ":", "\n", "# Assign fields to blocks", "\n", "        ", "df", "[", "'block'", "]", "=", "-", "1", "\n", "for", "block_idx", ",", "block", "in", "tqdm", "(", "blocks", ".", "iterrows", "(", ")", ",", "total", "=", "len", "(", "blocks", ")", ",", "desc", "=", "'Locating fields within blocks'", ")", ":", "\n", "            ", "fields_within_bbox", "=", "df", ".", "geometry", ".", "within", "(", "block", ".", "geometry", ")", "\n", "df", ".", "loc", "[", "fields_within_bbox", ",", "'block'", "]", "=", "block_idx", "\n", "\n", "", "df", "=", "df", "[", "df", ".", "block", "!=", "-", "1", "]", "\n", "print", "(", "f'Remaining parcels after removing those not contained in blocks: {len(df)}/{available_fields}'", ")", "\n", "", "else", ":", "\n", "        ", "df", "[", "'block'", "]", "=", "0", "# assign all to single block", "\n", "\n", "", "df", ".", "geometry", "=", "df", ".", "geometry", ".", "buffer", "(", "-", "erosion_m", ")", "\n", "df", "=", "df", "[", "~", "df", ".", "geometry", ".", "is_empty", "]", "\n", "print", "(", "f'Remaining parcels after {erosion_m}m erosion: {len(df)}/{available_fields}'", ")", "\n", "\n", "df", "=", "df", "[", "df", ".", "geometry", ".", "area", ">=", "min_area_sqm", "]", "\n", "print", "(", "f'Remaining parcels after removing parcels less than {min_area_sqm} m2: {len(df)}/{available_fields}'", ")", "\n", "\n", "print", "(", "'Saving filtered shapefile...'", ")", "\n", "df", ".", "to_file", "(", "output_file", ")", "\n", "\n", "return", "df", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.create_blocks": [[262, 299], ["output_dir.mkdir", "list", "print", "geopandas.GeoDataFrame", "gpd.GeoDataFrame.to_file", "itertools.product", "prepare_pixels.create_blocks.pixel_to_world"], "function", ["None"], ["", "def", "create_blocks", "(", "tile_bbox", ",", "config", ",", "s2_tile_size", "=", "10980", ")", ":", "\n", "    ", "output_dir", "=", "config", ".", "meta_dir", "/", "'blocks'", "\n", "output_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ",", "parents", "=", "True", ")", "\n", "output_file", "=", "output_dir", "/", "f'blocks_{config.country}_{config.tile}_{config.year}.shp'", "\n", "\n", "crs", "=", "tile_bbox", ".", "crs", "\n", "bbox_minx", ",", "bbox_miny", ",", "bbox_maxx", ",", "bbox_maxy", "=", "tile_bbox", ".", "bounds", ".", "values", "[", "0", "]", "\n", "\n", "block_size", ",", "margin", "=", "config", ".", "block_size", ",", "config", ".", "margin", "\n", "\n", "fixed_raster_size", "=", "s2_tile_size", "-", "(", "(", "s2_tile_size", "-", "block_size", ")", "%", "(", "block_size", "+", "margin", ")", ")", "\n", "blocks", "=", "list", "(", "product", "(", "range", "(", "0", ",", "fixed_raster_size", ",", "block_size", "+", "margin", ")", ",", "repeat", "=", "2", ")", ")", "\n", "blocks", "=", "[", "(", "minx", ",", "miny", ",", "block_size", ",", "block_size", ")", "for", "minx", ",", "miny", "in", "blocks", "]", "\n", "blocks", "=", "[", "{", "'idx'", ":", "idx", ",", "'bbox'", ":", "bbox", "}", "for", "idx", ",", "bbox", "in", "enumerate", "(", "blocks", ")", "]", "\n", "\n", "print", "(", "\n", "f'Dividing rasters with block_size={block_size} and margin={margin}, leaving {s2_tile_size - fixed_raster_size}px unused'", ")", "\n", "\n", "def", "pixel_to_world", "(", "x", ",", "y", ",", "ulx", ",", "uly", ",", "res", "=", "10", ")", ":", "\n", "        ", "return", "res", "*", "x", "+", "ulx", ",", "uly", "-", "y", "*", "res", "\n", "\n", "", "blocks_world", "=", "[", "]", "\n", "for", "block", "in", "blocks", ":", "\n", "        ", "minx", ",", "miny", ",", "width", ",", "height", "=", "block", "[", "'bbox'", "]", "\n", "world_minx", ",", "world_maxy", "=", "pixel_to_world", "(", "minx", ",", "miny", ",", "ulx", "=", "bbox_minx", ",", "uly", "=", "bbox_maxy", ")", "\n", "\n", "blocks_world", ".", "append", "(", "box", "(", "\n", "minx", "=", "world_minx", ",", "\n", "miny", "=", "world_maxy", "-", "height", "*", "10", ",", "\n", "maxx", "=", "world_minx", "+", "width", "*", "10", ",", "\n", "maxy", "=", "world_maxy", ",", "\n", ")", ")", "\n", "\n", "", "gdf", "=", "gpd", ".", "GeoDataFrame", "(", "{", "'id'", ":", "list", "(", "range", "(", "len", "(", "blocks", ")", ")", ")", "}", ",", "geometry", "=", "blocks_world", ",", "crs", "=", "crs", ")", "\n", "gdf", ".", "to_file", "(", "output_file", ")", "\n", "\n", "return", "gdf", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.preprocessing.prepare_pixels.fix_crs": [[300, 310], ["print", "gdal.Open", "osr.SpatialReference", "osr.SpatialReference.ImportFromEPSG", "gdal.Open.SetProjection", "str", "osr.SpatialReference.ExportToWkt"], "function", ["None"], ["", "def", "fix_crs", "(", "s2_images", ",", "epsg", "=", "32632", ")", ":", "\n", "    ", "from", "osgeo", "import", "gdal", ",", "osr", "\n", "for", "s2_image", "in", "s2_images", ":", "\n", "        ", "for", "band", "in", "s2_image", ".", "bands_10m", "+", "s2_image", ".", "bands_20m", ":", "\n", "            ", "ds", "=", "gdal", ".", "Open", "(", "str", "(", "band", ")", ",", "1", ")", "\n", "proj", "=", "osr", ".", "SpatialReference", "(", ")", "\n", "proj", ".", "ImportFromEPSG", "(", "32632", ")", "\n", "ds", ".", "SetProjection", "(", "proj", ".", "ExportToWkt", "(", ")", ")", "\n", "ds", "=", "None", "\n", "", "", "print", "(", "'updated crs'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.samplers.VariableSequenceLengthBatchSampler.__init__": [[10, 27], ["range", "enumerate", "all", "len", "n_examples_per_seq_length.append", "sum", "list", "sum", "len", "len", "len", "len", "range", "range", "len", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data_source", ",", "batch_size", ")", ":", "\n", "        ", "self", ".", "data_source", "=", "data_source", "\n", "\n", "n_examples_per_seq_length", "=", "[", "]", "\n", "for", "zarr_file_idx", "in", "range", "(", "len", "(", "data_source", ".", "zarr_files", ")", ")", ":", "\n", "            ", "n_examples_per_seq_length", ".", "append", "(", "len", "(", "[", "1", "for", "idx", ",", "_", ",", "_", ",", "_", "in", "data_source", ".", "images", "if", "idx", "==", "zarr_file_idx", "]", ")", ")", "\n", "\n", "", "self", ".", "batches", "=", "[", "]", "\n", "for", "offset_idx", ",", "n_examples", "in", "enumerate", "(", "n_examples_per_seq_length", ")", ":", "\n", "            ", "offset", "=", "sum", "(", "x", "for", "x", "in", "n_examples_per_seq_length", "[", ":", "offset_idx", "]", ")", "\n", "indices", "=", "list", "(", "range", "(", "offset", ",", "offset", "+", "n_examples", ")", ")", "\n", "self", ".", "batches", "+=", "[", "indices", "[", "a", ":", "a", "+", "batch_size", "]", "for", "a", "in", "range", "(", "0", ",", "n_examples", ",", "batch_size", ")", "]", "\n", "\n", "# Sanity checks: all batches should be at most the batch size, and all patches should be included.", "\n", "", "assert", "all", "(", "[", "len", "(", "batch", ")", "<=", "batch_size", "for", "batch", "in", "self", ".", "batches", "]", ")", "\n", "assert", "sum", "(", "[", "len", "(", "batch", ")", "for", "batch", "in", "self", ".", "batches", "]", ")", "==", "len", "(", "data_source", ")", "\n", "assert", "len", "(", "{", "idx", "for", "batch", "in", "self", ".", "batches", "for", "idx", "in", "batch", "}", ")", "==", "len", "(", "data_source", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.samplers.VariableSequenceLengthBatchSampler.__iter__": [[28, 31], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "batch", "in", "self", ".", "batches", ":", "\n", "            ", "yield", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.samplers.VariableSequenceLengthBatchSampler.__len__": [[32, 34], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "batches", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.AverageMeter.__init__": [[126, 128], ["metrics.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.AverageMeter.reset": [[129, 134], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.AverageMeter.update": [[135, 140], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "val", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "val", "=", "val", "\n", "self", ".", "sum", "+=", "val", "*", "n", "\n", "self", ".", "count", "+=", "n", "\n", "self", ".", "avg", "=", "self", ".", "sum", "/", "self", ".", "count", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy": [[6, 10], ["torch.no_grad", "outputs.argmax", "outputs.argmax.eq().float().mean().item", "outputs.argmax.eq().float().mean", "outputs.argmax.eq().float", "outputs.argmax.eq"], "function", ["None"], ["@", "torch", ".", "no_grad", "(", ")", "\n", "def", "accuracy", "(", "outputs", ",", "targets", ")", ":", "\n", "    ", "preds", "=", "outputs", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "return", "preds", ".", "eq", "(", "targets", ")", ".", "float", "(", ")", ".", "mean", "(", ")", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.f1_score": [[12, 25], ["range", "f1_scores.append", "numpy.mean", "confusion_matrix[].sum", "confusion_matrix[].sum", "float"], "function", ["None"], ["", "def", "f1_score", "(", "confusion_matrix", ",", "reduce_mean", "=", "True", ")", ":", "\n", "    ", "f1_scores", "=", "[", "]", "\n", "for", "index", "in", "range", "(", "confusion_matrix", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "true_positives", "=", "confusion_matrix", "[", "index", ",", "index", "]", "\n", "false_positives", "=", "confusion_matrix", "[", ":", ",", "index", "]", ".", "sum", "(", ")", "-", "true_positives", "\n", "false_negatives", "=", "confusion_matrix", "[", "index", ",", ":", "]", ".", "sum", "(", ")", "-", "true_positives", "\n", "denom", "=", "2", "*", "true_positives", "+", "false_positives", "+", "false_negatives", "\n", "if", "denom", "==", "0", ":", "\n", "            ", "f1_score", "=", "0.0", "\n", "", "else", ":", "\n", "            ", "f1_score", "=", "2", "*", "float", "(", "true_positives", ")", "/", "denom", "\n", "", "f1_scores", ".", "append", "(", "f1_score", ")", "\n", "", "return", "np", ".", "mean", "(", "f1_scores", ")", "if", "reduce_mean", "else", "f1_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.precision_recall_fscore_support": [[27, 49], ["range", "f1_scores.append", "precisions.append", "recalls.append", "supports.append", "confusion_matrix[].sum", "confusion_matrix[].sum", "int", "float", "float", "float"], "function", ["None"], ["", "def", "precision_recall_fscore_support", "(", "confusion_matrix", ")", ":", "\n", "    ", "f1_scores", ",", "precisions", ",", "recalls", ",", "supports", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "index", "in", "range", "(", "confusion_matrix", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "true_positives", "=", "confusion_matrix", "[", "index", ",", "index", "]", "\n", "false_positives", "=", "confusion_matrix", "[", ":", ",", "index", "]", ".", "sum", "(", ")", "-", "true_positives", "\n", "false_negatives", "=", "confusion_matrix", "[", "index", ",", ":", "]", ".", "sum", "(", ")", "-", "true_positives", "\n", "\n", "denom", "=", "true_positives", "+", "false_positives", "\n", "precision", "=", "0.0", "if", "denom", "==", "0", "else", "float", "(", "true_positives", ")", "/", "denom", "\n", "\n", "denom", "=", "true_positives", "+", "false_negatives", "\n", "recall", "=", "0.0", "if", "denom", "==", "0", "else", "float", "(", "true_positives", ")", "/", "denom", "\n", "\n", "denom", "=", "precision", "+", "recall", "\n", "f1_score", "=", "0.0", "if", "denom", "==", "0", "else", "2", "*", "float", "(", "precision", "*", "recall", ")", "/", "denom", "\n", "\n", "f1_scores", ".", "append", "(", "f1_score", ")", "\n", "precisions", ".", "append", "(", "precision", ")", "\n", "recalls", ".", "append", "(", "recall", ")", "\n", "supports", ".", "append", "(", "int", "(", "true_positives", "+", "false_negatives", ")", ")", "\n", "\n", "", "return", "precisions", ",", "recalls", ",", "f1_scores", ",", "supports", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy_cm": [[51, 53], ["numpy.diag().sum", "confusion_matrix.sum", "numpy.diag"], "function", ["None"], ["", "def", "accuracy_cm", "(", "confusion_matrix", ")", ":", "\n", "    ", "return", "np", ".", "diag", "(", "confusion_matrix", ")", ".", "sum", "(", ")", "/", "confusion_matrix", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.compute_confusion_matrix": [[55, 67], ["numpy.histogramdd", "confusion_matrix.astype.astype", "numpy.vstack", "ground_truth.flatten", "prediction.flatten"], "function", ["None"], ["", "def", "compute_confusion_matrix", "(", "prediction", ",", "ground_truth", ",", "num_classes", ")", ":", "\n", "    ", "replace_indices", "=", "np", ".", "vstack", "(", "(", "\n", "ground_truth", ".", "flatten", "(", ")", ",", "\n", "prediction", ".", "flatten", "(", ")", ")", "\n", ")", ".", "T", "\n", "confusion_matrix", ",", "_", "=", "np", ".", "histogramdd", "(", "\n", "replace_indices", ",", "\n", "bins", "=", "(", "num_classes", ",", "num_classes", ")", ",", "\n", "range", "=", "[", "(", "0", ",", "num_classes", ")", ",", "(", "0", ",", "num_classes", ")", "]", "\n", ")", "\n", "confusion_matrix", "=", "confusion_matrix", ".", "astype", "(", "np", ".", "uint32", ")", "\n", "return", "confusion_matrix", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.classification_report": [[69, 81], ["metrics.precision_recall_fscore_support", "list", "metrics.accuracy_cm", "sum", "list.append", "list.append", "list.append", "tabulate.tabulate", "zip", "numpy.mean", "numpy.mean", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.precision_recall_fscore_support", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy_cm"], ["", "def", "classification_report", "(", "cm", ",", "class_names", ")", ":", "\n", "    ", "precisions", ",", "recalls", ",", "f1_scores", ",", "supports", "=", "precision_recall_fscore_support", "(", "cm", ")", "\n", "rows", "=", "list", "(", "zip", "(", "class_names", ",", "precisions", ",", "recalls", ",", "f1_scores", ",", "supports", ")", ")", "\n", "accuracy", "=", "accuracy_cm", "(", "cm", ")", "\n", "total_support", "=", "sum", "(", "supports", ")", "\n", "rows", ".", "append", "(", "[", "None", ",", "None", ",", "None", ",", "None", ",", "None", "]", ")", "\n", "rows", ".", "append", "(", "[", "'accuracy'", ",", "None", ",", "None", ",", "accuracy", ",", "total_support", "]", ")", "\n", "rows", ".", "append", "(", "[", "'macro avg'", ",", "np", ".", "mean", "(", "precisions", ")", ",", "np", ".", "mean", "(", "recalls", ")", ",", "np", ".", "mean", "(", "f1_scores", ")", ",", "total_support", "]", ")", "\n", "# weights = np.array(supports) / total_support", "\n", "# rows.append(['weighted avg', np.average(precisions, weights=weights), np.average(recalls, weights=weights), np.average(f1_scores, weights=weights), total_support])", "\n", "headers", "=", "[", "''", ",", "'precision'", ",", "'recall'", ",", "'f1-score'", ",", "'support'", "]", "\n", "return", "tabulate", "(", "rows", ",", "headers", "=", "headers", ",", "floatfmt", "=", "'.2f'", ",", "tablefmt", "=", "'pipe'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.confusion_matrix_report": [[83, 90], ["list", "zip", "tabulate.tabulate", "range", "rows.append", "len", "conf.tolist"], "function", ["None"], ["", "def", "confusion_matrix_report", "(", "cm", ",", "class_names", ")", ":", "\n", "    ", "rows", "=", "[", "]", "\n", "classes", "=", "list", "(", "range", "(", "len", "(", "class_names", ")", ")", ")", "\n", "for", "cls", ",", "conf", "in", "zip", "(", "classes", ",", "cm", ")", ":", "\n", "        ", "rows", ".", "append", "(", "[", "cls", ",", "]", "+", "conf", ".", "tolist", "(", ")", ")", "\n", "", "headers", "=", "[", "'true\\\\pred'", ",", "]", "+", "classes", "\n", "return", "tabulate", "(", "rows", ",", "headers", "=", "headers", ",", "floatfmt", "=", "'.2f'", ",", "tablefmt", "=", "'pipe'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.overall_classification_report": [[92, 121], ["numpy.array", "enumerate", "numpy.array", "rows.append", "rows.append", "range", "rows.append", "tabulate.tabulate", "metrics.precision_recall_fscore_support", "list", "rows.append", "numpy.mean", "numpy.std", "macro_avg.append", "zip", "numpy.sum", "numpy.std", "numpy.mean", "numpy.std", "numpy.mean", "numpy.std", "metrics.accuracy_cm", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.precision_recall_fscore_support", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy_cm"], ["", "def", "overall_classification_report", "(", "cms", ",", "class_names", ")", ":", "\n", "    ", "class_metrics", "=", "[", "precision_recall_fscore_support", "(", "cm", ")", "for", "cm", "in", "cms", "]", "\n", "class_metrics", "=", "np", ".", "array", "(", "class_metrics", ")", "# (len(cms), 4, len(class_names))", "\n", "class_metrics", "[", ":", ",", ":", "-", "1", "]", "*=", "100.0", "\n", "rows", "=", "[", "]", "\n", "for", "class_idx", ",", "class_name", "in", "enumerate", "(", "class_names", ")", ":", "\n", "        ", "metrics", "=", "class_metrics", "[", ":", ",", ":", ",", "class_idx", "]", "\n", "mean_stds", "=", "list", "(", "zip", "(", "np", ".", "mean", "(", "metrics", ",", "axis", "=", "0", ")", ",", "np", ".", "std", "(", "metrics", ",", "axis", "=", "0", ")", ")", ")", "\n", "support_mean", ",", "support_std", "=", "mean_stds", "[", "-", "1", "]", "\n", "# mean_stds = np.array(mean_stds[:-1]) * 100.0", "\n", "mean_stds", "=", "[", "f'{mean:.1f}\u00b1{std:.1f}'", "for", "mean", ",", "std", "in", "mean_stds", "[", ":", "-", "1", "]", "]", "+", "[", "f'{support_mean:.1f}\u00b1{support_std:.1f}'", "]", "\n", "rows", ".", "append", "(", "(", "class_name", ",", "*", "mean_stds", ")", ")", "\n", "\n", "", "accs", "=", "np", ".", "array", "(", "[", "accuracy_cm", "(", "cm", ")", "*", "100.0", "for", "cm", "in", "cms", "]", ")", "\n", "accuracy", "=", "'{:.1f}\u00b1{:.1f}'", ".", "format", "(", "np", ".", "mean", "(", "accs", ")", ",", "np", ".", "std", "(", "accs", ")", ")", "\n", "rows", ".", "append", "(", "[", "None", ",", "None", ",", "None", ",", "None", ",", "None", "]", ")", "\n", "rows", ".", "append", "(", "[", "'accuracy'", ",", "None", ",", "None", ",", "None", ",", "accuracy", "]", ")", "\n", "macro_avg", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "if", "i", "==", "3", ":", "# sum support", "\n", "            ", "macro_avg_per_run", "=", "np", ".", "sum", "(", "class_metrics", "[", ":", ",", "i", ",", ":", "]", ",", "axis", "=", "-", "1", ")", "\n", "std", "=", "np", ".", "std", "(", "macro_avg_per_run", ")", "\n", "", "else", ":", "\n", "            ", "macro_avg_per_run", "=", "np", ".", "mean", "(", "class_metrics", "[", ":", ",", "i", ",", ":", "]", ",", "axis", "=", "-", "1", ")", "\n", "std", "=", "np", ".", "std", "(", "macro_avg_per_run", ")", "\n", "", "macro_avg", ".", "append", "(", "f'{np.mean(macro_avg_per_run):.1f}\u00b1{std:.1f}'", ")", "\n", "", "rows", ".", "append", "(", "[", "'macro avg'", ",", "*", "macro_avg", "]", ")", "\n", "headers", "=", "[", "''", ",", "'precision'", ",", "'recall'", ",", "'f1-score'", ",", "'support'", "]", "\n", "return", "tabulate", "(", "rows", ",", "headers", "=", "headers", ",", "floatfmt", "=", "'.2f'", ",", "tablefmt", "=", "'pipe'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_classes": [[5, 13], ["sorted", "label_utils.get_code_to_class", "class_sets.append", "list", "set", "method", "get_code_to_class.values"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_code_to_class"], ["def", "get_classes", "(", "*", "countries", ",", "method", "=", "set", ".", "union", ",", "combine_spring_and_winter", "=", "False", ")", ":", "\n", "    ", "class_sets", "=", "[", "]", "\n", "for", "country", "in", "countries", ":", "\n", "        ", "code_to_class", "=", "get_code_to_class", "(", "country", ",", "combine_spring_and_winter", ")", "\n", "class_sets", ".", "append", "(", "set", "(", "code_to_class", ".", "values", "(", ")", ")", ")", "\n", "\n", "", "classes", "=", "sorted", "(", "list", "(", "method", "(", "*", "class_sets", ")", ")", ")", "\n", "return", "classes", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.read_yaml_class_mapping": [[14, 16], ["yaml.load", "open", "os.path.join"], "function", ["None"], ["", "def", "read_yaml_class_mapping", "(", "country", ")", ":", "\n", "    ", "return", "yaml", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "'class_mapping'", ",", "f'{country}_class_mapping.yml'", ")", ")", ",", "Loader", "=", "yaml", ".", "FullLoader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_code_to_class": [[17, 37], ["label_utils.read_yaml_class_mapping", "read_yaml_class_mapping.keys", "code_to_class.update", "code_to_class.update", "code_to_class.update", "code_to_class.update", "codes[].keys", "codes[].keys"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.read_yaml_class_mapping", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update"], ["", "def", "get_code_to_class", "(", "country", ",", "combine_spring_and_winter", "=", "False", ")", ":", "\n", "    ", "class_mapping", "=", "read_yaml_class_mapping", "(", "country", ")", "\n", "\n", "code_to_class", "=", "{", "}", "\n", "for", "cls", "in", "class_mapping", ".", "keys", "(", ")", ":", "\n", "        ", "codes", "=", "class_mapping", "[", "cls", "]", "\n", "if", "codes", "is", "None", ":", "\n", "            ", "continue", "\n", "", "if", "'spring'", "in", "codes", "and", "'winter'", "in", "codes", ":", "\n", "            ", "if", "combine_spring_and_winter", ":", "\n", "                ", "combined", "=", "{", "**", "(", "codes", "[", "'spring'", "]", "if", "codes", "[", "'spring'", "]", "is", "not", "None", "else", "{", "}", ")", ",", "**", "(", "codes", "[", "'winter'", "]", "if", "codes", "[", "'winter'", "]", "is", "not", "None", "else", "{", "}", ")", "}", "\n", "code_to_class", ".", "update", "(", "{", "code", ":", "cls", "for", "code", "in", "combined", "}", ")", "\n", "", "else", ":", "\n", "                ", "if", "codes", "[", "'spring'", "]", "is", "not", "None", ":", "\n", "                    ", "code_to_class", ".", "update", "(", "{", "code", ":", "f'spring_{cls}'", "for", "code", "in", "codes", "[", "'spring'", "]", ".", "keys", "(", ")", "}", ")", "\n", "", "if", "codes", "[", "'winter'", "]", "is", "not", "None", ":", "\n", "                    ", "code_to_class", ".", "update", "(", "{", "code", ":", "f'winter_{cls}'", "for", "code", "in", "codes", "[", "'winter'", "]", ".", "keys", "(", ")", "}", ")", "\n", "", "", "", "else", ":", "\n", "            ", "code_to_class", ".", "update", "(", "{", "code", ":", "cls", "for", "code", "in", "codes", "}", ")", "\n", "", "", "return", "code_to_class", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_shapefile_columns": [[38, 41], ["None"], "function", ["None"], ["", "def", "get_shapefile_columns", "(", "country", ")", ":", "\n", "    ", "cols", "=", "_shapefile_columns", "[", "country", "]", "\n", "return", "cols", "[", "'id'", "]", ",", "cols", "[", "'crop_code'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.label_utils.get_codification_table": [[42, 49], ["os.path.join", "open", "csv.reader"], "function", ["None"], ["", "def", "get_codification_table", "(", "country", ")", ":", "\n", "    ", "codification_table", "=", "os", ".", "path", ".", "join", "(", "'class_mapping'", ",", "f'{country}_codification_table.csv'", ")", "\n", "with", "open", "(", "codification_table", ",", "newline", "=", "''", ")", "as", "f", ":", "\n", "        ", "delimiter", "=", "';'", "if", "country", "in", "[", "'denmark'", ",", "'austria'", "]", "else", "','", "\n", "crop_codes", "=", "csv", ".", "reader", "(", "f", ",", "delimiter", "=", "delimiter", ")", "\n", "crop_codes", "=", "{", "x", "[", "0", "]", ":", "x", "[", "1", "]", "for", "x", "in", "crop_codes", "}", "# crop_code: (name, group)", "\n", "", "return", "crop_codes", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.__init__": [[37, 39], ["train_utils.AverageMeter.reset"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.reset": [[40, 45], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "val", "=", "0", "\n", "self", ".", "avg", "=", "0", "\n", "self", ".", "sum", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update": [[46, 51], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "val", ",", "n", "=", "1", ")", ":", "\n", "        ", "self", ".", "val", "=", "val", "\n", "self", ".", "sum", "+=", "val", "*", "n", "\n", "self", ".", "count", "+=", "n", "\n", "self", ".", "avg", "=", "self", ".", "sum", "/", "self", ".", "count", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda": [[8, 17], ["sample[].cuda", "sample[].cuda", "sample[].cuda", "sample[].cuda"], "function", ["None"], ["def", "to_cuda", "(", "sample", ",", "device", ",", "non_blocking", "=", "True", ")", ":", "\n", "    ", "pixels", "=", "sample", "[", "'pixels'", "]", ".", "cuda", "(", "device", "=", "device", ",", "non_blocking", "=", "non_blocking", ")", "\n", "valid_pixels", "=", "sample", "[", "'valid_pixels'", "]", ".", "cuda", "(", "device", "=", "device", ",", "non_blocking", "=", "non_blocking", ")", "\n", "positions", "=", "sample", "[", "'positions'", "]", ".", "cuda", "(", "device", "=", "device", ",", "non_blocking", "=", "non_blocking", ")", "\n", "if", "'extra'", "in", "sample", ":", "\n", "        ", "extra", "=", "sample", "[", "'extra'", "]", ".", "cuda", "(", "device", "=", "device", ",", "non_blocking", "=", "non_blocking", ")", "\n", "", "else", ":", "\n", "        ", "extra", "=", "None", "\n", "", "return", "pixels", ",", "valid_pixels", ",", "positions", ",", "extra", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cat_samples": [[19, 29], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "function", ["None"], ["", "def", "cat_samples", "(", "samples", ")", ":", "\n", "    ", "out", "=", "{", "\n", "'pixels'", ":", "torch", ".", "cat", "(", "[", "x", "[", "'pixels'", "]", "for", "x", "in", "samples", "]", ")", ",", "\n", "'valid_pixels'", ":", "torch", ".", "cat", "(", "[", "x", "[", "'valid_pixels'", "]", "for", "x", "in", "samples", "]", ")", ",", "\n", "'positions'", ":", "torch", ".", "cat", "(", "[", "x", "[", "'positions'", "]", "for", "x", "in", "samples", "]", ")", ",", "\n", "'label'", ":", "torch", ".", "cat", "(", "[", "x", "[", "'label'", "]", "for", "x", "in", "samples", "]", ")", ",", "\n", "}", "\n", "if", "'extra'", "in", "samples", "[", "0", "]", ":", "\n", "        ", "out", "[", "'extra'", "]", "=", "torch", ".", "cat", "(", "[", "x", "[", "'extra'", "]", "for", "x", "in", "samples", "]", ")", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.onehot": [[31, 33], ["torch.zeros().scatter_", "label.view", "torch.zeros", "label.size"], "function", ["None"], ["", "def", "onehot", "(", "label", ",", "num_classes", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "return", "torch", ".", "zeros", "(", "label", ".", "size", "(", "0", ")", ",", "num_classes", ",", "device", "=", "device", ")", ".", "scatter_", "(", "1", ",", "label", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle": [[53, 57], ["None"], "function", ["None"], ["", "", "def", "cycle", "(", "iterable", ")", ":", "# Don't use itertools.cycle, as it repeats the same shuffle", "\n", "    ", "while", "True", ":", "\n", "        ", "for", "x", "in", "iterable", ":", "\n", "            ", "yield", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.bool_flag": [[58, 68], ["s.lower", "s.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["", "", "", "def", "bool_flag", "(", "s", ")", ":", "\n", "    ", "\"\"\"\n    Parse boolean arguments from the command line.\n    \"\"\"", "\n", "if", "s", ".", "lower", "(", ")", "in", "FALSY_STRINGS", ":", "\n", "        ", "return", "False", "\n", "", "elif", "s", ".", "lower", "(", ")", "in", "TRUTHY_STRINGS", ":", "\n", "        ", "return", "True", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "\"invalid value for a boolean flag\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.focal_loss.FocalLoss.__init__": [[12, 16], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gamma", "=", "0", ",", "size_average", "=", "True", ")", ":", "\n", "        ", "super", "(", "FocalLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "size_average", "=", "size_average", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.utils.focal_loss.FocalLoss.forward": [[17, 29], ["target.view.view.view", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "logpt.view.view.gather", "logpt.view.view.view", "logpt.view.view.exp", "loss.mean", "loss.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "# input shape (B, C), target shape (B,)", "\n", "        ", "target", "=", "target", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "\n", "logpt", "=", "F", ".", "log_softmax", "(", "input", ",", "dim", "=", "1", ")", "\n", "logpt", "=", "logpt", ".", "gather", "(", "1", ",", "target", ")", "\n", "logpt", "=", "logpt", ".", "view", "(", "-", "1", ")", "\n", "pt", "=", "logpt", ".", "exp", "(", ")", "\n", "\n", "loss", "=", "-", "1", "*", "(", "1", "-", "pt", ")", "**", "self", ".", "gamma", "*", "logpt", "\n", "if", "self", ".", "size_average", ":", "return", "loss", ".", "mean", "(", ")", "\n", "else", ":", "return", "loss", ".", "sum", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.Multi_AdversarialNetwork.__init__": [[212, 229], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Sigmoid", "torch.Sigmoid", "train_alda.Multi_AdversarialNetwork.apply"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_feature", ",", "hidden_size", ",", "class_num", ")", ":", "\n", "        ", "super", "(", "Multi_AdversarialNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "ad_layer1", "=", "nn", ".", "Linear", "(", "in_feature", ",", "hidden_size", ")", "\n", "self", ".", "ad_layer2", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", "\n", "self", ".", "ad_layer3", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "class_num", ")", "\n", "self", ".", "relu1", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "ReLU", "(", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "self", ".", "apply", "(", "init_weights", ")", "\n", "self", ".", "iter_num", "=", "0", "\n", "self", ".", "alpha", "=", "10", "\n", "self", ".", "low", "=", "0.0", "\n", "self", ".", "high", "=", "1.0", "\n", "# self.max_iter = 10000.0", "\n", "self", ".", "max_iter", "=", "1000.0", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.Multi_AdversarialNetwork.forward": [[230, 245], ["train_alda.Multi_AdversarialNetwork.ad_layer1", "train_alda.Multi_AdversarialNetwork.relu1", "train_alda.Multi_AdversarialNetwork.dropout1", "train_alda.Multi_AdversarialNetwork.ad_layer2", "train_alda.Multi_AdversarialNetwork.relu2", "train_alda.Multi_AdversarialNetwork.dropout2", "train_alda.Multi_AdversarialNetwork.ad_layer3", "train_alda.calc_coeff", "train_alda.Multi_AdversarialNetwork.register_hook", "train_alda.grl_hook"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.calc_coeff", "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.grl_hook"], ["", "def", "forward", "(", "self", ",", "x", ",", "grl", "=", "True", ")", ":", "\n", "        ", "if", "self", ".", "training", ":", "\n", "            ", "self", ".", "iter_num", "+=", "1", "\n", "", "if", "grl", "and", "self", ".", "training", ":", "\n", "            ", "coeff", "=", "calc_coeff", "(", "self", ".", "iter_num", ",", "self", ".", "high", ",", "self", ".", "low", ",", "self", ".", "alpha", ",", "self", ".", "max_iter", ")", "\n", "x", "=", "x", "*", "1.0", "\n", "x", ".", "register_hook", "(", "grl_hook", "(", "coeff", ")", ")", "\n", "", "x", "=", "self", ".", "ad_layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu1", "(", "x", ")", "\n", "x", "=", "self", ".", "dropout1", "(", "x", ")", "\n", "x", "=", "self", ".", "ad_layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "relu2", "(", "x", ")", "\n", "x", "=", "self", ".", "dropout2", "(", "x", ")", "\n", "y", "=", "self", ".", "ad_layer3", "(", "x", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.Multi_AdversarialNetwork.output_num": [[246, 248], ["None"], "methods", ["None"], ["", "def", "output_num", "(", "self", ")", ":", "\n", "        ", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.Multi_AdversarialNetwork.get_parameters": [[249, 251], ["train_alda.Multi_AdversarialNetwork.parameters"], "methods", ["None"], ["", "def", "get_parameters", "(", "self", ")", ":", "\n", "        ", "return", "[", "{", "\"params\"", ":", "self", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "1.0", "}", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.train_alda": [[16, 142], ["train_alda.get_data_loaders", "train_alda.Multi_AdversarialNetwork", "Multi_AdversarialNetwork.cuda", "torch.CrossEntropyLoss", "iter", "iter", "range", "torch.save", "torch.save", "model.load_state_dict", "torch.optim.sgd.SGD", "torch.optim.lr_scheduler.LambdaLR", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "utils.train_utils.cycle", "utils.train_utils.cycle", "tqdm.tqdm", "utils.train_utils.AverageMeter", "utils.train_utils.AverageMeter", "utils.train_utils.AverageMeter", "model.train", "Multi_AdversarialNetwork.train", "tqdm.tqdm.close", "model.eval", "evaluation.validation", "torch.load", "torch.load", "range", "torch.optim.Adam.zero_grad", "x_s[].cuda", "model", "model", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "Multi_AdversarialNetwork.", "competitors.ALDA_loss", "train_alda.calc_coeff", "model.parameters", "reg_loss.backward", "model.parameters", "nn.CrossEntropyLoss.", "total_loss.backward", "torch.optim.Adam.step", "torch.optim.lr_scheduler.CosineAnnealingLR.step", "utils.train_utils.AverageMeter.update", "utils.train_utils.AverageMeter.update", "tqdm.tqdm.set_postfix", "model.state_dict", "model.spatial_encoder.parameters", "model.temporal_encoder.parameters", "model.decoder.parameters", "train_alda.Multi_AdversarialNetwork.get_parameters", "list", "list", "next", "next", "torch.Softmax", "total_loss.item", "utils.metrics.accuracy", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "model.parameters", "Multi_AdversarialNetwork.parameters", "utils.train_utils.to_cuda", "utils.train_utils.to_cuda", "float"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.get_data_loaders", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.alda.loss.ALDA_loss", "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.calc_coeff", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.DomainDiscriminator.get_parameters", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda"], ["def", "train_alda", "(", "\n", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", "\n", ")", ":", "\n", "    ", "source_loader", ",", "target_loader", "=", "get_data_loaders", "(", "splits", ",", "config", ")", "\n", "\n", "if", "config", ".", "weights", "is", "not", "None", ":", "\n", "        ", "pretrained_path", "=", "f\"{config.weights}/fold_{fold_num}\"", "\n", "pretrained_weights", "=", "torch", ".", "load", "(", "f\"{pretrained_path}/model.pt\"", ")", "[", "\"state_dict\"", "]", "\n", "model", ".", "load_state_dict", "(", "pretrained_weights", ")", "\n", "\n", "", "features_dim", "=", "128", "\n", "hidden_size", "=", "1024", "\n", "class_num", "=", "config", ".", "num_classes", "\n", "ad_net", "=", "Multi_AdversarialNetwork", "(", "features_dim", ",", "hidden_size", ",", "class_num", ")", "\n", "ad_net", ".", "cuda", "(", ")", "\n", "\n", "if", "config", ".", "use_default_optim", ":", "\n", "        ", "base_lr", "=", "1.0", "\n", "classifier_params", "=", "[", "\n", "{", "\"params\"", ":", "model", ".", "spatial_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "temporal_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "decoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "1.0", "*", "base_lr", "}", ",", "\n", "]", "\n", "lr_gamma", "=", "0.001", "\n", "lr_decay", "=", "0.75", "\n", "optimizer", "=", "SGD", "(", "\n", "classifier_params", "+", "ad_net", ".", "get_parameters", "(", ")", ",", "\n", "config", ".", "lr", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", "nesterov", "=", "True", ",", "\n", ")", "\n", "lr_scheduler", "=", "LambdaLR", "(", "\n", "optimizer", ",", "lambda", "x", ":", "config", ".", "lr", "*", "(", "1.0", "+", "lr_gamma", "*", "float", "(", "x", ")", ")", "**", "(", "-", "lr_decay", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "list", "(", "model", ".", "parameters", "(", ")", ")", "+", "list", "(", "ad_net", ".", "parameters", "(", ")", ")", ",", "\n", "lr", "=", "config", ".", "lr", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "\n", "optimizer", ",", "T_max", "=", "config", ".", "epochs", "*", "config", ".", "steps_per_epoch", ",", "eta_min", "=", "0", "\n", ")", "\n", "\n", "## train", "\n", "", "best_f1", "=", "0.0", "\n", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "global_step", "=", "0", "\n", "source_iter", "=", "iter", "(", "cycle", "(", "source_loader", ")", ")", "\n", "target_iter", "=", "iter", "(", "cycle", "(", "target_loader", ")", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "config", ".", "epochs", ")", ":", "\n", "        ", "progress_bar", "=", "tqdm", "(", "\n", "range", "(", "config", ".", "steps_per_epoch", ")", ",", "\n", "desc", "=", "f\"ALDA Epoch {epoch + 1}/{config.epochs}\"", ",", "\n", ")", "\n", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "class_accs", "=", "AverageMeter", "(", ")", "\n", "domain_accs", "=", "AverageMeter", "(", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "ad_net", ".", "train", "(", ")", "\n", "\n", "for", "i", "in", "progress_bar", ":", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "x_s", ",", "x_t", "=", "next", "(", "source_iter", ")", ",", "next", "(", "target_iter", ")", "\n", "labels_s", "=", "x_s", "[", "\"label\"", "]", ".", "cuda", "(", ")", "\n", "\n", "y_s", ",", "f_s", "=", "model", "(", "*", "to_cuda", "(", "x_s", ",", "device", ")", ",", "return_feats", "=", "True", ")", "\n", "y_t", ",", "f_t", "=", "model", "(", "*", "to_cuda", "(", "x_t", ",", "device", ")", ",", "return_feats", "=", "True", ")", "\n", "features", "=", "torch", ".", "cat", "(", "(", "f_s", ",", "f_t", ")", ",", "dim", "=", "0", ")", "\n", "outputs", "=", "torch", ".", "cat", "(", "(", "y_s", ",", "y_t", ")", ",", "dim", "=", "0", ")", "\n", "softmax_out", "=", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "outputs", ")", "\n", "\n", "ad_out", "=", "ad_net", "(", "features", ")", "\n", "adv_loss", ",", "reg_loss", ",", "correct_loss", "=", "loss", ".", "ALDA_loss", "(", "ad_out", ",", "labels_s", ",", "\n", "softmax_out", ",", "threshold", "=", "config", ".", "pseudo_threshold", ")", "\n", "\n", "adv_weight", "=", "config", ".", "trade_off", "\n", "trade_off", "=", "calc_coeff", "(", "i", ",", "high", "=", "1.0", ")", "\n", "\n", "transfer_loss", "=", "adv_weight", "*", "adv_loss", "+", "adv_weight", "*", "trade_off", "*", "correct_loss", "\n", "\n", "\n", "# reg_loss is only backward to the discriminator", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "", "reg_loss", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "for", "param", "in", "model", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "True", "\n", "\n", "", "cls_loss", "=", "criterion", "(", "y_s", ",", "labels_s", ")", "\n", "\n", "total_loss", "=", "cls_loss", "+", "transfer_loss", "\n", "\n", "total_loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "\n", "losses", ".", "update", "(", "total_loss", ".", "item", "(", ")", ")", "\n", "class_accs", ".", "update", "(", "accuracy", "(", "y_s", ",", "labels_s", ")", ",", "config", ".", "batch_size", ")", "\n", "\n", "progress_bar", ".", "set_postfix", "(", "\n", "loss", "=", "f\"{losses.avg:.3f}\"", ",", "\n", "class_acc", "=", "f\"{class_accs.avg:.2f}\"", ",", "\n", "domain_acc", "=", "f\"{domain_accs.avg:.2f}\"", ",", "\n", ")", "\n", "if", "global_step", "%", "config", ".", "log_step", "==", "0", ":", "\n", "                ", "writer", ".", "add_scalar", "(", "\"train/loss\"", ",", "losses", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/accuracy\"", ",", "class_accs", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\n", "\"train/lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "global_step", "\n", ")", "\n", "", "global_step", "+=", "1", "\n", "\n", "", "progress_bar", ".", "close", "(", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "\n", "best_f1", ",", "None", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "model", ",", "val_loader", ",", "writer", "\n", ")", "\n", "\n", "# save final model and use for evaluation", "\n", "", "torch", ".", "save", "(", "{", "\"state_dict\"", ":", "model", ".", "state_dict", "(", ")", "}", ",", "best_model_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.get_data_loaders": [[144, 190], ["torchvision.transforms.Compose", "dataset.PixelSetData", "train_alda.get_data_loaders.create_data_loader"], "function", ["None"], ["", "def", "get_data_loaders", "(", "splits", ",", "config", ")", ":", "\n", "    ", "def", "create_data_loader", "(", "dataset", ")", ":", "\n", "        ", "return", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "", "train_transform", "=", "transforms", ".", "Compose", "(", "\n", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", ",", "\n", "RandomTemporalShift", "(", "max_shift", "=", "config", ".", "max_shift_aug", ",", "p", "=", "config", ".", "shift_aug_p", ")", "if", "config", ".", "with_shift_aug", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "source_dataset", "=", "PixelSetData", "(", "\n", "config", ".", "data_root", ",", "\n", "config", ".", "source", ",", "\n", "config", ".", "classes", ",", "\n", "train_transform", ",", "\n", "indices", "=", "splits", "[", "config", ".", "source", "]", "[", "\"train\"", "]", ",", "\n", ")", "\n", "source_loader", "=", "create_data_loader", "(", "source_dataset", ")", "\n", "target_dataset", "=", "PixelSetData", "(", "\n", "config", ".", "data_root", ",", "\n", "config", ".", "target", ",", "\n", "config", ".", "classes", ",", "\n", "train_transform", ",", "\n", "indices", "=", "splits", "[", "config", ".", "target", "]", "[", "\"train\"", "]", ",", "\n", ")", "\n", "target_loader", "=", "create_data_loader", "(", "target_dataset", ")", "\n", "\n", "print", "(", "\n", "f\"size of source dataset: {len(source_dataset)} ({len(source_loader)} batches)\"", "\n", ")", "\n", "print", "(", "\n", "f\"size of target dataset: {len(target_dataset)} ({len(target_loader)} batches)\"", "\n", ")", "\n", "\n", "return", "source_loader", ",", "target_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.calc_coeff": [[191, 193], ["numpy.float", "numpy.exp"], "function", ["None"], ["", "def", "calc_coeff", "(", "iter_num", ",", "high", "=", "1.0", ",", "low", "=", "0.0", ",", "alpha", "=", "10.0", ",", "max_iter", "=", "10000.0", ")", ":", "\n", "    ", "return", "np", ".", "float", "(", "2.0", "*", "(", "high", "-", "low", ")", "/", "(", "1.0", "+", "np", ".", "exp", "(", "-", "alpha", "*", "iter_num", "/", "max_iter", ")", ")", "-", "(", "high", "-", "low", ")", "+", "low", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.init_weights": [[194, 205], ["torch.init.kaiming_uniform_", "torch.init.zeros_", "classname.find", "classname.find", "classname.find", "torch.init.normal_", "torch.init.zeros_", "classname.find", "torch.init.xavier_normal_", "torch.init.zeros_"], "function", ["None"], ["", "def", "init_weights", "(", "m", ")", ":", "\n", "    ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'Conv2d'", ")", "!=", "-", "1", "or", "classname", ".", "find", "(", "'ConvTranspose2d'", ")", "!=", "-", "1", ":", "\n", "        ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "m", ".", "bias", ")", "\n", "", "elif", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "        ", "nn", ".", "init", ".", "normal_", "(", "m", ".", "weight", ",", "1.0", ",", "0.02", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "m", ".", "bias", ")", "\n", "", "elif", "classname", ".", "find", "(", "'Linear'", ")", "!=", "-", "1", ":", "\n", "        ", "nn", ".", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ")", "\n", "nn", ".", "init", ".", "zeros_", "(", "m", ".", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.train_alda.grl_hook": [[206, 210], ["grad.clone"], "function", ["None"], ["", "", "def", "grl_hook", "(", "coeff", ")", ":", "\n", "    ", "def", "fun1", "(", "grad", ")", ":", "\n", "        ", "return", "-", "coeff", "*", "grad", ".", "clone", "(", ")", "\n", "", "return", "fun1", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.loss.create_matrix": [[6, 23], ["numpy.zeros", "range", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "range", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["def", "create_matrix", "(", "n", ")", ":", "\n", "    ", "\"\"\"\n    :param n: matrix size (class num)\n    :return a matrix with torch.tensor type:\n    for example n=3:\n    1     -1/2  -1/2\n    -1/2    1   -1/2\n    -1/2  -1/2    1\n    \"\"\"", "\n", "a", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "n", ")", ":", "\n", "            ", "if", "i", "==", "j", ":", "\n", "                ", "a", "[", "i", ",", "j", "]", "=", "1", "\n", "", "else", ":", "\n", "                ", "a", "[", "i", ",", "j", "]", "=", "-", "1", "/", "(", "n", "-", "1", ")", "\n", "", "", "", "return", "torch", ".", "from_numpy", "(", "a", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.alda.loss.ALDA_loss": [[24, 74], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid.size", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "softmax_out[].detach", "softmax_out[].detach", "torch.max", "torch.max", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.max", "torch.max", "torch.zeros().to().scatter_", "torch.zeros().to().scatter_", "torch.where", "torch.where", "loss.create_matrix", "torch.cat", "torch.cat", "torch.mul().sum", "torch.mul().sum", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.mul().sum", "torch.mul().sum", "torch.mean", "torch.mean", "torch.sigmoid.size", "labels_source.unsqueeze", "argpred.unsqueeze", "argpred.unsqueeze", "target_mask.unsqueeze", "torch.zeros().to", "torch.zeros().to", "torch.mul", "torch.mul", "torch.sum", "torch.sum", "torch.cat.float().sum", "torch.CrossEntropyLoss", "torch.mul", "torch.mul", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "create_matrix.unsqueeze", "torch.sigmoid.unsqueeze", "torch.mul", "torch.mul", "torch.BCELoss", "torch.mul", "torch.mul", "torch.zeros", "torch.zeros", "torch.cat.unsqueeze", "torch.cat.float", "torch.where.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "create_matrix.detach", "torch.eye", "torch.eye"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.alda.loss.create_matrix"], ["", "def", "ALDA_loss", "(", "ad_out_score", ",", "labels_source", ",", "softmax_out", ",", "threshold", "=", "0.9", ")", ":", "\n", "    ", "\"\"\"\n    :param ad_out_score: the discriminator output (N, C, H, W)\n    :param labels_source: the source ground truth (N, H, W)\n    :param softmax_out: the model prediction probability (N, C, H, W)\n    :return: \n    adv_loss: adversarial learning loss\n    reg_loss: regularization term for the discriminator\n    correct_loss: corrected self-training loss\n    \"\"\"", "\n", "ad_out", "=", "torch", ".", "sigmoid", "(", "ad_out_score", ")", "\n", "\n", "batch_size", "=", "ad_out", ".", "size", "(", "0", ")", "//", "2", "\n", "class_num", "=", "ad_out", ".", "size", "(", "1", ")", "\n", "\n", "labels_source_mask", "=", "torch", ".", "zeros", "(", "batch_size", ",", "class_num", ")", ".", "to", "(", "ad_out", ".", "device", ")", ".", "scatter_", "(", "1", ",", "labels_source", ".", "unsqueeze", "(", "1", ")", ",", "1", ")", "\n", "probs_source", "=", "softmax_out", "[", ":", "batch_size", "]", ".", "detach", "(", ")", "\n", "probs_target", "=", "softmax_out", "[", "batch_size", ":", "]", ".", "detach", "(", ")", "\n", "maxpred", ",", "argpred", "=", "torch", ".", "max", "(", "probs_source", ",", "dim", "=", "1", ")", "\n", "preds_source_mask", "=", "torch", ".", "zeros", "(", "batch_size", ",", "class_num", ")", ".", "to", "(", "ad_out", ".", "device", ")", ".", "scatter_", "(", "1", ",", "argpred", ".", "unsqueeze", "(", "1", ")", ",", "1", ")", "\n", "maxpred", ",", "argpred", "=", "torch", ".", "max", "(", "probs_target", ",", "dim", "=", "1", ")", "\n", "preds_target_mask", "=", "torch", ".", "zeros", "(", "batch_size", ",", "class_num", ")", ".", "to", "(", "ad_out", ".", "device", ")", ".", "scatter_", "(", "1", ",", "argpred", ".", "unsqueeze", "(", "1", ")", ",", "1", ")", "\n", "\n", "# filter out those low confidence samples", "\n", "target_mask", "=", "(", "maxpred", ">", "threshold", ")", "\n", "preds_target_mask", "=", "torch", ".", "where", "(", "target_mask", ".", "unsqueeze", "(", "1", ")", ",", "preds_target_mask", ",", "torch", ".", "zeros", "(", "1", ")", ".", "to", "(", "ad_out", ".", "device", ")", ")", "\n", "# construct the confusion matrix from ad_out. See the paper for more details.", "\n", "confusion_matrix", "=", "create_matrix", "(", "class_num", ")", "\n", "ant_eye", "=", "(", "1", "-", "torch", ".", "eye", "(", "class_num", ")", ")", ".", "cuda", "(", ")", ".", "unsqueeze", "(", "0", ")", "\n", "confusion_matrix", "=", "ant_eye", "/", "(", "class_num", "-", "1", ")", "+", "torch", ".", "mul", "(", "confusion_matrix", ".", "unsqueeze", "(", "0", ")", ",", "ad_out", ".", "unsqueeze", "(", "1", ")", ")", "#(2*batch_size, class_num, class_num)", "\n", "preds_mask", "=", "torch", ".", "cat", "(", "[", "preds_source_mask", ",", "preds_target_mask", "]", ",", "dim", "=", "0", ")", "#labels_source_mask", "\n", "loss_pred", "=", "torch", ".", "mul", "(", "confusion_matrix", ",", "preds_mask", ".", "unsqueeze", "(", "1", ")", ")", ".", "sum", "(", "dim", "=", "2", ")", "\n", "# different correction targets for different domains", "\n", "loss_target", "=", "(", "1", "-", "preds_target_mask", ")", "/", "(", "class_num", "-", "1", ")", "\n", "loss_target", "=", "torch", ".", "cat", "(", "[", "labels_source_mask", ",", "loss_target", "]", ",", "dim", "=", "0", ")", "\n", "if", "not", "(", "(", "loss_pred", ">=", "0", ")", ".", "all", "(", ")", "and", "(", "loss_pred", "<=", "1", ")", ".", "all", "(", ")", ")", ":", "\n", "        ", "raise", "AssertionError", "\n", "", "mask", "=", "torch", ".", "cat", "(", "[", "(", "maxpred", ">=", "0", ")", ",", "target_mask", "]", ",", "dim", "=", "0", ")", "\n", "adv_loss", "=", "nn", ".", "BCELoss", "(", "reduction", "=", "'none'", ")", "(", "loss_pred", ",", "loss_target", ")", "[", "mask", "]", "\n", "adv_loss", "=", "torch", ".", "sum", "(", "adv_loss", ")", "/", "mask", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "\n", "# reg_loss", "\n", "reg_loss", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "(", "ad_out_score", "[", ":", "batch_size", "]", ",", "labels_source", ")", "\n", "\n", "# corrected target loss function", "\n", "target_probs", "=", "1.0", "*", "softmax_out", "[", "batch_size", ":", "]", "\n", "correct_target", "=", "torch", ".", "mul", "(", "confusion_matrix", ".", "detach", "(", ")", "[", "batch_size", ":", "]", ",", "preds_target_mask", ".", "unsqueeze", "(", "1", ")", ")", ".", "sum", "(", "dim", "=", "2", ")", "\n", "correct_loss", "=", "-", "torch", ".", "mul", "(", "target_probs", ",", "correct_target", ")", "\n", "correct_loss", "=", "torch", ".", "mean", "(", "correct_loss", "[", "target_mask", "]", ")", "\n", "return", "adv_loss", ",", "reg_loss", ",", "correct_loss", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.forward": [[10, 15], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ":", "Any", ",", "input", ":", "torch", ".", "Tensor", ",", "coeff", ":", "Optional", "[", "float", "]", "=", "1.", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "ctx", ".", "coeff", "=", "coeff", "\n", "output", "=", "input", "*", "1.0", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward": [[16, 19], ["grad_output.neg"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ":", "Any", ",", "grad_output", ":", "torch", ".", "Tensor", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "Any", "]", ":", "\n", "        ", "return", "grad_output", ".", "neg", "(", ")", "*", "ctx", ".", "coeff", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseLayer.__init__": [[22, 24], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "GradientReverseLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseLayer.forward": [[25, 27], ["GradientReverseFunction.apply"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "*", "input", ")", ":", "\n", "        ", "return", "GradientReverseFunction", ".", "apply", "(", "*", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.__init__": [[55, 64], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "alpha", ":", "Optional", "[", "float", "]", "=", "1.0", ",", "lo", ":", "Optional", "[", "float", "]", "=", "0.0", ",", "hi", ":", "Optional", "[", "float", "]", "=", "1.", ",", "\n", "max_iters", ":", "Optional", "[", "int", "]", "=", "1000.", ",", "auto_step", ":", "Optional", "[", "bool", "]", "=", "False", ")", ":", "\n", "        ", "super", "(", "WarmStartGradientReverseLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "lo", "=", "lo", "\n", "self", ".", "hi", "=", "hi", "\n", "self", ".", "iter_num", "=", "0", "\n", "self", ".", "max_iters", "=", "max_iters", "\n", "self", ".", "auto_step", "=", "auto_step", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.forward": [[65, 74], ["numpy.float", "GradientReverseFunction.apply", "grl.WarmStartGradientReverseLayer.step", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step"], ["", "def", "forward", "(", "self", ",", "input", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "\"\"\"\"\"\"", "\n", "coeff", "=", "np", ".", "float", "(", "\n", "2.0", "*", "(", "self", ".", "hi", "-", "self", ".", "lo", ")", "/", "(", "1.0", "+", "np", ".", "exp", "(", "-", "self", ".", "alpha", "*", "self", ".", "iter_num", "/", "self", ".", "max_iters", ")", ")", "\n", "-", "(", "self", ".", "hi", "-", "self", ".", "lo", ")", "+", "self", ".", "lo", "\n", ")", "\n", "if", "self", ".", "auto_step", ":", "\n", "            ", "self", ".", "step", "(", ")", "\n", "", "return", "GradientReverseFunction", ".", "apply", "(", "input", ",", "coeff", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step": [[75, 78], ["None"], "methods", ["None"], ["", "def", "step", "(", "self", ")", ":", "\n", "        ", "\"\"\"Increase iteration number :math:`i` by 1\"\"\"", "\n", "self", ".", "iter_num", "+=", "1", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.DomainDiscriminator.__init__": [[229, 251], ["torch.Sequential.__init__", "torch.Sequential.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "in_feature", ":", "int", ",", "hidden_size", ":", "int", ",", "batch_norm", "=", "True", ")", ":", "\n", "        ", "if", "batch_norm", ":", "\n", "            ", "super", "(", "DomainDiscriminator", ",", "self", ")", ".", "__init__", "(", "\n", "nn", ".", "Linear", "(", "in_feature", ",", "hidden_size", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "super", "(", "DomainDiscriminator", ",", "self", ")", ".", "__init__", "(", "\n", "nn", ".", "Linear", "(", "in_feature", ",", "hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Dropout", "(", "0.5", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Dropout", "(", "0.5", ")", ",", "\n", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ")", ",", "\n", "nn", ".", "Sigmoid", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.DomainDiscriminator.get_parameters": [[253, 255], ["dann.DomainDiscriminator.parameters"], "methods", ["None"], ["", "", "def", "get_parameters", "(", "self", ")", "->", "List", "[", "Dict", "]", ":", "\n", "        ", "return", "[", "{", "\"params\"", ":", "self", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "1.0", "}", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.DomainAdversarialLoss.__init__": [[292, 311], ["torch.Module.__init__", "competitors.dann.grl.WarmStartGradientReverseLayer", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "domain_discriminator", ":", "nn", ".", "Module", ",", "\n", "reduction", ":", "Optional", "[", "str", "]", "=", "\"mean\"", ",", "\n", "grl", ":", "Optional", "=", "None", ",", "\n", ")", ":", "\n", "        ", "super", "(", "DomainAdversarialLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "grl", "=", "(", "\n", "WarmStartGradientReverseLayer", "(", "\n", "alpha", "=", "1.0", ",", "lo", "=", "0.0", ",", "hi", "=", "1.0", ",", "max_iters", "=", "1000", ",", "auto_step", "=", "True", "\n", ")", "\n", "if", "grl", "is", "None", "\n", "else", "grl", "\n", ")", "\n", "self", ".", "domain_discriminator", "=", "domain_discriminator", "\n", "self", ".", "bce", "=", "lambda", "input", ",", "target", ",", "weight", ":", "F", ".", "binary_cross_entropy", "(", "\n", "input", ",", "target", ",", "weight", "=", "weight", ",", "reduction", "=", "reduction", "\n", ")", "\n", "self", ".", "domain_discriminator_accuracy", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.DomainAdversarialLoss.forward": [[312, 335], ["dann.DomainAdversarialLoss.grl", "dann.DomainAdversarialLoss.domain_discriminator", "dann.DomainAdversarialLoss.chunk", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "dann.binary_accuracy", "dann.binary_accuracy", "dann.DomainAdversarialLoss.bce", "dann.DomainAdversarialLoss.bce", "torch.ones_like.view_as", "torch.ones_like.view_as", "torch.ones_like.view_as", "torch.ones_like.view_as", "torch.ones_like.view_as", "torch.ones_like.view_as", "torch.ones_like.view_as", "torch.ones_like.view_as", "f_s.size", "f_t.size"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.binary_accuracy", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.binary_accuracy"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "f_s", ":", "torch", ".", "Tensor", ",", "\n", "f_t", ":", "torch", ".", "Tensor", ",", "\n", "w_s", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "w_t", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "f", "=", "self", ".", "grl", "(", "torch", ".", "cat", "(", "(", "f_s", ",", "f_t", ")", ",", "dim", "=", "0", ")", ")", "\n", "d", "=", "self", ".", "domain_discriminator", "(", "f", ")", "\n", "d_s", ",", "d_t", "=", "d", ".", "chunk", "(", "2", ",", "dim", "=", "0", ")", "\n", "d_label_s", "=", "torch", ".", "ones", "(", "(", "f_s", ".", "size", "(", "0", ")", ",", "1", ")", ")", ".", "to", "(", "f_s", ".", "device", ")", "\n", "d_label_t", "=", "torch", ".", "zeros", "(", "(", "f_t", ".", "size", "(", "0", ")", ",", "1", ")", ")", ".", "to", "(", "f_t", ".", "device", ")", "\n", "self", ".", "domain_discriminator_accuracy", "=", "0.5", "*", "(", "\n", "binary_accuracy", "(", "d_s", ",", "d_label_s", ")", "+", "binary_accuracy", "(", "d_t", ",", "d_label_t", ")", "\n", ")", "\n", "\n", "if", "w_s", "is", "None", ":", "\n", "            ", "w_s", "=", "torch", ".", "ones_like", "(", "d_label_s", ")", "\n", "", "if", "w_t", "is", "None", ":", "\n", "            ", "w_t", "=", "torch", ".", "ones_like", "(", "d_label_t", ")", "\n", "", "return", "0.5", "*", "(", "\n", "self", ".", "bce", "(", "d_s", ",", "d_label_s", ",", "w_s", ".", "view_as", "(", "d_s", ")", ")", "\n", "+", "self", ".", "bce", "(", "d_t", ",", "d_label_t", ",", "w_t", ".", "view_as", "(", "d_t", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.ConditionalDomainAdversarialLoss.__init__": [[399, 432], ["torch.Module.__init__", "competitors.dann.grl.WarmStartGradientReverseLayer", "dann.RandomizedMultiLinearMap", "dann.MultiLinearMap", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy", "torch.binary_cross_entropy"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "domain_discriminator", ":", "nn", ".", "Module", ",", "\n", "entropy_conditioning", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", "randomized", ":", "Optional", "[", "bool", "]", "=", "False", ",", "\n", "num_classes", ":", "Optional", "[", "int", "]", "=", "-", "1", ",", "\n", "features_dim", ":", "Optional", "[", "int", "]", "=", "-", "1", ",", "\n", "randomized_dim", ":", "Optional", "[", "int", "]", "=", "1024", ",", "\n", "reduction", ":", "Optional", "[", "str", "]", "=", "\"mean\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", "ConditionalDomainAdversarialLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "domain_discriminator", "=", "domain_discriminator", "\n", "self", ".", "grl", "=", "WarmStartGradientReverseLayer", "(", "\n", "alpha", "=", "1.0", ",", "lo", "=", "0.0", ",", "hi", "=", "1.0", ",", "max_iters", "=", "1000", ",", "auto_step", "=", "True", "\n", ")", "\n", "self", ".", "entropy_conditioning", "=", "entropy_conditioning", "\n", "\n", "if", "randomized", ":", "\n", "            ", "assert", "num_classes", ">", "0", "and", "features_dim", ">", "0", "and", "randomized_dim", ">", "0", "\n", "self", ".", "map", "=", "RandomizedMultiLinearMap", "(", "\n", "features_dim", ",", "num_classes", ",", "randomized_dim", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "map", "=", "MultiLinearMap", "(", ")", "\n", "\n", "", "self", ".", "bce", "=", "(", "\n", "lambda", "input", ",", "target", ",", "weight", ":", "F", ".", "binary_cross_entropy", "(", "\n", "input", ",", "target", ",", "weight", ",", "reduction", "=", "reduction", "\n", ")", "\n", "if", "self", ".", "entropy_conditioning", "\n", "else", "F", ".", "binary_cross_entropy", "(", "input", ",", "target", ",", "reduction", "=", "reduction", ")", "\n", ")", "\n", "self", ".", "domain_discriminator_accuracy", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.ConditionalDomainAdversarialLoss.forward": [[433, 452], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax().detach", "torch.softmax().detach", "torch.softmax().detach", "torch.softmax().detach", "dann.ConditionalDomainAdversarialLoss.grl", "dann.ConditionalDomainAdversarialLoss.domain_discriminator", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "dann.binary_accuracy", "dann.ConditionalDomainAdversarialLoss.bce", "dann.ConditionalDomainAdversarialLoss.map", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "weight.view_as", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "dann.entropy", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "g_s.size", "g_t.size"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.binary_accuracy", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.entropy"], ["", "def", "forward", "(", "\n", "self", ",", "g_s", ":", "torch", ".", "Tensor", ",", "f_s", ":", "torch", ".", "Tensor", ",", "g_t", ":", "torch", ".", "Tensor", ",", "f_t", ":", "torch", ".", "Tensor", "\n", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "f", "=", "torch", ".", "cat", "(", "(", "f_s", ",", "f_t", ")", ",", "dim", "=", "0", ")", "\n", "g", "=", "torch", ".", "cat", "(", "(", "g_s", ",", "g_t", ")", ",", "dim", "=", "0", ")", "\n", "g", "=", "F", ".", "softmax", "(", "g", ",", "dim", "=", "1", ")", ".", "detach", "(", ")", "\n", "h", "=", "self", ".", "grl", "(", "self", ".", "map", "(", "f", ",", "g", ")", ")", "\n", "d", "=", "self", ".", "domain_discriminator", "(", "h", ")", "\n", "d_label", "=", "torch", ".", "cat", "(", "\n", "(", "\n", "torch", ".", "ones", "(", "(", "g_s", ".", "size", "(", "0", ")", ",", "1", ")", ")", ".", "to", "(", "g_s", ".", "device", ")", ",", "\n", "torch", ".", "zeros", "(", "(", "g_t", ".", "size", "(", "0", ")", ",", "1", ")", ")", ".", "to", "(", "g_t", ".", "device", ")", ",", "\n", ")", "\n", ")", "\n", "weight", "=", "1.0", "+", "torch", ".", "exp", "(", "-", "entropy", "(", "g", ")", ")", "\n", "batch_size", "=", "f", ".", "size", "(", "0", ")", "\n", "weight", "=", "weight", "/", "torch", ".", "sum", "(", "weight", ")", "*", "batch_size", "\n", "self", ".", "domain_discriminator_accuracy", "=", "binary_accuracy", "(", "d", ",", "d_label", ")", "\n", "return", "self", ".", "bce", "(", "d", ",", "d_label", ",", "weight", ".", "view_as", "(", "d", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.RandomizedMultiLinearMap.__init__": [[471, 478], ["torch.Module.__init__", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "\n", "self", ",", "features_dim", ":", "int", ",", "num_classes", ":", "int", ",", "output_dim", ":", "Optional", "[", "int", "]", "=", "1024", "\n", ")", ":", "\n", "        ", "super", "(", "RandomizedMultiLinearMap", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "Rf", "=", "torch", ".", "randn", "(", "features_dim", ",", "output_dim", ")", "\n", "self", ".", "Rg", "=", "torch", ".", "randn", "(", "num_classes", ",", "output_dim", ")", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.RandomizedMultiLinearMap.forward": [[479, 484], ["torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "dann.RandomizedMultiLinearMap.Rf.to", "dann.RandomizedMultiLinearMap.Rg.to", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "torch.mul", "numpy.sqrt", "float"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "f", ":", "torch", ".", "Tensor", ",", "g", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "f", "=", "torch", ".", "mm", "(", "f", ",", "self", ".", "Rf", ".", "to", "(", "f", ".", "device", ")", ")", "\n", "g", "=", "torch", ".", "mm", "(", "g", ",", "self", ".", "Rg", ".", "to", "(", "g", ".", "device", ")", ")", "\n", "output", "=", "torch", ".", "mul", "(", "f", ",", "g", ")", "/", "np", ".", "sqrt", "(", "float", "(", "self", ".", "output_dim", ")", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.MultiLinearMap.__init__": [[494, 496], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "MultiLinearMap", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.MultiLinearMap.forward": [[497, 501], ["f.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm.view", "torch.bmm.view", "torch.bmm.view", "torch.bmm.view", "g.unsqueeze", "f.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "f", ":", "torch", ".", "Tensor", ",", "g", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "batch_size", "=", "f", ".", "size", "(", "0", ")", "\n", "output", "=", "torch", ".", "bmm", "(", "g", ".", "unsqueeze", "(", "2", ")", ",", "f", ".", "unsqueeze", "(", "1", ")", ")", "\n", "return", "output", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.train_dann": [[23, 161], ["dann.get_data_loaders", "torch.CrossEntropyLoss", "iter", "iter", "range", "torch.save", "torch.save", "torch.save", "torch.save", "model.load_state_dict", "DomainDiscriminator().to", "DomainAdversarialLoss().to", "torch.optim.sgd.SGD", "torch.optim.lr_scheduler.LambdaLR", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "utils.train_utils.cycle", "utils.train_utils.cycle", "tqdm.tqdm", "utils.train_utils.AverageMeter", "utils.train_utils.AverageMeter", "utils.train_utils.AverageMeter", "model.train", "ConditionalDomainAdversarialLoss().to.train", "tqdm.tqdm.close", "model.eval", "evaluation.validation", "torch.load", "torch.load", "torch.load", "torch.load", "ConditionalDomainAdversarialLoss().to", "range", "x_s[].cuda", "utils.train_utils.cat_samples", "model", "y.chunk", "f.chunk", "nn.CrossEntropyLoss.", "torch.optim.Adam.zero_grad", "loss.backward", "torch.optim.Adam.step", "torch.optim.lr_scheduler.CosineAnnealingLR.step", "utils.train_utils.AverageMeter.update", "utils.train_utils.AverageMeter.update", "utils.train_utils.AverageMeter.update", "tqdm.tqdm.set_postfix", "model.state_dict", "dann.DomainDiscriminator", "dann.DomainAdversarialLoss", "DomainDiscriminator().to", "DomainDiscriminator().to", "model.spatial_encoder.parameters", "model.temporal_encoder.parameters", "model.decoder.parameters", "DomainDiscriminator().to.get_parameters", "list", "list", "next", "next", "ConditionalDomainAdversarialLoss().to.", "ConditionalDomainAdversarialLoss().to.", "loss.item", "utils.metrics.accuracy", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "dann.ConditionalDomainAdversarialLoss", "model.parameters", "DomainDiscriminator().to.parameters", "utils.train_utils.to_cuda", "dann.DomainDiscriminator", "dann.DomainDiscriminator", "float"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.get_data_loaders", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cat_samples", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.DomainDiscriminator.get_parameters", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda"], ["def", "train_dann", "(", "\n", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", "\n", ")", ":", "\n", "    ", "source_loader", ",", "target_loader", "=", "get_data_loaders", "(", "splits", ",", "config", ")", "\n", "\n", "if", "config", ".", "weights", "is", "not", "None", ":", "\n", "        ", "pretrained_path", "=", "f\"{config.weights}/fold_{fold_num}\"", "\n", "pretrained_weights", "=", "torch", ".", "load", "(", "f\"{pretrained_path}/model.pt\"", ")", "[", "\"state_dict\"", "]", "\n", "model", ".", "load_state_dict", "(", "pretrained_weights", ")", "\n", "\n", "", "features_dim", "=", "128", "\n", "hidden_size", "=", "1024", "\n", "if", "config", ".", "adv_loss", "==", "\"DANN\"", ":", "\n", "        ", "domain_discri", "=", "DomainDiscriminator", "(", "features_dim", ",", "hidden_size", "=", "hidden_size", ")", ".", "to", "(", "\n", "device", "\n", ")", "\n", "domain_adv", "=", "DomainAdversarialLoss", "(", "domain_discri", ")", ".", "to", "(", "device", ")", "\n", "", "elif", "config", ".", "adv_loss", "in", "[", "\"CDAN\"", ",", "\"CDAN+E\"", "]", ":", "\n", "        ", "use_entropy", "=", "config", ".", "adv_loss", "==", "\"CDAN+E\"", "\n", "use_randomized", "=", "features_dim", "*", "config", ".", "num_classes", ">", "4096", "\n", "randomized_dim", "=", "1024", "\n", "if", "use_randomized", ":", "\n", "            ", "domain_discri", "=", "DomainDiscriminator", "(", "\n", "randomized_dim", ",", "hidden_size", "=", "hidden_size", "\n", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "            ", "domain_discri", "=", "DomainDiscriminator", "(", "\n", "features_dim", "*", "config", ".", "num_classes", ",", "hidden_size", "=", "hidden_size", "\n", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "domain_adv", "=", "ConditionalDomainAdversarialLoss", "(", "\n", "domain_discri", ",", "\n", "entropy_conditioning", "=", "use_entropy", ",", "\n", "num_classes", "=", "config", ".", "num_classes", ",", "\n", "features_dim", "=", "features_dim", ",", "\n", "randomized", "=", "use_randomized", ",", "\n", "randomized_dim", "=", "randomized_dim", ",", "\n", ")", ".", "to", "(", "device", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "if", "config", ".", "use_default_optim", ":", "\n", "        ", "base_lr", "=", "1.0", "\n", "classifier_params", "=", "[", "\n", "{", "\"params\"", ":", "model", ".", "spatial_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "temporal_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "decoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "1.0", "*", "base_lr", "}", ",", "\n", "]", "\n", "lr_gamma", "=", "0.001", "\n", "lr_decay", "=", "0.75", "\n", "optimizer", "=", "SGD", "(", "\n", "classifier_params", "+", "domain_discri", ".", "get_parameters", "(", ")", ",", "\n", "config", ".", "lr", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", "nesterov", "=", "True", ",", "\n", ")", "\n", "lr_scheduler", "=", "LambdaLR", "(", "\n", "optimizer", ",", "lambda", "x", ":", "config", ".", "lr", "*", "(", "1.0", "+", "lr_gamma", "*", "float", "(", "x", ")", ")", "**", "(", "-", "lr_decay", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "list", "(", "model", ".", "parameters", "(", ")", ")", "+", "list", "(", "domain_discri", ".", "parameters", "(", ")", ")", ",", "\n", "lr", "=", "config", ".", "lr", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "\n", "optimizer", ",", "T_max", "=", "config", ".", "epochs", "*", "config", ".", "steps_per_epoch", ",", "eta_min", "=", "0", "\n", ")", "\n", "\n", "## train", "\n", "", "best_f1", "=", "0.0", "\n", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "global_step", "=", "0", "\n", "source_iter", "=", "iter", "(", "cycle", "(", "source_loader", ")", ")", "\n", "target_iter", "=", "iter", "(", "cycle", "(", "target_loader", ")", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "config", ".", "epochs", ")", ":", "\n", "        ", "progress_bar", "=", "tqdm", "(", "\n", "range", "(", "config", ".", "steps_per_epoch", ")", ",", "\n", "desc", "=", "f\"{config.adv_loss} Epoch {epoch + 1}/{config.epochs}\"", ",", "\n", ")", "\n", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "class_accs", "=", "AverageMeter", "(", ")", "\n", "domain_accs", "=", "AverageMeter", "(", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "domain_adv", ".", "train", "(", ")", "\n", "\n", "for", "_", "in", "progress_bar", ":", "\n", "            ", "x_s", ",", "x_t", "=", "next", "(", "source_iter", ")", ",", "next", "(", "target_iter", ")", "\n", "labels_s", "=", "x_s", "[", "\"label\"", "]", ".", "cuda", "(", ")", "\n", "\n", "x", "=", "cat_samples", "(", "[", "x_s", ",", "x_t", "]", ")", "\n", "y", ",", "f", "=", "model", "(", "*", "to_cuda", "(", "x", ",", "device", ")", ",", "return_feats", "=", "True", ")", "\n", "y_s", ",", "y_t", "=", "y", ".", "chunk", "(", "2", ",", "dim", "=", "0", ")", "\n", "f_s", ",", "f_t", "=", "f", ".", "chunk", "(", "2", ",", "dim", "=", "0", ")", "\n", "\n", "cls_loss", "=", "criterion", "(", "y_s", ",", "labels_s", ")", "\n", "if", "config", ".", "adv_loss", "==", "\"DANN\"", ":", "\n", "                ", "transfer_loss", "=", "domain_adv", "(", "f_s", ",", "f_t", ")", "\n", "", "else", ":", "\n", "                ", "transfer_loss", "=", "domain_adv", "(", "y_s", ",", "f_s", ",", "y_t", ",", "f_t", ")", "\n", "", "domain_acc", "=", "domain_adv", ".", "domain_discriminator_accuracy", "\n", "loss", "=", "cls_loss", "+", "transfer_loss", "*", "config", ".", "trade_off", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "\n", "losses", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "config", ".", "batch_size", ")", "\n", "class_accs", ".", "update", "(", "accuracy", "(", "y_s", ",", "labels_s", ")", ",", "config", ".", "batch_size", ")", "\n", "domain_accs", ".", "update", "(", "domain_acc", ",", "config", ".", "batch_size", ")", "\n", "\n", "progress_bar", ".", "set_postfix", "(", "\n", "loss", "=", "f\"{losses.avg:.3f}\"", ",", "\n", "class_acc", "=", "f\"{class_accs.avg:.2f}\"", ",", "\n", "domain_acc", "=", "f\"{domain_accs.avg:.2f}\"", ",", "\n", ")", "\n", "if", "global_step", "%", "config", ".", "log_step", "==", "0", ":", "\n", "                ", "writer", ".", "add_scalar", "(", "\"train/loss\"", ",", "losses", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/accuracy\"", ",", "class_accs", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\n", "\"train/lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "global_step", "\n", ")", "\n", "", "global_step", "+=", "1", "\n", "\n", "", "progress_bar", ".", "close", "(", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "\n", "best_f1", ",", "None", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "model", ",", "val_loader", ",", "writer", "\n", ")", "\n", "\n", "# save final model and use for evaluation", "\n", "", "torch", ".", "save", "(", "{", "\"state_dict\"", ":", "model", ".", "state_dict", "(", ")", "}", ",", "best_model_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.get_data_loaders": [[163, 209], ["torchvision.transforms.Compose", "dataset.PixelSetData", "dann.get_data_loaders.create_data_loader"], "function", ["None"], ["", "def", "get_data_loaders", "(", "splits", ",", "config", ")", ":", "\n", "    ", "def", "create_data_loader", "(", "dataset", ")", ":", "\n", "        ", "return", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "", "train_transform", "=", "transforms", ".", "Compose", "(", "\n", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", ",", "\n", "RandomTemporalShift", "(", "max_shift", "=", "config", ".", "max_shift_aug", ",", "p", "=", "config", ".", "shift_aug_p", ")", "if", "config", ".", "with_shift_aug", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", "\n", ")", "\n", "\n", "source_dataset", "=", "PixelSetData", "(", "\n", "config", ".", "data_root", ",", "\n", "config", ".", "source", ",", "\n", "config", ".", "classes", ",", "\n", "train_transform", ",", "\n", "indices", "=", "splits", "[", "config", ".", "source", "]", "[", "\"train\"", "]", ",", "\n", ")", "\n", "source_loader", "=", "create_data_loader", "(", "source_dataset", ")", "\n", "target_dataset", "=", "PixelSetData", "(", "\n", "config", ".", "data_root", ",", "\n", "config", ".", "target", ",", "\n", "config", ".", "classes", ",", "\n", "train_transform", ",", "\n", "indices", "=", "splits", "[", "config", ".", "target", "]", "[", "\"train\"", "]", ",", "\n", ")", "\n", "target_loader", "=", "create_data_loader", "(", "target_dataset", ")", "\n", "\n", "print", "(", "\n", "f\"size of source dataset: {len(source_dataset)} ({len(source_loader)} batches)\"", "\n", ")", "\n", "print", "(", "\n", "f\"size of target dataset: {len(target_dataset)} ({len(target_loader)} batches)\"", "\n", ")", "\n", "\n", "return", "source_loader", ",", "target_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.binary_accuracy": [[338, 346], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "target.size", "pred.eq().float().sum", "pred.eq().float().sum.mul_", "pred.eq().float", "pred.eq", "target.view"], "function", ["None"], ["", "", "def", "binary_accuracy", "(", "output", ":", "torch", ".", "Tensor", ",", "target", ":", "torch", ".", "Tensor", ")", "->", "float", ":", "\n", "    ", "\"\"\"Computes the accuracy for binary classification\"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "batch_size", "=", "target", ".", "size", "(", "0", ")", "\n", "pred", "=", "(", "output", ">=", "0.5", ")", ".", "float", "(", ")", ".", "t", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "correct", "=", "pred", ".", "eq", "(", "target", ".", "view", "(", "-", "1", ")", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "correct", ".", "mul_", "(", "100.0", "/", "batch_size", ")", "\n", "return", "correct", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.dann.dann.entropy": [[503, 526], ["H.sum.sum", "torch.log", "torch.log", "torch.log", "torch.log", "H.sum.mean"], "function", ["None"], ["", "", "def", "entropy", "(", "predictions", ":", "torch", ".", "Tensor", ",", "reduction", "=", "\"none\"", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "r\"\"\"Entropy of prediction.\n    The definition is:\n    .. math::\n        entropy(p) = - \\sum_{c=1}^C p_c \\log p_c\n    where C is number of classes.\n    Args:\n        predictions (tensor): Classifier predictions. Expected to contain raw, normalized scores for each class\n        reduction (str, optional): Specifies the reduction to apply to the output:\n          ``'none'`` | ``'mean'``. ``'none'``: no reduction will be applied,\n          ``'mean'``: the sum of the output will be divided by the number of\n          elements in the output. Default: ``'mean'``\n    Shape:\n        - predictions: :math:`(minibatch, C)` where C means the number of classes.\n        - Output: :math:`(minibatch, )` by default. If :attr:`reduction` is ``'mean'``, then scalar.\n    \"\"\"", "\n", "epsilon", "=", "1e-5", "\n", "H", "=", "-", "predictions", "*", "torch", ".", "log", "(", "predictions", "+", "epsilon", ")", "\n", "H", "=", "H", ".", "sum", "(", "dim", "=", "1", ")", "\n", "if", "reduction", "==", "\"mean\"", ":", "\n", "        ", "return", "H", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "H", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.dan.MultipleKernelMaximumMeanDiscrepancy.__init__": [[66, 71], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "kernels", ":", "Sequence", "[", "nn", ".", "Module", "]", ",", "linear", ":", "Optional", "[", "bool", "]", "=", "False", ")", ":", "\n", "        ", "super", "(", "MultipleKernelMaximumMeanDiscrepancy", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "kernels", "=", "kernels", "\n", "self", ".", "index_matrix", "=", "None", "\n", "self", ".", "linear", "=", "linear", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.dan.MultipleKernelMaximumMeanDiscrepancy.forward": [[72, 84], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "int", "_update_index_matrix().to", "sum", "z_s.size", "dan._update_index_matrix", "kernel", "float"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.mmd.dan._update_index_matrix"], ["", "def", "forward", "(", "self", ",", "z_s", ":", "torch", ".", "Tensor", ",", "z_t", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "features", "=", "torch", ".", "cat", "(", "[", "z_s", ",", "z_t", "]", ",", "dim", "=", "0", ")", "\n", "batch_size", "=", "int", "(", "z_s", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "index_matrix", "=", "_update_index_matrix", "(", "batch_size", ",", "self", ".", "index_matrix", ",", "self", ".", "linear", ")", ".", "to", "(", "z_s", ".", "device", ")", "\n", "\n", "\n", "kernel_matrix", "=", "sum", "(", "[", "kernel", "(", "features", ")", "for", "kernel", "in", "self", ".", "kernels", "]", ")", "# Add up the matrix of each kernel", "\n", "# Add 2 / (n-1) to make up for the value on the diagonal", "\n", "# to ensure loss is positive in the non-linear version", "\n", "loss", "=", "(", "kernel_matrix", "*", "self", ".", "index_matrix", ")", ".", "sum", "(", ")", "+", "2.", "/", "float", "(", "batch_size", "-", "1", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.dan._update_index_matrix": [[86, 114], ["torch.zeros", "torch.zeros", "torch.zeros.size", "range", "range", "range", "range", "range", "float", "float", "float", "float", "float", "float", "float", "float"], "function", ["None"], ["", "", "def", "_update_index_matrix", "(", "batch_size", ":", "int", ",", "index_matrix", ":", "Optional", "[", "torch", ".", "Tensor", "]", "=", "None", ",", "\n", "linear", ":", "Optional", "[", "bool", "]", "=", "True", ")", "->", "torch", ".", "Tensor", ":", "\n", "    ", "r\"\"\"\n    Update the `index_matrix` which convert `kernel_matrix` to loss.\n    If `index_matrix` is a tensor with shape (2 x batch_size, 2 x batch_size), then return `index_matrix`.\n    Else return a new tensor with shape (2 x batch_size, 2 x batch_size).\n    \"\"\"", "\n", "if", "index_matrix", "is", "None", "or", "index_matrix", ".", "size", "(", "0", ")", "!=", "batch_size", "*", "2", ":", "\n", "        ", "index_matrix", "=", "torch", ".", "zeros", "(", "2", "*", "batch_size", ",", "2", "*", "batch_size", ")", "\n", "if", "linear", ":", "\n", "            ", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "s1", ",", "s2", "=", "i", ",", "(", "i", "+", "1", ")", "%", "batch_size", "\n", "t1", ",", "t2", "=", "s1", "+", "batch_size", ",", "s2", "+", "batch_size", "\n", "index_matrix", "[", "s1", ",", "s2", "]", "=", "1.", "/", "float", "(", "batch_size", ")", "\n", "index_matrix", "[", "t1", ",", "t2", "]", "=", "1.", "/", "float", "(", "batch_size", ")", "\n", "index_matrix", "[", "s1", ",", "t2", "]", "=", "-", "1.", "/", "float", "(", "batch_size", ")", "\n", "index_matrix", "[", "s2", ",", "t1", "]", "=", "-", "1.", "/", "float", "(", "batch_size", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "if", "i", "!=", "j", ":", "\n", "                        ", "index_matrix", "[", "i", "]", "[", "j", "]", "=", "1.", "/", "float", "(", "batch_size", "*", "(", "batch_size", "-", "1", ")", ")", "\n", "index_matrix", "[", "i", "+", "batch_size", "]", "[", "j", "+", "batch_size", "]", "=", "1.", "/", "float", "(", "batch_size", "*", "(", "batch_size", "-", "1", ")", ")", "\n", "", "", "", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "for", "j", "in", "range", "(", "batch_size", ")", ":", "\n", "                    ", "index_matrix", "[", "i", "]", "[", "j", "+", "batch_size", "]", "=", "-", "1.", "/", "float", "(", "batch_size", "*", "batch_size", ")", "\n", "index_matrix", "[", "i", "+", "batch_size", "]", "[", "j", "]", "=", "-", "1.", "/", "float", "(", "batch_size", "*", "batch_size", ")", "\n", "", "", "", "", "return", "index_matrix", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.kernels.GaussianKernel.__init__": [[44, 51], ["torch.Module.__init__", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "sigma", ":", "Optional", "[", "float", "]", "=", "None", ",", "track_running_stats", ":", "Optional", "[", "bool", "]", "=", "True", ",", "\n", "alpha", ":", "Optional", "[", "float", "]", "=", "1.", ")", ":", "\n", "        ", "super", "(", "GaussianKernel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "track_running_stats", "or", "sigma", "is", "not", "None", "\n", "self", ".", "sigma_square", "=", "torch", ".", "tensor", "(", "sigma", "*", "sigma", ")", "if", "sigma", "is", "not", "None", "else", "None", "\n", "self", ".", "track_running_stats", "=", "track_running_stats", "\n", "self", ".", "alpha", "=", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.kernels.GaussianKernel.forward": [[52, 59], ["torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "l2_distance_square.detach", "X.unsqueeze", "X.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "X", ":", "torch", ".", "Tensor", ")", "->", "torch", ".", "Tensor", ":", "\n", "        ", "l2_distance_square", "=", "(", "(", "X", ".", "unsqueeze", "(", "0", ")", "-", "X", ".", "unsqueeze", "(", "1", ")", ")", "**", "2", ")", ".", "sum", "(", "2", ")", "\n", "\n", "if", "self", ".", "track_running_stats", ":", "\n", "            ", "self", ".", "sigma_square", "=", "self", ".", "alpha", "*", "torch", ".", "mean", "(", "l2_distance_square", ".", "detach", "(", ")", ")", "\n", "\n", "", "return", "torch", ".", "exp", "(", "-", "l2_distance_square", "/", "(", "2", "*", "self", ".", "sigma_square", ")", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.train_mmd.train_mmd": [[20, 118], ["train_mmd.get_data_loaders", "model.to", "competitors.mmd.dan.MultipleKernelMaximumMeanDiscrepancy", "torch.CrossEntropyLoss", "range", "torch.save", "torch.save", "model.load_state_dict", "torch.optim.sgd.SGD", "torch.optim.lr_scheduler.LambdaLR", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.lr_scheduler.CosineAnnealingLR", "torch.optim.lr_scheduler.CosineAnnealingLR", "iter", "iter", "tqdm.tqdm", "utils.train_utils.AverageMeter", "utils.train_utils.AverageMeter", "model.train", "competitors.mmd.dan.MultipleKernelMaximumMeanDiscrepancy.train", "tqdm.tqdm.close", "model.eval", "evaluation.validation", "torch.load", "torch.load", "model.parameters", "utils.train_utils.cycle", "utils.train_utils.cycle", "range", "x_s[].cuda", "utils.train_utils.cat_samples", "model", "y.chunk", "f.chunk", "nn.CrossEntropyLoss.", "competitors.mmd.dan.MultipleKernelMaximumMeanDiscrepancy.", "torch.optim.Adam.zero_grad", "loss.backward", "torch.optim.Adam.step", "torch.optim.lr_scheduler.CosineAnnealingLR.step", "utils.train_utils.AverageMeter.update", "utils.train_utils.AverageMeter.update", "tqdm.tqdm.set_postfix", "model.state_dict", "competitors.mmd.kernels.GaussianKernel", "model.spatial_encoder.parameters", "model.temporal_encoder.parameters", "model.decoder.parameters", "next", "next", "loss.item", "utils.metrics.accuracy", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "range", "utils.train_utils.to_cuda", "float"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.get_data_loaders", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cat_samples", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda"], ["def", "train_mmd", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", ":", "\n", "    ", "source_loader", ",", "target_loader", "=", "get_data_loaders", "(", "splits", ",", "config", ")", "\n", "\n", "model", ".", "to", "(", "device", ")", "\n", "if", "config", ".", "weights", "is", "not", "None", ":", "\n", "        ", "pretrained_path", "=", "f\"{config.weights}/fold_{fold_num}\"", "\n", "pretrained_weights", "=", "torch", ".", "load", "(", "f\"{pretrained_path}/model.pt\"", ")", "[", "\"state_dict\"", "]", "\n", "model", ".", "load_state_dict", "(", "pretrained_weights", ")", "\n", "\n", "", "linear_time", "=", "True", "# whether to compute MMD in linear time or quadratic", "\n", "mkmmd_loss", "=", "MultipleKernelMaximumMeanDiscrepancy", "(", "\n", "kernels", "=", "[", "GaussianKernel", "(", "alpha", "=", "2", "**", "k", ")", "for", "k", "in", "range", "(", "-", "3", ",", "2", ")", "]", ",", "\n", "linear", "=", "linear_time", "\n", ")", "\n", "if", "config", ".", "use_default_optim", ":", "\n", "        ", "base_lr", "=", "1.0", "\n", "classifier_params", "=", "[", "\n", "{", "\"params\"", ":", "model", ".", "spatial_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "temporal_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "decoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "1.0", "*", "base_lr", "}", ",", "\n", "]", "\n", "# lr_gamma = 0.0003", "\n", "lr_gamma", "=", "0.001", "\n", "lr_decay", "=", "0.75", "\n", "optimizer", "=", "SGD", "(", "\n", "classifier_params", ",", "\n", "config", ".", "lr", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", "nesterov", "=", "True", ",", "\n", ")", "\n", "lr_scheduler", "=", "LambdaLR", "(", "\n", "optimizer", ",", "lambda", "x", ":", "config", ".", "lr", "*", "(", "1.0", "+", "lr_gamma", "*", "float", "(", "x", ")", ")", "**", "(", "-", "lr_decay", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "model", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "config", ".", "lr", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", ")", "\n", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "CosineAnnealingLR", "(", "\n", "optimizer", ",", "T_max", "=", "config", ".", "epochs", "*", "config", ".", "steps_per_epoch", ",", "eta_min", "=", "0", "\n", ")", "\n", "\n", "## train", "\n", "", "best_f1", "=", "0.0", "\n", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "source_iter", ",", "target_iter", "=", "iter", "(", "cycle", "(", "source_loader", ")", ")", ",", "iter", "(", "cycle", "(", "target_loader", ")", ")", "\n", "global_step", "=", "0", "\n", "for", "epoch", "in", "range", "(", "config", ".", "epochs", ")", ":", "\n", "        ", "progress_bar", "=", "tqdm", "(", "range", "(", "config", ".", "steps_per_epoch", ")", ",", "desc", "=", "f'MMD Epoch {epoch + 1}/{config.epochs}'", ")", "\n", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "class_accs", "=", "AverageMeter", "(", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "mkmmd_loss", ".", "train", "(", ")", "\n", "\n", "for", "_", "in", "progress_bar", ":", "\n", "            ", "x_s", ",", "x_t", "=", "next", "(", "source_iter", ")", ",", "next", "(", "target_iter", ")", "\n", "labels_s", "=", "x_s", "[", "\"label\"", "]", ".", "cuda", "(", ")", "\n", "\n", "x", "=", "cat_samples", "(", "[", "x_s", ",", "x_t", "]", ")", "\n", "y", ",", "f", "=", "model", "(", "*", "to_cuda", "(", "x", ",", "device", ")", ",", "return_feats", "=", "True", ")", "\n", "y_s", ",", "_", "=", "y", ".", "chunk", "(", "2", ",", "dim", "=", "0", ")", "\n", "f_s", ",", "f_t", "=", "f", ".", "chunk", "(", "2", ",", "dim", "=", "0", ")", "\n", "\n", "cls_loss", "=", "criterion", "(", "y_s", ",", "labels_s", ")", "\n", "transfer_loss", "=", "mkmmd_loss", "(", "f_s", ",", "f_t", ")", "\n", "loss", "=", "cls_loss", "+", "transfer_loss", "*", "config", ".", "trade_off", "\n", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "\n", "losses", ".", "update", "(", "loss", ".", "item", "(", ")", ",", "config", ".", "batch_size", ")", "\n", "class_accs", ".", "update", "(", "accuracy", "(", "y_s", ",", "labels_s", ")", ",", "config", ".", "batch_size", ")", "\n", "\n", "progress_bar", ".", "set_postfix", "(", "\n", "loss", "=", "f\"{losses.avg:.3f}\"", ",", "\n", "class_acc", "=", "f\"{class_accs.avg:.2f}\"", ",", "\n", ")", "\n", "if", "global_step", "%", "config", ".", "log_step", "==", "0", ":", "\n", "                ", "writer", ".", "add_scalar", "(", "\"train/loss\"", ",", "losses", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/accuracy\"", ",", "class_accs", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\n", "\"train/lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "global_step", "\n", ")", "\n", "", "global_step", "+=", "1", "\n", "\n", "", "progress_bar", ".", "close", "(", ")", "\n", "\n", "model", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "best_f1", ",", "best_model_path", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "model", ",", "val_loader", ",", "writer", ")", "\n", "\n", "# save final model and use for evaluation", "\n", "", "torch", ".", "save", "(", "{", "'state_dict'", ":", "model", ".", "state_dict", "(", ")", "}", ",", "best_model_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.mmd.train_mmd.get_data_loaders": [[120, 143], ["torchvision.transforms.Compose", "dataset.PixelSetData", "train_mmd.get_data_loaders.create_data_loader"], "function", ["None"], ["", "def", "get_data_loaders", "(", "splits", ",", "config", ")", ":", "\n", "    ", "def", "create_data_loader", "(", "dataset", ")", ":", "\n", "        ", "return", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "pin_memory", "=", "True", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "shuffle", "=", "True", ",", "drop_last", "=", "True", ")", "\n", "\n", "", "train_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", ",", "\n", "RandomTemporalShift", "(", "max_shift", "=", "config", ".", "max_shift_aug", ",", "p", "=", "config", ".", "shift_aug_p", ")", "if", "config", ".", "with_shift_aug", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", ")", "\n", "\n", "source_dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "source", ",", "config", ".", "classes", ",", "train_transform", ",", "indices", "=", "splits", "[", "config", ".", "source", "]", "[", "'train'", "]", ")", "\n", "source_loader", "=", "create_data_loader", "(", "source_dataset", ")", "\n", "target_dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "target", ",", "config", ".", "classes", ",", "train_transform", ",", "indices", "=", "splits", "[", "config", ".", "target", "]", "[", "'train'", "]", ")", "\n", "target_loader", "=", "create_data_loader", "(", "target_dataset", ")", "\n", "\n", "print", "(", "f'size of source dataset: {len(source_dataset)} ({len(source_loader)} batches)'", ")", "\n", "print", "(", "f'size of target dataset: {len(target_dataset)} ({len(target_loader)} batches)'", ")", "\n", "\n", "return", "source_loader", ",", "target_loader", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.BalancedBatchSampler.__init__": [[191, 216], ["sorted", "print", "len", "len", "print", "print", "set", "ValueError", "jumbot.InfiniteSliceIterator", "ValueError", "numpy.where"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "labels", ",", "batch_size", ")", ":", "\n", "        ", "classes", "=", "sorted", "(", "set", "(", "labels", ")", ")", "\n", "print", "(", "classes", ")", "\n", "\n", "n_classes", "=", "len", "(", "classes", ")", "\n", "self", ".", "_n_samples", "=", "batch_size", "//", "n_classes", "\n", "if", "self", ".", "_n_samples", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"batch_size should be bigger than the number of classes, got {batch_size}\"", "\n", ")", "\n", "\n", "", "self", ".", "_class_iters", "=", "[", "\n", "InfiniteSliceIterator", "(", "np", ".", "where", "(", "labels", "==", "class_", ")", "[", "0", "]", ",", "class_", "=", "class_", ")", "\n", "for", "class_", "in", "classes", "\n", "]", "\n", "\n", "batch_size", "=", "self", ".", "_n_samples", "*", "n_classes", "\n", "self", ".", "n_dataset", "=", "len", "(", "labels", ")", "\n", "self", ".", "_n_batches", "=", "self", ".", "n_dataset", "//", "batch_size", "\n", "if", "self", ".", "_n_batches", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"Dataset is not big enough to generate batches with size {batch_size}\"", "\n", ")", "\n", "", "print", "(", "\"K=\"", ",", "n_classes", ",", "\"nk=\"", ",", "self", ".", "_n_samples", ")", "\n", "print", "(", "\"Batch size = \"", ",", "batch_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.BalancedBatchSampler.__iter__": [[217, 227], ["range", "numpy.random.shuffle", "class_iter.reset", "indices.extend", "class_iter.get"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "self", ".", "_n_batches", ")", ":", "\n", "            ", "indices", "=", "[", "]", "\n", "for", "class_iter", "in", "self", ".", "_class_iters", ":", "\n", "                ", "indices", ".", "extend", "(", "class_iter", ".", "get", "(", "self", ".", "_n_samples", ")", ")", "\n", "", "np", ".", "random", ".", "shuffle", "(", "indices", ")", "\n", "yield", "indices", "\n", "\n", "", "for", "class_iter", "in", "self", ".", "_class_iters", ":", "\n", "            ", "class_iter", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.BalancedBatchSampler.__len__": [[228, 230], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_n_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.__init__": [[233, 238], ["type"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "array", ",", "class_", ")", ":", "\n", "        ", "assert", "type", "(", "array", ")", "is", "np", ".", "ndarray", "\n", "self", ".", "array", "=", "array", "\n", "self", ".", "i", "=", "0", "\n", "self", ".", "class_", "=", "class_", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset": [[239, 241], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "i", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.get": [[242, 262], ["len", "print", "jumbot.InfiniteSliceIterator.reset", "numpy.random.shuffle", "numpy.concatenate", "jumbot.InfiniteSliceIterator.reset", "numpy.random.shuffle", "numpy.tile"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset", "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.InfiniteSliceIterator.reset"], ["", "def", "get", "(", "self", ",", "n", ")", ":", "\n", "        ", "len_", "=", "len", "(", "self", ".", "array", ")", "\n", "# not enough element in 'array'", "\n", "if", "len_", "<", "n", ":", "\n", "            ", "print", "(", "f\"there are really few items in class {self.class_}\"", ")", "\n", "self", ".", "reset", "(", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "self", ".", "array", ")", "\n", "mul", "=", "n", "//", "len_", "\n", "rest", "=", "n", "-", "mul", "*", "len_", "\n", "return", "np", ".", "concatenate", "(", "(", "np", ".", "tile", "(", "self", ".", "array", ",", "mul", ")", ",", "self", ".", "array", "[", ":", "rest", "]", ")", ")", "\n", "\n", "# not enough element in array's tail", "\n", "", "if", "len_", "-", "self", ".", "i", "<", "n", ":", "\n", "            ", "self", ".", "reset", "(", ")", "\n", "\n", "", "if", "self", ".", "i", "==", "0", ":", "\n", "            ", "np", ".", "random", ".", "shuffle", "(", "self", ".", "array", ")", "\n", "", "i", "=", "self", ".", "i", "\n", "self", ".", "i", "+=", "n", "\n", "return", "self", ".", "array", "[", "i", ":", "self", ".", "i", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.train_jumbot": [[35, 133], ["jumbot.get_data_loaders", "model.to", "torch.optim.sgd.SGD", "torch.optim.lr_scheduler.LambdaLR", "torch.CrossEntropyLoss", "range", "torch.save", "torch.save", "torch.save", "torch.save", "model.load_state_dict", "print", "iter", "iter", "tqdm.tqdm", "utils.train_utils.AverageMeter", "utils.train_utils.AverageMeter", "model.train", "tqdm.tqdm.close", "model.eval", "evaluation.validation", "torch.load", "torch.load", "torch.load", "torch.load", "model.spatial_encoder.parameters", "model.temporal_encoder.parameters", "model.decoder.parameters", "utils.train_utils.cycle", "utils.train_utils.cycle", "range", "x_s[].cuda", "model", "model", "torch.softmax", "nn.CrossEntropyLoss.", "torch.one_hot().float", "ot.unbalanced.sinkhorn_knopp_unbalanced", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.from_numpy().float().cuda", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.optim.sgd.SGD.zero_grad", "tot_loss.backward", "torch.optim.sgd.SGD.step", "torch.optim.lr_scheduler.LambdaLR.step", "utils.train_utils.AverageMeter.update", "utils.train_utils.AverageMeter.update", "tqdm.tqdm.set_postfix", "model.state_dict", "next", "next", "torch.cdist", "torch.cdist", "torch.cdist", "torch.cdist", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "ot.unif", "ot.unif", "M.detach().cpu().numpy", "tot_loss.item", "utils.metrics.accuracy", "writer.add_scalar", "writer.add_scalar", "writer.add_scalar", "utils.train_utils.to_cuda", "utils.train_utils.to_cuda", "torch.one_hot", "torch.transpose", "torch.transpose", "torch.transpose", "torch.transpose", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.log", "torch.log", "torch.log", "torch.log", "f_s.size", "f_t.size", "M.detach().cpu", "float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "M.detach"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.get_data_loaders", "home.repos.pwc.inspect_result.jnyborg_timematch.None.evaluation.validation", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.cycle", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.GradientReverseFunction.backward", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.dann.grl.WarmStartGradientReverseLayer.step", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.AverageMeter.update", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.metrics.accuracy", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda", "home.repos.pwc.inspect_result.jnyborg_timematch.utils.train_utils.to_cuda"], ["def", "train_jumbot", "(", "model", ",", "config", ",", "writer", ",", "val_loader", ",", "device", ",", "best_model_path", ",", "fold_num", ",", "splits", ")", ":", "\n", "    ", "source_loader", ",", "target_loader", "=", "get_data_loaders", "(", "splits", ",", "config", ",", "source_balanced", "=", "False", ")", "\n", "\n", "model", ".", "to", "(", "device", ")", "\n", "if", "config", ".", "weights", "is", "not", "None", ":", "\n", "        ", "pretrained_path", "=", "f\"{config.weights}/fold_{fold_num}\"", "\n", "pretrained_weights", "=", "torch", ".", "load", "(", "f\"{pretrained_path}/model.pt\"", ")", "[", "\"state_dict\"", "]", "\n", "model", ".", "load_state_dict", "(", "pretrained_weights", ")", "\n", "print", "(", "'using pretrained weights'", ",", "config", ".", "weights", ")", "\n", "\n", "\n", "", "base_lr", "=", "1.0", "\n", "classifier_params", "=", "[", "\n", "{", "\"params\"", ":", "model", ".", "spatial_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "temporal_encoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "0.1", "*", "base_lr", "}", ",", "\n", "{", "\"params\"", ":", "model", ".", "decoder", ".", "parameters", "(", ")", ",", "\"lr\"", ":", "1.0", "*", "base_lr", "}", ",", "\n", "]", "\n", "lr_gamma", "=", "0.001", "\n", "lr_decay", "=", "0.75", "\n", "optimizer", "=", "SGD", "(", "\n", "classifier_params", ",", "\n", "config", ".", "lr", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "config", ".", "weight_decay", ",", "\n", "nesterov", "=", "True", ",", "\n", ")", "\n", "lr_scheduler", "=", "LambdaLR", "(", "\n", "optimizer", ",", "lambda", "x", ":", "config", ".", "lr", "*", "(", "1.0", "+", "lr_gamma", "*", "float", "(", "x", ")", ")", "**", "(", "-", "lr_decay", ")", "\n", ")", "\n", "\n", "criterion", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "global_step", "=", "0", "\n", "best_f1", "=", "0.0", "\n", "\n", "source_iter", ",", "target_iter", "=", "iter", "(", "cycle", "(", "source_loader", ")", ")", ",", "iter", "(", "cycle", "(", "target_loader", ")", ")", "\n", "for", "epoch", "in", "range", "(", "config", ".", "epochs", ")", ":", "\n", "        ", "progress_bar", "=", "tqdm", "(", "range", "(", "config", ".", "steps_per_epoch", ")", ",", "desc", "=", "f'JUMBOT Epoch {epoch + 1}/{config.epochs}'", ")", "\n", "\n", "losses", "=", "AverageMeter", "(", ")", "\n", "class_accs", "=", "AverageMeter", "(", ")", "\n", "\n", "model", ".", "train", "(", ")", "\n", "for", "_", "in", "progress_bar", ":", "\n", "            ", "x_s", ",", "x_t", "=", "next", "(", "source_iter", ")", ",", "next", "(", "target_iter", ")", "\n", "labels_s", "=", "x_s", "[", "\"label\"", "]", ".", "cuda", "(", ")", "\n", "\n", "y_s", ",", "f_s", "=", "model", "(", "*", "to_cuda", "(", "x_s", ",", "device", ")", ",", "return_feats", "=", "True", ")", "\n", "y_t", ",", "f_t", "=", "model", "(", "*", "to_cuda", "(", "x_t", ",", "device", ")", ",", "return_feats", "=", "True", ")", "\n", "pred_x_t", "=", "F", ".", "softmax", "(", "y_t", ",", "1", ")", "\n", "\n", "cls_loss", "=", "criterion", "(", "y_s", ",", "labels_s", ")", "\n", "\n", "one_hot_labels_s", "=", "F", ".", "one_hot", "(", "labels_s", ",", "num_classes", "=", "config", ".", "num_classes", ")", ".", "float", "(", ")", "\n", "M_embed", "=", "torch", ".", "cdist", "(", "f_s", ",", "f_t", ")", "**", "2", "# term on embedded data", "\n", "M_sce", "=", "-", "torch", ".", "mm", "(", "one_hot_labels_s", ",", "torch", ".", "transpose", "(", "torch", ".", "log", "(", "pred_x_t", ")", ",", "0", ",", "1", ")", ")", "# term on labels", "\n", "M", "=", "config", ".", "eta1", "*", "M_embed", "+", "config", ".", "eta2", "*", "M_sce", "\n", "# M_normalized = M / M.max()  # normalize by max to avoid numerical issues", "\n", "\n", "#OT computation", "\n", "a", ",", "b", "=", "ot", ".", "unif", "(", "f_s", ".", "size", "(", ")", "[", "0", "]", ")", ",", "ot", ".", "unif", "(", "f_t", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "pi", "=", "ot", ".", "unbalanced", ".", "sinkhorn_knopp_unbalanced", "(", "a", ",", "b", ",", "M", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "config", ".", "epsilon", ",", "config", ".", "tau", ")", "\n", "# To get DeepJDOT (https://arxiv.org/abs/1803.10081) comment the line above ", "\n", "# and uncomment the following line:", "\n", "#pi = ot.emd(a, b, M.detach().cpu().numpy())", "\n", "pi", "=", "torch", ".", "from_numpy", "(", "pi", ")", ".", "float", "(", ")", ".", "cuda", "(", ")", "# Transport plan between minibatches", "\n", "transfer_loss", "=", "torch", ".", "sum", "(", "pi", "*", "M", ")", "\n", "\n", "# if global_step % 100 == 0:", "\n", "#     print(torch.sum(pi), transfer_loss, torch.min(M), torch.min(M_embed), torch.min(M_sce))", "\n", "\n", "# train the model ", "\n", "tot_loss", "=", "cls_loss", "+", "transfer_loss", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "tot_loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "lr_scheduler", ".", "step", "(", ")", "\n", "\n", "losses", ".", "update", "(", "tot_loss", ".", "item", "(", ")", ",", "config", ".", "batch_size", ")", "\n", "class_accs", ".", "update", "(", "accuracy", "(", "y_s", ",", "labels_s", ")", ",", "config", ".", "batch_size", ")", "\n", "\n", "progress_bar", ".", "set_postfix", "(", "\n", "loss", "=", "f\"{losses.avg:.3f}\"", ",", "\n", "class_acc", "=", "f\"{class_accs.avg:.2f}\"", ",", "\n", ")", "\n", "if", "global_step", "%", "config", ".", "log_step", "==", "0", ":", "\n", "                ", "writer", ".", "add_scalar", "(", "\"train/loss\"", ",", "losses", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\"train/accuracy\"", ",", "class_accs", ".", "val", ",", "global_step", ")", "\n", "writer", ".", "add_scalar", "(", "\n", "\"train/lr\"", ",", "optimizer", ".", "param_groups", "[", "0", "]", "[", "\"lr\"", "]", ",", "global_step", "\n", ")", "\n", "", "global_step", "+=", "1", "\n", "\n", "", "progress_bar", ".", "close", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "best_f1", "=", "validation", "(", "best_f1", ",", "None", ",", "config", ",", "criterion", ",", "device", ",", "epoch", ",", "model", ",", "val_loader", ",", "writer", ")", "\n", "\n", "# save final model and use for evaluation", "\n", "", "torch", ".", "save", "(", "{", "'state_dict'", ":", "model", ".", "state_dict", "(", ")", "}", ",", "best_model_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.jumbot.jumbot.get_data_loaders": [[135, 182], ["torchvision.transforms.Compose", "dataset.PixelSetData", "dataset.PixelSetData", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "print", "print", "dataset.PixelSetData.get_labels", "jumbot.BalancedBatchSampler", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "transforms.RandomSamplePixels", "transforms.RandomSampleTimeSteps", "transforms.Normalize", "transforms.ToTensor", "transforms.RandomTemporalShift", "transforms.Identity", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.None.dataset.PixelSetData.get_labels"], ["", "def", "get_data_loaders", "(", "splits", ",", "config", ",", "source_balanced", "=", "False", ")", ":", "\n", "    ", "train_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "RandomSamplePixels", "(", "config", ".", "num_pixels", ")", ",", "\n", "RandomSampleTimeSteps", "(", "config", ".", "seq_length", ")", ",", "\n", "RandomTemporalShift", "(", "max_shift", "=", "config", ".", "max_shift_aug", ",", "p", "=", "config", ".", "shift_aug_p", ")", "if", "config", ".", "with_shift_aug", "else", "Identity", "(", ")", ",", "\n", "Normalize", "(", ")", ",", "\n", "ToTensor", "(", ")", ",", "\n", "]", ")", "\n", "\n", "source_dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "source", ",", "config", ".", "classes", ",", "train_transform", ",", "indices", "=", "splits", "[", "config", ".", "source", "]", "[", "'train'", "]", ")", "\n", "\n", "if", "source_balanced", ":", "\n", "        ", "print", "(", "\"using balanced loader for source\"", ")", "\n", "source_labels", "=", "source_dataset", ".", "get_labels", "(", ")", "\n", "train_batch_sampler", "=", "BalancedBatchSampler", "(", "source_labels", ",", "batch_size", "=", "config", ".", "batch_size", ")", "\n", "\n", "source_loader", "=", "data", ".", "DataLoader", "(", "\n", "source_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "batch_sampler", "=", "train_batch_sampler", ",", "\n", ")", "\n", "", "else", ":", "\n", "        ", "source_loader", "=", "data", ".", "DataLoader", "(", "\n", "source_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "\n", "", "target_dataset", "=", "PixelSetData", "(", "config", ".", "data_root", ",", "config", ".", "target", ",", "config", ".", "classes", ",", "train_transform", ",", "indices", "=", "splits", "[", "config", ".", "target", "]", "[", "'train'", "]", ")", "\n", "target_loader", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "target_dataset", ",", "\n", "num_workers", "=", "config", ".", "num_workers", ",", "\n", "pin_memory", "=", "True", ",", "\n", "batch_size", "=", "config", ".", "batch_size", ",", "\n", "shuffle", "=", "True", ",", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n", "\n", "print", "(", "f'size of source dataset: {len(source_dataset)} ({len(source_loader)} batches)'", ")", "\n", "print", "(", "f'size of target dataset: {len(target_dataset)} ({len(target_loader)} batches)'", ")", "\n", "\n", "return", "source_loader", ",", "target_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseLTae.__init__": [[17, 59], ["torch.Module.__init__", "models.pse.PixelSetEncoder", "models.ltae.LTAE", "models.decoder.get_decoder", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.decoder.get_decoder"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", "=", "10", ",", "\n", "mlp1", "=", "[", "10", ",", "32", ",", "64", "]", ",", "\n", "pooling", "=", "\"mean_std\"", ",", "\n", "mlp2", "=", "[", "128", ",", "128", "]", ",", "\n", "with_extra", "=", "True", ",", "\n", "extra_size", "=", "4", ",", "\n", "n_head", "=", "16", ",", "\n", "d_k", "=", "8", ",", "\n", "d_model", "=", "256", ",", "\n", "mlp3", "=", "[", "256", ",", "128", "]", ",", "\n", "dropout", "=", "0.2", ",", "\n", "T", "=", "1000", ",", "\n", "mlp4", "=", "[", "128", ",", "64", ",", "32", "]", ",", "\n", "num_classes", "=", "20", ",", "\n", "max_temporal_shift", "=", "100", ",", "\n", ")", ":", "\n", "        ", "super", "(", "PseLTae", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "with_extra", ":", "\n", "            ", "mlp2", "=", "deepcopy", "(", "mlp2", ")", "\n", "mlp2", "[", "0", "]", "+=", "extra_size", "\n", "\n", "", "self", ".", "spatial_encoder", "=", "PixelSetEncoder", "(", "\n", "input_dim", ",", "\n", "mlp1", "=", "mlp1", ",", "\n", "pooling", "=", "pooling", ",", "\n", "mlp2", "=", "mlp2", ",", "\n", "with_extra", "=", "with_extra", ",", "\n", "extra_size", "=", "extra_size", ",", "\n", ")", "\n", "self", ".", "temporal_encoder", "=", "LTAE", "(", "\n", "in_channels", "=", "mlp2", "[", "-", "1", "]", ",", "\n", "n_head", "=", "n_head", ",", "\n", "d_k", "=", "d_k", ",", "\n", "d_model", "=", "d_model", ",", "\n", "n_neurons", "=", "mlp3", ",", "\n", "dropout", "=", "dropout", ",", "\n", "T", "=", "T", ",", "\n", "max_temporal_shift", "=", "max_temporal_shift", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "get_decoder", "(", "mlp4", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseLTae.forward": [[60, 76], ["stclassifier.PseLTae.spatial_encoder", "stclassifier.PseLTae.temporal_encoder", "stclassifier.PseLTae.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pixels", ",", "mask", ",", "positions", ",", "extra", ",", "return_feats", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n           input(tuple): (Pixel-Set, Pixel-Mask) or ((Pixel-Set, Pixel-Mask), Extra-features)\n           Pixel-Set : Batch_size x Sequence length x Channel x Number of pixels\n           Pixel-Mask : Batch_size x Sequence length x Number of pixels\n           Positions : Batch_size x Sequence length\n           Extra-features : Batch_size x Sequence length x Number of features\n        \"\"\"", "\n", "spatial_feats", "=", "self", ".", "spatial_encoder", "(", "pixels", ",", "mask", ",", "extra", ")", "\n", "temporal_feats", "=", "self", ".", "temporal_encoder", "(", "spatial_feats", ",", "positions", ")", "\n", "logits", "=", "self", ".", "decoder", "(", "temporal_feats", ")", "\n", "if", "return_feats", ":", "\n", "            ", "return", "logits", ",", "temporal_feats", "\n", "", "else", ":", "\n", "            ", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseLTae.param_ratio": [[77, 91], ["stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "print", "print"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams"], ["", "", "def", "param_ratio", "(", "self", ")", ":", "\n", "        ", "total", "=", "get_ntrainparams", "(", "self", ")", "\n", "s", "=", "get_ntrainparams", "(", "self", ".", "spatial_encoder", ")", "\n", "t", "=", "get_ntrainparams", "(", "self", ".", "temporal_encoder", ")", "\n", "c", "=", "get_ntrainparams", "(", "self", ".", "decoder", ")", "\n", "\n", "print", "(", "\"TOTAL TRAINABLE PARAMETERS : {}\"", ".", "format", "(", "total", ")", ")", "\n", "print", "(", "\n", "\"RATIOS: Spatial {:5.1f}% , Temporal {:5.1f}% , Classifier {:5.1f}%\"", ".", "format", "(", "\n", "s", "/", "total", "*", "100", ",", "t", "/", "total", "*", "100", ",", "c", "/", "total", "*", "100", "\n", ")", "\n", ")", "\n", "\n", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseTae.__init__": [[98, 141], ["torch.Module.__init__", "models.pse.PixelSetEncoder", "models.tae.TemporalAttentionEncoder", "models.decoder.get_decoder", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.decoder.get_decoder"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", "=", "10", ",", "\n", "mlp1", "=", "[", "10", ",", "32", ",", "64", "]", ",", "\n", "pooling", "=", "\"mean_std\"", ",", "\n", "mlp2", "=", "[", "128", ",", "128", "]", ",", "\n", "with_extra", "=", "True", ",", "\n", "extra_size", "=", "4", ",", "\n", "n_head", "=", "4", ",", "\n", "d_k", "=", "32", ",", "\n", "d_model", "=", "None", ",", "\n", "mlp3", "=", "[", "512", ",", "128", ",", "128", "]", ",", "\n", "dropout", "=", "0.2", ",", "\n", "T", "=", "1000", ",", "\n", "mlp4", "=", "[", "128", ",", "64", ",", "32", "]", ",", "\n", "num_classes", "=", "20", ",", "\n", "max_temporal_shift", "=", "100", ",", "\n", "max_position", "=", "365", ",", "\n", ")", ":", "\n", "        ", "super", "(", "PseTae", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "with_extra", ":", "\n", "            ", "mlp2", "=", "deepcopy", "(", "mlp2", ")", "\n", "mlp2", "[", "0", "]", "+=", "4", "\n", "", "self", ".", "spatial_encoder", "=", "PixelSetEncoder", "(", "\n", "input_dim", ",", "\n", "mlp1", "=", "mlp1", ",", "\n", "pooling", "=", "pooling", ",", "\n", "mlp2", "=", "mlp2", ",", "\n", "with_extra", "=", "with_extra", ",", "\n", "extra_size", "=", "extra_size", ",", "\n", ")", "\n", "self", ".", "temporal_encoder", "=", "TemporalAttentionEncoder", "(", "\n", "in_channels", "=", "mlp2", "[", "-", "1", "]", ",", "\n", "n_head", "=", "n_head", ",", "\n", "d_k", "=", "d_k", ",", "\n", "d_model", "=", "d_model", ",", "\n", "n_neurons", "=", "mlp3", ",", "\n", "dropout", "=", "dropout", ",", "\n", "T", "=", "T", ",", "\n", "max_position", "=", "max_position", ",", "\n", "max_temporal_shift", "=", "max_temporal_shift", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "get_decoder", "(", "mlp4", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseTae.forward": [[142, 158], ["stclassifier.PseTae.spatial_encoder", "stclassifier.PseTae.temporal_encoder", "stclassifier.PseTae.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pixels", ",", "mask", ",", "positions", ",", "extra", ",", "return_feats", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n           input(tuple): (Pixel-Set, Pixel-Mask) or ((Pixel-Set, Pixel-Mask), Extra-features)\n           Pixel-Set : Batch_size x Sequence length x Channel x Number of pixels\n           Pixel-Mask : Batch_size x Sequence length x Number of pixels\n           Positions : Batch_size x Sequence length\n           Extra-features : Batch_size x Sequence length x Number of features\n        \"\"\"", "\n", "spatial_feats", "=", "self", ".", "spatial_encoder", "(", "pixels", ",", "mask", ",", "extra", ")", "\n", "temporal_feats", "=", "self", ".", "temporal_encoder", "(", "spatial_feats", ",", "positions", ")", "\n", "logits", "=", "self", ".", "decoder", "(", "temporal_feats", ")", "\n", "if", "return_feats", ":", "\n", "            ", "return", "logits", ",", "temporal_feats", "\n", "", "else", ":", "\n", "            ", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseTae.param_ratio": [[159, 172], ["stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "print", "print"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams"], ["", "", "def", "param_ratio", "(", "self", ")", ":", "\n", "        ", "total", "=", "get_ntrainparams", "(", "self", ")", "\n", "s", "=", "get_ntrainparams", "(", "self", ".", "spatial_encoder", ")", "\n", "t", "=", "get_ntrainparams", "(", "self", ".", "temporal_encoder", ")", "\n", "c", "=", "get_ntrainparams", "(", "self", ".", "decoder", ")", "\n", "\n", "print", "(", "\"TOTAL TRAINABLE PARAMETERS : {}\"", ".", "format", "(", "total", ")", ")", "\n", "print", "(", "\n", "\"RATIOS: Spatial {:5.1f}% , Temporal {:5.1f}% , Classifier {:5.1f}%\"", ".", "format", "(", "\n", "s", "/", "total", "*", "100", ",", "t", "/", "total", "*", "100", ",", "c", "/", "total", "*", "100", "\n", ")", "\n", ")", "\n", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseGru.__init__": [[179, 212], ["torch.Module.__init__", "models.pse.PixelSetEncoder", "models.competings.GRU", "models.decoder.get_decoder", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.decoder.get_decoder"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", "=", "10", ",", "\n", "mlp1", "=", "[", "10", ",", "32", ",", "64", "]", ",", "\n", "pooling", "=", "\"mean_std\"", ",", "\n", "mlp2", "=", "[", "128", ",", "128", "]", ",", "\n", "with_extra", "=", "True", ",", "\n", "extra_size", "=", "4", ",", "\n", "hidden_dim", "=", "128", ",", "\n", "mlp4", "=", "[", "128", ",", "64", ",", "32", "]", ",", "\n", "num_classes", "=", "20", ",", "\n", "max_temporal_shift", "=", "100", ",", "\n", "max_position", "=", "365", ",", "\n", ")", ":", "\n", "        ", "super", "(", "PseGru", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "with_extra", ":", "\n", "            ", "mlp2", "=", "deepcopy", "(", "mlp2", ")", "\n", "mlp2", "[", "0", "]", "+=", "4", "\n", "", "self", ".", "spatial_encoder", "=", "PixelSetEncoder", "(", "\n", "input_dim", ",", "\n", "mlp1", "=", "mlp1", ",", "\n", "pooling", "=", "pooling", ",", "\n", "mlp2", "=", "mlp2", ",", "\n", "with_extra", "=", "with_extra", ",", "\n", "extra_size", "=", "extra_size", ",", "\n", ")", "\n", "self", ".", "temporal_encoder", "=", "GRU", "(", "\n", "in_channels", "=", "mlp2", "[", "-", "1", "]", ",", "\n", "hidden_dim", "=", "hidden_dim", ",", "\n", "max_position", "=", "max_position", ",", "\n", "max_temporal_shift", "=", "max_temporal_shift", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "get_decoder", "(", "mlp4", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseGru.forward": [[213, 229], ["stclassifier.PseGru.spatial_encoder", "stclassifier.PseGru.temporal_encoder", "stclassifier.PseGru.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pixels", ",", "mask", ",", "positions", ",", "extra", ",", "return_feats", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n           input(tuple): (Pixel-Set, Pixel-Mask) or ((Pixel-Set, Pixel-Mask), Extra-features)\n           Pixel-Set : Batch_size x Sequence length x Channel x Number of pixels\n           Pixel-Mask : Batch_size x Sequence length x Number of pixels\n           Positions : Batch_size x Sequence length\n           Extra-features : Batch_size x Sequence length x Number of features\n        \"\"\"", "\n", "spatial_feats", "=", "self", ".", "spatial_encoder", "(", "pixels", ",", "mask", ",", "extra", ")", "\n", "temporal_feats", "=", "self", ".", "temporal_encoder", "(", "spatial_feats", ",", "positions", ")", "\n", "logits", "=", "self", ".", "decoder", "(", "temporal_feats", ")", "\n", "if", "return_feats", ":", "\n", "            ", "return", "logits", ",", "temporal_feats", "\n", "", "else", ":", "\n", "            ", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseGru.param_ratio": [[230, 243], ["stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "print", "print"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams"], ["", "", "def", "param_ratio", "(", "self", ")", ":", "\n", "        ", "total", "=", "get_ntrainparams", "(", "self", ")", "\n", "s", "=", "get_ntrainparams", "(", "self", ".", "spatial_encoder", ")", "\n", "t", "=", "get_ntrainparams", "(", "self", ".", "temporal_encoder", ")", "\n", "c", "=", "get_ntrainparams", "(", "self", ".", "decoder", ")", "\n", "\n", "print", "(", "\"TOTAL TRAINABLE PARAMETERS : {}\"", ".", "format", "(", "total", ")", ")", "\n", "print", "(", "\n", "\"RATIOS: Spatial {:5.1f}% , Temporal {:5.1f}% , Classifier {:5.1f}%\"", ".", "format", "(", "\n", "s", "/", "total", "*", "100", ",", "t", "/", "total", "*", "100", ",", "c", "/", "total", "*", "100", "\n", ")", "\n", ")", "\n", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseTempCNN.__init__": [[250, 288], ["torch.Module.__init__", "models.pse.PixelSetEncoder", "models.competings.TempConv", "models.decoder.get_decoder", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.decoder.get_decoder"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", "=", "10", ",", "\n", "mlp1", "=", "[", "10", ",", "32", ",", "64", "]", ",", "\n", "pooling", "=", "\"mean_std\"", ",", "\n", "mlp2", "=", "[", "128", ",", "128", "]", ",", "\n", "with_extra", "=", "True", ",", "\n", "extra_size", "=", "4", ",", "\n", "nker", "=", "[", "32", ",", "32", ",", "128", "]", ",", "\n", "mlp3", "=", "[", "128", ",", "128", "]", ",", "\n", "seq_len", "=", "24", ",", "\n", "mlp4", "=", "[", "128", ",", "64", ",", "32", "]", ",", "\n", "num_classes", "=", "20", ",", "\n", "max_temporal_shift", "=", "100", ",", "\n", "max_position", "=", "365", ",", "\n", ")", ":", "\n", "        ", "super", "(", "PseTempCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "with_extra", ":", "\n", "            ", "mlp2", "=", "deepcopy", "(", "mlp2", ")", "\n", "mlp2", "[", "0", "]", "+=", "4", "\n", "\n", "", "self", ".", "spatial_encoder", "=", "PixelSetEncoder", "(", "\n", "input_dim", ",", "\n", "mlp1", "=", "mlp1", ",", "\n", "pooling", "=", "pooling", ",", "\n", "mlp2", "=", "mlp2", ",", "\n", "with_extra", "=", "with_extra", ",", "\n", "extra_size", "=", "extra_size", ",", "\n", ")", "\n", "self", ".", "temporal_encoder", "=", "TempConv", "(", "\n", "input_size", "=", "mlp2", "[", "-", "1", "]", ",", "\n", "nker", "=", "nker", ",", "\n", "seq_len", "=", "seq_len", ",", "\n", "nfc", "=", "mlp3", ",", "\n", "max_position", "=", "max_position", ",", "\n", "max_temporal_shift", "=", "max_temporal_shift", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "get_decoder", "(", "mlp4", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseTempCNN.forward": [[289, 305], ["stclassifier.PseTempCNN.spatial_encoder", "stclassifier.PseTempCNN.temporal_encoder", "stclassifier.PseTempCNN.decoder"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pixels", ",", "mask", ",", "positions", ",", "extra", ",", "return_feats", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n           input(tuple): (Pixel-Set, Pixel-Mask) or ((Pixel-Set, Pixel-Mask), Extra-features)\n           Pixel-Set : Batch_size x Sequence length x Channel x Number of pixels\n           Pixel-Mask : Batch_size x Sequence length x Number of pixels\n           Positions : Batch_size x Sequence length\n           Extra-features : Batch_size x Sequence length x Number of features\n        \"\"\"", "\n", "spatial_feats", "=", "self", ".", "spatial_encoder", "(", "pixels", ",", "mask", ",", "extra", ")", "\n", "temporal_feats", "=", "self", ".", "temporal_encoder", "(", "spatial_feats", ",", "positions", ")", "\n", "logits", "=", "self", ".", "decoder", "(", "temporal_feats", ")", "\n", "if", "return_feats", ":", "\n", "            ", "return", "logits", ",", "temporal_feats", "\n", "", "else", ":", "\n", "            ", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.PseTempCNN.param_ratio": [[306, 319], ["stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "stclassifier.get_ntrainparams", "print", "print"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams", "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams"], ["", "", "def", "param_ratio", "(", "self", ")", ":", "\n", "        ", "total", "=", "get_ntrainparams", "(", "self", ")", "\n", "s", "=", "get_ntrainparams", "(", "self", ".", "spatial_encoder", ")", "\n", "t", "=", "get_ntrainparams", "(", "self", ".", "temporal_encoder", ")", "\n", "c", "=", "get_ntrainparams", "(", "self", ".", "decoder", ")", "\n", "\n", "print", "(", "\"TOTAL TRAINABLE PARAMETERS : {}\"", ".", "format", "(", "total", ")", ")", "\n", "print", "(", "\n", "\"RATIOS: Spatial {:5.1f}% , Temporal {:5.1f}% , Classifier {:5.1f}%\"", ".", "format", "(", "\n", "s", "/", "total", "*", "100", ",", "t", "/", "total", "*", "100", ",", "c", "/", "total", "*", "100", "\n", ")", "\n", ")", "\n", "return", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.stclassifier.get_ntrainparams": [[321, 323], ["sum", "p.numel", "model.parameters"], "function", ["None"], ["", "", "def", "get_ntrainparams", "(", "model", ")", ":", "\n", "    ", "return", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.PixelSetEncoder.__init__": [[15, 69], ["torch.Module.__init__", "copy.deepcopy", "copy.deepcopy", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "len", "layers.append", "layers.append", "len", "len", "pooling.split", "len", "models.layers.LinearLayer", "len", "models.layers.LinearLayer", "pooling.split"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "mlp1", "=", "[", "10", ",", "32", ",", "64", "]", ",", "\n", "pooling", "=", "\"mean_std\"", ",", "\n", "mlp2", "=", "[", "64", ",", "128", "]", ",", "\n", "with_extra", "=", "True", ",", "\n", "extra_size", "=", "4", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Pixel-set encoder.\n        Args:\n            input_dim (int): Number of channels of the input tensors\n            mlp1 (list):  Dimensions of the successive feature spaces of MLP1\n            pooling (str): Pixel-embedding pooling strategy, can be chosen in ('mean','std','max,'min')\n                or any underscore-separated combination thereof.\n            mlp2 (list): Dimensions of the successive feature spaces of MLP2\n            with_extra (bool): Whether additional pre-computed features are passed between the two MLPs\n            extra_size (int, optional): Number of channels of the additional features, if any.\n        \"\"\"", "\n", "\n", "super", "(", "PixelSetEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "mlp1_dim", "=", "copy", ".", "deepcopy", "(", "mlp1", ")", "\n", "self", ".", "mlp2_dim", "=", "copy", ".", "deepcopy", "(", "mlp2", ")", "\n", "self", ".", "pooling", "=", "pooling", "\n", "\n", "self", ".", "with_extra", "=", "with_extra", "\n", "self", ".", "extra_size", "=", "extra_size", "\n", "\n", "self", ".", "output_dim", "=", "(", "\n", "input_dim", "*", "len", "(", "pooling", ".", "split", "(", "\"_\"", ")", ")", "\n", "if", "len", "(", "self", ".", "mlp2_dim", ")", "==", "0", "\n", "else", "self", ".", "mlp2_dim", "[", "-", "1", "]", "\n", ")", "\n", "\n", "inter_dim", "=", "self", ".", "mlp1_dim", "[", "-", "1", "]", "*", "len", "(", "pooling", ".", "split", "(", "\"_\"", ")", ")", "\n", "if", "self", ".", "with_extra", ":", "\n", "            ", "inter_dim", "+=", "self", ".", "extra_size", "\n", "\n", "", "assert", "input_dim", "==", "mlp1", "[", "0", "]", "\n", "assert", "inter_dim", "==", "mlp2", "[", "0", "]", "\n", "# Feature extraction", "\n", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "mlp1_dim", ")", "-", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "LinearLayer", "(", "self", ".", "mlp1_dim", "[", "i", "]", ",", "self", ".", "mlp1_dim", "[", "i", "+", "1", "]", ")", ")", "\n", "", "self", ".", "mlp1", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "# MLP after pooling", "\n", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "mlp2_dim", ")", "-", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "LinearLayer", "(", "self", ".", "mlp2_dim", "[", "i", "]", ",", "self", ".", "mlp2_dim", "[", "i", "+", "1", "]", ")", ")", "\n", "", "self", ".", "mlp2", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.PixelSetEncoder.forward": [[70, 101], ["torch.cat.view().transpose", "torch.cat.view().transpose", "torch.cat.view().transpose", "mask.view.view.view", "pse.PixelSetEncoder.mlp1().transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "pse.PixelSetEncoder.mlp2", "torch.cat.view", "torch.cat.view", "torch.cat.view", "extra.view.view.unsqueeze().repeat", "extra.view.view.view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat.view", "torch.cat.view", "torch.cat.view", "pse.PixelSetEncoder.mlp1", "pse.PixelSetEncoder.pooling.split", "extra.view.view.unsqueeze"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pixels", ",", "mask", ",", "extra", ")", ":", "\n", "        ", "\"\"\"\n        The input of the PSE is a tuple of tensors as yielded by the PixelSetData class:\n          (Pixel-Set, Pixel-Mask) or ((Pixel-Set, Pixel-Mask), Extra-features)\n        Pixel-Set : Batch_size x (Sequence length) x Channel x Number of pixels\n        Pixel-Mask : Batch_size x (Sequence length) x Number of pixels\n        Extra-features : Batch_size x (Sequence length) x Number of features\n\n        If the input tensors have a temporal dimension, it will be combined with the batch dimension so that the\n        complete sequences are processed at once. Then the temporal dimension is separated back to produce a tensor of\n        shape Batch_size x Sequence length x Embedding dimension\n        \"\"\"", "\n", "out", "=", "pixels", "\n", "\n", "batch", ",", "temp", "=", "out", ".", "shape", "[", ":", "2", "]", "\n", "\n", "out", "=", "out", ".", "view", "(", "batch", "*", "temp", ",", "*", "out", ".", "shape", "[", "2", ":", "]", ")", ".", "transpose", "(", "1", ",", "2", ")", "# (B*T, S, C)", "\n", "mask", "=", "mask", ".", "view", "(", "batch", "*", "temp", ",", "-", "1", ")", "\n", "\n", "out", "=", "self", ".", "mlp1", "(", "out", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "out", "=", "torch", ".", "cat", "(", "\n", "[", "pooling_methods", "[", "n", "]", "(", "out", ",", "mask", ")", "for", "n", "in", "self", ".", "pooling", ".", "split", "(", "\"_\"", ")", "]", ",", "dim", "=", "1", "\n", ")", "\n", "\n", "if", "self", ".", "with_extra", ":", "\n", "            ", "extra", "=", "extra", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "temp", ",", "1", ")", "\n", "extra", "=", "extra", ".", "view", "(", "batch", "*", "temp", ",", "-", "1", ")", "\n", "out", "=", "torch", ".", "cat", "(", "[", "out", ",", "extra", "]", ",", "dim", "=", "1", ")", "\n", "", "out", "=", "self", ".", "mlp2", "(", "out", ")", "\n", "out", "=", "out", ".", "view", "(", "batch", ",", "temp", ",", "-", "1", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.masked_mean": [[103, 109], ["x.permute", "out.permute.permute", "out.permute.sum", "mask.sum"], "function", ["None"], ["", "", "def", "masked_mean", "(", "x", ",", "mask", ")", ":", "\n", "    ", "out", "=", "x", ".", "permute", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "out", "=", "out", "*", "mask", "\n", "out", "=", "out", ".", "sum", "(", "dim", "=", "-", "1", ")", "/", "mask", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "out", "=", "out", ".", "permute", "(", "(", "1", ",", "0", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.masked_std": [[110, 125], ["pse.masked_mean", "x.permute", "out.permute.permute", "mask.sum", "torch.sqrt", "torch.sqrt", "torch.sqrt", "out.permute.permute"], "function", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.masked_mean"], ["", "def", "masked_std", "(", "x", ",", "mask", ")", ":", "\n", "    ", "m", "=", "masked_mean", "(", "x", ",", "mask", ")", "\n", "\n", "out", "=", "x", ".", "permute", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "out", "=", "out", "-", "m", "\n", "out", "=", "out", ".", "permute", "(", "(", "2", ",", "1", ",", "0", ")", ")", "\n", "\n", "out", "=", "out", "*", "mask", "\n", "d", "=", "mask", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "d", "[", "d", "==", "1", "]", "=", "2", "\n", "\n", "out", "=", "(", "out", "**", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "/", "(", "d", "-", "1", ")", "\n", "out", "=", "torch", ".", "sqrt", "(", "out", "+", "10e-32", ")", "# To ensure differentiability", "\n", "out", "=", "out", ".", "permute", "(", "1", ",", "0", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.maximum": [[126, 128], ["[].squeeze", "x.max"], "function", ["None"], ["", "def", "maximum", "(", "x", ",", "mask", ")", ":", "\n", "    ", "return", "x", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.pse.minimum": [[129, 131], ["[].squeeze", "x.min"], "function", ["None"], ["", "def", "minimum", "(", "x", ",", "mask", ")", ":", "\n", "    ", "return", "x", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ".", "squeeze", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.decoder.get_decoder": [[5, 19], ["range", "layers.append", "torch.Sequential", "layers.append", "torch.Linear", "len", "models.layers.LinearLayer"], "function", ["None"], ["def", "get_decoder", "(", "n_neurons", ",", "n_classes", ")", ":", "\n", "    ", "\"\"\"Returns an MLP with the layer widths specified in n_neurons.\n    Every linear layer but the last one is followed by BatchNorm + ReLu\n\n    args:\n        n_neurons (list): List of int that specifies the width and length of the MLP.\n        n_classes (int): Output size\n    \"\"\"", "\n", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "n_neurons", ")", "-", "1", ")", ":", "\n", "        ", "layers", ".", "append", "(", "LinearLayer", "(", "n_neurons", "[", "i", "]", ",", "n_neurons", "[", "i", "+", "1", "]", ")", ")", "\n", "", "layers", ".", "append", "(", "nn", ".", "Linear", "(", "n_neurons", "[", "-", "1", "]", ",", "n_classes", ")", ")", "\n", "m", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "return", "m", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.layers.LinearLayer.__init__": [[7, 12], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "in_dim", ",", "out_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "norm", "=", "nn", ".", "BatchNorm1d", "(", "out_dim", ")", "\n", "self", ".", "activation", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.layers.LinearLayer.forward": [[13, 22], ["layers.LinearLayer.linear", "layers.LinearLayer.activation", "layers.LinearLayer.dim", "layers.LinearLayer.norm().transpose", "layers.LinearLayer.norm", "layers.LinearLayer.norm", "layers.LinearLayer.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# x = (B, C) or (B, S, C)", "\n", "        ", "x", "=", "self", ".", "linear", "(", "x", ")", "# linear expect channels last", "\n", "if", "x", ".", "dim", "(", ")", "==", "3", ":", "\n", "# BatchNorm1d expects channels first, move to (B, C, S)", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "", "else", ":", "# (B, C)", "\n", "            ", "x", "=", "self", ".", "norm", "(", "x", ")", "\n", "", "return", "self", ".", "activation", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.layers.get_positional_encoding": [[25, 32], ["torch.zeros", "torch.zeros", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.exp", "torch.exp", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.arange", "torch.arange", "torch.arange().float", "torch.arange().float", "torch.arange", "torch.arange", "math.log"], "function", ["None"], ["", "", "def", "get_positional_encoding", "(", "max_len", ",", "d_model", ",", "T", "=", "1000.0", ")", ":", "\n", "    ", "pe", "=", "torch", ".", "zeros", "(", "max_len", ",", "d_model", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0", ",", "max_len", ",", "dtype", "=", "torch", ".", "float", ")", ".", "unsqueeze", "(", "1", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "d_model", ",", "2", ")", ".", "float", "(", ")", "*", "(", "-", "math", ".", "log", "(", "T", ")", "/", "d_model", ")", ")", "\n", "pe", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", "*", "div_term", ")", "\n", "pe", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", "*", "div_term", ")", "\n", "return", "pe", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.TemporalAttentionEncoder.__init__": [[20, 83], ["torch.Module.__init__", "copy.deepcopy", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "torch.LayerNorm", "tae.MultiHeadAttention", "range", "torch.Sequential", "torch.Sequential", "torch.Dropout", "torch.Dropout", "tae.get_positional_encoding", "torch.Conv1d", "torch.Conv1d", "layers.extend", "len", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.get_positional_encoding"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "128", ",", "\n", "n_head", "=", "4", ",", "\n", "d_k", "=", "32", ",", "\n", "d_model", "=", "None", ",", "\n", "n_neurons", "=", "[", "512", ",", "128", ",", "128", "]", ",", "\n", "dropout", "=", "0.2", ",", "\n", "T", "=", "1000", ",", "\n", "max_position", "=", "365", ",", "\n", "max_temporal_shift", "=", "100", ")", ":", "\n", "        ", "\"\"\"\n        Sequence-to-embedding encoder.\n        Args:\n            in_channels (int): Number of channels of the input embeddings\n            n_head (int): Number of attention heads\n            d_k (int): Dimension of the key and query vectors\n            n_neurons (list): Defines the dimensions of the successive feature spaces of the MLP that processes\n                the concatenated outputs of the attention heads\n            dropout (float): dropout\n            T (int): Period to use for the positional encoding\n            len_max_seq (int, optional): Maximum sequence length, used to pre-compute the positional encoding table\n            positions (list, optional): List of temporal positions to use instead of position in the sequence\n            d_model (int, optional): If specified, the input tensors will first processed by a fully connected layer\n                to project them into a feature space of dimension d_model\n\n        \"\"\"", "\n", "\n", "super", "(", "TemporalAttentionEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "n_neurons", "=", "copy", ".", "deepcopy", "(", "n_neurons", ")", "\n", "self", ".", "max_temporal_shift", "=", "max_temporal_shift", "\n", "\n", "self", ".", "position_enc", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "\n", "get_positional_encoding", "(", "max_position", "+", "2", "*", "max_temporal_shift", ",", "self", ".", "in_channels", ",", "T", "=", "T", ")", ",", "\n", "freeze", "=", "True", ")", "\n", "\n", "self", ".", "inlayernorm", "=", "nn", ".", "LayerNorm", "(", "self", ".", "in_channels", ")", "\n", "\n", "if", "d_model", "is", "not", "None", ":", "\n", "            ", "self", ".", "d_model", "=", "d_model", "\n", "self", ".", "inconv", "=", "nn", ".", "Conv1d", "(", "in_channels", ",", "d_model", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "d_model", "=", "in_channels", "\n", "self", ".", "inconv", "=", "None", "\n", "\n", "", "self", ".", "outlayernorm", "=", "nn", ".", "LayerNorm", "(", "n_neurons", "[", "-", "1", "]", ")", "\n", "\n", "self", ".", "attention_heads", "=", "MultiHeadAttention", "(", "n_head", "=", "n_head", ",", "\n", "d_k", "=", "d_k", ",", "\n", "d_in", "=", "self", ".", "d_model", ")", "\n", "\n", "assert", "(", "self", ".", "n_neurons", "[", "0", "]", "==", "n_head", "*", "self", ".", "d_model", ")", "\n", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "n_neurons", ")", "-", "1", ")", ":", "\n", "            ", "layers", ".", "extend", "(", "[", "\n", "nn", ".", "Linear", "(", "self", ".", "n_neurons", "[", "i", "]", ",", "self", ".", "n_neurons", "[", "i", "+", "1", "]", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "self", ".", "n_neurons", "[", "i", "+", "1", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", "]", ")", "\n", "\n", "", "self", ".", "mlp", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.TemporalAttentionEncoder.forward": [[84, 98], ["tae.TemporalAttentionEncoder.inlayernorm", "tae.TemporalAttentionEncoder.attention_heads", "tae.TemporalAttentionEncoder.permute().contiguous().view", "tae.TemporalAttentionEncoder.outlayernorm", "tae.TemporalAttentionEncoder.position_enc", "tae.TemporalAttentionEncoder.inconv().permute", "tae.TemporalAttentionEncoder.dropout", "tae.TemporalAttentionEncoder.permute().contiguous", "tae.TemporalAttentionEncoder.mlp", "tae.TemporalAttentionEncoder.inconv", "tae.TemporalAttentionEncoder.permute", "tae.TemporalAttentionEncoder.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "positions", ",", "return_att", "=", "False", ")", ":", "\n", "        ", "x", "=", "self", ".", "inlayernorm", "(", "x", ")", "\n", "enc_output", "=", "x", "+", "self", ".", "position_enc", "(", "positions", "+", "self", ".", "max_temporal_shift", ")", "\n", "\n", "if", "self", ".", "inconv", "is", "not", "None", ":", "\n", "            ", "enc_output", "=", "self", ".", "inconv", "(", "enc_output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "", "enc_output", ",", "attn", "=", "self", ".", "attention_heads", "(", "enc_output", ",", "enc_output", ",", "enc_output", ")", "\n", "enc_output", "=", "enc_output", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "# Concatenate heads", "\n", "enc_output", "=", "self", ".", "outlayernorm", "(", "self", ".", "dropout", "(", "self", ".", "mlp", "(", "enc_output", ")", ")", ")", "\n", "\n", "if", "return_att", ":", "\n", "            ", "return", "enc_output", ",", "attn", "\n", "", "else", ":", "\n", "            ", "return", "enc_output", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.MultiHeadAttention.__init__": [[102, 119], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.init.normal_", "torch.init.normal_", "torch.Linear", "torch.Linear", "torch.init.normal_", "torch.init.normal_", "torch.Sequential", "torch.Sequential", "tae.ScaledDotProductAttention", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Linear", "torch.Linear", "numpy.sqrt", "numpy.sqrt", "numpy.power"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "n_head", ",", "d_k", ",", "d_in", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_head", "=", "n_head", "\n", "self", ".", "d_k", "=", "d_k", "\n", "self", ".", "d_in", "=", "d_in", "\n", "\n", "self", ".", "fc1_q", "=", "nn", ".", "Linear", "(", "d_in", ",", "n_head", "*", "d_k", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "fc1_q", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "np", ".", "sqrt", "(", "2.0", "/", "(", "d_k", ")", ")", ")", "\n", "\n", "self", ".", "fc1_k", "=", "nn", ".", "Linear", "(", "d_in", ",", "n_head", "*", "d_k", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "fc1_k", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "np", ".", "sqrt", "(", "2.0", "/", "(", "d_k", ")", ")", ")", "\n", "\n", "self", ".", "fc2", "=", "nn", ".", "Sequential", "(", "nn", ".", "BatchNorm1d", "(", "n_head", "*", "d_k", ")", ",", "\n", "nn", ".", "Linear", "(", "n_head", "*", "d_k", ",", "n_head", "*", "d_k", ")", ")", "\n", "\n", "self", ".", "attention", "=", "ScaledDotProductAttention", "(", "\n", "temperature", "=", "np", ".", "power", "(", "d_k", ",", "0.5", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.MultiHeadAttention.forward": [[120, 144], ["q.permute().contiguous().view.permute().contiguous().view.size", "tae.MultiHeadAttention.fc1_q().view", "q.permute().contiguous().view.permute().contiguous().view.mean().squeeze", "tae.MultiHeadAttention.fc2().view", "q.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "tae.MultiHeadAttention.fc1_k().view", "k.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "v.repeat.repeat.repeat", "tae.MultiHeadAttention.attention", "output.squeeze.squeeze.view", "output.squeeze.squeeze.squeeze", "attn.squeeze.squeeze.view", "attn.squeeze.squeeze.squeeze", "tae.MultiHeadAttention.fc1_q", "q.permute().contiguous().view.permute().contiguous().view.mean", "tae.MultiHeadAttention.fc2", "q.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "tae.MultiHeadAttention.fc1_k", "k.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "q.permute().contiguous().view.permute().contiguous().view.view", "q.permute().contiguous().view.permute().contiguous().view.permute", "k.permute().contiguous().view.permute().contiguous().view.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "k", ",", "v", ")", ":", "\n", "        ", "d_k", ",", "d_in", ",", "n_head", "=", "self", ".", "d_k", ",", "self", ".", "d_in", ",", "self", ".", "n_head", "\n", "sz_b", ",", "seq_len", ",", "_", "=", "q", ".", "size", "(", ")", "\n", "\n", "q", "=", "self", ".", "fc1_q", "(", "q", ")", ".", "view", "(", "sz_b", ",", "seq_len", ",", "n_head", ",", "d_k", ")", "\n", "q", "=", "q", ".", "mean", "(", "dim", "=", "1", ")", ".", "squeeze", "(", ")", "# MEAN query", "\n", "q", "=", "self", ".", "fc2", "(", "q", ".", "view", "(", "sz_b", ",", "n_head", "*", "d_k", ")", ")", ".", "view", "(", "sz_b", ",", "n_head", ",", "d_k", ")", "\n", "q", "=", "q", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "n_head", "*", "sz_b", ",", "d_k", ")", "\n", "\n", "k", "=", "self", ".", "fc1_k", "(", "k", ")", ".", "view", "(", "sz_b", ",", "seq_len", ",", "n_head", ",", "d_k", ")", "\n", "k", "=", "k", ".", "permute", "(", "2", ",", "0", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "seq_len", ",", "\n", "d_k", ")", "# (n*b) x lk x dk", "\n", "\n", "v", "=", "v", ".", "repeat", "(", "n_head", ",", "1", ",", "1", ")", "# (n*b) x lv x d_in", "\n", "\n", "output", ",", "attn", "=", "self", ".", "attention", "(", "q", ",", "k", ",", "v", ")", "\n", "\n", "output", "=", "output", ".", "view", "(", "n_head", ",", "sz_b", ",", "1", ",", "d_in", ")", "\n", "output", "=", "output", ".", "squeeze", "(", "dim", "=", "2", ")", "\n", "\n", "attn", "=", "attn", ".", "view", "(", "n_head", ",", "sz_b", ",", "1", ",", "seq_len", ")", "\n", "attn", "=", "attn", ".", "squeeze", "(", "dim", "=", "2", ")", "\n", "\n", "return", "output", ",", "attn", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.ScaledDotProductAttention.__init__": [[148, 153], ["torch.Module.__init__", "torch.Dropout", "torch.Dropout", "torch.Softmax", "torch.Softmax"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "temperature", ",", "attn_dropout", "=", "0.1", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "temperature", "=", "temperature", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "attn_dropout", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.ScaledDotProductAttention.forward": [[154, 163], ["torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "tae.ScaledDotProductAttention.softmax", "tae.ScaledDotProductAttention.dropout", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "q.unsqueeze", "k.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "q", ",", "k", ",", "v", ")", ":", "\n", "        ", "attn", "=", "torch", ".", "matmul", "(", "q", ".", "unsqueeze", "(", "1", ")", ",", "k", ".", "transpose", "(", "1", ",", "2", ")", ")", "\n", "attn", "=", "attn", "/", "self", ".", "temperature", "\n", "\n", "attn", "=", "self", ".", "softmax", "(", "attn", ")", "\n", "attn", "=", "self", ".", "dropout", "(", "attn", ")", "\n", "output", "=", "torch", ".", "matmul", "(", "attn", ",", "v", ")", "\n", "\n", "return", "output", ",", "attn", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.get_positional_encoding": [[165, 172], ["torch.zeros", "torch.zeros", "torch.arange().unsqueeze", "torch.arange().unsqueeze", "torch.exp", "torch.exp", "torch.sin", "torch.sin", "torch.cos", "torch.cos", "torch.arange", "torch.arange", "torch.arange().float", "torch.arange().float", "torch.arange", "torch.arange", "math.log"], "function", ["None"], ["", "", "def", "get_positional_encoding", "(", "max_len", ",", "d_model", ",", "T", "=", "1000", ")", ":", "\n", "    ", "pe", "=", "torch", ".", "zeros", "(", "max_len", ",", "d_model", ")", "\n", "position", "=", "torch", ".", "arange", "(", "0", ",", "max_len", ",", "dtype", "=", "torch", ".", "float", ")", ".", "unsqueeze", "(", "1", ")", "\n", "div_term", "=", "torch", ".", "exp", "(", "torch", ".", "arange", "(", "0", ",", "d_model", ",", "2", ")", ".", "float", "(", ")", "*", "(", "-", "math", ".", "log", "(", "T", ")", "/", "d_model", ")", ")", "\n", "pe", "[", ":", ",", "0", ":", ":", "2", "]", "=", "torch", ".", "sin", "(", "position", "*", "div_term", ")", "\n", "pe", "[", ":", ",", "1", ":", ":", "2", "]", "=", "torch", ".", "cos", "(", "position", "*", "div_term", ")", "\n", "return", "pe", "\n", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.competings.GRU.__init__": [[12, 21], ["torch.Module.__init__", "torch.GRU", "torch.Embedding.from_pretrained", "models.tae.get_positional_encoding"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.get_positional_encoding"], ["def", "__init__", "(", "self", ",", "in_channels", "=", "128", ",", "hidden_dim", "=", "128", ",", "max_position", "=", "365", ",", "max_temporal_shift", "=", "100", ")", ":", "\n", "        ", "super", "(", "GRU", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "name", "=", "'GRU_h{}'", ".", "format", "(", "hidden_dim", ")", "\n", "self", ".", "gru_cell", "=", "nn", ".", "GRU", "(", "input_size", "=", "in_channels", ",", "hidden_size", "=", "hidden_dim", ",", "batch_first", "=", "True", ")", "\n", "\n", "self", ".", "max_temporal_shift", "=", "max_temporal_shift", "\n", "self", ".", "position_enc", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "\n", "get_positional_encoding", "(", "max_position", "+", "2", "*", "max_temporal_shift", ",", "self", ".", "in_channels", ",", "T", "=", "1000", ")", ",", "\n", "freeze", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.competings.GRU.forward": [[22, 26], ["competings.GRU.gru_cell", "competings.GRU.position_enc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "positions", ")", ":", "\n", "        ", "enc_output", "=", "input", "+", "self", ".", "position_enc", "(", "positions", "+", "self", ".", "max_temporal_shift", ")", "\n", "out", ",", "_", "=", "self", ".", "gru_cell", "(", "enc_output", ")", "\n", "return", "out", "[", ":", ",", "-", "1", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.competings.TempConv.__init__": [[33, 71], ["torch.Module.__init__", "copy.deepcopy", "copy.deepcopy", "competings.TempConv.nker.insert", "range", "torch.Sequential", "competings.TempConv.nfc.insert", "range", "torch.Sequential", "torch.Embedding.from_pretrained", "list", "conv_layers.extend", "lin_layers.extend", "models.tae.get_positional_encoding", "map", "list", "len", "len", "map", "torch.Conv1d", "torch.BatchNorm1d", "torch.ReLU", "torch.Linear", "torch.BatchNorm1d", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.get_positional_encoding"], ["def", "__init__", "(", "self", ",", "input_size", ",", "nker", ",", "seq_len", ",", "nfc", ",", "max_position", "=", "365", ",", "max_temporal_shift", "=", "100", ")", ":", "\n", "        ", "super", "(", "TempConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "seq_len", "=", "seq_len", "\n", "self", ".", "name", "=", "'TempCNN_'", "\n", "\n", "self", ".", "nker", "=", "copy", ".", "deepcopy", "(", "nker", ")", "\n", "self", ".", "nfc", "=", "copy", ".", "deepcopy", "(", "nfc", ")", "\n", "self", ".", "name", "+=", "'|'", ".", "join", "(", "list", "(", "map", "(", "str", ",", "self", ".", "nker", ")", ")", ")", "\n", "\n", "if", "self", ".", "nfc", "is", "not", "None", ":", "\n", "            ", "self", ".", "name", "+=", "'FC'", "\n", "self", ".", "name", "+=", "'|'", ".", "join", "(", "list", "(", "map", "(", "str", ",", "self", ".", "nfc", ")", ")", ")", "\n", "\n", "", "conv_layers", "=", "[", "]", "\n", "self", ".", "nker", ".", "insert", "(", "0", ",", "input_size", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nker", ")", "-", "1", ")", ":", "\n", "            ", "conv_layers", ".", "extend", "(", "[", "\n", "nn", ".", "Conv1d", "(", "self", ".", "nker", "[", "i", "]", ",", "self", ".", "nker", "[", "i", "+", "1", "]", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "self", ".", "nker", "[", "i", "+", "1", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", "]", ")", "\n", "", "self", ".", "conv1d", "=", "nn", ".", "Sequential", "(", "*", "conv_layers", ")", "\n", "\n", "self", ".", "nfc", ".", "insert", "(", "0", ",", "self", ".", "nker", "[", "-", "1", "]", "*", "seq_len", ")", "\n", "lin_layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "nfc", ")", "-", "1", ")", ":", "\n", "            ", "lin_layers", ".", "extend", "(", "[", "\n", "nn", ".", "Linear", "(", "self", ".", "nfc", "[", "i", "]", ",", "self", ".", "nfc", "[", "i", "+", "1", "]", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "self", ".", "nfc", "[", "i", "+", "1", "]", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", "\n", "]", ")", "\n", "", "self", ".", "linear", "=", "nn", ".", "Sequential", "(", "*", "lin_layers", ")", "\n", "\n", "self", ".", "max_temporal_shift", "=", "max_temporal_shift", "\n", "self", ".", "position_enc", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "\n", "get_positional_encoding", "(", "max_position", "+", "2", "*", "max_temporal_shift", ",", "self", ".", "in_channels", ",", "T", "=", "1000", ")", ",", "\n", "freeze", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.competings.TempConv.forward": [[73, 79], ["competings.TempConv.conv1d", "competings.TempConv.view", "competings.TempConv.linear", "competings.TempConv.position_enc", "enc_output.permute"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "positions", ")", ":", "\n", "        ", "enc_output", "=", "input", "+", "self", ".", "position_enc", "(", "positions", "+", "self", ".", "max_temporal_shift", ")", "\n", "out", "=", "self", ".", "conv1d", "(", "enc_output", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear", "(", "out", ")", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.LTAE.__init__": [[22, 83], ["torch.Module.__init__", "copy.deepcopy", "torch.Embedding.from_pretrained", "torch.Embedding.from_pretrained", "ltae.MultiHeadAttention", "range", "torch.Sequential", "torch.Sequential", "torch.Dropout", "torch.Dropout", "models.layers.LinearLayer", "models.layers.get_positional_encoding", "layers.append", "len", "models.layers.LinearLayer"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__", "home.repos.pwc.inspect_result.jnyborg_timematch.models.tae.get_positional_encoding"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_channels", "=", "128", ",", "\n", "n_head", "=", "16", ",", "\n", "d_k", "=", "8", ",", "\n", "n_neurons", "=", "[", "256", ",", "128", "]", ",", "\n", "dropout", "=", "0.2", ",", "\n", "d_model", "=", "256", ",", "\n", "T", "=", "1000", ",", "\n", "max_temporal_shift", "=", "100", ",", "\n", "max_position", "=", "365", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Sequence-to-embedding encoder.\n        Args:\n            in_channels (int): Number of channels of the input embeddings\n            n_head (int): Number of attention heads\n            d_k (int): Dimension of the key and query vectors\n            n_neurons (list): Defines the dimensions of the successive feature spaces of the MLP that processes\n                the concatenated outputs of the attention heads\n            dropout (float): dropout\n            T (int): Period to use for the positional encoding\n            len_max_seq (int, optional): Maximum sequence length, used to pre-compute the positional encoding table\n            positions (list, optional): List of temporal positions to use instead of position in the sequence\n            d_model (int, optional): If specified, the input tensors will first processed by a fully connected layer\n                to project them into a feature space of dimension d_model\n            return_att (bool): If true, the module returns the attention masks along with the embeddings (default False)\n\n        \"\"\"", "\n", "\n", "super", "(", "LTAE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "n_neurons", "=", "copy", ".", "deepcopy", "(", "n_neurons", ")", "\n", "self", ".", "max_temporal_shift", "=", "max_temporal_shift", "\n", "\n", "if", "d_model", "is", "not", "None", ":", "\n", "            ", "self", ".", "d_model", "=", "d_model", "\n", "# self.inconv = nn.Conv1d(in_channels, d_model, 1)", "\n", "self", ".", "inconv", "=", "LinearLayer", "(", "in_channels", ",", "d_model", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "d_model", "=", "in_channels", "\n", "self", ".", "inconv", "=", "None", "\n", "\n", "", "self", ".", "positional_enc", "=", "nn", ".", "Embedding", ".", "from_pretrained", "(", "get_positional_encoding", "(", "max_position", "+", "2", "*", "max_temporal_shift", ",", "self", ".", "d_model", ",", "T", "=", "T", ")", ",", "freeze", "=", "True", ")", "\n", "# not splitting positional encoding seems to adapt better", "\n", "# sin_tab = get_positional_encoding(max_position + 2*max_temporal_shift, self.d_model // n_head, T=T)", "\n", "# self.positional_enc = nn.Embedding.from_pretrained(torch.cat([sin_tab for _ in range(n_head)], dim=1), freeze=True)", "\n", "\n", "# self.inlayernorm = nn.LayerNorm(self.in_channels)", "\n", "# self.outlayernorm = nn.LayerNorm(n_neurons[-1])", "\n", "\n", "self", ".", "attention_heads", "=", "MultiHeadAttention", "(", "n_head", "=", "n_head", ",", "d_k", "=", "d_k", ",", "d_in", "=", "self", ".", "d_model", ")", "\n", "\n", "assert", "(", "self", ".", "n_neurons", "[", "0", "]", "==", "self", ".", "d_model", ")", "\n", "\n", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "n_neurons", ")", "-", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "LinearLayer", "(", "self", ".", "n_neurons", "[", "i", "]", ",", "self", ".", "n_neurons", "[", "i", "+", "1", "]", ")", ")", "\n", "\n", "", "self", ".", "mlp", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.LTAE.forward": [[84, 97], ["ltae.LTAE.attention_heads", "ltae.LTAE.dropout", "ltae.LTAE.inconv", "ltae.LTAE.positional_enc", "ltae.LTAE.mlp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "positions", ",", "return_att", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "inconv", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "inconv", "(", "x", ")", "\n", "", "enc_output", "=", "x", "+", "self", ".", "positional_enc", "(", "positions", "+", "self", ".", "max_temporal_shift", ")", "\n", "\n", "enc_output", ",", "attn", "=", "self", ".", "attention_heads", "(", "enc_output", ")", "\n", "\n", "enc_output", "=", "self", ".", "dropout", "(", "self", ".", "mlp", "(", "enc_output", ")", ")", "\n", "\n", "if", "return_att", ":", "\n", "            ", "return", "enc_output", ",", "attn", "\n", "", "else", ":", "\n", "            ", "return", "enc_output", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__": [[101, 114], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Parameter().requires_grad_", "torch.Parameter().requires_grad_", "torch.init.normal_", "torch.init.normal_", "numpy.power", "torch.Dropout", "torch.Dropout", "torch.Softmax", "torch.Softmax", "torch.Parameter", "torch.Parameter", "numpy.sqrt", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.__init__"], ["def", "__init__", "(", "self", ",", "n_head", ",", "d_k", ",", "d_in", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_head", "=", "n_head", "\n", "self", ".", "d_k", "=", "d_k", "\n", "self", ".", "d_in", "=", "d_in", "\n", "\n", "self", ".", "key", "=", "nn", ".", "Linear", "(", "d_in", ",", "n_head", "*", "d_k", ")", "\n", "self", ".", "query", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "n_head", ",", "d_k", ")", ")", ".", "requires_grad_", "(", "True", ")", "\n", "nn", ".", "init", ".", "normal_", "(", "self", ".", "query", ",", "mean", "=", "0", ",", "std", "=", "np", ".", "sqrt", "(", "2.0", "/", "(", "d_k", ")", ")", ")", "\n", "\n", "self", ".", "temperature", "=", "np", ".", "power", "(", "d_k", ",", "0.5", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "0.1", ")", "\n", "self", ".", "softmax", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.jnyborg_timematch.models.ltae.MultiHeadAttention.forward": [[116, 129], ["x.size", "ltae.MultiHeadAttention.query.repeat().transpose", "ltae.MultiHeadAttention.key().view().transpose", "x.view().transpose", "ltae.MultiHeadAttention.softmax", "ltae.MultiHeadAttention.dropout", "y.transpose().contiguous().view.transpose().contiguous().view.transpose().contiguous().view", "ltae.MultiHeadAttention.query.repeat", "ltae.MultiHeadAttention.key().view", "x.view", "ltae.MultiHeadAttention.transpose", "y.transpose().contiguous().view.transpose().contiguous().view.transpose().contiguous", "ltae.MultiHeadAttention.key", "y.transpose().contiguous().view.transpose().contiguous().view.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Slightly more efficient re-implementation of LTAE", "\n", "        ", "B", ",", "T", ",", "C", "=", "x", ".", "size", "(", ")", "\n", "q", "=", "self", ".", "query", ".", "repeat", "(", "B", ",", "1", ",", "1", ",", "1", ")", ".", "transpose", "(", "1", ",", "2", ")", "# (nh, hs) -> (B, nh, 1, d_k)", "\n", "k", "=", "self", ".", "key", "(", "x", ")", ".", "view", "(", "B", ",", "T", ",", "self", ".", "n_head", ",", "self", ".", "d_k", ")", ".", "transpose", "(", "1", ",", "2", ")", "# (B, nh, T, d_k)", "\n", "v", "=", "x", ".", "view", "(", "B", ",", "T", ",", "self", ".", "n_head", ",", "C", "//", "self", ".", "n_head", ")", ".", "transpose", "(", "1", ",", "2", ")", "\n", "# self-attend; (B, nh, 1, d_k) x (B, nh, d_k, T) -> (B, nh, 1, T)", "\n", "att", "=", "(", "q", "@", "k", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ")", "/", "self", ".", "temperature", "\n", "att", "=", "self", ".", "softmax", "(", "att", ")", "\n", "att", "=", "self", ".", "dropout", "(", "att", ")", "\n", "y", "=", "att", "@", "v", "# (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)", "\n", "y", "=", "y", ".", "transpose", "(", "1", ",", "2", ")", ".", "contiguous", "(", ")", ".", "view", "(", "B", ",", "C", ")", "\n", "return", "y", ",", "att", "\n", "", "", ""]]}