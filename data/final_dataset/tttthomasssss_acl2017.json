{"home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.split_path_from_word": [[14, 43], ["event.count", "reversed", "event.split", "event.count", "event.rsplit", "reversed", "path.insert", "path.insert", "dep.startswith", "dep.split", "len", "word.insert", "subpath.insert", "word.insert", "subpath.pop", "sub_dep.startswith"], "function", ["None"], ["def", "split_path_from_word", "(", "event", ",", "universal_deps", "=", "[", "]", ")", ":", "\n", "    ", "if", "(", "event", ".", "count", "(", "':'", ")", ">", "1", ")", ":", "\n", "        ", "path", "=", "[", "]", "\n", "word", "=", "[", "]", "\n", "\n", "for", "dep", "in", "reversed", "(", "event", ".", "split", "(", "'\\xbb'", ")", ")", ":", "\n", "            ", "d", "=", "dep", "if", "not", "dep", ".", "startswith", "(", "'_'", ")", "else", "dep", "[", "1", ":", "]", "\n", "\n", "if", "(", "':'", "in", "d", ")", ":", "\n", "                ", "subpath", "=", "[", "]", "\n", "for", "sub_dep", "in", "reversed", "(", "dep", ".", "split", "(", "':'", ")", ")", ":", "\n", "                    ", "sd", "=", "sub_dep", "if", "not", "sub_dep", ".", "startswith", "(", "'_'", ")", "else", "sub_dep", "[", "1", ":", "]", "\n", "if", "(", "sd", "in", "universal_deps", ")", ":", "\n", "                        ", "subpath", ".", "insert", "(", "0", ",", "sub_dep", ")", "\n", "", "else", ":", "\n", "                        ", "word", ".", "insert", "(", "0", ",", "sub_dep", ")", "\n", "\n", "# Handle words that happen to have the same signifier as a dependency", "\n", "", "", "if", "(", "len", "(", "word", ")", "<=", "0", ")", ":", "\n", "                    ", "word", ".", "insert", "(", "0", ",", "subpath", ".", "pop", "(", ")", ")", "\n", "\n", "", "path", ".", "insert", "(", "0", ",", "':'", ".", "join", "(", "subpath", ")", ")", "\n", "", "else", ":", "\n", "                ", "path", ".", "insert", "(", "0", ",", "dep", ")", "\n", "", "", "return", "'\\xbb'", ".", "join", "(", "path", ")", ",", "':'", ".", "join", "(", "word", ")", "\n", "", "elif", "(", "event", ".", "count", "(", "':'", ")", "<=", "0", ")", ":", "# Could be a simple co-occurrence count vector", "\n", "        ", "return", "''", ",", "event", "\n", "", "else", ":", "\n", "        ", "return", "event", ".", "rsplit", "(", "':'", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.apply_offset_path": [[45, 68], ["path.startswith", "vector_utils.split_path_from_word", "head.split", "path.startswith"], "function", ["home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.split_path_from_word"], ["", "", "def", "apply_offset_path", "(", "path", ",", "offset", ",", "incompatible_paths", "=", "'strict'", ")", ":", "\n", "    ", "'''\n    :param path: dependency path feature\n    :param offset: offset path\n    :param incompatible_paths: pass 'strict' to exclude incompatible paths (double negative path) or 'ignore' to leave them in\n    :return: offset_path or None if the path is incompatible and `incompatible_paths='strict'`\n    '''", "\n", "\n", "if", "(", "path", ".", "startswith", "(", "':'", ")", ")", ":", "# EPSILON", "\n", "        ", "offset_path", "=", "offset", "+", "path", "\n", "", "else", ":", "\n", "        ", "head", ",", "feat", "=", "split_path_from_word", "(", "path", ")", "\n", "\n", "parts", "=", "head", ".", "split", "(", "'\\xbb'", ")", "\n", "\n", "if", "(", "'_{}'", ".", "format", "(", "parts", "[", "0", "]", ")", "==", "offset", "or", "'_{}'", ".", "format", "(", "offset", ")", "==", "parts", "[", "0", "]", ")", ":", "\n", "            ", "offset_path", "=", "'{}:{}'", ".", "format", "(", "'\\xbb'", ".", "join", "(", "parts", "[", "1", ":", "]", ")", ",", "feat", ")", "\n", "", "elif", "(", "path", ".", "startswith", "(", "'_'", ")", "and", "incompatible_paths", "==", "'strict'", ")", ":", "# Incompatible feature", "\n", "            ", "offset_path", "=", "None", "\n", "", "else", ":", "\n", "            ", "offset_path", "=", "'\\xbb'", ".", "join", "(", "[", "offset", ",", "path", "]", ")", "\n", "\n", "", "", "return", "offset_path", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.create_offset_vector": [[70, 83], ["offset_path.startswith", "vector.keys", "vector_utils.apply_offset_path"], "function", ["home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.apply_offset_path"], ["", "def", "create_offset_vector", "(", "vector", ",", "offset_path", ",", "incompatible_paths", "=", "'strict'", ")", ":", "\n", "# Translate from my notation to Dave's notation", "\n", "    ", "if", "(", "offset_path", ".", "startswith", "(", "'!'", ")", ")", ":", "\n", "        ", "offset_path", "=", "'_'", "+", "offset_path", "[", "1", ":", "]", "\n", "\n", "", "v", "=", "{", "}", "\n", "for", "feat", "in", "vector", ".", "keys", "(", ")", ":", "\n", "        ", "new_feat_path", "=", "apply_offset_path", "(", "feat", ",", "offset_path", ",", "incompatible_paths", "=", "incompatible_paths", ")", "\n", "\n", "if", "(", "new_feat_path", "is", "not", "None", ")", ":", "\n", "            ", "v", "[", "new_feat_path", "]", "=", "vector", "[", "feat", "]", "\n", "\n", "", "", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.collapse_offset_vector": [[85, 103], ["collections.defaultdict", "offset_vector.keys", "key.rsplit", "head.split", "len"], "function", ["None"], ["", "def", "collapse_offset_vector", "(", "offset_vector", ",", "offset_path", "=", "None", ")", ":", "\n", "    ", "reduced_offset_vector", "=", "collections", ".", "defaultdict", "(", "float", ")", "\n", "for", "key", "in", "offset_vector", ".", "keys", "(", ")", ":", "\n", "        ", "head", ",", "feat", "=", "key", ".", "rsplit", "(", "':'", ",", "1", ")", "\n", "\n", "parts", "=", "head", ".", "split", "(", "'\\xbb'", ")", "\n", "if", "(", "len", "(", "parts", ")", ">", "1", ")", ":", "\n", "            ", "offset", "=", "parts", "[", "0", "]", "if", "offset_path", "is", "None", "else", "offset_path", "\n", "if", "(", "offset", "[", "1", ":", "]", "==", "parts", "[", "1", "]", "or", "offset", "==", "parts", "[", "1", "]", "[", "1", ":", "]", ")", ":", "\n", "                ", "new_key", "=", "'{}:{}'", ".", "format", "(", "'\\xbb'", ".", "join", "(", "parts", "[", "2", ":", "]", ")", ",", "feat", ")", "\n", "", "else", ":", "\n", "                ", "new_key", "=", "key", "\n", "", "", "else", ":", "\n", "            ", "new_key", "=", "key", "\n", "\n", "", "reduced_offset_vector", "[", "new_key", "]", "+=", "offset_vector", "[", "key", "]", "\n", "\n", "return", "reduced_offset_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.load_vector_cache": [[105, 116], ["vector_in_file.endswith", "open", "dill.load", "vector_in_file.endswith", "joblib.load", "vector_in_file.endswith", "sqlitedict.SqliteDict", "kwargs.pop"], "function", ["None"], ["", "", "def", "load_vector_cache", "(", "vector_in_file", ",", "filetype", "=", "''", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "(", "vector_in_file", ".", "endswith", "(", "'.dill'", ")", "or", "filetype", "==", "'dill'", ")", ":", "\n", "        ", "with", "open", "(", "vector_in_file", ",", "'rb'", ")", "as", "data_file", ":", "\n", "            ", "vectors", "=", "dill", ".", "load", "(", "data_file", ")", "\n", "", "return", "vectors", "\n", "", "elif", "(", "vector_in_file", ".", "endswith", "(", "'.joblib'", ")", "or", "filetype", "==", "'joblib'", ")", ":", "\n", "        ", "return", "joblib", ".", "load", "(", "vector_in_file", ")", "\n", "", "elif", "(", "vector_in_file", ".", "endswith", "(", "'.sqlite'", ")", "or", "filetype", "==", "'sqlite'", ")", ":", "\n", "        ", "return", "SqliteDict", "(", "vector_in_file", ",", "autocommit", "=", "kwargs", ".", "pop", "(", "'autocommit'", ",", "True", ")", ",", "flag", "=", "'r'", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.utils.vector_utils.save_vector_cache": [[118, 139], ["logging.info", "vector_out_file.endswith", "len", "open", "dill.dump", "vector_out_file.endswith", "joblib.dump", "vector_out_file.endswith", "kwargs.pop", "isinstance", "kwargs.get", "kwargs.get", "kwargs.get", "vectors.commit", "sqlitedict.SqliteDict", "vectors.items", "data_file.commit"], "function", ["None"], ["", "", "def", "save_vector_cache", "(", "vectors", ",", "vector_out_file", ",", "filetype", "=", "''", ",", "**", "kwargs", ")", ":", "\n", "    ", "logging", ".", "info", "(", "\"Saving {} vectors to cache {}\"", ".", "format", "(", "len", "(", "vectors", ")", ",", "vector_out_file", ")", ")", "\n", "if", "(", "vector_out_file", ".", "endswith", "(", "'.dill'", ")", "or", "filetype", "==", "'dill'", ")", ":", "\n", "        ", "with", "open", "(", "vector_out_file", ",", "'wb'", ")", "as", "data_file", ":", "\n", "            ", "dill", ".", "dump", "(", "vectors", ",", "data_file", ",", "protocol", "=", "kwargs", ".", "get", "(", "'dill_protocol'", ",", "3", ")", ")", "\n", "", "", "elif", "(", "vector_out_file", ".", "endswith", "(", "'.joblib'", ")", "or", "filetype", "==", "'joblib'", ")", ":", "\n", "        ", "joblib", ".", "dump", "(", "vectors", ",", "vector_out_file", ",", "compress", "=", "kwargs", ".", "get", "(", "'joblib_compression'", ",", "3", ")", ",", "\n", "protocol", "=", "kwargs", ".", "get", "(", "'joblib_protocol'", ",", "3", ")", ")", "\n", "", "elif", "(", "vector_out_file", ".", "endswith", "(", "'.sqlite'", ")", "or", "filetype", "==", "'sqlite'", ")", ":", "\n", "        ", "autocommit", "=", "kwargs", ".", "pop", "(", "'autocommit'", ",", "True", ")", "\n", "if", "(", "isinstance", "(", "vectors", ",", "SqliteDict", ")", ")", ":", "\n", "            ", "vectors", ".", "commit", "(", ")", "\n", "", "else", ":", "\n", "            ", "with", "SqliteDict", "(", "vector_out_file", ",", "autocommit", "=", "autocommit", ")", "as", "data_file", ":", "\n", "                ", "for", "key", ",", "value", "in", "vectors", ".", "items", "(", ")", ":", "\n", "                    ", "data_file", "[", "key", "]", "=", "value", "\n", "\n", "", "if", "(", "not", "autocommit", ")", ":", "\n", "                    ", "data_file", ".", "commit", "(", ")", "\n", "", "", "", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "", "", "", ""]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.distributional_inference.distributional_inference.static_top_n": [[9, 59], ["isinstance", "isinstance", "kwargs.pop", "Vectors.from_dict_of_dicts.init_sims", "vectors.keys", "Vectors.from_dict_of_dicts.get_vector", "sparse.csr_matrix.copy", "discoutils.thesaurus_loader.Vectors.from_dict_of_dicts", "ValueError", "scipy.sparse.csr_matrix", "Vectors.from_dict_of_dicts.get_nearest_neighbours", "scipy.sparse.csr_matrix", "Vectors.from_dict_of_dicts.get_vector", "logging.error"], "function", ["None"], ["def", "static_top_n", "(", "vectors", ",", "words", "=", "None", ",", "num_neighbours", "=", "10", ",", "alpha", "=", "'auto'", ",", "nn_metric", "=", "'cosine'", ",", "**", "kwargs", ")", ":", "\n", "\t", "\"\"\"\n\tPerform smoothing by associative inference\n\t:param vectors: Original elementary APTs\n\t:param words: Lexemes of interest to apply distributional inference on (pass None for all lexemes)\n\t:param num_neighbours: Number of neighbours used for distributional inference\n\t:param alpha: weighting of original vector (default='auto', which multiplies the original vectors by `num_neighbours`)\n\t:param nn_metric: nearest neighbour metric to use (default='cosine'; supported are 'cosine' and 'euclidean')\n\t:return: smoothed apt vector\n\t\"\"\"", "\n", "smoothed_vectors", "=", "{", "}", "\n", "if", "(", "isinstance", "(", "vectors", ",", "Vectors", ")", ")", ":", "\n", "\t\t", "disco_vectors", "=", "vectors", "\n", "", "else", ":", "# Passive-Aggressive-Defensive loading cascade", "\n", "\t\t", "if", "(", "isinstance", "(", "vectors", ",", "dict", ")", ")", ":", "\n", "\t\t\t", "disco_vectors", "=", "Vectors", ".", "from_dict_of_dicts", "(", "vectors", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'Unsupported type[{}] for `vectors` supplied. Supported types are [`discoutils.thesaurus_loader.Vectors` and `dict`]!'", ")", "\n", "\n", "", "", "if", "(", "not", "kwargs", ".", "pop", "(", "'is_initialised'", ",", "False", ")", ")", ":", "\n", "\t\t", "disco_vectors", ".", "init_sims", "(", "n_neighbors", "=", "num_neighbours", ",", "nn_metric", "=", "nn_metric", ",", "knn", "=", "'brute'", "if", "nn_metric", "==", "'cosine'", "else", "'kd_tree'", ")", "\n", "\n", "", "words", "=", "words", "if", "words", "is", "not", "None", "else", "vectors", ".", "keys", "(", ")", "\n", "\n", "a", "=", "alpha", "if", "alpha", "!=", "'auto'", "else", "num_neighbours", "\n", "for", "w", "in", "words", ":", "\n", "\t\t", "if", "(", "w", "not", "in", "disco_vectors", ")", ":", "\n", "\t\t\t", "smoothed_vectors", "[", "w", "]", "=", "sparse", ".", "csr_matrix", "(", "(", "1", ",", "disco_vectors", ".", "matrix", ".", "shape", "[", "1", "]", ")", ")", "\n", "continue", "\n", "\n", "", "neighbours", "=", "[", "]", "\n", "try", ":", "\n", "\t\t\t", "neighbours", "=", "disco_vectors", ".", "get_nearest_neighbours", "(", "w", ")", "\n", "", "except", "ValueError", "as", "ex", ":", "\n", "\t\t\t", "import", "logging", "\n", "logging", ".", "error", "(", "'Failed to retrieve neighbours for w={}: {}...'", ".", "format", "(", "w", ",", "ex", ")", ")", "\n", "raise", "ex", "\n", "\n", "# Enrich original vector", "\n", "", "apt", "=", "disco_vectors", ".", "get_vector", "(", "w", ")", "\n", "if", "(", "apt", "is", "None", ")", ":", "# OOV", "\n", "\t\t\t", "apt", "=", "sparse", ".", "csr_matrix", "(", "(", "1", ",", "disco_vectors", ".", "matrix", ".", "shape", "[", "1", "]", ")", ")", "\n", "", "apt", "*=", "a", "\n", "\n", "for", "neighbour", ",", "_", "in", "neighbours", ":", "\n", "\t\t\t", "apt", "+=", "disco_vectors", ".", "get_vector", "(", "neighbour", ")", "\n", "\n", "", "smoothed_vectors", "[", "w", "]", "=", "apt", ".", "copy", "(", ")", "\n", "\n", "", "return", "disco_vectors", ",", "smoothed_vectors", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.distributional_inference.distributional_inference.density_window": [[61, 110], ["isinstance", "isinstance", "kwargs.pop", "Vectors.from_dict_of_dicts.init_sims", "vectors.keys", "Vectors.from_dict_of_dicts.get_nearest_neighbours", "apt.copy", "discoutils.thesaurus_loader.Vectors.from_dict_of_dicts", "ValueError", "Vectors.from_dict_of_dicts.get_nearest_neighbours", "neighbours.append", "Vectors.from_dict_of_dicts.get_vector", "Vectors.from_dict_of_dicts.get_vector"], "function", ["None"], ["", "def", "density_window", "(", "vectors", ",", "words", "=", "None", ",", "num_neighbours", "=", "10", ",", "window_size", "=", "0.1", ",", "alpha", "=", "'auto'", ",", "nn_metric", "=", "'cosine'", ",", "**", "kwargs", ")", ":", "\n", "\t", "\"\"\"\n\tPerform smoothing by associative inference\n\t:param vectors: Original elementary APTs\n\t:param words: Lexemes of interest to apply distributional inference on (pass None for all lexemes)\n\t:param num_neighbours: Maximum number of neighbours used for distributional inference\n\t:param window_size: proportional distance to nearest neighbour, defining the parzen window for each vector individually (default=0.1)\n\t:param alpha: weighting of original vector (default='auto', which multiplies the original vectors by `num_neighbours`)\n\t:param nn_metric: nearest neighbour metric to use (default='cosine'; supported are 'cosine' and 'euclidean')\n\t:return: smoothed apt vector\n\t\"\"\"", "\n", "smoothed_vectors", "=", "{", "}", "\n", "if", "(", "isinstance", "(", "vectors", ",", "Vectors", ")", ")", ":", "\n", "\t\t", "disco_vectors", "=", "vectors", "\n", "", "else", ":", "# Passive-Aggressive-Defensive loading cascade", "\n", "\t\t", "if", "(", "isinstance", "(", "vectors", ",", "dict", ")", ")", ":", "\n", "\t\t\t", "disco_vectors", "=", "Vectors", ".", "from_dict_of_dicts", "(", "vectors", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'Unsupported type[{}] for `vectors` supplied. Supported types are [`discoutils.thesaurus_loader.Vectors` and `dict`]!'", ")", "\n", "\n", "", "", "if", "(", "not", "kwargs", ".", "pop", "(", "'is_initialised'", ",", "False", ")", ")", ":", "\n", "\t\t", "disco_vectors", ".", "init_sims", "(", "n_neighbors", "=", "num_neighbours", ",", "nn_metric", "=", "nn_metric", ",", "knn", "=", "'brute'", "if", "nn_metric", "==", "'cosine'", "else", "'kd_tree'", ")", "\n", "\n", "", "words", "=", "words", "if", "words", "is", "not", "None", "else", "vectors", ".", "keys", "(", ")", "\n", "\n", "a", "=", "alpha", "if", "alpha", "!=", "'auto'", "else", "num_neighbours", "\n", "for", "w", "in", "words", ":", "\n", "\t\t", "if", "(", "w", "not", "in", "disco_vectors", ")", ":", "continue", "\n", "# Retrieve top neighbour", "\n", "top_neighbour", "=", "disco_vectors", ".", "get_nearest_neighbours", "(", "w", ")", "[", "0", "]", "\n", "\n", "# Anything within `distance_threshold` is still considered for inference", "\n", "distance_threshold", "=", "top_neighbour", "[", "1", "]", "*", "(", "1", "+", "window_size", ")", "\n", "\n", "neighbours", "=", "[", "]", "\n", "for", "neighbour", ",", "distance", "in", "disco_vectors", ".", "get_nearest_neighbours", "(", "w", ")", ":", "\n", "\t\t\t", "if", "(", "distance", ">", "distance_threshold", ")", ":", "break", "\n", "\n", "neighbours", ".", "append", "(", "(", "neighbour", ",", "distance", ")", ")", "\n", "\n", "# Enrich original vector", "\n", "", "apt", "=", "disco_vectors", ".", "get_vector", "(", "w", ")", "*", "a", "\n", "\n", "for", "neighbour", ",", "_", "in", "neighbours", ":", "\n", "\t\t\t", "apt", "+=", "disco_vectors", ".", "get_vector", "(", "neighbour", ")", "\n", "\n", "", "smoothed_vectors", "[", "w", "]", "=", "apt", ".", "copy", "(", ")", "\n", "\n", "", "return", "disco_vectors", ",", "smoothed_vectors", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.distributional_inference.distributional_inference.wordnet_synsets": [[112, 160], ["isinstance", "isinstance", "kwargs.pop", "Vectors.from_dict_of_dicts.init_sims", "vectors.keys", "set", "nltk.corpus.wordnet.synsets", "enumerate", "scipy.sparse.csr_matrix", "sparse.csr_matrix.copy", "discoutils.thesaurus_loader.Vectors.from_dict_of_dicts", "ValueError", "syn.name().split", "set.add", "idx.append", "numpy.array", "Vectors.from_dict_of_dicts.get_vector().multiply", "A.sum", "syn.name", "Vectors.from_dict_of_dicts.get_vector"], "function", ["None"], ["", "def", "wordnet_synsets", "(", "vectors", ",", "words", ",", "num_neighbours", ",", "alpha", "=", "'auto'", ",", "nn_metric", "=", "'cosine'", ",", "**", "kwargs", ")", ":", "\n", "\t", "\"\"\"\n\tPerform smoothing by associative inference\n\t:param vectors: Original elementary APTs\n\t:param words: Lexemes of interest to apply distributional inference on (pass None for all lexemes), !!!Need to be (word, pos) tuples!!!\n\t:param num_neighbours: Maximum number of neighbours used for distributional inference\n\t:param alpha: weighting of original vector (default='auto', which multiplies the original vectors by `num_neighbours`)\n\t:param nn_metric: nearest neighbour metric to use (default='cosine'; supported are 'cosine' and 'euclidean')\n\t:return: smoothed apt vector\n\t\"\"\"", "\n", "smoothed_vectors", "=", "{", "}", "\n", "if", "(", "isinstance", "(", "vectors", ",", "Vectors", ")", ")", ":", "\n", "\t\t", "disco_vectors", "=", "vectors", "\n", "", "else", ":", "# Passive-Aggressive-Defensive loading cascade", "\n", "\t\t", "if", "(", "isinstance", "(", "vectors", ",", "dict", ")", ")", ":", "\n", "\t\t\t", "disco_vectors", "=", "Vectors", ".", "from_dict_of_dicts", "(", "vectors", ")", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'Unsupported type[{}] for `vectors` supplied. Supported types are [`discoutils.thesaurus_loader.Vectors` and `dict`]!'", ")", "\n", "\n", "", "", "if", "(", "not", "kwargs", ".", "pop", "(", "'is_initialised'", ",", "False", ")", ")", ":", "\n", "\t\t", "disco_vectors", ".", "init_sims", "(", "n_neighbors", "=", "num_neighbours", ",", "nn_metric", "=", "nn_metric", ",", "knn", "=", "'brute'", "if", "nn_metric", "==", "'cosine'", "else", "'kd_tree'", ")", "\n", "\n", "", "words", "=", "words", "if", "words", "is", "not", "None", "else", "vectors", ".", "keys", "(", ")", "\n", "\n", "a", "=", "alpha", "if", "alpha", "!=", "'auto'", "else", "num_neighbours", "\n", "for", "w", ",", "pos", "in", "words", ":", "\n", "\t\t", "if", "(", "w", "not", "in", "disco_vectors", ")", ":", "continue", "\n", "neighbours", "=", "set", "(", ")", "\n", "for", "syn", "in", "wordnet", ".", "synsets", "(", "w", ",", "pos", "=", "pos", ")", ":", "\n", "\t\t\t", "n", "=", "syn", ".", "name", "(", ")", ".", "split", "(", "'.'", ")", "[", "0", "]", "\n", "if", "(", "n", "!=", "w", ")", ":", "\n", "\t\t\t\t", "neighbours", ".", "add", "(", "n", ")", "\n", "\n", "# Get indices of neighbours", "\n", "", "", "idx", "=", "[", "]", "\n", "for", "i", ",", "n", "in", "enumerate", "(", "neighbours", ",", "1", ")", ":", "\n", "\t\t\t", "if", "(", "i", ">", "num_neighbours", ")", ":", "break", "\n", "if", "(", "n", "in", "disco_vectors", ")", ":", "\n", "\t\t\t\t", "idx", ".", "append", "(", "disco_vectors", ".", "name2row", "[", "n", "]", ")", "\n", "\n", "", "", "A", "=", "disco_vectors", ".", "matrix", "[", "np", ".", "array", "(", "idx", ")", "]", "\n", "\n", "# Retrieve vector for `w` and add `A` to it and apply alpha weighting to original APT", "\n", "apt", "=", "sparse", ".", "csr_matrix", "(", "disco_vectors", ".", "get_vector", "(", "w", ")", ".", "multiply", "(", "a", ")", "+", "A", ".", "sum", "(", "axis", "=", "0", ")", ")", "# Should still be sparse enough", "\n", "\n", "smoothed_vectors", "[", "w", "]", "=", "apt", ".", "copy", "(", ")", "\n", "\n", "", "return", "disco_vectors", ",", "smoothed_vectors", "", "", ""]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.distributional_inference.di_utils.perform_distributional_inference": [[4, 36], ["kwargs.pop", "inference_function", "isinstance", "smoothed_apt[].nonzero"], "function", ["None"], ["def", "perform_distributional_inference", "(", "inference_function", ",", "disco_vectors", ",", "apt", ",", "word", ",", "num_neighbours", "=", "100", ",", "**", "kwargs", ")", ":", "\n", "\t", "\"\"\"\n\tWrapper for the DI functions in distributional_inference.py\n\n\t:param inference_function: callable of one of the functions in distributional_inference.py\n\t:param disco_vectors: vectors transformed by discoutils.thesaurus_loader.Vectors.from_dict_of_dicts()\n\t:param apt: higher-order dependency-typed vector as `dict`\n\t:param word: word to perform distributional inference for\n\t:param num_neighbours: number of neighbours\n\t:param kwargs: keyword arguments for any of the distributional inference functions\n\t:return:\n\t\"\"\"", "\n", "\n", "pos", "=", "kwargs", ".", "pop", "(", "'pos'", ")", "\n", "if", "(", "'wordnet'", "in", "inference_function", ".", "__name__", ")", ":", "\n", "\t\t", "words", "=", "[", "(", "word", ",", "pos", ")", "]", "\n", "", "else", ":", "\n", "\t\t", "words", "=", "[", "word", "]", "\n", "\n", "", "_", ",", "smoothed_apt", "=", "inference_function", "(", "disco_vectors", ",", "words", ",", "num_neighbours", "=", "num_neighbours", ",", "**", "kwargs", ")", "\n", "\n", "if", "(", "isinstance", "(", "smoothed_apt", "[", "word", "]", ",", "dict", ")", ")", ":", "\n", "\t\t", "return", "smoothed_apt", "[", "word", "]", "# Inverse transform already performed", "\n", "", "else", ":", "\n", "\t\t", "smoothed_cols", "=", "smoothed_apt", "[", "word", "]", ".", "nonzero", "(", ")", "[", "1", "]", "\n", "\n", "for", "col", "in", "smoothed_cols", ":", "\n", "\t\t\t", "feat", "=", "disco_vectors", ".", "columns", "[", "col", "]", "\n", "\n", "apt", "[", "feat", "]", "=", "smoothed_apt", "[", "word", "]", "[", "0", ",", "col", "]", "\n", "\n", "", "return", "apt", "", "", "", ""]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.composition.mozart.union_apts": [[5, 19], ["set", "set", "merge_fn", "vector_1.keys", "vector_2.keys", "vector_1.get", "vector_2.get"], "function", ["None"], ["def", "union_apts", "(", "vector_1", ",", "vector_2", ",", "merge_fn", "=", "operator", ".", "add", ")", ":", "\n", "\t", "\"\"\"\n\tCompose 2 APT vectors (as `dicts`) by the union of their distributional features.\n\n\t:param vector_1: constituent vector 1\n\t:param vector_2: constituent vector 2\n\t:param merge_fn: any function to combine the two values (e.g. min, max, operator.add, operator.mul), default is operator.add\n\t:return: composed APT (as `dict`)\n\t\"\"\"", "\n", "composed_vector", "=", "{", "}", "\n", "for", "feat", "in", "(", "set", "(", "vector_1", ".", "keys", "(", ")", ")", "|", "set", "(", "vector_2", ".", "keys", "(", ")", ")", ")", ":", "\n", "\t\t", "composed_vector", "[", "feat", "]", "=", "merge_fn", "(", "vector_1", ".", "get", "(", "feat", ",", "0.", ")", ",", "vector_2", ".", "get", "(", "feat", ",", "0.", ")", ")", "\n", "\n", "", "return", "composed_vector", "\n", "\n"]], "home.repos.pwc.inspect_result.tttthomasssss_acl2017.composition.mozart.intersect_apts": [[21, 35], ["set", "set", "merge_fn", "vector_1.keys", "vector_2.keys"], "function", ["None"], ["", "def", "intersect_apts", "(", "vector_1", ",", "vector_2", ",", "merge_fn", "=", "operator", ".", "add", ")", ":", "\n", "\t", "\"\"\"\n\tCompose 2 APT vectors (as `dicts`) by the intersection of their distributional features.\n\n\t:param vector_1: constituent vector 1\n\t:param vector_2: constituent vector 2\n\t:param merge_fn: any function to combine the two values (e.g. min, max, operator.add, operator.mul), default is operator.add\n\t:return: composed APT (as `dict`)\n\t\"\"\"", "\n", "composed_vector", "=", "{", "}", "\n", "for", "feat", "in", "(", "set", "(", "vector_1", ".", "keys", "(", ")", ")", "&", "set", "(", "vector_2", ".", "keys", "(", ")", ")", ")", ":", "\n", "\t\t", "composed_vector", "[", "feat", "]", "=", "merge_fn", "(", "vector_1", "[", "feat", "]", ",", "vector_2", "[", "feat", "]", ")", "\n", "\n", "", "return", "composed_vector", "", "", ""]]}