{"home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.train_loop": [[40, 58], ["logging.getLogger", "logging.getLogger.info", "detectron2.utils.events.EventStorage", "train_sor.Trainer.before_train", "range", "train_sor.Trainer.after_train", "train_sor.Trainer.before_step", "train_sor.Trainer.run_step", "train_sor.Trainer.after_step"], "methods", ["None"], ["def", "train_loop", "(", "self", ",", "start_iter", ":", "int", ",", "max_iter", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            start_iter, max_iter (int): See docs above\n        \"\"\"", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "logger", ".", "info", "(", "\"Starting training from iteration {}\"", ".", "format", "(", "start_iter", ")", ")", "\n", "\n", "self", ".", "iter", "=", "self", ".", "start_iter", "=", "start_iter", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "\n", "with", "EventStorage", "(", "start_iter", ")", "as", "self", ".", "storage", ":", "\n", "            ", "self", ".", "before_train", "(", ")", "\n", "for", "self", ".", "iter", "in", "range", "(", "start_iter", ",", "max_iter", ")", ":", "\n", "                ", "self", ".", "before_step", "(", ")", "\n", "self", ".", "run_step", "(", ")", "\n", "self", ".", "after_step", "(", ")", "\n", "", "self", ".", "after_train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.train": [[59, 70], ["train_sor.Trainer.train_loop", "hasattr", "detectron2.is_main_process", "detectron2.evaluation.verify_results"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.train_loop"], ["", "", "def", "train", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Run training.\n\n        Returns:\n            OrderedDict of results, if evaluation is enabled. Otherwise None.\n        \"\"\"", "\n", "self", ".", "train_loop", "(", "self", ".", "start_iter", ",", "self", ".", "max_iter", ")", "\n", "if", "hasattr", "(", "self", ",", "\"_last_eval_results\"", ")", "and", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "verify_results", "(", "self", ".", "cfg", ",", "self", ".", "_last_eval_results", ")", "\n", "return", "self", ".", "_last_eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.build_train_loader": [[71, 82], ["sor.assr_dataset_mapper.DatasetMapper", "detectron2.data.build_detection_train_loader"], "methods", ["None"], ["", "", "@", "classmethod", "\n", "def", "build_train_loader", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            iterable\n\n        It calls :func:`detectron2.data.build_detection_train_loader` with a customized\n        DatasetMapper, which adds categorical labels as a semantic mask.\n        \"\"\"", "\n", "mapper", "=", "DatasetMapper", "(", "cfg", ",", "True", ")", "\n", "return", "build_detection_train_loader", "(", "cfg", ",", "mapper", "=", "mapper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.build_test_loader": [[83, 88], ["sor.assr_dataset_mapper.DatasetMapper", "print", "detectron2.data.build_detection_test_loader"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "build_test_loader", "(", "cls", ",", "cfg", ",", "dataset_name", ")", ":", "\n", "        ", "mapper", "=", "DatasetMapper", "(", "cfg", ",", "is_train", "=", "False", ")", "\n", "print", "(", "\"custom test loader\"", ")", "\n", "return", "build_detection_test_loader", "(", "cfg", ",", "dataset_name", ",", "mapper", "=", "mapper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.build_evaluator": [[89, 101], ["centermask.evaluation.COCOEvaluator", "os.path.join"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "build_evaluator", "(", "cls", ",", "cfg", ",", "dataset_name", ",", "output_folder", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Create evaluator(s) for a given dataset.\n        This uses the special metadata \"evaluator_type\" associated with each builtin dataset.\n        For your own dataset, you can simply create an evaluator manually in your\n        script and do not have to worry about the hacky if-else logic here.\n        \"\"\"", "\n", "if", "output_folder", "is", "None", ":", "\n", "            ", "output_folder", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "OUTPUT_DIR", ",", "\"inference\"", ")", "\n", "\n", "", "return", "COCOEvaluator", "(", "dataset_name", ",", "cfg", ",", "True", ",", "output_folder", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.test_with_TTA": [[102, 119], ["logging.getLogger", "logging.getLogger.info", "detectron2.modeling.GeneralizedRCNNWithTTA", "cls.test", "collections.OrderedDict", "cls.build_evaluator", "os.path.join", "collections.OrderedDict.items"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.build_evaluator"], ["", "@", "classmethod", "\n", "def", "test_with_TTA", "(", "cls", ",", "cfg", ",", "model", ")", ":", "\n", "        ", "logger", "=", "logging", ".", "getLogger", "(", "\"detectron2.trainer\"", ")", "\n", "# In the end of training, run an evaluation with TTA", "\n", "# Only support some R-CNN models.", "\n", "logger", ".", "info", "(", "\"Running inference with test-time augmentation ...\"", ")", "\n", "model", "=", "GeneralizedRCNNWithTTA", "(", "cfg", ",", "model", ")", "\n", "evaluators", "=", "[", "\n", "cls", ".", "build_evaluator", "(", "\n", "cfg", ",", "name", ",", "output_folder", "=", "os", ".", "path", ".", "join", "(", "\n", "cfg", ".", "OUTPUT_DIR", ",", "\"inference_TTA\"", ")", "\n", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "cls", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "res", "=", "OrderedDict", "(", "{", "k", "+", "\"_TTA\"", ":", "v", "for", "k", ",", "v", "in", "res", ".", "items", "(", ")", "}", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.setup": [[121, 140], ["centermask.config.get_cfg", "centermask.config.get_cfg.merge_from_file", "centermask.config.get_cfg.merge_from_list", "centermask.config.get_cfg.freeze", "detectron2.engine.default_setup"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.config.config.get_cfg"], ["", "", "def", "setup", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Create configs and perform basic setups.\n    \"\"\"", "\n", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "\n", "# Set score_threshold for builtin models", "\n", "confidence_threshold", "=", "0.3", "\n", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "FCOS", ".", "INFERENCE_TH_TEST", "=", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "confidence_threshold", "\n", "\n", "cfg", ".", "freeze", "(", ")", "\n", "default_setup", "(", "cfg", ",", "args", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.main": [[142, 173], ["train_sor.setup", "train_sor.Trainer", "Trainer.resume_or_load", "train_sor.Trainer.train", "detectron2.data.DatasetCatalog.register", "detectron2.data.MetadataCatalog.get().set", "detectron2.data.MetadataCatalog.get().set", "Trainer.build_model", "centermask.checkpoint.AdetCheckpointer().resume_or_load", "Trainer.test", "detectron2.is_main_process", "train_sor.Trainer.build_evaluator", "detectron2.evaluation.verify_results", "sor.assr_register.get_assr_dicts", "detectron2.data.MetadataCatalog.get", "detectron2.data.MetadataCatalog.get", "centermask.checkpoint.AdetCheckpointer"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.setup", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.train", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor_ppa.train_sor.Trainer.build_evaluator", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor.assr_register.get_assr_dicts", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "main", "(", "args", ")", ":", "\n", "    ", "cfg", "=", "setup", "(", "args", ")", "\n", "# register new dataset", "\n", "for", "d", "in", "[", "'train'", ",", "'test'", "]", ":", "\n", "        ", "DatasetCatalog", ".", "register", "(", "\"assr_\"", "+", "d", ",", "lambda", "d", "=", "d", ":", "get_assr_dicts", "(", "\n", "root", "=", "'datasets/ASSR'", ",", "mode", "=", "d", ")", ")", "\n", "MetadataCatalog", ".", "get", "(", "\"assr_\"", "+", "d", ")", ".", "set", "(", "thing_classes", "=", "[", "\"salient_obj\"", "]", ")", "\n", "MetadataCatalog", ".", "get", "(", "\"assr_\"", "+", "d", ")", ".", "set", "(", "evaluator_type", "=", "\"coco\"", ")", "\n", "\n", "", "if", "args", ".", "eval_only", ":", "\n", "        ", "model", "=", "Trainer", ".", "build_model", "(", "cfg", ")", "\n", "AdetCheckpointer", "(", "model", ",", "save_dir", "=", "cfg", ".", "OUTPUT_DIR", ")", ".", "resume_or_load", "(", "\n", "cfg", ".", "MODEL", ".", "WEIGHTS", ",", "resume", "=", "args", ".", "resume", "\n", ")", "\n", "evaluators", "=", "[", "\n", "Trainer", ".", "build_evaluator", "(", "cfg", ",", "name", ")", "\n", "for", "name", "in", "cfg", ".", "DATASETS", ".", "TEST", "\n", "]", "\n", "res", "=", "Trainer", ".", "test", "(", "cfg", ",", "model", ",", "evaluators", ")", "\n", "if", "comm", ".", "is_main_process", "(", ")", ":", "\n", "            ", "verify_results", "(", "cfg", ",", "res", ")", "\n", "", "return", "res", "\n", "\n", "", "\"\"\"\n    If you'd like to do anything fancier than the standard training logic,\n    consider writing your own training loop or subclassing the trainer.\n    \"\"\"", "\n", "trainer", "=", "Trainer", "(", "cfg", ")", "\n", "trainer", ".", "resume_or_load", "(", "resume", "=", "args", ".", "resume", ")", "\n", "\n", "return", "trainer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.MaskRCNNConvUpsampleHead.__init__": [[232, 284], ["torch.nn.Module.__init__", "range", "detectron2.layers.ConvTranspose2d", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "detectron2.layers.Conv2d", "mask_head.MaskRCNNConvUpsampleHead.add_module", "mask_head.MaskRCNNConvUpsampleHead.conv_norm_relus.append", "fvcore.c2_msra_fill", "torch.nn.init.constant_", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            num_conv: the number of conv layers\n            conv_dim: the dimension of the conv layers\n            norm: normalization for the conv layers\n        \"\"\"", "\n", "super", "(", "MaskRCNNConvUpsampleHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "self", ".", "norm", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NORM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "\n", "cls_agnostic_mask", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CLS_AGNOSTIC_MASK", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_norm_relus", "=", "[", "]", "\n", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "self", ".", "norm", ",", "\n", "norm", "=", "get_norm", "(", "self", ".", "norm", ",", "conv_dims", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "self", ".", "add_module", "(", "\"mask_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_norm_relus", ".", "append", "(", "conv", ")", "\n", "\n", "", "self", ".", "deconv", "=", "ConvTranspose2d", "(", "\n", "conv_dims", "if", "num_conv", ">", "0", "else", "input_channels", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "2", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "\n", "num_mask_classes", "=", "1", "if", "cls_agnostic_mask", "else", "num_classes", "\n", "self", ".", "predictor", "=", "Conv2d", "(", "\n", "conv_dims", ",", "num_mask_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_norm_relus", "+", "[", "self", ".", "deconv", "]", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "if", "self", ".", "predictor", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.MaskRCNNConvUpsampleHead.forward": [[285, 290], ["torch.nn.functional.relu", "mask_head.MaskRCNNConvUpsampleHead.predictor", "layer", "mask_head.MaskRCNNConvUpsampleHead.deconv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "conv_norm_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "F", ".", "relu", "(", "self", ".", "deconv", "(", "x", ")", ")", "\n", "return", "self", ".", "predictor", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.crop": [[26, 33], ["boxes.to().numpy.to().numpy", "detectron2.structures.masks.PolygonMasks", "mask_head._crop", "boxes.to().numpy.to", "zip", "torch.device"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head._crop"], ["def", "crop", "(", "polygons", ":", "List", "[", "List", "[", "np", ".", "ndarray", "]", "]", ",", "boxes", ":", "torch", ".", "Tensor", ")", "->", "\"PolygonMasks\"", ":", "\n", "    ", "boxes", "=", "boxes", ".", "to", "(", "torch", ".", "device", "(", "\"cpu\"", ")", ")", ".", "numpy", "(", ")", "\n", "results", "=", "[", "\n", "_crop", "(", "polygon", ",", "box", ")", "for", "polygon", ",", "box", "in", "zip", "(", "polygons", ",", "boxes", ")", "\n", "]", "\n", "\n", "return", "PolygonMasks", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head._crop": [[35, 44], ["copy.deepcopy"], "function", ["None"], ["", "def", "_crop", "(", "polygons", ":", "np", ".", "ndarray", ",", "box", ":", "np", ".", "ndarray", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "    ", "w", ",", "h", "=", "box", "[", "2", "]", "-", "box", "[", "0", "]", ",", "box", "[", "3", "]", "-", "box", "[", "1", "]", "\n", "\n", "polygons", "=", "copy", ".", "deepcopy", "(", "polygons", ")", "\n", "for", "p", "in", "polygons", ":", "\n", "        ", "p", "[", "0", ":", ":", "2", "]", "=", "p", "[", "0", ":", ":", "2", "]", "-", "box", "[", "0", "]", "# .clamp(min=0, max=w)", "\n", "p", "[", "1", ":", ":", "2", "]", "=", "p", "[", "1", ":", ":", "2", "]", "-", "box", "[", "1", "]", "# .clamp(min=0, max=h)", "\n", "\n", "", "return", "polygons", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_loss": [[46, 182], ["pred_mask_logits.size", "pred_mask_logits.size", "detectron2.layers.cat", "gt_masks_bool.sum().item", "torch.nn.functional.binary_cross_entropy_with_logits", "pred_mask_logits.size", "pred_mask_logits.size", "pred_mask_logits.size", "instances_per_image.gt_masks.crop_and_resize().to", "detectron2.layers.cat.append", "len", "torch.LongTensor", "torch.zeros", "torch.arange", "detectron2.layers.cat", "max", "max", "detectron2.layers.cat.to", "detectron2.layers.cat", "torch.max", "torch.ones().double", "torch.zeros", "torch.max", "torch.max", "pred_mask_logits.reshape", "selected_mask.reshape.sigmoid", "len", "instances_per_image.gt_classes.to", "detectron2.layers.cat.append", "mask_head.crop", "torch.tensor", "torch.max.append", "torch.arange", "selected_mask.reshape.reshape", "mask_incorrect.sum().item", "max", "gt_masks_bool.sum", "torch.ones().double", "detectron2.layers.cat.sum", "maskiou_targets.detach", "instances_per_image.gt_masks.crop_and_resize", "pred_mask_logits.sum", "mask_incorrect.numel", "gt_masks_bool.numel", "pred_masks.sum", "torch.ones", "pycocotools.area().sum().astype", "pred_mask_logits.sum", "mask_incorrect.sum", "torch.ones", "zip", "pycocotools.area().sum", "pycocotools.area", "instances_per_image.gt_masks.area", "pycocotools.frPyObjects"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.crop"], ["", "def", "mask_rcnn_loss", "(", "pred_mask_logits", ",", "instances", ",", "maskiou_on", ")", ":", "\n", "    ", "\"\"\"\n    Compute the mask prediction loss defined in the Mask R-CNN paper.\n\n    Args:\n        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)\n            for class-specific or class-agnostic, where B is the total number of predicted masks\n            in all images, C is the number of foreground classes, and Hmask, Wmask are the height\n            and width of the mask predictions. The values are logits.\n        instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. These instances are in 1:1\n            correspondence with the pred_mask_logits. The ground-truth labels (class, box, mask,\n            ...) associated with each instance are stored in fields.\n\n    Returns:\n        mask_loss (Tensor): A scalar tensor containing the loss.\n    \"\"\"", "\n", "cls_agnostic_mask", "=", "pred_mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "total_num_masks", "=", "pred_mask_logits", ".", "size", "(", "0", ")", "\n", "mask_side_len", "=", "pred_mask_logits", ".", "size", "(", "2", ")", "\n", "assert", "pred_mask_logits", ".", "size", "(", "2", ")", "==", "pred_mask_logits", ".", "size", "(", "\n", "3", ")", ",", "\"Mask prediction must be square!\"", "\n", "\n", "gt_classes", "=", "[", "]", "\n", "gt_masks", "=", "[", "]", "\n", "mask_ratios", "=", "[", "]", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "        ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "not", "cls_agnostic_mask", ":", "\n", "            ", "gt_classes_per_image", "=", "instances_per_image", ".", "gt_classes", ".", "to", "(", "\n", "dtype", "=", "torch", ".", "int64", ")", "\n", "gt_classes", ".", "append", "(", "gt_classes_per_image", ")", "\n", "\n", "", "if", "maskiou_on", ":", "\n", "            ", "cropped_mask", "=", "crop", "(", "instances_per_image", ".", "gt_masks", ".", "polygons", ",", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ")", "\n", "cropped_mask", "=", "torch", ".", "tensor", "(", "\n", "[", "mask_utils", ".", "area", "(", "mask_utils", ".", "frPyObjects", "(", "[", "p", "for", "p", "in", "obj", "]", ",", "box", "[", "3", "]", "-", "box", "[", "1", "]", ",", "box", "[", "2", "]", "-", "box", "[", "0", "]", ")", ")", ".", "sum", "(", ")", ".", "astype", "(", "float", ")", "\n", "for", "obj", ",", "box", "in", "zip", "(", "cropped_mask", ".", "polygons", ",", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ")", "]", "\n", ")", "\n", "\n", "mask_ratios", ".", "append", "(", "\n", "(", "cropped_mask", "/", "instances_per_image", ".", "gt_masks", ".", "area", "(", ")", ")", "\n", ".", "to", "(", "device", "=", "pred_mask_logits", ".", "device", ")", ".", "clamp", "(", "min", "=", "0.", ",", "max", "=", "1.", ")", "\n", ")", "\n", "\n", "", "gt_masks_per_image", "=", "instances_per_image", ".", "gt_masks", ".", "crop_and_resize", "(", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ",", "mask_side_len", "\n", ")", ".", "to", "(", "device", "=", "pred_mask_logits", ".", "device", ")", "\n", "# A tensor of shape (N, M, M), N=#instances in the image; M=mask_side_len", "\n", "gt_masks", ".", "append", "(", "gt_masks_per_image", ")", "\n", "\n", "#gt_classes = cat(gt_classes, dim=0)", "\n", "\n", "", "if", "len", "(", "gt_masks", ")", "==", "0", ":", "\n", "        ", "gt_classes", "=", "torch", ".", "LongTensor", "(", "gt_classes", ")", "\n", "if", "maskiou_on", ":", "\n", "            ", "selected_index", "=", "torch", ".", "arange", "(", "\n", "pred_mask_logits", ".", "shape", "[", "0", "]", ",", "device", "=", "pred_mask_logits", ".", "device", ")", "\n", "if", "cls_agnostic_mask", ":", "\n", "                ", "selected_mask", "=", "pred_mask_logits", "[", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "# gt_classes = torch.LongTensor(gt_classes)", "\n", "                ", "selected_mask", "=", "pred_mask_logits", "[", "selected_index", ",", "gt_classes", "]", "\n", "", "mask_num", ",", "mask_h", ",", "mask_w", "=", "selected_mask", ".", "shape", "\n", "selected_mask", "=", "selected_mask", ".", "reshape", "(", "mask_num", ",", "1", ",", "mask_h", ",", "mask_w", ")", "\n", "return", "pred_mask_logits", ".", "sum", "(", ")", "*", "0", ",", "selected_mask", ",", "gt_classes", ",", "None", "\n", "\n", "", "else", ":", "\n", "            ", "return", "pred_mask_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "", "gt_masks", "=", "cat", "(", "gt_masks", ",", "dim", "=", "0", ")", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "pred_mask_logits", "=", "pred_mask_logits", "[", ":", ",", "0", "]", "\n", "gt_classes", "=", "torch", ".", "zeros", "(", "total_num_masks", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "", "else", ":", "\n", "        ", "indices", "=", "torch", ".", "arange", "(", "total_num_masks", ")", "\n", "gt_classes", "=", "cat", "(", "gt_classes", ",", "dim", "=", "0", ")", "# ywlee", "\n", "# (num_mask, Hmask, Wmask)", "\n", "pred_mask_logits", "=", "pred_mask_logits", "[", "indices", ",", "gt_classes", "]", "\n", "\n", "", "if", "gt_masks", ".", "dtype", "==", "torch", ".", "bool", ":", "\n", "        ", "gt_masks_bool", "=", "gt_masks", "\n", "", "else", ":", "\n", "# Here we allow gt_masks to be float as well (depend on the implementation of rasterize())", "\n", "        ", "gt_masks_bool", "=", "gt_masks", ">", "0.5", "\n", "\n", "# Log the training accuracy (using gt classes and 0.5 threshold)", "\n", "", "mask_incorrect", "=", "(", "pred_mask_logits", ">", "0.0", ")", "!=", "gt_masks_bool", "\n", "mask_accuracy", "=", "1", "-", "(", "mask_incorrect", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "\n", "max", "(", "mask_incorrect", ".", "numel", "(", ")", ",", "1.0", ")", ")", "\n", "num_positive", "=", "gt_masks_bool", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "false_positive", "=", "(", "mask_incorrect", "&", "~", "gt_masks_bool", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "/", "max", "(", "\n", "gt_masks_bool", ".", "numel", "(", ")", "-", "num_positive", ",", "1.0", "\n", ")", "\n", "false_negative", "=", "(", "mask_incorrect", "&", "gt_masks_bool", ")", ".", "sum", "(", "\n", ")", ".", "item", "(", ")", "/", "max", "(", "num_positive", ",", "1.0", ")", "\n", "\n", "# storage = get_event_storage()", "\n", "# storage.put_scalar(\"mask_rcnn/accuracy\", mask_accuracy)", "\n", "# storage.put_scalar(\"mask_rcnn/false_positive\", false_positive)", "\n", "# storage.put_scalar(\"mask_rcnn/false_negative\", false_negative)", "\n", "\n", "mask_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "pred_mask_logits", ",", "gt_masks", ".", "to", "(", "dtype", "=", "torch", ".", "float32", ")", ",", "reduction", "=", "\"mean\"", "\n", ")", "\n", "\n", "if", "maskiou_on", ":", "\n", "        ", "mask_ratios", "=", "cat", "(", "mask_ratios", ",", "dim", "=", "0", ")", "\n", "\n", "value_eps", "=", "1e-10", "*", "torch", ".", "ones", "(", "gt_masks", ".", "shape", "[", "0", "]", ",", "device", "=", "gt_masks", ".", "device", ")", ".", "double", "(", ")", "\n", "mask_ratios", "=", "torch", ".", "max", "(", "mask_ratios", ",", "value_eps", ")", "\n", "\n", "pred_masks", "=", "pred_mask_logits", ">", "0", "\n", "\n", "mask_targets_full_area", "=", "gt_masks", ".", "sum", "(", "dim", "=", "[", "1", ",", "2", "]", ")", "/", "mask_ratios", "\n", "\n", "mask_ovr_area", "=", "(", "pred_masks", "*", "gt_masks", ")", ".", "sum", "(", "dim", "=", "[", "1", ",", "2", "]", ")", ".", "float", "(", ")", "\n", "mask_union_area", "=", "pred_masks", ".", "sum", "(", "\n", "dim", "=", "[", "1", ",", "2", "]", ")", "+", "mask_targets_full_area", "-", "mask_ovr_area", "\n", "value_1", "=", "torch", ".", "ones", "(", "\n", "pred_masks", ".", "shape", "[", "0", "]", ",", "device", "=", "gt_masks", ".", "device", ")", ".", "double", "(", ")", "\n", "value_0", "=", "torch", ".", "zeros", "(", "pred_masks", ".", "shape", "[", "0", "]", ",", "device", "=", "gt_masks", ".", "device", ")", "\n", "mask_union_area", "=", "torch", ".", "max", "(", "mask_union_area", ",", "value_1", ")", "\n", "mask_ovr_area", "=", "torch", ".", "max", "(", "mask_ovr_area", ",", "value_0", ")", "\n", "maskiou_targets", "=", "mask_ovr_area", "/", "mask_union_area", "\n", "mask_num", ",", "mask_h", ",", "mask_w", "=", "pred_mask_logits", ".", "shape", "\n", "selected_mask", "=", "pred_mask_logits", ".", "reshape", "(", "mask_num", ",", "1", ",", "mask_h", ",", "mask_w", ")", "\n", "selected_mask", "=", "selected_mask", ".", "sigmoid", "(", ")", "\n", "return", "mask_loss", ",", "selected_mask", ",", "gt_classes", ",", "maskiou_targets", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "mask_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_inference": [[184, 224], ["[].sigmoid.split", "zip", "pred_mask_logits.size", "pred_mask_logits.sigmoid", "detectron2.layers.cat", "torch.arange", "[].sigmoid", "len"], "function", ["None"], ["", "", "def", "mask_rcnn_inference", "(", "pred_mask_logits", ",", "pred_instances", ")", ":", "\n", "    ", "\"\"\"\n    Convert pred_mask_logits to estimated foreground probability masks while also\n    extracting only the masks for the predicted classes in pred_instances. For each\n    predicted box, the mask of the same class is attached to the instance by adding a\n    new \"pred_masks\" field to pred_instances.\n\n    Args:\n        pred_mask_logits (Tensor): A tensor of shape (B, C, Hmask, Wmask) or (B, 1, Hmask, Wmask)\n            for class-specific or class-agnostic, where B is the total number of predicted masks\n            in all images, C is the number of foreground classes, and Hmask, Wmask are the height\n            and width of the mask predictions. The values are logits.\n        pred_instances (list[Instances]): A list of N Instances, where N is the number of images\n            in the batch. Each Instances must have field \"pred_classes\".\n\n    Returns:\n        None. pred_instances will contain an extra \"pred_masks\" field storing a mask of size (Hmask,\n            Wmask) for predicted class. Note that the masks are returned as a soft (non-quantized)\n            masks the resolution predicted by the network; post-processing steps, such as resizing\n            the predicted masks to the original image resolution and/or binarizing them, is left\n            to the caller.\n    \"\"\"", "\n", "cls_agnostic_mask", "=", "pred_mask_logits", ".", "size", "(", "1", ")", "==", "1", "\n", "\n", "if", "cls_agnostic_mask", ":", "\n", "        ", "mask_probs_pred", "=", "pred_mask_logits", ".", "sigmoid", "(", ")", "\n", "", "else", ":", "\n", "# Select masks corresponding to the predicted classes", "\n", "        ", "num_masks", "=", "pred_mask_logits", ".", "shape", "[", "0", "]", "\n", "class_pred", "=", "cat", "(", "[", "i", ".", "pred_classes", "for", "i", "in", "pred_instances", "]", ")", "\n", "indices", "=", "torch", ".", "arange", "(", "num_masks", ",", "device", "=", "class_pred", ".", "device", ")", "\n", "mask_probs_pred", "=", "pred_mask_logits", "[", "indices", ",", "\n", "class_pred", "]", "[", ":", ",", "None", "]", ".", "sigmoid", "(", ")", "\n", "# mask_probs_pred.shape: (B, 1, Hmask, Wmask)", "\n", "\n", "", "num_boxes_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "mask_probs_pred", "=", "mask_probs_pred", ".", "split", "(", "num_boxes_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "prob", ",", "instances", "in", "zip", "(", "mask_probs_pred", ",", "pred_instances", ")", ":", "\n", "        ", "instances", ".", "pred_masks", "=", "prob", "# (1, Hmask, Wmask)", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.build_mask_head": [[292, 298], ["ROI_MASK_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "", "def", "build_mask_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a mask head defined by `cfg.MODEL.ROI_MASK_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NAME", "\n", "return", "ROI_MASK_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.proposal_utils.add_ground_truth_to_proposals": [[9, 32], ["len", "len", "len", "proposal_utils.add_ground_truth_to_proposals_single_image", "zip"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.proposal_utils.add_ground_truth_to_proposals_single_image"], ["def", "add_ground_truth_to_proposals", "(", "targets", ",", "proposals", ")", ":", "\n", "    ", "\"\"\"\n    Call `add_ground_truth_to_proposals_single_image` for all images.\n\n    Args:\n        targets(list[Instances]): list of N elements. Element i is a Boxes\n            representing the gound-truth for image i.\n        proposals (list[Instances]): list of N elements. Element i is a Instances\n            representing the proposals for image i.\n\n    Returns:\n        list[Instances]: list of N Instances. Each is the proposals for the image,\n            with field \"proposal_boxes\" and \"objectness_logits\".\n    \"\"\"", "\n", "assert", "targets", "is", "not", "None", "\n", "\n", "assert", "len", "(", "proposals", ")", "==", "len", "(", "targets", ")", "\n", "if", "len", "(", "proposals", ")", "==", "0", ":", "\n", "        ", "return", "proposals", "\n", "\n", "", "return", "[", "\n", "add_ground_truth_to_proposals_single_image", "(", "tagets_i", ",", "proposals_i", ")", "\n", "for", "tagets_i", ",", "proposals_i", "in", "zip", "(", "targets", ",", "proposals", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.proposal_utils.add_ground_truth_to_proposals_single_image": [[35, 63], ["proposals.remove", "math.log", "detectron2.structures.Instances", "torch.ones", "detectron2.structures.Instances.cat", "torch.ones", "len", "len"], "function", ["None"], ["", "def", "add_ground_truth_to_proposals_single_image", "(", "targets_i", ",", "proposals", ")", ":", "\n", "    ", "\"\"\"\n    Augment `proposals` with ground-truth boxes from `gt_boxes`.\n\n    Args:\n        Same as `add_ground_truth_to_proposals`, but with targets and proposals\n        per image.\n\n    Returns:\n        Same as `add_ground_truth_to_proposals`, but for only one image.\n    \"\"\"", "\n", "device", "=", "proposals", ".", "scores", ".", "device", "\n", "proposals", ".", "proposal_boxes", "=", "proposals", ".", "pred_boxes", "\n", "proposals", ".", "remove", "(", "\"pred_boxes\"", ")", "\n", "# Concatenating gt_boxes with proposals requires them to have the same fields", "\n", "# Assign all ground-truth boxes an objectness logit corresponding to P(object) \\approx 1.", "\n", "gt_logit_value", "=", "math", ".", "log", "(", "(", "1.0", "-", "1e-10", ")", "/", "(", "1", "-", "(", "1.0", "-", "1e-10", ")", ")", ")", "\n", "gt_logits", "=", "gt_logit_value", "*", "torch", ".", "ones", "(", "len", "(", "targets_i", ")", ",", "device", "=", "device", ")", "\n", "gt_proposal", "=", "Instances", "(", "proposals", ".", "image_size", ")", "\n", "gt_proposal", ".", "proposal_boxes", "=", "targets_i", ".", "gt_boxes", "\n", "# to have the same fields with proposals", "\n", "gt_proposal", ".", "scores", "=", "gt_logits", "\n", "gt_proposal", ".", "pred_classes", "=", "targets_i", ".", "gt_classes", "\n", "gt_proposal", ".", "locations", "=", "torch", ".", "ones", "(", "(", "len", "(", "targets_i", ")", ",", "2", ")", ",", "device", "=", "device", ")", "\n", "\n", "new_proposals", "=", "Instances", ".", "cat", "(", "[", "proposals", ",", "gt_proposal", "]", ")", "\n", "\n", "return", "new_proposals", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.MaskIoUHead.__init__": [[62, 104], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "maskiou_head.MaskIoUHead.add_module", "maskiou_head.MaskIoUHead.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "MaskIoUHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "ROI_MASKIOU_HEAD", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_MASKIOU_HEAD", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"maskiou_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "", "self", ".", "maskiou_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "1024", ")", "\n", "self", ".", "maskiou_fc2", "=", "Linear", "(", "1024", ",", "1024", ")", "\n", "self", ".", "maskiou", "=", "Linear", "(", "1024", ",", "num_classes", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "", "for", "l", "in", "[", "self", ".", "maskiou_fc1", ",", "self", ".", "maskiou_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "maskiou", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "maskiou", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.MaskIoUHead.forward": [[105, 116], ["maskiou_head.MaskIoUHead.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "maskiou_head.MaskIoUHead.maskiou", "layer", "maskiou_head.MaskIoUHead.maskiou_fc1", "maskiou_head.MaskIoUHead.maskiou_fc2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "maskiou_fc1", "(", "x", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "maskiou_fc2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "maskiou", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.mask_iou_loss": [[18, 48], ["torch.arange().to", "maskiou_head.mask_iou_loss.l2_loss"], "function", ["None"], ["def", "mask_iou_loss", "(", "labels", ",", "pred_maskiou", ",", "gt_maskiou", ",", "loss_weight", ")", ":", "\n", "    ", "\"\"\"\n    Compute the maskiou loss.\n\n    Args:\n        labels (Tensor): Given mask labels (num of instance,)\n        pred_maskiou (Tensor):  A tensor of shape (num of instance, C)\n        gt_maskiou (Tensor): Ground Truth IOU generated in mask head (num of instance,)\n    \"\"\"", "\n", "def", "l2_loss", "(", "input", ",", "target", ")", ":", "\n", "        ", "\"\"\"\n        very similar to the smooth_l1_loss from pytorch, but with\n        the extra beta parameter\n        \"\"\"", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "target", ">", "0.0", ")", ".", "squeeze", "(", "1", ")", "\n", "if", "pos_inds", ".", "shape", "[", "0", "]", ">", "0", ":", "\n", "            ", "cond", "=", "torch", ".", "abs", "(", "input", "[", "pos_inds", "]", "-", "target", "[", "pos_inds", "]", ")", "\n", "loss", "=", "0.5", "*", "cond", "**", "2", "/", "pos_inds", ".", "shape", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "loss", "=", "input", "*", "0.0", "\n", "", "return", "loss", ".", "sum", "(", ")", "\n", "\n", "", "if", "labels", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "return", "pred_maskiou", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "index", "=", "torch", ".", "arange", "(", "pred_maskiou", ".", "shape", "[", "0", "]", ")", ".", "to", "(", "device", "=", "pred_maskiou", ".", "device", ")", "\n", "maskiou_loss", "=", "l2_loss", "(", "pred_maskiou", "[", "index", ",", "labels", "]", ",", "gt_maskiou", ")", "\n", "maskiou_loss", "=", "loss_weight", "*", "maskiou_loss", "\n", "\n", "return", "maskiou_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.mask_iou_inference": [[50, 58], ["detectron2.layers.cat", "torch.arange", "pred_maskiou[].split", "zip", "len"], "function", ["None"], ["", "def", "mask_iou_inference", "(", "pred_instances", ",", "pred_maskiou", ")", ":", "\n", "    ", "labels", "=", "cat", "(", "[", "i", ".", "pred_classes", "for", "i", "in", "pred_instances", "]", ")", "\n", "num_masks", "=", "pred_maskiou", ".", "shape", "[", "0", "]", "\n", "index", "=", "torch", ".", "arange", "(", "num_masks", ",", "device", "=", "labels", ".", "device", ")", "\n", "num_boxes_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "maskious", "=", "pred_maskiou", "[", "index", ",", "labels", "]", ".", "split", "(", "num_boxes_per_image", ",", "dim", "=", "0", ")", "\n", "for", "maskiou", ",", "box", "in", "zip", "(", "maskious", ",", "pred_instances", ")", ":", "\n", "        ", "box", ".", "mask_scores", "=", "box", ".", "scores", "*", "maskiou", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.build_maskiou_head": [[118, 124], ["ROI_MASKIOU_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "", "def", "build_maskiou_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a mask iou head defined by `cfg.MODEL.ROI_MASKIOU_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_MASKIOU_HEAD", ".", "NAME", "\n", "return", "ROI_MASKIOU_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SinglePredictor.__init__": [[27, 69], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "sor_heads.SinglePredictor.add_module", "sor_heads.SinglePredictor.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SinglePredictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "# print(self)", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SinglePredictor.forward": [[71, 85], ["sor_heads.SinglePredictor.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "sor_heads.SinglePredictor.sor", "layer", "sor_heads.SinglePredictor.sor_fc1", "sor_heads.SinglePredictor.sor_fc2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "# transformer can be added here", "\n", "\n", "x", "=", "self", ".", "sor", "(", "obj_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionPredictor.__init__": [[89, 149], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoder", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "sor_heads.SelfAttentionPredictor.add_module", "sor_heads.SelfAttentionPredictor.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "l.children", "isinstance", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SelfAttentionPredictor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "encoder_layer", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoder", "(", "encoder_layer", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "LAYERS", ")", "\n", "self", ".", "obj_dim", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "for", "l", "in", "self", ".", "transformer_encoder", ".", "layers", ":", "\n", "            ", "for", "m", "in", "l", ".", "children", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "m", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionPredictor.forward": [[151, 174], ["sor_heads.SelfAttentionPredictor.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "enumerate", "torch.cat().squeeze", "sor_heads.SelfAttentionPredictor.sor", "layer", "sor_heads.SelfAttentionPredictor.sor_fc1", "sor_heads.SelfAttentionPredictor.sor_fc2", "sor_heads.SelfAttentionPredictor.transformer_encoder", "torch.cat().squeeze.append", "len", "proposal_fea.reshape", "torch.cat"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "# transformer can be added here", "\n", "nums", "=", "[", "len", "(", "p", ")", "for", "p", "in", "instances", "]", "if", "instances", "is", "not", "None", "else", "[", "obj_features", ".", "shape", "[", "0", "]", "]", "\n", "\n", "start", "=", "0", "\n", "fusion_features", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "nums", ")", ":", "\n", "            ", "proposal_fea", "=", "obj_features", "[", "start", ":", "start", "+", "nums", "[", "i", "]", ",", ":", "]", "\n", "start", "+=", "nums", "[", "i", "]", "\n", "fusion", "=", "self", ".", "transformer_encoder", "(", "proposal_fea", ".", "reshape", "(", "-", "1", ",", "1", ",", "self", ".", "obj_dim", ")", ")", "\n", "fusion_features", ".", "append", "(", "fusion", ")", "\n", "", "fusion_features", "=", "torch", ".", "cat", "(", "fusion_features", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "sor", "(", "fusion_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithPosCat.__init__": [[178, 238], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoder", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "sor_heads.SelfAttentionWithPosCat.add_module", "sor_heads.SelfAttentionWithPosCat.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "l.children", "isinstance", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SelfAttentionWithPosCat", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "+", "2", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "encoder_layer", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoder", "(", "encoder_layer", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "LAYERS", ")", "\n", "self", ".", "obj_dim", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "for", "l", "in", "self", ".", "transformer_encoder", ".", "layers", ":", "\n", "            ", "for", "m", "in", "l", ".", "children", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "m", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithPosCat.forward": [[240, 263], ["sor_heads.SelfAttentionWithPosCat.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "enumerate", "torch.cat().squeeze", "sor_heads.SelfAttentionWithPosCat.sor", "layer", "sor_heads.SelfAttentionWithPosCat.sor_fc1", "sor_heads.SelfAttentionWithPosCat.sor_fc2", "sor_heads.SelfAttentionWithPosCat.transformer_encoder", "torch.cat().squeeze.append", "len", "proposal_fea.reshape", "torch.cat"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ",", "pos", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "# transformer can be added here", "\n", "nums", "=", "[", "len", "(", "p", ")", "for", "p", "in", "instances", "]", "if", "instances", "is", "not", "None", "else", "[", "obj_features", ".", "shape", "[", "0", "]", "]", "\n", "\n", "start", "=", "0", "\n", "fusion_features", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "nums", ")", ":", "\n", "            ", "proposal_fea", "=", "obj_features", "[", "start", ":", "start", "+", "nums", "[", "i", "]", ",", ":", "]", "\n", "start", "+=", "nums", "[", "i", "]", "\n", "fusion", "=", "self", ".", "transformer_encoder", "(", "proposal_fea", ".", "reshape", "(", "-", "1", ",", "1", ",", "self", ".", "obj_dim", ")", ")", "\n", "fusion_features", ".", "append", "(", "fusion", ")", "\n", "", "fusion_features", "=", "torch", ".", "cat", "(", "fusion_features", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "sor", "(", "fusion_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithPosConvCat.__init__": [[266, 343], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "detectron2.layers.Conv2d", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoder", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "sor_heads.SelfAttentionWithPosConvCat.add_module", "sor_heads.SelfAttentionWithPosConvCat.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "l.children", "isinstance", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SelfAttentionWithPosConvCat", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "+", "2", "+", "2", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "# self.pos_conv_relus = []", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "\n", "# pos_conv = Conv2d(", "\n", "#     2 if k == 0 else conv_dims,", "\n", "#     conv_dims,", "\n", "#     kernel_size=3,", "\n", "#     stride=stride,", "\n", "#     padding=1,", "\n", "#     activation=F.relu", "\n", "# )", "\n", "# self.add_module(\"pos_fcn{}\".format(k+1), pos_conv)", "\n", "# self.pos_conv_relus.append(pos_conv)", "\n", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "pos_conv", "=", "Conv2d", "(", "2", ",", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "activation", "=", "F", ".", "relu", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "encoder_layer", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoder", "(", "encoder_layer", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "LAYERS", ")", "\n", "self", ".", "obj_dim", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "pos_conv", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "pos_conv", ".", "bias", ",", "0", ")", "\n", "\n", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "for", "l", "in", "self", ".", "transformer_encoder", ".", "layers", ":", "\n", "            ", "for", "m", "in", "l", ".", "children", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "m", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithPosConvCat.forward": [[345, 369], ["sor_heads.SelfAttentionWithPosConvCat.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "enumerate", "torch.cat().squeeze", "sor_heads.SelfAttentionWithPosConvCat.sor", "layer", "sor_heads.SelfAttentionWithPosConvCat.sor_fc1", "sor_heads.SelfAttentionWithPosConvCat.sor_fc2", "sor_heads.SelfAttentionWithPosConvCat.transformer_encoder", "torch.cat().squeeze.append", "sor_heads.SelfAttentionWithPosConvCat.pos_conv", "len", "proposal_fea.reshape", "torch.cat"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ",", "pos", ",", "self", ".", "pos_conv", "(", "pos", ")", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "# transformer can be added here", "\n", "nums", "=", "[", "len", "(", "p", ")", "for", "p", "in", "instances", "]", "if", "self", ".", "training", "else", "[", "obj_features", ".", "shape", "[", "0", "]", "]", "\n", "\n", "start", "=", "0", "\n", "fusion_features", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "nums", ")", ":", "\n", "            ", "proposal_fea", "=", "obj_features", "[", "start", ":", "start", "+", "nums", "[", "i", "]", ",", ":", "]", "\n", "start", "+=", "nums", "[", "i", "]", "\n", "fusion", "=", "self", ".", "transformer_encoder", "(", "proposal_fea", ".", "reshape", "(", "-", "1", ",", "1", ",", "self", ".", "obj_dim", ")", ")", "\n", "fusion_features", ".", "append", "(", "fusion", ")", "\n", "", "fusion_features", "=", "torch", ".", "cat", "(", "fusion_features", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "x", "=", "self", ".", "sor", "(", "fusion_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SinglePredictorWithPos.__init__": [[372, 417], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "sor_heads.SinglePredictorWithPos.add_module", "sor_heads.SinglePredictorWithPos.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SinglePredictorWithPos", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "+", "4", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "pos_conv", "=", "Conv2d", "(", "2", ",", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "activation", "=", "F", ".", "relu", ")", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "nn", ".", "init", ".", "kaiming_normal_", "(", "self", ".", "pos_conv", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "pos_conv", ".", "bias", ",", "0", ")", "\n", "# print(self)", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SinglePredictorWithPos.forward": [[419, 433], ["sor_heads.SinglePredictorWithPos.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "sor_heads.SinglePredictorWithPos.sor", "layer", "sor_heads.SinglePredictorWithPos.sor_fc1", "sor_heads.SinglePredictorWithPos.sor_fc2", "sor_heads.SinglePredictorWithPos.pos_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ",", "pos", ",", "self", ".", "pos_conv", "(", "pos", ")", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "# transformer can be added here", "\n", "\n", "x", "=", "self", ".", "sor", "(", "obj_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithOtherPos.__init__": [[436, 516], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoder", "torch.nn.init.normal_", "torch.nn.init.constant_", "detectron2.layers.Conv2d", "sor_heads.SelfAttentionWithOtherPos.add_module", "sor_heads.SelfAttentionWithOtherPos.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "l.children", "isinstance", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SelfAttentionWithOtherPos", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "# self.pos_conv_relus = []", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "\n", "# pos_conv = Conv2d(", "\n", "#     2 if k == 0 else conv_dims,", "\n", "#     conv_dims,", "\n", "#     kernel_size=3,", "\n", "#     stride=stride,", "\n", "#     padding=1,", "\n", "#     activation=F.relu", "\n", "# )", "\n", "# self.add_module(\"pos_fcn{}\".format(k+1), pos_conv)", "\n", "# self.pos_conv_relus.append(pos_conv)", "\n", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "+", "4", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "# self.pos_conv = Conv2d(2, 2, kernel_size=3, stride=1, padding=1, activation=F.relu)", "\n", "# self.transformer_encoder = nn.TransformerEncoderLayer(", "\n", "#     d_model=cfg.MODEL.SOR.TRANSFORMER.D_MODEL,", "\n", "#     nhead=cfg.MODEL.SOR.TRANSFORMER.N_HEAD,", "\n", "#     dim_feedforward=cfg.MODEL.SOR.TRANSFORMER.D_MODEL * 4", "\n", "# )", "\n", "encoder_layer", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoder", "(", "encoder_layer", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "LAYERS", ")", "\n", "self", ".", "obj_dim", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "+", "4", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "# nn.init.kaiming_normal_(self.pos_conv.weight, mode=\"fan_out\", nonlinearity=\"relu\")", "\n", "# nn.init.constant_(self.pos_conv.bias, 0)", "\n", "\n", "", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "for", "l", "in", "self", ".", "transformer_encoder", ".", "layers", ":", "\n", "            ", "for", "m", "in", "l", ".", "children", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "m", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "self", ".", "img_height", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_HEIGHT", "\n", "self", ".", "img_witdh", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_WIDTH", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithOtherPos.forward": [[519, 557], ["sor_heads.SelfAttentionWithOtherPos.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.cat", "torch.zeros().cuda", "torch.cat", "enumerate", "torch.cat().squeeze", "sor_heads.SelfAttentionWithOtherPos.sor", "layer", "sor_heads.SelfAttentionWithOtherPos.sor_fc1", "sor_heads.SelfAttentionWithOtherPos.sor_fc2", "sor_heads.SelfAttentionWithOtherPos.transformer_encoder", "torch.cat().squeeze.append", "torch.zeros", "len", "proposal_fea.reshape", "torch.cat", "instance.get_fields"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "field", "=", "'proposal_boxes'", "if", "self", ".", "training", "else", "'pred_boxes'", "\n", "boxes", "=", "torch", ".", "cat", "(", "[", "instance", ".", "get_fields", "(", ")", "[", "field", "]", ".", "tensor", "for", "instance", "in", "instances", "]", ",", "0", ")", "\n", "pos", "=", "torch", ".", "zeros", "(", "(", "boxes", ".", "shape", "[", "0", "]", ",", "4", ")", ")", ".", "cuda", "(", ")", "\n", "pos", "[", ":", ",", "0", "]", "=", "(", "0.5", "*", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", ")", "/", "self", ".", "img_witdh", "\n", "pos", "[", ":", ",", "1", "]", "=", "(", "0.5", "*", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", ")", "/", "self", ".", "img_height", "\n", "pos", "[", ":", ",", "2", "]", "=", "(", "boxes", "[", ":", ",", "2", "]", "-", "boxes", "[", ":", ",", "0", "]", ")", "/", "self", ".", "img_witdh", "\n", "pos", "[", ":", ",", "3", "]", "=", "(", "boxes", "[", ":", ",", "3", "]", "+", "boxes", "[", ":", ",", "1", "]", ")", "/", "self", ".", "img_height", "\n", "\n", "obj_features", "=", "torch", ".", "cat", "(", "(", "obj_features", ",", "pos", ")", ",", "1", ")", "\n", "\n", "## other pos", "\n", "\n", "# transformer can be added here", "\n", "nums", "=", "[", "len", "(", "p", ")", "for", "p", "in", "instances", "]", "if", "self", ".", "training", "else", "[", "obj_features", ".", "shape", "[", "0", "]", "]", "\n", "\n", "start", "=", "0", "\n", "fusion_features", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "nums", ")", ":", "\n", "            ", "proposal_fea", "=", "obj_features", "[", "start", ":", "start", "+", "nums", "[", "i", "]", ",", ":", "]", "\n", "start", "+=", "nums", "[", "i", "]", "\n", "fusion", "=", "self", ".", "transformer_encoder", "(", "proposal_fea", ".", "reshape", "(", "-", "1", ",", "1", ",", "self", ".", "obj_dim", ")", ")", "\n", "fusion_features", ".", "append", "(", "fusion", ")", "\n", "", "fusion_features", "=", "torch", ".", "cat", "(", "fusion_features", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "# print(fusion_features.shape)", "\n", "# print(self.sor)", "\n", "x", "=", "self", ".", "sor", "(", "fusion_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithOtherPosQuant.__init__": [[560, 642], ["torch.nn.Module.__init__", "range", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.Linear", "centermask.layers.MaxPool2d", "torch.nn.TransformerEncoderLayer", "torch.nn.TransformerEncoder", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.Parameter", "detectron2.layers.Conv2d", "sor_heads.SelfAttentionWithOtherPosQuant.add_module", "sor_heads.SelfAttentionWithOtherPosQuant.conv_relus.append", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_", "l.children", "torch.rand", "isinstance", "torch.nn.init.kaiming_normal_", "torch.nn.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "super", "(", "SelfAttentionWithOtherPosQuant", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_ranks", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_RANKS", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "CONV_DIM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "+", "1", "\n", "resolution", "=", "input_shape", ".", "width", "//", "2", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_relus", "=", "[", "]", "\n", "# self.pos_conv_relus = []", "\n", "stride", "=", "1", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "if", "(", "k", "+", "1", ")", "==", "num_conv", ":", "\n", "                ", "stride", "=", "2", "\n", "", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "activation", "=", "F", ".", "relu", "\n", ")", "\n", "self", ".", "add_module", "(", "\"sor_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_relus", ".", "append", "(", "conv", ")", "\n", "\n", "# pos_conv = Conv2d(", "\n", "#     2 if k == 0 else conv_dims,", "\n", "#     conv_dims,", "\n", "#     kernel_size=3,", "\n", "#     stride=stride,", "\n", "#     padding=1,", "\n", "#     activation=F.relu", "\n", "# )", "\n", "# self.add_module(\"pos_fcn{}\".format(k+1), pos_conv)", "\n", "# self.pos_conv_relus.append(pos_conv)", "\n", "\n", "", "self", ".", "sor_fc1", "=", "Linear", "(", "conv_dims", "*", "resolution", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ")", "\n", "self", ".", "sor_fc2", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "DENSE_DIM", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ")", "\n", "self", ".", "sor", "=", "Linear", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", ",", "num_ranks", ")", "\n", "self", ".", "pooling", "=", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "# self.pos_conv = Conv2d(2, 2, kernel_size=3, stride=1, padding=1, activation=F.relu)", "\n", "# self.transformer_encoder = nn.TransformerEncoderLayer(", "\n", "#     d_model=cfg.MODEL.SOR.TRANSFORMER.D_MODEL,", "\n", "#     nhead=cfg.MODEL.SOR.TRANSFORMER.N_HEAD,", "\n", "#     dim_feedforward=cfg.MODEL.SOR.TRANSFORMER.D_MODEL * 4", "\n", "# )", "\n", "encoder_layer", "=", "nn", ".", "TransformerEncoderLayer", "(", "\n", "d_model", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", ",", "\n", "nhead", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "N_HEAD", ",", "\n", "dim_feedforward", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "D_MODEL", "*", "4", "\n", ")", "\n", "self", ".", "transformer_encoder", "=", "nn", ".", "TransformerEncoder", "(", "encoder_layer", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "LAYERS", ")", "\n", "self", ".", "obj_dim", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "\n", "\n", "for", "l", "in", "self", ".", "conv_relus", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "# nn.init.kaiming_normal_(self.pos_conv.weight, mode=\"fan_out\", nonlinearity=\"relu\")", "\n", "# nn.init.constant_(self.pos_conv.bias, 0)", "\n", "\n", "", "for", "l", "in", "[", "self", ".", "sor_fc1", ",", "self", ".", "sor_fc2", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "l", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "sor", ".", "weight", ",", "mean", "=", "0", ",", "std", "=", "0.01", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "self", ".", "sor", ".", "bias", ",", "0", ")", "\n", "for", "l", "in", "self", ".", "transformer_encoder", ".", "layers", ":", "\n", "            ", "for", "m", "in", "l", ".", "children", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_normal_", "(", "\n", "m", ".", "weight", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "", "self", ".", "img_height", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_HEIGHT", "\n", "self", ".", "img_witdh", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_WIDTH", "\n", "self", ".", "pos_embedding", "=", "nn", ".", "Parameter", "(", "torch", ".", "rand", "(", "cfg", ".", "MODEL", ".", "SOR", ".", "QUANT_NUM", "**", "2", ",", "cfg", ".", "MODEL", ".", "SOR", ".", "OBJ_DIM", "//", "2", "*", "2", ")", ")", "\n", "self", ".", "quant_num", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "QUANT_NUM", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.SelfAttentionWithOtherPosQuant.forward": [[647, 712], ["sor_heads.SelfAttentionWithOtherPosQuant.pooling", "torch.cat", "torch.flatten", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.cat", "enumerate", "torch.cat().squeeze", "sor_heads.SelfAttentionWithOtherPosQuant.sor", "layer", "sor_heads.SelfAttentionWithOtherPosQuant.sor_fc1", "sor_heads.SelfAttentionWithOtherPosQuant.sor_fc2", "cy.long", "sor_heads.SelfAttentionWithOtherPosQuant.transformer_encoder", "torch.cat().squeeze.append", "cx.long", "len", "proposal_fea.reshape", "torch.cat", "instance.get_fields"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "mask", ",", "instances", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "mask_pool", "=", "self", ".", "pooling", "(", "mask", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x", ",", "mask_pool", ")", ",", "1", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "\n", "", "x", "=", "torch", ".", "flatten", "(", "x", ",", "1", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "sor_fc1", "(", "x", ")", ")", "\n", "obj_features", "=", "F", ".", "relu", "(", "self", ".", "sor_fc2", "(", "x", ")", ")", "\n", "\n", "field", "=", "'proposal_boxes'", "if", "self", ".", "training", "else", "'pred_boxes'", "\n", "boxes", "=", "torch", ".", "cat", "(", "[", "instance", ".", "get_fields", "(", ")", "[", "field", "]", ".", "tensor", "for", "instance", "in", "instances", "]", ",", "0", ")", "\n", "cx", "=", "0.5", "*", "(", "boxes", "[", ":", ",", "0", "]", "+", "boxes", "[", ":", ",", "2", "]", ")", "/", "(", "self", ".", "img_witdh", "/", "self", ".", "quant_num", ")", "\n", "cy", "=", "0.5", "*", "(", "boxes", "[", ":", ",", "1", "]", "+", "boxes", "[", ":", ",", "3", "]", ")", "/", "(", "self", ".", "img_height", "/", "self", ".", "quant_num", ")", "\n", "idx", "=", "cx", ".", "long", "(", ")", "*", "self", ".", "quant_num", "+", "cy", ".", "long", "(", ")", "\n", "\n", "pos_features", "=", "self", ".", "pos_embedding", "[", "idx", "]", "\n", "\n", "# iw = (boxes[:, 2] - boxes[:, 0]) / (self.img_witdh / self.scale_quant_num)", "\n", "# ih = (boxes[:, 3] - boxes[:, 1]) / (self.img_height / self.scale_quant_num)", "\n", "# scale_idx = iw.long() * self.scale_quant_num + ih.long()", "\n", "# scale_idx[scale_idx >= self.scale_quant_num**2] = self.scale_quant_num**2-1", "\n", "\n", "# if scale_idx.max() >= 16:", "\n", "#     with open('tmp.pkl', 'wb') as f:", "\n", "#         import pickle", "\n", "#         pickle.dump({", "\n", "#             \"obj_features\": obj_features,", "\n", "#             \"boxes\": boxes,", "\n", "#         }, f)", "\n", "#         print('out of range')", "\n", "#         print('-------------------------------------------------------------------------')", "\n", "#         exit(0)", "\n", "# scale_features = self.scale_embedding[scale_idx]", "\n", "\n", "\n", "obj_features", "=", "obj_features", "+", "pos_features", "# torch.cat((pos_features, scale_features), 1)", "\n", "\n", "## other pos", "\n", "# with open('tmp.pkl', 'wb') as f:", "\n", "#     import pickle", "\n", "#     pickle.dump({", "\n", "#         \"obj_features\": obj_features,", "\n", "#         \"boxes\": boxes,", "\n", "#     }, f)", "\n", "#     print('-------------------------------------------------------------------------')", "\n", "#     exit(0)", "\n", "\n", "\n", "# transformer can be added here", "\n", "nums", "=", "[", "len", "(", "p", ")", "for", "p", "in", "instances", "]", "if", "self", ".", "training", "else", "[", "obj_features", ".", "shape", "[", "0", "]", "]", "\n", "\n", "start", "=", "0", "\n", "fusion_features", "=", "[", "]", "\n", "for", "i", ",", "num", "in", "enumerate", "(", "nums", ")", ":", "\n", "            ", "proposal_fea", "=", "obj_features", "[", "start", ":", "start", "+", "nums", "[", "i", "]", ",", ":", "]", "\n", "start", "+=", "nums", "[", "i", "]", "\n", "fusion", "=", "self", ".", "transformer_encoder", "(", "proposal_fea", ".", "reshape", "(", "-", "1", ",", "1", ",", "self", ".", "obj_dim", ")", ")", "\n", "fusion_features", ".", "append", "(", "fusion", ")", "\n", "", "fusion_features", "=", "torch", ".", "cat", "(", "fusion_features", ",", "dim", "=", "0", ")", ".", "squeeze", "(", "dim", "=", "1", ")", "\n", "# print(fusion_features.shape)", "\n", "# print(self.sor)", "\n", "x", "=", "self", ".", "sor", "(", "fusion_features", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.sor_loss": [[20, 23], ["detectron2.layers.cat", "torch.nn.functional.cross_entropy"], "function", ["None"], ["def", "sor_loss", "(", "pred_sor", ",", "instances", ")", ":", "\n", "    ", "gt_ranks", "=", "cat", "(", "[", "instance", ".", "gt_ranks", "for", "instance", "in", "instances", "]", ",", "dim", "=", "0", ")", "\n", "return", "F", ".", "cross_entropy", "(", "pred_sor", ",", "gt_ranks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.build_sor_head": [[714, 717], ["SOR_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "", "def", "build_sor_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "name", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "NAME", "\n", "return", "SOR_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sam.SpatialAttention.__init__": [[13, 22], ["torch.nn.Module.__init__", "detectron2.layers.Conv2d", "fvcore.c2_msra_fill", "torch.nn.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "kernel_size", "=", "3", ")", ":", "\n", "        ", "super", "(", "SpatialAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "kernel_size", "in", "(", "3", ",", "7", ")", ",", "'kernel size must be 3 or 7'", "\n", "padding", "=", "3", "if", "kernel_size", "==", "7", "else", "1", "\n", "\n", "self", ".", "conv", "=", "Conv2d", "(", "2", ",", "1", ",", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "False", ")", "\n", "weight_init", ".", "c2_msra_fill", "(", "self", ".", "conv", ")", "\n", "self", ".", "sigmoid", "=", "nn", ".", "Sigmoid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sam.SpatialAttention.forward": [[23, 29], ["torch.mean", "centermask.layers.Max", "torch.cat", "sam.SpatialAttention.conv", "sam.SpatialAttention.sigmoid"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.Max"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "avg_out", "=", "torch", ".", "mean", "(", "x", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "max_out", "=", "Max", "(", "x", ")", "\n", "scale", "=", "torch", ".", "cat", "(", "[", "avg_out", ",", "max_out", "]", ",", "dim", "=", "1", ")", "\n", "scale", "=", "self", ".", "conv", "(", "scale", ")", "\n", "return", "x", "*", "self", ".", "sigmoid", "(", "scale", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sam.SpatialAttentionMaskHead.__init__": [[38, 91], ["torch.nn.Module.__init__", "range", "sam.SpatialAttention", "detectron2.layers.ConvTranspose2d", "detectron2.layers.Conv2d", "torch.nn.init.normal_", "detectron2.layers.Conv2d", "sam.SpatialAttentionMaskHead.add_module", "sam.SpatialAttentionMaskHead.conv_norm_relus.append", "fvcore.c2_msra_fill", "torch.nn.init.constant_", "detectron2.layers.get_norm"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            num_conv: the number of conv layers\n            conv_dim: the dimension of the conv layers\n            norm: normalization for the conv layers\n        \"\"\"", "\n", "super", "(", "SpatialAttentionMaskHead", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "self", ".", "norm", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NORM", "\n", "num_conv", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "NUM_CONV", "\n", "input_channels", "=", "input_shape", ".", "channels", "\n", "cls_agnostic_mask", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CLS_AGNOSTIC_MASK", "\n", "# fmt: on", "\n", "\n", "self", ".", "conv_norm_relus", "=", "[", "]", "\n", "\n", "for", "k", "in", "range", "(", "num_conv", ")", ":", "\n", "            ", "conv", "=", "Conv2d", "(", "\n", "input_channels", "if", "k", "==", "0", "else", "conv_dims", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "not", "self", ".", "norm", ",", "\n", "norm", "=", "get_norm", "(", "self", ".", "norm", ",", "conv_dims", ")", ",", "\n", "activation", "=", "F", ".", "relu", ",", "\n", ")", "\n", "self", ".", "add_module", "(", "\"mask_fcn{}\"", ".", "format", "(", "k", "+", "1", ")", ",", "conv", ")", "\n", "self", ".", "conv_norm_relus", ".", "append", "(", "conv", ")", "\n", "\n", "", "self", ".", "spatialAtt", "=", "SpatialAttention", "(", ")", "\n", "\n", "self", ".", "deconv", "=", "ConvTranspose2d", "(", "\n", "conv_dims", "if", "num_conv", ">", "0", "else", "input_channels", ",", "\n", "conv_dims", ",", "\n", "kernel_size", "=", "2", ",", "\n", "stride", "=", "2", ",", "\n", "padding", "=", "0", ",", "\n", ")", "\n", "\n", "num_mask_classes", "=", "1", "if", "cls_agnostic_mask", "else", "num_classes", "\n", "self", ".", "predictor", "=", "Conv2d", "(", "conv_dims", ",", "num_mask_classes", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", "\n", "\n", "for", "layer", "in", "self", ".", "conv_norm_relus", "+", "[", "self", ".", "deconv", "]", ":", "\n", "            ", "weight_init", ".", "c2_msra_fill", "(", "layer", ")", "\n", "# use normal distribution initialization for mask prediction layer", "\n", "", "nn", ".", "init", ".", "normal_", "(", "self", ".", "predictor", ".", "weight", ",", "std", "=", "0.001", ")", "\n", "if", "self", ".", "predictor", ".", "bias", "is", "not", "None", ":", "\n", "            ", "nn", ".", "init", ".", "constant_", "(", "self", ".", "predictor", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sam.SpatialAttentionMaskHead.forward": [[92, 98], ["sam.SpatialAttentionMaskHead.spatialAtt", "torch.nn.functional.relu", "sam.SpatialAttentionMaskHead.predictor", "layer", "sam.SpatialAttentionMaskHead.deconv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "conv_norm_relus", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "", "x", "=", "self", ".", "spatialAtt", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "deconv", "(", "x", ")", ")", "\n", "return", "self", ".", "predictor", "(", "x", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.ROIHeads.__init__": [[137, 164], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "num_classes", ",", "\n", "batch_size_per_image", ",", "\n", "positive_fraction", ",", "\n", "proposal_matcher", ",", "\n", "proposal_append_gt", "=", "True", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            num_classes (int): number of classes. Used to label background proposals.\n            batch_size_per_image (int): number of proposals to sample for training\n            positive_fraction (float): fraction of positive (foreground) proposals\n                to sample for training.\n            proposal_matcher (Matcher): matcher that matches proposals and ground truth\n            proposal_append_gt (bool): whether to include ground truth as proposals as well\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "batch_size_per_image", "=", "batch_size_per_image", "\n", "self", ".", "positive_fraction", "=", "positive_fraction", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "proposal_matcher", "=", "proposal_matcher", "\n", "self", ".", "proposal_append_gt", "=", "proposal_append_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.ROIHeads.from_config": [[165, 177], ["detectron2.modeling.matcher.Matcher"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ")", ":", "\n", "        ", "return", "{", "\n", "\"batch_size_per_image\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", ",", "\n", "\"positive_fraction\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", ",", "\n", "\"num_classes\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", ",", "\n", "\"proposal_append_gt\"", ":", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", ",", "\n", "# Matcher to assign box proposals to gt boxes", "\n", "\"proposal_matcher\"", ":", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "False", ",", "\n", ")", ",", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.ROIHeads._sample_proposals": [[180, 217], ["detectron2.modeling.sampling.subsample_labels", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "gt_classes.numel", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like"], "methods", ["None"], ["", "def", "_sample_proposals", "(", "\n", "self", ",", "matched_idxs", ":", "torch", ".", "Tensor", ",", "matched_labels", ":", "torch", ".", "Tensor", ",", "gt_classes", ":", "torch", ".", "Tensor", "\n", ")", "->", "Tuple", "[", "torch", ".", "Tensor", ",", "torch", ".", "Tensor", "]", ":", "\n", "        ", "\"\"\"\n        Based on the matching between N proposals and M groundtruth,\n        sample the proposals and set their classification labels.\n\n        Args:\n            matched_idxs (Tensor): a vector of length N, each is the best-matched\n                gt index in [0, M) for each proposal.\n            matched_labels (Tensor): a vector of length N, the matcher's label\n                (one of cfg.MODEL.ROI_HEADS.IOU_LABELS) for each proposal.\n            gt_classes (Tensor): a vector of length M.\n\n        Returns:\n            Tensor: a vector of indices of sampled proposals. Each is in [0, N).\n            Tensor: a vector of the same length, the classification label for\n                each sampled proposal. Each sample is labeled as either a category in\n                [0, num_classes) or the background (num_classes).\n        \"\"\"", "\n", "has_gt", "=", "gt_classes", ".", "numel", "(", ")", ">", "0", "\n", "# Get the corresponding GT for each proposal", "\n", "if", "has_gt", ":", "\n", "            ", "gt_classes", "=", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "matched_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_classes", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "\n", "", "sampled_fg_idxs", ",", "sampled_bg_idxs", "=", "subsample_labels", "(", "\n", "gt_classes", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_fraction", ",", "self", ".", "num_classes", "\n", ")", "\n", "\n", "sampled_idxs", "=", "torch", ".", "cat", "(", "[", "sampled_fg_idxs", ",", "sampled_bg_idxs", "]", ",", "dim", "=", "0", ")", "\n", "return", "sampled_idxs", ",", "gt_classes", "[", "sampled_idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.ROIHeads.label_and_sample_proposals": [[218, 303], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "zip", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.utils.events.get_event_storage.put_scalar", "detectron2.modeling.proposal_generator.proposal_utils.add_ground_truth_to_proposals", "detectron2.structures.pairwise_iou", "maskrcnn_heads.ROIHeads.proposal_matcher", "maskrcnn_heads.ROIHeads._sample_proposals", "num_bg_samples.append", "num_fg_samples.append", "proposals_with_gt.append", "numpy.mean", "numpy.mean", "len", "targets_per_image.get_fields().items", "gt_classes.numel", "targets_per_image.get_fields", "trg_name.startswith", "proposals_per_image.set", "proposals_per_image.has"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.proposal_utils.add_ground_truth_to_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads._sample_proposals"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "\n", "self", ",", "proposals", ":", "List", "[", "Instances", "]", ",", "targets", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Prepare some proposals to be used to train the ROI heads.\n        It performs box matching between `proposals` and `targets`, and assigns\n        training labels to the proposals.\n        It returns ``self.batch_size_per_image`` random samples from proposals and groundtruth\n        boxes, with a fraction of positives that is no larger than\n        ``self.positive_fraction``.\n\n        Args:\n            See :meth:`ROIHeads.forward`\n\n        Returns:\n            list[Instances]:\n                length `N` list of `Instances`s containing the proposals\n                sampled for training. Each `Instances` has the following fields:\n\n                - proposal_boxes: the proposal boxes\n                - gt_boxes: the ground-truth box that the proposal is assigned to\n                  (this is only meaningful if the proposal has a label > 0; if label = 0\n                  then the ground-truth box is random)\n\n                Other fields such as \"gt_classes\", \"gt_masks\", that's included in `targets`.\n        \"\"\"", "\n", "gt_boxes", "=", "[", "x", ".", "gt_boxes", "for", "x", "in", "targets", "]", "\n", "# Augment proposals with ground-truth boxes.", "\n", "# In the case of learned proposals (e.g., RPN), when training starts", "\n", "# the proposals will be low quality due to random initialization.", "\n", "# It's possible that none of these initial", "\n", "# proposals have high enough overlap with the gt objects to be used", "\n", "# as positive examples for the second stage components (box head,", "\n", "# cls head, mask head). Adding the gt boxes to the set of proposals", "\n", "# ensures that the second stage components will have some positive", "\n", "# examples from the start of training. For RPN, this augmentation improves", "\n", "# convergence and empirically improves box AP on COCO by about 0.5", "\n", "# points (under one tested configuration).", "\n", "if", "self", ".", "proposal_append_gt", ":", "\n", "            ", "proposals", "=", "add_ground_truth_to_proposals", "(", "gt_boxes", ",", "proposals", ")", "\n", "\n", "", "proposals_with_gt", "=", "[", "]", "\n", "\n", "num_fg_samples", "=", "[", "]", "\n", "num_bg_samples", "=", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "has_gt", "=", "len", "(", "targets_per_image", ")", ">", "0", "\n", "match_quality_matrix", "=", "pairwise_iou", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "matched_idxs", ",", "matched_labels", "=", "self", ".", "proposal_matcher", "(", "match_quality_matrix", ")", "\n", "sampled_idxs", ",", "gt_classes", "=", "self", ".", "_sample_proposals", "(", "\n", "matched_idxs", ",", "matched_labels", ",", "targets_per_image", ".", "gt_classes", "\n", ")", "\n", "\n", "# Set target attributes of the sampled proposals:", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "\n", "if", "has_gt", ":", "\n", "                ", "sampled_targets", "=", "matched_idxs", "[", "sampled_idxs", "]", "\n", "# We index all the attributes of targets that start with \"gt_\"", "\n", "# and have not been added to proposals yet (=\"gt_classes\").", "\n", "# NOTE: here the indexing waste some compute, because heads", "\n", "# like masks, keypoints, etc, will filter the proposals again,", "\n", "# (by foreground/background, or number of keypoints in the image, etc)", "\n", "# so we essentially index the data twice.", "\n", "for", "(", "trg_name", ",", "trg_value", ")", "in", "targets_per_image", ".", "get_fields", "(", ")", ".", "items", "(", ")", ":", "\n", "                    ", "if", "trg_name", ".", "startswith", "(", "\"gt_\"", ")", "and", "not", "proposals_per_image", ".", "has", "(", "trg_name", ")", ":", "\n", "                        ", "proposals_per_image", ".", "set", "(", "trg_name", ",", "trg_value", "[", "sampled_targets", "]", ")", "\n", "# If no GT is given in the image, we don't know what a dummy gt value can be.", "\n", "# Therefore the returned proposals won't have any gt_* fields, except for a", "\n", "# gt_classes full of background label.", "\n", "\n", "", "", "", "num_bg_samples", ".", "append", "(", "(", "gt_classes", "==", "self", ".", "num_classes", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_fg_samples", ".", "append", "(", "gt_classes", ".", "numel", "(", ")", "-", "num_bg_samples", "[", "-", "1", "]", ")", "\n", "proposals_with_gt", ".", "append", "(", "proposals_per_image", ")", "\n", "\n", "# Log the number of fg/bg samples that are selected for training ROI heads", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "num_fg_samples", ")", ")", "\n", "storage", ".", "put_scalar", "(", "\"roi_head/num_bg_samples\"", ",", "np", ".", "mean", "(", "num_bg_samples", ")", ")", "\n", "\n", "return", "proposals_with_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.ROIHeads.forward": [[304, 339], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        Args:\n            images (ImageList):\n            features (dict[str,Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            proposals (list[Instances]): length `N` list of `Instances`. The i-th\n                `Instances` contains object proposals for the i-th input image,\n                with fields \"proposal_boxes\" and \"objectness_logits\".\n            targets (list[Instances], optional): length `N` list of `Instances`. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.  Specify `targets` during training only.\n                It may have the following fields:\n\n                - gt_boxes: the bounding box of each instance.\n                - gt_classes: the label for each instance with a category ranging in [0, #class].\n                - gt_masks: PolygonMasks or BitMasks, the ground-truth masks of each instance.\n                - gt_keypoints: NxKx3, the groud-truth keypoints for each instance.\n\n        Returns:\n            list[Instances]: length `N` list of `Instances` containing the\n            detected instances. Returned during inference only; may be [] during training.\n\n            dict[str->Tensor]:\n            mapping from a named loss to a tensor storing the loss. Used during training only.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads.__init__": [[353, 415], ["maskrcnn_heads.ROIHeads.__init__", "maskrcnn_heads.MaskRCNNHeads._init_sor_head", "maskrcnn_heads.MaskRCNNHeads.input_shape.items"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_sor_head"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "*", ",", "\n", "box_in_features", ":", "List", "[", "str", "]", ",", "\n", "box_pooler", ":", "ROIPooler", ",", "\n", "box_head", ":", "nn", ".", "Module", ",", "\n", "box_predictor", ":", "nn", ".", "Module", ",", "\n", "mask_in_features", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "mask_pooler", ":", "Optional", "[", "ROIPooler", "]", "=", "None", ",", "\n", "mask_head", ":", "Optional", "[", "nn", ".", "Module", "]", "=", "None", ",", "\n", "keypoint_in_features", ":", "Optional", "[", "List", "[", "str", "]", "]", "=", "None", ",", "\n", "keypoint_pooler", ":", "Optional", "[", "ROIPooler", "]", "=", "None", ",", "\n", "keypoint_head", ":", "Optional", "[", "nn", ".", "Module", "]", "=", "None", ",", "\n", "train_on_pred_boxes", ":", "bool", "=", "False", ",", "\n", "**", "kwargs", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            box_in_features (list[str]): list of feature names to use for the box head.\n            box_pooler (ROIPooler): pooler to extra region features for box head\n            box_head (nn.Module): transform features to make box predictions\n            box_predictor (nn.Module): make box predictions from the feature.\n                Should have the same interface as :class:`FastRCNNOutputLayers`.\n            mask_in_features (list[str]): list of feature names to use for the mask\n                pooler or mask head. None if not using mask head.\n            mask_pooler (ROIPooler): pooler to extract region features from image features.\n                The mask head will then take region features to make predictions.\n                If None, the mask head will directly take the dict of image features\n                defined by `mask_in_features`\n            mask_head (nn.Module): transform features to make mask predictions\n            keypoint_in_features, keypoint_pooler, keypoint_head: similar to ``mask_*``.\n            train_on_pred_boxes (bool): whether to use proposal boxes or\n                predicted boxes from the box head to train other heads.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "# keep self.in_features for backward compatibility", "\n", "self", ".", "in_features", "=", "self", ".", "box_in_features", "=", "box_in_features", "\n", "self", ".", "box_pooler", "=", "box_pooler", "\n", "self", ".", "box_head", "=", "box_head", "\n", "self", ".", "box_predictor", "=", "box_predictor", "\n", "\n", "self", ".", "mask_on", "=", "mask_in_features", "is", "not", "None", "\n", "if", "self", ".", "mask_on", ":", "\n", "            ", "self", ".", "mask_in_features", "=", "mask_in_features", "\n", "self", ".", "mask_pooler", "=", "mask_pooler", "\n", "self", ".", "mask_head", "=", "mask_head", "\n", "\n", "", "self", ".", "keypoint_on", "=", "keypoint_in_features", "is", "not", "None", "\n", "if", "self", ".", "keypoint_on", ":", "\n", "            ", "self", ".", "keypoint_in_features", "=", "keypoint_in_features", "\n", "self", ".", "keypoint_pooler", "=", "keypoint_pooler", "\n", "self", ".", "keypoint_head", "=", "keypoint_head", "\n", "\n", "", "self", ".", "train_on_pred_boxes", "=", "train_on_pred_boxes", "\n", "\n", "self", ".", "_init_sor_head", "(", "self", ".", "cfg", ")", "\n", "self", ".", "img_width", "=", "self", ".", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_WIDTH", "\n", "self", ".", "img_height", "=", "self", ".", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_HEIGHT", "\n", "self", ".", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "self", ".", "input_shape", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads.from_config": [[417, 435], ["maskrcnn_heads.ROIHeads.from_config", "inspect.ismethod", "inspect.ismethod", "inspect.ismethod", "super().from_config.update", "super().from_config.update", "super().from_config.update", "cls._init_box_head", "cls._init_mask_head", "cls._init_keypoint_head"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor.assr_dataset_mapper.DatasetMapper.from_config", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._init_box_head", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_mask_head", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_keypoint_head"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "ret", "=", "super", "(", ")", ".", "from_config", "(", "cfg", ")", "\n", "ret", "[", "\"train_on_pred_boxes\"", "]", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "TRAIN_ON_PRED_BOXES", "\n", "# Subclasses that have not been updated to use from_config style construction", "\n", "# may have overridden _init_*_head methods. In this case, those overridden methods", "\n", "# will not be classmethods and we need to avoid trying to call them here.", "\n", "# We test for this with ismethod which only returns True for bound methods of cls.", "\n", "# Such subclasses will need to handle calling their overridden _init_*_head methods.", "\n", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_box_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_box_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_mask_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_mask_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "if", "inspect", ".", "ismethod", "(", "cls", ".", "_init_keypoint_head", ")", ":", "\n", "            ", "ret", ".", "update", "(", "cls", ".", "_init_keypoint_head", "(", "cfg", ",", "input_shape", ")", ")", "\n", "", "cls", ".", "cfg", "=", "cfg", "\n", "cls", ".", "input_shape", "=", "input_shape", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._init_box_head": [[436, 471], ["tuple", "detectron2.modeling.poolers.ROIPooler", "detectron2.modeling.roi_heads.box_head.build_box_head", "detectron2.modeling.roi_heads.fast_rcnn.FastRCNNOutputLayers", "len", "detectron2.layers.ShapeSpec", "set"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "_init_box_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_BOX_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "# If StandardROIHeads is applied on multiple feature maps (as in FPN),", "\n", "# then we share the same predictors and therefore the channel counts must be the same", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "\n", "# Check all channel counts are equal", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "in_channels", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "box_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "# Here we split \"box head\" and \"box predictor\", which is mainly due to historical reasons.", "\n", "# They are used together so the \"box predictor\" layers should be part of the \"box head\".", "\n", "# New subclasses of ROIHeads do not need \"box predictor\"s.", "\n", "box_head", "=", "build_box_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "height", "=", "pooler_resolution", ",", "width", "=", "pooler_resolution", ")", "\n", ")", "\n", "box_predictor", "=", "FastRCNNOutputLayers", "(", "cfg", ",", "box_head", ".", "output_shape", ")", "\n", "return", "{", "\n", "\"box_in_features\"", ":", "in_features", ",", "\n", "\"box_pooler\"", ":", "box_pooler", ",", "\n", "\"box_head\"", ":", "box_head", ",", "\n", "\"box_predictor\"", ":", "box_predictor", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._init_mask_head": [[473, 506], ["tuple", "detectron2.modeling.roi_heads.mask_head.build_mask_head", "detectron2.modeling.poolers.ROIPooler", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.build_mask_head"], ["", "@", "classmethod", "\n", "def", "_init_mask_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "return", "{", "}", "\n", "# fmt: off", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "ret", "=", "{", "\"mask_in_features\"", ":", "in_features", "}", "\n", "ret", "[", "\"mask_pooler\"", "]", "=", "(", "\n", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "if", "pooler_type", "\n", "else", "None", "\n", ")", "\n", "if", "pooler_type", ":", "\n", "            ", "shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "{", "f", ":", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "}", "\n", "", "ret", "[", "\"mask_head\"", "]", "=", "build_mask_head", "(", "cfg", ",", "shape", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._init_keypoint_head": [[507, 540], ["tuple", "detectron2.modeling.roi_heads.keypoint_head.build_keypoint_head", "detectron2.modeling.poolers.ROIPooler", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.build_keypoint_head"], ["", "@", "classmethod", "\n", "def", "_init_keypoint_head", "(", "cls", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "return", "{", "}", "\n", "# fmt: off", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "in_features", ")", "# noqa", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_TYPE", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "in_features", "]", "[", "0", "]", "\n", "\n", "ret", "=", "{", "\"keypoint_in_features\"", ":", "in_features", "}", "\n", "ret", "[", "\"keypoint_pooler\"", "]", "=", "(", "\n", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", ")", "\n", "if", "pooler_type", "\n", "else", "None", "\n", ")", "\n", "if", "pooler_type", ":", "\n", "            ", "shape", "=", "ShapeSpec", "(", "\n", "channels", "=", "in_channels", ",", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", "\n", ")", "\n", "", "else", ":", "\n", "            ", "shape", "=", "{", "f", ":", "input_shape", "[", "f", "]", "for", "f", "in", "in_features", "}", "\n", "", "ret", "[", "\"keypoint_head\"", "]", "=", "build_keypoint_head", "(", "cfg", ",", "shape", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._init_sor_head": [[541, 547], ["sor_heads.build_sor_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.build_sor_head"], ["", "def", "_init_sor_head", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "sor_head", "=", "build_sor_head", "(", "\n", "cfg", ",", "\n", "ShapeSpec", "(", "channels", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", ",", "\n", "width", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", ",", "\n", "height", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads.forward": [[550, 583], ["maskrcnn_heads.MaskRCNNHeads.label_and_sample_proposals", "maskrcnn_heads.MaskRCNNHeads._forward_box", "maskrcnn_heads.MaskRCNNHeads._forward_mask", "maskrcnn_heads.MaskRCNNHeads.update", "maskrcnn_heads.MaskRCNNHeads.update", "maskrcnn_heads.MaskRCNNHeads.update", "maskrcnn_heads.MaskRCNNHeads._forward_box", "maskrcnn_heads.MaskRCNNHeads.forward_with_given_boxes", "maskrcnn_heads.MaskRCNNHeads._forward_sor", "maskrcnn_heads.MaskRCNNHeads._forward_keypoint"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._forward_box", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._forward_box", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_keypoint"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        See :class:`ROIHeads.forward`.\n        \"\"\"", "\n", "del", "images", "\n", "if", "self", ".", "training", ":", "\n", "            ", "assert", "targets", ",", "\"'targets' argument is required during training\"", "\n", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "", "del", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "# Usually the original proposals used by the box head are used by the mask, keypoint", "\n", "# heads. But when `self.train_on_pred_boxes is True`, proposals will contain boxes", "\n", "# predicted by the box head.", "\n", "mask_loss", ",", "mask_features", ",", "selected_mask", ",", "pos_proposals", ",", "pos", "=", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", "\n", "losses", ".", "update", "(", "mask_loss", ")", "\n", "losses", ".", "update", "(", "self", ".", "_forward_sor", "(", "mask_features", ",", "pos_proposals", ",", "selected_mask", ",", "pos", "=", "pos", ")", ")", "\n", "\n", "losses", ".", "update", "(", "self", ".", "_forward_keypoint", "(", "features", ",", "proposals", ")", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", "=", "self", ".", "_forward_box", "(", "features", ",", "proposals", ")", "\n", "# During inference cascaded prediction is used: the mask and keypoints heads are only", "\n", "# applied to the top scoring box detections.", "\n", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "pred_instances", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads.forward_with_given_boxes": [[584, 611], ["maskrcnn_heads.MaskRCNNHeads._forward_mask", "maskrcnn_heads.MaskRCNNHeads._forward_sor", "maskrcnn_heads.MaskRCNNHeads._forward_keypoint", "instances[].has", "instances[].has"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_keypoint"], ["", "", "def", "forward_with_given_boxes", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        This is useful for downstream tasks where a box is known, but need to obtain\n        other attributes (outputs of other heads).\n        Test-time augmentation also uses this.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (list[Instances]):\n                the same `Instances` objects, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "assert", "instances", "[", "0", "]", ".", "has", "(", "\"pred_boxes\"", ")", "and", "instances", "[", "0", "]", ".", "has", "(", "\"pred_classes\"", ")", "\n", "\n", "instances", ",", "mask_features", ",", "pos", "=", "self", ".", "_forward_mask", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_sor", "(", "mask_features", ",", "instances", ",", "pos", "=", "pos", ")", "\n", "instances", "=", "self", ".", "_forward_keypoint", "(", "features", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._forward_box": [[612, 649], ["maskrcnn_heads.MaskRCNNHeads.box_pooler", "maskrcnn_heads.MaskRCNNHeads.box_head", "maskrcnn_heads.MaskRCNNHeads.box_predictor", "maskrcnn_heads.MaskRCNNHeads.box_predictor.losses", "maskrcnn_heads.MaskRCNNHeads.box_predictor.inference", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "maskrcnn_heads.MaskRCNNHeads.box_predictor.predict_boxes_for_gt_classes", "zip", "detectron2.structures.Boxes"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.losses"], ["", "def", "_forward_box", "(", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "proposals", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the box prediction branch. If `self.train_on_pred_boxes is True`,\n            the function puts predicted boxes in the `proposal_boxes` field of `proposals` argument.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            proposals (list[Instances]): the per-image object proposals with\n                their matching ground truth.\n                Each has fields \"proposal_boxes\", and \"objectness_logits\",\n                \"gt_classes\", \"gt_boxes\".\n\n        Returns:\n            In training, a dict of losses.\n            In inference, a list of `Instances`, the predicted instances.\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "box_in_features", "]", "\n", "box_features", "=", "self", ".", "box_pooler", "(", "features", ",", "[", "x", ".", "proposal_boxes", "for", "x", "in", "proposals", "]", ")", "\n", "box_features", "=", "self", ".", "box_head", "(", "box_features", ")", "\n", "predictions", "=", "self", ".", "box_predictor", "(", "box_features", ")", "\n", "del", "box_features", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", "=", "self", ".", "box_predictor", ".", "losses", "(", "predictions", ",", "proposals", ")", "\n", "# proposals is modified in-place below, so losses must be computed first.", "\n", "if", "self", ".", "train_on_pred_boxes", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "pred_boxes", "=", "self", ".", "box_predictor", ".", "predict_boxes_for_gt_classes", "(", "\n", "predictions", ",", "proposals", "\n", ")", "\n", "for", "proposals_per_image", ",", "pred_boxes_per_image", "in", "zip", "(", "proposals", ",", "pred_boxes", ")", ":", "\n", "                        ", "proposals_per_image", ".", "proposal_boxes", "=", "Boxes", "(", "pred_boxes_per_image", ")", "\n", "", "", "", "return", "losses", "\n", "", "else", ":", "\n", "            ", "pred_instances", ",", "_", "=", "self", ".", "box_predictor", ".", "inference", "(", "predictions", ",", "proposals", ")", "\n", "return", "pred_instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._forward_mask": [[650, 707], ["maskrcnn_heads.MaskRCNNHeads.mask_pooler", "maskrcnn_heads.select_foreground_proposals", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "torch.arange().reshape", "y.repeat().cuda.repeat().cuda.repeat().cuda", "x.repeat().cuda.repeat().cuda.repeat().cuda", "features_.append", "maskrcnn_heads.MaskRCNNHeads.mask_head.layers", "maskrcnn_heads.MaskRCNNHeads.mask_head", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "detectron2.modeling.roi_heads.mask_head.mask_rcnn_loss", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "y.repeat().cuda.repeat().cuda.repeat", "x.repeat().cuda.repeat().cuda.repeat"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.KRCNNConvDeconvUpsampleHead.layers", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_loss"], ["", "", "def", "_forward_mask", "(", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the boxes predicted by R-CNN box head.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_masks\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "mask_on", ":", "\n", "# https://github.com/pytorch/pytorch/issues/43942", "\n", "            ", "if", "self", ".", "training", ":", "\n", "                ", "return", "{", "}", "\n", "", "else", ":", "\n", "                ", "return", "instances", "\n", "\n", "", "", "if", "self", ".", "training", ":", "\n", "# head is only trained on positive proposals.", "\n", "            ", "instances", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "\n", "\n", "# features = [features[f] for f in self.mask_in_features]", "\n", "", "features_", "=", "[", "]", "\n", "for", "f", "in", "self", ".", "in_features", ":", "\n", "            ", "stride", "=", "self", ".", "feature_strides", "[", "f", "]", "\n", "y", "=", "torch", ".", "arange", "(", "stride", "/", "2", ",", "self", ".", "img_height", ",", "stride", ")", ".", "reshape", "(", "1", ",", "1", ",", "-", "1", ",", "1", ")", "\n", "x", "=", "torch", ".", "arange", "(", "stride", "/", "2", ",", "self", ".", "img_width", ",", "stride", ")", ".", "reshape", "(", "1", ",", "1", ",", "1", ",", "-", "1", ")", "\n", "feature", "=", "features", "[", "f", "]", "\n", "# norm", "\n", "y", "/=", "self", ".", "img_height", "\n", "x", "/=", "self", ".", "img_width", "\n", "# repeat", "\n", "y", "=", "y", ".", "repeat", "(", "feature", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "self", ".", "img_width", "//", "stride", ")", ".", "cuda", "(", ")", "\n", "x", "=", "x", ".", "repeat", "(", "feature", ".", "shape", "[", "0", "]", ",", "1", ",", "self", ".", "img_height", "//", "stride", ",", "1", ")", ".", "cuda", "(", ")", "\n", "features_", ".", "append", "(", "torch", ".", "cat", "(", "(", "feature", ",", "y", ",", "x", ")", ",", "dim", "=", "1", ")", ")", "\n", "", "features", "=", "features_", "\n", "\n", "\n", "boxes", "=", "[", "x", ".", "proposal_boxes", "if", "self", ".", "training", "else", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "mask_features", "=", "self", ".", "mask_pooler", "(", "features", ",", "boxes", ")", "\n", "\n", "pos", "=", "mask_features", "[", ":", ",", "-", "2", ":", ",", ":", ",", ":", "]", "\n", "mask_features", "=", "mask_features", "[", ":", ",", ":", "-", "2", ",", ":", ",", ":", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "selected_mask", "=", "self", ".", "mask_head", ".", "layers", "(", "mask_features", ")", "\n", "mask_loss", "=", "{", "'mask_loss'", ":", "mask_rcnn_loss", "(", "selected_mask", ",", "instances", ")", "}", "\n", "return", "mask_loss", ",", "mask_features", ",", "selected_mask", ",", "instances", ",", "pos", "\n", "", "else", ":", "\n", "            ", "instances", "=", "self", ".", "mask_head", "(", "mask_features", ",", "instances", ")", "\n", "return", "instances", ",", "mask_features", ",", "pos", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._forward_keypoint": [[708, 741], ["maskrcnn_heads.MaskRCNNHeads.keypoint_head", "maskrcnn_heads.select_foreground_proposals", "maskrcnn_heads.select_proposals_with_visible_keypoints", "maskrcnn_heads.MaskRCNNHeads.keypoint_pooler", "dict"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_proposals_with_visible_keypoints"], ["", "", "def", "_forward_keypoint", "(", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the keypoint prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict keypoints.\n                In training, they can be the proposals.\n                In inference, they can be the boxes predicted by R-CNN box head.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_keypoints\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "keypoint_on", ":", "\n", "            ", "if", "self", ".", "training", ":", "\n", "                ", "return", "{", "}", "\n", "", "else", ":", "\n", "                ", "return", "instances", "\n", "\n", "", "", "if", "self", ".", "training", ":", "\n", "# head is only trained on positive proposals with >=1 visible keypoints.", "\n", "            ", "instances", ",", "_", "=", "select_foreground_proposals", "(", "instances", ",", "self", ".", "num_classes", ")", "\n", "instances", "=", "select_proposals_with_visible_keypoints", "(", "instances", ")", "\n", "\n", "", "if", "self", ".", "keypoint_pooler", "is", "not", "None", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "keypoint_in_features", "]", "\n", "boxes", "=", "[", "x", ".", "proposal_boxes", "if", "self", ".", "training", "else", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "features", "=", "self", ".", "keypoint_pooler", "(", "features", ",", "boxes", ")", "\n", "", "else", ":", "\n", "            ", "features", "=", "dict", "(", "[", "(", "f", ",", "features", "[", "f", "]", ")", "for", "f", "in", "self", ".", "keypoint_in_features", "]", ")", "\n", "", "return", "self", ".", "keypoint_head", "(", "features", ",", "instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.MaskRCNNHeads._forward_sor": [[743, 791], ["maskrcnn_heads.MaskRCNNHeads.sor_head", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "maskrcnn_heads.MaskRCNNHeads.sor_head", "F.softmax", "deepcopy", "range", "zip", "sor_heads.sor_loss", "print", "pred_ranks[].argmax", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "float"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.sor_loss"], ["", "def", "_forward_sor", "(", "self", ",", "mask_features", ",", "instances", ",", "selected_mask", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask iou prediction branch.\n        Args:\n            features (list[Tensor]): #level input features for mask prediction\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n            selected_mask (list[Tensor]) mask prediction resolution x resolution x 1\n        Returns:\n            In training, a dict of losses.\n            In inference, instances' rank scores.\n        \"\"\"", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "pred_sor", "=", "self", ".", "sor_head", "(", "mask_features", ",", "selected_mask", ",", "instances", "=", "instances", ",", "pos", "=", "pos", ")", "\n", "return", "{", "\"sor_loss\"", ":", "sor_loss", "(", "pred_sor", ",", "instances", ")", "}", "\n", "", "else", ":", "\n", "            ", "selected_mask", "=", "torch", ".", "cat", "(", "[", "i", ".", "pred_masks", "for", "i", "in", "instances", "]", ",", "0", ")", "\n", "if", "selected_mask", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "print", "(", "'selected_mask.shape[0] == 0'", ")", "\n", "return", "instances", "\n", "# print(self.sor_head(mask_features, selected_mask).shape)", "\n", "\n", "# pred_sor = [self.sor_head(mask_features, selected_mask, instances=None, pos=pos)]", "\n", "", "pred_ranks", "=", "self", ".", "sor_head", "(", "mask_features", ",", "selected_mask", ",", "instances", "=", "instances", ",", "pos", "=", "pos", ")", "\n", "import", "torch", ".", "nn", ".", "functional", "as", "F", "\n", "pred_ranks", "=", "F", ".", "softmax", "(", "pred_ranks", ",", "dim", "=", "0", ")", "\n", "\n", "ranks", "=", "pred_ranks", ".", "shape", "[", "0", "]", "*", "[", "-", "1", "]", "\n", "from", "copy", "import", "deepcopy", "\n", "tmp", "=", "deepcopy", "(", "pred_ranks", ")", "\n", "for", "r", "in", "range", "(", "4", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "                ", "idx", "=", "pred_ranks", "[", ":", ",", "r", "]", ".", "argmax", "(", ")", "\n", "if", "pred_ranks", "[", "idx", ",", "r", "]", ">", "0", ":", "\n", "                    ", "ranks", "[", "idx", "]", "=", "r", "\n", "pred_ranks", "[", "idx", ",", ":", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "# if 4 not in ranks and len(ranks) >=5 :", "\n", "# with open('tmp2.pkl', 'wb') as f:", "\n", "#     import pickle", "\n", "#     pickle.dump(tmp, f)", "\n", "#     exit(0)", "\n", "", "", "pred_sor", "=", "[", "torch", ".", "Tensor", "(", "ranks", ")", "]", "\n", "\n", "\n", "for", "rank", ",", "box", "in", "zip", "(", "pred_sor", ",", "instances", ")", ":", "\n", "                ", "box", ".", "pred_ranks", "=", "rank", "\n", "", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.build_roi_heads": [[37, 43], ["detectron2.modeling.roi_heads.ROI_HEADS_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["def", "build_roi_heads", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build ROIHeads defined by `cfg.MODEL.ROI_HEADS.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NAME", "\n", "return", "ROI_HEADS_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.select_foreground_proposals": [[45, 75], ["isinstance", "isinstance", "proposals[].has", "fg_selection_mask.nonzero().squeeze", "fg_proposals.append", "fg_selection_masks.append", "fg_selection_mask.nonzero"], "function", ["None"], ["", "def", "select_foreground_proposals", "(", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "bg_label", ":", "int", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "List", "[", "torch", ".", "Tensor", "]", "]", ":", "\n", "    ", "\"\"\"\n    Given a list of N Instances (for N images), each containing a `gt_classes` field,\n    return a list of Instances that contain only instances with `gt_classes != -1 &&\n    gt_classes != bg_label`.\n\n    Args:\n        proposals (list[Instances]): A list of N Instances, where N is the number of\n            images in the batch.\n        bg_label: label index of background class.\n\n    Returns:\n        list[Instances]: N Instances, each contains only the selected foreground instances.\n        list[Tensor]: N boolean vector, correspond to the selection mask of\n            each Instances object. True for selected instances.\n    \"\"\"", "\n", "assert", "isinstance", "(", "proposals", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "proposals", "[", "0", "]", ",", "Instances", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "fg_proposals", "=", "[", "]", "\n", "fg_selection_masks", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "        ", "gt_classes", "=", "proposals_per_image", ".", "gt_classes", "\n", "fg_selection_mask", "=", "(", "gt_classes", "!=", "-", "1", ")", "&", "(", "gt_classes", "!=", "bg_label", ")", "\n", "fg_idxs", "=", "fg_selection_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "fg_proposals", ".", "append", "(", "proposals_per_image", "[", "fg_idxs", "]", ")", "\n", "fg_selection_masks", ".", "append", "(", "fg_selection_mask", ")", "\n", "", "return", "fg_proposals", ",", "fg_selection_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskrcnn_heads.select_proposals_with_visible_keypoints": [[77, 120], ["detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "proposals_per_image.proposal_boxes.tensor.unsqueeze", "all_num_fg.append", "ret.append", "numpy.mean", "len", "ret.append", "detectron2.layers.nonzero_tuple", "selection_idxs.numel"], "function", ["None"], ["", "def", "select_proposals_with_visible_keypoints", "(", "proposals", ":", "List", "[", "Instances", "]", ")", "->", "List", "[", "Instances", "]", ":", "\n", "    ", "\"\"\"\n    Args:\n        proposals (list[Instances]): a list of N Instances, where N is the\n            number of images.\n\n    Returns:\n        proposals: only contains proposals with at least one visible keypoint.\n\n    Note that this is still slightly different from Detectron.\n    In Detectron, proposals for training keypoint head are re-sampled from\n    all the proposals with IOU>threshold & >=1 visible keypoint.\n\n    Here, the proposals are first sampled from all proposals with\n    IOU>threshold, then proposals with no visible keypoint are filtered out.\n    This strategy seems to make no difference on Detectron and is easier to implement.\n    \"\"\"", "\n", "ret", "=", "[", "]", "\n", "all_num_fg", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "# If empty/unannotated image (hard negatives), skip filtering for train", "\n", "        ", "if", "len", "(", "proposals_per_image", ")", "==", "0", ":", "\n", "            ", "ret", ".", "append", "(", "proposals_per_image", ")", "\n", "continue", "\n", "", "gt_keypoints", "=", "proposals_per_image", ".", "gt_keypoints", ".", "tensor", "\n", "# #fg x K x 3", "\n", "vis_mask", "=", "gt_keypoints", "[", ":", ",", ":", ",", "2", "]", ">=", "1", "\n", "xs", ",", "ys", "=", "gt_keypoints", "[", ":", ",", ":", ",", "0", "]", ",", "gt_keypoints", "[", ":", ",", ":", ",", "1", "]", "\n", "proposal_boxes", "=", "proposals_per_image", ".", "proposal_boxes", ".", "tensor", ".", "unsqueeze", "(", "dim", "=", "1", ")", "# #fg x 1 x 4", "\n", "kp_in_box", "=", "(", "\n", "(", "xs", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "&", "(", "xs", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "2", "]", ")", "\n", "&", "(", "ys", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "1", "]", ")", "\n", "&", "(", "ys", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "3", "]", ")", "\n", ")", "\n", "selection", "=", "(", "kp_in_box", "&", "vis_mask", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "selection_idxs", "=", "nonzero_tuple", "(", "selection", ")", "[", "0", "]", "\n", "all_num_fg", ".", "append", "(", "selection_idxs", ".", "numel", "(", ")", ")", "\n", "ret", ".", "append", "(", "proposals_per_image", "[", "selection_idxs", "]", ")", "\n", "\n", "", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"keypoint_head/num_fg_samples\"", ",", "np", ".", "mean", "(", "all_num_fg", ")", ")", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.BaseKeypointRCNNHead.__init__": [[123, 134], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "self", ".", "loss_weight", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "LOSS_WEIGHT", "\n", "self", ".", "normalize_by_visible_keypoints", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NORMALIZE_LOSS_BY_VISIBLE_KEYPOINTS", "# noqa", "\n", "self", ".", "num_keypoints", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_KEYPOINTS", "\n", "batch_size_per_image", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", "\n", "positive_sample_fraction", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", "\n", "# fmt: on", "\n", "self", ".", "normalizer_per_img", "=", "(", "\n", "self", ".", "num_keypoints", "*", "batch_size_per_image", "*", "positive_sample_fraction", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.BaseKeypointRCNNHead.forward": [[136, 165], ["keypoint_head.BaseKeypointRCNNHead.layers", "len", "keypoint_head.keypoint_rcnn_inference", "keypoint_head.keypoint_rcnn_loss"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.KRCNNConvDeconvUpsampleHead.layers", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.keypoint_rcnn_inference", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.keypoint_rcnn_loss"], ["", "def", "forward", "(", "self", ",", "x", ",", "instances", ":", "List", "[", "Instances", "]", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x: input region feature(s) provided by :class:`ROIHeads`.\n            instances (list[Instances]): contains the boxes & labels corresponding\n                to the input features.\n                Exact format is up to its caller to decide.\n                Typically, this is the foreground instances in training, with\n                \"proposal_boxes\" field and other gt annotations.\n                In inference, it contains boxes that are already predicted.\n\n        Returns:\n            A dict of losses if in training. The predicted \"instances\" if in inference.\n        \"\"\"", "\n", "x", "=", "self", ".", "layers", "(", "x", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "num_images", "=", "len", "(", "instances", ")", "\n", "normalizer", "=", "(", "\n", "None", "\n", "if", "self", ".", "normalize_by_visible_keypoints", "\n", "else", "num_images", "*", "self", ".", "normalizer_per_img", "\n", ")", "\n", "return", "{", "\n", "\"loss_keypoint\"", ":", "keypoint_rcnn_loss", "(", "x", ",", "instances", ",", "normalizer", "=", "normalizer", ")", "\n", "*", "self", ".", "loss_weight", "\n", "}", "\n", "", "else", ":", "\n", "            ", "keypoint_rcnn_inference", "(", "x", ",", "instances", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.BaseKeypointRCNNHead.layers": [[166, 171], ["None"], "methods", ["None"], ["", "", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Neural network layers that makes predictions from regional input features.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.KRCNNConvDeconvUpsampleHead.__init__": [[180, 218], ["keypoint_head.BaseKeypointRCNNHead.__init__", "enumerate", "detectron2.layers.ConvTranspose2d", "keypoint_head.KRCNNConvDeconvUpsampleHead.named_parameters", "detectron2.layers.Conv2d", "keypoint_head.KRCNNConvDeconvUpsampleHead.add_module", "keypoint_head.KRCNNConvDeconvUpsampleHead.blocks.append", "torch.nn.init.constant_", "torch.nn.init.kaiming_normal_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "        ", "\"\"\"\n        The following attributes are parsed from config:\n            conv_dims: an iterable of output channel counts for each conv in the head\n                         e.g. (512, 512, 512) for three convs outputting 512 channels.\n            num_keypoints: number of keypoint heatmaps to predicts, determines the number of\n                           channels in the final output.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "\n", "# fmt: off", "\n", "# default up_scale to 2 (this can eventually be moved to config)", "\n", "up_scale", "=", "2", "\n", "conv_dims", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "CONV_DIMS", "\n", "num_keypoints", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NUM_KEYPOINTS", "\n", "in_channels", "=", "input_shape", ".", "channels", "\n", "# fmt: on", "\n", "\n", "self", ".", "blocks", "=", "[", "]", "\n", "for", "idx", ",", "layer_channels", "in", "enumerate", "(", "conv_dims", ",", "1", ")", ":", "\n", "            ", "module", "=", "Conv2d", "(", "in_channels", ",", "layer_channels", ",", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "add_module", "(", "\"conv_fcn{}\"", ".", "format", "(", "idx", ")", ",", "module", ")", "\n", "self", ".", "blocks", ".", "append", "(", "module", ")", "\n", "in_channels", "=", "layer_channels", "\n", "\n", "", "deconv_kernel", "=", "4", "\n", "self", ".", "score_lowres", "=", "ConvTranspose2d", "(", "\n", "in_channels", ",", "num_keypoints", ",", "deconv_kernel", ",", "stride", "=", "2", ",", "padding", "=", "deconv_kernel", "//", "2", "-", "1", "\n", ")", "\n", "self", ".", "up_scale", "=", "up_scale", "\n", "\n", "for", "name", ",", "param", "in", "self", ".", "named_parameters", "(", ")", ":", "\n", "            ", "if", "\"bias\"", "in", "name", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "param", ",", "0", ")", "\n", "", "elif", "\"weight\"", "in", "name", ":", "\n", "# Caffe2 implementation uses MSRAFill, which in fact", "\n", "# corresponds to kaiming_normal_ in PyTorch", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "param", ",", "mode", "=", "\"fan_out\"", ",", "nonlinearity", "=", "\"relu\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.KRCNNConvDeconvUpsampleHead.layers": [[219, 225], ["keypoint_head.KRCNNConvDeconvUpsampleHead.score_lowres", "detectron2.layers.interpolate", "torch.nn.functional.relu", "layer"], "methods", ["None"], ["", "", "", "def", "layers", "(", "self", ",", "x", ")", ":", "\n", "        ", "for", "layer", "in", "self", ".", "blocks", ":", "\n", "            ", "x", "=", "F", ".", "relu", "(", "layer", "(", "x", ")", ")", "\n", "", "x", "=", "self", ".", "score_lowres", "(", "x", ")", "\n", "x", "=", "interpolate", "(", "x", ",", "scale_factor", "=", "self", ".", "up_scale", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "False", ")", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.build_keypoint_head": [[22, 28], ["ROI_KEYPOINT_HEAD_REGISTRY.get"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["def", "build_keypoint_head", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Build a keypoint head from `cfg.MODEL.ROI_KEYPOINT_HEAD.NAME`.\n    \"\"\"", "\n", "name", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "NAME", "\n", "return", "ROI_KEYPOINT_HEAD_REGISTRY", ".", "get", "(", "name", ")", "(", "cfg", ",", "input_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.keypoint_rcnn_loss": [[30, 87], ["len", "pred_keypoint_logits.view.view", "torch.nn.functional.cross_entropy", "keypoints.to_heatmap", "heatmaps.append", "torch.nonzero().squeeze.append", "detectron2.layers.cat", "detectron2.layers.cat().to", "torch.nonzero().squeeze", "detectron2.utils.events.get_event_storage", "detectron2.utils.events.get_event_storage.put_scalar", "torch.nonzero().squeeze.numel", "len", "heatmaps_per_image.view", "valid_per_image.view", "len", "torch.nonzero().squeeze.numel", "pred_keypoint_logits.view.sum", "detectron2.layers.cat", "torch.nonzero"], "function", ["None"], ["", "def", "keypoint_rcnn_loss", "(", "pred_keypoint_logits", ",", "instances", ",", "normalizer", ")", ":", "\n", "    ", "\"\"\"\n    Arguments:\n        pred_keypoint_logits (Tensor): A tensor of shape (N, K, S, S) where N is the total number\n            of instances in the batch, K is the number of keypoints, and S is the side length\n            of the keypoint heatmap. The values are spatial logits.\n        instances (list[Instances]): A list of M Instances, where M is the batch size.\n            These instances are predictions from the model\n            that are in 1:1 correspondence with pred_keypoint_logits.\n            Each Instances should contain a `gt_keypoints` field containing a `structures.Keypoint`\n            instance.\n        normalizer (float): Normalize the loss by this amount.\n            If not specified, we normalize by the number of visible keypoints in the minibatch.\n\n    Returns a scalar tensor containing the loss.\n    \"\"\"", "\n", "heatmaps", "=", "[", "]", "\n", "valid", "=", "[", "]", "\n", "\n", "keypoint_side_len", "=", "pred_keypoint_logits", ".", "shape", "[", "2", "]", "\n", "for", "instances_per_image", "in", "instances", ":", "\n", "        ", "if", "len", "(", "instances_per_image", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "keypoints", "=", "instances_per_image", ".", "gt_keypoints", "\n", "heatmaps_per_image", ",", "valid_per_image", "=", "keypoints", ".", "to_heatmap", "(", "\n", "instances_per_image", ".", "proposal_boxes", ".", "tensor", ",", "keypoint_side_len", "\n", ")", "\n", "heatmaps", ".", "append", "(", "heatmaps_per_image", ".", "view", "(", "-", "1", ")", ")", "\n", "valid", ".", "append", "(", "valid_per_image", ".", "view", "(", "-", "1", ")", ")", "\n", "\n", "", "if", "len", "(", "heatmaps", ")", ":", "\n", "        ", "keypoint_targets", "=", "cat", "(", "heatmaps", ",", "dim", "=", "0", ")", "\n", "valid", "=", "cat", "(", "valid", ",", "dim", "=", "0", ")", ".", "to", "(", "dtype", "=", "torch", ".", "uint8", ")", "\n", "valid", "=", "torch", ".", "nonzero", "(", "valid", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "# torch.mean (in binary_cross_entropy_with_logits) doesn't", "\n", "# accept empty tensors, so handle it separately", "\n", "", "if", "len", "(", "heatmaps", ")", "==", "0", "or", "valid", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "global", "_TOTAL_SKIPPED", "\n", "_TOTAL_SKIPPED", "+=", "1", "\n", "storage", "=", "get_event_storage", "(", ")", "\n", "storage", ".", "put_scalar", "(", "\"kpts_num_skipped_batches\"", ",", "_TOTAL_SKIPPED", ",", "smoothing_hint", "=", "False", ")", "\n", "return", "pred_keypoint_logits", ".", "sum", "(", ")", "*", "0", "\n", "\n", "", "N", ",", "K", ",", "H", ",", "W", "=", "pred_keypoint_logits", ".", "shape", "\n", "pred_keypoint_logits", "=", "pred_keypoint_logits", ".", "view", "(", "N", "*", "K", ",", "H", "*", "W", ")", "\n", "\n", "keypoint_loss", "=", "F", ".", "cross_entropy", "(", "\n", "pred_keypoint_logits", "[", "valid", "]", ",", "keypoint_targets", "[", "valid", "]", ",", "reduction", "=", "\"sum\"", "\n", ")", "\n", "\n", "# If a normalizer isn't specified, normalize by the number of visible keypoints in the minibatch", "\n", "if", "normalizer", "is", "None", ":", "\n", "        ", "normalizer", "=", "valid", ".", "numel", "(", ")", "\n", "", "keypoint_loss", "/=", "normalizer", "\n", "\n", "return", "keypoint_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.keypoint_rcnn_inference": [[89, 116], ["detectron2.layers.cat", "detectron2.structures.heatmaps_to_keypoints", "keypoint_results[].split", "zip", "pred_keypoint_logits.detach", "detectron2.layers.cat.detach", "len"], "function", ["None"], ["", "def", "keypoint_rcnn_inference", "(", "pred_keypoint_logits", ",", "pred_instances", ")", ":", "\n", "    ", "\"\"\"\n    Post process each predicted keypoint heatmap in `pred_keypoint_logits` into (x, y, score)\n        and add it to the `pred_instances` as a `pred_keypoints` field.\n\n    Args:\n        pred_keypoint_logits (Tensor): A tensor of shape (R, K, S, S) where R is the total number\n           of instances in the batch, K is the number of keypoints, and S is the side length of\n           the keypoint heatmap. The values are spatial logits.\n        pred_instances (list[Instances]): A list of N Instances, where N is the number of images.\n\n    Returns:\n        None. Each element in pred_instances will contain an extra \"pred_keypoints\" field.\n            The field is a tensor of shape (#instance, K, 3) where the last\n            dimension corresponds to (x, y, score).\n            The scores are larger than 0.\n    \"\"\"", "\n", "# flatten all bboxes from all images together (list[Boxes] -> Rx4 tensor)", "\n", "bboxes_flat", "=", "cat", "(", "[", "b", ".", "pred_boxes", ".", "tensor", "for", "b", "in", "pred_instances", "]", ",", "dim", "=", "0", ")", "\n", "\n", "keypoint_results", "=", "heatmaps_to_keypoints", "(", "pred_keypoint_logits", ".", "detach", "(", ")", ",", "bboxes_flat", ".", "detach", "(", ")", ")", "\n", "num_instances_per_image", "=", "[", "len", "(", "i", ")", "for", "i", "in", "pred_instances", "]", "\n", "keypoint_results", "=", "keypoint_results", "[", ":", ",", ":", ",", "[", "0", ",", "1", ",", "3", "]", "]", ".", "split", "(", "num_instances_per_image", ",", "dim", "=", "0", ")", "\n", "\n", "for", "keypoint_results_per_image", ",", "instances_per_image", "in", "zip", "(", "keypoint_results", ",", "pred_instances", ")", ":", "\n", "# keypoint_results_per_image is (num instances)x(num keypoints)x(x, y, score)", "\n", "        ", "instances_per_image", ".", "pred_keypoints", "=", "keypoint_results_per_image", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads.__init__": [[115, 136], ["torch.nn.Module.__init__", "detectron2.modeling.matcher.Matcher", "input_shape.items", "input_shape.items"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", "ROIHeads", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# fmt: off", "\n", "self", ".", "batch_size_per_image", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "BATCH_SIZE_PER_IMAGE", "\n", "self", ".", "positive_sample_fraction", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "POSITIVE_FRACTION", "\n", "self", ".", "test_score_thresh", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "\n", "self", ".", "test_nms_thresh", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NMS_THRESH_TEST", "\n", "self", ".", "test_detections_per_img", "=", "cfg", ".", "TEST", ".", "DETECTIONS_PER_IMAGE", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IN_FEATURES", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "NUM_CLASSES", "\n", "self", ".", "proposal_append_gt", "=", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "PROPOSAL_APPEND_GT", "\n", "self", ".", "feature_strides", "=", "{", "k", ":", "v", ".", "stride", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "self", ".", "feature_channels", "=", "{", "k", ":", "v", ".", "channels", "for", "k", ",", "v", "in", "input_shape", ".", "items", "(", ")", "}", "\n", "# fmt: on", "\n", "\n", "# Matcher to assign box proposals to gt boxes", "\n", "self", ".", "proposal_matcher", "=", "Matcher", "(", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_THRESHOLDS", ",", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "IOU_LABELS", ",", "\n", "allow_low_quality_matches", "=", "False", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads._sample_proposals": [[138, 180], ["detectron2.modeling.sampling.subsample_labels", "torch.cat", "gt_classes.numel", "torch.zeros_like", "torch.zeros_like"], "methods", ["None"], ["", "def", "_sample_proposals", "(", "self", ",", "matched_idxs", ",", "matched_labels", ",", "gt_classes", ",", "gt_ranks", ")", ":", "\n", "        ", "\"\"\"\n        Based on the matching between N proposals and M groundtruth,\n        sample the proposals and set their classification labels.\n\n        Args:\n            matched_idxs (Tensor): a vector of length N, each is the best-matched\n                gt index in [0, M) for each proposal.\n            matched_labels (Tensor): a vector of length N, the matcher's label\n                (one of cfg.MODEL.ROI_HEADS.IOU_LABELS) for each proposal.\n            gt_classes (Tensor): a vector of length M.\n\n        Returns:\n            Tensor: a vector of indices of sampled proposals. Each is in [0, N).\n            Tensor: a vector of the same length, the classification label for\n                each sampled proposal. Each sample is labeled as either a category in\n                [0, num_classes) or the background (num_classes).\n        \"\"\"", "\n", "has_gt", "=", "gt_classes", ".", "numel", "(", ")", ">", "0", "\n", "# Get the corresponding GT for each proposal", "\n", "if", "has_gt", ":", "\n", "            ", "gt_classes", "=", "gt_classes", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_classes", "[", "matched_labels", "==", "0", "]", "=", "self", ".", "num_classes", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_classes", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1", "\n", "\n", "gt_ranks", "=", "gt_ranks", "[", "matched_idxs", "]", "\n", "# Label unmatched proposals (0 label from matcher) as background (label=num_classes)", "\n", "gt_ranks", "[", "matched_labels", "==", "0", "]", "=", "0.0", "# neg", "\n", "# Label ignore proposals (-1 label)", "\n", "gt_ranks", "[", "matched_labels", "==", "-", "1", "]", "=", "-", "1.0", "# backgound rank", "\n", "", "else", ":", "\n", "            ", "gt_classes", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "self", ".", "num_classes", "\n", "gt_ranks", "=", "torch", ".", "zeros_like", "(", "matched_idxs", ")", "+", "0.0", "\n", "\n", "", "sampled_fg_idxs", ",", "sampled_bg_idxs", "=", "subsample_labels", "(", "\n", "gt_classes", ",", "self", ".", "batch_size_per_image", ",", "self", ".", "positive_sample_fraction", ",", "self", ".", "num_classes", "\n", ")", "\n", "\n", "sampled_idxs", "=", "torch", ".", "cat", "(", "[", "sampled_fg_idxs", ",", "sampled_bg_idxs", "]", ",", "dim", "=", "0", ")", "\n", "return", "sampled_idxs", ",", "gt_classes", "[", "sampled_idxs", "]", ",", "gt_ranks", "[", "sampled_idxs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads.label_and_sample_proposals": [[181, 276], ["torch.no_grad", "zip", "proposal_utils.add_ground_truth_to_proposals", "detectron2.structures.pairwise_iou", "center_heads.ROIHeads.proposal_matcher", "center_heads.ROIHeads._sample_proposals", "num_bg_samples.append", "num_fg_samples.append", "proposals_with_gt.append", "len", "targets_per_image.get_fields().items", "detectron2.structures.Boxes", "targets_per_image.gt_boxes.tensor.new_zeros", "gt_classes.numel", "targets_per_image.get_fields", "trg_name.startswith", "proposals_per_image.set", "proposals_per_image.has", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.proposal_utils.add_ground_truth_to_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads._sample_proposals"], ["", "@", "torch", ".", "no_grad", "(", ")", "\n", "def", "label_and_sample_proposals", "(", "self", ",", "proposals", ",", "targets", ")", ":", "\n", "        ", "\"\"\"\n        Prepare some proposals to be used to train the ROI heads.\n        It performs box matching between `proposals` and `targets`, and assigns\n        training labels to the proposals.\n        It returns ``self.batch_size_per_image`` random samples from proposals and groundtruth\n        boxes, with a fraction of positives that is no larger than\n        ``self.positive_sample_fraction``.\n\n        Args:\n            See :meth:`ROIHeads.forward`\n\n        Returns:\n            list[Instances]:\n                length `N` list of `Instances`s containing the proposals\n                sampled for training. Each `Instances` has the following fields:\n\n                - proposal_boxes: the proposal boxes\n                - gt_boxes: the ground-truth box that the proposal is assigned to\n                  (this is only meaningful if the proposal has a label > 0; if label = 0\n                  then the ground-truth box is random)\n\n                Other fields such as \"gt_classes\", \"gt_masks\", that's included in `targets`.\n        \"\"\"", "\n", "# ywlee for using targets.gt_classes", "\n", "# in add_ground_truth_to_proposal()", "\n", "# gt_boxes = [x.gt_boxes for x in targets]", "\n", "\n", "# Augment proposals with ground-truth boxes.", "\n", "# In the case of learned proposals (e.g., RPN), when training starts", "\n", "# the proposals will be low quality due to random initialization.", "\n", "# It's possible that none of these initial", "\n", "# proposals have high enough overlap with the gt objects to be used", "\n", "# as positive examples for the second stage components (box head,", "\n", "# cls head, mask head). Adding the gt boxes to the set of proposals", "\n", "# ensures that the second stage components will have some positive", "\n", "# examples from the start of training. For RPN, this augmentation improves", "\n", "# convergence and empirically improves box AP on COCO by about 0.5", "\n", "# points (under one tested configuration).", "\n", "if", "self", ".", "proposal_append_gt", ":", "\n", "            ", "proposals", "=", "add_ground_truth_to_proposals", "(", "targets", ",", "proposals", ")", "\n", "\n", "", "proposals_with_gt", "=", "[", "]", "\n", "\n", "num_fg_samples", "=", "[", "]", "\n", "num_bg_samples", "=", "[", "]", "\n", "for", "proposals_per_image", ",", "targets_per_image", "in", "zip", "(", "proposals", ",", "targets", ")", ":", "\n", "            ", "has_gt", "=", "len", "(", "targets_per_image", ")", ">", "0", "\n", "match_quality_matrix", "=", "pairwise_iou", "(", "\n", "targets_per_image", ".", "gt_boxes", ",", "proposals_per_image", ".", "proposal_boxes", "\n", ")", "\n", "matched_idxs", ",", "matched_labels", "=", "self", ".", "proposal_matcher", "(", "\n", "match_quality_matrix", ")", "\n", "\n", "sampled_idxs", ",", "gt_classes", ",", "gt_ranks", "=", "self", ".", "_sample_proposals", "(", "\n", "matched_idxs", ",", "matched_labels", ",", "targets_per_image", ".", "gt_classes", ",", "targets_per_image", ".", "gt_ranks", "\n", ")", "\n", "\n", "# Set target attributes of the sampled proposals:", "\n", "proposals_per_image", "=", "proposals_per_image", "[", "sampled_idxs", "]", "\n", "proposals_per_image", ".", "gt_classes", "=", "gt_classes", "\n", "\n", "proposals_per_image", ".", "gt_ranks", "=", "gt_ranks", "\n", "\n", "# We index all the attributes of targets that start with \"gt_\"", "\n", "# and have not been added to proposals yet (=\"gt_classes\").", "\n", "if", "has_gt", ":", "\n", "                ", "sampled_targets", "=", "matched_idxs", "[", "sampled_idxs", "]", "\n", "# NOTE: here the indexing waste some compute, because heads", "\n", "# like masks, keypoints, etc, will filter the proposals again,", "\n", "# (by foreground/background, or number of keypoints in the image, etc)", "\n", "# so we essentially index the data twice.", "\n", "for", "(", "trg_name", ",", "trg_value", ")", "in", "targets_per_image", ".", "get_fields", "(", ")", ".", "items", "(", ")", ":", "\n", "                    ", "if", "trg_name", ".", "startswith", "(", "\"gt_\"", ")", "and", "not", "proposals_per_image", ".", "has", "(", "trg_name", ")", ":", "\n", "                        ", "proposals_per_image", ".", "set", "(", "\n", "trg_name", ",", "trg_value", "[", "sampled_targets", "]", ")", "\n", "", "", "", "else", ":", "\n", "                ", "gt_boxes", "=", "Boxes", "(", "\n", "targets_per_image", ".", "gt_boxes", ".", "tensor", ".", "new_zeros", "(", "\n", "(", "len", "(", "sampled_idxs", ")", ",", "4", ")", ")", "\n", ")", "\n", "proposals_per_image", ".", "gt_boxes", "=", "gt_boxes", "\n", "\n", "", "num_bg_samples", ".", "append", "(", "\n", "(", "gt_classes", "==", "self", ".", "num_classes", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ")", "\n", "num_fg_samples", ".", "append", "(", "gt_classes", ".", "numel", "(", ")", "-", "num_bg_samples", "[", "-", "1", "]", ")", "\n", "proposals_with_gt", ".", "append", "(", "proposals_per_image", ")", "\n", "\n", "# Log the number of fg/bg samples that are selected for training ROI heads", "\n", "# storage = get_event_storage()", "\n", "# storage.put_scalar(\"roi_head/num_fg_samples\", np.mean(num_fg_samples))", "\n", "# storage.put_scalar(\"roi_head/num_bg_samples\", np.mean(num_bg_samples))", "\n", "\n", "", "return", "proposals_with_gt", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads.forward": [[277, 306], ["NotImplementedError"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "proposals", ",", "targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            images (ImageList):\n            features (dict[str: Tensor]): input data as a mapping from feature\n                map name to tensor. Axis 0 represents the number of images `N` in\n                the input data; axes 1-3 are channels, height, and width, which may\n                vary between feature maps (e.g., if a feature pyramid is used).\n            proposals (list[Instances]): length `N` list of `Instances`s. The i-th\n                `Instances` contains object proposals for the i-th input image,\n                with fields \"proposal_boxes\" and \"objectness_logits\".\n            targets (list[Instances], optional): length `N` list of `Instances`s. The i-th\n                `Instances` contains the ground-truth per-instance annotations\n                for the i-th input image.  Specify `targets` during training only.\n                It may have the following fields:\n\n                - gt_boxes: the bounding box of each instance.\n                - gt_classes: the label for each instance with a category ranging in [0, #class].\n                - gt_masks: PolygonMasks or BitMasks, the ground-truth masks of each instance.\n                - gt_keypoints: NxKx3, the groud-truth keypoints for each instance.\n\n        Returns:\n            results (list[Instances]): length `N` list of `Instances`s containing the\n            detected instances. Returned during inference only; may be [] during training.\n\n            losses (dict[str->Tensor]):\n            mapping from a named loss to a tensor storing the loss. Used during training only.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads.__init__": [[321, 331], ["center_heads.ROIHeads.__init__", "center_heads.CenterROIHeads._init_mask_head", "center_heads.CenterROIHeads._init_mask_iou_head", "center_heads.CenterROIHeads._init_keypoint_head", "center_heads.CenterROIHeads._init_sor_head"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_mask_head", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_mask_iou_head", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_keypoint_head", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_sor_head"], ["def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "CenterROIHeads", ",", "self", ")", ".", "__init__", "(", "cfg", ",", "input_shape", ")", "\n", "self", ".", "_init_mask_head", "(", "cfg", ")", "\n", "self", ".", "_init_mask_iou_head", "(", "cfg", ")", "\n", "self", ".", "_init_keypoint_head", "(", "cfg", ",", "input_shape", ")", "\n", "self", ".", "_init_sor_head", "(", "cfg", ")", "\n", "self", ".", "use_pos", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "USE_POS", "\n", "if", "self", ".", "use_pos", ":", "\n", "            ", "self", ".", "img_width", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_WIDTH", "\n", "self", ".", "img_height", "=", "cfg", ".", "MODEL", ".", "SOR", ".", "TRANSFORMER", ".", "IMG_HEIGHT", "\n", "# self.det_weights = cfg.MODEL.DET_WEIGHTS", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_mask_head": [[333, 359], ["tuple", "pooler.ROIPooler", "mask_head.build_mask_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.build_mask_head"], ["", "", "def", "_init_mask_head", "(", "self", ",", "cfg", ")", ":", "\n", "# fmt: off", "\n", "        ", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "if", "not", "self", ".", "mask_on", ":", "\n", "            ", "return", "\n", "", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "\n", "1.0", "/", "self", ".", "feature_strides", "[", "k", "]", "for", "k", "in", "self", ".", "in_features", ")", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_TYPE", "\n", "assign_crit", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "ASSIGN_CRITERION", "\n", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "self", ".", "feature_channels", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "[", "0", "]", "\n", "\n", "self", ".", "mask_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", "assign_crit", "=", "assign_crit", ",", "\n", ")", "\n", "self", ".", "mask_head", "=", "build_mask_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "\n", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_sor_head": [[361, 367], ["sor_heads.build_sor_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.build_sor_head"], ["", "def", "_init_sor_head", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "self", ".", "sor_head", "=", "build_sor_head", "(", "\n", "cfg", ",", "\n", "ShapeSpec", "(", "channels", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", ",", "\n", "width", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", ",", "\n", "height", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_mask_iou_head": [[370, 384], ["maskiou_head.build_maskiou_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.build_maskiou_head"], ["", "def", "_init_mask_iou_head", "(", "self", ",", "cfg", ")", ":", "\n", "# fmt: off", "\n", "        ", "self", ".", "maskiou_on", "=", "cfg", ".", "MODEL", ".", "MASKIOU_ON", "\n", "if", "not", "self", ".", "maskiou_on", ":", "\n", "            ", "return", "\n", "", "in_channels", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "CONV_DIM", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_MASK_HEAD", ".", "POOLER_RESOLUTION", "\n", "self", ".", "maskiou_weight", "=", "cfg", ".", "MODEL", ".", "MASKIOU_LOSS_WEIGHT", "\n", "\n", "# fmt : on", "\n", "\n", "self", ".", "maskiou_head", "=", "build_maskiou_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "\n", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._init_keypoint_head": [[386, 411], ["tuple", "pooler.ROIPooler", "keypoint_head.build_keypoint_head", "detectron2.layers.ShapeSpec"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.keypoint_head.build_keypoint_head"], ["", "def", "_init_keypoint_head", "(", "self", ",", "cfg", ",", "input_shape", ")", ":", "\n", "# fmt: off", "\n", "        ", "self", ".", "keypoint_on", "=", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", "\n", "if", "not", "self", ".", "keypoint_on", ":", "\n", "            ", "return", "\n", "", "self", ".", "kp_in_features", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "IN_FEATURES", "\n", "pooler_resolution", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_RESOLUTION", "\n", "pooler_scales", "=", "tuple", "(", "1.0", "/", "input_shape", "[", "k", "]", ".", "stride", "for", "k", "in", "self", ".", "kp_in_features", ")", "# noqa", "\n", "sampling_ratio", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_SAMPLING_RATIO", "\n", "pooler_type", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "POOLER_TYPE", "\n", "assign_crit", "=", "cfg", ".", "MODEL", ".", "ROI_KEYPOINT_HEAD", ".", "ASSIGN_CRITERION", "\n", "# fmt: on", "\n", "\n", "in_channels", "=", "[", "input_shape", "[", "f", "]", ".", "channels", "for", "f", "in", "self", ".", "kp_in_features", "]", "[", "0", "]", "\n", "\n", "self", ".", "keypoint_pooler", "=", "ROIPooler", "(", "\n", "output_size", "=", "pooler_resolution", ",", "\n", "scales", "=", "pooler_scales", ",", "\n", "sampling_ratio", "=", "sampling_ratio", ",", "\n", "pooler_type", "=", "pooler_type", ",", "\n", "assign_crit", "=", "assign_crit", ",", "\n", ")", "\n", "self", ".", "keypoint_head", "=", "build_keypoint_head", "(", "\n", "cfg", ",", "ShapeSpec", "(", "channels", "=", "in_channels", ",", "\n", "width", "=", "pooler_resolution", ",", "height", "=", "pooler_resolution", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads.forward": [[413, 460], ["center_heads.CenterROIHeads.label_and_sample_proposals", "center_heads.CenterROIHeads.update", "center_heads.CenterROIHeads.forward_with_given_boxes", "center_heads.CenterROIHeads.update", "center_heads.CenterROIHeads._forward_keypoint", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_maskiou", "center_heads.CenterROIHeads.update", "center_heads.CenterROIHeads.update", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_sor", "center_heads.CenterROIHeads._forward_sor"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.ROIHeads.label_and_sample_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads.forward_with_given_boxes", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_keypoint", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_maskiou", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor"], ["", "def", "forward", "(", "\n", "self", ",", "\n", "images", ":", "ImageList", ",", "\n", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "\n", "proposals", ":", "List", "[", "Instances", "]", ",", "\n", "targets", ":", "Optional", "[", "List", "[", "Instances", "]", "]", "=", "None", ",", "\n", ")", "->", "Tuple", "[", "List", "[", "Instances", "]", ",", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", "]", ":", "\n", "        ", "\"\"\"\n        See :class:`ROIHeads.forward`.\n        \"\"\"", "\n", "del", "images", "\n", "if", "self", ".", "training", ":", "\n", "            ", "proposals", "=", "self", ".", "label_and_sample_proposals", "(", "proposals", ",", "targets", ")", "\n", "", "del", "targets", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "if", "self", ".", "maskiou_on", ":", "\n", "                ", "if", "self", ".", "use_pos", ":", "\n", "                    ", "losses", ",", "mask_features", ",", "selected_mask", ",", "labels", ",", "maskiou_targets", ",", "pos_proposals", ",", "pos", "=", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", "\n", "", "else", ":", "\n", "                    ", "losses", ",", "mask_features", ",", "selected_mask", ",", "labels", ",", "maskiou_targets", ",", "pos_proposals", "=", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", "\n", "\n", "# TODO: add sor branch in this place", "\n", "# input: mask_features, pos_proposals", "\n", "# output: {rank_loss: val}", "\n", "", "losses", ".", "update", "(", "self", ".", "_forward_maskiou", "(", "\n", "mask_features", ",", "proposals", ",", "selected_mask", ",", "labels", ",", "maskiou_targets", ")", ")", "\n", "# for k, v in losses.items():", "\n", "#     losses[k] = v * self.det_weights", "\n", "\n", "if", "self", ".", "use_pos", ":", "\n", "                    ", "losses", ".", "update", "(", "self", ".", "_forward_sor", "(", "mask_features", ",", "pos_proposals", ",", "selected_mask", ",", "pos", "=", "pos", ")", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "losses", ".", "update", "(", "self", ".", "_forward_sor", "(", "mask_features", ",", "pos_proposals", ",", "selected_mask", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "use_pos", ":", "\n", "                    ", "losses", ",", "pos", "=", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", "\n", "", "else", ":", "\n", "                    ", "losses", "=", "self", ".", "_forward_mask", "(", "features", ",", "proposals", ")", "\n", "", "", "losses", ".", "update", "(", "self", ".", "_forward_keypoint", "(", "features", ",", "proposals", ")", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "# During inference cascaded prediction is used: the mask and keypoints heads are only", "\n", "# applied to the top scoring box detections.", "\n", "            ", "pred_instances", "=", "self", ".", "forward_with_given_boxes", "(", "features", ",", "proposals", ")", "\n", "return", "pred_instances", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads.forward_with_given_boxes": [[461, 500], ["center_heads.CenterROIHeads._forward_keypoint", "instances[].has", "instances[].has", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_maskiou", "center_heads.CenterROIHeads._forward_sor", "center_heads.CenterROIHeads._forward_mask", "center_heads.CenterROIHeads._forward_maskiou", "center_heads.CenterROIHeads._forward_sor"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_keypoint", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_maskiou", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_maskiou", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor"], ["", "", "def", "forward_with_given_boxes", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "List", "[", "Instances", "]", ":", "\n", "        ", "\"\"\"\n        Use the given boxes in `instances` to produce other (non-box) per-ROI outputs.\n\n        This is useful for downstream tasks where a box is known, but need to obtain\n        other attributes (outputs of other heads).\n        Test-time augmentation also uses this.\n\n        Args:\n            features: same as in `forward()`\n            instances (list[Instances]): instances to predict other outputs. Expect the keys\n                \"pred_boxes\" and \"pred_classes\" to exist.\n\n        Returns:\n            instances (list[Instances]):\n                the same `Instances` objects, with extra\n                fields such as `pred_masks` or `pred_keypoints`.\n        \"\"\"", "\n", "assert", "not", "self", ".", "training", "\n", "assert", "instances", "[", "0", "]", ".", "has", "(", "\n", "\"pred_boxes\"", ")", "and", "instances", "[", "0", "]", ".", "has", "(", "\"pred_classes\"", ")", "\n", "\n", "if", "self", ".", "maskiou_on", ":", "\n", "            ", "if", "self", ".", "use_pos", ":", "\n", "                ", "instances", ",", "mask_features", ",", "pos", "=", "self", ".", "_forward_mask", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_maskiou", "(", "mask_features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_sor", "(", "mask_features", ",", "instances", ",", "pos", "=", "pos", ")", "\n", "", "else", ":", "\n", "                ", "instances", ",", "mask_features", "=", "self", ".", "_forward_mask", "(", "features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_maskiou", "(", "mask_features", ",", "instances", ")", "\n", "instances", "=", "self", ".", "_forward_sor", "(", "mask_features", ",", "instances", ")", "\n", "", "", "else", ":", "\n", "            ", "instances", "=", "self", ".", "_forward_mask", "(", "features", ",", "instances", ")", "\n", "\n", "", "instances", "=", "self", ".", "_forward_keypoint", "(", "features", ",", "instances", ")", "\n", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_mask": [[501, 585], ["center_heads.select_foreground_proposals", "center_heads.CenterROIHeads.mask_pooler", "center_heads.CenterROIHeads.mask_head", "center_heads.CenterROIHeads.mask_pooler", "center_heads.CenterROIHeads.mask_head", "mask_head.mask_rcnn_inference", "torch.arange().reshape", "torch.arange().reshape", "y.repeat().cuda.repeat().cuda.repeat().cuda", "x.repeat().cuda.repeat().cuda.repeat().cuda", "features_.append", "mask_head.mask_rcnn_loss", "torch.cat", "torch.arange", "torch.arange", "y.repeat().cuda.repeat().cuda.repeat", "x.repeat().cuda.repeat().cuda.repeat", "mask_head.mask_rcnn_loss", "mask_head.mask_rcnn_loss"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_inference", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_loss", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_loss", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.mask_head.mask_rcnn_loss"], ["", "def", "_forward_mask", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_masks\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "mask_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "if", "self", ".", "use_pos", ":", "\n", "            ", "features_", "=", "[", "]", "\n", "for", "f", "in", "self", ".", "in_features", ":", "\n", "                ", "stride", "=", "self", ".", "feature_strides", "[", "f", "]", "\n", "y", "=", "torch", ".", "arange", "(", "stride", "/", "2", ",", "self", ".", "img_height", ",", "stride", ")", ".", "reshape", "(", "1", ",", "1", ",", "-", "1", ",", "1", ")", "\n", "x", "=", "torch", ".", "arange", "(", "stride", "/", "2", ",", "self", ".", "img_width", ",", "stride", ")", ".", "reshape", "(", "1", ",", "1", ",", "1", ",", "-", "1", ")", "\n", "feature", "=", "features", "[", "f", "]", "\n", "# norm", "\n", "y", "/=", "self", ".", "img_height", "\n", "x", "/=", "self", ".", "img_width", "\n", "# repeat", "\n", "y", "=", "y", ".", "repeat", "(", "feature", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "self", ".", "img_width", "//", "stride", ")", ".", "cuda", "(", ")", "\n", "x", "=", "x", ".", "repeat", "(", "feature", ".", "shape", "[", "0", "]", ",", "1", ",", "self", ".", "img_height", "//", "stride", ",", "1", ")", ".", "cuda", "(", ")", "\n", "features_", ".", "append", "(", "torch", ".", "cat", "(", "(", "feature", ",", "y", ",", "x", ")", ",", "dim", "=", "1", ")", ")", "\n", "", "features", "=", "features_", "\n", "\n", "", "else", ":", "\n", "            ", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "# The loss is only defined on positive proposals.", "\n", "            ", "proposals", ",", "_", "=", "select_foreground_proposals", "(", "\n", "instances", ",", "self", ".", "num_classes", ")", "\n", "# proposal_boxes = [x.proposal_boxes for x in proposals]", "\n", "mask_features", "=", "self", ".", "mask_pooler", "(", "\n", "features", ",", "proposals", ",", "self", ".", "training", ")", "\n", "if", "self", ".", "use_pos", ":", "\n", "                ", "pos", "=", "mask_features", "[", ":", ",", "-", "2", ":", ",", ":", ",", ":", "]", "\n", "mask_features", "=", "mask_features", "[", ":", ",", ":", "-", "2", ",", ":", ",", ":", "]", "\n", "\n", "", "mask_logits", "=", "self", ".", "mask_head", "(", "mask_features", ")", "\n", "if", "self", ".", "maskiou_on", ":", "\n", "                ", "loss", ",", "selected_mask", ",", "labels", ",", "maskiou_targets", "=", "mask_rcnn_loss", "(", "\n", "mask_logits", ",", "proposals", ",", "self", ".", "maskiou_on", ")", "\n", "if", "self", ".", "use_pos", ":", "\n", "                    ", "return", "{", "\"loss_mask\"", ":", "loss", "}", ",", "mask_features", ",", "selected_mask", ",", "labels", ",", "maskiou_targets", ",", "proposals", ",", "pos", "\n", "", "else", ":", "\n", "                    ", "return", "{", "\"loss_mask\"", ":", "loss", "}", ",", "mask_features", ",", "selected_mask", ",", "labels", ",", "maskiou_targets", ",", "proposals", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "use_pos", ":", "\n", "                    ", "return", "{", "\"loss_mask\"", ":", "mask_rcnn_loss", "(", "mask_logits", ",", "proposals", ",", "self", ".", "maskiou_on", ")", "}", ",", "pos", "\n", "", "else", ":", "\n", "                    ", "return", "{", "\"loss_mask\"", ":", "mask_rcnn_loss", "(", "mask_logits", ",", "proposals", ",", "self", ".", "maskiou_on", ")", "}", "\n", "", "", "", "else", ":", "\n", "# pred_boxes = [x.pred_boxes for x in instances]", "\n", "            ", "mask_features", "=", "self", ".", "mask_pooler", "(", "features", ",", "instances", ")", "\n", "if", "self", ".", "use_pos", ":", "\n", "                ", "pos", "=", "mask_features", "[", ":", ",", "-", "2", ":", ",", ":", ",", ":", "]", "\n", "mask_features", "=", "mask_features", "[", ":", ",", ":", "-", "2", ",", ":", ",", ":", "]", "\n", "", "mask_logits", "=", "self", ".", "mask_head", "(", "mask_features", ")", "\n", "mask_rcnn_inference", "(", "mask_logits", ",", "instances", ")", "\n", "\n", "\n", "\n", "if", "self", ".", "maskiou_on", ":", "\n", "                ", "if", "self", ".", "use_pos", ":", "\n", "                    ", "return", "instances", ",", "mask_features", ",", "pos", "\n", "", "else", ":", "\n", "                    ", "return", "instances", ",", "mask_features", "\n", "", "", "else", ":", "\n", "                ", "if", "self", ".", "use_pos", ":", "\n", "                    ", "return", "instances", ",", "pos", "\n", "", "else", ":", "\n", "                    ", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_maskiou": [[586, 612], ["center_heads.CenterROIHeads.maskiou_head", "torch.cat", "center_heads.CenterROIHeads.maskiou_head", "maskiou_head.mask_iou_inference", "maskiou_head.mask_iou_loss"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.mask_iou_inference", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.maskiou_head.mask_iou_loss"], ["", "", "", "", "def", "_forward_maskiou", "(", "self", ",", "mask_features", ",", "instances", ",", "selected_mask", "=", "None", ",", "labels", "=", "None", ",", "maskiou_targets", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask iou prediction branch.\n        Args:\n            features (list[Tensor]): #level input features for mask prediction\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n        Returns:\n            In training, a dict of losses.\n            In inference, calibrate instances' scores.\n        \"\"\"", "\n", "if", "not", "self", ".", "maskiou_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "if", "self", ".", "training", ":", "\n", "            ", "pred_maskiou", "=", "self", ".", "maskiou_head", "(", "mask_features", ",", "selected_mask", ")", "\n", "return", "{", "\"loss_maskiou\"", ":", "mask_iou_loss", "(", "labels", ",", "pred_maskiou", ",", "maskiou_targets", ",", "self", ".", "maskiou_weight", ")", "}", "\n", "\n", "", "else", ":", "\n", "            ", "selected_mask", "=", "torch", ".", "cat", "(", "[", "i", ".", "pred_masks", "for", "i", "in", "instances", "]", ",", "0", ")", "\n", "if", "selected_mask", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "return", "instances", "\n", "", "pred_maskiou", "=", "self", ".", "maskiou_head", "(", "mask_features", ",", "selected_mask", ")", "\n", "mask_iou_inference", "(", "instances", ",", "pred_maskiou", ")", "\n", "return", "instances", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_keypoint": [[613, 649], ["center_heads.select_foreground_proposals", "center_heads.select_proposals_with_visible_keypoints", "center_heads.CenterROIHeads.keypoint_pooler", "center_heads.CenterROIHeads.keypoint_head", "center_heads.CenterROIHeads.keypoint_pooler", "center_heads.CenterROIHeads.keypoint_head"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_foreground_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_proposals_with_visible_keypoints"], ["", "", "def", "_forward_keypoint", "(", "\n", "self", ",", "features", ":", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "instances", ":", "List", "[", "Instances", "]", "\n", ")", "->", "Union", "[", "Dict", "[", "str", ",", "torch", ".", "Tensor", "]", ",", "List", "[", "Instances", "]", "]", ":", "\n", "        ", "\"\"\"\n        Forward logic of the keypoint prediction branch.\n\n        Args:\n            features (dict[str, Tensor]): mapping from feature map names to tensor.\n                Same as in :meth:`ROIHeads.forward`.\n            instances (list[Instances]): the per-image instances to train/predict keypoints.\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n\n        Returns:\n            In training, a dict of losses.\n            In inference, update `instances` with new fields \"pred_keypoints\" and return it.\n        \"\"\"", "\n", "if", "not", "self", ".", "keypoint_on", ":", "\n", "            ", "return", "{", "}", "if", "self", ".", "training", "else", "instances", "\n", "\n", "", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "kp_in_features", "]", "\n", "\n", "if", "self", ".", "training", ":", "\n", "# The loss is defined on positive proposals with at >=1 visible keypoints.", "\n", "            ", "proposals", ",", "_", "=", "select_foreground_proposals", "(", "\n", "instances", ",", "self", ".", "num_classes", ")", "\n", "proposals", "=", "select_proposals_with_visible_keypoints", "(", "proposals", ")", "\n", "# proposal_boxes = [x.proposal_boxes for x in proposals]", "\n", "\n", "keypoint_features", "=", "self", ".", "keypoint_pooler", "(", "\n", "features", ",", "proposals", ",", "self", ".", "training", ")", "\n", "return", "self", ".", "keypoint_head", "(", "keypoint_features", ",", "proposals", ")", "\n", "", "else", ":", "\n", "# pred_boxes = [x.pred_boxes for x in instances]", "\n", "            ", "keypoint_features", "=", "self", ".", "keypoint_pooler", "(", "features", ",", "instances", ")", "\n", "return", "self", ".", "keypoint_head", "(", "keypoint_features", ",", "instances", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.CenterROIHeads._forward_sor": [[650, 698], ["center_heads.CenterROIHeads.sor_head", "torch.cat", "center_heads.CenterROIHeads.sor_head", "F.softmax", "deepcopy", "range", "zip", "sor_heads.sor_loss", "print", "pred_ranks[].argmax", "torch.Tensor", "float"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.sor_heads.sor_loss"], ["", "", "def", "_forward_sor", "(", "self", ",", "mask_features", ",", "instances", ",", "selected_mask", "=", "None", ",", "pos", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Forward logic of the mask iou prediction branch.\n        Args:\n            features (list[Tensor]): #level input features for mask prediction\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n            selected_mask (list[Tensor]) mask prediction resolution x resolution x 1\n        Returns:\n            In training, a dict of losses.\n            In inference, instances' rank scores.\n        \"\"\"", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "pred_sor", "=", "self", ".", "sor_head", "(", "mask_features", ",", "selected_mask", ",", "instances", "=", "instances", ",", "pos", "=", "pos", ")", "\n", "return", "{", "\"sor_loss\"", ":", "sor_loss", "(", "pred_sor", ",", "instances", ")", "}", "\n", "", "else", ":", "\n", "            ", "selected_mask", "=", "torch", ".", "cat", "(", "[", "i", ".", "pred_masks", "for", "i", "in", "instances", "]", ",", "0", ")", "\n", "if", "selected_mask", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "                ", "print", "(", "'selected_mask.shape[0] == 0'", ")", "\n", "return", "instances", "\n", "# print(self.sor_head(mask_features, selected_mask).shape)", "\n", "\n", "# pred_sor = [self.sor_head(mask_features, selected_mask, instances=None, pos=pos)]", "\n", "", "pred_ranks", "=", "self", ".", "sor_head", "(", "mask_features", ",", "selected_mask", ",", "instances", "=", "instances", ",", "pos", "=", "pos", ")", "\n", "import", "torch", ".", "nn", ".", "functional", "as", "F", "\n", "pred_ranks", "=", "F", ".", "softmax", "(", "pred_ranks", ",", "dim", "=", "0", ")", "\n", "\n", "ranks", "=", "pred_ranks", ".", "shape", "[", "0", "]", "*", "[", "-", "1", "]", "\n", "from", "copy", "import", "deepcopy", "\n", "tmp", "=", "deepcopy", "(", "pred_ranks", ")", "\n", "for", "r", "in", "range", "(", "4", ",", "-", "1", ",", "-", "1", ")", ":", "\n", "                ", "idx", "=", "pred_ranks", "[", ":", ",", "r", "]", ".", "argmax", "(", ")", "\n", "if", "pred_ranks", "[", "idx", ",", "r", "]", ">", "0.1", ":", "\n", "                    ", "ranks", "[", "idx", "]", "=", "r", "\n", "pred_ranks", "[", "idx", ",", ":", "]", "=", "-", "float", "(", "'inf'", ")", "\n", "# if 4 not in ranks and len(ranks) >=5 :", "\n", "# with open('tmp2.pkl', 'wb') as f:", "\n", "#     import pickle", "\n", "#     pickle.dump(tmp, f)", "\n", "#     exit(0)", "\n", "", "", "pred_sor", "=", "[", "torch", ".", "Tensor", "(", "ranks", ")", "]", "\n", "\n", "\n", "for", "rank", ",", "box", "in", "zip", "(", "pred_sor", ",", "instances", ")", ":", "\n", "                ", "box", ".", "pred_ranks", "=", "rank", "\n", "", "return", "instances", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_foreground_proposals": [[29, 57], ["isinstance", "isinstance", "proposals[].has", "fg_selection_mask.nonzero().squeeze", "fg_proposals.append", "fg_selection_masks.append", "fg_selection_mask.nonzero"], "function", ["None"], ["def", "select_foreground_proposals", "(", "proposals", ",", "bg_label", ")", ":", "\n", "    ", "\"\"\"\n    Given a list of N Instances (for N images), each containing a `gt_classes` field,\n    return a list of Instances that contain only instances with `gt_classes != -1 &&\n    gt_classes != bg_label`.\n\n    Args:\n        proposals (list[Instances]): A list of N Instances, where N is the number of\n            images in the batch.\n        bg_label: label index of background class.\n\n    Returns:\n        list[Instances]: N Instances, each contains only the selected foreground instances.\n        list[Tensor]: N boolean vector, correspond to the selection mask of\n            each Instances object. True for selected instances.\n    \"\"\"", "\n", "assert", "isinstance", "(", "proposals", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "proposals", "[", "0", "]", ",", "Instances", ")", "\n", "assert", "proposals", "[", "0", "]", ".", "has", "(", "\"gt_classes\"", ")", "\n", "fg_proposals", "=", "[", "]", "\n", "fg_selection_masks", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "        ", "gt_classes", "=", "proposals_per_image", ".", "gt_classes", "\n", "fg_selection_mask", "=", "(", "gt_classes", "!=", "-", "1", ")", "&", "(", "gt_classes", "!=", "bg_label", ")", "\n", "fg_idxs", "=", "fg_selection_mask", ".", "nonzero", "(", ")", ".", "squeeze", "(", "1", ")", "\n", "fg_proposals", ".", "append", "(", "proposals_per_image", "[", "fg_idxs", "]", ")", "\n", "fg_selection_masks", ".", "append", "(", "fg_selection_mask", ")", "\n", "", "return", "fg_proposals", ",", "fg_selection_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.center_heads.select_proposals_with_visible_keypoints": [[59, 103], ["proposals_per_image.proposal_boxes.tensor.unsqueeze", "torch.nonzero().squeeze", "all_num_fg.append", "ret.append", "len", "ret.append", "torch.nonzero().squeeze.numel", "torch.nonzero"], "function", ["None"], ["", "def", "select_proposals_with_visible_keypoints", "(", "proposals", ":", "List", "[", "Instances", "]", ")", "->", "List", "[", "Instances", "]", ":", "\n", "    ", "\"\"\"\n    Args:\n        proposals (list[Instances]): a list of N Instances, where N is the\n            number of images.\n\n    Returns:\n        proposals: only contains proposals with at least one visible keypoint.\n\n    Note that this is still slightly different from Detectron.\n    In Detectron, proposals for training keypoint head are re-sampled from\n    all the proposals with IOU>threshold & >=1 visible keypoint.\n\n    Here, the proposals are first sampled from all proposals with\n    IOU>threshold, then proposals with no visible keypoint are filtered out.\n    This strategy seems to make no difference on Detectron and is easier to implement.\n    \"\"\"", "\n", "ret", "=", "[", "]", "\n", "all_num_fg", "=", "[", "]", "\n", "for", "proposals_per_image", "in", "proposals", ":", "\n", "# If empty/unannotated image (hard negatives), skip filtering for train", "\n", "        ", "if", "len", "(", "proposals_per_image", ")", "==", "0", ":", "\n", "            ", "ret", ".", "append", "(", "proposals_per_image", ")", "\n", "continue", "\n", "", "gt_keypoints", "=", "proposals_per_image", ".", "gt_keypoints", ".", "tensor", "\n", "# #fg x K x 3", "\n", "vis_mask", "=", "gt_keypoints", "[", ":", ",", ":", ",", "2", "]", ">=", "1", "\n", "xs", ",", "ys", "=", "gt_keypoints", "[", ":", ",", ":", ",", "0", "]", ",", "gt_keypoints", "[", ":", ",", ":", ",", "1", "]", "\n", "proposal_boxes", "=", "proposals_per_image", ".", "proposal_boxes", ".", "tensor", ".", "unsqueeze", "(", "\n", "dim", "=", "1", ")", "# #fg x 1 x 4", "\n", "kp_in_box", "=", "(", "\n", "(", "xs", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "0", "]", ")", "\n", "&", "(", "xs", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "2", "]", ")", "\n", "&", "(", "ys", ">=", "proposal_boxes", "[", ":", ",", ":", ",", "1", "]", ")", "\n", "&", "(", "ys", "<=", "proposal_boxes", "[", ":", ",", ":", ",", "3", "]", ")", "\n", ")", "\n", "selection", "=", "(", "kp_in_box", "&", "vis_mask", ")", ".", "any", "(", "dim", "=", "1", ")", "\n", "selection_idxs", "=", "torch", ".", "nonzero", "(", "selection", ")", ".", "squeeze", "(", "1", ")", "\n", "all_num_fg", ".", "append", "(", "selection_idxs", ".", "numel", "(", ")", ")", "\n", "ret", ".", "append", "(", "proposals_per_image", "[", "selection_idxs", "]", ")", "\n", "\n", "# storage = get_event_storage()", "\n", "# storage.put_scalar(\"keypoint_head/num_fg_samples\", np.mean(all_num_fg))", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.ROIPooler.__init__": [[139, 230], ["torch.nn.Module.__init__", "isinstance", "int", "int", "len", "isinstance", "isinstance", "torch.nn.ModuleList", "math.log2", "math.log2", "math.isclose", "math.isclose", "len", "len", "torch.nn.ModuleList", "int", "int", "detectron2.layers.ROIAlign", "torch.nn.ModuleList", "detectron2.layers.ROIAlign", "torch.nn.ModuleList", "ValueError", "torchvision.ops.RoIPool", "detectron2.layers.ROIAlignRotated"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "output_size", ",", "\n", "scales", ",", "\n", "sampling_ratio", ",", "\n", "pooler_type", ",", "\n", "canonical_box_size", "=", "224", ",", "\n", "canonical_level", "=", "4", ",", "\n", "assign_crit", "=", "\"area\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            output_size (int, tuple[int] or list[int]): output size of the pooled region,\n                e.g., 14 x 14. If tuple or list is given, the length must be 2.\n            scales (list[float]): The scale for each low-level pooling op relative to\n                the input image. For a feature map with stride s relative to the input\n                image, scale is defined as a 1 / s. The stride must be power of 2.\n                When there are multiple scales, they must form a pyramid, i.e. they must be\n                a monotically decreasing geometric sequence with a factor of 1/2.\n            sampling_ratio (int): The `sampling_ratio` parameter for the ROIAlign op.\n            pooler_type (string): Name of the type of pooling operation that should be applied.\n                For instance, \"ROIPool\" or \"ROIAlignV2\".\n            canonical_box_size (int): A canonical box size in pixels (sqrt(box area)). The default\n                is heuristically defined as 224 pixels in the FPN paper (based on ImageNet\n                pre-training).\n            canonical_level (int): The feature map level index from which a canonically-sized box\n                should be placed. The default is defined as level 4 (stride=16) in the FPN paper,\n                i.e., a box of size 224x224 will be placed on the feature with stride=16.\n                The box placement for all boxes will be determined from their sizes w.r.t\n                canonical_box_size. For example, a box whose area is 4x that of a canonical box\n                should be used to pool features from feature level ``canonical_level+1``.\n\n                Note that the actual input feature maps given to this module may not have\n                sufficiently many levels for the input boxes. If the boxes are too large or too\n                small for the input feature maps, the closest level will be used.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "isinstance", "(", "output_size", ",", "int", ")", ":", "\n", "            ", "output_size", "=", "(", "output_size", ",", "output_size", ")", "\n", "", "assert", "len", "(", "output_size", ")", "==", "2", "\n", "assert", "isinstance", "(", "output_size", "[", "0", "]", ",", "int", ")", "and", "isinstance", "(", "output_size", "[", "1", "]", ",", "int", ")", "\n", "self", ".", "output_size", "=", "output_size", "\n", "\n", "if", "pooler_type", "==", "\"ROIAlign\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ",", "aligned", "=", "False", "\n", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIAlignV2\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlign", "(", "\n", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ",", "aligned", "=", "True", "\n", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIPool\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "RoIPool", "(", "output_size", ",", "spatial_scale", "=", "scale", ")", "for", "scale", "in", "scales", "\n", ")", "\n", "", "elif", "pooler_type", "==", "\"ROIAlignRotated\"", ":", "\n", "            ", "self", ".", "level_poolers", "=", "nn", ".", "ModuleList", "(", "\n", "ROIAlignRotated", "(", "output_size", ",", "spatial_scale", "=", "scale", ",", "sampling_ratio", "=", "sampling_ratio", ")", "\n", "for", "scale", "in", "scales", "\n", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown pooler type: {}\"", ".", "format", "(", "pooler_type", ")", ")", "\n", "\n", "# Map scale (defined as 1 / stride) to its feature map level under the", "\n", "# assumption that stride is a power of 2.", "\n", "", "min_level", "=", "-", "math", ".", "log2", "(", "scales", "[", "0", "]", ")", "\n", "max_level", "=", "-", "math", ".", "log2", "(", "scales", "[", "-", "1", "]", ")", "\n", "assert", "math", ".", "isclose", "(", "min_level", ",", "int", "(", "min_level", ")", ")", "and", "math", ".", "isclose", "(", "\n", "max_level", ",", "int", "(", "max_level", ")", "\n", ")", ",", "\"Featuremap stride is not power of 2!\"", "\n", "self", ".", "min_level", "=", "int", "(", "min_level", ")", "\n", "self", ".", "max_level", "=", "int", "(", "max_level", ")", "\n", "assert", "(", "\n", "len", "(", "scales", ")", "==", "self", ".", "max_level", "-", "self", ".", "min_level", "+", "1", "\n", ")", ",", "\"[ROIPooler] Sizes of input featuremaps do not form a pyramid!\"", "\n", "assert", "0", "<", "self", ".", "min_level", "and", "self", ".", "min_level", "<=", "self", ".", "max_level", "\n", "if", "len", "(", "scales", ")", ">", "1", ":", "\n", "# When there is only one feature map, canonical_level is redundant and we should not", "\n", "# require it to be a sensible value. Therefore we skip this assertion", "\n", "            ", "assert", "self", ".", "min_level", "<=", "canonical_level", "and", "canonical_level", "<=", "self", ".", "max_level", "\n", "", "self", ".", "canonical_level", "=", "canonical_level", "\n", "assert", "canonical_box_size", ">", "0", "\n", "self", ".", "canonical_box_size", "=", "canonical_box_size", "\n", "self", ".", "assign_crit", "=", "assign_crit", "#ywlee", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.ROIPooler.forward": [[231, 297], ["len", "detectron2.modeling.poolers.convert_boxes_to_pooler_format", "len", "torch.zeros", "enumerate", "isinstance", "isinstance", "len", "len", "len", "x[].size", "x[].size", "len", "pooler.assign_boxes_to_levels_by_ratio", "detectron2.modeling.poolers.assign_boxes_to_levels", "zip", "torch.nonzero().squeeze", "pooler", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.convert_boxes_to_pooler_format", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.assign_boxes_to_levels_by_ratio", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.assign_boxes_to_levels"], ["", "def", "forward", "(", "self", ",", "x", ",", "instances", ",", "is_train", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            x (list[Tensor]): A list of feature maps of NCHW shape, with scales matching those\n                used to construct this module.\n            instances (list[Instances]): the per-image instances to train/predict masks.\n                In training, they can be the proposals.\n                In inference, they can be the predicted boxes.\n            is_train (True/False)\n\n        Returns:\n            Tensor:\n                A tensor of shape (M, C, output_size, output_size) where M is the total number of\n                boxes aggregated over all N batch images and C is the number of channels in `x`.\n        \"\"\"", "\n", "if", "is_train", ":", "\n", "            ", "box_lists", "=", "[", "x", ".", "proposal_boxes", "for", "x", "in", "instances", "]", "\n", "", "else", ":", "\n", "            ", "box_lists", "=", "[", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "\n", "", "num_level_assignments", "=", "len", "(", "self", ".", "level_poolers", ")", "\n", "\n", "assert", "isinstance", "(", "x", ",", "list", ")", "and", "isinstance", "(", "\n", "box_lists", ",", "list", "\n", ")", ",", "\"Arguments to pooler must be lists\"", "\n", "assert", "(", "\n", "len", "(", "x", ")", "==", "num_level_assignments", "\n", ")", ",", "\"unequal value, num_level_assignments={}, but x is list of {} Tensors\"", ".", "format", "(", "\n", "num_level_assignments", ",", "len", "(", "x", ")", "\n", ")", "\n", "\n", "assert", "len", "(", "box_lists", ")", "==", "x", "[", "0", "]", ".", "size", "(", "\n", "0", "\n", ")", ",", "\"unequal value, x[0] batch dim 0 is {}, but box_list has length {}\"", ".", "format", "(", "\n", "x", "[", "0", "]", ".", "size", "(", "0", ")", ",", "len", "(", "box_lists", ")", "\n", ")", "\n", "\n", "pooler_fmt_boxes", "=", "convert_boxes_to_pooler_format", "(", "box_lists", ")", "\n", "\n", "if", "num_level_assignments", "==", "1", ":", "\n", "            ", "return", "self", ".", "level_poolers", "[", "0", "]", "(", "x", "[", "0", "]", ",", "pooler_fmt_boxes", ")", "\n", "\n", "", "if", "self", ".", "assign_crit", "==", "\"ratio\"", ":", "\n", "            ", "level_assignments", "=", "assign_boxes_to_levels_by_ratio", "(", "\n", "instances", ",", "self", ".", "min_level", ",", "self", ".", "max_level", ",", "is_train", "\n", ")", "\n", "", "else", ":", "#default", "\n", "            ", "level_assignments", "=", "assign_boxes_to_levels", "(", "\n", "box_lists", ",", "self", ".", "min_level", ",", "self", ".", "max_level", ",", "self", ".", "canonical_box_size", ",", "self", ".", "canonical_level", "\n", ")", "\n", "\n", "", "num_boxes", "=", "len", "(", "pooler_fmt_boxes", ")", "\n", "num_channels", "=", "x", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "output_size", "=", "self", ".", "output_size", "[", "0", "]", "\n", "\n", "dtype", ",", "device", "=", "x", "[", "0", "]", ".", "dtype", ",", "x", "[", "0", "]", ".", "device", "\n", "output", "=", "torch", ".", "zeros", "(", "\n", "(", "num_boxes", ",", "num_channels", ",", "output_size", ",", "output_size", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", "\n", ")", "\n", "\n", "for", "level", ",", "(", "x_level", ",", "pooler", ")", "in", "enumerate", "(", "zip", "(", "x", ",", "self", ".", "level_poolers", ")", ")", ":", "\n", "            ", "inds", "=", "torch", ".", "nonzero", "(", "level_assignments", "==", "level", ")", ".", "squeeze", "(", "1", ")", "\n", "pooler_fmt_boxes_level", "=", "pooler_fmt_boxes", "[", "inds", "]", "\n", "output", "[", "inds", "]", "=", "pooler", "(", "x_level", ",", "pooler_fmt_boxes_level", ")", "\n", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler._img_area": [[14, 22], ["torch.as_tensor", "torch.zeros", "len"], "function", ["None"], ["def", "_img_area", "(", "instance", ")", ":", "\n", "\n", "    ", "device", "=", "instance", ".", "pred_classes", ".", "device", "\n", "image_size", "=", "instance", ".", "image_size", "\n", "area", "=", "torch", ".", "as_tensor", "(", "image_size", "[", "0", "]", "*", "image_size", "[", "1", "]", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "tmp", "=", "torch", ".", "zeros", "(", "(", "len", "(", "instance", ".", "pred_classes", ")", ",", "1", ")", ",", "dtype", "=", "torch", ".", "float", ",", "device", "=", "device", ")", "\n", "\n", "return", "(", "area", "+", "tmp", ")", ".", "squeeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.assign_boxes_to_levels_by_ratio": [[24, 60], ["detectron2.layers.cat", "detectron2.layers.cat", "torch.ceil", "torch.clamp", "torch.clamp.to", "boxes.area", "pooler._img_area", "torch.log2"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler._img_area"], ["", "def", "assign_boxes_to_levels_by_ratio", "(", "instances", ",", "min_level", ",", "max_level", ",", "is_train", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Map each box in `instances` to a feature map level index by adaptive ROI mapping function \n    in CenterMask paper and return the assignment\n    vector.\n\n    Args:\n        instances (list[Instances]): the per-image instances to train/predict masks.\n        min_level (int): Smallest feature map level index. The input is considered index 0,\n            the output of stage 1 is index 1, and so.\n        max_level (int): Largest feature map level index.\n\n    Returns:\n        A tensor of length M, where M is the total number of boxes aggregated over all\n            N batch images. The memory layout corresponds to the concatenation of boxes\n            from all images. Each element is the feature map index, as an offset from\n            `self.min_level`, for the corresponding box (so value i means the box is at\n            `self.min_level + i`).\n    \"\"\"", "\n", "eps", "=", "sys", ".", "float_info", ".", "epsilon", "\n", "if", "is_train", ":", "\n", "        ", "box_lists", "=", "[", "x", ".", "proposal_boxes", "for", "x", "in", "instances", "]", "\n", "", "else", ":", "\n", "        ", "box_lists", "=", "[", "x", ".", "pred_boxes", "for", "x", "in", "instances", "]", "\n", "", "box_areas", "=", "cat", "(", "[", "boxes", ".", "area", "(", ")", "for", "boxes", "in", "box_lists", "]", ")", "\n", "img_areas", "=", "cat", "(", "[", "_img_area", "(", "instance_i", ")", "for", "instance_i", "in", "instances", "]", ")", "\n", "\n", "# Eqn.(2) in the CenterMask paper", "\n", "level_assignments", "=", "torch", ".", "ceil", "(", "\n", "max_level", "-", "torch", ".", "log2", "(", "img_areas", "/", "box_areas", "+", "eps", ")", "\n", ")", "\n", "\n", "# clamp level to (min, max), in case the box size is too large or too small", "\n", "# for the available feature maps", "\n", "level_assignments", "=", "torch", ".", "clamp", "(", "level_assignments", ",", "min", "=", "min_level", ",", "max", "=", "max_level", ")", "\n", "return", "level_assignments", ".", "to", "(", "torch", ".", "int64", ")", "-", "min_level", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.assign_boxes_to_levels": [[62, 94], ["torch.sqrt", "torch.floor", "torch.clamp", "detectron2.layers.cat", "torch.clamp.to", "torch.log2", "boxes.area"], "function", ["None"], ["", "def", "assign_boxes_to_levels", "(", "box_lists", ",", "min_level", ",", "max_level", ",", "canonical_box_size", ",", "canonical_level", ")", ":", "\n", "    ", "\"\"\"\n    Map each box in `box_lists` to a feature map level index and return the assignment\n    vector.\n\n    Args:\n        box_lists (list[Boxes] | list[RotatedBoxes]): A list of N Boxes or N RotatedBoxes,\n            where N is the number of images in the batch.\n        min_level (int): Smallest feature map level index. The input is considered index 0,\n            the output of stage 1 is index 1, and so.\n        max_level (int): Largest feature map level index.\n        canonical_box_size (int): A canonical box size in pixels (sqrt(box area)).\n        canonical_level (int): The feature map level index on which a canonically-sized box\n            should be placed.\n\n    Returns:\n        A tensor of length M, where M is the total number of boxes aggregated over all\n            N batch images. The memory layout corresponds to the concatenation of boxes\n            from all images. Each element is the feature map index, as an offset from\n            `self.min_level`, for the corresponding box (so value i means the box is at\n            `self.min_level + i`).\n    \"\"\"", "\n", "eps", "=", "sys", ".", "float_info", ".", "epsilon", "\n", "box_sizes", "=", "torch", ".", "sqrt", "(", "cat", "(", "[", "boxes", ".", "area", "(", ")", "for", "boxes", "in", "box_lists", "]", ")", ")", "\n", "# Eqn.(1) in FPN paper", "\n", "level_assignments", "=", "torch", ".", "floor", "(", "\n", "canonical_level", "+", "torch", ".", "log2", "(", "box_sizes", "/", "canonical_box_size", "+", "eps", ")", "\n", ")", "\n", "# clamp level to (min, max), in case the box size is too large or too small", "\n", "# for the available feature maps", "\n", "level_assignments", "=", "torch", ".", "clamp", "(", "level_assignments", ",", "min", "=", "min_level", ",", "max", "=", "max_level", ")", "\n", "return", "level_assignments", ".", "to", "(", "torch", ".", "int64", ")", "-", "min_level", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.centermask.pooler.convert_boxes_to_pooler_format": [[96, 131], ["detectron2.layers.cat", "torch.full", "detectron2.layers.cat", "pooler.convert_boxes_to_pooler_format.fmt_box_list"], "function", ["None"], ["", "def", "convert_boxes_to_pooler_format", "(", "box_lists", ")", ":", "\n", "    ", "\"\"\"\n    Convert all boxes in `box_lists` to the low-level format used by ROI pooling ops\n    (see description under Returns).\n\n    Args:\n        box_lists (list[Boxes] | list[RotatedBoxes]):\n            A list of N Boxes or N RotatedBoxes, where N is the number of images in the batch.\n\n    Returns:\n        When input is list[Boxes]:\n            A tensor of shape (M, 5), where M is the total number of boxes aggregated over all\n            N batch images.\n            The 5 columns are (batch index, x0, y0, x1, y1), where batch index\n            is the index in [0, N) identifying which batch image the box with corners at\n            (x0, y0, x1, y1) comes from.\n        When input is list[RotatedBoxes]:\n            A tensor of shape (M, 6), where M is the total number of boxes aggregated over all\n            N batch images.\n            The 6 columns are (batch index, x_ctr, y_ctr, width, height, angle_degrees),\n            where batch index is the index in [0, N) identifying which batch image the\n            rotated box (x_ctr, y_ctr, width, height, angle_degrees) comes from.\n    \"\"\"", "\n", "\n", "def", "fmt_box_list", "(", "box_tensor", ",", "batch_index", ")", ":", "\n", "        ", "repeated_index", "=", "torch", ".", "full", "(", "\n", "(", "len", "(", "box_tensor", ")", ",", "1", ")", ",", "batch_index", ",", "dtype", "=", "box_tensor", ".", "dtype", ",", "device", "=", "box_tensor", ".", "device", "\n", ")", "\n", "return", "cat", "(", "(", "repeated_index", ",", "box_tensor", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "pooler_fmt_boxes", "=", "cat", "(", "\n", "[", "fmt_box_list", "(", "box_list", ".", "tensor", ",", "i", ")", "for", "i", ",", "box_list", "in", "enumerate", "(", "box_lists", ")", "]", ",", "dim", "=", "0", "\n", ")", "\n", "\n", "return", "pooler_fmt_boxes", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_num_gen": [[13, 15], ["sum"], "function", ["None"], ["def", "get_num_gen", "(", "gen", ")", ":", "\n", "    ", "return", "sum", "(", "1", "for", "x", "in", "gen", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.is_pruned": [[17, 23], ["None"], "function", ["None"], ["", "def", "is_pruned", "(", "layer", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "layer", ".", "mask", "\n", "return", "True", "\n", "", "except", "AttributeError", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.is_leaf": [[25, 27], ["measures.get_num_gen", "model.children"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_num_gen"], ["", "", "def", "is_leaf", "(", "model", ")", ":", "\n", "    ", "return", "get_num_gen", "(", "model", ".", "children", "(", ")", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_info": [[29, 33], ["str", "layer_str[].strip", "str.find"], "function", ["None"], ["", "def", "get_layer_info", "(", "layer", ")", ":", "\n", "    ", "layer_str", "=", "str", "(", "layer", ")", "\n", "type_name", "=", "layer_str", "[", ":", "layer_str", ".", "find", "(", "'('", ")", "]", ".", "strip", "(", ")", "\n", "return", "type_name", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param": [[35, 37], ["sum", "functools.reduce", "i.size", "model.parameters"], "function", ["None"], ["", "def", "get_layer_param", "(", "model", ")", ":", "\n", "    ", "return", "sum", "(", "[", "reduce", "(", "operator", ".", "mul", ",", "i", ".", "size", "(", ")", ",", "1", ")", "for", "i", "in", "model", ".", "parameters", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.measure_layer": [[40, 156], ["measures.get_layer_info", "int", "int", "measures.get_layer_param", "x.size", "int", "int", "measures.get_layer_param", "measures.measure_layer", "measures.measure_layer", "int", "int", "measures.get_layer_param", "x.numel", "measures.get_layer_param", "int", "int", "measures.get_layer_param", "x.size", "x.size", "x.size", "measures.get_layer_param", "x.size", "x.size", "x.size", "layer.bias.numel", "measures.get_layer_param", "x.size", "x.size", "x.size", "layer.weight.numel", "measures.get_layer_param", "x.size", "x.size", "x.size", "x.numel", "measures.measure_layer", "measures.measure_layer", "measures.get_layer_param", "x.numel", "measures.get_layer_param", "x.numel", "functools.reduce", "int", "int", "measures.get_layer_param", "TypeError", "list", "offset_conv.size", "layer.parameters", "x.size", "x.size", "x.size", "x.size"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_info", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.measure_layer", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.measure_layer", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.measure_layer", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.measure_layer", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.get_layer_param"], ["", "def", "measure_layer", "(", "layer", ",", "*", "args", ")", ":", "\n", "    ", "global", "count_ops", ",", "count_params", "\n", "\n", "for", "x", "in", "args", ":", "\n", "        ", "delta_ops", "=", "0", "\n", "delta_params", "=", "0", "\n", "multi_add", "=", "1", "\n", "type_name", "=", "get_layer_info", "(", "layer", ")", "\n", "\n", "### ops_conv", "\n", "if", "type_name", "in", "[", "'Conv2d'", "]", ":", "\n", "            ", "out_h", "=", "int", "(", "(", "x", ".", "size", "(", ")", "[", "2", "]", "+", "2", "*", "layer", ".", "padding", "[", "0", "]", "/", "layer", ".", "dilation", "[", "0", "]", "-", "layer", ".", "kernel_size", "[", "0", "]", ")", "/", "\n", "layer", ".", "stride", "[", "0", "]", "+", "1", ")", "\n", "out_w", "=", "int", "(", "(", "x", ".", "size", "(", ")", "[", "3", "]", "+", "2", "*", "layer", ".", "padding", "[", "1", "]", "/", "layer", ".", "dilation", "[", "1", "]", "-", "layer", ".", "kernel_size", "[", "1", "]", ")", "/", "\n", "layer", ".", "stride", "[", "1", "]", "+", "1", ")", "\n", "delta_ops", "=", "layer", ".", "in_channels", "*", "layer", ".", "out_channels", "*", "layer", ".", "kernel_size", "[", "0", "]", "*", "layer", ".", "kernel_size", "[", "1", "]", "*", "out_h", "*", "out_w", "/", "layer", ".", "groups", "*", "multi_add", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "", "elif", "type_name", "in", "[", "'ConvTranspose2d'", "]", ":", "\n", "            ", "_", ",", "_", ",", "in_h", ",", "in_w", "=", "x", ".", "size", "(", ")", "\n", "out_h", "=", "int", "(", "(", "in_h", "-", "1", ")", "*", "layer", ".", "stride", "[", "0", "]", "-", "2", "*", "layer", ".", "padding", "[", "0", "]", "+", "layer", ".", "kernel_size", "[", "0", "]", "+", "layer", ".", "output_padding", "[", "0", "]", ")", "\n", "out_w", "=", "int", "(", "(", "in_w", "-", "1", ")", "*", "layer", ".", "stride", "[", "1", "]", "-", "2", "*", "layer", ".", "padding", "[", "1", "]", "+", "layer", ".", "kernel_size", "[", "1", "]", "+", "layer", ".", "output_padding", "[", "1", "]", ")", "\n", "delta_ops", "=", "layer", ".", "in_channels", "*", "layer", ".", "out_channels", "*", "layer", ".", "kernel_size", "[", "0", "]", "*", "layer", ".", "kernel_size", "[", "1", "]", "*", "out_h", "*", "out_w", "/", "layer", ".", "groups", "*", "multi_add", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "### ops_learned_conv", "\n", "", "elif", "type_name", "in", "[", "'LearnedGroupConv'", "]", ":", "\n", "            ", "measure_layer", "(", "layer", ".", "relu", ",", "x", ")", "\n", "measure_layer", "(", "layer", ".", "norm", ",", "x", ")", "\n", "conv", "=", "layer", ".", "conv", "\n", "out_h", "=", "int", "(", "(", "x", ".", "size", "(", ")", "[", "2", "]", "+", "2", "*", "conv", ".", "padding", "[", "0", "]", "-", "conv", ".", "kernel_size", "[", "0", "]", ")", "/", "\n", "conv", ".", "stride", "[", "0", "]", "+", "1", ")", "\n", "out_w", "=", "int", "(", "(", "x", ".", "size", "(", ")", "[", "3", "]", "+", "2", "*", "conv", ".", "padding", "[", "1", "]", "-", "conv", ".", "kernel_size", "[", "1", "]", ")", "/", "\n", "conv", ".", "stride", "[", "1", "]", "+", "1", ")", "\n", "delta_ops", "=", "conv", ".", "in_channels", "*", "conv", ".", "out_channels", "*", "conv", ".", "kernel_size", "[", "0", "]", "*", "conv", ".", "kernel_size", "[", "1", "]", "*", "out_h", "*", "out_w", "/", "layer", ".", "condense_factor", "*", "multi_add", "\n", "delta_params", "=", "get_layer_param", "(", "conv", ")", "/", "layer", ".", "condense_factor", "\n", "\n", "### ops_nonlinearity", "\n", "", "elif", "type_name", "in", "[", "'ReLU'", ",", "'ReLU6'", "]", ":", "\n", "            ", "delta_ops", "=", "x", ".", "numel", "(", ")", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "### ops_pooling", "\n", "", "elif", "type_name", "in", "[", "'AvgPool2d'", ",", "'MaxPool2d'", "]", ":", "\n", "            ", "in_w", "=", "x", ".", "size", "(", ")", "[", "2", "]", "\n", "kernel_ops", "=", "layer", ".", "kernel_size", "*", "layer", ".", "kernel_size", "\n", "out_w", "=", "int", "(", "(", "in_w", "+", "2", "*", "layer", ".", "padding", "-", "layer", ".", "kernel_size", ")", "/", "layer", ".", "stride", "+", "1", ")", "\n", "out_h", "=", "int", "(", "(", "in_w", "+", "2", "*", "layer", ".", "padding", "-", "layer", ".", "kernel_size", ")", "/", "layer", ".", "stride", "+", "1", ")", "\n", "delta_ops", "=", "x", ".", "size", "(", ")", "[", "0", "]", "*", "x", ".", "size", "(", ")", "[", "1", "]", "*", "out_w", "*", "out_h", "*", "kernel_ops", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "", "elif", "type_name", "in", "[", "'LastLevelMaxPool'", "]", ":", "\n", "            ", "pass", "\n", "\n", "", "elif", "type_name", "in", "[", "'AdaptiveAvgPool2d'", "]", ":", "\n", "            ", "delta_ops", "=", "x", ".", "size", "(", ")", "[", "0", "]", "*", "x", ".", "size", "(", ")", "[", "1", "]", "*", "x", ".", "size", "(", ")", "[", "2", "]", "*", "x", ".", "size", "(", ")", "[", "3", "]", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "", "elif", "type_name", "in", "[", "'ZeroPad2d'", ",", "'RetinaNetPostProcessor'", "]", ":", "\n", "            ", "pass", "\n", "#delta_ops = x.size()[0] * x.size()[1] * x.size()[2] * x.size()[3]", "\n", "#delta_params = get_layer_param(layer)", "\n", "\n", "### ops_linear", "\n", "", "elif", "type_name", "in", "[", "'Linear'", "]", ":", "\n", "            ", "weight_ops", "=", "layer", ".", "weight", ".", "numel", "(", ")", "*", "multi_add", "\n", "bias_ops", "=", "layer", ".", "bias", ".", "numel", "(", ")", "\n", "delta_ops", "=", "x", ".", "size", "(", ")", "[", "0", "]", "*", "(", "weight_ops", "+", "bias_ops", ")", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "### ops_nothing", "\n", "", "elif", "type_name", "in", "[", "'BatchNorm2d'", ",", "'Dropout2d'", ",", "'DropChannel'", ",", "'Dropout'", ",", "'FrozenBatchNorm2d'", ",", "'GroupNorm'", "]", ":", "\n", "            ", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "", "elif", "type_name", "in", "[", "'SumTwo'", "]", ":", "\n", "            ", "delta_ops", "=", "x", ".", "numel", "(", ")", "\n", "\n", "", "elif", "type_name", "in", "[", "'AggregateCell'", "]", ":", "\n", "            ", "if", "not", "layer", ".", "pre_transform", ":", "\n", "                ", "delta_ops", "=", "2", "*", "x", ".", "numel", "(", ")", "# twice for each input", "\n", "", "else", ":", "\n", "                ", "measure_layer", "(", "layer", ".", "branch_1", ",", "x", ")", "\n", "measure_layer", "(", "layer", ".", "branch_2", ",", "x", ")", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "", "", "elif", "type_name", "in", "[", "'Identity'", ",", "'Zero'", "]", ":", "\n", "            ", "pass", "\n", "\n", "", "elif", "type_name", "in", "[", "'Scale'", "]", ":", "\n", "            ", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "delta_ops", "=", "x", ".", "numel", "(", ")", "\n", "\n", "", "elif", "type_name", "in", "[", "'FCOSPostProcessor'", ",", "'RPNPostProcessor'", ",", "'KeypointPostProcessor'", ",", "\n", "'ROIAlign'", ",", "'PostProcessor'", ",", "'KeypointRCNNPredictor'", ",", "\n", "'NaiveSyncBatchNorm'", ",", "'Upsample'", ",", "'Sequential'", "]", ":", "\n", "            ", "pass", "\n", "\n", "", "elif", "type_name", "in", "[", "'DeformConv'", "]", ":", "\n", "# don't count bilinear", "\n", "            ", "offset_conv", "=", "list", "(", "layer", ".", "parameters", "(", ")", ")", "[", "0", "]", "\n", "delta_ops", "=", "reduce", "(", "operator", ".", "mul", ",", "offset_conv", ".", "size", "(", ")", ",", "x", ".", "size", "(", ")", "[", "2", "]", "*", "x", ".", "size", "(", ")", "[", "3", "]", ")", "\n", "out_h", "=", "int", "(", "(", "x", ".", "size", "(", ")", "[", "2", "]", "+", "2", "*", "layer", ".", "padding", "[", "0", "]", "/", "layer", ".", "dilation", "[", "0", "]", "\n", "-", "layer", ".", "kernel_size", "[", "0", "]", ")", "/", "layer", ".", "stride", "[", "0", "]", "+", "1", ")", "\n", "out_w", "=", "int", "(", "(", "x", ".", "size", "(", ")", "[", "3", "]", "+", "2", "*", "layer", ".", "padding", "[", "1", "]", "/", "layer", ".", "dilation", "[", "1", "]", "\n", "-", "layer", ".", "kernel_size", "[", "1", "]", ")", "/", "layer", ".", "stride", "[", "1", "]", "+", "1", ")", "\n", "delta_ops", "+=", "layer", ".", "in_channels", "*", "layer", ".", "out_channels", "*", "layer", ".", "kernel_size", "[", "0", "]", "*", "layer", ".", "kernel_size", "[", "1", "]", "*", "out_h", "*", "out_w", "/", "layer", ".", "groups", "*", "multi_add", "\n", "delta_params", "=", "get_layer_param", "(", "layer", ")", "\n", "\n", "### unknown layer type", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "'unknown layer type: %s'", "%", "type_name", ")", "\n", "\n", "", "count_ops", "+=", "delta_ops", "\n", "count_params", "+=", "delta_params", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.measures.measure_model": [[158, 193], ["measures.measure_model.modify_forward"], "function", ["None"], ["", "def", "measure_model", "(", "model", ",", "x", ")", ":", "\n", "    ", "global", "count_ops", ",", "count_params", "\n", "count_ops", "=", "0", "\n", "count_params", "=", "0", "\n", "\n", "def", "should_measure", "(", "x", ")", ":", "\n", "        ", "return", "is_leaf", "(", "x", ")", "or", "is_pruned", "(", "x", ")", "\n", "\n", "", "def", "modify_forward", "(", "model", ")", ":", "\n", "        ", "for", "child", "in", "model", ".", "children", "(", ")", ":", "\n", "            ", "if", "should_measure", "(", "child", ")", ":", "\n", "                ", "def", "new_forward", "(", "m", ")", ":", "\n", "                    ", "def", "lambda_forward", "(", "*", "args", ")", ":", "\n", "                        ", "measure_layer", "(", "m", ",", "*", "args", ")", "\n", "return", "m", ".", "old_forward", "(", "*", "args", ")", "\n", "", "return", "lambda_forward", "\n", "", "child", ".", "old_forward", "=", "child", ".", "forward", "\n", "child", ".", "forward", "=", "new_forward", "(", "child", ")", "\n", "", "else", ":", "\n", "                ", "modify_forward", "(", "child", ")", "\n", "\n", "", "", "", "def", "restore_forward", "(", "model", ")", ":", "\n", "        ", "for", "child", "in", "model", ".", "children", "(", ")", ":", "\n", "# leaf node", "\n", "            ", "if", "is_leaf", "(", "child", ")", "and", "hasattr", "(", "child", ",", "'old_forward'", ")", ":", "\n", "                ", "child", ".", "forward", "=", "child", ".", "old_forward", "\n", "child", ".", "old_forward", "=", "None", "\n", "", "else", ":", "\n", "                ", "restore_forward", "(", "child", ")", "\n", "\n", "", "", "", "modify_forward", "(", "model", ")", "\n", "out", "=", "model", ".", "forward", "(", "x", ")", "\n", "restore_forward", "(", "model", ")", "\n", "\n", "return", "out", ",", "count_ops", ",", "count_params", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.comm.reduce_sum": [[5, 12], ["detectron2.utils.comm.get_world_size", "tensor.clone.clone", "torch.all_reduce"], "function", ["None"], ["def", "reduce_sum", "(", "tensor", ")", ":", "\n", "    ", "world_size", "=", "get_world_size", "(", ")", "\n", "if", "world_size", "<", "2", ":", "\n", "        ", "return", "tensor", "\n", "", "tensor", "=", "tensor", ".", "clone", "(", ")", "\n", "dist", ".", "all_reduce", "(", "tensor", ",", "op", "=", "dist", ".", "ReduceOp", ".", "SUM", ")", "\n", "return", "tensor", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.__init__": [[111, 155], ["len", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "images", ",", "\n", "locations", ",", "\n", "logits_pred", ",", "\n", "reg_pred", ",", "\n", "ctrness_pred", ",", "\n", "focal_loss_alpha", ",", "\n", "focal_loss_gamma", ",", "\n", "iou_loss", ",", "\n", "center_sample", ",", "\n", "sizes_of_interest", ",", "\n", "strides", ",", "\n", "radius", ",", "\n", "num_classes", ",", "\n", "pre_nms_thresh", ",", "\n", "pre_nms_top_n", ",", "\n", "nms_thresh", ",", "\n", "fpn_post_nms_top_n", ",", "\n", "thresh_with_ctr", ",", "\n", "gt_instances", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "logits_pred", "=", "logits_pred", "\n", "self", ".", "reg_pred", "=", "reg_pred", "\n", "self", ".", "ctrness_pred", "=", "ctrness_pred", "\n", "self", ".", "locations", "=", "locations", "\n", "\n", "self", ".", "gt_instances", "=", "gt_instances", "\n", "self", ".", "num_feature_maps", "=", "len", "(", "logits_pred", ")", "\n", "self", ".", "num_images", "=", "len", "(", "images", ")", "\n", "self", ".", "image_sizes", "=", "images", ".", "image_sizes", "\n", "self", ".", "focal_loss_alpha", "=", "focal_loss_alpha", "\n", "self", ".", "focal_loss_gamma", "=", "focal_loss_gamma", "\n", "self", ".", "iou_loss", "=", "iou_loss", "\n", "self", ".", "center_sample", "=", "center_sample", "\n", "self", ".", "sizes_of_interest", "=", "sizes_of_interest", "\n", "self", ".", "strides", "=", "strides", "\n", "self", ".", "radius", "=", "radius", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "pre_nms_thresh", "=", "pre_nms_thresh", "\n", "self", ".", "pre_nms_top_n", "=", "pre_nms_top_n", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "fpn_post_nms_top_n", "=", "fpn_post_nms_top_n", "\n", "self", ".", "thresh_with_ctr", "=", "thresh_with_ctr", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs._transpose": [[156, 172], ["range", "zip", "len", "torch.split", "torch.split", "torch.split", "torch.split", "targets_level_first.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "_transpose", "(", "self", ",", "training_targets", ",", "num_loc_list", ")", ":", "\n", "        ", "'''\n        This function is used to transpose image first training targets to level first ones\n        :return: level first training targets\n        '''", "\n", "for", "im_i", "in", "range", "(", "len", "(", "training_targets", ")", ")", ":", "\n", "            ", "training_targets", "[", "im_i", "]", "=", "torch", ".", "split", "(", "\n", "training_targets", "[", "im_i", "]", ",", "num_loc_list", ",", "dim", "=", "0", "\n", ")", "\n", "\n", "", "targets_level_first", "=", "[", "]", "\n", "for", "targets_per_level", "in", "zip", "(", "*", "training_targets", ")", ":", "\n", "            ", "targets_level_first", ".", "append", "(", "\n", "torch", ".", "cat", "(", "targets_per_level", ",", "dim", "=", "0", ")", "\n", ")", "\n", "", "return", "targets_level_first", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs._get_ground_truth": [[173, 203], ["enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "fcos_outputs.FCOSOutputs.compute_targets_for_locations", "range", "len", "loc_per_level.new_tensor", "torch.cat.append", "torch.cat.append", "fcos_outputs.FCOSOutputs._transpose", "len", "loc_to_size_range_per_level[].expand", "fcos_outputs.FCOSOutputs.items", "float"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.compute_targets_for_locations", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs._transpose"], ["", "def", "_get_ground_truth", "(", "self", ")", ":", "\n", "        ", "num_loc_list", "=", "[", "len", "(", "loc", ")", "for", "loc", "in", "self", ".", "locations", "]", "\n", "self", ".", "num_loc_list", "=", "num_loc_list", "\n", "\n", "# compute locations to size ranges", "\n", "loc_to_size_range", "=", "[", "]", "\n", "for", "l", ",", "loc_per_level", "in", "enumerate", "(", "self", ".", "locations", ")", ":", "\n", "            ", "loc_to_size_range_per_level", "=", "loc_per_level", ".", "new_tensor", "(", "self", ".", "sizes_of_interest", "[", "l", "]", ")", "\n", "loc_to_size_range", ".", "append", "(", "\n", "loc_to_size_range_per_level", "[", "None", "]", ".", "expand", "(", "num_loc_list", "[", "l", "]", ",", "-", "1", ")", "\n", ")", "\n", "\n", "", "loc_to_size_range", "=", "torch", ".", "cat", "(", "loc_to_size_range", ",", "dim", "=", "0", ")", "\n", "locations", "=", "torch", ".", "cat", "(", "self", ".", "locations", ",", "dim", "=", "0", ")", "\n", "\n", "training_targets", "=", "self", ".", "compute_targets_for_locations", "(", "\n", "locations", ",", "self", ".", "gt_instances", ",", "loc_to_size_range", "\n", ")", "\n", "\n", "# transpose im first training_targets to level first ones", "\n", "training_targets", "=", "{", "\n", "k", ":", "self", ".", "_transpose", "(", "v", ",", "num_loc_list", ")", "for", "k", ",", "v", "in", "training_targets", ".", "items", "(", ")", "\n", "}", "\n", "\n", "# we normalize reg_targets by FPN's strides here", "\n", "reg_targets", "=", "training_targets", "[", "\"reg_targets\"", "]", "\n", "for", "l", "in", "range", "(", "len", "(", "reg_targets", ")", ")", ":", "\n", "            ", "reg_targets", "[", "l", "]", "=", "reg_targets", "[", "l", "]", "/", "float", "(", "self", ".", "strides", "[", "l", "]", ")", "\n", "\n", "", "return", "training_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.get_sample_region": [[204, 235], ["len", "gt[].expand", "gt[].expand.new_zeros", "enumerate", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "loc_xs.new_zeros", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where", "center_x.numel", "center_x[].sum", "torch.stack.min", "torch.stack.min"], "methods", ["None"], ["", "def", "get_sample_region", "(", "self", ",", "gt", ",", "strides", ",", "num_loc_list", ",", "loc_xs", ",", "loc_ys", ",", "radius", "=", "1", ")", ":", "\n", "        ", "num_gts", "=", "gt", ".", "shape", "[", "0", "]", "\n", "K", "=", "len", "(", "loc_xs", ")", "\n", "gt", "=", "gt", "[", "None", "]", ".", "expand", "(", "K", ",", "num_gts", ",", "4", ")", "\n", "center_x", "=", "(", "gt", "[", "...", ",", "0", "]", "+", "gt", "[", "...", ",", "2", "]", ")", "/", "2", "\n", "center_y", "=", "(", "gt", "[", "...", ",", "1", "]", "+", "gt", "[", "...", ",", "3", "]", ")", "/", "2", "\n", "center_gt", "=", "gt", ".", "new_zeros", "(", "gt", ".", "shape", ")", "\n", "# no gt", "\n", "if", "center_x", ".", "numel", "(", ")", "==", "0", "or", "center_x", "[", "...", ",", "0", "]", ".", "sum", "(", ")", "==", "0", ":", "\n", "            ", "return", "loc_xs", ".", "new_zeros", "(", "loc_xs", ".", "shape", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "", "beg", "=", "0", "\n", "for", "level", ",", "num_loc", "in", "enumerate", "(", "num_loc_list", ")", ":", "\n", "            ", "end", "=", "beg", "+", "num_loc", "\n", "stride", "=", "strides", "[", "level", "]", "*", "radius", "\n", "xmin", "=", "center_x", "[", "beg", ":", "end", "]", "-", "stride", "\n", "ymin", "=", "center_y", "[", "beg", ":", "end", "]", "-", "stride", "\n", "xmax", "=", "center_x", "[", "beg", ":", "end", "]", "+", "stride", "\n", "ymax", "=", "center_y", "[", "beg", ":", "end", "]", "+", "stride", "\n", "# limit sample region in gt", "\n", "center_gt", "[", "beg", ":", "end", ",", ":", ",", "0", "]", "=", "torch", ".", "where", "(", "xmin", ">", "gt", "[", "beg", ":", "end", ",", ":", ",", "0", "]", ",", "xmin", ",", "gt", "[", "beg", ":", "end", ",", ":", ",", "0", "]", ")", "\n", "center_gt", "[", "beg", ":", "end", ",", ":", ",", "1", "]", "=", "torch", ".", "where", "(", "ymin", ">", "gt", "[", "beg", ":", "end", ",", ":", ",", "1", "]", ",", "ymin", ",", "gt", "[", "beg", ":", "end", ",", ":", ",", "1", "]", ")", "\n", "center_gt", "[", "beg", ":", "end", ",", ":", ",", "2", "]", "=", "torch", ".", "where", "(", "xmax", ">", "gt", "[", "beg", ":", "end", ",", ":", ",", "2", "]", ",", "gt", "[", "beg", ":", "end", ",", ":", ",", "2", "]", ",", "xmax", ")", "\n", "center_gt", "[", "beg", ":", "end", ",", ":", ",", "3", "]", "=", "torch", ".", "where", "(", "ymax", ">", "gt", "[", "beg", ":", "end", ",", ":", ",", "3", "]", ",", "gt", "[", "beg", ":", "end", ",", ":", ",", "3", "]", ",", "ymax", ")", "\n", "beg", "=", "end", "\n", "", "left", "=", "loc_xs", "[", ":", ",", "None", "]", "-", "center_gt", "[", "...", ",", "0", "]", "\n", "right", "=", "center_gt", "[", "...", ",", "2", "]", "-", "loc_xs", "[", ":", ",", "None", "]", "\n", "top", "=", "loc_ys", "[", ":", ",", "None", "]", "-", "center_gt", "[", "...", ",", "1", "]", "\n", "bottom", "=", "center_gt", "[", "...", ",", "3", "]", "-", "loc_ys", "[", ":", ",", "None", "]", "\n", "center_bbox", "=", "torch", ".", "stack", "(", "(", "left", ",", "top", ",", "right", ",", "bottom", ")", ",", "-", "1", ")", "\n", "inside_gt_bbox_mask", "=", "center_bbox", ".", "min", "(", "-", "1", ")", "[", "0", "]", ">", "0", "\n", "return", "inside_gt_bbox_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.compute_targets_for_locations": [[236, 291], ["range", "len", "targets_per_im.gt_boxes.area", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "area[].repeat", "area[].repeat.min", "labels.append", "reg_targets.append", "bboxes.numel", "labels.append", "reg_targets.append", "fcos_outputs.FCOSOutputs.get_sample_region", "torch.stack.max", "torch.stack.max", "len", "locations.new_zeros", "labels_per_im.new_zeros", "torch.stack.min", "torch.stack.min", "range", "locations.size", "locations.size", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.get_sample_region"], ["", "def", "compute_targets_for_locations", "(", "self", ",", "locations", ",", "targets", ",", "size_ranges", ")", ":", "\n", "        ", "labels", "=", "[", "]", "\n", "reg_targets", "=", "[", "]", "\n", "xs", ",", "ys", "=", "locations", "[", ":", ",", "0", "]", ",", "locations", "[", ":", ",", "1", "]", "\n", "\n", "for", "im_i", "in", "range", "(", "len", "(", "targets", ")", ")", ":", "\n", "            ", "targets_per_im", "=", "targets", "[", "im_i", "]", "\n", "bboxes", "=", "targets_per_im", ".", "gt_boxes", ".", "tensor", "\n", "labels_per_im", "=", "targets_per_im", ".", "gt_classes", "\n", "\n", "# no gt", "\n", "if", "bboxes", ".", "numel", "(", ")", "==", "0", ":", "\n", "                ", "labels", ".", "append", "(", "labels_per_im", ".", "new_zeros", "(", "locations", ".", "size", "(", "0", ")", ")", "+", "self", ".", "num_classes", ")", "\n", "reg_targets", ".", "append", "(", "locations", ".", "new_zeros", "(", "(", "locations", ".", "size", "(", "0", ")", ",", "4", ")", ")", ")", "\n", "continue", "\n", "\n", "", "area", "=", "targets_per_im", ".", "gt_boxes", ".", "area", "(", ")", "\n", "\n", "l", "=", "xs", "[", ":", ",", "None", "]", "-", "bboxes", "[", ":", ",", "0", "]", "[", "None", "]", "\n", "t", "=", "ys", "[", ":", ",", "None", "]", "-", "bboxes", "[", ":", ",", "1", "]", "[", "None", "]", "\n", "r", "=", "bboxes", "[", ":", ",", "2", "]", "[", "None", "]", "-", "xs", "[", ":", ",", "None", "]", "\n", "b", "=", "bboxes", "[", ":", ",", "3", "]", "[", "None", "]", "-", "ys", "[", ":", ",", "None", "]", "\n", "reg_targets_per_im", "=", "torch", ".", "stack", "(", "[", "l", ",", "t", ",", "r", ",", "b", "]", ",", "dim", "=", "2", ")", "\n", "\n", "if", "self", ".", "center_sample", ":", "\n", "                ", "is_in_boxes", "=", "self", ".", "get_sample_region", "(", "\n", "bboxes", ",", "self", ".", "strides", ",", "self", ".", "num_loc_list", ",", "\n", "xs", ",", "ys", ",", "radius", "=", "self", ".", "radius", "\n", ")", "\n", "", "else", ":", "\n", "                ", "is_in_boxes", "=", "reg_targets_per_im", ".", "min", "(", "dim", "=", "2", ")", "[", "0", "]", ">", "0", "\n", "\n", "", "max_reg_targets_per_im", "=", "reg_targets_per_im", ".", "max", "(", "dim", "=", "2", ")", "[", "0", "]", "\n", "# limit the regression range for each location", "\n", "is_cared_in_the_level", "=", "(", "max_reg_targets_per_im", ">=", "size_ranges", "[", ":", ",", "[", "0", "]", "]", ")", "&", "(", "max_reg_targets_per_im", "<=", "size_ranges", "[", ":", ",", "[", "1", "]", "]", ")", "\n", "\n", "locations_to_gt_area", "=", "area", "[", "None", "]", ".", "repeat", "(", "len", "(", "locations", ")", ",", "1", ")", "\n", "locations_to_gt_area", "[", "is_in_boxes", "==", "0", "]", "=", "INF", "\n", "locations_to_gt_area", "[", "is_cared_in_the_level", "==", "0", "]", "=", "INF", "\n", "\n", "# if there are still more than one objects for a location,", "\n", "# we choose the one with minimal area", "\n", "locations_to_min_area", ",", "locations_to_gt_inds", "=", "locations_to_gt_area", ".", "min", "(", "dim", "=", "1", ")", "\n", "\n", "reg_targets_per_im", "=", "reg_targets_per_im", "[", "range", "(", "len", "(", "locations", ")", ")", ",", "locations_to_gt_inds", "]", "\n", "\n", "labels_per_im", "=", "labels_per_im", "[", "locations_to_gt_inds", "]", "\n", "labels_per_im", "[", "locations_to_min_area", "==", "INF", "]", "=", "self", ".", "num_classes", "\n", "\n", "labels", ".", "append", "(", "labels_per_im", ")", "\n", "reg_targets", ".", "append", "(", "reg_targets_per_im", ")", "\n", "\n", "", "return", "{", "\"labels\"", ":", "labels", ",", "\"reg_targets\"", ":", "reg_targets", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.losses": [[292, 345], ["fcos_outputs.FCOSOutputs._get_ground_truth", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "detectron2.layers.cat", "fcos_outputs.fcos_losses", "x.permute().reshape", "x.permute().reshape", "x.reshape", "x.reshape", "x.reshape", "x.permute", "x.permute"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs._get_ground_truth", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.fcos_losses"], ["", "def", "losses", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Return the losses from a set of FCOS predictions and their associated ground-truth.\n\n        Returns:\n            dict[loss name -> loss value]: A dict mapping from loss name to loss value.\n        \"\"\"", "\n", "\n", "training_targets", "=", "self", ".", "_get_ground_truth", "(", ")", "\n", "labels", ",", "reg_targets", "=", "training_targets", "[", "\"labels\"", "]", ",", "training_targets", "[", "\"reg_targets\"", "]", "\n", "\n", "# Collect all logits and regression predictions over feature maps", "\n", "# and images to arrive at the same shape as the labels and targets", "\n", "# The final ordering is L, N, H, W from slowest to fastest axis.", "\n", "logits_pred", "=", "cat", "(", "\n", "[", "\n", "# Reshape: (N, C, Hi, Wi) -> (N, Hi, Wi, C) -> (N*Hi*Wi, C)", "\n", "x", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "self", ".", "num_classes", ")", "\n", "for", "x", "in", "self", ".", "logits_pred", "\n", "]", ",", "dim", "=", "0", ",", ")", "\n", "reg_pred", "=", "cat", "(", "\n", "[", "\n", "# Reshape: (N, B, Hi, Wi) -> (N, Hi, Wi, B) -> (N*Hi*Wi, B)", "\n", "x", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "for", "x", "in", "self", ".", "reg_pred", "\n", "]", ",", "dim", "=", "0", ",", ")", "\n", "ctrness_pred", "=", "cat", "(", "\n", "[", "\n", "# Reshape: (N, 1, Hi, Wi) -> (N*Hi*Wi,)", "\n", "x", ".", "reshape", "(", "-", "1", ")", "for", "x", "in", "self", ".", "ctrness_pred", "\n", "]", ",", "dim", "=", "0", ",", ")", "\n", "\n", "labels", "=", "cat", "(", "\n", "[", "\n", "# Reshape: (N, 1, Hi, Wi) -> (N*Hi*Wi,)", "\n", "x", ".", "reshape", "(", "-", "1", ")", "for", "x", "in", "labels", "\n", "]", ",", "dim", "=", "0", ",", ")", "\n", "\n", "reg_targets", "=", "cat", "(", "\n", "[", "\n", "# Reshape: (N, Hi, Wi, 4) -> (N*Hi*Wi, 4)", "\n", "x", ".", "reshape", "(", "-", "1", ",", "4", ")", "for", "x", "in", "reg_targets", "\n", "]", ",", "dim", "=", "0", ",", ")", "\n", "\n", "return", "fcos_losses", "(", "\n", "labels", ",", "\n", "reg_targets", ",", "\n", "logits_pred", ",", "\n", "reg_pred", ",", "\n", "ctrness_pred", ",", "\n", "self", ".", "focal_loss_alpha", ",", "\n", "self", ".", "focal_loss_gamma", ",", "\n", "self", ".", "iou_loss", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.predict_proposals": [[347, 370], ["enumerate", "list", "fcos_outputs.FCOSOutputs.select_over_all_levels", "zip", "sampled_boxes.append", "zip", "detectron2.structures.Instances.cat", "fcos_outputs.FCOSOutputs.forward_for_single_feature_map"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.select_over_all_levels", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.forward_for_single_feature_map"], ["", "def", "predict_proposals", "(", "self", ")", ":", "\n", "        ", "sampled_boxes", "=", "[", "]", "\n", "\n", "bundle", "=", "(", "\n", "self", ".", "locations", ",", "self", ".", "logits_pred", ",", "\n", "self", ".", "reg_pred", ",", "self", ".", "ctrness_pred", ",", "\n", "self", ".", "strides", "\n", ")", "\n", "\n", "for", "i", ",", "(", "l", ",", "o", ",", "r", ",", "c", ",", "s", ")", "in", "enumerate", "(", "zip", "(", "*", "bundle", ")", ")", ":", "\n", "# recall that during training, we normalize regression targets with FPN's stride.", "\n", "# we denormalize them here.", "\n", "            ", "r", "=", "r", "*", "s", "\n", "sampled_boxes", ".", "append", "(", "\n", "self", ".", "forward_for_single_feature_map", "(", "\n", "l", ",", "o", ",", "r", ",", "c", ",", "self", ".", "image_sizes", "\n", ")", "\n", ")", "\n", "\n", "", "boxlists", "=", "list", "(", "zip", "(", "*", "sampled_boxes", ")", ")", "\n", "boxlists", "=", "[", "Instances", ".", "cat", "(", "boxlist", ")", "for", "boxlist", "in", "boxlists", "]", "\n", "boxlists", "=", "self", ".", "select_over_all_levels", "(", "boxlists", ")", "\n", "return", "boxlists", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.forward_for_single_feature_map": [[371, 435], ["box_cls.reshape().sigmoid.reshape().sigmoid.view().permute", "box_cls.reshape().sigmoid.reshape().sigmoid.reshape().sigmoid", "reg_pred.view().permute", "box_regression.reshape.reshape.reshape", "ctrness.reshape().sigmoid.reshape().sigmoid.view().permute", "ctrness.reshape().sigmoid.reshape().sigmoid.reshape().sigmoid", "candidate_inds.reshape().sum", "pre_nms_top_n.clamp.clamp.clamp", "range", "per_candidate_inds.nonzero", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "detectron2.structures.Instances", "detectron2.structures.Boxes", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "results.append", "box_cls.reshape().sigmoid.reshape().sigmoid.view", "box_cls.reshape().sigmoid.reshape().sigmoid.reshape", "reg_pred.view", "ctrness.reshape().sigmoid.reshape().sigmoid.view", "ctrness.reshape().sigmoid.reshape().sigmoid.reshape", "candidate_inds.reshape", "per_candidate_inds.sum().item", "per_pre_nms_top_n.item", "per_box_cls.topk", "per_candidate_inds.sum"], "methods", ["None"], ["", "def", "forward_for_single_feature_map", "(", "\n", "self", ",", "locations", ",", "box_cls", ",", "\n", "reg_pred", ",", "ctrness", ",", "image_sizes", "\n", ")", ":", "\n", "        ", "N", ",", "C", ",", "H", ",", "W", "=", "box_cls", ".", "shape", "\n", "\n", "# put in the same format as locations", "\n", "box_cls", "=", "box_cls", ".", "view", "(", "N", ",", "C", ",", "H", ",", "W", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "box_cls", "=", "box_cls", ".", "reshape", "(", "N", ",", "-", "1", ",", "C", ")", ".", "sigmoid", "(", ")", "\n", "box_regression", "=", "reg_pred", ".", "view", "(", "N", ",", "4", ",", "H", ",", "W", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "box_regression", "=", "box_regression", ".", "reshape", "(", "N", ",", "-", "1", ",", "4", ")", "\n", "ctrness", "=", "ctrness", ".", "view", "(", "N", ",", "1", ",", "H", ",", "W", ")", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "ctrness", "=", "ctrness", ".", "reshape", "(", "N", ",", "-", "1", ")", ".", "sigmoid", "(", ")", "\n", "\n", "# if self.thresh_with_ctr is True, we multiply the classification", "\n", "# scores with centerness scores before applying the threshold.", "\n", "if", "self", ".", "thresh_with_ctr", ":", "\n", "            ", "box_cls", "=", "box_cls", "*", "ctrness", "[", ":", ",", ":", ",", "None", "]", "\n", "", "candidate_inds", "=", "box_cls", ">", "self", ".", "pre_nms_thresh", "\n", "pre_nms_top_n", "=", "candidate_inds", ".", "reshape", "(", "N", ",", "-", "1", ")", ".", "sum", "(", "1", ")", "\n", "pre_nms_top_n", "=", "pre_nms_top_n", ".", "clamp", "(", "max", "=", "self", ".", "pre_nms_top_n", ")", "\n", "\n", "if", "not", "self", ".", "thresh_with_ctr", ":", "\n", "            ", "box_cls", "=", "box_cls", "*", "ctrness", "[", ":", ",", ":", ",", "None", "]", "\n", "\n", "", "results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "per_box_cls", "=", "box_cls", "[", "i", "]", "\n", "per_candidate_inds", "=", "candidate_inds", "[", "i", "]", "\n", "per_box_cls", "=", "per_box_cls", "[", "per_candidate_inds", "]", "\n", "\n", "per_candidate_nonzeros", "=", "per_candidate_inds", ".", "nonzero", "(", ")", "\n", "per_box_loc", "=", "per_candidate_nonzeros", "[", ":", ",", "0", "]", "\n", "per_class", "=", "per_candidate_nonzeros", "[", ":", ",", "1", "]", "\n", "\n", "per_box_regression", "=", "box_regression", "[", "i", "]", "\n", "per_box_regression", "=", "per_box_regression", "[", "per_box_loc", "]", "\n", "per_locations", "=", "locations", "[", "per_box_loc", "]", "\n", "\n", "per_pre_nms_top_n", "=", "pre_nms_top_n", "[", "i", "]", "\n", "\n", "if", "per_candidate_inds", ".", "sum", "(", ")", ".", "item", "(", ")", ">", "per_pre_nms_top_n", ".", "item", "(", ")", ":", "\n", "                ", "per_box_cls", ",", "top_k_indices", "=", "per_box_cls", ".", "topk", "(", "per_pre_nms_top_n", ",", "sorted", "=", "False", ")", "\n", "per_class", "=", "per_class", "[", "top_k_indices", "]", "\n", "per_box_regression", "=", "per_box_regression", "[", "top_k_indices", "]", "\n", "per_locations", "=", "per_locations", "[", "top_k_indices", "]", "\n", "\n", "", "detections", "=", "torch", ".", "stack", "(", "[", "\n", "per_locations", "[", ":", ",", "0", "]", "-", "per_box_regression", "[", ":", ",", "0", "]", ",", "\n", "per_locations", "[", ":", ",", "1", "]", "-", "per_box_regression", "[", ":", ",", "1", "]", ",", "\n", "per_locations", "[", ":", ",", "0", "]", "+", "per_box_regression", "[", ":", ",", "2", "]", ",", "\n", "per_locations", "[", ":", ",", "1", "]", "+", "per_box_regression", "[", ":", ",", "3", "]", ",", "\n", "]", ",", "dim", "=", "1", ")", "\n", "\n", "boxlist", "=", "Instances", "(", "image_sizes", "[", "i", "]", ")", "\n", "boxlist", ".", "pred_boxes", "=", "Boxes", "(", "detections", ")", "\n", "boxlist", ".", "scores", "=", "torch", ".", "sqrt", "(", "per_box_cls", ")", "\n", "boxlist", ".", "pred_classes", "=", "per_class", "\n", "boxlist", ".", "locations", "=", "per_locations", "\n", "\n", "results", ".", "append", "(", "boxlist", ")", "\n", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.select_over_all_levels": [[436, 456], ["len", "range", "centermask.layers.ml_nms", "len", "results.append", "torch.kthvalue", "torch.kthvalue", "torch.kthvalue", "torch.kthvalue", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "cls_scores.cpu", "image_thresh.item", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.ml_nms.ml_nms"], ["", "def", "select_over_all_levels", "(", "self", ",", "boxlists", ")", ":", "\n", "        ", "num_images", "=", "len", "(", "boxlists", ")", "\n", "results", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_images", ")", ":", "\n", "# multiclass nms", "\n", "            ", "result", "=", "ml_nms", "(", "boxlists", "[", "i", "]", ",", "self", ".", "nms_thresh", ")", "\n", "number_of_detections", "=", "len", "(", "result", ")", "\n", "\n", "# Limit to max_per_image detections **over all classes**", "\n", "if", "number_of_detections", ">", "self", ".", "fpn_post_nms_top_n", ">", "0", ":", "\n", "                ", "cls_scores", "=", "result", ".", "scores", "\n", "image_thresh", ",", "_", "=", "torch", ".", "kthvalue", "(", "\n", "cls_scores", ".", "cpu", "(", ")", ",", "\n", "number_of_detections", "-", "self", ".", "fpn_post_nms_top_n", "+", "1", "\n", ")", "\n", "keep", "=", "cls_scores", ">=", "image_thresh", ".", "item", "(", ")", "\n", "keep", "=", "torch", ".", "nonzero", "(", "keep", ")", ".", "squeeze", "(", "1", ")", "\n", "result", "=", "result", "[", "keep", "]", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.compute_ctrness_targets": [[41, 49], ["torch.sqrt", "torch.sqrt", "len", "reg_targets.new_zeros", "len", "left_right.min", "left_right.max", "top_bottom.min", "top_bottom.max"], "function", ["None"], ["def", "compute_ctrness_targets", "(", "reg_targets", ")", ":", "\n", "    ", "if", "len", "(", "reg_targets", ")", "==", "0", ":", "\n", "        ", "return", "reg_targets", ".", "new_zeros", "(", "len", "(", "reg_targets", ")", ")", "\n", "", "left_right", "=", "reg_targets", "[", ":", ",", "[", "0", ",", "2", "]", "]", "\n", "top_bottom", "=", "reg_targets", "[", ":", ",", "[", "1", ",", "3", "]", "]", "\n", "ctrness", "=", "(", "left_right", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "left_right", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "*", "(", "top_bottom", ".", "min", "(", "dim", "=", "-", "1", ")", "[", "0", "]", "/", "top_bottom", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ")", "\n", "return", "torch", ".", "sqrt", "(", "ctrness", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.fcos_losses": [[51, 108], ["logits_pred.size", "labels.flatten.flatten", "torch.nonzero().squeeze", "torch.nonzero().squeeze", "torch.nonzero().squeeze.numel", "centermask.utils.comm.get_world_size", "centermask.utils.comm.reduce_sum().item", "max", "torch.zeros_like", "torch.zeros_like", "fcos_outputs.compute_ctrness_targets", "compute_ctrness_targets.sum", "max", "fvcore.nn.sigmoid_focal_loss_jit", "iou_loss", "torch.binary_cross_entropy_with_logits", "torch.nonzero", "torch.nonzero", "centermask.utils.comm.reduce_sum", "centermask.utils.comm.reduce_sum().item", "torch.nonzero().squeeze.new_tensor", "centermask.utils.comm.reduce_sum"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.compute_ctrness_targets", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.comm.reduce_sum", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.utils.comm.reduce_sum"], ["", "def", "fcos_losses", "(", "\n", "labels", ",", "\n", "reg_targets", ",", "\n", "logits_pred", ",", "\n", "reg_pred", ",", "\n", "ctrness_pred", ",", "\n", "focal_loss_alpha", ",", "\n", "focal_loss_gamma", ",", "\n", "iou_loss", ",", "\n", ")", ":", "\n", "    ", "num_classes", "=", "logits_pred", ".", "size", "(", "1", ")", "\n", "labels", "=", "labels", ".", "flatten", "(", ")", "\n", "\n", "pos_inds", "=", "torch", ".", "nonzero", "(", "labels", "!=", "num_classes", ")", ".", "squeeze", "(", "1", ")", "\n", "num_pos_local", "=", "pos_inds", ".", "numel", "(", ")", "\n", "num_gpus", "=", "get_world_size", "(", ")", "\n", "total_num_pos", "=", "reduce_sum", "(", "pos_inds", ".", "new_tensor", "(", "[", "num_pos_local", "]", ")", ")", ".", "item", "(", ")", "\n", "num_pos_avg", "=", "max", "(", "total_num_pos", "/", "num_gpus", ",", "1.0", ")", "\n", "\n", "# prepare one_hot", "\n", "class_target", "=", "torch", ".", "zeros_like", "(", "logits_pred", ")", "\n", "class_target", "[", "pos_inds", ",", "labels", "[", "pos_inds", "]", "]", "=", "1", "\n", "\n", "class_loss", "=", "sigmoid_focal_loss_jit", "(", "\n", "logits_pred", ",", "\n", "class_target", ",", "\n", "alpha", "=", "focal_loss_alpha", ",", "\n", "gamma", "=", "focal_loss_gamma", ",", "\n", "reduction", "=", "\"sum\"", ",", "\n", ")", "/", "num_pos_avg", "\n", "\n", "reg_pred", "=", "reg_pred", "[", "pos_inds", "]", "\n", "reg_targets", "=", "reg_targets", "[", "pos_inds", "]", "\n", "ctrness_pred", "=", "ctrness_pred", "[", "pos_inds", "]", "\n", "\n", "ctrness_targets", "=", "compute_ctrness_targets", "(", "reg_targets", ")", "\n", "ctrness_targets_sum", "=", "ctrness_targets", ".", "sum", "(", ")", "\n", "ctrness_norm", "=", "max", "(", "reduce_sum", "(", "ctrness_targets_sum", ")", ".", "item", "(", ")", "/", "num_gpus", ",", "1e-6", ")", "\n", "\n", "reg_loss", "=", "iou_loss", "(", "\n", "reg_pred", ",", "\n", "reg_targets", ",", "\n", "ctrness_targets", "\n", ")", "/", "ctrness_norm", "\n", "\n", "ctrness_loss", "=", "F", ".", "binary_cross_entropy_with_logits", "(", "\n", "ctrness_pred", ",", "\n", "ctrness_targets", ",", "\n", "reduction", "=", "\"sum\"", "\n", ")", "/", "num_pos_avg", "\n", "\n", "losses", "=", "{", "\n", "\"loss_fcos_cls\"", ":", "class_loss", ",", "\n", "\"loss_fcos_loc\"", ":", "reg_loss", ",", "\n", "\"loss_fcos_ctr\"", ":", "ctrness_loss", "\n", "}", "\n", "return", "losses", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.Scale.__init__": [[20, 23], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "init_value", "=", "1.0", ")", ":", "\n", "        ", "super", "(", "Scale", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "scale", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "[", "init_value", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.Scale.forward": [[24, 26], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "input", "*", "self", ".", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOS.__init__": [[30, 60], ["torch.nn.Module.__init__", "centermask.layers.IOULoss", "soi.append", "fcos.FCOSHead", "soi.append"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "Dict", "[", "str", ",", "ShapeSpec", "]", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# fmt: off", "\n", "self", ".", "in_features", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "IN_FEATURES", "\n", "self", ".", "fpn_strides", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "FPN_STRIDES", "\n", "self", ".", "focal_loss_alpha", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "LOSS_ALPHA", "\n", "self", ".", "focal_loss_gamma", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "LOSS_GAMMA", "\n", "self", ".", "center_sample", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "CENTER_SAMPLE", "\n", "self", ".", "strides", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "FPN_STRIDES", "\n", "self", ".", "radius", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "POS_RADIUS", "\n", "self", ".", "pre_nms_thresh_train", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "INFERENCE_TH_TRAIN", "\n", "self", ".", "pre_nms_thresh_test", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "INFERENCE_TH_TEST", "\n", "self", ".", "pre_nms_topk_train", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "PRE_NMS_TOPK_TRAIN", "\n", "self", ".", "pre_nms_topk_test", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "PRE_NMS_TOPK_TEST", "\n", "self", ".", "nms_thresh", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "NMS_TH", "\n", "self", ".", "post_nms_topk_train", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "POST_NMS_TOPK_TRAIN", "\n", "self", ".", "post_nms_topk_test", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "POST_NMS_TOPK_TEST", "\n", "self", ".", "thresh_with_ctr", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "THRESH_WITH_CTR", "\n", "self", ".", "mask_on", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "#ywlee", "\n", "# fmt: on", "\n", "self", ".", "iou_loss", "=", "IOULoss", "(", "cfg", ".", "MODEL", ".", "FCOS", ".", "LOC_LOSS_TYPE", ")", "\n", "# generate sizes of interest", "\n", "soi", "=", "[", "]", "\n", "prev_size", "=", "-", "1", "\n", "for", "s", "in", "cfg", ".", "MODEL", ".", "FCOS", ".", "SIZES_OF_INTEREST", ":", "\n", "            ", "soi", ".", "append", "(", "[", "prev_size", ",", "s", "]", ")", "\n", "prev_size", "=", "s", "\n", "", "soi", ".", "append", "(", "[", "prev_size", ",", "INF", "]", ")", "\n", "self", ".", "sizes_of_interest", "=", "soi", "\n", "self", ".", "fcos_head", "=", "FCOSHead", "(", "cfg", ",", "[", "input_shape", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", ")", "\n", "# self.det_weights = cfg.MODEL.DET_WEIGHTS", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOS.forward": [[62, 122], ["fcos.FCOS.compute_locations", "fcos.FCOS.fcos_head", "fcos_outputs.FCOSOutputs", "fcos_outputs.FCOSOutputs.losses", "fcos_outputs.FCOSOutputs.predict_proposals", "fcos_outputs.FCOSOutputs.predict_proposals"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOS.compute_locations", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.losses", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.predict_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos_outputs.FCOSOutputs.predict_proposals"], ["", "def", "forward", "(", "self", ",", "images", ",", "features", ",", "gt_instances", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            images (list[Tensor] or ImageList): images to be processed\n            targets (list[BoxList]): ground-truth boxes present in the image (optional)\n\n        Returns:\n            result (list[BoxList] or dict[Tensor]): the output from the model.\n                During training, it returns a dict[Tensor] which contains the losses.\n                During testing, it returns list[BoxList] contains additional fields\n                like `scores`, `labels` and `mask` (for Mask R-CNN models).\n\n        \"\"\"", "\n", "features", "=", "[", "features", "[", "f", "]", "for", "f", "in", "self", ".", "in_features", "]", "\n", "locations", "=", "self", ".", "compute_locations", "(", "features", ")", "\n", "logits_pred", ",", "reg_pred", ",", "ctrness_pred", ",", "bbox_towers", "=", "self", ".", "fcos_head", "(", "features", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "pre_nms_thresh", "=", "self", ".", "pre_nms_thresh_train", "\n", "pre_nms_topk", "=", "self", ".", "pre_nms_topk_train", "\n", "post_nms_topk", "=", "self", ".", "post_nms_topk_train", "\n", "", "else", ":", "\n", "            ", "pre_nms_thresh", "=", "self", ".", "pre_nms_thresh_test", "\n", "pre_nms_topk", "=", "self", ".", "pre_nms_topk_test", "\n", "post_nms_topk", "=", "self", ".", "post_nms_topk_test", "\n", "\n", "", "outputs", "=", "FCOSOutputs", "(", "\n", "images", ",", "\n", "locations", ",", "\n", "logits_pred", ",", "\n", "reg_pred", ",", "\n", "ctrness_pred", ",", "\n", "self", ".", "focal_loss_alpha", ",", "\n", "self", ".", "focal_loss_gamma", ",", "\n", "self", ".", "iou_loss", ",", "\n", "self", ".", "center_sample", ",", "\n", "self", ".", "sizes_of_interest", ",", "\n", "self", ".", "strides", ",", "\n", "self", ".", "radius", ",", "\n", "self", ".", "fcos_head", ".", "num_classes", ",", "\n", "pre_nms_thresh", ",", "\n", "pre_nms_topk", ",", "\n", "self", ".", "nms_thresh", ",", "\n", "post_nms_topk", ",", "\n", "self", ".", "thresh_with_ctr", ",", "\n", "gt_instances", ",", "\n", ")", "\n", "\n", "if", "self", ".", "training", ":", "\n", "            ", "losses", ",", "_", "=", "outputs", ".", "losses", "(", ")", "\n", "# for k, v in losses.items():", "\n", "#     losses[k] = v * self.det_weights", "\n", "if", "self", ".", "mask_on", ":", "\n", "                ", "proposals", "=", "outputs", ".", "predict_proposals", "(", ")", "\n", "return", "proposals", ",", "losses", "\n", "", "else", ":", "\n", "                ", "return", "None", ",", "losses", "\n", "", "", "else", ":", "\n", "            ", "proposals", "=", "outputs", ".", "predict_proposals", "(", ")", "\n", "return", "proposals", ",", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOS.compute_locations": [[123, 133], ["enumerate", "fcos.FCOS.compute_locations_per_level", "locations.append", "feature.size"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOS.compute_locations_per_level"], ["", "", "def", "compute_locations", "(", "self", ",", "features", ")", ":", "\n", "        ", "locations", "=", "[", "]", "\n", "for", "level", ",", "feature", "in", "enumerate", "(", "features", ")", ":", "\n", "            ", "h", ",", "w", "=", "feature", ".", "size", "(", ")", "[", "-", "2", ":", "]", "\n", "locations_per_level", "=", "self", ".", "compute_locations_per_level", "(", "\n", "h", ",", "w", ",", "self", ".", "fpn_strides", "[", "level", "]", ",", "\n", "feature", ".", "device", "\n", ")", "\n", "locations", ".", "append", "(", "locations_per_level", ")", "\n", "", "return", "locations", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOS.compute_locations_per_level": [[134, 148], ["torch.arange", "torch.arange", "torch.meshgrid", "shift_x.reshape.reshape.reshape", "shift_y.reshape.reshape.reshape", "torch.stack"], "methods", ["None"], ["", "def", "compute_locations_per_level", "(", "self", ",", "h", ",", "w", ",", "stride", ",", "device", ")", ":", "\n", "        ", "shifts_x", "=", "torch", ".", "arange", "(", "\n", "0", ",", "w", "*", "stride", ",", "step", "=", "stride", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shifts_y", "=", "torch", ".", "arange", "(", "\n", "0", ",", "h", "*", "stride", ",", "step", "=", "stride", ",", "\n", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "device", "\n", ")", "\n", "shift_y", ",", "shift_x", "=", "torch", ".", "meshgrid", "(", "shifts_y", ",", "shifts_x", ")", "\n", "shift_x", "=", "shift_x", ".", "reshape", "(", "-", "1", ")", "\n", "shift_y", "=", "shift_y", ".", "reshape", "(", "-", "1", ")", "\n", "locations", "=", "torch", ".", "stack", "(", "(", "shift_x", ",", "shift_y", ")", ",", "dim", "=", "1", ")", "+", "stride", "//", "2", "\n", "return", "locations", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOSHead.__init__": [[151, 224], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.init.constant_", "len", "range", "fcos.FCOSHead.add_module", "torch.nn.ModuleList", "modules.modules", "math.log", "set", "tower.append", "tower.append", "torch.nn.Sequential", "isinstance", "conv_func", "tower.append", "torch.nn.ReLU", "fcos.Scale", "torch.nn.init.normal_", "torch.nn.init.constant_", "torch.nn.GroupNorm"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_shape", ":", "List", "[", "ShapeSpec", "]", ")", ":", "\n", "        ", "\"\"\"\n        Arguments:\n            in_channels (int): number of channels of the input feature\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# TODO: Implement the sigmoid version first.", "\n", "self", ".", "num_classes", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "NUM_CLASSES", "\n", "self", ".", "fpn_strides", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "FPN_STRIDES", "\n", "head_configs", "=", "{", "\"cls\"", ":", "(", "cfg", ".", "MODEL", ".", "FCOS", ".", "NUM_CLS_CONVS", ",", "\n", "False", ")", ",", "\n", "\"bbox\"", ":", "(", "cfg", ".", "MODEL", ".", "FCOS", ".", "NUM_BOX_CONVS", ",", "\n", "cfg", ".", "MODEL", ".", "FCOS", ".", "USE_DEFORMABLE", ")", ",", "\n", "\"share\"", ":", "(", "cfg", ".", "MODEL", ".", "FCOS", ".", "NUM_SHARE_CONVS", ",", "\n", "cfg", ".", "MODEL", ".", "FCOS", ".", "USE_DEFORMABLE", ")", "}", "\n", "norm", "=", "None", "if", "cfg", ".", "MODEL", ".", "FCOS", ".", "NORM", "==", "\"none\"", "else", "cfg", ".", "MODEL", ".", "FCOS", ".", "NORM", "\n", "\n", "in_channels", "=", "[", "s", ".", "channels", "for", "s", "in", "input_shape", "]", "\n", "assert", "len", "(", "set", "(", "in_channels", ")", ")", "==", "1", ",", "\"Each level must have the same channel!\"", "\n", "in_channels", "=", "in_channels", "[", "0", "]", "\n", "\n", "for", "head", "in", "head_configs", ":", "\n", "            ", "tower", "=", "[", "]", "\n", "num_convs", ",", "use_deformable", "=", "head_configs", "[", "head", "]", "\n", "if", "use_deformable", ":", "\n", "                ", "conv_func", "=", "DFConv2d", "\n", "", "else", ":", "\n", "                ", "conv_func", "=", "nn", ".", "Conv2d", "\n", "", "for", "i", "in", "range", "(", "num_convs", ")", ":", "\n", "                ", "tower", ".", "append", "(", "conv_func", "(", "\n", "in_channels", ",", "in_channels", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "1", ",", "bias", "=", "True", "\n", ")", ")", "\n", "if", "norm", "==", "\"GN\"", ":", "\n", "                    ", "tower", ".", "append", "(", "nn", ".", "GroupNorm", "(", "32", ",", "in_channels", ")", ")", "\n", "", "tower", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "", "self", ".", "add_module", "(", "'{}_tower'", ".", "format", "(", "head", ")", ",", "\n", "nn", ".", "Sequential", "(", "*", "tower", ")", ")", "\n", "\n", "", "self", ".", "cls_logits", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "self", ".", "num_classes", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "\n", "padding", "=", "1", "\n", ")", "\n", "self", ".", "bbox_pred", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "4", ",", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "self", ".", "ctrness", "=", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "1", ",", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "padding", "=", "1", "\n", ")", "\n", "\n", "if", "cfg", ".", "MODEL", ".", "FCOS", ".", "USE_SCALE", ":", "\n", "            ", "self", ".", "scales", "=", "nn", ".", "ModuleList", "(", "[", "Scale", "(", "init_value", "=", "1.0", ")", "for", "_", "in", "self", ".", "fpn_strides", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "scales", "=", "None", "\n", "\n", "", "for", "modules", "in", "[", "\n", "self", ".", "cls_tower", ",", "self", ".", "bbox_tower", ",", "\n", "self", ".", "share_tower", ",", "self", ".", "cls_logits", ",", "\n", "self", ".", "bbox_pred", ",", "self", ".", "ctrness", "\n", "]", ":", "\n", "            ", "for", "l", "in", "modules", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "l", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "torch", ".", "nn", ".", "init", ".", "normal_", "(", "l", ".", "weight", ",", "std", "=", "0.01", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0", ")", "\n", "\n", "# initialize the bias for focal loss", "\n", "", "", "", "prior_prob", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "PRIOR_PROB", "\n", "bias_value", "=", "-", "math", ".", "log", "(", "(", "1", "-", "prior_prob", ")", "/", "prior_prob", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "self", ".", "cls_logits", ".", "bias", ",", "bias_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.fcos.fcos.FCOSHead.forward": [[225, 244], ["enumerate", "fcos.FCOSHead.share_tower", "fcos.FCOSHead.cls_tower", "fcos.FCOSHead.bbox_tower", "logits.append", "ctrness.append", "fcos.FCOSHead.bbox_pred", "bbox_reg.append", "fcos.FCOSHead.cls_logits", "fcos.FCOSHead.ctrness", "torch.nn.functional.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "logits", "=", "[", "]", "\n", "bbox_reg", "=", "[", "]", "\n", "ctrness", "=", "[", "]", "\n", "bbox_towers", "=", "[", "]", "\n", "for", "l", ",", "feature", "in", "enumerate", "(", "x", ")", ":", "\n", "            ", "feature", "=", "self", ".", "share_tower", "(", "feature", ")", "\n", "cls_tower", "=", "self", ".", "cls_tower", "(", "feature", ")", "\n", "bbox_tower", "=", "self", ".", "bbox_tower", "(", "feature", ")", "\n", "\n", "logits", ".", "append", "(", "self", ".", "cls_logits", "(", "cls_tower", ")", ")", "\n", "ctrness", ".", "append", "(", "self", ".", "ctrness", "(", "bbox_tower", ")", ")", "\n", "reg", "=", "self", ".", "bbox_pred", "(", "bbox_tower", ")", "\n", "if", "self", ".", "scales", "is", "not", "None", ":", "\n", "                ", "reg", "=", "self", ".", "scales", "[", "l", "]", "(", "reg", ")", "\n", "# Note that we use relu, as in the improved FCOS, instead of exp.", "\n", "", "bbox_reg", ".", "append", "(", "F", ".", "relu", "(", "reg", ")", ")", "\n", "\n", "", "return", "logits", ",", "bbox_reg", ",", "ctrness", ",", "bbox_towers", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.InvertedResidual.__init__": [[39, 70], ["torch.nn.Module.__init__", "int", "round", "torch.nn.Sequential", "torch.nn.Sequential", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d", "torch.nn.ReLU6", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d", "torch.nn.ReLU6", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d", "torch.nn.ReLU6", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inp", ",", "oup", ",", "stride", ",", "expand_ratio", ")", ":", "\n", "        ", "super", "(", "InvertedResidual", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "stride", "=", "stride", "\n", "assert", "stride", "in", "[", "1", ",", "2", "]", "\n", "\n", "hidden_dim", "=", "int", "(", "round", "(", "inp", "*", "expand_ratio", ")", ")", "\n", "self", ".", "use_res_connect", "=", "self", ".", "stride", "==", "1", "and", "inp", "==", "oup", "\n", "\n", "if", "expand_ratio", "==", "1", ":", "\n", "            ", "self", ".", "conv", "=", "nn", ".", "Sequential", "(", "\n", "# dw", "\n", "Conv2d", "(", "hidden_dim", ",", "hidden_dim", ",", "3", ",", "stride", ",", "1", ",", "groups", "=", "hidden_dim", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "hidden_dim", ")", ",", "\n", "nn", ".", "ReLU6", "(", "inplace", "=", "True", ")", ",", "\n", "# pw-linear", "\n", "Conv2d", "(", "hidden_dim", ",", "oup", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "oup", ")", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "conv", "=", "nn", ".", "Sequential", "(", "\n", "# pw", "\n", "Conv2d", "(", "inp", ",", "hidden_dim", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "hidden_dim", ")", ",", "\n", "nn", ".", "ReLU6", "(", "inplace", "=", "True", ")", ",", "\n", "# dw", "\n", "Conv2d", "(", "hidden_dim", ",", "hidden_dim", ",", "3", ",", "stride", ",", "1", ",", "groups", "=", "hidden_dim", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "hidden_dim", ")", ",", "\n", "nn", ".", "ReLU6", "(", "inplace", "=", "True", ")", ",", "\n", "# pw-linear", "\n", "Conv2d", "(", "hidden_dim", ",", "oup", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "oup", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.InvertedResidual.forward": [[72, 77], ["mobilenet.InvertedResidual.conv", "mobilenet.InvertedResidual.conv"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "use_res_connect", ":", "\n", "            ", "return", "x", "+", "self", ".", "conv", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.MobileNetV2.__init__": [[83, 118], ["detectron2.modeling.backbone.Backbone.__init__", "int", "torch.nn.ModuleList", "mobilenet.MobileNetV2._initialize_weights", "mobilenet.MobileNetV2._freeze_backbone", "int", "range", "mobilenet.conv_bn", "mobilenet.MobileNetV2.features.append", "mobilenet.MobileNetV2.features.append", "mobilenet.MobileNetV2.return_features_num_channels.append", "block", "block", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet._initialize_weights", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet._freeze_backbone", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.conv_bn"], ["def", "__init__", "(", "self", ",", "cfg", ",", "n_class", "=", "1000", ",", "input_size", "=", "224", ",", "width_mult", "=", "1.", ")", ":", "\n", "        ", "super", "(", "MobileNetV2", ",", "self", ")", ".", "__init__", "(", ")", "\n", "block", "=", "InvertedResidual", "\n", "input_channel", "=", "32", "\n", "interverted_residual_setting", "=", "[", "\n", "# t, c, n, s", "\n", "[", "1", ",", "16", ",", "1", ",", "1", "]", ",", "\n", "[", "6", ",", "24", ",", "2", ",", "2", "]", ",", "\n", "[", "6", ",", "32", ",", "3", ",", "2", "]", ",", "\n", "[", "6", ",", "64", ",", "4", ",", "2", "]", ",", "\n", "[", "6", ",", "96", ",", "3", ",", "1", "]", ",", "\n", "[", "6", ",", "160", ",", "3", ",", "2", "]", ",", "\n", "[", "6", ",", "320", ",", "1", ",", "1", "]", ",", "\n", "]", "\n", "\n", "# building first layer", "\n", "assert", "input_size", "%", "32", "==", "0", "\n", "input_channel", "=", "int", "(", "input_channel", "*", "width_mult", ")", "\n", "self", ".", "return_features_indices", "=", "[", "3", ",", "6", ",", "13", ",", "17", "]", "\n", "self", ".", "return_features_num_channels", "=", "[", "]", "\n", "self", ".", "features", "=", "nn", ".", "ModuleList", "(", "[", "conv_bn", "(", "3", ",", "input_channel", ",", "2", ")", "]", ")", "\n", "# building inverted residual blocks", "\n", "for", "t", ",", "c", ",", "n", ",", "s", "in", "interverted_residual_setting", ":", "\n", "            ", "output_channel", "=", "int", "(", "c", "*", "width_mult", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "self", ".", "features", ".", "append", "(", "block", "(", "input_channel", ",", "output_channel", ",", "s", ",", "expand_ratio", "=", "t", ")", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "features", ".", "append", "(", "block", "(", "input_channel", ",", "output_channel", ",", "1", ",", "expand_ratio", "=", "t", ")", ")", "\n", "", "input_channel", "=", "output_channel", "\n", "if", "len", "(", "self", ".", "features", ")", "-", "1", "in", "self", ".", "return_features_indices", ":", "\n", "                    ", "self", ".", "return_features_num_channels", ".", "append", "(", "output_channel", ")", "\n", "\n", "", "", "", "self", ".", "_initialize_weights", "(", ")", "\n", "self", ".", "_freeze_backbone", "(", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.MobileNetV2._freeze_backbone": [[119, 123], ["range", "mobilenet.MobileNetV2.features[].parameters"], "methods", ["None"], ["", "def", "_freeze_backbone", "(", "self", ",", "freeze_at", ")", ":", "\n", "        ", "for", "layer_index", "in", "range", "(", "freeze_at", ")", ":", "\n", "            ", "for", "p", "in", "self", ".", "features", "[", "layer_index", "]", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.MobileNetV2.forward": [[124, 131], ["enumerate", "m", "res.append", "enumerate"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "res", "=", "[", "]", "\n", "for", "i", ",", "m", "in", "enumerate", "(", "self", ".", "features", ")", ":", "\n", "            ", "x", "=", "m", "(", "x", ")", "\n", "if", "i", "in", "self", ".", "return_features_indices", ":", "\n", "                ", "res", ".", "append", "(", "x", ")", "\n", "", "", "return", "{", "'res{}'", ".", "format", "(", "i", "+", "2", ")", ":", "r", "for", "i", ",", "r", "in", "enumerate", "(", "res", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.MobileNetV2._initialize_weights": [[132, 146], ["mobilenet.MobileNetV2.modules", "isinstance", "m.weight.data.normal_", "isinstance", "m.bias.data.zero_", "m.weight.data.fill_", "m.bias.data.zero_", "isinstance", "m.weight.size", "m.weight.data.normal_", "m.bias.data.zero_"], "methods", ["None"], ["", "def", "_initialize_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "(", "2.", "/", "n", ")", "**", "0.5", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "                ", "n", "=", "m", ".", "weight", ".", "size", "(", "1", ")", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "0.01", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.conv_bn": [[22, 27], ["torch.nn.Sequential", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d", "torch.nn.ReLU6"], "function", ["None"], ["def", "conv_bn", "(", "inp", ",", "oup", ",", "stride", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "inp", ",", "oup", ",", "3", ",", "stride", ",", "1", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "oup", ")", ",", "\n", "nn", ".", "ReLU6", "(", "inplace", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.conv_1x1_bn": [[30, 35], ["torch.nn.Sequential", "detectron2.layers.Conv2d", "detectron2.layers.FrozenBatchNorm2d", "torch.nn.ReLU6"], "function", ["None"], ["", "def", "conv_1x1_bn", "(", "inp", ",", "oup", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "Conv2d", "(", "inp", ",", "oup", ",", "1", ",", "1", ",", "0", ",", "bias", "=", "False", ")", ",", "\n", "FrozenBatchNorm2d", "(", "oup", ")", ",", "\n", "nn", ".", "ReLU6", "(", "inplace", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.build_mnv2_backbone": [[147, 164], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "mobilenet.MobileNetV2"], "function", ["None"], ["", "", "", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_mnv2_backbone", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Create a MobileNetV2 instance from config.\n    Returns:\n        MobileNetV2: a :class:`MobileNetV2` instance.\n    \"\"\"", "\n", "out_features", "=", "cfg", ".", "MODEL", ".", "RESNETS", ".", "OUT_FEATURES", "\n", "\n", "out_feature_channels", "=", "{", "\"res2\"", ":", "24", ",", "\"res3\"", ":", "32", ",", "\n", "\"res4\"", ":", "96", ",", "\"res5\"", ":", "320", "}", "\n", "out_feature_strides", "=", "{", "\"res2\"", ":", "4", ",", "\"res3\"", ":", "8", ",", "\"res4\"", ":", "16", ",", "\"res5\"", ":", "32", "}", "\n", "model", "=", "MobileNetV2", "(", "cfg", ")", "\n", "model", ".", "_out_features", "=", "out_features", "\n", "model", ".", "_out_feature_channels", "=", "out_feature_channels", "\n", "model", ".", "_out_feature_strides", "=", "out_feature_strides", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.build_mobilenetv2_fpn_backbone": [[166, 186], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "mobilenet.build_mnv2_backbone", "detectron2.modeling.backbone.fpn.FPN", "detectron2.modeling.backbone.fpn.LastLevelMaxPool"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.build_mnv2_backbone"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_mobilenetv2_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_mnv2_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "LastLevelMaxPool", "(", ")", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.build_fcos_mobilenetv2_fpn_backbone": [[188, 216], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "mobilenet.build_mnv2_backbone", "detectron2.modeling.backbone.fpn.FPN", "fpn.LastLevelP6P7", "fpn.LastLevelP6"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.build_mnv2_backbone"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_fcos_mobilenetv2_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_mnv2_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "top_levels", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "TOP_LEVELS", "\n", "in_channels_top", "=", "out_channels", "\n", "if", "top_levels", "==", "2", ":", "\n", "        ", "top_block", "=", "LastLevelP6P7", "(", "in_channels_top", ",", "out_channels", ",", "\"p5\"", ")", "\n", "", "if", "top_levels", "==", "1", ":", "\n", "        ", "top_block", "=", "LastLevelP6", "(", "in_channels_top", ",", "out_channels", ",", "\"p5\"", ")", "\n", "", "elif", "top_levels", "==", "0", ":", "\n", "        ", "top_block", "=", "None", "\n", "", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "top_block", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.fpn.LastLevelP6P7.__init__": [[23, 31], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "in_features", "=", "\"res5\"", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_levels", "=", "2", "\n", "self", ".", "in_feature", "=", "in_features", "\n", "self", ".", "p6", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "self", ".", "p7", "=", "nn", ".", "Conv2d", "(", "out_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "for", "module", "in", "[", "self", ".", "p6", ",", "self", ".", "p7", "]", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.fpn.LastLevelP6P7.forward": [[32, 36], ["fpn.LastLevelP6P7.p6", "fpn.LastLevelP6P7.p7", "torch.relu"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "p6", "=", "self", ".", "p6", "(", "x", ")", "\n", "p7", "=", "self", ".", "p7", "(", "F", ".", "relu", "(", "p6", ")", ")", "\n", "return", "[", "p6", ",", "p7", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.fpn.LastLevelP6.__init__": [[43, 50], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "fvcore.c2_xavier_fill"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "in_features", "=", "\"res5\"", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_levels", "=", "1", "\n", "self", ".", "in_feature", "=", "in_features", "\n", "self", ".", "p6", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "3", ",", "2", ",", "1", ")", "\n", "for", "module", "in", "[", "self", ".", "p6", "]", ":", "\n", "            ", "weight_init", ".", "c2_xavier_fill", "(", "module", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.fpn.LastLevelP6.forward": [[51, 54], ["fpn.LastLevelP6.p6"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "p6", "=", "self", ".", "p6", "(", "x", ")", "\n", "return", "[", "p6", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.fpn.build_fcos_resnet_fpn_backbone": [[56, 88], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "detectron2.modeling.backbone.FPN", "build_mnv2_backbone", "detectron2.modeling.backbone.build_resnet_backbone", "fpn.LastLevelP6P7", "fpn.LastLevelP6"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.mobilenet.build_mnv2_backbone"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_fcos_resnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "if", "cfg", ".", "MODEL", ".", "MOBILENET", ":", "\n", "        ", "bottom_up", "=", "build_mnv2_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "", "else", ":", "\n", "        ", "bottom_up", "=", "build_resnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "top_levels", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "TOP_LEVELS", "\n", "in_channels_top", "=", "out_channels", "\n", "if", "top_levels", "==", "2", ":", "\n", "        ", "top_block", "=", "LastLevelP6P7", "(", "in_channels_top", ",", "out_channels", ",", "\"p5\"", ")", "\n", "", "if", "top_levels", "==", "1", ":", "\n", "        ", "top_block", "=", "LastLevelP6", "(", "in_channels_top", ",", "out_channels", ",", "\"p5\"", ")", "\n", "", "elif", "top_levels", "==", "0", ":", "\n", "        ", "top_block", "=", "None", "\n", "", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "top_block", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.DFConv3x3.__init__": [[133, 186], ["torch.Module.__init__", "vovnet.DFConv3x3.module_names.append", "vovnet.DFConv3x3.add_module", "vovnet.DFConv3x3.modules", "vovnet.DFConv3x3.module_names.append", "vovnet.DFConv3x3.add_module", "vovnet.DFConv3x3.module_names.append", "vovnet.DFConv3x3.add_module", "detectron2.layers.Conv2d", "isinstance", "deform_conv_op", "detectron2.layers.get_norm", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "module_name", ",", "\n", "postfix", ",", "\n", "dilation", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "with_modulated_dcn", "=", "None", ",", "\n", "deformable_groups", "=", "1", "\n", ")", ":", "\n", "        ", "super", "(", "DFConv3x3", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "module_names", "=", "[", "]", "\n", "self", ".", "with_modulated_dcn", "=", "with_modulated_dcn", "\n", "if", "self", ".", "with_modulated_dcn", ":", "\n", "            ", "deform_conv_op", "=", "ModulatedDeformConv", "\n", "# offset channels are 2 or 3 (if with modulated) * kernel_size * kernel_size", "\n", "offset_channels", "=", "27", "\n", "", "else", ":", "\n", "            ", "deform_conv_op", "=", "DeformConv", "\n", "offset_channels", "=", "18", "\n", "\n", "", "unit_name", "=", "f\"{module_name}_{postfix}/conv_offset\"", "\n", "self", ".", "module_names", ".", "append", "(", "unit_name", ")", "\n", "self", ".", "add_module", "(", "unit_name", ",", "Conv2d", "(", "\n", "in_channels", ",", "\n", "offset_channels", "*", "deformable_groups", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "dilation", "=", "dilation", ",", "\n", ")", ")", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "0", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n", "", "", "unit_name", "=", "f\"{module_name}_{postfix}/conv\"", "\n", "self", ".", "module_names", ".", "append", "(", "unit_name", ")", "\n", "self", ".", "add_module", "(", "f\"{module_name}_{postfix}/conv\"", ",", "deform_conv_op", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "1", "*", "dilation", ",", "\n", "bias", "=", "False", ",", "\n", "groups", "=", "groups", ",", "\n", "dilation", "=", "1", ",", "\n", "deformable_groups", "=", "deformable_groups", ",", "\n", ")", ")", "\n", "unit_name", "=", "f\"{module_name}_{postfix}/norm\"", "\n", "self", ".", "module_names", ".", "append", "(", "unit_name", ")", "\n", "self", ".", "add_module", "(", "unit_name", ",", "get_norm", "(", "_NORM", ",", "out_channels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.DFConv3x3.forward": [[188, 202], ["torch.relu_", "torch.relu_", "torch.relu_", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "mask.sigmoid.sigmoid.sigmoid", "getattr", "getattr", "getattr", "getattr", "getattr"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "with_modulated_dcn", ":", "\n", "#offset conv", "\n", "            ", "offset_mask", "=", "getattr", "(", "self", ",", "self", ".", "module_names", "[", "0", "]", ")", "(", "x", ")", "\n", "offset_x", ",", "offset_y", ",", "mask", "=", "torch", ".", "chunk", "(", "offset_mask", ",", "3", ",", "dim", "=", "1", ")", "\n", "offset", "=", "torch", ".", "cat", "(", "(", "offset_x", ",", "offset_y", ")", ",", "dim", "=", "1", ")", "\n", "mask", "=", "mask", ".", "sigmoid", "(", ")", "\n", "#conv", "\n", "out", "=", "getattr", "(", "self", ",", "self", ".", "module_names", "[", "1", "]", ")", "(", "x", ",", "offset", ",", "mask", ")", "\n", "", "else", ":", "\n", "            ", "offset", "=", "getattr", "(", "self", ",", "self", ".", "module_names", "[", "0", "]", ")", "(", "x", ")", "\n", "out", "=", "getattr", "(", "self", ",", "self", ".", "module_names", "[", "1", "]", ")", "(", "x", ",", "offset", ")", "\n", "\n", "", "return", "F", ".", "relu_", "(", "getattr", "(", "self", ",", "self", ".", "module_names", "[", "2", "]", ")", "(", "out", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.Hsigmoid.__init__": [[239, 242], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplace", "=", "True", ")", ":", "\n", "        ", "super", "(", "Hsigmoid", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inplace", "=", "inplace", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.Hsigmoid.forward": [[243, 245], ["torch.relu6", "torch.relu6", "torch.relu6"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "F", ".", "relu6", "(", "x", "+", "3.", ",", "inplace", "=", "self", ".", "inplace", ")", "/", "6.", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.eSEModule.__init__": [[248, 254], ["torch.Module.__init__", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "vovnet.Hsigmoid"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channel", ",", "reduction", "=", "4", ")", ":", "\n", "        ", "super", "(", "eSEModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "avg_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Conv2d", "(", "channel", ",", "channel", ",", "kernel_size", "=", "1", ",", "\n", "padding", "=", "0", ")", "\n", "self", ".", "hsigmoid", "=", "Hsigmoid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.eSEModule.forward": [[255, 261], ["vovnet.eSEModule.avg_pool", "vovnet.eSEModule.fc", "vovnet.eSEModule.hsigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "input", "=", "x", "\n", "x", "=", "self", ".", "avg_pool", "(", "x", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "x", "=", "self", ".", "hsigmoid", "(", "x", ")", "\n", "return", "input", "*", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet._OSA_module.__init__": [[265, 308], ["torch.Module.__init__", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "dcn_config.get", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "vovnet.eSEModule", "torch.Sequential", "torch.Sequential", "torch.Sequential", "collections.OrderedDict", "collections.OrderedDict", "vovnet._OSA_module.layers.append", "vovnet.conv1x1", "vovnet.conv1x1", "torch.Sequential", "torch.Sequential", "torch.Sequential", "dcn_config.get", "dcn_config.get", "vovnet._OSA_module.layers.append", "vovnet._OSA_module.layers.append", "collections.OrderedDict", "vovnet.DFConv3x3", "torch.Sequential", "torch.Sequential", "torch.Sequential", "vovnet.dw_conv3x3", "collections.OrderedDict", "vovnet.conv3x3"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.conv1x1", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.conv1x1", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.dw_conv3x3", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.conv3x3"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_ch", ",", "\n", "stage_ch", ",", "\n", "concat_ch", ",", "\n", "layer_per_block", ",", "\n", "module_name", ",", "\n", "SE", "=", "False", ",", "\n", "identity", "=", "False", ",", "\n", "depthwise", "=", "False", ",", "\n", "dcn_config", "=", "{", "}", ",", "\n", ")", ":", "\n", "\n", "        ", "super", "(", "_OSA_module", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "identity", "=", "identity", "\n", "self", ".", "depthwise", "=", "depthwise", "\n", "self", ".", "isReduced", "=", "False", "\n", "self", ".", "layers", "=", "nn", ".", "ModuleList", "(", ")", "\n", "in_channel", "=", "in_ch", "\n", "if", "self", ".", "depthwise", "and", "in_channel", "!=", "stage_ch", ":", "\n", "            ", "self", ".", "isReduced", "=", "True", "\n", "self", ".", "conv_reduction", "=", "nn", ".", "Sequential", "(", "\n", "OrderedDict", "(", "conv1x1", "(", "in_channel", ",", "stage_ch", ",", "\n", "\"{}_reduction\"", ".", "format", "(", "module_name", ")", ",", "\"0\"", ")", ")", ")", "\n", "", "with_dcn", "=", "dcn_config", ".", "get", "(", "\"stage_with_dcn\"", ",", "False", ")", "\n", "for", "i", "in", "range", "(", "layer_per_block", ")", ":", "\n", "            ", "if", "self", ".", "depthwise", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "\n", "nn", ".", "Sequential", "(", "OrderedDict", "(", "dw_conv3x3", "(", "stage_ch", ",", "stage_ch", ",", "module_name", ",", "i", ")", ")", ")", ")", "\n", "", "elif", "with_dcn", ":", "\n", "                ", "deformable_groups", "=", "dcn_config", ".", "get", "(", "\"deformable_groups\"", ",", "1", ")", "\n", "with_modulated_dcn", "=", "dcn_config", ".", "get", "(", "\"with_modulated_dcn\"", ",", "False", ")", "\n", "self", ".", "layers", ".", "append", "(", "DFConv3x3", "(", "in_channel", ",", "stage_ch", ",", "module_name", ",", "i", ",", "\n", "with_modulated_dcn", "=", "with_modulated_dcn", ",", "deformable_groups", "=", "deformable_groups", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "layers", ".", "append", "(", "nn", ".", "Sequential", "(", "OrderedDict", "(", "conv3x3", "(", "in_channel", ",", "stage_ch", ",", "module_name", ",", "i", ")", ")", ")", ")", "\n", "", "in_channel", "=", "stage_ch", "\n", "\n", "# feature aggregation", "\n", "", "in_channel", "=", "in_ch", "+", "layer_per_block", "*", "stage_ch", "\n", "self", ".", "concat", "=", "nn", ".", "Sequential", "(", "OrderedDict", "(", "conv1x1", "(", "in_channel", ",", "concat_ch", ",", "module_name", ",", "\"concat\"", ")", ")", ")", "\n", "\n", "self", ".", "ese", "=", "eSEModule", "(", "concat_ch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet._OSA_module.forward": [[310, 333], ["output.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "vovnet._OSA_module.concat", "vovnet._OSA_module.ese", "vovnet._OSA_module.conv_reduction", "layer", "output.append"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "identity_feat", "=", "x", "\n", "\n", "output", "=", "[", "]", "\n", "output", ".", "append", "(", "x", ")", "\n", "\n", "if", "self", ".", "depthwise", "and", "self", ".", "isReduced", ":", "\n", "            ", "x", "=", "self", ".", "conv_reduction", "(", "x", ")", "\n", "\n", "", "for", "layer", "in", "self", ".", "layers", ":", "\n", "            ", "x", "=", "layer", "(", "x", ")", "\n", "output", ".", "append", "(", "x", ")", "\n", "\n", "", "x", "=", "torch", ".", "cat", "(", "output", ",", "dim", "=", "1", ")", "\n", "xt", "=", "self", ".", "concat", "(", "x", ")", "\n", "\n", "xt", "=", "self", ".", "ese", "(", "xt", ")", "\n", "\n", "if", "self", ".", "identity", ":", "\n", "            ", "xt", "=", "xt", "+", "identity_feat", "\n", "\n", "", "return", "xt", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet._OSA_stage.__init__": [[337, 377], ["torch.Sequential.__init__", "vovnet._OSA_stage.add_module", "range", "vovnet._OSA_stage.add_module", "vovnet._OSA_module", "vovnet._OSA_stage.add_module", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "vovnet._OSA_module"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "in_ch", ",", "\n", "stage_ch", ",", "\n", "concat_ch", ",", "\n", "block_per_stage", ",", "\n", "layer_per_block", ",", "\n", "stage_num", ",", "\n", "SE", "=", "False", ",", "\n", "depthwise", "=", "False", ",", "\n", "dcn_config", "=", "{", "}", ")", ":", "\n", "        ", "super", "(", "_OSA_stage", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "stage_num", "==", "2", ":", "\n", "            ", "self", ".", "add_module", "(", "\"Pooling\"", ",", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", ")", "\n", "\n", "", "if", "block_per_stage", "!=", "1", ":", "\n", "            ", "SE", "=", "False", "\n", "", "module_name", "=", "f\"OSA{stage_num}_1\"", "\n", "self", ".", "add_module", "(", "module_name", ",", "_OSA_module", "(", "in_ch", ",", "\n", "stage_ch", ",", "\n", "concat_ch", ",", "\n", "layer_per_block", ",", "\n", "module_name", ",", "\n", "SE", ",", "\n", "depthwise", "=", "depthwise", ",", "\n", "dcn_config", "=", "dcn_config", ")", ")", "\n", "for", "i", "in", "range", "(", "block_per_stage", "-", "1", ")", ":", "\n", "            ", "if", "i", "!=", "block_per_stage", "-", "2", ":", "#last block", "\n", "                ", "SE", "=", "False", "\n", "", "module_name", "=", "f\"OSA{stage_num}_{i + 2}\"", "\n", "self", ".", "add_module", "(", "module_name", ",", "\n", "_OSA_module", "(", "concat_ch", ",", "\n", "stage_ch", ",", "\n", "concat_ch", ",", "\n", "layer_per_block", ",", "\n", "module_name", ",", "\n", "SE", ",", "\n", "identity", "=", "True", ",", "\n", "depthwise", "=", "depthwise", ",", "\n", "dcn_config", "=", "dcn_config", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet.__init__": [[382, 448], ["detectron2.modeling.backbone.Backbone.__init__", "vovnet.conv3x3", "conv_type", "conv_type", "vovnet.VoVNet.add_module", "range", "vovnet.VoVNet._freeze_backbone", "torch.Sequential", "torch.Sequential", "torch.Sequential", "vovnet.VoVNet.stage_names.append", "vovnet.VoVNet.add_module", "collections.OrderedDict", "vovnet._OSA_stage", "int"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.conv3x3", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet._freeze_backbone"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "input_ch", ",", "out_features", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            input_ch(int) : the number of input channel\n            out_features (list[str]): name of the layers whose outputs should\n                be returned in forward. Can be anything in \"stem\", \"stage2\" ...\n        \"\"\"", "\n", "super", "(", "VoVNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "global", "_NORM", "\n", "_NORM", "=", "cfg", ".", "MODEL", ".", "VOVNET", ".", "NORM", "\n", "\n", "stage_specs", "=", "_STAGE_SPECS", "[", "cfg", ".", "MODEL", ".", "VOVNET", ".", "CONV_BODY", "]", "\n", "\n", "stem_ch", "=", "stage_specs", "[", "\"stem\"", "]", "\n", "config_stage_ch", "=", "stage_specs", "[", "\"stage_conv_ch\"", "]", "\n", "config_concat_ch", "=", "stage_specs", "[", "\"stage_out_ch\"", "]", "\n", "block_per_stage", "=", "stage_specs", "[", "\"block_per_stage\"", "]", "\n", "layer_per_block", "=", "stage_specs", "[", "\"layer_per_block\"", "]", "\n", "SE", "=", "stage_specs", "[", "\"eSE\"", "]", "\n", "depthwise", "=", "stage_specs", "[", "\"dw\"", "]", "\n", "\n", "self", ".", "_out_features", "=", "out_features", "\n", "\n", "\n", "# Stem module", "\n", "conv_type", "=", "dw_conv3x3", "if", "depthwise", "else", "conv3x3", "\n", "stem", "=", "conv3x3", "(", "input_ch", ",", "stem_ch", "[", "0", "]", ",", "\"stem\"", ",", "\"1\"", ",", "2", ")", "\n", "stem", "+=", "conv_type", "(", "stem_ch", "[", "0", "]", ",", "stem_ch", "[", "1", "]", ",", "\"stem\"", ",", "\"2\"", ",", "1", ")", "\n", "stem", "+=", "conv_type", "(", "stem_ch", "[", "1", "]", ",", "stem_ch", "[", "2", "]", ",", "\"stem\"", ",", "\"3\"", ",", "2", ")", "\n", "self", ".", "add_module", "(", "\"stem\"", ",", "nn", ".", "Sequential", "(", "(", "OrderedDict", "(", "stem", ")", ")", ")", ")", "\n", "current_stirde", "=", "4", "\n", "self", ".", "_out_feature_strides", "=", "{", "\"stem\"", ":", "current_stirde", ",", "\"stage2\"", ":", "current_stirde", "}", "\n", "self", ".", "_out_feature_channels", "=", "{", "\"stem\"", ":", "stem_ch", "[", "2", "]", "}", "\n", "\n", "stem_out_ch", "=", "[", "stem_ch", "[", "2", "]", "]", "\n", "in_ch_list", "=", "stem_out_ch", "+", "config_concat_ch", "[", ":", "-", "1", "]", "\n", "# OSA stages", "\n", "self", ".", "stage_names", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "# num_stages", "\n", "            ", "name", "=", "\"stage%d\"", "%", "(", "i", "+", "2", ")", "# stage 2 ... stage 5", "\n", "self", ".", "stage_names", ".", "append", "(", "name", ")", "\n", "self", ".", "add_module", "(", "name", ",", "_OSA_stage", "(", "in_ch_list", "[", "i", "]", ",", "\n", "config_stage_ch", "[", "i", "]", ",", "\n", "config_concat_ch", "[", "i", "]", ",", "\n", "block_per_stage", "[", "i", "]", ",", "\n", "layer_per_block", ",", "\n", "i", "+", "2", ",", "\n", "SE", ",", "\n", "depthwise", ",", "\n", "dcn_config", "=", "{", "\n", "\"stage_with_dcn\"", ":", "cfg", ".", "MODEL", ".", "VOVNET", ".", "STAGE_WITH_DCN", "[", "i", "]", ",", "\n", "\"with_modulated_dcn\"", ":", "cfg", ".", "MODEL", ".", "VOVNET", ".", "WITH_MODULATED_DCN", ",", "\n", "\"deformable_groups\"", ":", "cfg", ".", "MODEL", ".", "VOVNET", ".", "DEFORMABLE_GROUPS", ",", "\n", "}", "\n", ")", ")", "\n", "\n", "self", ".", "_out_feature_channels", "[", "name", "]", "=", "config_concat_ch", "[", "i", "]", "\n", "if", "not", "i", "==", "0", ":", "\n", "                ", "self", ".", "_out_feature_strides", "[", "name", "]", "=", "current_stirde", "=", "int", "(", "\n", "current_stirde", "*", "2", ")", "\n", "\n", "# initialize weights", "\n", "# self._initialize_weights()", "\n", "# Optionally freeze (requires_grad=False) parts of the backbone", "\n", "", "", "self", ".", "_freeze_backbone", "(", "cfg", ".", "MODEL", ".", "BACKBONE", ".", "FREEZE_AT", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet._initialize_weights": [[450, 454], ["vovnet.VoVNet.modules", "isinstance", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_"], "methods", ["None"], ["", "def", "_initialize_weights", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet._freeze_backbone": [[455, 470], ["vovnet.VoVNet.modules", "range", "isinstance", "getattr.parameters", "freeze_bn_params", "getattr", "detectron2.layers.FrozenBatchNorm2d.convert_frozen_batchnorm", "str"], "methods", ["None"], ["", "", "", "def", "_freeze_backbone", "(", "self", ",", "freeze_at", ")", ":", "\n", "        ", "if", "freeze_at", "<", "0", ":", "\n", "            ", "return", "\n", "# freeze BN layers", "\n", "", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "freeze_bn_params", "(", "m", ")", "\n", "", "", "for", "stage_index", "in", "range", "(", "freeze_at", ")", ":", "\n", "            ", "if", "stage_index", "==", "0", ":", "\n", "                ", "m", "=", "self", ".", "stem", "# stage 0 is the stem", "\n", "", "else", ":", "\n", "                ", "m", "=", "getattr", "(", "self", ",", "\"stage\"", "+", "str", "(", "stage_index", "+", "1", ")", ")", "\n", "", "for", "p", "in", "m", ".", "parameters", "(", ")", ":", "\n", "                ", "p", ".", "requires_grad", "=", "False", "\n", "FrozenBatchNorm2d", ".", "convert_frozen_batchnorm", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet.forward": [[471, 482], ["vovnet.VoVNet.stem", "getattr"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "outputs", "=", "{", "}", "\n", "x", "=", "self", ".", "stem", "(", "x", ")", "\n", "if", "\"stem\"", "in", "self", ".", "_out_features", ":", "\n", "            ", "outputs", "[", "\"stem\"", "]", "=", "x", "\n", "", "for", "name", "in", "self", ".", "stage_names", ":", "\n", "            ", "x", "=", "getattr", "(", "self", ",", "name", ")", "(", "x", ")", "\n", "if", "name", "in", "self", ".", "_out_features", ":", "\n", "                ", "outputs", "[", "name", "]", "=", "x", "\n", "\n", "", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.VoVNet.output_shape": [[483, 489], ["detectron2.layers.ShapeSpec"], "methods", ["None"], ["", "def", "output_shape", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "name", ":", "ShapeSpec", "(", "\n", "channels", "=", "self", ".", "_out_feature_channels", "[", "name", "]", ",", "stride", "=", "self", ".", "_out_feature_strides", "[", "name", "]", "\n", ")", "\n", "for", "name", "in", "self", ".", "_out_features", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.dw_conv3x3": [[110, 130], ["torch.Conv2d", "torch.Conv2d", "detectron2.layers.get_norm", "torch.ReLU"], "function", ["None"], ["def", "dw_conv3x3", "(", "in_channels", ",", "out_channels", ",", "module_name", ",", "postfix", ",", "\n", "stride", "=", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "[", "\n", "(", "'{}_{}/dw_conv3x3'", ".", "format", "(", "module_name", ",", "postfix", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "groups", "=", "out_channels", ",", "\n", "bias", "=", "False", ")", ")", ",", "\n", "(", "'{}_{}/pw_conv1x1'", ".", "format", "(", "module_name", ",", "postfix", ")", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "\n", "kernel_size", "=", "1", ",", "\n", "stride", "=", "1", ",", "\n", "padding", "=", "0", ",", "\n", "groups", "=", "1", ",", "\n", "bias", "=", "False", ")", ")", ",", "\n", "(", "'{}_{}/pw_norm'", ".", "format", "(", "module_name", ",", "postfix", ")", ",", "get_norm", "(", "_NORM", ",", "out_channels", ")", ")", ",", "\n", "(", "'{}_{}/pw_relu'", ".", "format", "(", "module_name", ",", "postfix", ")", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", ",", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.conv3x3": [[205, 219], ["torch.Conv2d", "detectron2.layers.get_norm", "torch.ReLU"], "function", ["None"], ["", "", "def", "conv3x3", "(", "in_channels", ",", "out_channels", ",", "module_name", ",", "postfix", ",", "\n", "stride", "=", "1", ",", "groups", "=", "1", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "[", "\n", "(", "f'{module_name}_{postfix}/conv'", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", ")", ",", "\n", "(", "f'{module_name}_{postfix}/norm'", ",", "get_norm", "(", "_NORM", ",", "out_channels", ")", ")", ",", "\n", "(", "f'{module_name}_{postfix}/relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.conv1x1": [[222, 236], ["torch.Conv2d", "detectron2.layers.get_norm", "torch.ReLU"], "function", ["None"], ["", "def", "conv1x1", "(", "in_channels", ",", "out_channels", ",", "module_name", ",", "postfix", ",", "\n", "stride", "=", "1", ",", "groups", "=", "1", ",", "kernel_size", "=", "1", ",", "padding", "=", "0", ")", ":", "\n", "    ", "\"\"\"1x1 convolution with padding\"\"\"", "\n", "return", "[", "\n", "(", "f'{module_name}_{postfix}/conv'", ",", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "False", ")", ")", ",", "\n", "(", "f'{module_name}_{postfix}/norm'", ",", "get_norm", "(", "_NORM", ",", "out_channels", ")", ")", ",", "\n", "(", "f'{module_name}_{postfix}/relu'", ",", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.build_vovnet_backbone": [[492, 502], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "vovnet.VoVNet"], "function", ["None"], ["", "", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_vovnet_backbone", "(", "cfg", ",", "input_shape", ")", ":", "\n", "    ", "\"\"\"\n    Create a VoVNet instance from config.\n\n    Returns:\n        VoVNet: a :class:`VoVNet` instance.\n    \"\"\"", "\n", "out_features", "=", "cfg", ".", "MODEL", ".", "VOVNET", ".", "OUT_FEATURES", "\n", "return", "VoVNet", "(", "cfg", ",", "input_shape", ".", "channels", ",", "out_features", "=", "out_features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.build_vovnet_fpn_backbone": [[504, 525], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "vovnet.build_vovnet_backbone", "detectron2.modeling.backbone.fpn.FPN", "detectron2.modeling.backbone.fpn.LastLevelMaxPool"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.build_vovnet_backbone"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_vovnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_vovnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "LastLevelMaxPool", "(", ")", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.build_fcos_vovnet_fpn_backbone": [[527, 556], ["detectron2.modeling.backbone.build.BACKBONE_REGISTRY.register", "vovnet.build_vovnet_backbone", "detectron2.modeling.backbone.fpn.FPN", "fpn.LastLevelP6P7", "fpn.LastLevelP6"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.backbone.vovnet.build_vovnet_backbone"], ["", "@", "BACKBONE_REGISTRY", ".", "register", "(", ")", "\n", "def", "build_fcos_vovnet_fpn_backbone", "(", "cfg", ",", "input_shape", ":", "ShapeSpec", ")", ":", "\n", "    ", "\"\"\"\n    Args:\n        cfg: a detectron2 CfgNode\n\n    Returns:\n        backbone (Backbone): backbone module, must be a subclass of :class:`Backbone`.\n    \"\"\"", "\n", "bottom_up", "=", "build_vovnet_backbone", "(", "cfg", ",", "input_shape", ")", "\n", "in_features", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "IN_FEATURES", "\n", "out_channels", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "OUT_CHANNELS", "\n", "top_levels", "=", "cfg", ".", "MODEL", ".", "FCOS", ".", "TOP_LEVELS", "\n", "in_channels_top", "=", "out_channels", "\n", "if", "top_levels", "==", "2", ":", "\n", "        ", "top_block", "=", "LastLevelP6P7", "(", "in_channels_top", ",", "out_channels", ",", "\"p5\"", ")", "\n", "", "if", "top_levels", "==", "1", ":", "\n", "        ", "top_block", "=", "LastLevelP6", "(", "in_channels_top", ",", "out_channels", ",", "\"p5\"", ")", "\n", "", "elif", "top_levels", "==", "0", ":", "\n", "        ", "top_block", "=", "None", "\n", "", "backbone", "=", "FPN", "(", "\n", "bottom_up", "=", "bottom_up", ",", "\n", "in_features", "=", "in_features", ",", "\n", "out_channels", "=", "out_channels", ",", "\n", "norm", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "NORM", ",", "\n", "top_block", "=", "top_block", ",", "\n", "fuse_type", "=", "cfg", ".", "MODEL", ".", "FPN", ".", "FUSE_TYPE", ",", "\n", ")", "\n", "return", "backbone", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.config.config.get_cfg": [[4, 14], ["_C.clone"], "function", ["None"], ["def", "get_cfg", "(", ")", "->", "CfgNode", ":", "\n", "    ", "\"\"\"\n    Get a copy of the default config.\n\n    Returns:\n        a detectron2 CfgNode instance.\n    \"\"\"", "\n", "from", ".", "defaults", "import", "_C", "\n", "\n", "return", "_C", ".", "clone", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers._NewEmptyTensorOp.forward": [[8, 12], ["x.new_empty"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "new_shape", ")", ":", "\n", "        ", "ctx", ".", "shape", "=", "x", ".", "shape", "\n", "return", "x", ".", "new_empty", "(", "new_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers._NewEmptyTensorOp.backward": [[13, 17], ["_NewEmptyTensorOp.apply"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad", ")", ":", "\n", "        ", "shape", "=", "ctx", ".", "shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "grad", ",", "shape", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.MaxPool2d.__init__": [[24, 27], ["super().__init__", "wrappers.MaxPool2d._make_iteratable"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.MaxPool2d._make_iteratable"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_make_iteratable", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.MaxPool2d.forward": [[28, 49], ["super().forward", "super().forward.numel", "_NewEmptyTensorOp.apply", "zip"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.iou_loss.IOULoss.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "# When input is empty, we want to return a empty tensor with \"correct\" shape,", "\n", "# So that the following operations will not panic", "\n", "# if they check for the shape of the tensor.", "\n", "# This computes the height and width of the output tensor", "\n", "\n", "            ", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "s", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "s", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "self", ".", "padding", ",", "self", ".", "dilation", ",", "self", ".", "kernel_size", ",", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", "]", "+", "output_shape", "\n", "empty", "=", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "\n", "return", "empty", "\n", "\n", "", "x", "=", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.MaxPool2d._make_iteratable": [[50, 62], ["isinstance", "isinstance", "isinstance", "isinstance"], "methods", ["None"], ["", "def", "_make_iteratable", "(", "self", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "self", ".", "padding", ",", "list", ")", ":", "\n", "            ", "self", ".", "padding", "=", "[", "self", ".", "padding", ",", "self", ".", "padding", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "self", ".", "dilation", ",", "list", ")", ":", "\n", "            ", "self", ".", "dilation", "=", "[", "self", ".", "dilation", ",", "self", ".", "dilation", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "self", ".", "kernel_size", ",", "list", ")", ":", "\n", "            ", "self", ".", "kernel_size", "=", "[", "self", ".", "kernel_size", ",", "self", ".", "kernel_size", "]", "\n", "\n", "", "if", "not", "isinstance", "(", "self", ".", "stride", ",", "list", ")", ":", "\n", "            ", "self", ".", "stride", "=", "[", "self", ".", "stride", ",", "self", ".", "stride", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.Linear.__init__": [[70, 72], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.Linear.forward": [[73, 88], ["super().forward", "super().forward.numel", "_NewEmptyTensorOp.apply", "sum", "super().forward.view", "wrappers.Linear.parameters"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.iou_loss.IOULoss.forward"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "            ", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "weight", ".", "shape", "[", "0", "]", "]", "\n", "\n", "empty", "=", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "if", "self", ".", "training", ":", "\n", "# This is to make DDP happy.", "\n", "# DDP expects all workers to have gradient w.r.t the same set of parameters.", "\n", "                ", "_dummy", "=", "sum", "(", "x", ".", "view", "(", "-", "1", ")", "[", "0", "]", "for", "x", "in", "self", ".", "parameters", "(", ")", ")", "*", "0.0", "\n", "return", "empty", "+", "_dummy", "\n", "", "else", ":", "\n", "                ", "return", "empty", "\n", "\n", "", "", "x", "=", "super", "(", ")", ".", "forward", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.wrappers.Max": [[90, 99], ["x.numel", "_NewEmptyTensorOp.apply", "torch.max"], "function", ["None"], ["", "", "def", "Max", "(", "x", ")", ":", "\n", "    ", "\"\"\"\n    A wrapper around torch.max in Spatial Attention Module (SAM) to support empty inputs and more features.\n    \"\"\"", "\n", "if", "x", ".", "numel", "(", ")", "==", "0", ":", "\n", "        ", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "1", ",", "x", ".", "shape", "[", "2", "]", ",", "x", ".", "shape", "[", "3", "]", "]", "\n", "empty", "=", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "return", "empty", "\n", "", "return", "torch", ".", "max", "(", "x", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.ml_nms.ml_nms": [[4, 26], ["detectron2.layers.batched_nms"], "function", ["None"], ["def", "ml_nms", "(", "boxlist", ",", "nms_thresh", ",", "max_proposals", "=", "-", "1", ",", "\n", "score_field", "=", "\"scores\"", ",", "label_field", "=", "\"labels\"", ")", ":", "\n", "    ", "\"\"\"\n    Performs non-maximum suppression on a boxlist, with scores specified\n    in a boxlist field via score_field.\n    Arguments:\n        boxlist(BoxList)\n        nms_thresh (float)\n        max_proposals (int): if > 0, then only the top max_proposals are kept\n            after non-maximum suppression\n        score_field (str)\n    \"\"\"", "\n", "if", "nms_thresh", "<=", "0", ":", "\n", "        ", "return", "boxlist", "\n", "", "boxes", "=", "boxlist", ".", "pred_boxes", ".", "tensor", "\n", "scores", "=", "boxlist", ".", "scores", "\n", "labels", "=", "boxlist", ".", "pred_classes", "\n", "keep", "=", "batched_nms", "(", "boxes", ",", "scores", ",", "labels", ",", "nms_thresh", ")", "\n", "if", "max_proposals", ">", "0", ":", "\n", "        ", "keep", "=", "keep", "[", ":", "max_proposals", "]", "\n", "", "boxlist", "=", "boxlist", "[", "keep", "]", "\n", "return", "boxlist", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.deform_conv._NewEmptyTensorOp.forward": [[8, 12], ["x.new_empty"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "x", ",", "new_shape", ")", ":", "\n", "        ", "ctx", ".", "shape", "=", "x", ".", "shape", "\n", "return", "x", ".", "new_empty", "(", "new_shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.deform_conv._NewEmptyTensorOp.backward": [[13, 17], ["_NewEmptyTensorOp.apply"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad", ")", ":", "\n", "        ", "shape", "=", "ctx", ".", "shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "grad", ",", "shape", ")", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.deform_conv.DFConv2d.__init__": [[21, 86], ["torch.nn.Module.__init__", "isinstance", "detectron2.layers.Conv2d", "conv_block", "isinstance", "isinstance", "torch.nn.init.kaiming_uniform_", "torch.nn.init.constant_", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "with_modulated_dcn", "=", "True", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "1", ",", "\n", "groups", "=", "1", ",", "\n", "dilation", "=", "1", ",", "\n", "deformable_groups", "=", "1", ",", "\n", "bias", "=", "False", ",", "\n", "padding", "=", "None", "\n", ")", ":", "\n", "        ", "super", "(", "DFConv2d", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "isinstance", "(", "kernel_size", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "            ", "assert", "isinstance", "(", "stride", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "isinstance", "(", "dilation", ",", "(", "list", ",", "tuple", ")", ")", "\n", "assert", "len", "(", "kernel_size", ")", "==", "2", "\n", "assert", "len", "(", "stride", ")", "==", "2", "\n", "assert", "len", "(", "dilation", ")", "==", "2", "\n", "padding", "=", "(", "\n", "dilation", "[", "0", "]", "*", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "//", "2", ",", "\n", "dilation", "[", "1", "]", "*", "(", "kernel_size", "[", "1", "]", "-", "1", ")", "//", "2", "\n", ")", "\n", "offset_base_channels", "=", "kernel_size", "[", "0", "]", "*", "kernel_size", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "padding", "=", "dilation", "*", "(", "kernel_size", "-", "1", ")", "//", "2", "\n", "offset_base_channels", "=", "kernel_size", "*", "kernel_size", "\n", "", "if", "with_modulated_dcn", ":", "\n", "            ", "from", ".", "deform_conv", "import", "ModulatedDeformConv", "\n", "offset_channels", "=", "offset_base_channels", "*", "3", "# default: 27", "\n", "conv_block", "=", "ModulatedDeformConv", "\n", "", "else", ":", "\n", "            ", "from", ".", "deform_conv", "import", "DeformConv", "\n", "offset_channels", "=", "offset_base_channels", "*", "2", "# default: 18", "\n", "conv_block", "=", "DeformConv", "\n", "", "self", ".", "offset", "=", "Conv2d", "(", "\n", "in_channels", ",", "\n", "deformable_groups", "*", "offset_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "groups", "=", "1", ",", "\n", "dilation", "=", "dilation", "\n", ")", "\n", "for", "l", "in", "[", "self", ".", "offset", ",", "]", ":", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "l", ".", "weight", ",", "a", "=", "1", ")", "\n", "torch", ".", "nn", ".", "init", ".", "constant_", "(", "l", ".", "bias", ",", "0.", ")", "\n", "", "self", ".", "conv", "=", "conv_block", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "padding", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "deformable_groups", "=", "deformable_groups", ",", "\n", "bias", "=", "bias", "\n", ")", "\n", "self", ".", "with_modulated_dcn", "=", "with_modulated_dcn", "\n", "self", ".", "kernel_size", "=", "kernel_size", "\n", "self", ".", "stride", "=", "stride", "\n", "self", ".", "padding", "=", "padding", "\n", "self", ".", "dilation", "=", "dilation", "\n", "self", ".", "offset_split", "=", "offset_base_channels", "*", "deformable_groups", "*", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.deform_conv.DFConv2d.forward": [[87, 113], ["_NewEmptyTensorOp.apply", "deform_conv.DFConv2d.numel", "deform_conv.DFConv2d.offset", "deform_conv.DFConv2d.conv", "deform_conv.DFConv2d.offset", "offset_mask[].sigmoid", "deform_conv.DFConv2d.conv", "zip"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "return_offset", "=", "False", ")", ":", "\n", "        ", "if", "x", ".", "numel", "(", ")", ">", "0", ":", "\n", "            ", "if", "not", "self", ".", "with_modulated_dcn", ":", "\n", "                ", "offset_mask", "=", "self", ".", "offset", "(", "x", ")", "\n", "x", "=", "self", ".", "conv", "(", "x", ",", "offset_mask", ")", "\n", "", "else", ":", "\n", "                ", "offset_mask", "=", "self", ".", "offset", "(", "x", ")", "\n", "offset", "=", "offset_mask", "[", ":", ",", ":", "self", ".", "offset_split", ",", ":", ",", ":", "]", "\n", "mask", "=", "offset_mask", "[", ":", ",", "self", ".", "offset_split", ":", ",", ":", ",", ":", "]", ".", "sigmoid", "(", ")", "\n", "x", "=", "self", ".", "conv", "(", "x", ",", "offset", ",", "mask", ")", "\n", "", "if", "return_offset", ":", "\n", "                ", "return", "x", ",", "offset_mask", "\n", "", "return", "x", "\n", "# get output shape", "\n", "", "output_shape", "=", "[", "\n", "(", "i", "+", "2", "*", "p", "-", "(", "di", "*", "(", "k", "-", "1", ")", "+", "1", ")", ")", "//", "d", "+", "1", "\n", "for", "i", ",", "p", ",", "di", ",", "k", ",", "d", "in", "zip", "(", "\n", "x", ".", "shape", "[", "-", "2", ":", "]", ",", "\n", "self", ".", "padding", ",", "\n", "self", ".", "dilation", ",", "\n", "self", ".", "kernel_size", ",", "\n", "self", ".", "stride", "\n", ")", "\n", "]", "\n", "output_shape", "=", "[", "x", ".", "shape", "[", "0", "]", ",", "self", ".", "conv", ".", "weight", ".", "shape", "[", "0", "]", "]", "+", "output_shape", "\n", "return", "_NewEmptyTensorOp", ".", "apply", "(", "x", ",", "output_shape", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.iou_loss.IOULoss.__init__": [[6, 9], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "loc_loss_type", "=", "'iou'", ")", ":", "\n", "        ", "super", "(", "IOULoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "loc_loss_type", "=", "loc_loss_type", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.iou_loss.IOULoss.forward": [[10, 55], ["torch.min", "torch.min", "torch.min", "torch.min", "torch.max", "torch.max", "torch.max", "torch.max", "losses.sum", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "weight", "=", "None", ")", ":", "\n", "        ", "pred_left", "=", "pred", "[", ":", ",", "0", "]", "\n", "pred_top", "=", "pred", "[", ":", ",", "1", "]", "\n", "pred_right", "=", "pred", "[", ":", ",", "2", "]", "\n", "pred_bottom", "=", "pred", "[", ":", ",", "3", "]", "\n", "\n", "target_left", "=", "target", "[", ":", ",", "0", "]", "\n", "target_top", "=", "target", "[", ":", ",", "1", "]", "\n", "target_right", "=", "target", "[", ":", ",", "2", "]", "\n", "target_bottom", "=", "target", "[", ":", ",", "3", "]", "\n", "\n", "target_aera", "=", "(", "target_left", "+", "target_right", ")", "*", "(", "target_top", "+", "target_bottom", ")", "\n", "pred_aera", "=", "(", "pred_left", "+", "pred_right", ")", "*", "(", "pred_top", "+", "pred_bottom", ")", "\n", "\n", "w_intersect", "=", "torch", ".", "min", "(", "pred_left", ",", "target_left", ")", "+", "torch", ".", "min", "(", "pred_right", ",", "target_right", ")", "\n", "h_intersect", "=", "torch", ".", "min", "(", "pred_bottom", ",", "target_bottom", ")", "+", "torch", ".", "min", "(", "pred_top", ",", "target_top", ")", "\n", "\n", "g_w_intersect", "=", "torch", ".", "max", "(", "pred_left", ",", "target_left", ")", "+", "torch", ".", "max", "(", "pred_right", ",", "target_right", ")", "\n", "g_h_intersect", "=", "torch", ".", "max", "(", "pred_bottom", ",", "target_bottom", ")", "+", "torch", ".", "max", "(", "pred_top", ",", "target_top", ")", "\n", "ac_uion", "=", "g_w_intersect", "*", "g_h_intersect", "\n", "\n", "area_intersect", "=", "w_intersect", "*", "h_intersect", "\n", "area_union", "=", "target_aera", "+", "pred_aera", "-", "area_intersect", "\n", "\n", "ious", "=", "(", "area_intersect", "+", "1.0", ")", "/", "(", "area_union", "+", "1.0", ")", "\n", "gious", "=", "ious", "-", "(", "ac_uion", "-", "area_union", ")", "/", "ac_uion", "\n", "if", "self", ".", "loc_loss_type", "==", "'iou'", ":", "\n", "            ", "losses", "=", "-", "torch", ".", "log", "(", "ious", ")", "\n", "", "elif", "self", ".", "loc_loss_type", "==", "'linear_iou'", ":", "\n", "            ", "losses", "=", "1", "-", "ious", "\n", "", "elif", "self", ".", "loc_loss_type", "==", "'giou'", ":", "\n", "            ", "losses", "=", "1", "-", "gious", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "if", "weight", "is", "not", "None", ":", "\n", "            ", "return", "(", "losses", "*", "weight", ")", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "return", "losses", ".", "sum", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.layers.conv_with_kaiming_uniform.conv_with_kaiming_uniform": [[8, 53], ["conv_func", "torch.nn.init.kaiming_uniform_", "module.append", "module.append", "len", "torch.nn.Sequential", "torch.nn.init.constant_", "torch.nn.GroupNorm", "detectron2.layers.batch_norm.get_norm", "torch.nn.ReLU"], "function", ["None"], ["def", "conv_with_kaiming_uniform", "(", "\n", "norm", "=", "None", ",", "activation", "=", "None", ",", "\n", "use_deformable", "=", "False", ",", "use_sep", "=", "False", ")", ":", "\n", "    ", "def", "make_conv", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "stride", "=", "1", ",", "dilation", "=", "1", "\n", ")", ":", "\n", "        ", "if", "use_deformable", ":", "\n", "            ", "conv_func", "=", "DFConv2d", "\n", "", "else", ":", "\n", "            ", "conv_func", "=", "Conv2d", "\n", "", "if", "use_sep", ":", "\n", "            ", "assert", "in_channels", "==", "out_channels", "\n", "groups", "=", "in_channels", "\n", "", "else", ":", "\n", "            ", "groups", "=", "1", "\n", "", "conv", "=", "conv_func", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "dilation", "*", "(", "kernel_size", "-", "1", ")", "//", "2", ",", "\n", "dilation", "=", "dilation", ",", "\n", "groups", "=", "groups", ",", "\n", "bias", "=", "(", "norm", "is", "None", ")", "\n", ")", "\n", "if", "not", "use_deformable", ":", "\n", "# Caffe2 implementation uses XavierFill, which in fact", "\n", "# corresponds to kaiming_uniform_ in PyTorch", "\n", "            ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "conv", ".", "weight", ",", "a", "=", "1", ")", "\n", "if", "norm", "is", "None", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "conv", ".", "bias", ",", "0", ")", "\n", "", "", "module", "=", "[", "conv", ",", "]", "\n", "if", "norm", "is", "not", "None", ":", "\n", "            ", "if", "norm", "==", "\"GN\"", ":", "\n", "                ", "norm_module", "=", "nn", ".", "GroupNorm", "(", "32", ",", "out_channels", ")", "\n", "", "else", ":", "\n", "                ", "norm_module", "=", "get_norm", "(", "norm", ",", "out_channels", ")", "\n", "", "module", ".", "append", "(", "norm_module", ")", "\n", "", "if", "activation", "is", "not", "None", ":", "\n", "            ", "module", ".", "append", "(", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ")", "\n", "", "if", "len", "(", "module", ")", ">", "1", ":", "\n", "            ", "return", "nn", ".", "Sequential", "(", "*", "module", ")", "\n", "", "return", "conv", "\n", "\n", "", "return", "make_conv", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.checkpoint.adet_checkpoint.AdetCheckpointer._load_file": [[7, 29], ["filename.endswith", "super()._load_file", "fvcore.common.file_io.PathManager.open", "pickle.load", "adet_checkpoint.AdetCheckpointer.logger.info", "pickle.load.items", "k.endswith"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.checkpoint.adet_checkpoint.AdetCheckpointer._load_file"], ["    ", "def", "_load_file", "(", "self", ",", "filename", ")", ":", "\n", "        ", "if", "filename", ".", "endswith", "(", "\".pkl\"", ")", ":", "\n", "            ", "with", "PathManager", ".", "open", "(", "filename", ",", "\"rb\"", ")", "as", "f", ":", "\n", "                ", "data", "=", "pickle", ".", "load", "(", "f", ",", "encoding", "=", "\"latin1\"", ")", "\n", "", "if", "\"model\"", "in", "data", "and", "\"__author__\"", "in", "data", ":", "\n", "# file is in Detectron2 model zoo format", "\n", "                ", "self", ".", "logger", ".", "info", "(", "\"Reading a file from '{}'\"", ".", "format", "(", "data", "[", "\"__author__\"", "]", ")", ")", "\n", "return", "data", "\n", "", "else", ":", "\n", "# assume file is from Caffe2 / Detectron1 model zoo", "\n", "                ", "if", "\"blobs\"", "in", "data", ":", "\n", "# Detection models have \"blobs\", but ImageNet models don't", "\n", "                    ", "data", "=", "data", "[", "\"blobs\"", "]", "\n", "", "data", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "data", ".", "items", "(", ")", "if", "not", "k", ".", "endswith", "(", "\"_momentum\"", ")", "}", "\n", "return", "{", "\"model\"", ":", "data", ",", "\"__author__\"", ":", "\"Caffe2\"", ",", "\"matching_heuristics\"", ":", "True", "}", "\n", "\n", "", "", "loaded", "=", "super", "(", ")", ".", "_load_file", "(", "filename", ")", "# load native pth checkpoint", "\n", "if", "\"model\"", "not", "in", "loaded", ":", "\n", "            ", "loaded", "=", "{", "\"model\"", ":", "loaded", "}", "\n", "", "if", "\"lpf\"", "in", "filename", ":", "\n", "            ", "loaded", "[", "\"matching_heuristics\"", "]", "=", "True", "\n", "", "return", "loaded", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator.__init__": [[38, 87], ["coco_evaluation.COCOEvaluator._tasks_from_config", "torch.device", "logging.getLogger", "detectron2.data.MetadataCatalog.get", "pathlib.Path().mkdir", "coco_evaluation.COCOEvaluator._saliency_map_dir.mkdir", "fvcore.common.file_io.PathManager.get_local_path", "pathlib.Path", "hasattr", "coco_evaluation.COCOEvaluator._logger.warning", "os.path.join", "detectron2.data.datasets.coco.convert_to_coco_json", "contextlib.redirect_stdout", "pycocotools.coco.COCO", "pathlib.Path", "io.StringIO"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["def", "__init__", "(", "self", ",", "dataset_name", ",", "cfg", ",", "distributed", ",", "output_dir", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_name (str): name of the dataset to be evaluated.\n                It must have either the following corresponding metadata:\n                    \"json_file\": the path to the COCO format annotation\n                Or it must be in detectron2's standard dataset format\n                so it can be converted to COCO format automatically.\n            cfg (CfgNode): config instance\n            distributed (True): if True, will collect results from all ranks for evaluation.\n                Otherwise, will evaluate the results in the current process.\n            output_dir (str): optional, an output directory to dump all\n                results predicted on the dataset. The dump contains two files:\n                1. \"instance_predictions.pth\" a file in torch serialization\n                   format that contains all the raw original predictions.\n                2. \"coco_instances_results.json\" a json file in COCO's result\n                   format.\n        \"\"\"", "\n", "self", ".", "_tasks", "=", "self", ".", "_tasks_from_config", "(", "cfg", ")", "\n", "self", ".", "_distributed", "=", "distributed", "\n", "self", ".", "_output_dir", "=", "output_dir", "\n", "\n", "self", ".", "_cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "_logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "\n", "self", ".", "_metadata", "=", "MetadataCatalog", ".", "get", "(", "dataset_name", ")", "\n", "self", ".", "_saliency_map_dir", "=", "Path", "(", "self", ".", "_output_dir", ")", "/", "'saliency_map'", "\n", "Path", "(", "self", ".", "_output_dir", ")", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "self", ".", "_saliency_map_dir", ".", "mkdir", "(", "exist_ok", "=", "True", ")", "\n", "\n", "if", "not", "hasattr", "(", "self", ".", "_metadata", ",", "\"json_file\"", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\n", "f\"json_file was not found in MetaDataCatalog for '{dataset_name}'.\"", "\n", "\" Trying to convert it to COCO format ...\"", "\n", ")", "\n", "\n", "cache_path", "=", "os", ".", "path", ".", "join", "(", "\n", "output_dir", ",", "f\"{dataset_name}_coco_format.json\"", ")", "\n", "self", ".", "_metadata", ".", "json_file", "=", "cache_path", "\n", "convert_to_coco_json", "(", "dataset_name", ",", "cache_path", ")", "\n", "\n", "", "json_file", "=", "PathManager", ".", "get_local_path", "(", "self", ".", "_metadata", ".", "json_file", ")", "\n", "with", "contextlib", ".", "redirect_stdout", "(", "io", ".", "StringIO", "(", ")", ")", ":", "\n", "            ", "self", ".", "_coco_api", "=", "COCO", "(", "json_file", ")", "\n", "\n", "", "self", ".", "_kpt_oks_sigmas", "=", "cfg", ".", "TEST", ".", "KEYPOINT_OKS_SIGMAS", "\n", "# Test set json files do not contain annotations (evaluation must be", "\n", "# performed using the COCO evaluation server).", "\n", "self", ".", "_do_evaluation", "=", "\"annotations\"", "in", "self", ".", "_coco_api", ".", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator.reset": [[88, 90], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "_predictions", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._tasks_from_config": [[91, 102], ["None"], "methods", ["None"], ["", "def", "_tasks_from_config", "(", "self", ",", "cfg", ")", ":", "\n", "        ", "\"\"\"\n        Returns:\n            tuple[str]: tasks that can be evaluated under the given configuration.\n        \"\"\"", "\n", "tasks", "=", "(", "\"bbox\"", ",", ")", "\n", "if", "cfg", ".", "MODEL", ".", "MASK_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"segm\"", ",", ")", "\n", "", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "tasks", "=", "tasks", "+", "(", "\"keypoints\"", ",", ")", "\n", "", "return", "tasks", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator.process": [[103, 128], ["zip", "coco_evaluation.COCOEvaluator._predictions.append", "output[].to", "coco_evaluation.instances_to_coco_json", "output[].to"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.instances_to_coco_json"], ["", "def", "process", "(", "self", ",", "inputs", ",", "outputs", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            inputs: the inputs to a COCO model (e.g., GeneralizedRCNN).\n                It is a list of dict. Each dict corresponds to an image and\n                contains keys like \"height\", \"width\", \"file_name\", \"image_id\".\n            outputs: the outputs of a COCO model. It is a list of dicts with key\n                \"instances\" that contains :class:`Instances`.\n        \"\"\"", "\n", "for", "input", ",", "output", "in", "zip", "(", "inputs", ",", "outputs", ")", ":", "\n", "            ", "prediction", "=", "{", "\n", "\"image_id\"", ":", "input", "[", "\"image_id\"", "]", ",", "\n", "\"file_name\"", ":", "input", "[", "\"file_name\"", "]", "\n", "}", "\n", "\n", "# TODO this is ugly", "\n", "if", "\"instances\"", "in", "output", ":", "\n", "                ", "instances", "=", "output", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "_cpu_device", ")", "\n", "prediction", "[", "\"instances\"", "]", "=", "instances_to_coco_json", "(", "\n", "instances", ",", "input", "[", "\"image_id\"", "]", ")", "\n", "prediction", "[", "\"predictions_for_ranking\"", "]", "=", "instances", "\n", "", "if", "\"proposals\"", "in", "output", ":", "\n", "                ", "prediction", "[", "\"proposals\"", "]", "=", "output", "[", "\"proposals\"", "]", ".", "to", "(", "\n", "self", ".", "_cpu_device", ")", "\n", "", "self", ".", "_predictions", ".", "append", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator.evaluate": [[129, 162], ["collections.OrderedDict", "coco_evaluation.COCOEvaluator._eval_sor", "copy.deepcopy", "detectron2.synchronize", "detectron2.gather", "list", "len", "coco_evaluation.COCOEvaluator._logger.warning", "fvcore.common.file_io.PathManager.mkdirs", "os.path.join", "coco_evaluation.COCOEvaluator._eval_box_proposals", "coco_evaluation.COCOEvaluator._eval_predictions", "itertools.chain", "detectron2.is_main_process", "fvcore.common.file_io.PathManager.open", "torch.save", "set"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._eval_sor", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._eval_predictions"], ["", "", "def", "evaluate", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_distributed", ":", "\n", "            ", "comm", ".", "synchronize", "(", ")", "\n", "predictions", "=", "comm", ".", "gather", "(", "self", ".", "_predictions", ",", "dst", "=", "0", ")", "\n", "predictions", "=", "list", "(", "itertools", ".", "chain", "(", "*", "predictions", ")", ")", "\n", "\n", "if", "not", "comm", ".", "is_main_process", "(", ")", ":", "\n", "                ", "return", "{", "}", "\n", "", "", "else", ":", "\n", "            ", "predictions", "=", "self", ".", "_predictions", "\n", "\n", "", "if", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "self", ".", "_logger", ".", "warning", "(", "\n", "\"[COCOEvaluator] Did not receive valid predictions.\"", ")", "\n", "return", "{", "}", "\n", "\n", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "PathManager", ".", "mkdirs", "(", "self", ".", "_output_dir", ")", "\n", "file_path", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_output_dir", ",", "\"instances_predictions.pth\"", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "torch", ".", "save", "(", "predictions", ",", "f", ")", "\n", "\n", "", "", "self", ".", "_results", "=", "OrderedDict", "(", ")", "\n", "# add sor eval oneline", "\n", "self", ".", "_eval_sor", "(", "predictions", ")", "\n", "\n", "if", "\"proposals\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_box_proposals", "(", "predictions", ")", "\n", "", "if", "\"instances\"", "in", "predictions", "[", "0", "]", ":", "\n", "            ", "self", ".", "_eval_predictions", "(", "set", "(", "self", ".", "_tasks", ")", ",", "predictions", ")", "\n", "# Copy so the caller can do whatever with results", "\n", "", "return", "copy", ".", "deepcopy", "(", "self", ".", "_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._eval_sor": [[163, 171], ["tqdm.tqdm.tqdm", "centermask.evaluation.sor_eval.eval_sor", "SORVisualizer", "SORVisualizer.draw_instance_sor_predictions", "SORVisualizer.draw_instance_sor_predictions.save", "numpy.zeros", "str", "pathlib.Path"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_sor", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.draw_instance_sor_predictions"], ["", "def", "_eval_sor", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "from", "vis", ".", "visualizer", "import", "SORVisualizer", "\n", "for", "pred", "in", "tqdm", "(", "predictions", ",", "desc", "=", "\"generating saliency map\"", ")", ":", "\n", "            ", "vis", "=", "SORVisualizer", "(", "np", ".", "zeros", "(", "(", "480", ",", "640", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", ",", "self", ".", "_metadata", ")", "\n", "out", "=", "vis", ".", "draw_instance_sor_predictions", "(", "predictions", "=", "pred", "[", "'predictions_for_ranking'", "]", ")", "\n", "out", ".", "save", "(", "self", ".", "_saliency_map_dir", "/", "(", "Path", "(", "pred", "[", "'file_name'", "]", ")", ".", "stem", "+", "'.png'", ")", ")", "\n", "", "res", "=", "eval_sor", "(", "map_path", "=", "str", "(", "self", ".", "_saliency_map_dir", ")", "+", "'/'", ")", "\n", "self", ".", "_results", "[", "'saliency_object_ranking'", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._eval_predictions": [[172, 222], ["coco_evaluation.COCOEvaluator._logger.info", "list", "hasattr", "coco_evaluation.COCOEvaluator._logger.info", "sorted", "itertools.chain", "os.path.join", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._derive_coco_results", "fvcore.common.file_io.PathManager.open", "f.write", "f.flush", "coco_evaluation._evaluate_predictions_on_coco", "coco_evaluation.COCOEvaluator._metadata.thing_dataset_id_to_contiguous_id.items", "json.dumps", "len", "coco_evaluation.COCOEvaluator._metadata.get"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation._evaluate_predictions_on_coco", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "_eval_predictions", "(", "self", ",", "tasks", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate predictions on the given tasks.\n        Fill self._results with the metrics of the tasks.\n        \"\"\"", "\n", "self", ".", "_logger", ".", "info", "(", "\"Preparing results for COCO format ...\"", ")", "\n", "coco_results", "=", "list", "(", "itertools", ".", "chain", "(", "\n", "*", "[", "x", "[", "\"instances\"", "]", "for", "x", "in", "predictions", "]", ")", ")", "\n", "\n", "# unmap the category ids for COCO", "\n", "if", "hasattr", "(", "self", ".", "_metadata", ",", "\"thing_dataset_id_to_contiguous_id\"", ")", ":", "\n", "            ", "reverse_id_mapping", "=", "{", "\n", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "_metadata", ".", "thing_dataset_id_to_contiguous_id", ".", "items", "(", ")", "\n", "}", "\n", "for", "result", "in", "coco_results", ":", "\n", "                ", "category_id", "=", "result", "[", "\"category_id\"", "]", "\n", "assert", "(", "\n", "category_id", "in", "reverse_id_mapping", "\n", ")", ",", "\"A prediction has category_id={}, which is not available in the dataset.\"", ".", "format", "(", "\n", "category_id", "\n", ")", "\n", "result", "[", "\"category_id\"", "]", "=", "reverse_id_mapping", "[", "category_id", "]", "\n", "\n", "", "", "if", "self", ".", "_output_dir", ":", "\n", "            ", "file_path", "=", "os", ".", "path", ".", "join", "(", "\n", "self", ".", "_output_dir", ",", "\"coco_instances_results.json\"", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Saving results to {}\"", ".", "format", "(", "file_path", ")", ")", "\n", "with", "PathManager", ".", "open", "(", "file_path", ",", "\"w\"", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "json", ".", "dumps", "(", "coco_results", ")", ")", "\n", "f", ".", "flush", "(", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating predictions ...\"", ")", "\n", "for", "task", "in", "sorted", "(", "tasks", ")", ":", "\n", "            ", "coco_eval", "=", "(", "\n", "_evaluate_predictions_on_coco", "(", "\n", "self", ".", "_coco_api", ",", "coco_results", ",", "task", ",", "kpt_oks_sigmas", "=", "self", ".", "_kpt_oks_sigmas", "\n", ")", "\n", "if", "len", "(", "coco_results", ")", ">", "0", "\n", "else", "None", "# cocoapi does not handle empty results very well", "\n", ")", "\n", "\n", "res", "=", "self", ".", "_derive_coco_results", "(", "\n", "coco_eval", ",", "task", ",", "class_names", "=", "self", ".", "_metadata", ".", "get", "(", "\n", "\"thing_classes\"", ")", "\n", ")", "\n", "self", ".", "_results", "[", "task", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._eval_box_proposals": [[223, 264], ["coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "coco_evaluation.COCOEvaluator._logger.info", "areas.items", "ids.append", "boxes.append", "objectness_logits.append", "fvcore.common.file_io.PathManager.open", "pickle.dump", "coco_evaluation._evaluate_box_proposals", "float", "detectron2.utils.logger.create_small_table", "prediction[].proposal_boxes.tensor.numpy", "prediction[].objectness_logits.numpy", "os.path.join", "stats[].item"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation._evaluate_box_proposals"], ["", "", "def", "_eval_box_proposals", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Evaluate the box proposals in predictions.\n        Fill self._results with the metrics for \"box_proposals\" task.\n        \"\"\"", "\n", "if", "self", ".", "_output_dir", ":", "\n", "# Saving generated box proposals to file.", "\n", "# Predicted box_proposals are in XYXY_ABS mode.", "\n", "            ", "bbox_mode", "=", "BoxMode", ".", "XYXY_ABS", ".", "value", "\n", "ids", ",", "boxes", ",", "objectness_logits", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "prediction", "in", "predictions", ":", "\n", "                ", "ids", ".", "append", "(", "prediction", "[", "\"image_id\"", "]", ")", "\n", "boxes", ".", "append", "(", "\n", "prediction", "[", "\"proposals\"", "]", ".", "proposal_boxes", ".", "tensor", ".", "numpy", "(", ")", ")", "\n", "objectness_logits", ".", "append", "(", "\n", "prediction", "[", "\"proposals\"", "]", ".", "objectness_logits", ".", "numpy", "(", ")", ")", "\n", "\n", "", "proposal_data", "=", "{", "\n", "\"boxes\"", ":", "boxes", ",", "\n", "\"objectness_logits\"", ":", "objectness_logits", ",", "\n", "\"ids\"", ":", "ids", ",", "\n", "\"bbox_mode\"", ":", "bbox_mode", ",", "\n", "}", "\n", "with", "PathManager", ".", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "_output_dir", ",", "\"box_proposals.pkl\"", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "proposal_data", ",", "f", ")", "\n", "\n", "", "", "if", "not", "self", ".", "_do_evaluation", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Annotations are not available for evaluation.\"", ")", "\n", "return", "\n", "\n", "", "self", ".", "_logger", ".", "info", "(", "\"Evaluating bbox proposals ...\"", ")", "\n", "res", "=", "{", "}", "\n", "areas", "=", "{", "\"all\"", ":", "\"\"", ",", "\"small\"", ":", "\"s\"", ",", "\"medium\"", ":", "\"m\"", ",", "\"large\"", ":", "\"l\"", "}", "\n", "for", "limit", "in", "[", "100", ",", "1000", "]", ":", "\n", "            ", "for", "area", ",", "suffix", "in", "areas", ".", "items", "(", ")", ":", "\n", "                ", "stats", "=", "_evaluate_box_proposals", "(", "\n", "predictions", ",", "self", ".", "_coco_api", ",", "area", "=", "area", ",", "limit", "=", "limit", ")", "\n", "key", "=", "\"AR{}@{:d}\"", ".", "format", "(", "suffix", ",", "limit", ")", "\n", "res", "[", "key", "]", "=", "float", "(", "stats", "[", "\"ar\"", "]", ".", "item", "(", ")", "*", "100", ")", "\n", "", "", "self", ".", "_logger", ".", "info", "(", "\"Proposal metrics: \\n\"", "+", "create_small_table", "(", "res", ")", ")", "\n", "self", ".", "_results", "[", "\"box_proposals\"", "]", "=", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator._derive_coco_results": [[265, 333], ["coco_evaluation.COCOEvaluator._logger.info", "enumerate", "min", "list", "itertools.zip_longest", "tabulate.tabulate.tabulate", "coco_evaluation.COCOEvaluator._logger.info", "results.update", "coco_evaluation.COCOEvaluator._logger.warn", "float", "numpy.isfinite", "coco_evaluation.COCOEvaluator._logger.info", "len", "results_per_category.append", "itertools.chain", "float", "enumerate", "detectron2.utils.logger.create_small_table", "sum", "len", "numpy.mean", "float", "len", "results.values", "float", "range"], "methods", ["None"], ["", "def", "_derive_coco_results", "(", "self", ",", "coco_eval", ",", "iou_type", ",", "class_names", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Derive the desired score numbers from summarized COCOeval.\n        Args:\n            coco_eval (None or COCOEval): None represents no predictions from model.\n            iou_type (str):\n            class_names (None or list[str]): if provided, will use it to predict\n                per-category AP.\n        Returns:\n            a dict of {metric name: score}\n        \"\"\"", "\n", "\n", "metrics", "=", "{", "\n", "\"bbox\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "\"segm\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APs\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "\"keypoints\"", ":", "[", "\"AP\"", ",", "\"AP50\"", ",", "\"AP75\"", ",", "\"APm\"", ",", "\"APl\"", "]", ",", "\n", "}", "[", "iou_type", "]", "\n", "\n", "if", "coco_eval", "is", "None", ":", "\n", "            ", "self", ".", "_logger", ".", "warn", "(", "\"No predictions from the model!\"", ")", "\n", "return", "{", "metric", ":", "float", "(", "\"nan\"", ")", "for", "metric", "in", "metrics", "}", "\n", "\n", "# the standard metrics", "\n", "", "results", "=", "{", "\n", "metric", ":", "float", "(", "\n", "coco_eval", ".", "stats", "[", "idx", "]", "*", "100", "if", "coco_eval", ".", "stats", "[", "idx", "]", ">=", "0", "else", "\"nan\"", ")", "\n", "for", "idx", ",", "metric", "in", "enumerate", "(", "metrics", ")", "\n", "}", "\n", "self", ".", "_logger", ".", "info", "(", "\n", "\"Evaluation results for {}: \\n\"", ".", "format", "(", "\n", "iou_type", ")", "+", "create_small_table", "(", "results", ")", "\n", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "sum", "(", "results", ".", "values", "(", ")", ")", ")", ":", "\n", "            ", "self", ".", "_logger", ".", "info", "(", "\"Note that some metrics cannot be computed.\"", ")", "\n", "\n", "", "if", "class_names", "is", "None", "or", "len", "(", "class_names", ")", "<=", "1", ":", "\n", "            ", "return", "results", "\n", "# Compute per-category AP", "\n", "# from https://github.com/facebookresearch/Detectron/blob/a6a835f5b8208c45d0dce217ce9bbda915f44df7/detectron/datasets/json_dataset_evaluator.py#L222-L252 # noqa", "\n", "", "precisions", "=", "coco_eval", ".", "eval", "[", "\"precision\"", "]", "\n", "# precision has dims (iou, recall, cls, area range, max dets)", "\n", "assert", "len", "(", "class_names", ")", "==", "precisions", ".", "shape", "[", "2", "]", "\n", "\n", "results_per_category", "=", "[", "]", "\n", "for", "idx", ",", "name", "in", "enumerate", "(", "class_names", ")", ":", "\n", "# area range index 0: all area ranges", "\n", "# max dets index -1: typically 100 per image", "\n", "            ", "precision", "=", "precisions", "[", ":", ",", ":", ",", "idx", ",", "0", ",", "-", "1", "]", "\n", "precision", "=", "precision", "[", "precision", ">", "-", "1", "]", "\n", "ap", "=", "np", ".", "mean", "(", "precision", ")", "if", "precision", ".", "size", "else", "float", "(", "\"nan\"", ")", "\n", "results_per_category", ".", "append", "(", "(", "\"{}\"", ".", "format", "(", "name", ")", ",", "float", "(", "ap", "*", "100", ")", ")", ")", "\n", "\n", "# tabulate it", "\n", "", "N_COLS", "=", "min", "(", "6", ",", "len", "(", "results_per_category", ")", "*", "2", ")", "\n", "results_flatten", "=", "list", "(", "itertools", ".", "chain", "(", "*", "results_per_category", ")", ")", "\n", "results_2d", "=", "itertools", ".", "zip_longest", "(", "\n", "*", "[", "results_flatten", "[", "i", ":", ":", "N_COLS", "]", "for", "i", "in", "range", "(", "N_COLS", ")", "]", ")", "\n", "table", "=", "tabulate", "(", "\n", "results_2d", ",", "\n", "tablefmt", "=", "\"pipe\"", ",", "\n", "floatfmt", "=", "\".3f\"", ",", "\n", "headers", "=", "[", "\"category\"", ",", "\"AP\"", "]", "*", "(", "N_COLS", "//", "2", ")", ",", "\n", "numalign", "=", "\"left\"", ",", "\n", ")", "\n", "self", ".", "_logger", ".", "info", "(", "\"Per-category {} AP: \\n\"", ".", "format", "(", "iou_type", ")", "+", "table", ")", "\n", "\n", "results", ".", "update", "(", "{", "\"AP-\"", "+", "name", ":", "ap", "for", "name", ",", "ap", "in", "results_per_category", "}", ")", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.instances_to_coco_json": [[335, 401], ["len", "instances.pred_boxes.tensor.numpy", "detectron2.structures.BoxMode.convert", "boxes.tolist.tolist", "instances.scores.tolist", "instances.pred_classes.tolist", "instances.has", "instances.has", "instances.has", "range", "results.append", "rle[].decode", "instances.mask_scores.tolist", "keypoints[].flatten().tolist", "pycocotools.encode", "numpy.array", "keypoints[].flatten"], "function", ["None"], ["", "", "def", "instances_to_coco_json", "(", "instances", ",", "img_id", ")", ":", "\n", "    ", "\"\"\"\n    Dump an \"Instances\" object to a COCO-format json that's used for evaluation.\n    Args:\n        instances (Instances):\n        img_id (int): the image id\n    Returns:\n        list[dict]: list of json annotations in COCO format.\n    \"\"\"", "\n", "num_instance", "=", "len", "(", "instances", ")", "\n", "if", "num_instance", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "\n", "", "boxes", "=", "instances", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "\n", "boxes", "=", "BoxMode", ".", "convert", "(", "boxes", ",", "BoxMode", ".", "XYXY_ABS", ",", "BoxMode", ".", "XYWH_ABS", ")", "\n", "boxes", "=", "boxes", ".", "tolist", "(", ")", "\n", "scores", "=", "instances", ".", "scores", ".", "tolist", "(", ")", "\n", "classes", "=", "instances", ".", "pred_classes", ".", "tolist", "(", ")", "\n", "\n", "has_mask", "=", "instances", ".", "has", "(", "\"pred_masks\"", ")", "\n", "has_mask_scores", "=", "instances", ".", "has", "(", "\"mask_scores\"", ")", "\n", "if", "has_mask", ":", "\n", "# use RLE to encode the masks, because they are too large and takes memory", "\n", "# since this evaluator stores outputs of the entire dataset", "\n", "        ", "rles", "=", "[", "\n", "mask_util", ".", "encode", "(", "\n", "np", ".", "array", "(", "mask", "[", ":", ",", ":", ",", "None", "]", ",", "order", "=", "\"F\"", ",", "dtype", "=", "\"uint8\"", ")", ")", "[", "0", "]", "\n", "for", "mask", "in", "instances", ".", "pred_masks", "\n", "]", "\n", "for", "rle", "in", "rles", ":", "\n", "# \"counts\" is an array encoded by mask_util as a byte-stream. Python3's", "\n", "# json writer which always produces strings cannot serialize a bytestream", "\n", "# unless you decode it. Thankfully, utf-8 works out (which is also what", "\n", "# the pycocotools/_mask.pyx does).", "\n", "            ", "rle", "[", "\"counts\"", "]", "=", "rle", "[", "\"counts\"", "]", ".", "decode", "(", "\"utf-8\"", ")", "\n", "\n", "", "if", "has_mask_scores", ":", "\n", "            ", "mask_scores", "=", "instances", ".", "mask_scores", ".", "tolist", "(", ")", "\n", "\n", "", "", "has_keypoints", "=", "instances", ".", "has", "(", "\"pred_keypoints\"", ")", "\n", "if", "has_keypoints", ":", "\n", "        ", "keypoints", "=", "instances", ".", "pred_keypoints", "\n", "\n", "", "results", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "num_instance", ")", ":", "\n", "        ", "result", "=", "{", "\n", "\"image_id\"", ":", "img_id", ",", "\n", "\"category_id\"", ":", "classes", "[", "k", "]", ",", "\n", "\"bbox\"", ":", "boxes", "[", "k", "]", ",", "\n", "\"score\"", ":", "scores", "[", "k", "]", ",", "\n", "}", "\n", "if", "has_mask", ":", "\n", "            ", "result", "[", "\"segmentation\"", "]", "=", "rles", "[", "k", "]", "\n", "if", "has_mask_scores", ":", "\n", "                ", "result", "[", "\"mask_score\"", "]", "=", "mask_scores", "[", "k", "]", "\n", "\n", "", "", "if", "has_keypoints", ":", "\n", "# In COCO annotations,", "\n", "# keypoints coordinates are pixel indices.", "\n", "# However our predictions are floating point coordinates.", "\n", "# Therefore we subtract 0.5 to be consistent with the annotation format.", "\n", "# This is the inverse of data loading logic in `datasets/coco.py`.", "\n", "            ", "keypoints", "[", "k", "]", "[", ":", ",", ":", "2", "]", "-=", "0.5", "\n", "result", "[", "\"keypoints\"", "]", "=", "keypoints", "[", "k", "]", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "", "results", ".", "append", "(", "result", ")", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation._evaluate_box_proposals": [[405, 514], ["torch.cat", "torch.sort", "torch.zeros_like", "enumerate", "torch.zeros_like.mean", "coco_api.getAnnIds", "coco_api.loadAnns", "torch.as_tensor().reshape", "detectron2.structures.Boxes", "torch.as_tensor", "len", "detectron2.structures.pairwise_iou", "torch.zeros", "range", "torch.cat.append", "torch.arange", "predictions.objectness_logits.sort", "detectron2.structures.BoxMode.convert", "len", "len", "min", "detectron2.structures.pairwise_iou.max", "max_overlaps.max", "float", "torch.as_tensor", "len", "len", "len", "len", "len"], "function", ["None"], ["", "def", "_evaluate_box_proposals", "(", "dataset_predictions", ",", "coco_api", ",", "thresholds", "=", "None", ",", "area", "=", "\"all\"", ",", "limit", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate detection proposal recall metrics. This function is a much\n    faster alternative to the official COCO API recall evaluation code. However,\n    it produces slightly different results.\n    \"\"\"", "\n", "# Record max overlap value for each gt box", "\n", "# Return vector of overlap values", "\n", "areas", "=", "{", "\n", "\"all\"", ":", "0", ",", "\n", "\"small\"", ":", "1", ",", "\n", "\"medium\"", ":", "2", ",", "\n", "\"large\"", ":", "3", ",", "\n", "\"96-128\"", ":", "4", ",", "\n", "\"128-256\"", ":", "5", ",", "\n", "\"256-512\"", ":", "6", ",", "\n", "\"512-inf\"", ":", "7", ",", "\n", "}", "\n", "area_ranges", "=", "[", "\n", "[", "0", "**", "2", ",", "1e5", "**", "2", "]", ",", "# all", "\n", "[", "0", "**", "2", ",", "32", "**", "2", "]", ",", "# small", "\n", "[", "32", "**", "2", ",", "96", "**", "2", "]", ",", "# medium", "\n", "[", "96", "**", "2", ",", "1e5", "**", "2", "]", ",", "# large", "\n", "[", "96", "**", "2", ",", "128", "**", "2", "]", ",", "# 96-128", "\n", "[", "128", "**", "2", ",", "256", "**", "2", "]", ",", "# 128-256", "\n", "[", "256", "**", "2", ",", "512", "**", "2", "]", ",", "# 256-512", "\n", "[", "512", "**", "2", ",", "1e5", "**", "2", "]", ",", "\n", "]", "# 512-inf", "\n", "assert", "area", "in", "areas", ",", "\"Unknown area range: {}\"", ".", "format", "(", "area", ")", "\n", "area_range", "=", "area_ranges", "[", "areas", "[", "area", "]", "]", "\n", "gt_overlaps", "=", "[", "]", "\n", "num_pos", "=", "0", "\n", "\n", "for", "prediction_dict", "in", "dataset_predictions", ":", "\n", "        ", "predictions", "=", "prediction_dict", "[", "\"proposals\"", "]", "\n", "\n", "# sort predictions in descending order", "\n", "# TODO maybe remove this and make it explicit in the documentation", "\n", "inds", "=", "predictions", ".", "objectness_logits", ".", "sort", "(", "descending", "=", "True", ")", "[", "1", "]", "\n", "predictions", "=", "predictions", "[", "inds", "]", "\n", "\n", "ann_ids", "=", "coco_api", ".", "getAnnIds", "(", "imgIds", "=", "prediction_dict", "[", "\"image_id\"", "]", ")", "\n", "anno", "=", "coco_api", ".", "loadAnns", "(", "ann_ids", ")", "\n", "gt_boxes", "=", "[", "\n", "BoxMode", ".", "convert", "(", "obj", "[", "\"bbox\"", "]", ",", "BoxMode", ".", "XYWH_ABS", ",", "BoxMode", ".", "XYXY_ABS", ")", "\n", "for", "obj", "in", "anno", "\n", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "\n", "]", "\n", "# guard against no boxes", "\n", "gt_boxes", "=", "torch", ".", "as_tensor", "(", "gt_boxes", ")", ".", "reshape", "(", "-", "1", ",", "4", ")", "\n", "gt_boxes", "=", "Boxes", "(", "gt_boxes", ")", "\n", "gt_areas", "=", "torch", ".", "as_tensor", "(", "[", "obj", "[", "\"area\"", "]", "\n", "for", "obj", "in", "anno", "if", "obj", "[", "\"iscrowd\"", "]", "==", "0", "]", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", "or", "len", "(", "predictions", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "valid_gt_inds", "=", "(", "gt_areas", ">=", "area_range", "[", "0", "]", ")", "&", "(", "\n", "gt_areas", "<=", "area_range", "[", "1", "]", ")", "\n", "gt_boxes", "=", "gt_boxes", "[", "valid_gt_inds", "]", "\n", "\n", "num_pos", "+=", "len", "(", "gt_boxes", ")", "\n", "\n", "if", "len", "(", "gt_boxes", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "limit", "is", "not", "None", "and", "len", "(", "predictions", ")", ">", "limit", ":", "\n", "            ", "predictions", "=", "predictions", "[", ":", "limit", "]", "\n", "\n", "", "overlaps", "=", "pairwise_iou", "(", "predictions", ".", "proposal_boxes", ",", "gt_boxes", ")", "\n", "\n", "_gt_overlaps", "=", "torch", ".", "zeros", "(", "len", "(", "gt_boxes", ")", ")", "\n", "for", "j", "in", "range", "(", "min", "(", "len", "(", "predictions", ")", ",", "len", "(", "gt_boxes", ")", ")", ")", ":", "\n", "# find which proposal box maximally covers each gt box", "\n", "# and get the iou amount of coverage for each gt box", "\n", "            ", "max_overlaps", ",", "argmax_overlaps", "=", "overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "\n", "# find which gt box is 'best' covered (i.e. 'best' = most iou)", "\n", "gt_ovr", ",", "gt_ind", "=", "max_overlaps", ".", "max", "(", "dim", "=", "0", ")", "\n", "assert", "gt_ovr", ">=", "0", "\n", "# find the proposal box that covers the best covered gt box", "\n", "box_ind", "=", "argmax_overlaps", "[", "gt_ind", "]", "\n", "# record the iou coverage of this gt box", "\n", "_gt_overlaps", "[", "j", "]", "=", "overlaps", "[", "box_ind", ",", "gt_ind", "]", "\n", "assert", "_gt_overlaps", "[", "j", "]", "==", "gt_ovr", "\n", "# mark the proposal box and the gt box as used", "\n", "overlaps", "[", "box_ind", ",", ":", "]", "=", "-", "1", "\n", "overlaps", "[", ":", ",", "gt_ind", "]", "=", "-", "1", "\n", "\n", "# append recorded iou coverage level", "\n", "", "gt_overlaps", ".", "append", "(", "_gt_overlaps", ")", "\n", "", "gt_overlaps", "=", "torch", ".", "cat", "(", "gt_overlaps", ",", "dim", "=", "0", ")", "\n", "gt_overlaps", ",", "_", "=", "torch", ".", "sort", "(", "gt_overlaps", ")", "\n", "\n", "if", "thresholds", "is", "None", ":", "\n", "        ", "step", "=", "0.05", "\n", "thresholds", "=", "torch", ".", "arange", "(", "0.5", ",", "0.95", "+", "1e-5", ",", "step", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "", "recalls", "=", "torch", ".", "zeros_like", "(", "thresholds", ")", "\n", "# compute recall for each iou threshold", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "thresholds", ")", ":", "\n", "        ", "recalls", "[", "i", "]", "=", "(", "gt_overlaps", ">=", "t", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "/", "float", "(", "num_pos", ")", "\n", "# ar = 2 * np.trapz(recalls, thresholds)", "\n", "", "ar", "=", "recalls", ".", "mean", "(", ")", "\n", "return", "{", "\n", "\"ar\"", ":", "ar", ",", "\n", "\"recalls\"", ":", "recalls", ",", "\n", "\"thresholds\"", ":", "thresholds", ",", "\n", "\"gt_overlaps\"", ":", "gt_overlaps", ",", "\n", "\"num_pos\"", ":", "num_pos", ",", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation._evaluate_predictions_on_coco": [[517, 558], ["coco_gt.loadRes", "pycocotools.cocoeval.COCOeval", "pycocotools.cocoeval.COCOeval.evaluate", "pycocotools.cocoeval.COCOeval.accumulate", "pycocotools.cocoeval.COCOeval.summarize", "len", "copy.deepcopy", "numpy.array", "c.pop", "len", "len"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.coco_evaluation.COCOEvaluator.evaluate"], ["", "def", "_evaluate_predictions_on_coco", "(", "coco_gt", ",", "coco_results", ",", "iou_type", ",", "kpt_oks_sigmas", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Evaluate the coco results using COCOEval API.\n    \"\"\"", "\n", "assert", "len", "(", "coco_results", ")", ">", "0", "\n", "\n", "if", "iou_type", "==", "\"segm\"", ":", "\n", "        ", "coco_results", "=", "copy", ".", "deepcopy", "(", "coco_results", ")", "\n", "# When evaluating mask AP, if the results contain bbox, cocoapi will", "\n", "# use the box area as the area of the instance, instead of the mask area.", "\n", "# This leads to a different definition of small/medium/large.", "\n", "# We remove the bbox field to let mask AP use mask area.", "\n", "# We also replace `score` with `mask_score` when using mask scoring.", "\n", "has_mask_scores", "=", "\"mask_score\"", "in", "coco_results", "[", "0", "]", "\n", "\n", "for", "c", "in", "coco_results", ":", "\n", "            ", "c", ".", "pop", "(", "\"bbox\"", ",", "None", ")", "\n", "if", "has_mask_scores", ":", "\n", "                ", "c", "[", "\"score\"", "]", "=", "c", "[", "\"mask_score\"", "]", "\n", "del", "c", "[", "\"mask_score\"", "]", "\n", "\n", "", "", "", "coco_dt", "=", "coco_gt", ".", "loadRes", "(", "coco_results", ")", "\n", "coco_eval", "=", "COCOeval", "(", "coco_gt", ",", "coco_dt", ",", "iou_type", ")", "\n", "# Use the COCO default keypoint OKS sigmas unless overrides are specified", "\n", "if", "kpt_oks_sigmas", ":", "\n", "        ", "coco_eval", ".", "params", ".", "kpt_oks_sigmas", "=", "np", ".", "array", "(", "kpt_oks_sigmas", ")", "\n", "\n", "", "if", "iou_type", "==", "\"keypoints\"", ":", "\n", "        ", "num_keypoints", "=", "len", "(", "coco_results", "[", "0", "]", "[", "\"keypoints\"", "]", ")", "//", "3", "\n", "assert", "len", "(", "coco_eval", ".", "params", ".", "kpt_oks_sigmas", ")", "==", "num_keypoints", ",", "(", "\n", "\"[COCOEvaluator] The length of cfg.TEST.KEYPOINT_OKS_SIGMAS (default: 17) \"", "\n", "\"must be equal to the number of keypoints. However the prediction has {} \"", "\n", "\"keypoints! For more information please refer to \"", "\n", "\"http://cocodataset.org/#keypoints-eval.\"", ".", "format", "(", "num_keypoints", ")", "\n", ")", "\n", "\n", "", "coco_eval", ".", "evaluate", "(", ")", "\n", "coco_eval", ".", "accumulate", "(", ")", "\n", "coco_eval", ".", "summarize", "(", ")", "\n", "\n", "return", "coco_eval", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.__init__": [[23, 38], ["sor_eval.DatasetTest.load_dataset", "sor_eval.DatasetTest.load_rank_order_data", "sor_eval.DatasetTest.load_object_seg_data"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_dataset", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_rank_order_data", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_object_seg_data"], ["    ", "def", "__init__", "(", "self", ",", "dataset_root", ",", "data_split", ",", "eval_spr", "=", "None", ")", ":", "\n", "        ", "self", ".", "dataset_root", "=", "dataset_root", "\n", "self", ".", "data_split", "=", "data_split", "\n", "\n", "self", ".", "load_dataset", "(", ")", "\n", "\n", "self", ".", "eval_spr", "=", "eval_spr", "\n", "if", "eval_spr", ":", "\n", "            ", "rank_order_root", "=", "self", ".", "dataset_root", "+", "\"rank_order/\"", "+", "self", ".", "data_split", "+", "\"/\"", "\n", "self", ".", "gt_rank_orders", "=", "self", ".", "load_rank_order_data", "(", "rank_order_root", ")", "\n", "\n", "obj_seg_data_path", "=", "self", ".", "dataset_root", "+", "\"obj_seg_data_\"", "+", "self", ".", "data_split", "+", "\".json\"", "\n", "self", ".", "obj_bboxes", ",", "self", ".", "obj_seg", ",", "self", ".", "sal_obj_idx_list", ",", "self", ".", "not_sal_obj_idx_list", "=", "self", ".", "load_object_seg_data", "(", "\n", "obj_seg_data_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_dataset": [[39, 50], ["print", "os.path.join", "open", "line.strip", "f.readlines"], "methods", ["None"], ["", "", "def", "load_dataset", "(", "self", ")", ":", "\n", "        ", "print", "(", "\"\\nLoading Dataset...\"", ")", "\n", "\n", "image_file", "=", "self", ".", "data_split", "+", "\"_images.txt\"", "\n", "\n", "# Get list of image ids", "\n", "image_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_root", ",", "image_file", ")", "\n", "with", "open", "(", "image_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "image_names", "=", "[", "line", ".", "strip", "(", ")", "for", "line", "in", "f", ".", "readlines", "(", ")", "]", "\n", "\n", "", "self", ".", "img_ids", "=", "image_names", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_rank_order_data": [[51, 67], ["gt_rank_orders.append", "open", "json.load"], "methods", ["None"], ["", "def", "load_rank_order_data", "(", "self", ",", "rank_order_root", ")", ":", "\n", "# rank_order_data_files = [f for f in os.listdir(rank_order_root)]", "\n", "\n", "        ", "gt_rank_orders", "=", "[", "]", "\n", "for", "img_id", "in", "self", ".", "img_ids", ":", "\n", "\n", "            ", "p", "=", "rank_order_root", "+", "img_id", "+", "\".json\"", "\n", "\n", "with", "open", "(", "p", ",", "\"r\"", ")", "as", "in_file", ":", "\n", "                ", "rank_data", "=", "json", ".", "load", "(", "in_file", ")", "\n", "\n", "", "rank_order", "=", "rank_data", "[", "\"rank_order\"", "]", "\n", "\n", "gt_rank_orders", ".", "append", "(", "rank_order", ")", "\n", "\n", "", "return", "gt_rank_orders", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_object_seg_data": [[68, 101], ["range", "range", "open", "json.load", "len", "obj_bbox.append", "obj_seg.append", "len", "numpy.array", "[].tolist", "_sal_obj_idx_list.append", "[].tolist", "_not_sal_obj_idx_list.append", "_img_obj_bbox.append", "_img_obj_seg.append", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "load_object_seg_data", "(", "self", ",", "obj_data_path", ")", ":", "\n", "        ", "with", "open", "(", "obj_data_path", ",", "\"r\"", ")", "as", "f", ":", "\n", "            ", "data", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "obj_bbox", "=", "[", "]", "\n", "obj_seg", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "data", ")", ")", ":", "\n", "            ", "img_data", "=", "data", "[", "i", "]", "\n", "\n", "img_obj_data", "=", "img_data", "[", "\"object_data\"", "]", "\n", "\n", "_img_obj_bbox", "=", "[", "]", "\n", "_img_obj_seg", "=", "[", "]", "\n", "for", "obj_data", "in", "img_obj_data", ":", "\n", "                ", "_img_obj_bbox", ".", "append", "(", "obj_data", "[", "\"bbox\"", "]", ")", "\n", "_img_obj_seg", ".", "append", "(", "obj_data", "[", "\"segmentation\"", "]", ")", "\n", "\n", "", "obj_bbox", ".", "append", "(", "_img_obj_bbox", ")", "\n", "obj_seg", ".", "append", "(", "_img_obj_seg", ")", "\n", "\n", "# Find N salient objects based on gt rank order", "\n", "", "_sal_obj_idx_list", "=", "[", "]", "\n", "_not_sal_obj_idx_list", "=", "[", "]", "\n", "# Create a set for defined salient objects", "\n", "for", "i", "in", "range", "(", "len", "(", "obj_bbox", ")", ")", ":", "\n", "            ", "gt_ranks", "=", "np", ".", "array", "(", "self", ".", "gt_rank_orders", "[", "i", "]", ")", "\n", "_idx_sal", "=", "np", ".", "where", "(", "gt_ranks", ">", "SAL_VAL_THRESH", ")", "[", "0", "]", ".", "tolist", "(", ")", "\n", "_sal_obj_idx_list", ".", "append", "(", "_idx_sal", ")", "\n", "\n", "_idx_not_sal", "=", "np", ".", "where", "(", "gt_ranks", "<=", "SAL_VAL_THRESH", ")", "[", "0", "]", ".", "tolist", "(", ")", "\n", "_not_sal_obj_idx_list", ".", "append", "(", "_idx_not_sal", ")", "\n", "\n", "", "return", "obj_bbox", ",", "obj_seg", ",", "_sal_obj_idx_list", ",", "_not_sal_obj_idx_list", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_image": [[102, 117], ["skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.io.imread", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb", "skimage.color.gray2rgb"], "methods", ["None"], ["", "def", "load_image", "(", "self", ",", "image_id", ")", ":", "\n", "        ", "\"\"\"Load the specified image and return a [H,W,3] Numpy array.\n        \"\"\"", "\n", "\n", "# Load image", "\n", "p", "=", "self", ".", "dataset_root", "+", "\"images/\"", "+", "self", ".", "data_split", "+", "\"/\"", "+", "image_id", "+", "\".jpg\"", "\n", "image", "=", "skimage", ".", "io", ".", "imread", "(", "p", ")", "\n", "\n", "# If grayscale. Convert to RGB for consistency.", "\n", "if", "image", ".", "ndim", "!=", "3", ":", "\n", "            ", "image", "=", "skimage", ".", "color", ".", "gray2rgb", "(", "image", ")", "\n", "# If has an alpha channel, remove it for consistency", "\n", "", "if", "image", ".", "shape", "[", "-", "1", "]", "==", "4", ":", "\n", "            ", "image", "=", "image", "[", "...", ",", ":", "3", "]", "\n", "", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_gt_mask": [[118, 130], ["cv2.imread().astype", "numpy.array", "cv2.imread"], "methods", ["None"], ["", "def", "load_gt_mask", "(", "self", ",", "image_id", ")", ":", "\n", "# Load mask", "\n", "        ", "p", "=", "self", ".", "dataset_root", "+", "\"gt/\"", "+", "self", ".", "data_split", "+", "\"/\"", "+", "image_id", "+", "\".png\"", "\n", "og_gt_mask", "=", "cv2", ".", "imread", "(", "p", ",", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Need only one channel", "\n", "mask", "=", "og_gt_mask", "[", ":", ",", ":", ",", "0", "]", "\n", "\n", "# Normalize to 0-1", "\n", "mask", "/=", "255.0", "\n", "\n", "return", "np", ".", "array", "(", "mask", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.get_obj_mask": [[132, 153], ["isinstance", "pycocotools.mask.decode", "pycocotools.mask.frPyObjects", "pycocotools.mask.merge", "isinstance", "pycocotools.mask.frPyObjects"], "function", ["None"], ["", "", "def", "get_obj_mask", "(", "seg_ann_data", ",", "height", ",", "width", ")", ":", "\n", "    ", "\"\"\"\n    Convert annotation which can be polygons, uncompressed RLE, or RLE to binary mask.\n    :return: binary mask (numpy 2D array)\n    \"\"\"", "\n", "if", "isinstance", "(", "seg_ann_data", ",", "list", ")", ":", "\n", "# polygon -- a single object might consist of multiple parts", "\n", "# we merge all parts into one mask rle code", "\n", "        ", "rles", "=", "maskUtils", ".", "frPyObjects", "(", "seg_ann_data", ",", "height", ",", "width", ")", "\n", "rle", "=", "maskUtils", ".", "merge", "(", "rles", ")", "\n", "", "elif", "isinstance", "(", "seg_ann_data", "[", "'counts'", "]", ",", "list", ")", ":", "\n", "# uncompressed RLE", "\n", "        ", "rle", "=", "maskUtils", ".", "frPyObjects", "(", "seg_ann_data", ",", "height", ",", "width", ")", "\n", "", "else", ":", "\n", "# rle", "\n", "# rle = seg_ann_data['segmentation']", "\n", "        ", "rle", "=", "seg_ann_data", "\n", "\n", "", "m", "=", "maskUtils", ".", "decode", "(", "rle", ")", "\n", "\n", "return", "m", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.get_usable_salient_objects_agreed": [[156, 177], ["range", "list", "list", "numpy.array", "numpy.array", "list", "list", "len", "range", "numpy.delete", "numpy.delete", "numpy.delete", "rm_list.append", "len", "numpy.array"], "function", ["None"], ["", "def", "get_usable_salient_objects_agreed", "(", "image_1_list", ",", "image_2_list", ")", ":", "\n", "# Remove indices list", "\n", "    ", "rm_list", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "len", "(", "image_1_list", ")", ")", ":", "\n", "        ", "v", "=", "image_1_list", "[", "idx", "]", "\n", "v2", "=", "image_2_list", "[", "idx", "]", "\n", "\n", "if", "v", "==", "0", "or", "v2", "==", "0", ":", "\n", "            ", "rm_list", ".", "append", "(", "idx", ")", "\n", "\n", "# Use indices list", "\n", "", "", "use_list", "=", "list", "(", "range", "(", "0", ",", "len", "(", "image_1_list", ")", ")", ")", "\n", "use_list", "=", "list", "(", "np", ".", "delete", "(", "np", ".", "array", "(", "use_list", ")", ",", "rm_list", ")", ")", "\n", "\n", "# Remove the indices", "\n", "x", "=", "np", ".", "array", "(", "image_1_list", ")", "\n", "y", "=", "np", ".", "array", "(", "image_2_list", ")", "\n", "x", "=", "list", "(", "np", ".", "delete", "(", "x", ",", "rm_list", ")", ")", "\n", "y", "=", "list", "(", "np", ".", "delete", "(", "y", ",", "rm_list", ")", ")", "\n", "\n", "return", "x", ",", "y", ",", "use_list", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.load_saliency_map": [[187, 198], ["cv2.imread().astype", "cv2.imread"], "function", ["None"], ["def", "load_saliency_map", "(", "path", ")", ":", "\n", "# Load mask", "\n", "    ", "sal_map", "=", "cv2", ".", "imread", "(", "path", ",", "1", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n", "# Need only one channel", "\n", "sal_map", "=", "sal_map", "[", ":", ",", ":", ",", "0", "]", "\n", "\n", "# Normalize to 0-1", "\n", "sal_map", "/=", "255.0", "\n", "\n", "return", "sal_map", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_mae": [[200, 227], ["print", "len", "range", "print", "print", "sor_eval.load_saliency_map", "dataset.load_gt_mask", "gt_mask.flatten.flatten", "pred_mask.flatten.flatten", "sklearn.metrics.mean_absolute_error", "mae_list.append", "sum", "len"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.load_saliency_map", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_gt_mask"], ["", "def", "eval_mae", "(", "dataset", ",", "map_path", ")", ":", "\n", "    ", "print", "(", "\"Calculating MAE...\"", ")", "\n", "\n", "mae_list", "=", "[", "]", "\n", "\n", "num", "=", "len", "(", "dataset", ".", "img_ids", ")", "\n", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "        ", "image_id", "=", "dataset", ".", "img_ids", "[", "i", "]", "\n", "\n", "p", "=", "map_path", "+", "image_id", "+", "\".png\"", "\n", "\n", "pred_mask", "=", "load_saliency_map", "(", "p", ")", "\n", "\n", "gt_mask", "=", "dataset", ".", "load_gt_mask", "(", "image_id", ")", "\n", "\n", "# Flatten masks", "\n", "gt_mask", "=", "gt_mask", ".", "flatten", "(", ")", "\n", "pred_mask", "=", "pred_mask", ".", "flatten", "(", ")", "\n", "\n", "mae", "=", "mean_absolute_error", "(", "gt_mask", ",", "pred_mask", ")", "\n", "\n", "mae_list", ".", "append", "(", "mae", ")", "\n", "\n", "", "print", "(", "\"\\n\"", ")", "\n", "avg_mae", "=", "sum", "(", "mae_list", ")", "/", "len", "(", "mae_list", ")", "\n", "print", "(", "\"Average MAE Images = \"", ",", "avg_mae", ")", "\n", "return", "avg_mae", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_mae_binary_mask": [[229, 258], ["print", "len", "range", "print", "print", "sor_eval.load_saliency_map", "dataset.load_gt_mask", "gt_mask.flatten.flatten", "pred_mask.flatten.flatten", "sklearn.metrics.mean_absolute_error", "mae_list.append", "sum", "len"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.load_saliency_map", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.DatasetTest.load_gt_mask"], ["", "def", "eval_mae_binary_mask", "(", "dataset", ",", "map_path", ")", ":", "\n", "    ", "print", "(", "\"Calculating MAE (Binary Saliency)...\"", ")", "\n", "\n", "mae_list", "=", "[", "]", "\n", "\n", "num", "=", "len", "(", "dataset", ".", "img_ids", ")", "\n", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "        ", "image_id", "=", "dataset", ".", "img_ids", "[", "i", "]", "\n", "\n", "p", "=", "map_path", "+", "image_id", "+", "\".png\"", "\n", "pred_mask", "=", "load_saliency_map", "(", "p", ")", "\n", "\n", "gt_mask", "=", "dataset", ".", "load_gt_mask", "(", "image_id", ")", "\n", "\n", "# Convert masks to binary", "\n", "pred_mask", "[", "pred_mask", ">", "0", "]", "=", "1", "\n", "gt_mask", "[", "gt_mask", ">", "0", "]", "=", "1", "\n", "\n", "# Flatten masks", "\n", "gt_mask", "=", "gt_mask", ".", "flatten", "(", ")", "\n", "pred_mask", "=", "pred_mask", ".", "flatten", "(", ")", "\n", "\n", "mae", "=", "mean_absolute_error", "(", "gt_mask", ",", "pred_mask", ")", "\n", "\n", "mae_list", ".", "append", "(", "mae", ")", "\n", "\n", "", "print", "(", "\"\\n\"", ")", "\n", "avg_mae", "=", "sum", "(", "mae_list", ")", "/", "len", "(", "mae_list", ")", "\n", "print", "(", "\"Average MAE Images (Binary Masks) = \"", ",", "avg_mae", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.calculate_spr": [[260, 361], ["print", "len", "range", "len", "range", "range", "range", "sor_eval.get_usable_salient_objects_agreed", "spr_data.append", "len", "sor_eval.get_obj_mask", "get_obj_mask.sum", "instance_masks.append", "instance_pix_count.append", "cv2.imread", "len", "numpy.where", "numpy.where", "len", "pred_ranks.append", "gt_ranks.append", "len", "scipy.spearmanr", "int", "len", "scipy.mode"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.get_usable_salient_objects_agreed", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.get_obj_mask"], ["", "def", "calculate_spr", "(", "dataset", ",", "model_pred_data_path", ")", ":", "\n", "    ", "print", "(", "\"Calculating SOR...\"", ")", "\n", "\n", "# Load GT Rank", "\n", "gt_rank_order", "=", "dataset", ".", "gt_rank_orders", "\n", "\n", "spr_data", "=", "[", "]", "\n", "\n", "num", "=", "len", "(", "dataset", ".", "img_ids", ")", "\n", "for", "i", "in", "range", "(", "num", ")", ":", "\n", "# Image Id", "\n", "        ", "image_id", "=", "dataset", ".", "img_ids", "[", "i", "]", "\n", "\n", "sal_obj_idx", "=", "dataset", ".", "sal_obj_idx_list", "[", "i", "]", "\n", "\n", "N", "=", "len", "(", "sal_obj_idx", ")", "\n", "\n", "# load seg data", "\n", "obj_seg", "=", "dataset", ".", "obj_seg", "[", "i", "]", "# polygon", "\n", "instance_masks", "=", "[", "]", "\n", "instance_pix_count", "=", "[", "]", "\n", "\n", "# Create mask for each salient object", "\n", "for", "s_i", "in", "range", "(", "len", "(", "sal_obj_idx", ")", ")", ":", "\n", "            ", "sal_idx", "=", "sal_obj_idx", "[", "s_i", "]", "\n", "\n", "# Get corresponding segmentation data", "\n", "seg", "=", "obj_seg", "[", "sal_idx", "]", "\n", "\n", "# Binary mask of object segment", "\n", "mask", "=", "get_obj_mask", "(", "seg", ",", "HEIGHT", ",", "WIDTH", ")", "\n", "\n", "# Count number of pixels of object segment", "\n", "pix_count", "=", "mask", ".", "sum", "(", ")", "\n", "\n", "instance_masks", ".", "append", "(", "mask", ")", "\n", "instance_pix_count", ".", "append", "(", "pix_count", ")", "\n", "\n", "# ********** Load Predicted Rank", "\n", "", "pred_data_path", "=", "model_pred_data_path", "+", "dataset", ".", "img_ids", "[", "i", "]", "+", "\".png\"", "\n", "\n", "pred_sal_map", "=", "cv2", ".", "imread", "(", "pred_data_path", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "\n", "# Get corresponding predicted rank for each gt salient objects", "\n", "pred_ranks", "=", "[", "]", "\n", "\n", "# Create mask for each salient object", "\n", "for", "s_i", "in", "range", "(", "len", "(", "instance_masks", ")", ")", ":", "\n", "            ", "gt_seg_mask", "=", "instance_masks", "[", "s_i", "]", "\n", "gt_pix_count", "=", "instance_pix_count", "[", "s_i", "]", "\n", "\n", "pred_seg", "=", "np", ".", "where", "(", "gt_seg_mask", "==", "1", ",", "pred_sal_map", ",", "0", ")", "\n", "\n", "# number of pixels with predicted values", "\n", "pred_pix_loc", "=", "np", ".", "where", "(", "pred_seg", ">", "0", ")", "\n", "\n", "pred_pix_num", "=", "len", "(", "pred_pix_loc", "[", "0", "]", ")", "\n", "\n", "# Get rank of object", "\n", "r", "=", "0", "\n", "if", "pred_pix_num", ">", "int", "(", "gt_pix_count", "*", "SEG_THRESHOLD", ")", ":", "\n", "\n", "                ", "vals", "=", "pred_seg", "[", "pred_pix_loc", "[", "0", "]", ",", "pred_pix_loc", "[", "1", "]", "]", "\n", "\n", "mode", "=", "sc", ".", "mode", "(", "vals", ")", "[", "0", "]", "[", "0", "]", "\n", "r", "=", "mode", "\n", "\n", "", "pred_ranks", ".", "append", "(", "r", ")", "\n", "\n", "# ********** Load GT Rank", "\n", "", "gt_rank_order_list", "=", "gt_rank_order", "[", "i", "]", "\n", "\n", "# Get Gt Rank Order of salient objects", "\n", "gt_ranks", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "N", ")", ":", "\n", "            ", "s_idx", "=", "sal_obj_idx", "[", "j", "]", "\n", "gt_r", "=", "gt_rank_order_list", "[", "s_idx", "]", "\n", "gt_ranks", ".", "append", "(", "gt_r", ")", "\n", "\n", "# Remove objects with no saliency value in both list", "\n", "", "gt_ranks", ",", "pred_ranks", ",", "use_indices_list", "=", "get_usable_salient_objects_agreed", "(", "gt_ranks", ",", "pred_ranks", ")", "\n", "\n", "spr", "=", "None", "\n", "\n", "if", "len", "(", "gt_ranks", ")", ">", "1", ":", "\n", "            ", "spr", "=", "sc", ".", "spearmanr", "(", "gt_ranks", ",", "pred_ranks", ")", "\n", "", "elif", "len", "(", "gt_ranks", ")", "==", "1", ":", "\n", "            ", "spr", "=", "1", "\n", "\n", "", "d", "=", "[", "image_id", ",", "spr", ",", "use_indices_list", "]", "\n", "spr_data", ".", "append", "(", "d", ")", "\n", "\n", "# out_root = \"../spr_data/\"", "\n", "# out_path = out_root + \"spr_data\"", "\n", "# if not os.path.exists(out_root):", "\n", "#     os.makedirs(out_root)", "\n", "\n", "# with open(out_path, \"wb\") as f:", "\n", "#     pickle.dump(spr_data, f)", "\n", "", "return", "spr_data", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.extract_spr_value": [[363, 380], ["range", "len", "spr.append", "use_idx_list.append", "spr.append", "use_idx_list.append", "numpy.isnan"], "function", ["None"], ["", "def", "extract_spr_value", "(", "data_list", ")", ":", "\n", "    ", "use_idx_list", "=", "[", "]", "\n", "spr", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "data_list", ")", ")", ":", "\n", "        ", "s", "=", "data_list", "[", "i", "]", "[", "1", "]", "\n", "\n", "if", "s", "==", "1", ":", "\n", "            ", "spr", ".", "append", "(", "s", ")", "\n", "use_idx_list", ".", "append", "(", "i", ")", "\n", "", "elif", "s", "and", "not", "np", ".", "isnan", "(", "s", "[", "0", "]", ")", ":", "\n", "            ", "spr", ".", "append", "(", "s", "[", "0", "]", ")", "\n", "use_idx_list", ".", "append", "(", "i", ")", "\n", "", "else", ":", "\n", "# N = 0, not obj ranker_score > 0.5", "\n", "            ", "pass", "\n", "\n", "", "", "return", "spr", ",", "use_idx_list", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.cal_avg_spr": [[382, 386], ["numpy.array", "numpy.average"], "function", ["None"], ["", "def", "cal_avg_spr", "(", "data_list", ")", ":", "\n", "    ", "spr", "=", "np", ".", "array", "(", "data_list", ")", "\n", "avg", "=", "np", ".", "average", "(", "spr", ")", "\n", "return", "avg", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.get_norm_spr": [[388, 405], ["None"], "function", ["None"], ["", "def", "get_norm_spr", "(", "spr_value", ")", ":", "\n", "#       m - r_min", "\n", "# m -> ---------------- x (t_max - t_min) + t_min", "\n", "#       r_max - r_min", "\n", "#", "\n", "# m = measure value", "\n", "# r_min = min range of measurement", "\n", "# r_max = max range of measurement", "\n", "# t_min = min range of desired scale", "\n", "# t_max = max range of desired scale", "\n", "\n", "    ", "r_min", "=", "-", "1", "\n", "r_max", "=", "1", "\n", "\n", "norm_spr", "=", "(", "spr_value", "-", "r_min", ")", "/", "(", "r_max", "-", "r_min", ")", "\n", "\n", "return", "norm_spr", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_spr": [[407, 433], ["sor_eval.extract_spr_value", "range", "print", "print", "sor_eval.cal_avg_spr", "sor_eval.get_norm_spr", "print", "print", "print", "print", "len", "len", "len", "len", "len", "len", "pos_l.append", "neg_l.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.extract_spr_value", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.cal_avg_spr", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.get_norm_spr"], ["", "def", "eval_spr", "(", "spr_all_data", ")", ":", "\n", "# with open(spr_data_path, \"rb\") as f:", "\n", "#     spr_all_data = pickle.load(f)", "\n", "\n", "    ", "spr_data", ",", "spr_use_idx", "=", "extract_spr_value", "(", "spr_all_data", ")", "\n", "\n", "pos_l", "=", "[", "]", "\n", "neg_l", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "spr_data", ")", ")", ":", "\n", "        ", "if", "spr_data", "[", "i", "]", ">", "0", ":", "\n", "            ", "pos_l", ".", "append", "(", "spr_data", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "            ", "neg_l", ".", "append", "(", "spr_data", "[", "i", "]", ")", "\n", "\n", "", "", "print", "(", "\"Positive SPR: \"", ",", "len", "(", "pos_l", ")", ")", "\n", "print", "(", "\"Negative SPR: \"", ",", "len", "(", "neg_l", ")", ")", "\n", "\n", "avg_spr", "=", "cal_avg_spr", "(", "spr_data", ")", "\n", "avg_spr_norm", "=", "get_norm_spr", "(", "avg_spr", ")", "\n", "\n", "print", "(", "\"\\n----------------------------------------------------------\"", ")", "\n", "print", "(", "len", "(", "spr_data", ")", ",", "\"/\"", ",", "len", "(", "spr_all_data", ")", ",", "\" - \"", ",", "\n", "(", "len", "(", "spr_all_data", ")", "-", "len", "(", "spr_data", ")", ")", ",", "\"Images Not used\"", ")", "\n", "print", "(", "\"Average SPR Saliency: \"", ",", "avg_spr", ")", "\n", "print", "(", "\"Average SPR Saliency Normalized: \"", ",", "avg_spr_norm", ")", "\n", "return", "len", "(", "spr_data", ")", ",", "avg_spr_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_sor": [[434, 450], ["sor_eval.DatasetTest", "sor_eval.eval_mae", "sor_eval.calculate_spr", "sor_eval.eval_spr"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_mae", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.calculate_spr", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.evaluation.sor_eval.eval_spr"], ["", "def", "eval_sor", "(", "map_path", ",", "dataset_root", "=", "'datasets/ASSR/'", ")", ":", "\n", "    ", "data_split", "=", "\"test\"", "\n", "dataset", "=", "DatasetTest", "(", "dataset_root", ",", "\n", "data_split", ",", "eval_spr", "=", "True", ")", "\n", "\n", "# Calculate MAE", "\n", "avg_mae", "=", "eval_mae", "(", "dataset", ",", "map_path", ")", "\n", "\n", "####################################################", "\n", "# Calculate SOR", "\n", "spr_data", "=", "calculate_spr", "(", "dataset", ",", "map_path", ")", "\n", "image_used", ",", "sor", "=", "eval_spr", "(", "spr_data", ")", "\n", "return", "{", "\n", "'mae'", ":", "avg_mae", ",", "\n", "'image_used'", ":", "image_used", ",", "\n", "'sor'", ":", "sor", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.demo.setup_cfg": [[25, 37], ["centermask.config.get_cfg", "centermask.config.get_cfg.merge_from_file", "centermask.config.get_cfg.merge_from_list", "centermask.config.get_cfg.freeze"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.config.config.get_cfg"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "# load config from file and command-line arguments", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "# Set score_threshold for builtin models", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "FCOS", ".", "INFERENCE_TH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.demo.get_parser": [[39, 70], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Detectron2 Demo\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"configs/quick_schedules/e2e_mask_rcnn_R_50_FPN_inference_acc_test.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--webcam\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Take inputs from webcam.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--video-input\"", ",", "help", "=", "\"Path to video file.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--input\"", ",", "\n", "help", "=", "\"Input images dir\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "help", "=", "\"A file or directory to save output visualizations. \"", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--confidence-threshold\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.4", ",", "\n", "help", "=", "\"Minimum score for instance predictions to be shown\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.VisualizationDemo.__init__": [[16, 36], ["detectron2.data.MetadataCatalog.get", "torch.device", "torch.cuda.device_count", "predictor0.AsyncPredictor", "detectron2.engine.defaults.DefaultPredictor", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ",", "parallel", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            instance_mode (ColorMode):\n            parallel (bool): whether to run the model in different processes from visualization.\n                Useful since the visualization logic can be slow.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", "if", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "else", "\"__unused\"", "\n", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "instance_mode", "=", "instance_mode", "\n", "\n", "self", ".", "parallel", "=", "parallel", "\n", "if", "parallel", ":", "\n", "            ", "num_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "self", ".", "predictor", "=", "AsyncPredictor", "(", "cfg", ",", "num_gpus", "=", "num_gpu", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.VisualizationDemo.run_on_image": [[37, 69], ["predictor0.VisualizationDemo.predictor", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_panoptic_seg_predictions", "panoptic_seg.to", "detectron2.utils.visualizer.Visualizer.draw_sem_seg", "predictions[].to", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "predictions[].argmax().to", "predictions[].argmax"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_sem_seg", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "", "def", "run_on_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (np.ndarray): an image of shape (H, W, C) (in BGR order).\n                This is the format used by OpenCV.\n\n        Returns:\n            predictions (dict): the output of the model.\n            vis_output (VisImage): the visualized image output.\n        \"\"\"", "\n", "vis_output", "=", "None", "\n", "predictions", "=", "self", ".", "predictor", "(", "image", ")", "\n", "# Convert image from OpenCV BGR format to Matplotlib RGB format.", "\n", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "visualizer", "=", "Visualizer", "(", "image", ",", "self", ".", "metadata", ",", "\n", "instance_mode", "=", "self", ".", "instance_mode", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "            ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_output", "=", "visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_output", "=", "visualizer", ".", "draw_sem_seg", "(", "\n", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "", "if", "\"instances\"", "in", "predictions", ":", "\n", "                ", "instances", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_output", "=", "visualizer", ".", "draw_instance_predictions", "(", "\n", "predictions", "=", "instances", ")", "\n", "\n", "", "", "return", "predictions", ",", "vis_output", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.VisualizationDemo._frame_from_video": [[70, 77], ["video.isOpened", "video.read"], "methods", ["None"], ["", "def", "_frame_from_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "while", "video", ".", "isOpened", "(", ")", ":", "\n", "            ", "success", ",", "frame", "=", "video", ".", "read", "(", ")", "\n", "if", "success", ":", "\n", "                ", "yield", "frame", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.VisualizationDemo.run_on_video": [[78, 134], ["detectron2.utils.video_visualizer.VideoVisualizer", "predictor0.VisualizationDemo._frame_from_video", "cv2.cvtColor", "cv2.cvtColor", "collections.deque", "enumerate", "len", "detectron2.utils.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "detectron2.utils.video_visualizer.VideoVisualizer.draw_sem_seg.get_image", "collections.deque.append", "predictor0.VisualizationDemo.predictor.put", "collections.deque.popleft", "predictor0.VisualizationDemo.predictor.get", "panoptic_seg.to", "predictions[].to", "detectron2.utils.video_visualizer.VideoVisualizer.draw_instance_predictions", "collections.deque.popleft", "predictor0.VisualizationDemo.predictor.get", "predictor0.VisualizationDemo.run_on_video.process_predictions"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo._frame_from_video", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "", "", "def", "run_on_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "\"\"\"\n        Visualizes predictions on frames of the input video.\n\n        Args:\n            video (cv2.VideoCapture): a :class:`VideoCapture` object, whose source can be\n                either a webcam or a video file.\n\n        Yields:\n            ndarray: BGR visualizations of each video frame.\n        \"\"\"", "\n", "video_visualizer", "=", "VideoVisualizer", "(", "self", ".", "metadata", ",", "self", ".", "instance_mode", ")", "\n", "\n", "def", "process_predictions", "(", "frame", ",", "predictions", ")", ":", "\n", "            ", "frame", "=", "cv2", ".", "cvtColor", "(", "frame", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "                ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "frame", ",", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "elif", "\"instances\"", "in", "predictions", ":", "\n", "                ", "predictions", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_instance_predictions", "(", "\n", "frame", ",", "predictions", ")", "\n", "", "elif", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_frame", "=", "video_visualizer", ".", "draw_sem_seg", "(", "\n", "frame", ",", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "\n", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "\n", "# Converts Matplotlib RGB format to OpenCV BGR format", "\n", "", "vis_frame", "=", "cv2", ".", "cvtColor", "(", "vis_frame", ".", "get_image", "(", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "return", "vis_frame", "\n", "\n", "", "frame_gen", "=", "self", ".", "_frame_from_video", "(", "video", ")", "\n", "if", "self", ".", "parallel", ":", "\n", "            ", "buffer_size", "=", "self", ".", "predictor", ".", "default_buffer_size", "\n", "\n", "frame_data", "=", "deque", "(", ")", "\n", "\n", "for", "cnt", ",", "frame", "in", "enumerate", "(", "frame_gen", ")", ":", "\n", "                ", "frame_data", ".", "append", "(", "frame", ")", "\n", "self", ".", "predictor", ".", "put", "(", "frame", ")", "\n", "\n", "if", "cnt", ">=", "buffer_size", ":", "\n", "                    ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "\n", "", "", "while", "len", "(", "frame_data", ")", ":", "\n", "                ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "frame", "in", "frame_gen", ":", "\n", "                ", "yield", "process_predictions", "(", "frame", ",", "self", ".", "predictor", "(", "frame", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.__init__": [[164, 192], ["max", "multiprocessing.Queue", "multiprocessing.Queue", "range", "atexit.register", "max", "cfg.clone.clone.clone", "cfg.clone.clone.defrost", "predictor0.AsyncPredictor.procs.append", "p.start", "AsyncPredictor._PredictWorker"], "methods", ["None"], ["", "", "", "def", "__init__", "(", "self", ",", "cfg", ",", "num_gpus", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            num_gpus (int): if 0, will run on CPU\n        \"\"\"", "\n", "num_workers", "=", "max", "(", "num_gpus", ",", "1", ")", "\n", "self", ".", "task_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "result_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "procs", "=", "[", "]", "\n", "for", "gpuid", "in", "range", "(", "max", "(", "num_gpus", ",", "1", ")", ")", ":", "\n", "            ", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cuda:{}\"", ".", "format", "(", "\n", "gpuid", ")", "if", "num_gpus", ">", "0", "else", "\"cpu\"", "\n", "self", ".", "procs", ".", "append", "(", "\n", "AsyncPredictor", ".", "_PredictWorker", "(", "\n", "cfg", ",", "self", ".", "task_queue", ",", "self", ".", "result_queue", ")", "\n", ")", "\n", "\n", "", "self", ".", "put_idx", "=", "0", "\n", "self", ".", "get_idx", "=", "0", "\n", "self", ".", "result_rank", "=", "[", "]", "\n", "self", ".", "result_data", "=", "[", "]", "\n", "\n", "for", "p", "in", "self", ".", "procs", ":", "\n", "            ", "p", ".", "start", "(", ")", "\n", "", "atexit", ".", "register", "(", "self", ".", "shutdown", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.put": [[193, 196], ["predictor0.AsyncPredictor.task_queue.put"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put"], ["", "def", "put", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put_idx", "+=", "1", "\n", "self", ".", "task_queue", ".", "put", "(", "(", "self", ".", "put_idx", ",", "image", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.get": [[197, 212], ["len", "predictor0.AsyncPredictor.result_queue.get", "bisect.bisect", "predictor0.AsyncPredictor.result_rank.insert", "predictor0.AsyncPredictor.result_data.insert"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "self", ".", "get_idx", "+=", "1", "# the index needed for this request", "\n", "if", "len", "(", "self", ".", "result_rank", ")", "and", "self", ".", "result_rank", "[", "0", "]", "==", "self", ".", "get_idx", ":", "\n", "            ", "res", "=", "self", ".", "result_data", "[", "0", "]", "\n", "del", "self", ".", "result_data", "[", "0", "]", ",", "self", ".", "result_rank", "[", "0", "]", "\n", "return", "res", "\n", "\n", "", "while", "True", ":", "\n", "# make sure the results are returned in the correct order", "\n", "            ", "idx", ",", "res", "=", "self", ".", "result_queue", ".", "get", "(", ")", "\n", "if", "idx", "==", "self", ".", "get_idx", ":", "\n", "                ", "return", "res", "\n", "", "insert", "=", "bisect", ".", "bisect", "(", "self", ".", "result_rank", ",", "idx", ")", "\n", "self", ".", "result_rank", ".", "insert", "(", "insert", ",", "idx", ")", "\n", "self", ".", "result_data", ".", "insert", "(", "insert", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.__len__": [[213, 215], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "put_idx", "-", "self", ".", "get_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.__call__": [[216, 219], ["predictor0.AsyncPredictor.put", "predictor0.AsyncPredictor.get"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put", "(", "image", ")", "\n", "return", "self", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.shutdown": [[220, 223], ["predictor0.AsyncPredictor.task_queue.put", "AsyncPredictor._StopToken"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put"], ["", "def", "shutdown", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "self", ".", "procs", ":", "\n", "            ", "self", ".", "task_queue", ".", "put", "(", "AsyncPredictor", ".", "_StopToken", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor0.AsyncPredictor.default_buffer_size": [[224, 227], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "default_buffer_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "procs", ")", "*", "5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo.__init__": [[19, 39], ["detectron2.data.MetadataCatalog.get", "torch.device", "torch.cuda.device_count", "predictor.AsyncPredictor", "detectron2.engine.defaults.DefaultPredictor", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ",", "parallel", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            instance_mode (ColorMode):\n            parallel (bool): whether to run the model in different processes from visualization.\n                Useful since the visualization logic can be slow.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", "if", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "else", "\"__unused\"", "\n", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "instance_mode", "=", "instance_mode", "\n", "\n", "self", ".", "parallel", "=", "parallel", "\n", "if", "parallel", ":", "\n", "            ", "num_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "self", ".", "predictor", "=", "AsyncPredictor", "(", "cfg", ",", "num_gpus", "=", "num_gpu", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo.run_on_image": [[40, 73], ["predictor.VisualizationDemo.predictor", "detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.vis_inst", "predictor.VisualizationDemo.vis_bases", "detectron2.utils.visualizer.Visualizer.draw_panoptic_seg_predictions", "panoptic_seg.to", "detectron2.utils.visualizer.Visualizer.draw_sem_seg", "predictions[].to", "detectron2.utils.visualizer.Visualizer.draw_instance_predictions", "predictions[].argmax().to", "predictions[].argmax"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo.vis_bases", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_sem_seg", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_instance_predictions"], ["", "", "def", "run_on_image", "(", "self", ",", "image", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            image (np.ndarray): an image of shape (H, W, C) (in BGR order).\n                This is the format used by OpenCV.\n\n        Returns:\n            predictions (dict): the output of the model.\n            vis_output (VisImage): the visualized image output.\n        \"\"\"", "\n", "vis_output", "=", "None", "\n", "predictions", "=", "self", ".", "predictor", "(", "image", ")", "\n", "# Convert image from OpenCV BGR format to Matplotlib RGB format.", "\n", "image", "=", "image", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "visualizer", "=", "Visualizer", "(", "image", ",", "self", ".", "metadata", ",", "instance_mode", "=", "self", ".", "instance_mode", ")", "\n", "if", "\"inst\"", "in", "predictions", ":", "\n", "            ", "visualizer", ".", "vis_inst", "(", "predictions", "[", "\"inst\"", "]", ")", "\n", "", "if", "\"bases\"", "in", "predictions", ":", "\n", "            ", "self", ".", "vis_bases", "(", "predictions", "[", "\"bases\"", "]", ")", "\n", "", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "            ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_output", "=", "visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "else", ":", "\n", "            ", "if", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_output", "=", "visualizer", ".", "draw_sem_seg", "(", "\n", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", ")", "\n", "", "if", "\"instances\"", "in", "predictions", ":", "\n", "                ", "instances", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_output", "=", "visualizer", ".", "draw_instance_predictions", "(", "predictions", "=", "instances", ")", "\n", "\n", "", "", "return", "predictions", ",", "vis_output", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo._frame_from_video": [[74, 81], ["video.isOpened", "video.read"], "methods", ["None"], ["", "def", "_frame_from_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "while", "video", ".", "isOpened", "(", ")", ":", "\n", "            ", "success", ",", "frame", "=", "video", ".", "read", "(", ")", "\n", "if", "success", ":", "\n", "                ", "yield", "frame", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo.vis_bases": [[82, 98], ["bases[].squeeze", "len", "matplotlib.subplots", "enumerate", "matplotlib.show", "numpy.zeros", "numpy.uint8", "cv2.cvtColor", "[].imshow", "basis.max"], "methods", ["None"], ["", "", "", "def", "vis_bases", "(", "self", ",", "bases", ")", ":", "\n", "        ", "basis_colors", "=", "[", "[", "2", ",", "200", ",", "255", "]", ",", "[", "107", ",", "220", ",", "255", "]", ",", "[", "30", ",", "200", ",", "255", "]", ",", "[", "60", ",", "220", ",", "255", "]", "]", "\n", "bases", "=", "bases", "[", "0", "]", ".", "squeeze", "(", ")", "\n", "bases", "=", "(", "bases", "/", "8", ")", ".", "tanh", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "num_bases", "=", "len", "(", "bases", ")", "\n", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "nrows", "=", "num_bases", "//", "2", ",", "ncols", "=", "2", ")", "\n", "for", "i", ",", "basis", "in", "enumerate", "(", "bases", ")", ":", "\n", "            ", "basis", "=", "(", "basis", "+", "1", ")", "/", "2", "\n", "basis", "=", "basis", "/", "basis", ".", "max", "(", ")", "\n", "basis_viz", "=", "np", ".", "zeros", "(", "(", "basis", ".", "shape", "[", "0", "]", ",", "basis", ".", "shape", "[", "1", "]", ",", "3", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "basis_viz", "[", ":", ",", ":", ",", "0", "]", "=", "basis_colors", "[", "i", "]", "[", "0", "]", "\n", "basis_viz", "[", ":", ",", ":", ",", "1", "]", "=", "basis_colors", "[", "i", "]", "[", "1", "]", "\n", "basis_viz", "[", ":", ",", ":", ",", "2", "]", "=", "np", ".", "uint8", "(", "basis", "*", "255", ")", "\n", "basis_viz", "=", "cv2", ".", "cvtColor", "(", "basis_viz", ",", "cv2", ".", "COLOR_HSV2RGB", ")", "\n", "axes", "[", "i", "//", "2", "]", "[", "i", "%", "2", "]", ".", "imshow", "(", "basis_viz", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo.run_on_video": [[99, 153], ["video_visualizer.VideoVisualizer.VideoVisualizer", "predictor.VisualizationDemo._frame_from_video", "cv2.cvtColor", "cv2.cvtColor", "collections.deque", "enumerate", "len", "video_visualizer.VideoVisualizer.VideoVisualizer.draw_panoptic_seg_predictions", "video_visualizer.VideoVisualizer.draw_sem_seg.get_image", "collections.deque.append", "predictor.VisualizationDemo.predictor.put", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "panoptic_seg.to", "predictions[].to", "video_visualizer.VideoVisualizer.VideoVisualizer.draw_instance_predictions", "collections.deque.popleft", "predictor.VisualizationDemo.predictor.get", "predictor.VisualizationDemo.run_on_video.process_predictions"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.VisualizationDemo._frame_from_video", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_instance_predictions", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "run_on_video", "(", "self", ",", "video", ")", ":", "\n", "        ", "\"\"\"\n        Visualizes predictions on frames of the input video.\n\n        Args:\n            video (cv2.VideoCapture): a :class:`VideoCapture` object, whose source can be\n                either a webcam or a video file.\n\n        Yields:\n            ndarray: BGR visualizations of each video frame.\n        \"\"\"", "\n", "video_visualizer", "=", "VideoVisualizer", "(", "self", ".", "metadata", ",", "self", ".", "instance_mode", ")", "\n", "\n", "def", "process_predictions", "(", "frame", ",", "predictions", ")", ":", "\n", "            ", "frame", "=", "cv2", ".", "cvtColor", "(", "frame", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "if", "\"panoptic_seg\"", "in", "predictions", ":", "\n", "                ", "panoptic_seg", ",", "segments_info", "=", "predictions", "[", "\"panoptic_seg\"", "]", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_panoptic_seg_predictions", "(", "\n", "frame", ",", "panoptic_seg", ".", "to", "(", "self", ".", "cpu_device", ")", ",", "segments_info", "\n", ")", "\n", "", "elif", "\"instances\"", "in", "predictions", ":", "\n", "                ", "predictions", "=", "predictions", "[", "\"instances\"", "]", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", "vis_frame", "=", "video_visualizer", ".", "draw_instance_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "elif", "\"sem_seg\"", "in", "predictions", ":", "\n", "                ", "vis_frame", "=", "video_visualizer", ".", "draw_sem_seg", "(", "\n", "frame", ",", "predictions", "[", "\"sem_seg\"", "]", ".", "argmax", "(", "dim", "=", "0", ")", ".", "to", "(", "self", ".", "cpu_device", ")", "\n", ")", "\n", "\n", "# Converts Matplotlib RGB format to OpenCV BGR format", "\n", "", "vis_frame", "=", "cv2", ".", "cvtColor", "(", "vis_frame", ".", "get_image", "(", ")", ",", "cv2", ".", "COLOR_RGB2BGR", ")", "\n", "return", "vis_frame", "\n", "\n", "", "frame_gen", "=", "self", ".", "_frame_from_video", "(", "video", ")", "\n", "if", "self", ".", "parallel", ":", "\n", "            ", "buffer_size", "=", "self", ".", "predictor", ".", "default_buffer_size", "\n", "\n", "frame_data", "=", "deque", "(", ")", "\n", "\n", "for", "cnt", ",", "frame", "in", "enumerate", "(", "frame_gen", ")", ":", "\n", "                ", "frame_data", ".", "append", "(", "frame", ")", "\n", "self", ".", "predictor", ".", "put", "(", "frame", ")", "\n", "\n", "if", "cnt", ">=", "buffer_size", ":", "\n", "                    ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "\n", "", "", "while", "len", "(", "frame_data", ")", ":", "\n", "                ", "frame", "=", "frame_data", ".", "popleft", "(", ")", "\n", "predictions", "=", "self", ".", "predictor", ".", "get", "(", ")", "\n", "yield", "process_predictions", "(", "frame", ",", "predictions", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "frame", "in", "frame_gen", ":", "\n", "                ", "yield", "process_predictions", "(", "frame", ",", "self", ".", "predictor", "(", "frame", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.__init__": [[183, 209], ["max", "multiprocessing.Queue", "multiprocessing.Queue", "range", "atexit.register", "max", "cfg.clone.clone.clone", "cfg.clone.clone.defrost", "predictor.AsyncPredictor.procs.append", "p.start", "AsyncPredictor._PredictWorker"], "methods", ["None"], ["", "", "", "def", "__init__", "(", "self", ",", "cfg", ",", "num_gpus", ":", "int", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            num_gpus (int): if 0, will run on CPU\n        \"\"\"", "\n", "num_workers", "=", "max", "(", "num_gpus", ",", "1", ")", "\n", "self", ".", "task_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "result_queue", "=", "mp", ".", "Queue", "(", "maxsize", "=", "num_workers", "*", "3", ")", "\n", "self", ".", "procs", "=", "[", "]", "\n", "for", "gpuid", "in", "range", "(", "max", "(", "num_gpus", ",", "1", ")", ")", ":", "\n", "            ", "cfg", "=", "cfg", ".", "clone", "(", ")", "\n", "cfg", ".", "defrost", "(", ")", "\n", "cfg", ".", "MODEL", ".", "DEVICE", "=", "\"cuda:{}\"", ".", "format", "(", "gpuid", ")", "if", "num_gpus", ">", "0", "else", "\"cpu\"", "\n", "self", ".", "procs", ".", "append", "(", "\n", "AsyncPredictor", ".", "_PredictWorker", "(", "cfg", ",", "self", ".", "task_queue", ",", "self", ".", "result_queue", ")", "\n", ")", "\n", "\n", "", "self", ".", "put_idx", "=", "0", "\n", "self", ".", "get_idx", "=", "0", "\n", "self", ".", "result_rank", "=", "[", "]", "\n", "self", ".", "result_data", "=", "[", "]", "\n", "\n", "for", "p", "in", "self", ".", "procs", ":", "\n", "            ", "p", ".", "start", "(", ")", "\n", "", "atexit", ".", "register", "(", "self", ".", "shutdown", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put": [[210, 213], ["predictor.AsyncPredictor.task_queue.put"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put"], ["", "def", "put", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put_idx", "+=", "1", "\n", "self", ".", "task_queue", ".", "put", "(", "(", "self", ".", "put_idx", ",", "image", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get": [[214, 229], ["len", "predictor.AsyncPredictor.result_queue.get", "bisect.bisect", "predictor.AsyncPredictor.result_rank.insert", "predictor.AsyncPredictor.result_data.insert"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "get", "(", "self", ")", ":", "\n", "        ", "self", ".", "get_idx", "+=", "1", "# the index needed for this request", "\n", "if", "len", "(", "self", ".", "result_rank", ")", "and", "self", ".", "result_rank", "[", "0", "]", "==", "self", ".", "get_idx", ":", "\n", "            ", "res", "=", "self", ".", "result_data", "[", "0", "]", "\n", "del", "self", ".", "result_data", "[", "0", "]", ",", "self", ".", "result_rank", "[", "0", "]", "\n", "return", "res", "\n", "\n", "", "while", "True", ":", "\n", "# make sure the results are returned in the correct order", "\n", "            ", "idx", ",", "res", "=", "self", ".", "result_queue", ".", "get", "(", ")", "\n", "if", "idx", "==", "self", ".", "get_idx", ":", "\n", "                ", "return", "res", "\n", "", "insert", "=", "bisect", ".", "bisect", "(", "self", ".", "result_rank", ",", "idx", ")", "\n", "self", ".", "result_rank", ".", "insert", "(", "insert", ",", "idx", ")", "\n", "self", ".", "result_data", ".", "insert", "(", "insert", ",", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.__len__": [[230, 232], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "put_idx", "-", "self", ".", "get_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.__call__": [[233, 236], ["predictor.AsyncPredictor.put", "predictor.AsyncPredictor.get"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "__call__", "(", "self", ",", "image", ")", ":", "\n", "        ", "self", ".", "put", "(", "image", ")", "\n", "return", "self", ".", "get", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.shutdown": [[237, 240], ["predictor.AsyncPredictor.task_queue.put", "AsyncPredictor._StopToken"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.put"], ["", "def", "shutdown", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "self", ".", "procs", ":", "\n", "            ", "self", ".", "task_queue", ".", "put", "(", "AsyncPredictor", ".", "_StopToken", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.default_buffer_size": [[241, 244], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "default_buffer_size", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "procs", ")", "*", "5", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer._DetectedInstance.__init__": [[31, 37], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "label", ",", "bbox", ",", "mask_rle", ",", "color", ",", "ttl", ")", ":", "\n", "        ", "self", ".", "label", "=", "label", "\n", "self", ".", "bbox", "=", "bbox", "\n", "self", ".", "mask_rle", "=", "mask_rle", "\n", "self", ".", "color", "=", "color", "\n", "self", ".", "ttl", "=", "ttl", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.__init__": [[40, 52], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "metadata", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            metadata (MetadataCatalog): image metadata.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "metadata", "\n", "self", ".", "_old_instances", "=", "[", "]", "\n", "assert", "instance_mode", "in", "[", "\n", "ColorMode", ".", "IMAGE", ",", "\n", "ColorMode", ".", "IMAGE_BW", ",", "\n", "]", ",", "\"Other mode not supported yet.\"", "\n", "self", ".", "_instance_mode", "=", "instance_mode", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_instance_predictions": [[53, 112], ["detectron2.utils.visualizer.Visualizer", "len", "predictions.has", "video_visualizer.VideoVisualizer._assign_colors", "detectron2.utils.visualizer._create_text_labels", "detectron2.utils.visualizer.Visualizer.overlay_instances", "predictions.has", "predictions.pred_boxes.tensor.numpy", "predictions.has", "predictions.has", "predictions.pred_classes.numpy", "predictions.has", "video_visualizer._DetectedInstance", "video_visualizer.VideoVisualizer.metadata.get", "detectron2.utils.visualizer.Visualizer._create_grayscale_image", "range", "masks.any"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer._assign_colors", "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "draw_instance_predictions", "(", "self", ",", "frame", ",", "predictions", ")", ":", "\n", "        ", "\"\"\"\n        Draw instance-level prediction results on an image.\n\n        Args:\n            frame (ndarray): an RGB image of shape (H, W, C), in the range [0, 255].\n            predictions (Instances): the output of an instance detection/segmentation\n                model. Following fields will be used to draw:\n                \"pred_boxes\", \"pred_classes\", \"scores\", \"pred_masks\" (or \"pred_masks_rle\").\n\n        Returns:\n            output (VisImage): image object with visualizations.\n        \"\"\"", "\n", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "num_instances", "=", "len", "(", "predictions", ")", "\n", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "frame_visualizer", ".", "output", "\n", "\n", "", "boxes", "=", "predictions", ".", "pred_boxes", ".", "tensor", ".", "numpy", "(", ")", "if", "predictions", ".", "has", "(", "\"pred_boxes\"", ")", "else", "None", "\n", "scores", "=", "predictions", ".", "scores", "if", "predictions", ".", "has", "(", "\"scores\"", ")", "else", "None", "\n", "classes", "=", "predictions", ".", "pred_classes", ".", "numpy", "(", ")", "if", "predictions", ".", "has", "(", "\"pred_classes\"", ")", "else", "None", "\n", "keypoints", "=", "predictions", ".", "pred_keypoints", "if", "predictions", ".", "has", "(", "\"pred_keypoints\"", ")", "else", "None", "\n", "\n", "if", "predictions", ".", "has", "(", "\"pred_masks\"", ")", ":", "\n", "            ", "masks", "=", "predictions", ".", "pred_masks", "\n", "# mask IOU is not yet enabled", "\n", "# masks_rles = mask_util.encode(np.asarray(masks.permute(1, 2, 0), order=\"F\"))", "\n", "# assert len(masks_rles) == num_instances", "\n", "", "else", ":", "\n", "            ", "masks", "=", "None", "\n", "\n", "", "detected", "=", "[", "\n", "_DetectedInstance", "(", "classes", "[", "i", "]", ",", "boxes", "[", "i", "]", ",", "mask_rle", "=", "None", ",", "color", "=", "None", ",", "ttl", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", "\n", "]", "\n", "colors", "=", "self", ".", "_assign_colors", "(", "detected", ")", "\n", "\n", "labels", "=", "_create_text_labels", "(", "classes", ",", "scores", ",", "self", ".", "metadata", ".", "get", "(", "\"thing_classes\"", ",", "None", ")", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "# any() returns uint8 tensor", "\n", "            ", "frame_visualizer", ".", "output", ".", "img", "=", "frame_visualizer", ".", "_create_grayscale_image", "(", "\n", "(", "masks", ".", "any", "(", "dim", "=", "0", ")", ">", "0", ")", ".", "numpy", "(", ")", "if", "masks", "is", "not", "None", "else", "None", "\n", ")", "\n", "alpha", "=", "0.3", "\n", "", "else", ":", "\n", "            ", "alpha", "=", "0.5", "\n", "\n", "", "frame_visualizer", ".", "overlay_instances", "(", "\n", "# boxes=None if masks is not None else boxes,  # boxes are a bit distracting", "\n", "boxes", "=", "boxes", ",", "\n", "masks", "=", "masks", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "keypoints", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_sem_seg": [[113, 124], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer.Visualizer.draw_sem_seg"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_sem_seg"], ["", "def", "draw_sem_seg", "(", "self", ",", "frame", ",", "sem_seg", ",", "area_threshold", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            sem_seg (ndarray or Tensor): semantic segmentation of shape (H, W),\n                each value is the integer label.\n            area_threshold (Optional[int]): only draw segmentations larger than the threshold\n        \"\"\"", "\n", "# don't need to do anything special", "\n", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "frame_visualizer", ".", "draw_sem_seg", "(", "sem_seg", ",", "area_threshold", "=", "None", ")", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer.draw_panoptic_seg_predictions": [[125, 180], ["detectron2.utils.visualizer.Visualizer", "detectron2.utils.visualizer._PanopticPrediction", "detectron2.utils.visualizer._PanopticPrediction.semantic_masks", "list", "list", "len", "pycocotools.encode", "video_visualizer.VideoVisualizer._assign_colors", "detectron2.utils.visualizer.Visualizer.overlay_instances", "detectron2.utils.visualizer.Visualizer._create_grayscale_image", "detectron2.utils.visualizer.Visualizer.draw_binary_mask", "detectron2.utils.visualizer._PanopticPrediction.instance_masks", "len", "zip", "numpy.asarray", "len", "video_visualizer._DetectedInstance", "detectron2.utils.visualizer._PanopticPrediction.non_empty_mask", "numpy.asarray().transpose", "range", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer._assign_colors"], ["", "def", "draw_panoptic_seg_predictions", "(", "\n", "self", ",", "frame", ",", "panoptic_seg", ",", "segments_info", ",", "area_threshold", "=", "None", ",", "alpha", "=", "0.5", "\n", ")", ":", "\n", "        ", "frame_visualizer", "=", "Visualizer", "(", "frame", ",", "self", ".", "metadata", ")", "\n", "pred", "=", "_PanopticPrediction", "(", "panoptic_seg", ",", "segments_info", ")", "\n", "\n", "if", "self", ".", "_instance_mode", "==", "ColorMode", ".", "IMAGE_BW", ":", "\n", "            ", "frame_visualizer", ".", "output", ".", "img", "=", "frame_visualizer", ".", "_create_grayscale_image", "(", "\n", "pred", ".", "non_empty_mask", "(", ")", "\n", ")", "\n", "\n", "# draw mask for all semantic segments first i.e. \"stuff\"", "\n", "", "for", "mask", ",", "sinfo", "in", "pred", ".", "semantic_masks", "(", ")", ":", "\n", "            ", "category_idx", "=", "sinfo", "[", "\"category_id\"", "]", "\n", "try", ":", "\n", "                ", "mask_color", "=", "[", "x", "/", "255", "for", "x", "in", "self", ".", "metadata", ".", "stuff_colors", "[", "category_idx", "]", "]", "\n", "", "except", "AttributeError", ":", "\n", "                ", "mask_color", "=", "None", "\n", "\n", "", "frame_visualizer", ".", "draw_binary_mask", "(", "\n", "mask", ",", "\n", "color", "=", "mask_color", ",", "\n", "text", "=", "self", ".", "metadata", ".", "stuff_classes", "[", "category_idx", "]", ",", "\n", "alpha", "=", "alpha", ",", "\n", "area_threshold", "=", "area_threshold", ",", "\n", ")", "\n", "\n", "", "all_instances", "=", "list", "(", "pred", ".", "instance_masks", "(", ")", ")", "\n", "if", "len", "(", "all_instances", ")", "==", "0", ":", "\n", "            ", "return", "frame_visualizer", ".", "output", "\n", "# draw mask for all instances second", "\n", "", "masks", ",", "sinfo", "=", "list", "(", "zip", "(", "*", "all_instances", ")", ")", "\n", "num_instances", "=", "len", "(", "masks", ")", "\n", "masks_rles", "=", "mask_util", ".", "encode", "(", "\n", "np", ".", "asarray", "(", "np", ".", "asarray", "(", "masks", ")", ".", "transpose", "(", "1", ",", "2", ",", "0", ")", ",", "dtype", "=", "np", ".", "uint8", ",", "order", "=", "\"F\"", ")", "\n", ")", "\n", "assert", "len", "(", "masks_rles", ")", "==", "num_instances", "\n", "\n", "category_ids", "=", "[", "x", "[", "\"category_id\"", "]", "for", "x", "in", "sinfo", "]", "\n", "detected", "=", "[", "\n", "_DetectedInstance", "(", "category_ids", "[", "i", "]", ",", "bbox", "=", "None", ",", "mask_rle", "=", "masks_rles", "[", "i", "]", ",", "color", "=", "None", ",", "ttl", "=", "8", ")", "\n", "for", "i", "in", "range", "(", "num_instances", ")", "\n", "]", "\n", "colors", "=", "self", ".", "_assign_colors", "(", "detected", ")", "\n", "labels", "=", "[", "self", ".", "metadata", ".", "thing_classes", "[", "k", "]", "for", "k", "in", "category_ids", "]", "\n", "\n", "frame_visualizer", ".", "overlay_instances", "(", "\n", "boxes", "=", "None", ",", "\n", "masks", "=", "masks", ",", "\n", "labels", "=", "labels", ",", "\n", "keypoints", "=", "None", ",", "\n", "assigned_colors", "=", "colors", ",", "\n", "alpha", "=", "alpha", ",", "\n", ")", "\n", "return", "frame_visualizer", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.video_visualizer.VideoVisualizer._assign_colors": [[181, 237], ["numpy.zeros", "enumerate", "numpy.asarray().argmax", "numpy.asarray().max", "enumerate", "pycocotools.iou", "pycocotools.iou", "len", "numpy.zeros", "enumerate", "len", "numpy.asarray", "numpy.asarray", "extra_instances.append", "detectron2.utils.colormap.random_color", "len", "len"], "methods", ["None"], ["", "def", "_assign_colors", "(", "self", ",", "instances", ")", ":", "\n", "        ", "\"\"\"\n        Naive tracking heuristics to assign same color to the same instance,\n        will update the internal state of tracked instances.\n\n        Returns:\n            list[tuple[float]]: list of colors.\n        \"\"\"", "\n", "\n", "# Compute iou with either boxes or masks:", "\n", "is_crowd", "=", "np", ".", "zeros", "(", "(", "len", "(", "instances", ")", ",", ")", ",", "dtype", "=", "np", ".", "bool", ")", "\n", "if", "instances", "[", "0", "]", ".", "bbox", "is", "None", ":", "\n", "            ", "assert", "instances", "[", "0", "]", ".", "mask_rle", "is", "not", "None", "\n", "# use mask iou only when box iou is None", "\n", "# because box seems good enough", "\n", "rles_old", "=", "[", "x", ".", "mask_rle", "for", "x", "in", "self", ".", "_old_instances", "]", "\n", "rles_new", "=", "[", "x", ".", "mask_rle", "for", "x", "in", "instances", "]", "\n", "ious", "=", "mask_util", ".", "iou", "(", "rles_old", ",", "rles_new", ",", "is_crowd", ")", "\n", "threshold", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "boxes_old", "=", "[", "x", ".", "bbox", "for", "x", "in", "self", ".", "_old_instances", "]", "\n", "boxes_new", "=", "[", "x", ".", "bbox", "for", "x", "in", "instances", "]", "\n", "ious", "=", "mask_util", ".", "iou", "(", "boxes_old", ",", "boxes_new", ",", "is_crowd", ")", "\n", "threshold", "=", "0.6", "\n", "", "if", "len", "(", "ious", ")", "==", "0", ":", "\n", "            ", "ious", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "_old_instances", ")", ",", "len", "(", "instances", ")", ")", ",", "dtype", "=", "\"float32\"", ")", "\n", "\n", "# Only allow matching instances of the same label:", "\n", "", "for", "old_idx", ",", "old", "in", "enumerate", "(", "self", ".", "_old_instances", ")", ":", "\n", "            ", "for", "new_idx", ",", "new", "in", "enumerate", "(", "instances", ")", ":", "\n", "                ", "if", "old", ".", "label", "!=", "new", ".", "label", ":", "\n", "                    ", "ious", "[", "old_idx", ",", "new_idx", "]", "=", "0", "\n", "\n", "", "", "", "matched_new_per_old", "=", "np", ".", "asarray", "(", "ious", ")", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_iou_per_old", "=", "np", ".", "asarray", "(", "ious", ")", ".", "max", "(", "axis", "=", "1", ")", "\n", "\n", "# Try to find match for each old instance:", "\n", "extra_instances", "=", "[", "]", "\n", "for", "idx", ",", "inst", "in", "enumerate", "(", "self", ".", "_old_instances", ")", ":", "\n", "            ", "if", "max_iou_per_old", "[", "idx", "]", ">", "threshold", ":", "\n", "                ", "newidx", "=", "matched_new_per_old", "[", "idx", "]", "\n", "if", "instances", "[", "newidx", "]", ".", "color", "is", "None", ":", "\n", "                    ", "instances", "[", "newidx", "]", ".", "color", "=", "inst", ".", "color", "\n", "continue", "\n", "# If an old instance does not match any new instances,", "\n", "# keep it for the next frame in case it is just missed by the detector", "\n", "", "", "inst", ".", "ttl", "-=", "1", "\n", "if", "inst", ".", "ttl", ">", "0", ":", "\n", "                ", "extra_instances", ".", "append", "(", "inst", ")", "\n", "\n", "# Assign random color to newly-detected instances:", "\n", "", "", "for", "inst", "in", "instances", ":", "\n", "            ", "if", "inst", ".", "color", "is", "None", ":", "\n", "                ", "inst", ".", "color", "=", "random_color", "(", "rgb", "=", "True", ",", "maximum", "=", "1", ")", "\n", "", "", "self", ".", "_old_instances", "=", "instances", "[", ":", "]", "+", "extra_instances", "\n", "return", "[", "d", ".", "color", "for", "d", "in", "instances", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.demo0.setup_cfg": [[20, 34], ["detectron2.config.get_cfg", "detectron2.config.get_cfg.merge_from_file", "detectron2.config.get_cfg.merge_from_list", "detectron2.config.get_cfg.freeze"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.config.config.get_cfg"], ["def", "setup_cfg", "(", "args", ")", ":", "\n", "# load config from file and command-line arguments", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "# To use demo for Panoptic-DeepLab, please uncomment the following two lines.", "\n", "# from detectron2.projects.panoptic_deeplab import add_panoptic_deeplab_config  # noqa", "\n", "# add_panoptic_deeplab_config(cfg)", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n", "cfg", ".", "merge_from_list", "(", "args", ".", "opts", ")", "\n", "# Set score_threshold for builtin models", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.demo0.get_parser": [[36, 73], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "\"Detectron2 demo for builtin configs\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"configs/quick_schedules/mask_rcnn_R_50_FPN_inference_acc_test.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--webcam\"", ",", "action", "=", "\"store_true\"", ",", "\n", "help", "=", "\"Take inputs from webcam.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--video-input\"", ",", "help", "=", "\"Path to video file.\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--input\"", ",", "\n", "nargs", "=", "\"+\"", ",", "\n", "help", "=", "\"A list of space separated input images; \"", "\n", "\"or a single glob pattern such as 'directory/*.jpg'\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "help", "=", "\"A file or directory to save output visualizations. \"", "\n", "\"If not given, will show output in an OpenCV window.\"", ",", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--confidence-threshold\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.5", ",", "\n", "help", "=", "\"Minimum score for instance predictions to be shown\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--opts\"", ",", "\n", "help", "=", "\"Modify config options using the command-line 'KEY VALUE' pairs\"", ",", "\n", "default", "=", "[", "]", ",", "\n", "nargs", "=", "argparse", ".", "REMAINDER", ",", "\n", ")", "\n", "return", "parser", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor.assr_register.get_assr_dicts": [[9, 49], ["pathlib.Path", "enumerate", "open", "json.load", "str", "zip", "dataset_dicts.append", "open", "len", "len", "cv2.imread", "json.load", "objs.append", "int"], "function", ["None"], ["def", "get_assr_dicts", "(", "root", ",", "mode", ")", ":", "\n", "    ", "root", "=", "Path", "(", "root", ")", "\n", "json_file", "=", "root", "/", "f\"obj_seg_data_{mode}.json\"", "\n", "list_file", "=", "root", "/", "f\"{mode}_images.txt\"", "\n", "with", "open", "(", "json_file", ")", "as", "f", ":", "\n", "        ", "imgs_anns", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "dataset_dicts", "=", "[", "]", "\n", "for", "idx", ",", "anno", "in", "enumerate", "(", "imgs_anns", ")", ":", "\n", "        ", "record", "=", "{", "}", "\n", "\n", "filename", "=", "str", "(", "root", "/", "'images'", "/", "mode", "/", "(", "anno", "[", "'img'", "]", "+", "'.jpg'", ")", ")", "\n", "height", ",", "width", "=", "cv2", ".", "imread", "(", "filename", ")", ".", "shape", "[", ":", "2", "]", "\n", "\n", "record", "[", "\"file_name\"", "]", "=", "filename", "\n", "record", "[", "\"image_id\"", "]", "=", "idx", "\n", "record", "[", "\"height\"", "]", "=", "height", "\n", "record", "[", "\"width\"", "]", "=", "width", "\n", "\n", "with", "open", "(", "root", "/", "'rank_order'", "/", "mode", "/", "(", "anno", "[", "'img'", "]", "+", "'.json'", ")", ")", "as", "f", ":", "\n", "            ", "ranker_order", "=", "json", ".", "load", "(", "f", ")", "[", "'rank_order'", "]", "\n", "\n", "", "objs", "=", "[", "]", "\n", "assert", "len", "(", "ranker_order", ")", "==", "len", "(", "\n", "anno", "[", "\"object_data\"", "]", ")", ",", "\"Every box should correspond a rank order\"", "\n", "\n", "for", "rank", ",", "obj_anno", "in", "zip", "(", "ranker_order", ",", "anno", "[", "\"object_data\"", "]", ")", ":", "\n", "# \u8fd9\u91cc\u8981\u8fc7\u6ee4\u4e00\u4e0brank <= 0.5 \u7684 box", "\n", "            ", "if", "rank", ">", "SAL_THR", ":", "\n", "                ", "obj", "=", "{", "\n", "\"bbox\"", ":", "obj_anno", "[", "'bbox'", "]", ",", "\n", "\"bbox_mode\"", ":", "BoxMode", ".", "XYXY_ABS", ",", "\n", "\"segmentation\"", ":", "obj_anno", "[", "'segmentation'", "]", ",", "\n", "\"category_id\"", ":", "0", ",", "\n", "\"gt_rank\"", ":", "int", "(", "rank", "*", "10", "-", "6", ")", "# map 0.5~1.0 to 0,1,2,3,4", "\n", "}", "\n", "objs", ".", "append", "(", "obj", ")", "\n", "", "", "record", "[", "\"annotations\"", "]", "=", "objs", "\n", "dataset_dicts", ".", "append", "(", "record", ")", "\n", "", "return", "dataset_dicts", "\n", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor.assr_dataset_mapper.DatasetMapper.__init__": [[39, 87], ["detectron2.data.transforms.AugmentationList", "logging.getLogger", "logging.getLogger.info"], "methods", ["None"], ["@", "configurable", "\n", "def", "__init__", "(", "\n", "self", ",", "\n", "is_train", ":", "bool", ",", "\n", "*", ",", "\n", "augmentations", ":", "List", "[", "Union", "[", "T", ".", "Augmentation", ",", "T", ".", "Transform", "]", "]", ",", "\n", "image_format", ":", "str", ",", "\n", "use_instance_mask", ":", "bool", "=", "False", ",", "\n", "use_keypoint", ":", "bool", "=", "False", ",", "\n", "instance_mask_format", ":", "str", "=", "\"polygon\"", ",", "\n", "keypoint_hflip_indices", ":", "Optional", "[", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "precomputed_proposal_topk", ":", "Optional", "[", "int", "]", "=", "None", ",", "\n", "recompute_boxes", ":", "bool", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        NOTE: this interface is experimental.\n\n        Args:\n            is_train: whether it's used in training or inference\n            augmentations: a list of augmentations or deterministic transforms to apply\n            image_format: an image format supported by :func:`detection_utils.read_image`.\n            use_instance_mask: whether to process instance segmentation annotations, if available\n            use_keypoint: whether to process keypoint annotations if available\n            instance_mask_format: one of \"polygon\" or \"bitmask\". Process instance segmentation\n                masks into this format.\n            keypoint_hflip_indices: see :func:`detection_utils.create_keypoint_hflip_indices`\n            precomputed_proposal_topk: if given, will load pre-computed\n                proposals from dataset_dict and keep the top k proposals for each image.\n            recompute_boxes: whether to overwrite bounding box annotations\n                by computing tight bounding boxes from instance mask annotations.\n        \"\"\"", "\n", "if", "recompute_boxes", ":", "\n", "            ", "assert", "use_instance_mask", ",", "\"recompute_boxes requires instance masks\"", "\n", "# fmt: off", "\n", "", "self", ".", "is_train", "=", "is_train", "\n", "self", ".", "augmentations", "=", "T", ".", "AugmentationList", "(", "augmentations", ")", "\n", "self", ".", "image_format", "=", "image_format", "\n", "self", ".", "use_instance_mask", "=", "use_instance_mask", "\n", "self", ".", "instance_mask_format", "=", "instance_mask_format", "\n", "self", ".", "use_keypoint", "=", "use_keypoint", "\n", "self", ".", "keypoint_hflip_indices", "=", "keypoint_hflip_indices", "\n", "self", ".", "proposal_topk", "=", "precomputed_proposal_topk", "\n", "self", ".", "recompute_boxes", "=", "recompute_boxes", "\n", "# fmt: on", "\n", "logger", "=", "logging", ".", "getLogger", "(", "__name__", ")", "\n", "mode", "=", "\"training\"", "if", "is_train", "else", "\"inference\"", "\n", "logger", ".", "info", "(", "\n", "f\"[DatasetMapper] Augmentations used in {mode}: {augmentations}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor.assr_dataset_mapper.DatasetMapper.from_config": [[88, 119], ["detectron2.data.detection_utils.build_augmentation", "detectron2.data.detection_utils.build_augmentation.insert", "detectron2.data.detection_utils.create_keypoint_hflip_indices", "detectron2.data.transforms.RandomCrop"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "from_config", "(", "cls", ",", "cfg", ",", "is_train", ":", "bool", "=", "True", ")", ":", "\n", "        ", "augs", "=", "utils", ".", "build_augmentation", "(", "cfg", ",", "is_train", ")", "\n", "if", "cfg", ".", "INPUT", ".", "CROP", ".", "ENABLED", "and", "is_train", ":", "\n", "            ", "augs", ".", "insert", "(", "0", ",", "T", ".", "RandomCrop", "(", "\n", "cfg", ".", "INPUT", ".", "CROP", ".", "TYPE", ",", "cfg", ".", "INPUT", ".", "CROP", ".", "SIZE", ")", ")", "\n", "recompute_boxes", "=", "cfg", ".", "MODEL", ".", "MASK_ON", "\n", "", "else", ":", "\n", "            ", "recompute_boxes", "=", "False", "\n", "\n", "", "ret", "=", "{", "\n", "\"is_train\"", ":", "is_train", ",", "\n", "\"augmentations\"", ":", "augs", ",", "\n", "\"image_format\"", ":", "cfg", ".", "INPUT", ".", "FORMAT", ",", "\n", "\"use_instance_mask\"", ":", "cfg", ".", "MODEL", ".", "MASK_ON", ",", "\n", "\"instance_mask_format\"", ":", "cfg", ".", "INPUT", ".", "MASK_FORMAT", ",", "\n", "\"use_keypoint\"", ":", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ",", "\n", "\"recompute_boxes\"", ":", "recompute_boxes", ",", "\n", "}", "\n", "\n", "if", "cfg", ".", "MODEL", ".", "KEYPOINT_ON", ":", "\n", "            ", "ret", "[", "\"keypoint_hflip_indices\"", "]", "=", "utils", ".", "create_keypoint_hflip_indices", "(", "\n", "cfg", ".", "DATASETS", ".", "TRAIN", ")", "\n", "\n", "", "if", "cfg", ".", "MODEL", ".", "LOAD_PROPOSALS", ":", "\n", "            ", "ret", "[", "\"precomputed_proposal_topk\"", "]", "=", "(", "\n", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TRAIN", "\n", "if", "is_train", "\n", "else", "cfg", ".", "DATASETS", ".", "PRECOMPUTED_PROPOSAL_TOPK_TEST", "\n", ")", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.sor.assr_dataset_mapper.DatasetMapper.__call__": [[120, 202], ["copy.deepcopy", "detectron2.data.detection_utils.read_image", "detectron2.data.detection_utils.check_image_size", "detectron2.data.transforms.AugInput", "assr_dataset_mapper.DatasetMapper.augmentations", "torch.as_tensor", "detectron2.data.detection_utils.read_image().squeeze", "numpy.ascontiguousarray", "torch.as_tensor", "detectron2.data.detection_utils.transform_proposals", "copy.deepcopy.pop", "copy.deepcopy.pop", "detectron2.data.detection_utils.annotations_to_instances", "detectron2.data.detection_utils.filter_empty_instances", "torch.LongTensor", "detectron2.data.detection_utils.read_image.transpose", "detectron2.data.detection_utils.read_image().squeeze.astype", "gt_ranks.append", "detectron2.data.detection_utils.transform_instance_annotations", "detectron2.data.detection_utils.annotations_to_instances.gt_masks.get_bounding_boxes", "detectron2.data.detection_utils.read_image", "anno.pop", "anno.pop", "copy.deepcopy.pop", "copy.deepcopy.pop", "obj.get"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["", "def", "__call__", "(", "self", ",", "dataset_dict", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            dataset_dict (dict): Metadata of one image, in Detectron2 Dataset format.\n\n        Returns:\n            dict: a format that builtin models in detectron2 accept\n        \"\"\"", "\n", "dataset_dict", "=", "copy", ".", "deepcopy", "(", "\n", "dataset_dict", ")", "# it will be modified by code below", "\n", "# USER: Write your own image loading if it's not from a file", "\n", "image", "=", "utils", ".", "read_image", "(", "\n", "dataset_dict", "[", "\"file_name\"", "]", ",", "format", "=", "self", ".", "image_format", ")", "\n", "utils", ".", "check_image_size", "(", "dataset_dict", ",", "image", ")", "\n", "\n", "# USER: Remove if you don't do semantic/panoptic segmentation.", "\n", "if", "\"sem_seg_file_name\"", "in", "dataset_dict", ":", "\n", "            ", "sem_seg_gt", "=", "utils", ".", "read_image", "(", "dataset_dict", ".", "pop", "(", "\n", "\"sem_seg_file_name\"", ")", ",", "\"L\"", ")", ".", "squeeze", "(", "2", ")", "\n", "", "else", ":", "\n", "            ", "sem_seg_gt", "=", "None", "\n", "\n", "", "aug_input", "=", "T", ".", "AugInput", "(", "image", ",", "sem_seg", "=", "sem_seg_gt", ")", "\n", "transforms", "=", "self", ".", "augmentations", "(", "aug_input", ")", "\n", "image", ",", "sem_seg_gt", "=", "aug_input", ".", "image", ",", "aug_input", ".", "sem_seg", "\n", "\n", "image_shape", "=", "image", ".", "shape", "[", ":", "2", "]", "# h, w", "\n", "# Pytorch's dataloader is efficient on torch.Tensor due to shared-memory,", "\n", "# but not efficient on large generic data structures due to the use of pickle & mp.Queue.", "\n", "# Therefore it's important to use torch.Tensor.", "\n", "dataset_dict", "[", "\"image\"", "]", "=", "torch", ".", "as_tensor", "(", "\n", "np", ".", "ascontiguousarray", "(", "image", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "if", "sem_seg_gt", "is", "not", "None", ":", "\n", "            ", "dataset_dict", "[", "\"sem_seg\"", "]", "=", "torch", ".", "as_tensor", "(", "\n", "sem_seg_gt", ".", "astype", "(", "\"long\"", ")", ")", "\n", "\n", "# USER: Remove if you don't use pre-computed proposals.", "\n", "# Most users would not need this feature.", "\n", "", "if", "self", ".", "proposal_topk", "is", "not", "None", ":", "\n", "            ", "utils", ".", "transform_proposals", "(", "\n", "dataset_dict", ",", "image_shape", ",", "transforms", ",", "proposal_topk", "=", "self", ".", "proposal_topk", "\n", ")", "\n", "\n", "", "if", "not", "self", ".", "is_train", ":", "\n", "# TODO: add rank anno", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "dataset_dict", ".", "pop", "(", "\"annotations\"", ",", "None", ")", "\n", "dataset_dict", ".", "pop", "(", "\"sem_seg_file_name\"", ",", "None", ")", "\n", "return", "dataset_dict", "\n", "\n", "", "if", "\"annotations\"", "in", "dataset_dict", ":", "\n", "# USER: Modify this if you want to keep them for some reason.", "\n", "            ", "gt_ranks", "=", "[", "]", "\n", "for", "anno", "in", "dataset_dict", "[", "\"annotations\"", "]", ":", "\n", "                ", "gt_ranks", ".", "append", "(", "anno", "[", "'gt_rank'", "]", ")", "\n", "if", "not", "self", ".", "use_instance_mask", ":", "\n", "                    ", "anno", ".", "pop", "(", "\"segmentation\"", ",", "None", ")", "\n", "", "if", "not", "self", ".", "use_keypoint", ":", "\n", "                    ", "anno", ".", "pop", "(", "\"keypoints\"", ",", "None", ")", "\n", "\n", "# USER: Implement additional transformations if you have other types of data", "\n", "", "", "annos", "=", "[", "\n", "utils", ".", "transform_instance_annotations", "(", "\n", "obj", ",", "transforms", ",", "image_shape", ",", "keypoint_hflip_indices", "=", "self", ".", "keypoint_hflip_indices", "\n", ")", "\n", "for", "obj", "in", "dataset_dict", ".", "pop", "(", "\"annotations\"", ")", "\n", "if", "obj", ".", "get", "(", "\"iscrowd\"", ",", "0", ")", "==", "0", "\n", "]", "\n", "instances", "=", "utils", ".", "annotations_to_instances", "(", "\n", "annos", ",", "image_shape", ",", "mask_format", "=", "self", ".", "instance_mask_format", "\n", ")", "\n", "\n", "# After transforms such as cropping are applied, the bounding box may no longer", "\n", "# tightly bound the object. As an example, imagine a triangle object", "\n", "# [(0,0), (2,0), (0,2)] cropped by a box [(1,0),(2,2)] (XYXY format). The tight", "\n", "# bounding box of the cropped triangle should be [(1,0),(2,1)], which is not equal to", "\n", "# the intersection of original bounding box and the cropping box.", "\n", "if", "self", ".", "recompute_boxes", ":", "\n", "                ", "instances", ".", "gt_boxes", "=", "instances", ".", "gt_masks", ".", "get_bounding_boxes", "(", ")", "\n", "", "dataset_dict", "[", "\"instances\"", "]", "=", "utils", ".", "filter_empty_instances", "(", "instances", ")", "\n", "dataset_dict", "[", "\"instances\"", "]", ".", "gt_ranks", "=", "torch", ".", "LongTensor", "(", "gt_ranks", ")", "\n", "", "return", "dataset_dict", "\n", "", "", ""]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.demo.setup_cfg": [[16, 28], ["centermask.config.get_cfg", "centermask.config.get_cfg.merge_from_file", "centermask.config.get_cfg.merge_from_list", "centermask.config.get_cfg.freeze"], "function", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.config.config.get_cfg"], ["from", "detectron2", ".", "utils", ".", "logger", "import", "setup_logger", "\n", "\n", "from", "predictor", "import", "VisualizationDemo", "\n", "from", "centermask", ".", "config", "import", "get_cfg", "\n", "\n", "# constants", "\n", "WINDOW_NAME", "=", "\"COCO detections\"", "\n", "\n", "\n", "def", "setup_cfg", "(", "args", ")", ":", "\n", "# load config from file and command-line arguments", "\n", "    ", "cfg", "=", "get_cfg", "(", ")", "\n", "cfg", ".", "merge_from_file", "(", "args", ".", "config_file", ")", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.demo.get_parser": [[30, 58], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["# Set score_threshold for builtin models", "\n", "cfg", ".", "MODEL", ".", "RETINANET", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "ROI_HEADS", ".", "SCORE_THRESH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "FCOS", ".", "INFERENCE_TH_TEST", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "MODEL", ".", "PANOPTIC_FPN", ".", "COMBINE", ".", "INSTANCES_CONFIDENCE_THRESH", "=", "args", ".", "confidence_threshold", "\n", "cfg", ".", "freeze", "(", ")", "\n", "return", "cfg", "\n", "\n", "\n", "", "def", "get_parser", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Detectron2 Demo\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--config-file\"", ",", "\n", "default", "=", "\"configs/quick_schedules/e2e_mask_rcnn_R_50_FPN_inference_acc_test.yaml\"", ",", "\n", "metavar", "=", "\"FILE\"", ",", "\n", "help", "=", "\"path to config file\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"--webcam\"", ",", "action", "=", "\"store_true\"", ",", "help", "=", "\"Take inputs from webcam.\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--video-input\"", ",", "help", "=", "\"Path to video file.\"", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\"--input\"", ",", "\n", "help", "=", "\"Input images dir\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--output\"", ",", "\n", "help", "=", "\"A file or directory to save output visualizations. \"", "\n", ")", "\n", "\n", "parser", ".", "add_argument", "(", "\n", "\"--confidence-threshold\"", ",", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.predictor.VisualizationDemo.__init__": [[10, 18], ["detectron2.data.MetadataCatalog.get", "torch.device", "detectron2.engine.defaults.DefaultPredictor", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.demo.predictor.AsyncPredictor.get"], ["\n", "from", "detectron2", ".", "data", "import", "MetadataCatalog", "\n", "from", "detectron2", ".", "engine", ".", "defaults", "import", "DefaultPredictor", "\n", "from", "detectron2", ".", "utils", ".", "visualizer", "import", "ColorMode", ",", "Visualizer", "\n", "\n", "from", "video_visualizer", "import", "VideoVisualizer", "\n", "\n", "\n", "class", "VisualizationDemo", "(", "object", ")", ":", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.predictor.VisualizationDemo.run_on_image": [[19, 40], ["predictor.VisualizationDemo.predictor", "visualizer.SORVisualizer.SORVisualizer", "predictions[].to", "visualizer.SORVisualizer.SORVisualizer.draw_instance_sor_predictions", "numpy.zeros_like"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.draw_instance_sor_predictions"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ",", "parallel", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            cfg (CfgNode):\n            instance_mode (ColorMode):\n            parallel (bool): whether to run the model in different processes from visualization.\n                Useful since the visualization logic can be slow.\n        \"\"\"", "\n", "self", ".", "metadata", "=", "MetadataCatalog", ".", "get", "(", "\n", "cfg", ".", "DATASETS", ".", "TEST", "[", "0", "]", "if", "len", "(", "cfg", ".", "DATASETS", ".", "TEST", ")", "else", "\"__unused\"", "\n", ")", "\n", "self", ".", "cpu_device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "\n", "self", ".", "instance_mode", "=", "instance_mode", "\n", "\n", "self", ".", "parallel", "=", "parallel", "\n", "if", "parallel", ":", "\n", "            ", "num_gpu", "=", "torch", ".", "cuda", ".", "device_count", "(", ")", "\n", "self", ".", "predictor", "=", "AsyncPredictor", "(", "cfg", ",", "num_gpus", "=", "num_gpu", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "predictor", "=", "DefaultPredictor", "(", "cfg", ")", "\n", "\n", "", "", "def", "run_on_image", "(", "self", ",", "image", ")", ":", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__": [[6, 9], ["detectron2.utils.visualizer.Visualizer.__init__"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.__init__"], ["    ", "def", "__init__", "(", "self", ",", "image", ",", "metadata", ",", "instance_mode", "=", "ColorMode", ".", "IMAGE", ")", ":", "\n", "        ", "super", "(", "SORVisualizer", ",", "self", ")", ".", "__init__", "(", "\n", "image", ",", "metadata", ",", "instance_mode", "=", "instance_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.draw_instance_sor_predictions": [[10, 21], ["numpy.asarray", "visualizer.SORVisualizer.overlay_sor_instances", "detectron2.utils.visualizer.GenericMask", "len"], "methods", ["home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.overlay_sor_instances"], ["", "def", "draw_instance_sor_predictions", "(", "self", ",", "predictions", ")", ":", "\n", "        ", "masks", "=", "np", ".", "asarray", "(", "predictions", ".", "pred_masks", ")", "\n", "masks", "=", "[", "GenericMask", "(", "x", ",", "self", ".", "output", ".", "height", ",", "self", ".", "output", ".", "width", ")", "\n", "for", "x", "in", "masks", "]", "\n", "ranks", "=", "predictions", ".", "pred_ranks", "if", "len", "(", "masks", ")", ">", "0", "else", "None", "\n", "\n", "self", ".", "overlay_sor_instances", "(", "\n", "masks", "=", "masks", ",", "\n", "ranks", "=", "ranks", "\n", ")", "\n", "return", "self", ".", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.EricFH_salient_object_ranking_with_PPA.vis.visualizer.SORVisualizer.overlay_sor_instances": [[22, 75], ["len", "zip", "len", "visualizer.SORVisualizer._convert_masks", "range", "assigned_colors.append", "numpy.asarray", "numpy.argsort().tolist", "filtered_masks.append", "filtered_ranks.append", "numpy.array", "x.area", "numpy.argsort", "visualizer.SORVisualizer.draw_polygon", "segment.reshape"], "methods", ["None"], ["", "def", "overlay_sor_instances", "(", "\n", "self", ",", "\n", "*", ",", "\n", "masks", "=", "None", ",", "\n", "ranks", "=", "None", "\n", ")", ":", "\n", "\n", "        ", "num_instances", "=", "len", "(", "masks", ")", "\n", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "\n", "", "filtered_masks", "=", "[", "]", "\n", "filtered_ranks", "=", "[", "]", "\n", "for", "rank", ",", "mask", "in", "zip", "(", "ranks", ",", "masks", ")", ":", "\n", "            ", "if", "rank", ">=", "0", ":", "\n", "                ", "filtered_masks", ".", "append", "(", "mask", ")", "\n", "filtered_ranks", ".", "append", "(", "rank", ")", "\n", "", "", "masks", "=", "filtered_masks", "\n", "ranks", "=", "filtered_ranks", "\n", "\n", "num_instances", "=", "len", "(", "masks", ")", "\n", "if", "num_instances", "==", "0", ":", "\n", "            ", "return", "self", ".", "output", "\n", "\n", "\n", "\n", "", "masks", "=", "self", ".", "_convert_masks", "(", "masks", ")", "\n", "\n", "assigned_colors", "=", "[", "]", "\n", "for", "r", "in", "ranks", ":", "\n", "            ", "val", "=", "(", "r", "+", "6.0", ")", "/", "10.0", "\n", "assigned_colors", ".", "append", "(", "np", ".", "array", "(", "[", "val", "]", "*", "3", ")", ")", "\n", "# assigned_colors = [random_color(rgb=True, maximum=1) for _ in range(num_instances)]", "\n", "\n", "# Display in largest to smallest order to reduce occlusion.", "\n", "", "areas", "=", "None", "\n", "if", "masks", "is", "not", "None", ":", "\n", "            ", "areas", "=", "np", ".", "asarray", "(", "[", "x", ".", "area", "(", ")", "for", "x", "in", "masks", "]", ")", "\n", "\n", "", "if", "areas", "is", "not", "None", ":", "\n", "            ", "sorted_idxs", "=", "np", ".", "argsort", "(", "-", "areas", ")", ".", "tolist", "(", ")", "\n", "# Re-order overlapped instances in descending order.", "\n", "masks", "=", "[", "masks", "[", "idx", "]", "\n", "for", "idx", "in", "sorted_idxs", "]", "if", "masks", "is", "not", "None", "else", "None", "\n", "assigned_colors", "=", "[", "assigned_colors", "[", "idx", "]", "for", "idx", "in", "sorted_idxs", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "num_instances", ")", ":", "\n", "            ", "color", "=", "assigned_colors", "[", "i", "]", "\n", "\n", "if", "masks", "is", "not", "None", ":", "\n", "                ", "for", "segment", "in", "masks", "[", "i", "]", ".", "polygons", ":", "\n", "                    ", "self", ".", "draw_polygon", "(", "segment", ".", "reshape", "(", "-", "1", ",", "2", ")", ",", "color", ",", "alpha", "=", "1.0", ")", "\n", "", "", "", "return", "self", ".", "output", "\n", "", "", ""]]}