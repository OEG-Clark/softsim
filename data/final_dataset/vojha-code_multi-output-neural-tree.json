{"home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_strcture.optimizeSTR": [[35, 174], ["dataloader.data_processing.DataProcessing", "dataloader.data_processing.DataProcessing.setParams", "print", "dataloader.data_loader.data_partition", "performance_dict.update", "dataloader.data_loader.data_evaluation", "datetime.datetime.now", "optimization.structure.structure_optimization.StructureOptimization", "optimization.structure.structure_optimization.StructureOptimization.optimize", "datetime.datetime.now", "reporting.plots.saveModel", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "reporting.plots.elpsadeTime", "optimumTreeStructure.getTreeInputFeatuereProperties", "print", "print", "print", "performance_dict.update", "performance_dict.update", "performance_dict.update", "performance_dict.update", "performance_dict.update", "os.path.join", "numpy.save", "reporting.plots.getTraingParamsDict", "print", "datetime.datetime.now", "optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "datetime.datetime.now", "reporting.plots.saveModel", "reporting.plots.plotPerfromance", "reporting.plots.plotPerfromanceBoth", "reporting.plots.elpsadeTime", "performance_dict.update", "performance_dict.update", "print", "os.path.join", "numpy.save", "str", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "reporting.plots.plotPrecisionVsRecall", "reporting.plots.plotPrecisionVsRecall", "datetime.datetime.now", "datetime.datetime.now", "reporting.plots.elpsadeTime", "print", "performance_dict.update", "performance_dict.update", "performance_dict.update", "dataloader.data_loader.data_partition", "datetime.datetime.now", "range", "print", "print", "dataloader.data_loader.data_partition", "datetime.datetime.now", "range", "print", "print", "str", "dataloader.data_loader.data_evaluation", "optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "print", "print", "avg_train.append", "avg_test.append", "range", "sum", "len", "sum", "len", "dataloader.data_loader.data_evaluation", "optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "print", "print", "avg_train.append", "avg_test.append", "sum", "len", "sum", "len", "sum", "len", "sum", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.setParams", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveModel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeInputFeatuereProperties", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.getTraingParamsDict", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveModel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPerfromance", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPerfromanceBoth", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPrecisionVsRecall", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPrecisionVsRecall", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness"], ["def", "optimizeSTR", "(", "params", ",", "directory", ",", "trail", ",", "optimize_tree_parameter", "=", "True", ")", ":", "\n", "    ", "'''\n    Optimize structure and paramters\n    Argument:\n        params: paramters\n        trail:  time\n        optimize_tree_parameter:  True or False\n    '''", "\n", "performance_dict", "=", "{", "}", "\n", "dataProcessing", "=", "DataProcessing", "(", ")", "\n", "dataProcessing", ".", "setParams", "(", "params", ")", "# setting it for data preporcessing", "\n", "\n", "print", "(", "'\\nStructure optimization....'", ")", "\n", "# recieve data for tree tsructure optimization", "\n", "data_input_values", ",", "data_target_values", ",", "random_sequence", "=", "data_partition", "(", "dataProcessing", ")", "\n", "performance_dict", ".", "update", "(", "{", "'data random sequence'", ":", "random_sequence", "}", ")", "\n", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ")", "\n", "# Structure", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "treeStucture", "=", "StructureOptimization", "(", "evaluateTree", ",", "params", ")", "\n", "optimumTreeStructure", ",", "tree_str_population", ",", "gp_perfromance", "=", "treeStucture", ".", "optimize", "(", "directory", ",", "trail", ")", "\n", "end", "=", "datetime", ".", "now", "(", ")", "\n", "\n", "# PLOTS and MODEL SAVING for strcuture optimization", "\n", "saveModel", "(", "optimumTreeStructure", ",", "params", ".", "n_algo_structure", ",", "directory", ",", "trail", ")", "\n", "#plotPerfromance(gp_perfromance, params.n_algo_structure, directory, trail, params.n_data_target_names, params.n_problem_type)", "\n", "#plotTreeFitness(evaluateTree, optimumTreeStructure, directory, trail, str(params.n_algo_structure), 'train')", "\n", "#plotTreeFitness(evaluateTree, optimumTreeStructure, directory, trail, str(params.n_algo_structure), 'test')", "\n", "gp_train_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimumTreeStructure", ",", "'train'", ")", "\n", "gp_test_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimumTreeStructure", ",", "'test'", ")", "\n", "#if params.n_problem_type == 'Classification':", "\n", "#    plotPrecisionVsRecall(gp_train_error, params.n_algo_structure, directory, trail, params.n_data_target_names, 'train')", "\n", "#    plotPrecisionVsRecall(gp_test_error, params.n_algo_structure, directory, trail, params.n_data_target_names, 'test')", "\n", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "# get features", "\n", "tree_feature_properties", "=", "optimumTreeStructure", ".", "getTreeInputFeatuereProperties", "(", "params", ".", "n_max_target_attr", ",", "params", ".", "n_data_input_names", ",", "params", ".", "n_data_target_names", ")", "\n", "# Collection and printing perfroance", "\n", "print", "(", "'TIME: structure optimization: '", ",", "elpsade_time", ",", "'sec'", ")", "\n", "print", "(", "'Structure optimization on training set error: '", ",", "gp_train_error", ")", "\n", "print", "(", "'Structure optimization on test     set error: '", ",", "gp_test_error", ")", "\n", "# Collection in to a dictionary", "\n", "performance_dict", ".", "update", "(", "{", "'gp iterations'", ":", "gp_perfromance", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gp best error'", ":", "[", "gp_train_error", ",", "gp_test_error", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gp time (sec)'", ":", "elpsade_time", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'tree features properties'", ":", "tree_feature_properties", "}", ")", "\n", "\n", "#Save perfromance of GP", "\n", "performance_dict", ".", "update", "(", "getTraingParamsDict", "(", "params", ")", ")", "\n", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerfroamnce_dict_gp_'", "+", "str", "(", "trail", ")", ")", "\n", "np", ".", "save", "(", "filePath", ",", "performance_dict", ")", "\n", "# delete unnecessary variables of tsructuer optimization", "\n", "del", "tree_str_population", ",", "gp_train_error", ",", "gp_test_error", ",", "elpsade_time", ",", "start", ",", "end", ",", "tree_feature_properties", "\n", "\n", "\n", "# Go for parameter optimization", "\n", "if", "optimize_tree_parameter", ":", "\n", "        ", "print", "(", "'\\n Mandatory paramter optimization....'", ")", "\n", "# recieve data for tree tsructure optimization Parameter optimization", "\n", "# MANDATORY Parameter optimization", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", "\n", "optimizedTree", ",", "param_perfromance", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "end", "=", "datetime", ".", "now", "(", ")", "\n", "# PLOTS and MODEL SAVING for parameter optimization", "\n", "saveModel", "(", "optimizedTree", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ")", "\n", "plotPerfromance", "(", "param_perfromance", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "params", ".", "n_problem_type", ")", "\n", "plotPerfromanceBoth", "(", "gp_perfromance", ",", "param_perfromance", ",", "params", ".", "n_algo_structure", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "params", ".", "n_problem_type", ")", "\n", "#plotTreeFitness(evaluateTree, optimizedTree, directory, trail, str(params.n_algo_param), 'train')", "\n", "#plotTreeFitness(evaluateTree, optimizedTree, directory, trail, str(params.n_algo_param), 'test')", "\n", "if", "params", ".", "n_problem_type", "==", "'Classification'", ":", "\n", "            ", "train_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'train'", ")", "\n", "test_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'test'", ")", "\n", "plotPrecisionVsRecall", "(", "train_error", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "'train'", ")", "\n", "plotPrecisionVsRecall", "(", "test_error", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "'test'", ")", "\n", "# End of Mandatory parameter optimization", "\n", "# COLLECTION Paramters", "\n", "", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh iterations'", ":", "param_perfromance", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh time (sec)'", ":", "elpsade_time", "}", ")", "\n", "print", "(", "'TIME: mandatory paramter optimization:'", ",", "elpsade_time", ",", "'sec.'", ")", "\n", "del", "param_perfromance", ",", "train_error", ",", "test_error", ",", "elpsade_time", "\n", "\n", "if", "params", ".", "n_validation_method", "==", "'k_fold'", "or", "params", ".", "n_validation_method", "==", "'five_x_two_fold'", ":", "\n", "            ", "k", "=", "params", ".", "n_validation_folds", "\n", "# CROSS VALIDATION", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "if", "params", ".", "n_validation_method", "==", "'k_fold'", ":", "\n", "                ", "data_input_values", ",", "data_target_values", "=", "data_partition", "(", "dataProcessing", ",", "params", ".", "n_validation_method", ")", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "avg_train", "=", "[", "]", "\n", "avg_test", "=", "[", "]", "\n", "if", "k", "==", "2", ":", "\n", "                    ", "nFOLDS", "=", "1", "\n", "", "else", ":", "\n", "                    ", "nFOLDS", "=", "k", "\n", "", "for", "fold", "in", "range", "(", "nFOLDS", ")", ":", "\n", "                    ", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ")", "\n", "# Parameter optimization", "\n", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimizedTree", ")", "\n", "foldTree", ",", "_", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "train_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'train'", ")", "\n", "test_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'test'", ")", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "", "print", "(", "'\\nAverange train on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ")", "\n", "print", "(", "'Averange test  on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", ")", "\n", "\n", "", "if", "params", ".", "n_validation_method", "==", "'five_x_two_fold'", ":", "\n", "                ", "data_input_values", ",", "data_target_values", "=", "data_partition", "(", "dataProcessing", ",", "params", ".", "n_validation_method", ")", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "avg_train", "=", "[", "]", "\n", "avg_test", "=", "[", "]", "\n", "for", "fold", "in", "range", "(", "5", ")", ":", "\n", "                    ", "for", "cross", "in", "range", "(", "2", ")", ":", "\n", "                        ", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ",", "cross", ")", "\n", "# Parameter optimization", "\n", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimizedTree", ")", "\n", "optimizedTree", ",", "param_perfromance", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "train_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'train'", ")", "\n", "test_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'test'", ")", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "", "", "print", "(", "'\\nAverange train on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ")", "\n", "print", "(", "'Averange test  on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", ")", "\n", "# End of parameter optimization", "\n", "", "end", "=", "datetime", ".", "now", "(", ")", "\n", "# COLLECTION CV paramters", "\n", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "print", "(", "'TIME: cv optimization:'", ",", "elpsade_time", ",", "'sec.'", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh cv error'", ":", "[", "avg_train", ",", "avg_test", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh average cv error'", ":", "[", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh cv time (sec)'", ":", "elpsade_time", "}", ")", "\n", "#Save paramters", "\n", "", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerfroamnce_dict_mh_'", "+", "str", "(", "trail", ")", ")", "\n", "np", ".", "save", "(", "filePath", ",", "performance_dict", ")", "\n", "##read_np = np.load('model/treePerfroamnce_Dict_iris_trail.npy').item()", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_mp.optimize": [[41, 180], ["dataloader.data_processing.DataProcessing", "dataloader.data_processing.DataProcessing.setParams", "print", "dataloader.data_loader.data_partition", "performance_dict.update", "dataloader.data_loader.data_evaluation", "datetime.datetime.now", "optimization.structure.structure_optimization.StructureOptimization", "optimization.structure.structure_optimization.StructureOptimization.optimize", "datetime.datetime.now", "reporting.plots.saveModel", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "reporting.plots.elpsadeTime", "optimumTreeStructure.getTreeInputFeatuereProperties", "print", "print", "print", "performance_dict.update", "performance_dict.update", "performance_dict.update", "performance_dict.update", "performance_dict.update", "os.path.join", "numpy.save", "reporting.plots.getTraingParamsDict", "print", "datetime.datetime.now", "optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "datetime.datetime.now", "reporting.plots.saveModel", "reporting.plots.plotPerfromance", "reporting.plots.plotPerfromanceBoth", "reporting.plots.elpsadeTime", "performance_dict.update", "performance_dict.update", "print", "os.path.join", "numpy.save", "str", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "reporting.plots.plotPrecisionVsRecall", "reporting.plots.plotPrecisionVsRecall", "datetime.datetime.now", "datetime.datetime.now", "reporting.plots.elpsadeTime", "print", "performance_dict.update", "performance_dict.update", "performance_dict.update", "dataloader.data_loader.data_partition", "datetime.datetime.now", "range", "print", "print", "dataloader.data_loader.data_partition", "datetime.datetime.now", "range", "print", "print", "str", "dataloader.data_loader.data_evaluation", "optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "print", "print", "avg_train.append", "avg_test.append", "range", "sum", "len", "sum", "len", "dataloader.data_loader.data_evaluation", "optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "print", "print", "avg_train.append", "avg_test.append", "sum", "len", "sum", "len", "sum", "len", "sum", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.setParams", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveModel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeInputFeatuereProperties", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.getTraingParamsDict", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveModel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPerfromance", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPerfromanceBoth", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPrecisionVsRecall", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPrecisionVsRecall", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness"], ["def", "optimize", "(", "params", ",", "directory", ",", "trail", ",", "optimize_tree_parameter", "=", "True", ")", ":", "\n", "    ", "'''\n    Optimize structure and paramters\n    Argument:\n        params: paramters\n        trail:  time\n        optimize_tree_parameter:  True or False\n    '''", "\n", "performance_dict", "=", "{", "}", "\n", "dataProcessing", "=", "DataProcessing", "(", ")", "\n", "dataProcessing", ".", "setParams", "(", "params", ")", "# setting it for data preporcessing", "\n", "\n", "print", "(", "'\\nStructure optimization....'", ")", "\n", "# recieve data for tree tsructure optimization", "\n", "data_input_values", ",", "data_target_values", ",", "random_sequence", "=", "data_partition", "(", "dataProcessing", ")", "\n", "performance_dict", ".", "update", "(", "{", "'data random sequence'", ":", "random_sequence", "}", ")", "\n", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ")", "\n", "# Structure", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "treeStucture", "=", "StructureOptimization", "(", "evaluateTree", ",", "params", ")", "\n", "optimumTreeStructure", ",", "tree_str_population", ",", "gp_perfromance", "=", "treeStucture", ".", "optimize", "(", "directory", ",", "trail", ")", "\n", "end", "=", "datetime", ".", "now", "(", ")", "\n", "\n", "# PLOTS and MODEL SAVING for strcuture optimization", "\n", "saveModel", "(", "optimumTreeStructure", ",", "params", ".", "n_algo_structure", ",", "directory", ",", "trail", ")", "\n", "#plotPerfromance(gp_perfromance, params.n_algo_structure, directory, trail, params.n_data_target_names, params.n_problem_type)", "\n", "#plotTreeFitness(evaluateTree, optimumTreeStructure, directory, trail, str(params.n_algo_structure), 'train')", "\n", "#plotTreeFitness(evaluateTree, optimumTreeStructure, directory, trail, str(params.n_algo_structure), 'test')", "\n", "gp_train_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimumTreeStructure", ",", "'train'", ")", "\n", "gp_test_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimumTreeStructure", ",", "'test'", ")", "\n", "#if params.n_problem_type == 'Classification':", "\n", "#    plotPrecisionVsRecall(gp_train_error, params.n_algo_structure, directory, trail, params.n_data_target_names, 'train')", "\n", "#    plotPrecisionVsRecall(gp_test_error, params.n_algo_structure, directory, trail, params.n_data_target_names, 'test')", "\n", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "# get features", "\n", "tree_feature_properties", "=", "optimumTreeStructure", ".", "getTreeInputFeatuereProperties", "(", "params", ".", "n_max_target_attr", ",", "params", ".", "n_data_input_names", ",", "params", ".", "n_data_target_names", ")", "\n", "# Collection and printing perfroance", "\n", "print", "(", "'TIME: structure optimization: '", ",", "elpsade_time", ",", "'sec'", ")", "\n", "print", "(", "'Structure optimization on training set error: '", ",", "gp_train_error", ")", "\n", "print", "(", "'Structure optimization on test     set error: '", ",", "gp_test_error", ")", "\n", "# Collection in to a dictionary", "\n", "performance_dict", ".", "update", "(", "{", "'gp iterations'", ":", "gp_perfromance", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gp best error'", ":", "[", "gp_train_error", ",", "gp_test_error", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gp time (sec)'", ":", "elpsade_time", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'tree features properties'", ":", "tree_feature_properties", "}", ")", "\n", "\n", "#Save perfromance of GP", "\n", "performance_dict", ".", "update", "(", "getTraingParamsDict", "(", "params", ")", ")", "\n", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerfroamnce_dict_gp_'", "+", "str", "(", "trail", ")", ")", "\n", "np", ".", "save", "(", "filePath", ",", "performance_dict", ")", "\n", "# delete unnecessary variables of tsructuer optimization", "\n", "del", "tree_str_population", ",", "gp_train_error", ",", "gp_test_error", ",", "elpsade_time", ",", "start", ",", "end", ",", "tree_feature_properties", "\n", "\n", "\n", "# Go for parameter optimization", "\n", "if", "optimize_tree_parameter", ":", "\n", "        ", "print", "(", "'\\n Mandatory paramter optimization....'", ")", "\n", "# recieve data for tree tsructure optimization Parameter optimization", "\n", "# MANDATORY Parameter optimization", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", "\n", "optimizedTree", ",", "param_perfromance", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "end", "=", "datetime", ".", "now", "(", ")", "\n", "# PLOTS and MODEL SAVING for parameter optimization", "\n", "saveModel", "(", "optimizedTree", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ")", "\n", "plotPerfromance", "(", "param_perfromance", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "params", ".", "n_problem_type", ")", "\n", "plotPerfromanceBoth", "(", "gp_perfromance", ",", "param_perfromance", ",", "params", ".", "n_algo_structure", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "params", ".", "n_problem_type", ")", "\n", "#plotTreeFitness(evaluateTree, optimizedTree, directory, trail, str(params.n_algo_param), 'train')", "\n", "#plotTreeFitness(evaluateTree, optimizedTree, directory, trail, str(params.n_algo_param), 'test')", "\n", "if", "params", ".", "n_problem_type", "==", "'Classification'", ":", "\n", "            ", "train_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'train'", ")", "\n", "test_error", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'test'", ")", "\n", "plotPrecisionVsRecall", "(", "train_error", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "'train'", ")", "\n", "plotPrecisionVsRecall", "(", "test_error", ",", "params", ".", "n_algo_param", ",", "directory", ",", "trail", ",", "params", ".", "n_data_target_names", ",", "'test'", ")", "\n", "# End of Mandatory parameter optimization", "\n", "# COLLECTION Paramters", "\n", "", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh iterations'", ":", "param_perfromance", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh time (sec)'", ":", "elpsade_time", "}", ")", "\n", "print", "(", "'TIME: mandatory paramter optimization:'", ",", "elpsade_time", ",", "'sec.'", ")", "\n", "del", "param_perfromance", ",", "train_error", ",", "test_error", ",", "elpsade_time", "\n", "\n", "if", "params", ".", "n_validation_method", "==", "'k_fold'", "or", "params", ".", "n_validation_method", "==", "'five_x_two_fold'", ":", "\n", "            ", "k", "=", "params", ".", "n_validation_folds", "\n", "# CROSS VALIDATION", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "if", "params", ".", "n_validation_method", "==", "'k_fold'", ":", "\n", "                ", "data_input_values", ",", "data_target_values", "=", "data_partition", "(", "dataProcessing", ",", "params", ".", "n_validation_method", ")", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "avg_train", "=", "[", "]", "\n", "avg_test", "=", "[", "]", "\n", "if", "k", "==", "2", ":", "\n", "                    ", "nFOLDS", "=", "1", "\n", "", "else", ":", "\n", "                    ", "nFOLDS", "=", "k", "\n", "", "for", "fold", "in", "range", "(", "nFOLDS", ")", ":", "\n", "                    ", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ")", "\n", "# Parameter optimization", "\n", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimizedTree", ")", "\n", "foldTree", ",", "_", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "train_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'train'", ")", "\n", "test_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'test'", ")", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "", "print", "(", "'\\nAverange train on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ")", "\n", "print", "(", "'Averange test  on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", ")", "\n", "\n", "", "if", "params", ".", "n_validation_method", "==", "'five_x_two_fold'", ":", "\n", "                ", "data_input_values", ",", "data_target_values", "=", "data_partition", "(", "dataProcessing", ",", "params", ".", "n_validation_method", ")", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "avg_train", "=", "[", "]", "\n", "avg_test", "=", "[", "]", "\n", "for", "fold", "in", "range", "(", "5", ")", ":", "\n", "                    ", "for", "cross", "in", "range", "(", "2", ")", ":", "\n", "                        ", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ",", "cross", ")", "\n", "# Parameter optimization", "\n", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimizedTree", ")", "\n", "optimizedTree", ",", "param_perfromance", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "train_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'train'", ")", "\n", "test_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "optimizedTree", ",", "'test'", ")", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "", "", "print", "(", "'\\nAverange train on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ")", "\n", "print", "(", "'Averange test  on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", ")", "\n", "# End of parameter optimization", "\n", "", "end", "=", "datetime", ".", "now", "(", ")", "\n", "# COLLECTION CV paramters", "\n", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "print", "(", "'TIME: cv optimization:'", ",", "elpsade_time", ",", "'sec.'", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh cv error'", ":", "[", "avg_train", ",", "avg_test", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh average cv error'", ":", "[", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh cv time (sec)'", ":", "elpsade_time", "}", ")", "\n", "#Save paramters", "\n", "", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerfroamnce_dict_mh_'", "+", "str", "(", "trail", ")", ")", "\n", "np", ".", "save", "(", "filePath", ",", "performance_dict", ")", "\n", "##read_np = np.load('model/treePerfroamnce_Dict_iris_trail.npy').item()", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_param.crossValidationRun": [[34, 41], ["optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness"], ["def", "crossValidationRun", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", ":", "\n", "# Parameter optimization", "\n", "    ", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", "\n", "foldTree", ",", "_", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "train_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'train'", ")", "\n", "test_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'test'", ")", "\n", "return", "[", "train_fold", ",", "test_fold", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_param.crossValidationRunMP": [[42, 49], ["optimization.parameter.parameter_optimization.ParameterOptimization", "optimization.parameter.parameter_optimization.ParameterOptimization.optimize", "reporting.plots.optimalTreeFitness", "reporting.plots.optimalTreeFitness", "send_end.send"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness"], ["", "def", "crossValidationRunMP", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ",", "send_end", ")", ":", "\n", "# Parameter optimization", "\n", "    ", "treeParameter", "=", "ParameterOptimization", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", "\n", "foldTree", ",", "_", "=", "treeParameter", ".", "optimize", "(", ")", "\n", "train_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'train'", ")", "\n", "test_fold", "=", "optimalTreeFitness", "(", "evaluateTree", ",", "foldTree", ",", "'test'", ")", "\n", "send_end", ".", "send", "(", "[", "train_fold", ",", "test_fold", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_param.optimizePARM": [[51, 170], ["dataloader.data_processing.DataProcessing", "dataloader.data_processing.DataProcessing.setParams", "print", "datetime.datetime.now", "reporting.plots.elpsadeTime", "print", "performance_dict.update", "performance_dict.update", "performance_dict.update", "os.path.join", "numpy.save", "dataloader.data_loader.data_partition", "performance_dict.update", "datetime.datetime.now", "print", "print", "dataloader.data_loader.data_partition", "datetime.datetime.now", "print", "print", "range", "range", "range", "range", "range", "range", "str", "multiprocessing.Pipe", "dataloader.data_loader.data_evaluation", "multiprocessing.Process", "jobs.append", "pipe_list.append", "mp.Process.start", "proc.join", "pipe_list[].recv", "print", "print", "avg_train.append", "avg_test.append", "dataloader.data_loader.data_evaluation", "train_tree_param.crossValidationRun", "print", "print", "avg_train.append", "avg_test.append", "sum", "len", "sum", "len", "range", "proc.join", "range", "range", "sum", "len", "sum", "len", "multiprocessing.Pipe", "dataloader.data_loader.data_evaluation", "multiprocessing.Process", "jobs.append", "pipe_list.append", "mp.Process.start", "pipe_list[].recv", "print", "print", "avg_train.append", "avg_test.append", "dataloader.data_loader.data_evaluation", "train_tree_param.crossValidationRun", "print", "print", "avg_train.append", "avg_test.append", "sum", "len", "sum", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.setParams", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_param.crossValidationRun", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_param.crossValidationRun"], ["", "def", "optimizePARM", "(", "params", ",", "directory", ",", "trail", ",", "optimize_tree_parameter", "=", "True", ",", "optimumTreeStructure", "=", "None", ")", ":", "\n", "    ", "'''\n    Optimize paramters\n    Argument:\n        params: paramters\n        trail:  time\n        optimize_tree_parameter:  True or False\n    '''", "\n", "performance_dict", "=", "{", "}", "\n", "dataProcessing", "=", "DataProcessing", "(", ")", "\n", "dataProcessing", ".", "setParams", "(", "params", ")", "# setting it for data preporcessing", "\n", "\n", "print", "(", "'\\n Fetch a Tree Structure for optimization....'", ")", "\n", "#dummay  tree for testing", "\n", "#if optimumTreeStructure == None:", "\n", "#    optimumTreeStructure = NeuralTree()", "\n", "#    optimumTreeStructure.genrateGenericRandomTree(params)", "\n", "runMP", "=", "True", "\n", "# Go for parameter optimization", "\n", "if", "params", ".", "n_validation_method", "==", "'k_fold'", "or", "params", ".", "n_validation_method", "==", "'five_x_two_fold'", ":", "\n", "        ", "k", "=", "params", ".", "n_validation_folds", "\n", "# CROSS VALIDATION", "\n", "if", "params", ".", "n_validation_method", "==", "'k_fold'", ":", "\n", "            ", "data_input_values", ",", "data_target_values", ",", "random_sequence", "=", "data_partition", "(", "dataProcessing", ",", "params", ".", "n_validation_method", ")", "\n", "performance_dict", ".", "update", "(", "{", "'data random sequence'", ":", "random_sequence", "}", ")", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "avg_train", "=", "[", "]", "\n", "avg_test", "=", "[", "]", "\n", "if", "k", "==", "2", ":", "\n", "                ", "nFOLDS", "=", "1", "\n", "", "else", ":", "\n", "                ", "nFOLDS", "=", "k", "\n", "\n", "", "if", "runMP", ":", "\n", "                ", "jobs", "=", "[", "]", "\n", "pipe_list", "=", "[", "]", "\n", "for", "fold", "in", "range", "(", "nFOLDS", ")", ":", "\n", "                    ", "recv_end", ",", "send_end", "=", "mp", ".", "Pipe", "(", "False", ")", "\n", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ")", "\n", "p", "=", "mp", ".", "Process", "(", "target", "=", "crossValidationRunMP", ",", "args", "=", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ",", "send_end", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "pipe_list", ".", "append", "(", "recv_end", ")", "\n", "p", ".", "start", "(", ")", "\n", "", "for", "proc", "in", "jobs", ":", "\n", "                    ", "proc", ".", "join", "(", ")", "\n", "", "for", "fold", "in", "range", "(", "nFOLDS", ")", ":", "\n", "                    ", "foldRes", "=", "pipe_list", "[", "fold", "]", ".", "recv", "(", ")", "\n", "train_fold", "=", "foldRes", "[", "0", "]", "\n", "test_fold", "=", "foldRes", "[", "1", "]", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "fold", "in", "range", "(", "nFOLDS", ")", ":", "\n", "                    ", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ")", "\n", "train_fold", ",", "test_fold", "=", "crossValidationRun", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "#end for", "\n", "#end else", "\n", "", "", "print", "(", "'\\nAverange train on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ")", "\n", "print", "(", "'Averange test  on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", ")", "\n", "\n", "", "if", "params", ".", "n_validation_method", "==", "'five_x_two_fold'", ":", "\n", "            ", "data_input_values", ",", "data_target_values", ",", "_", "=", "data_partition", "(", "dataProcessing", ",", "params", ".", "n_validation_method", ")", "\n", "start", "=", "datetime", ".", "now", "(", ")", "\n", "avg_train", "=", "[", "]", "\n", "avg_test", "=", "[", "]", "\n", "if", "runMP", ":", "\n", "                ", "jobs", "=", "[", "]", "\n", "pipe_list", "=", "[", "]", "\n", "for", "fold", "in", "range", "(", "5", ")", ":", "\n", "                    ", "for", "cross", "in", "range", "(", "2", ")", ":", "\n", "                        ", "recv_end", ",", "send_end", "=", "mp", ".", "Pipe", "(", "False", ")", "\n", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ",", "cross", ")", "\n", "p", "=", "mp", ".", "Process", "(", "target", "=", "crossValidationRunMP", ",", "args", "=", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ",", "send_end", ")", ")", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "pipe_list", ".", "append", "(", "recv_end", ")", "\n", "p", ".", "start", "(", ")", "\n", "", "", "for", "proc", "in", "jobs", ":", "\n", "                    ", "proc", ".", "join", "(", ")", "\n", "\n", "", "j", "=", "0", "\n", "for", "fold", "in", "range", "(", "5", ")", ":", "\n", "                    ", "for", "cross", "in", "range", "(", "2", ")", ":", "\n", "                        ", "foldRes", "=", "pipe_list", "[", "j", "]", ".", "recv", "(", ")", "\n", "train_fold", "=", "foldRes", "[", "0", "]", "\n", "test_fold", "=", "foldRes", "[", "1", "]", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "j", "=", "j", "+", "1", "\n", "", "", "", "else", ":", "\n", "                ", "for", "fold", "in", "range", "(", "5", ")", ":", "\n", "                    ", "for", "cross", "in", "range", "(", "2", ")", ":", "\n", "                        ", "evaluateTree", "=", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "params", ".", "n_validation_method", ",", "fold", ",", "cross", ")", "\n", "# Parameter optimization", "\n", "train_fold", ",", "test_fold", "=", "crossValidationRun", "(", "evaluateTree", ",", "params", ",", "optimumTreeStructure", ")", "\n", "print", "(", "'\\nTrain on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "train_fold", "[", "0", "]", ")", "\n", "print", "(", "'Test  on fold'", ",", "fold", ",", "cross", ",", "': '", ",", "test_fold", "[", "0", "]", ")", "\n", "avg_train", ".", "append", "(", "train_fold", ")", "\n", "avg_test", ".", "append", "(", "test_fold", ")", "\n", "", "", "", "print", "(", "'\\nAverange train on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ")", "\n", "print", "(", "'Averange test  on all folds: '", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", ")", "\n", "# End of parameter optimization", "\n", "", "end", "=", "datetime", ".", "now", "(", ")", "\n", "# COLLECTION CV paramters", "\n", "elpsade_time", "=", "elpsadeTime", "(", "start", ",", "end", ")", "\n", "print", "(", "'TIME: cv optimization:'", ",", "elpsade_time", ",", "'sec.'", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh cv error'", ":", "[", "avg_train", ",", "avg_test", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh average cv error'", ":", "[", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_train", "]", ")", "/", "len", "(", "avg_train", ")", ",", "sum", "(", "[", "row", "[", "0", "]", "for", "row", "in", "avg_test", "]", ")", "/", "len", "(", "avg_test", ")", "]", "}", ")", "\n", "performance_dict", ".", "update", "(", "{", "'gd/mh cv time (sec)'", ":", "elpsade_time", "}", ")", "\n", "#Save paramters", "\n", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerfroamnce_dict_mh_'", "+", "str", "(", "trail", ")", ")", "\n", "np", ".", "save", "(", "filePath", ",", "performance_dict", ")", "\n", "##read_np = np.load('model/treePerfroamnce_Dict_iris_trail.npy').item()", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.src.train_tree_param.readTreeStructure": [[174, 180], ["os.path.join", "print", "reporting.display_tree.DisplayTree", "reporting.display_tree.DisplayTree.retriveTreeFromFile", "os.path.join"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.retriveTreeFromFile"], ["", "", "def", "readTreeStructure", "(", "directory", ",", "data_file", ")", ":", "\n", "    ", "fileTree", "=", "data_file", "+", "\".json\"", "\n", "fileTree", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "join", "(", "directory", ",", "'selected_sig_tree'", ")", ",", "fileTree", ")", "\n", "print", "(", "'File'", ",", "data_file", ",", "fileTree", ")", "\n", "d_tree", "=", "DisplayTree", "(", ")", "# Creating object fo0r display tree", "\n", "return", "d_tree", ".", "retriveTreeFromFile", "(", "fileTree", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.Data.__init__": [[19, 32], ["pdata.min", "pdata.max", "ptarget.min", "ptarget.max"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pdata", ",", "pfeature_names", ",", "ptarget", ",", "ptarget_names", "=", "None", ")", ":", "\n", "        ", "'''\n            Setting data objects\n        '''", "\n", "self", ".", "data", "=", "pdata", "\n", "self", ".", "feature_min", "=", "pdata", ".", "min", "(", "axis", "=", "0", ")", "\n", "self", ".", "feature_max", "=", "pdata", ".", "max", "(", "axis", "=", "0", ")", "\n", "self", ".", "feature_names", "=", "pfeature_names", "\n", "\n", "self", ".", "target", "=", "ptarget", "\n", "self", ".", "target_min", "=", "ptarget", ".", "min", "(", "axis", "=", "0", ")", "\n", "self", ".", "target_max", "=", "ptarget", ".", "max", "(", "axis", "=", "0", ")", "\n", "self", ".", "target_names", "=", "ptarget_names", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.load_data": [[44, 95], ["os.path.join", "print", "os.path.exists", "os.getcwd", "print", "pandas.read_csv", "load_boston.columns.tolist", "numpy.asanyarray", "data_processing.Data", "numpy.unique().tolist", "print", "data_processing.Data", "print", "data_processing.Data", "target.replace.replace.replace", "dataset.lower", "load_iris", "dataset.lower", "load_wine", "dataset.lower", "load_breast_cancer", "dataset.lower", "load_diabetes", "dataset.lower", "load_boston", "numpy.unique", "numpy.unique().tolist.index", "numpy.asarray"], "methods", ["None"], ["def", "load_data", "(", "self", ",", "p_problem_type", ",", "dataset", "=", "'input_a_file.csv'", ")", ":", "\n", "        ", "'''\n            Loading data\n        '''", "\n", "fromFile", "=", "os", ".", "path", ".", "join", "(", "os", ".", "getcwd", "(", ")", ",", "'data'", "+", "os", ".", "sep", "+", "dataset", ")", "\n", "print", "(", "'DATA: file path'", ",", "fromFile", ")", "\n", "#fromFile = os.path.join(\"data\",\"mnist.csv\")", "\n", "if", "path", ".", "exists", "(", "fromFile", ")", ":", "\n", "            ", "print", "(", "'DATA:loading from file '", ",", "fromFile", ")", "\n", "\n", "dataPD", "=", "pd", ".", "read_csv", "(", "fromFile", ")", "\n", "#collecting input and input names", "\n", "data", "=", "dataPD", ".", "loc", "[", ":", ",", "dataPD", ".", "columns", "!=", "'target'", "]", "\n", "feature_names", "=", "data", ".", "columns", ".", "tolist", "(", ")", "\n", "data", "=", "data", ".", "values", "\n", "# Collecting target                                ", "\n", "target", "=", "dataPD", "[", "'target'", "]", "\n", "target_names", "=", "None", "\n", "if", "p_problem_type", "==", "'Classification'", ":", "\n", "# converting string to int", "\n", "                ", "target_names", "=", "np", ".", "unique", "(", "np", ".", "asarray", "(", "target", ")", ")", ".", "tolist", "(", ")", "\n", "for", "x", "in", "target_names", ":", "\n", "                    ", "target", "=", "target", ".", "replace", "(", "x", ",", "target_names", ".", "index", "(", "x", ")", ")", "\n", "", "", "target", "=", "np", ".", "asanyarray", "(", "target", ")", "\n", "return", "Data", "(", "data", ",", "feature_names", ",", "target", ",", "target_names", ")", "\n", "", "else", ":", "\n", "            ", "if", "p_problem_type", "==", "'Classification'", ":", "\n", "                ", "print", "(", "'DATA: Classification - loading dataset '", ",", "dataset", ",", "' from sklearn library...'", ")", "\n", "if", "dataset", ".", "lower", "(", ")", "==", "'Iris'", ".", "lower", "(", ")", ":", "\n", "                    ", "from", "sklearn", ".", "datasets", "import", "load_iris", "\n", "data", "=", "load_iris", "(", ")", "\n", "\n", "", "if", "dataset", ".", "lower", "(", ")", "==", "'Wine'", ".", "lower", "(", ")", ":", "\n", "                    ", "from", "sklearn", ".", "datasets", "import", "load_wine", "\n", "data", "=", "load_wine", "(", ")", "\n", "", "if", "dataset", ".", "lower", "(", ")", "==", "'Wisconsin'", ".", "lower", "(", ")", ":", "\n", "                    ", "from", "sklearn", ".", "datasets", "import", "load_breast_cancer", "\n", "data", "=", "load_breast_cancer", "(", ")", "\n", "#if dataset.lower() == 'MINIS'.lower():", "\n", "#    from sklearn import datasets", "\n", "#    digits = datasets.load_digits()", "\n", "", "return", "Data", "(", "data", ".", "data", ",", "data", ".", "feature_names", ",", "data", ".", "target", ",", "data", ".", "target_names", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "'DATA: Classification - loading dataset '", ",", "dataset", ",", "' from sklearn library...'", ")", "\n", "if", "dataset", ".", "lower", "(", ")", "==", "'Diabetes'", ".", "lower", "(", ")", ":", "\n", "                    ", "from", "sklearn", ".", "datasets", "import", "load_diabetes", "\n", "data", "=", "load_diabetes", "(", ")", "\n", "", "if", "dataset", ".", "lower", "(", ")", "==", "'Boston'", ".", "lower", "(", ")", ":", "\n", "                    ", "from", "sklearn", ".", "datasets", "import", "load_boston", "\n", "data", "=", "load_boston", "(", ")", "\n", "", "return", "Data", "(", "data", ".", "data", ",", "data", ".", "feature_names", ",", "data", ".", "target", ")", "\n", "#------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.setParams": [[96, 101], ["None"], "methods", ["None"], ["", "", "", "def", "setParams", "(", "self", ",", "p_params", ")", ":", "\n", "        ", "'''\n            Setting paramters\n        '''", "\n", "self", ".", "m_params", "=", "p_params", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.normalize_data": [[104, 121], ["numpy.ndarray.min", "numpy.ndarray.max", "type", "numpy.ndarray"], "methods", ["None"], ["", "def", "normalize_data", "(", "X", ",", "nmin", "=", "0.0", ",", "nmax", "=", "1.0", ")", ":", "\n", "        ", "'''\n        Normalizing (Scaling) each featuer between nmin and nmax\n        args:\n            param: X is a numpy matrix matrix\n            param: nmin lowerbound for normalization\n            param: nmax upper bound for normalization\n        '''", "\n", "if", "type", "(", "X", ")", "==", "list", ":", "\n", "            ", "X", "=", "np", ".", "ndarray", "(", "X", ")", "\n", "", "Xmin", "=", "X", ".", "min", "(", "axis", "=", "0", ")", "\n", "Xmax", "=", "X", ".", "max", "(", "axis", "=", "0", ")", "\n", "\n", "X_std", "=", "(", "X", "-", "Xmin", ")", "/", "(", "Xmax", "-", "Xmin", ")", "\n", "X_scaled", "=", "X_std", "*", "(", "nmax", "-", "nmin", ")", "+", "nmin", "\n", "\n", "return", "X_scaled", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.denormalize_data": [[124, 135], ["None"], "methods", ["None"], ["", "def", "denormalize_data", "(", "X_norm", ",", "Xmin", ",", "Xmax", ",", "nmin", "=", "0.0", ",", "nmax", "=", "1.0", ")", ":", "\n", "        ", "'''\n        De-normalizing (De-scaling) each featuer\n        args:\n            param: X is a numpy matrix matrix\n            param: Xmin original data Min vector used for normalization\n            param: Xmax original data MAx vector used for normalization\n            param: nmin original lowerbound used for normalization\n            param: nmax original upper bound used for normalization\n        '''", "\n", "return", "(", "(", "Xmin", "-", "Xmax", ")", "*", "X_norm", "-", "nmax", "*", "Xmin", "+", "Xmax", "*", "nmin", ")", "/", "(", "nmin", "-", "nmax", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.holdout_method": [[137, 182], ["print", "numpy.arange", "print", "print", "len", "numpy.random.shuffle", "numpy.zeros", "numpy.zeros", "range", "numpy.split", "numpy.split", "numpy.split", "numpy.split", "len", "len", "print", "len", "len", "len", "int", "int", "int", "int", "int", "int", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split"], ["", "def", "holdout_method", "(", "self", ",", "val_set", "=", "False", ",", "training_set", "=", "0.8", ")", ":", "\n", "        ", "'''\n            Spliting data\n            paramL param - set of parameters\n        '''", "\n", "print", "(", "'Shuffling and Spliting data into training, validation, and test sets:'", ")", "\n", "#Fetching data from the param", "\n", "data_input_values", "=", "self", ".", "m_params", ".", "n_data_input_values", "\n", "data_target_values", "=", "self", ".", "m_params", ".", "n_data_target_values", "\n", "#prearing training, validation, and test sets", "\n", "# Randomizing the data samples", "\n", "# making a deep copy so the keep object of original file safe as np.random.shuffle(arr) modifies original object", "\n", "# and equating a = b means object remais the same but assigned to two variables", "\n", "random_sequence", "=", "np", ".", "arange", "(", "len", "(", "data_input_values", ")", ")", "\n", "if", "self", ".", "m_params", ".", "n_dataset_name", "==", "\"mnist.csv\"", ":", "\n", "# Do not randomize the data", "\n", "            ", "training_set", "=", "0.8571428571428571", "\n", "data_input_values_rand", "=", "data_input_values", "\n", "data_target_values_rand", "=", "data_target_values", "\n", "", "else", ":", "\n", "            ", "np", ".", "random", ".", "shuffle", "(", "random_sequence", ")", "\n", "#fetching data from array ", "\n", "data_input_values_rand", "=", "np", ".", "zeros", "(", "data_input_values", ".", "shape", ")", "\n", "data_target_values_rand", "=", "np", ".", "zeros", "(", "data_target_values", ".", "shape", ")", "\n", "for", "index", "in", "range", "(", "len", "(", "data_input_values", ")", ")", ":", "\n", "                ", "data_input_values_rand", "[", "index", "]", "=", "data_input_values", "[", "random_sequence", "[", "index", "]", "]", "\n", "data_target_values_rand", "[", "index", "]", "=", "data_target_values", "[", "random_sequence", "[", "index", "]", "]", "\n", "\n", "# Spliting into training test and validation sets", "\n", "", "", "if", "val_set", ":", "\n", "            ", "data_inputs", "=", "np", ".", "split", "(", "data_input_values_rand", ",", "[", "int", "(", ".6", "*", "len", "(", "data_input_values_rand", ")", ")", ",", "int", "(", ".8", "*", "len", "(", "data_input_values_rand", ")", ")", "]", ")", "\n", "data_targets", "=", "np", ".", "split", "(", "data_target_values_rand", ",", "[", "int", "(", ".6", "*", "len", "(", "data_target_values_rand", ")", ")", ",", "int", "(", ".8", "*", "len", "(", "data_target_values_rand", ")", ")", "]", ")", "\n", "", "else", ":", "\n", "            ", "data_inputs", "=", "np", ".", "split", "(", "data_input_values_rand", ",", "[", "int", "(", "training_set", "*", "len", "(", "data_input_values_rand", ")", ")", "]", ")", "\n", "data_targets", "=", "np", ".", "split", "(", "data_target_values_rand", ",", "[", "int", "(", "training_set", "*", "len", "(", "data_target_values_rand", ")", ")", "]", ")", "\n", "\n", "\n", "#Cheking the percent of the split", "\n", "", "print", "(", "'    training set   :'", ",", "len", "(", "data_inputs", "[", "0", "]", ")", ",", "' -> '", ",", "len", "(", "data_inputs", "[", "0", "]", ")", "*", "100.00", "/", "len", "(", "data_input_values", ")", ",", "'%'", ")", "\n", "print", "(", "'    test set       :'", ",", "len", "(", "data_inputs", "[", "1", "]", ")", ",", "' -> '", ",", "len", "(", "data_inputs", "[", "1", "]", ")", "*", "100.00", "/", "len", "(", "data_input_values", ")", ",", "'%'", ")", "\n", "if", "val_set", ":", "\n", "            ", "print", "(", "'    validation set :'", ",", "len", "(", "data_input_values", "[", "2", "]", ")", "*", "100.00", "/", "len", "(", "data_input_values", ")", ",", "'%'", ")", "\n", "\n", "#returning data split        ", "\n", "", "return", "data_inputs", ",", "data_targets", ",", "random_sequence", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.k_fold": [[185, 233], ["print", "numpy.arange", "numpy.random.shuffle", "numpy.zeros", "numpy.zeros", "range", "len", "len", "data_processing.DataProcessing.holdout_method", "int", "print", "range", "print", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.holdout_method"], ["", "def", "k_fold", "(", "self", ")", ":", "\n", "        ", "'''\n            Spliting data in 10 fold\n            paramL param - set of parameters\n        '''", "\n", "print", "(", "'Shuffling and Spliting data into training, validation, and test sets:'", ")", "\n", "#Fetching data from the param", "\n", "data_input_values", "=", "self", ".", "m_params", ".", "n_data_input_values", "\n", "data_target_values", "=", "self", ".", "m_params", ".", "n_data_target_values", "\n", "#prearing training, validation, and test sets", "\n", "# Randomizing the data samples", "\n", "# making a deep copy so the keep object of original file safe as np.random.shuffle(arr) modifies original object", "\n", "# and equating a = b means object remais the same but assigned to two variables", "\n", "random_sequence", "=", "np", ".", "arange", "(", "len", "(", "data_input_values", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "random_sequence", ")", "\n", "#fetching data from array ", "\n", "data_input_values_rand", "=", "np", ".", "zeros", "(", "data_input_values", ".", "shape", ")", "\n", "data_target_values_rand", "=", "np", ".", "zeros", "(", "data_target_values", ".", "shape", ")", "\n", "for", "index", "in", "range", "(", "len", "(", "data_input_values", ")", ")", ":", "\n", "            ", "data_input_values_rand", "[", "index", "]", "=", "data_input_values", "[", "random_sequence", "[", "index", "]", "]", "\n", "data_target_values_rand", "[", "index", "]", "=", "data_target_values", "[", "random_sequence", "[", "index", "]", "]", "\n", "\n", "# Spliting into k fold traiing and test", "\n", "", "k", "=", "self", ".", "m_params", ".", "n_validation_folds", "\n", "if", "(", "k", "==", "2", ")", ":", "\n", "            ", "return", "self", ".", "holdout_method", "(", "False", ",", "training_set", "=", "0.5", ")", "\n", "", "else", ":", "\n", "            ", "length", "=", "int", "(", "len", "(", "data_input_values_rand", ")", "/", "k", ")", "#length of each fold", "\n", "print", "(", "' Each fold length           :'", ",", "length", ",", "'for data length'", ",", "len", "(", "data_input_values_rand", ")", ")", "\n", "data_inputs_folds", "=", "[", "]", "\n", "data_target_folds", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "k", "-", "1", ")", ":", "\n", "                ", "data_inputs_folds", "+=", "[", "data_input_values_rand", "[", "i", "*", "length", ":", "(", "i", "+", "1", ")", "*", "length", "]", "]", "\n", "data_target_folds", "+=", "[", "data_target_values_rand", "[", "i", "*", "length", ":", "(", "i", "+", "1", ")", "*", "length", "]", "]", "\n", "", "data_inputs_folds", "+=", "[", "data_input_values_rand", "[", "(", "k", "-", "1", ")", "*", "length", ":", "len", "(", "data_input_values_rand", ")", "]", "]", "\n", "data_target_folds", "+=", "[", "data_target_values_rand", "[", "(", "k", "-", "1", ")", "*", "length", ":", "len", "(", "data_target_values_rand", ")", "]", "]", "\n", "\n", "# ONLY works for even data set", "\n", "#data_inputs_folds = np.split(data_input_values_rand, 10) ", "\n", "#data_target_folds = np.split(data_target_values_rand, 10)", "\n", "\n", "#Cheking the percent of the split", "\n", "print", "(", "'    each fold set size (input, target) : ('", ",", "len", "(", "data_inputs_folds", "[", "0", "]", ")", "*", "100.00", "/", "len", "(", "data_input_values", ")", ",", "'%, '", ",", "\n", "len", "(", "data_target_folds", "[", "0", "]", ")", "*", "100.00", "/", "len", "(", "data_target_values", ")", ",", "'% )'", ")", "\n", "#print('    each test     fold set size :', )", "\n", "\n", "#returning data split", "\n", "return", "data_inputs_folds", ",", "data_target_folds", ",", "random_sequence", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.five_x_two_fold": [[235, 282], ["print", "int", "print", "range", "print", "len", "numpy.arange", "numpy.random.shuffle", "numpy.zeros", "numpy.zeros", "range", "data_inputs_folds.append", "data_target_folds.append", "numpy.arange", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "methods", ["None"], ["", "", "def", "five_x_two_fold", "(", "self", ")", ":", "\n", "        ", "'''\n            Spliting data in 10 fold\n            paramL param - set of parameters\n        '''", "\n", "print", "(", "'Shuffling and Spliting data into training, validation, and test sets:'", ")", "\n", "#Fetching data from the param", "\n", "data_input_values", "=", "self", ".", "m_params", ".", "n_data_input_values", "\n", "data_target_values", "=", "self", ".", "m_params", ".", "n_data_target_values", "\n", "#prearing training, validation, and test sets", "\n", "# Randomizing the data samples", "\n", "# making a deep copy so the keep object of original file safe as np.random.shuffle(arr) modifies original object", "\n", "# and equating a = b means object remais the same but assigned to two variables", "\n", "# Spliting into 5 fold traiing and test each with 50%", "\n", "length", "=", "int", "(", "len", "(", "data_input_values", ")", "/", "2", ")", "#length of each fold", "\n", "print", "(", "' Each fold length           :'", ",", "length", ",", "'for data length'", ",", "len", "(", "data_input_values", ")", ")", "\n", "data_inputs_folds", ",", "data_target_folds", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "            ", "random_sequence", "=", "np", ".", "arange", "(", "len", "(", "data_input_values", ")", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "random_sequence", ")", "\n", "#fetching data from array ", "\n", "data_input_values_rand", "=", "np", ".", "zeros", "(", "data_input_values", ".", "shape", ")", "\n", "data_target_values_rand", "=", "np", ".", "zeros", "(", "data_target_values", ".", "shape", ")", "\n", "for", "index", "in", "range", "(", "len", "(", "data_input_values", ")", ")", ":", "\n", "                ", "data_input_values_rand", "[", "index", "]", "=", "data_input_values", "[", "random_sequence", "[", "index", "]", "]", "\n", "data_target_values_rand", "[", "index", "]", "=", "data_target_values", "[", "random_sequence", "[", "index", "]", "]", "\n", "\n", "", "data_inputs", "=", "[", "]", "\n", "data_target", "=", "[", "]", "\n", "# Training", "\n", "data_inputs", "+=", "[", "data_input_values_rand", "[", "0", ":", "length", "]", "]", "\n", "data_target", "+=", "[", "data_target_values_rand", "[", "0", ":", "length", "]", "]", "\n", "# Test", "\n", "data_inputs", "+=", "[", "data_input_values_rand", "[", "length", ":", "len", "(", "data_input_values_rand", ")", "]", "]", "\n", "data_target", "+=", "[", "data_target_values_rand", "[", "length", ":", "len", "(", "data_target_values_rand", ")", "]", "]", "\n", "\n", "data_inputs_folds", ".", "append", "(", "data_inputs", ")", "\n", "data_target_folds", ".", "append", "(", "data_target", ")", "\n", "\n", "#data_inputs_folds.append(np.split(data_input_values_rand, 2))", "\n", "#data_target_folds.append(np.split(data_target_values_rand, 2))", "\n", "\n", "#Cheking the percent of the split", "\n", "", "print", "(", "'    each fold set size (input, target) :'", ",", "len", "(", "data_inputs_folds", "[", "0", "]", "[", "0", "]", ")", "*", "100.00", "/", "len", "(", "data_input_values", ")", ",", "'%'", ",", "\n", "len", "(", "data_target_folds", "[", "0", "]", "[", "1", "]", ")", "*", "100.00", "/", "len", "(", "data_target_values", ")", ",", "'%'", ")", "\n", "#returning data split", "\n", "return", "data_inputs_folds", ",", "data_target_folds", ",", "np", ".", "arange", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_partition": [[11, 24], ["print", "dataProcessing.holdout_method", "dataProcessing.holdout_method", "dataProcessing.k_fold", "dataProcessing.five_x_two_fold"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.holdout_method", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.holdout_method", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.k_fold", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.five_x_two_fold"], ["def", "data_partition", "(", "dataProcessing", ",", "data_partition", "=", "'holdout'", ")", ":", "\n", "    ", "print", "(", "'DATA PARTITION: '", ",", "data_partition", ")", "\n", "if", "(", "data_partition", "==", "'holdout'", ")", ":", "\n", "        ", "return", "dataProcessing", ".", "holdout_method", "(", ")", "\n", "\n", "", "if", "(", "data_partition", "==", "'holdout_val'", ")", ":", "\n", "        ", "return", "dataProcessing", ".", "holdout_method", "(", "True", ")", "\n", "\n", "", "if", "(", "data_partition", "==", "'k_fold'", ")", ":", "\n", "        ", "return", "dataProcessing", ".", "k_fold", "(", ")", "\n", "\n", "", "if", "(", "data_partition", "==", "'five_x_two_fold'", ")", ":", "\n", "        ", "return", "dataProcessing", ".", "five_x_two_fold", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_loader.data_evaluation": [[27, 111], ["print", "src.tree.evaluate_tree.EvaluateTree", "print", "range", "print", "n_target_denorm_params.append", "n_target_denorm_params.append", "n_target_denorm_params.append", "n_target_denorm_params.append", "numpy.concatenate", "numpy.concatenate"], "function", ["None"], ["", "", "def", "data_evaluation", "(", "params", ",", "data_input_values", ",", "data_target_values", ",", "data_partition", "=", "'holdout'", ",", "test_fold", "=", "0", ",", "cross", "=", "0", ")", ":", "\n", "    ", "k", "=", "params", ".", "n_validation_folds", "\n", "if", "(", "data_partition", "==", "'holdout'", "or", "k", "==", "2", ")", ":", "\n", "        ", "data_train_input_values", "=", "data_input_values", "[", "0", "]", "# Training inputs", "\n", "data_test_input_values", "=", "data_input_values", "[", "1", "]", "# Test inputs", "\n", "data_val_input_values", "=", "None", "\n", "data_train_target_values", "=", "data_target_values", "[", "0", "]", "# Training target", "\n", "data_test_target_values", "=", "data_target_values", "[", "1", "]", "# Test target", "\n", "data_val_target_values", "=", "None", "\n", "#del data_input_values, data_target_values ", "\n", "\n", "", "if", "(", "data_partition", "==", "'holdout_val'", ")", ":", "\n", "# preapre trainig data", "\n", "        ", "data_train_input_values", "=", "data_input_values", "[", "0", "]", "# Training inputs", "\n", "data_test_input_values", "=", "data_input_values", "[", "1", "]", "# Test inputs", "\n", "data_val_input_values", "=", "data_input_values", "[", "2", "]", "# Validation inputs", "\n", "data_train_target_values", "=", "data_target_values", "[", "0", "]", "# Training target", "\n", "data_test_target_values", "=", "data_target_values", "[", "1", "]", "# Test target", "\n", "data_val_target_values", "=", "data_target_values", "[", "2", "]", "# Validation target", "\n", "\n", "", "if", "(", "data_partition", "==", "'k_fold'", "and", "k", "!=", "2", ")", ":", "\n", "        ", "print", "(", "'\\nTraining on fold:'", ",", "test_fold", ")", "\n", "# concatenate training sets", "\n", "fistNonTestSetAdded", "=", "0", "\n", "for", "fold", "in", "range", "(", "k", ")", ":", "\n", "            ", "if", "fold", "!=", "test_fold", ":", "\n", "                ", "if", "fistNonTestSetAdded", "==", "0", ":", "\n", "                    ", "fistNonTestSetAdded", "=", "1", "\n", "data_train_input_values", "=", "data_input_values", "[", "fold", "]", "# Training inputs set for the test fold", "\n", "data_train_target_values", "=", "data_target_values", "[", "fold", "]", "# Training inputs set for the test fold", "\n", "#print('First set', data_train_input_values.shape, data_train_target_values.shape)", "\n", "", "else", ":", "\n", "                    ", "data_train_input_values", "=", "np", ".", "concatenate", "(", "(", "data_train_input_values", ",", "data_input_values", "[", "fold", "]", ")", ",", "axis", "=", "0", ")", "\n", "data_train_target_values", "=", "np", ".", "concatenate", "(", "(", "data_train_target_values", ",", "data_target_values", "[", "fold", "]", ")", ",", "axis", "=", "0", ")", "\n", "#print('Concatenation', data_train_input_values.shape, data_train_target_values.shape)", "\n", "\n", "", "", "", "data_test_input_values", "=", "data_input_values", "[", "test_fold", "]", "# Test inputs", "\n", "data_test_target_values", "=", "data_target_values", "[", "test_fold", "]", "# Test target", "\n", "\n", "data_val_input_values", "=", "None", "\n", "data_val_target_values", "=", "None", "\n", "\n", "", "if", "(", "data_partition", "==", "'five_x_two_fold'", ")", ":", "\n", "        ", "print", "(", "'\\nTraining on fold: '", ",", "test_fold", ",", "cross", ")", "\n", "if", "cross", "==", "0", ":", "\n", "#first set", "\n", "            ", "data_train_input_values", "=", "data_input_values", "[", "test_fold", "]", "[", "0", "]", "# Training inputs set fold", "\n", "data_train_target_values", "=", "data_target_values", "[", "test_fold", "]", "[", "0", "]", "# Training target fold", "\n", "#second set", "\n", "data_test_input_values", "=", "data_input_values", "[", "test_fold", "]", "[", "1", "]", "# Test inputs set fold", "\n", "data_test_target_values", "=", "data_target_values", "[", "test_fold", "]", "[", "1", "]", "# Test target fold", "\n", "", "else", ":", "\n", "#second set", "\n", "            ", "data_train_input_values", "=", "data_input_values", "[", "test_fold", "]", "[", "1", "]", "# Training inputs set fold", "\n", "data_train_target_values", "=", "data_target_values", "[", "test_fold", "]", "[", "1", "]", "# Training target fold", "\n", "#first set", "\n", "data_test_input_values", "=", "data_input_values", "[", "test_fold", "]", "[", "0", "]", "# Test inputs set fold", "\n", "data_test_target_values", "=", "data_target_values", "[", "test_fold", "]", "[", "0", "]", "# Test target fold ", "\n", "\n", "", "data_val_input_values", "=", "None", "\n", "data_val_target_values", "=", "None", "\n", "\n", "", "print", "(", "'Setting tree evalation paramters'", ")", "\n", "n_target_attr_count", "=", "params", ".", "n_max_target_attr", "\n", "n_class_names", "=", "params", ".", "n_data_target_names", "\n", "n_target_denorm_params", "=", "[", "params", ".", "n_is_data_normlized", "]", "\n", "if", "params", ".", "n_is_data_normlized", "and", "params", ".", "n_problem_type", "!=", "'Classification'", ":", "\n", "        ", "n_target_denorm_params", ".", "append", "(", "params", ".", "n_data_target_min", ")", "\n", "n_target_denorm_params", ".", "append", "(", "params", ".", "n_data_target_max", ")", "\n", "n_target_denorm_params", ".", "append", "(", "params", ".", "n_data_norm_min", ")", "\n", "n_target_denorm_params", ".", "append", "(", "params", ".", "n_data_norm_max", ")", "\n", "\n", "#Training data evaluation", "\n", "", "evaluateTree", "=", "EvaluateTree", "(", "params", ".", "n_problem_type", ",", "\n", "data_train_input_values", ",", "\n", "data_test_input_values", ",", "\n", "data_val_input_values", ",", "\n", "data_train_target_values", ",", "\n", "data_test_target_values", ",", "\n", "data_val_target_values", ",", "\n", "n_target_attr_count", ",", "\n", "n_class_names", ",", "\n", "n_target_denorm_params", ")", "\n", "return", "evaluateTree", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.elpsadeTime": [[14, 17], ["delta.total_seconds"], "function", ["None"], ["def", "elpsadeTime", "(", "start", ",", "end", ")", ":", "\n", "    ", "delta", "=", "end", "-", "start", "\n", "return", "delta", ".", "total_seconds", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.optimalTreeFitness": [[19, 23], ["evaluateTree.set_dataset_to_evaluate", "evaluateTree.getTreePredictedOutputs", "evaluateTree.getTreeFitness", "pTree.getTreeSize"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "def", "optimalTreeFitness", "(", "evaluateTree", ",", "pTree", ",", "pSet", "=", "'test'", ")", ":", "\n", "    ", "evaluateTree", ".", "set_dataset_to_evaluate", "(", "pSet", ")", "\n", "_", "=", "evaluateTree", ".", "getTreePredictedOutputs", "(", "pTree", ")", "\n", "return", "evaluateTree", ".", "getTreeFitness", "(", ")", "+", "[", "pTree", ".", "getTreeSize", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveModel": [[25, 33], ["src.reporting.display_tree.DisplayTree", "src.reporting.display_tree.DisplayTree.saveTreeOutline", "src.reporting.display_tree.DisplayTree.saveTreeModel", "src.reporting.display_tree.DisplayTree.saveTreeModel", "str", "str"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.saveTreeOutline", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.saveTreeModel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.saveTreeModel"], ["", "def", "saveModel", "(", "n_tree", ",", "algo", ",", "directory", ",", "trail", ",", "index", "=", "''", ",", "saveBothFormat", "=", "True", ")", ":", "\n", "    ", "d_tree", "=", "DisplayTree", "(", ")", "# Creating object fo0r display tree", "\n", "trail", "=", "str", "(", "algo", ")", "+", "'_'", "+", "str", "(", "trail", ")", "+", "index", "\n", "if", "saveBothFormat", ":", "\n", "        ", "d_tree", ".", "saveTreeOutline", "(", "n_tree", ",", "directory", ",", "trail", ")", "\n", "d_tree", ".", "saveTreeModel", "(", "n_tree", ",", "directory", ",", "trail", ")", "\n", "", "else", ":", "\n", "        ", "d_tree", ".", "saveTreeModel", "(", "n_tree", ",", "directory", ",", "trail", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotTreeFitness": [[35, 40], ["evaluateTree.set_dataset_to_evaluate", "evaluateTree.getTreePredictedOutputs", "evaluateTree.plot", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot"], ["", "", "def", "plotTreeFitness", "(", "evaluateTree", ",", "pTree", ",", "directory", ",", "trail", ",", "algo", "=", "'gp_gd'", ",", "pSet", "=", "'test'", ")", ":", "\n", "    ", "evaluateTree", ".", "set_dataset_to_evaluate", "(", "pSet", ")", "\n", "_", "=", "evaluateTree", ".", "getTreePredictedOutputs", "(", "pTree", ")", "\n", "trail", "=", "str", "(", "algo", ")", "+", "'_'", "+", "str", "(", "pSet", ")", "+", "'_'", "+", "str", "(", "trail", ")", "\n", "evaluateTree", ".", "plot", "(", "directory", ",", "trail", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPerfromance": [[41, 79], ["numpy.arange", "matplotlib.subplots", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.tight_layout", "os.path.join", "matplotlib.savefig", "len", "len", "matplotlib.figure", "seaborn.reset_orig", "seaborn.color_palette", "matplotlib.subplots", "range", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.tight_layout", "os.path.join", "plt.figure.savefig", "str", "ax.plot", "lines[].set_color", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot"], ["", "def", "plotPerfromance", "(", "performance", ",", "algo", ",", "directory", ",", "trail", ",", "class_names", ",", "isClass", "=", "'Classification'", ")", ":", "\n", "    ", "x", "=", "np", ".", "arange", "(", "len", "(", "performance", ")", ")", "\n", "y", "=", "[", "row", "[", "0", "]", "for", "row", "in", "performance", "]", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plt", ".", "plot", "(", "x", ",", "y", ",", "color", "=", "'b'", ")", "\n", "#plt.margins(0)", "\n", "plt", ".", "xlabel", "(", "'generations '", "+", "str", "(", "algo", ")", ")", "\n", "plt", ".", "ylabel", "(", "'error rate'", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "#plt.show()    ", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "# Save figure", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerformance_'", "+", "str", "(", "algo", ")", "+", "'_'", "+", "str", "(", "trail", ")", "+", "'.pdf'", ")", "\n", "plt", ".", "savefig", "(", "graph_filepath", ",", "dpi", "=", "300", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "#plt.close()", "\n", "if", "isClass", "==", "'Classification'", ":", "\n", "        ", "CLASSES", "=", "len", "(", "performance", "[", "0", "]", "[", "1", "]", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "sns", ".", "reset_orig", "(", ")", "# get default matplotlib styles back", "\n", "clrs", "=", "sns", ".", "color_palette", "(", "'husl'", ",", "n_colors", "=", "CLASSES", ")", "# a list of RGB tuples", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "CLASSES", ")", ":", "\n", "            ", "prec", "=", "[", "row", "[", "1", "]", "[", "i", "]", "for", "row", "in", "performance", "]", "# precision", "\n", "recall", "=", "[", "row", "[", "2", "]", "[", "i", "]", "for", "row", "in", "performance", "]", "# recall, sensictivty", "\n", "#specificity = [row[0][3][i] for row in performance] # specificity", "\n", "lines", "=", "ax", ".", "plot", "(", "recall", ",", "prec", ",", "marker", "=", "'o'", ",", "label", "=", "str", "(", "class_names", "[", "i", "]", ")", ")", "\n", "lines", "[", "0", "]", ".", "set_color", "(", "clrs", "[", "i", "]", ")", "\n", "#plt.plot(recall, prec, label=str(class_names[i]))", "\n", "", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'recall'", ")", "\n", "plt", ".", "ylabel", "(", "'precision'", ")", "\n", "plt", ".", "legend", "(", "bbox_to_anchor", "=", "(", "0", ",", "1.02", ",", "1", ",", "0.2", ")", ",", "loc", "=", "\"lower left\"", ",", "mode", "=", "\"expand\"", ",", "borderaxespad", "=", "0", ",", "ncol", "=", "3", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "#plt.show()", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePrecRecall_Curve_'", "+", "str", "(", "algo", ")", "+", "'_'", "+", "str", "(", "trail", ")", "+", "'.pdf'", ")", "\n", "fig", ".", "savefig", "(", "graph_filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPerfromanceBoth": [[82, 126], ["numpy.arange", "len", "seaborn.color_palette", "matplotlib.subplots", "matplotlib.plot", "matplotlib.plot", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.ylim", "matplotlib.tight_layout", "matplotlib.legend", "os.path.join", "matplotlib.savefig", "len", "len", "matplotlib.figure", "seaborn.reset_orig", "seaborn.color_palette", "matplotlib.subplots", "range", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.tight_layout", "os.path.join", "plt.figure.savefig", "str", "str", "str", "ax.plot", "lines[].set_color", "str", "str", "str", "str", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot"], ["", "", "def", "plotPerfromanceBoth", "(", "performanceGP", ",", "performanceMH", ",", "algo_gp", ",", "algo_mh", ",", "directory", ",", "trail", ",", "class_names", ",", "isClass", "=", "'Classification'", ")", ":", "\n", "    ", "performance", "=", "performanceGP", "+", "performanceMH", "\n", "x", "=", "np", ".", "arange", "(", "len", "(", "performance", ")", ")", "\n", "y", "=", "[", "row", "[", "0", "]", "for", "row", "in", "performance", "]", "\n", "x0", "=", "len", "(", "performanceGP", ")", "\n", "clrs", "=", "sns", ".", "color_palette", "(", "'husl'", ",", "n_colors", "=", "2", ")", "# a list of RGB tuples", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plt", ".", "plot", "(", "x", "[", ":", "x0", "+", "1", "]", ",", "y", "[", ":", "x0", "+", "1", "]", ",", "color", "=", "clrs", "[", "0", "]", ",", "label", "=", "str", "(", "algo_gp", ")", ")", "\n", "plt", ".", "plot", "(", "x", "[", "x0", ":", "]", ",", "y", "[", "x0", ":", "]", ",", "color", "=", "clrs", "[", "1", "]", ",", "label", "=", "str", "(", "algo_mh", ")", ")", "\n", "\n", "#plt.margins(0)", "\n", "plt", ".", "xlabel", "(", "'generations '", "+", "str", "(", "algo_gp", ")", "+", "' and '", "+", "str", "(", "algo_mh", ")", ")", "\n", "plt", ".", "ylabel", "(", "'error'", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'upper right'", ")", "\n", "#plt.show()", "\n", "# Save figure", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePerformance_'", "+", "str", "(", "algo_gp", ")", "+", "'_'", "+", "str", "(", "algo_mh", ")", "+", "'_'", "+", "str", "(", "trail", ")", "+", "'.pdf'", ")", "\n", "plt", ".", "savefig", "(", "graph_filepath", ",", "dpi", "=", "300", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n", "if", "isClass", "==", "'Classification'", ":", "\n", "        ", "CLASSES", "=", "len", "(", "performance", "[", "0", "]", "[", "1", "]", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "sns", ".", "reset_orig", "(", ")", "# get default matplotlib styles back", "\n", "clrs", "=", "sns", ".", "color_palette", "(", "'husl'", ",", "n_colors", "=", "CLASSES", ")", "# a list of RGB tuples", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "CLASSES", ")", ":", "\n", "            ", "prec", "=", "[", "row", "[", "1", "]", "[", "i", "]", "for", "row", "in", "performance", "]", "# precision", "\n", "recall", "=", "[", "row", "[", "2", "]", "[", "i", "]", "for", "row", "in", "performance", "]", "# recall, sensictivty", "\n", "#specificity = [row[0][3][i] for row in performance] # specificity", "\n", "lines", "=", "ax", ".", "plot", "(", "recall", ",", "prec", ",", "marker", "=", "'o'", ",", "label", "=", "str", "(", "class_names", "[", "i", "]", ")", ")", "\n", "lines", "[", "0", "]", ".", "set_color", "(", "clrs", "[", "i", "]", ")", "\n", "#plt.plot(recall, prec, label=str(class_names[i]))", "\n", "", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'recall'", ")", "\n", "plt", ".", "ylabel", "(", "'precision'", ")", "\n", "plt", ".", "legend", "(", "bbox_to_anchor", "=", "(", "0", ",", "1.02", ",", "1", ",", "0.2", ")", ",", "loc", "=", "\"lower left\"", ",", "mode", "=", "\"expand\"", ",", "borderaxespad", "=", "0", ",", "ncol", "=", "3", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "#plt.show()", "\n", "# Save figure", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePrecRecall_Curve_'", "+", "str", "(", "algo_gp", ")", "+", "'_'", "+", "str", "(", "algo_mh", ")", "+", "'_'", "+", "str", "(", "trail", ")", "+", "'.pdf'", ")", "\n", "fig", ".", "savefig", "(", "graph_filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotPrecisionVsRecall": [[128, 149], ["len", "matplotlib.figure", "seaborn.reset_orig", "seaborn.color_palette", "matplotlib.subplots", "range", "matplotlib.xlim", "matplotlib.ylim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.tight_layout", "os.path.join", "plt.figure.savefig", "ax.scatter", "str", "str", "str", "str"], "function", ["None"], ["", "", "def", "plotPrecisionVsRecall", "(", "performance", ",", "algo", ",", "directory", ",", "trail", ",", "class_names", ",", "pSet", ")", ":", "\n", "    ", "CLASSES", "=", "len", "(", "performance", "[", "1", "]", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "sns", ".", "reset_orig", "(", ")", "# get default matplotlib styles back", "\n", "clrs", "=", "sns", ".", "color_palette", "(", "'husl'", ",", "n_colors", "=", "CLASSES", ")", "# a list of RGB tuples", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "CLASSES", ")", ":", "\n", "        ", "prec", "=", "performance", "[", "1", "]", "[", "i", "]", "# precision", "\n", "recall", "=", "performance", "[", "2", "]", "[", "i", "]", "# recall, sensictivty", "\n", "#specificity = performance[3][i] # specificity", "\n", "ax", ".", "scatter", "(", "recall", ",", "prec", ",", "label", "=", "str", "(", "class_names", "[", "i", "]", ")", ",", "color", "=", "clrs", "[", "i", "]", ")", "\n", "\n", "", "plt", ".", "xlim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "ylim", "(", "[", "0.0", ",", "1.05", "]", ")", "\n", "plt", ".", "xlabel", "(", "'recall'", ")", "\n", "plt", ".", "ylabel", "(", "'precision'", ")", "\n", "plt", ".", "legend", "(", "bbox_to_anchor", "=", "(", "0", ",", "1.02", ",", "1", ",", "0.2", ")", ",", "loc", "=", "\"lower left\"", ",", "mode", "=", "\"expand\"", ",", "borderaxespad", "=", "0", ",", "ncol", "=", "3", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "#plt.show()", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treePrecRecall_Plot_'", "+", "str", "(", "algo", ")", "+", "'_'", "+", "str", "(", "pSet", ")", "+", "'_'", "+", "str", "(", "trail", ")", "+", "'.pdf'", ")", "\n", "fig", ".", "savefig", "(", "graph_filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.getTraingParamsDict": [[150, 161], ["vars", "training_params.update", "str", "training_params.update", "str", "training_params.update", "str"], "function", ["None"], ["", "def", "getTraingParamsDict", "(", "params", ")", ":", "\n", "    ", "training_params", "=", "{", "}", "\n", "for", "key", "in", "vars", "(", "params", ")", ":", "\n", "        ", "if", "str", "(", "key", ")", "==", "'n_data_input_values'", ":", "\n", "            ", "training_params", ".", "update", "(", "{", "'n_data_input_examples'", ":", "params", ".", "__dict__", "[", "key", "]", ".", "shape", "}", ")", "\n", "continue", "\n", "", "if", "str", "(", "key", ")", "==", "'n_data_target_values'", ":", "\n", "            ", "training_params", ".", "update", "(", "{", "'n_data_target_examples'", ":", "params", ".", "__dict__", "[", "key", "]", ".", "shape", "}", ")", "\n", "continue", "\n", "", "training_params", ".", "update", "(", "{", "str", "(", "key", ")", ":", "params", ".", "__dict__", "[", "key", "]", "}", ")", "\n", "", "return", "training_params", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotParetoFront": [[163, 179], ["matplotlib.subplots", "matplotlib.scatter", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.tight_layout", "os.path.join", "matplotlib.savefig", "os.path.join", "numpy.save", "zip", "str", "str", "str", "str", "str", "str"], "function", ["None"], ["", "def", "plotParetoFront", "(", "x", ",", "y", ",", "directory", ",", "trial", ",", "algo", "=", "'gp_'", ",", "plotName", "=", "'treePopulation_'", ")", ":", "\n", "    ", "'''\n        GP population data and saving error rate and tree size\n    '''", "\n", "# Plot", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plt", ".", "scatter", "(", "x", ",", "y", ",", "alpha", "=", "0.6", ",", "s", "=", "80", ",", "color", "=", "'b'", ",", "marker", "=", "'o'", ")", "\n", "#plt.margins(0,0)", "\n", "plt", ".", "xlabel", "(", "'error rate'", ")", "\n", "plt", ".", "ylabel", "(", "'tree size'", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "# Save figure", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "str", "(", "plotName", ")", "+", "str", "(", "algo", ")", "+", "str", "(", "trial", ")", "+", "'.pdf'", ")", "\n", "plt", ".", "savefig", "(", "graph_filepath", ",", "dpi", "=", "300", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "str", "(", "plotName", ")", "+", "str", "(", "algo", ")", "+", "str", "(", "trial", ")", ")", "\n", "np", ".", "save", "(", "graph_filepath", ",", "zip", "(", "x", ",", "y", ")", ")", "\n", "#plt.show()", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration": [[182, 199], ["os.path.join", "range", "os.path.join", "numpy.save", "str", "os.makedirs", "pPopulation[].mTree.getTreeSize", "len", "plots.saveModel", "zip", "print", "range", "range", "str", "len", "len", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveModel"], ["", "def", "saveGPIteration", "(", "pPopulation", ",", "directory", ",", "trial", ",", "dirItr", "=", "'0'", ",", "algo", "=", "'gp_'", ",", "plotName", "=", "'treeItrPopulation_'", ")", ":", "\n", "    ", "'''\n        Saveing GP iteration data\n    '''", "\n", "directoryItr", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "str", "(", "dirItr", ")", ")", "\n", "try", ":", "\n", "        ", "os", ".", "makedirs", "(", "directoryItr", ")", "\n", "", "except", "OSError", ":", "\n", "        ", "print", "(", "\"Directory already exisit or fails to create one\"", ")", "\n", "# Save iteration_data", "\n", "", "x", "=", "[", "pPopulation", "[", "i", "]", ".", "mCost", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "pPopulation", ")", ")", "]", "\n", "y", "=", "[", "pPopulation", "[", "i", "]", ".", "mTree", ".", "getTreeSize", "(", ")", "for", "i", "in", "range", "(", "len", "(", "pPopulation", ")", ")", "]", "\n", "\n", "for", "indx", "in", "range", "(", "len", "(", "pPopulation", ")", ")", ":", "\n", "        ", "saveModel", "(", "pPopulation", "[", "indx", "]", ".", "mTree", ",", "algo", ",", "directoryItr", ",", "trial", ",", "dirItr", "+", "'_'", "+", "str", "(", "indx", ")", ",", "False", ")", "\n", "", "data_filepath", "=", "os", ".", "path", ".", "join", "(", "directoryItr", ",", "str", "(", "plotName", ")", "+", "str", "(", "algo", ")", "+", "str", "(", "trial", ")", ")", "\n", "np", ".", "save", "(", "data_filepath", ",", "zip", "(", "x", ",", "y", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.__init__": [[28, 43], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p_prob_type", ",", "p_y_true", ",", "p_y_pred", ",", "p_class_names", ")", ":", "\n", "        ", "'''\n            Set the tru and predicted values\n            Args:\n                param: p_prob_type claisiffication or  regression\n                param: p_y_true an array\n                param: p_y_pred an array\n                param: p_y_names an array of class col names\n        '''", "\n", "self", ".", "m_y_type", "=", "p_prob_type", "#  Classifcation/ Regression", "\n", "\n", "self", ".", "m_y_true", "=", "p_y_true", "#  actual target values", "\n", "self", ".", "m_y_pred", "=", "p_y_pred", "#  tree predicted target values", "\n", "\n", "self", ".", "m_y_names", "=", "p_class_names", "#classs names or in other words target columns names", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.measures": [[46, 71], ["perfromance_metrices.Perfromance.classOuputProcessing", "performance.append", "performance.append", "performance.append", "sklearn.metrics.accuracy_score", "perfromance_metrices.Perfromance.get_FP_FN_TP_TN", "sklearn.metrics.mean_squared_error", "sklearn.metrics.r2_score", "sklearn.metrics.confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.classOuputProcessing", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.get_FP_FN_TP_TN"], ["", "def", "measures", "(", "self", ")", ":", "\n", "        ", "'''\n            Compute error of the tree for y_ture and y_pred\n            \n            Return: (float) accuracy/meas squared error of the tree\n        '''", "\n", "performance", "=", "[", "]", "\n", "if", "(", "self", ".", "m_y_type", "==", "'Classification'", ")", ":", "\n", "#If problem is classifcation", "\n", "# return error rate", "\n", "\n", "\n", "            ", "y_true", ",", "y_pred", "=", "self", ".", "classOuputProcessing", "(", "True", ")", "\n", "error", "=", "1.0", "-", "accuracy_score", "(", "y_true", ",", "y_pred", ")", "\n", "performance", ".", "append", "(", "error", ")", "\n", "performance", "=", "performance", "+", "self", ".", "get_FP_FN_TP_TN", "(", "confusion_matrix", "(", "y_true", ",", "y_pred", ")", ")", "\n", "#performance.append(log_loss(self.m_y_true, self.m_y_pred))", "\n", "#performance = performance + list(precision_recall_fscore_support(y_true, y_pred, average='macro'))", "\n", "#return 1.0 - accuracy_score(y_true, y_pred)", "\n", "", "else", ":", "\n", "#retrun mse", "\n", "            ", "performance", ".", "append", "(", "mean_squared_error", "(", "self", ".", "m_y_true", ",", "self", ".", "m_y_pred", ")", ")", "\n", "performance", ".", "append", "(", "r2_score", "(", "self", ".", "m_y_true", ",", "self", ".", "m_y_pred", ")", ")", "\n", "#return mean_squared_error(self.m_y_true, self.m_y_pred)", "\n", "", "return", "performance", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.get_FP_FN_TP_TN": [[72, 108], ["numpy.diag", "FP.astype.astype.astype", "FN.astype.astype.astype", "TP.astype.astype.astype", "TN.astype.astype.astype", "cm.sum", "numpy.diag", "cm.sum", "numpy.diag", "cm.sum"], "methods", ["None"], ["", "def", "get_FP_FN_TP_TN", "(", "self", ",", "cm", ")", ":", "\n", "        ", "FP", "=", "cm", ".", "sum", "(", "axis", "=", "0", ")", "-", "np", ".", "diag", "(", "cm", ")", "\n", "FN", "=", "cm", ".", "sum", "(", "axis", "=", "1", ")", "-", "np", ".", "diag", "(", "cm", ")", "\n", "TP", "=", "np", ".", "diag", "(", "cm", ")", "\n", "TN", "=", "cm", ".", "sum", "(", ")", "-", "(", "FP", "+", "FN", "+", "TP", ")", "\n", "\n", "FP", "=", "FP", ".", "astype", "(", "float", ")", "\n", "FN", "=", "FN", ".", "astype", "(", "float", ")", "\n", "TP", "=", "TP", ".", "astype", "(", "float", ")", "\n", "TN", "=", "TN", ".", "astype", "(", "float", ")", "\n", "\n", "## Sensitivity, hit rate, recall, or true positive rate", "\n", "TPR", "=", "TP", "/", "(", "TP", "+", "FN", ")", "\n", "\n", "## Specificity or true negative rate", "\n", "TNR", "=", "TN", "/", "(", "TN", "+", "FP", ")", "\n", "\n", "## Precision or positive predictive value", "\n", "PPV", "=", "TP", "/", "(", "TP", "+", "FP", ")", "\n", "# Negative predictive value", "\n", "#NPV = TN/(TN+FN)", "\n", "# Fall out or false positive rate", "\n", "#FPR = FP/(FP+TN)", "\n", "## False negative rate", "\n", "#FNR = FN/(TP+FN)", "\n", "## False discovery rate", "\n", "#FDR = FP/(TP+FP)", "\n", "\n", "# Overall accuracy", "\n", "#ACC = (TP+TN)/(TP+FP+FN+TN)", "\n", "#print('Precision',PPV)", "\n", "#print('Recall/Sensitivity',TPR)", "\n", "#print('Specificity',TNR)", "\n", "\n", "#precision, recall, Specificity", "\n", "return", "[", "PPV", ",", "TPR", ",", "]", "\n", "#-------------------------------------------------------------------------------------------------------------    ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.accuracy": [[111, 116], ["sklearn.metrics.accuracy_score"], "methods", ["None"], ["", "def", "accuracy", "(", "self", ")", ":", "\n", "        ", "'''\n            Return accuracy of the tree\n        '''", "\n", "return", "accuracy_score", "(", "self", ".", "m_y_true", ",", "self", ".", "m_y_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.classOuputProcessing": [[118, 140], ["perfromance_metrices.Perfromance.assignClassLebel", "perfromance_metrices.Perfromance.assignClassLebel", "perfromance_metrices.Perfromance.multilevelTOsinglelevel", "perfromance_metrices.Perfromance.multilevelTOsinglelevel", "perfromance_metrices.Perfromance.multilevelTOsinglelevel", "perfromance_metrices.Perfromance.multilevelTOsinglelevel", "perfromance_metrices.Perfromance.classPredictionBinarization", "perfromance_metrices.Perfromance.classPredictionBinarization"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.assignClassLebel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.assignClassLebel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.multilevelTOsinglelevel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.multilevelTOsinglelevel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.multilevelTOsinglelevel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.multilevelTOsinglelevel", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.classPredictionBinarization", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.classPredictionBinarization"], ["", "def", "classOuputProcessing", "(", "self", ",", "AssignLebels", "=", "True", ")", ":", "\n", "        ", "'''\n            Method for printing calssification confision metric and accuracy\n            variables used:\n                param:    p_class_names         (string) class name \n                param:    p_data_true_traget    (numeric) binarized class multi column calassss lebels\n                param:    p_data_pred_traget    (float) class multi column callss lebels\n                \n                Optional:\n                param:    AssignLebels          (boolean) \"True\" for NOMINAL return and \"False\" for NUMERIC\n            \n            return: NOMINAL/NUMERIC class array\n        '''", "\n", "#Computeing single level for the binary multilevel data   ", "\n", "if", "(", "AssignLebels", ")", ":", "\n", "#print('Test Assign Labels')", "\n", "            ", "y_true", "=", "self", ".", "assignClassLebel", "(", "self", ".", "m_y_names", ",", "self", ".", "multilevelTOsinglelevel", "(", "self", ".", "m_y_true", ")", ")", "\n", "y_pred", "=", "self", ".", "assignClassLebel", "(", "self", ".", "m_y_names", ",", "self", ".", "multilevelTOsinglelevel", "(", "self", ".", "classPredictionBinarization", "(", "self", ".", "m_y_pred", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "y_true", "=", "self", ".", "multilevelTOsinglelevel", "(", "self", ".", "m_y_true", ")", "\n", "y_pred", "=", "self", ".", "multilevelTOsinglelevel", "(", "self", ".", "classPredictionBinarization", "(", "self", ".", "m_y_pred", ")", ")", "\n", "", "return", "y_true", ",", "y_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.classPredictionBinarization": [[142, 159], ["len", "numpy.where", "numpy.zeros_like", "list", "numpy.asmatrix", "numpy.arange", "p_mxn_array_float.argmax", "len"], "methods", ["None"], ["", "def", "classPredictionBinarization", "(", "self", ",", "p_mxn_array_float", ")", ":", "\n", "        ", "'''\n            Convert real-value (float) matrix of row x col (class) matrix into binary calss data\n            args:\n                param:    p_mxn_array_float    prediction data from tree output\n            \n            return:    n_mxn_array_binary (m x n)    p_mxn_array_binary.shape[0] x p_mxn_array_binary.shape[1] binary data\n        '''", "\n", "if", "len", "(", "list", "(", "p_mxn_array_float", ".", "shape", ")", ")", "==", "1", ":", "\n", "            ", "p_mxn_array_float", "=", "np", ".", "asmatrix", "(", "p_mxn_array_float", ")", ".", "T", "\n", "\n", "", "if", "p_mxn_array_float", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "            ", "n_mxn_array_binary", "=", "np", ".", "where", "(", "p_mxn_array_float", ">", "0.499", ",", "1", ",", "0", ")", "\n", "", "else", ":", "\n", "            ", "n_mxn_array_binary", "=", "np", ".", "zeros_like", "(", "p_mxn_array_float", ")", "\n", "n_mxn_array_binary", "[", "np", ".", "arange", "(", "len", "(", "p_mxn_array_float", ")", ")", ",", "p_mxn_array_float", ".", "argmax", "(", "1", ")", "]", "=", "1", "\n", "", "return", "n_mxn_array_binary", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.multilevelTOsinglelevel": [[161, 180], ["p_mxn_array_binary.flatten", "numpy.arange", "numpy.array", "numpy.multiply", "numpy.sum", "len"], "methods", ["None"], ["", "def", "multilevelTOsinglelevel", "(", "self", ",", "p_mxn_array_binary", ")", ":", "\n", "        ", "'''\n            Transform multilevel to sinbgle level\n            args:\n                param:      p_mxn_array_binary        m x n binarized class multi column callss lebels\n            \n            return: numeric array - number single class labels\n        '''", "\n", "if", "p_mxn_array_binary", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "            ", "return", "p_mxn_array_binary", ".", "flatten", "(", ")", "\n", "", "else", ":", "\n", "# fetch number of columns into m x n p_mxn_array_binary data i.e., value of n ", "\n", "# and create an array of column index", "\n", "            ", "col_index", "=", "np", ".", "arange", "(", "p_mxn_array_binary", ".", "shape", "[", "1", "]", ")", "\n", "# reapate col index for the length (m times) of p_mxn_array_binary data", "\n", "col_index_matrix", "=", "np", ".", "array", "(", "[", "col_index", "]", "*", "len", "(", "p_mxn_array_binary", ")", ")", "\n", "# Multiply to insert right column (numeric class value/lebel) at right place in thge matrix ", "\n", "col_index_matrix", "=", "np", ".", "multiply", "(", "p_mxn_array_binary", ",", "col_index_matrix", ")", "\n", "return", "np", ".", "sum", "(", "col_index_matrix", ",", "axis", "=", "1", ")", "# sum will generate numeric single class labels (index start from zero)", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.assignClassLebel": [[182, 192], ["str", "p_array.tolist", "int"], "methods", ["None"], ["", "", "def", "assignClassLebel", "(", "self", ",", "p_class_names", ",", "p_array", ")", ":", "\n", "        ", "'''\n            Assign class lebels to the class values\n            args:\n                param:      p_class_names        original paramter settings\n                param:      p_array       single collumn numeric level of classes\n            \n            return: labled data with nominal (string attributes) \n        '''", "\n", "return", "[", "str", "(", "p_class_names", "[", "int", "(", "x", ")", "]", ")", "for", "x", "in", "p_array", ".", "tolist", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.plot_confusion_matrix": [[195, 256], ["sklearn.metrics.confusion_matrix", "print", "matplotlib.subplots", "ax.imshow", "ax.figure.colorbar", "ax.set", "matplotlib.setp", "range", "fig.tight_layout", "os.path.join", "matplotlib.savefig", "print", "print", "ax.get_xticklabels", "sklearn.metrics.confusion_matrix.max", "range", "sklearn.metrics.confusion_matrix.astype", "numpy.arange", "numpy.arange", "ax.text", "sklearn.metrics.confusion_matrix.sum", "format"], "methods", ["None"], ["", "def", "plot_confusion_matrix", "(", "self", ",", "y_true", ",", "y_pred", ",", "directory", ",", "trail", ",", "normalize", "=", "False", ",", "\n", "title", "=", "None", ",", "\n", "cmap", "=", "plt", ".", "cm", ".", "Blues", ")", ":", "\n", "\n", "        ", "\"\"\"\n            This function prints and plots the confusion matrix.\n            Normalization can be applied by setting `normalize=True`.\n            https://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html\n            \n            return plot object\n        \"\"\"", "\n", "classes", "=", "self", ".", "m_y_names", "\n", "\n", "if", "not", "title", ":", "\n", "            ", "if", "normalize", ":", "\n", "                ", "title", "=", "'Normalized confusion matrix'", "\n", "", "else", ":", "\n", "                ", "title", "=", "'Confusion matrix, without normalization'", "\n", "\n", "# Compute confusion matrix", "\n", "", "", "cm", "=", "confusion_matrix", "(", "y_true", ",", "y_pred", ")", "\n", "# Only use the labels that appear in the data", "\n", "#classes = classes[unique_labels(y_true, y_pred)]", "\n", "if", "normalize", ":", "\n", "            ", "cm", "=", "cm", ".", "astype", "(", "'float'", ")", "/", "cm", ".", "sum", "(", "axis", "=", "1", ")", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "print", "(", "\"Normalized confusion matrix\"", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'Confusion matrix, without normalization'", ")", "\n", "\n", "", "print", "(", "cm", ")", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "im", "=", "ax", ".", "imshow", "(", "cm", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "cmap", ")", "\n", "ax", ".", "figure", ".", "colorbar", "(", "im", ",", "ax", "=", "ax", ")", "\n", "# We want to show all ticks...", "\n", "ax", ".", "set", "(", "xticks", "=", "np", ".", "arange", "(", "cm", ".", "shape", "[", "1", "]", ")", ",", "\n", "yticks", "=", "np", ".", "arange", "(", "cm", ".", "shape", "[", "0", "]", ")", ",", "\n", "# ... and label them with the respective list entries", "\n", "xticklabels", "=", "classes", ",", "yticklabels", "=", "classes", ",", "\n", "#title=title,", "\n", "ylabel", "=", "'True label'", ",", "\n", "xlabel", "=", "'Predicted label'", ")", "\n", "\n", "# Rotate the tick labels and set their alignment.", "\n", "plt", ".", "setp", "(", "ax", ".", "get_xticklabels", "(", ")", ",", "rotation", "=", "45", ",", "ha", "=", "\"right\"", ",", "\n", "rotation_mode", "=", "\"anchor\"", ")", "\n", "\n", "# Loop over data dimensions and create text annotations.", "\n", "fmt", "=", "'.2f'", "if", "normalize", "else", "'d'", "\n", "thresh", "=", "cm", ".", "max", "(", ")", "/", "2.", "\n", "for", "i", "in", "range", "(", "cm", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "cm", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "ax", ".", "text", "(", "j", ",", "i", ",", "format", "(", "cm", "[", "i", ",", "j", "]", ",", "fmt", ")", ",", "\n", "ha", "=", "\"center\"", ",", "va", "=", "\"center\"", ",", "\n", "color", "=", "\"white\"", "if", "cm", "[", "i", ",", "j", "]", ">", "thresh", "else", "\"black\"", ")", "\n", "", "", "fig", ".", "tight_layout", "(", ")", "\n", "#plt.show()", "\n", "# Save figure", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treeCM_Plot_'", "+", "trail", "+", "'.pdf'", ")", "\n", "plt", ".", "savefig", "(", "graph_filepath", ",", "dpi", "=", "300", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.getConfusionMatrixPlot": [[258, 268], ["perfromance_metrices.Perfromance.classOuputProcessing", "perfromance_metrices.Perfromance.plot_confusion_matrix"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.classOuputProcessing", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.plot_confusion_matrix"], ["", "def", "getConfusionMatrixPlot", "(", "self", ",", "directory", ",", "trail", ",", "p_normalize", "=", "False", ")", ":", "\n", "        ", "'''\n        Print confusion matrix \n        args:\n            param:    y_true    an array of nominal true class values\n            param:    y_pred    an array of nominal predicted class values\n            param:    p_normalize boolean\n        '''", "\n", "y_true", ",", "y_pred", "=", "self", ".", "classOuputProcessing", "(", "True", ")", "\n", "self", ".", "plot_confusion_matrix", "(", "y_true", ",", "y_pred", ",", "directory", ",", "trail", ",", "p_normalize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.getScatterPlot": [[269, 278], ["perfromance_metrices.Perfromance.plot_scatter"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.plot_scatter"], ["", "def", "getScatterPlot", "(", "self", ",", "directory", ",", "trail", ",", "no_line", "=", "False", ")", ":", "\n", "        ", "'''\n        Print confusion matrix \n        args:\n            param:    y_true    an array of nominal true class values\n            param:    y_pred    an array of nominal predicted class values\n            param:    p_normalize boolean\n        '''", "\n", "self", ".", "plot_scatter", "(", "self", ".", "m_y_true", ",", "self", ".", "m_y_pred", ",", "directory", ",", "trail", ",", "no_line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.plot_scatter": [[281, 307], ["matplotlib.subplots", "matplotlib.scatter", "matplotlib.margins", "matplotlib.xlabel", "matplotlib.ylabel", "ax.xaxis.set_major_formatter", "ax.yaxis.set_major_formatter", "matplotlib.tight_layout", "os.path.join", "matplotlib.savefig", "matplotlib.gca", "numpy.polyfit", "numpy.linspace", "matplotlib.plot", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "matplotlib.gca.get_xlim", "matplotlib.gca.get_xlim"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot"], ["", "def", "plot_scatter", "(", "self", ",", "x", ",", "y", ",", "directory", ",", "trail", ",", "without_correlation_line", "=", "False", ")", ":", "\n", "        ", "'''\n        http://stackoverflow.com/a/34571821/395857\n        x does not have to be ordered.\n        '''", "\n", "# Scatter plot", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", ")", "\n", "plt", ".", "scatter", "(", "x", ",", "y", ",", "s", "=", "40", ",", "c", "=", "'r'", ",", "alpha", "=", "0.6", ",", "marker", "=", "'o'", ")", "\n", "plt", ".", "margins", "(", "0", ",", "0", ")", "\n", "if", "not", "without_correlation_line", ":", "\n", "# Add correlation line", "\n", "            ", "axes", "=", "plt", ".", "gca", "(", ")", "\n", "m", ",", "b", "=", "np", ".", "polyfit", "(", "x", ",", "y", ",", "1", ")", "\n", "X_plot", "=", "np", ".", "linspace", "(", "axes", ".", "get_xlim", "(", ")", "[", "0", "]", ",", "axes", ".", "get_xlim", "(", ")", "[", "1", "]", ",", "100", ")", "\n", "plt", ".", "plot", "(", "X_plot", ",", "m", "*", "X_plot", "+", "b", ",", "'-'", ",", "c", "=", "'b'", ")", "\n", "", "plt", ".", "xlabel", "(", "\"Target\"", ")", "\n", "plt", ".", "ylabel", "(", "\"Prediction\"", ")", "\n", "ax", ".", "xaxis", ".", "set_major_formatter", "(", "FormatStrFormatter", "(", "'%.2f'", ")", ")", "\n", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "FormatStrFormatter", "(", "'%.2f'", ")", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "#plt.show()", "\n", "# Save figure", "\n", "graph_filepath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treeReg_Plot_'", "+", "trail", "+", "'.pdf'", ")", "\n", "plt", ".", "savefig", "(", "graph_filepath", ",", "dpi", "=", "300", ",", "format", "=", "'pdf'", ",", "bbox_inches", "=", "'tight'", ")", "\n", "\n", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.__inti__": [[22, 24], ["print"], "methods", ["None"], ["def", "__inti__", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Printing Tree'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.displayTree": [[26, 35], ["json.loads", "anytree.importer.DictImporter", "anytree.importer.DictImporter.import_", "print", "p_tree.print_tree", "anytree.RenderTree"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree"], ["", "def", "displayTree", "(", "self", ",", "p_tree", ")", ":", "\n", "        ", "'''\n            This displays a tree\n        '''", "\n", "# Its dictionary of the tree -  JSON string", "\n", "json_tree", "=", "json", ".", "loads", "(", "p_tree", ".", "print_tree", "(", ")", ")", "\n", "importer", "=", "DictImporter", "(", ")", "\n", "root", "=", "importer", ".", "import_", "(", "json_tree", ")", "\n", "print", "(", "RenderTree", "(", "root", ")", ")", "\n", "#DotExporter(root).to_dotfile('tree.dot')", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.displayTreeFile": [[40, 49], ["display_tree.DisplayTree.readTree", "anytree.importer.DictImporter", "anytree.importer.DictImporter.import_", "print", "anytree.RenderTree"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.readTree"], ["", "def", "displayTreeFile", "(", "self", ",", "json_file", "=", "'model/treeOutline_trial.json'", ")", ":", "\n", "        ", "'''\n            This displays a tree\n        '''", "\n", "# Its dictionary of the tree -  JSON string", "\n", "json_tree", "=", "self", ".", "readTree", "(", "json_file", ")", "\n", "importer", "=", "DictImporter", "(", ")", "\n", "root", "=", "importer", ".", "import_", "(", "json_tree", ")", "\n", "print", "(", "RenderTree", "(", "root", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.retriveTreeFromFile": [[51, 60], ["display_tree.DisplayTree.readTree", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.retrive_JSON_Tree"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.readTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.retrive_JSON_Tree"], ["", "def", "retriveTreeFromFile", "(", "self", ",", "json_file", "=", "'model/treeModel_trial.json'", ")", ":", "\n", "        ", "'''\n            This display a tree\n        '''", "\n", "# Its dictionary of the tree -  JSON string", "\n", "json_tree", "=", "self", ".", "readTree", "(", "json_file", ")", "\n", "n_tree", "=", "NeuralTree", "(", ")", "\n", "n_tree", ".", "retrive_JSON_Tree", "(", "json_tree", ")", "# a funciton in NeuralTree Class", "\n", "return", "n_tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.readTree": [[62, 74], ["print", "open", "json.load"], "methods", ["None"], ["", "def", "readTree", "(", "self", ",", "filename", ")", ":", "\n", "        ", "'''\n            This function saves tree to current directory\n            param:    p_tree        a tree\n            param:    filename      filename string\n\n        '''", "\n", "if", "filename", ":", "\n", "            ", "with", "open", "(", "filename", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "return", "json", ".", "load", "(", "f", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "'Wrong filename string'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.saveTreeOutline": [[76, 91], ["os.path.join", "json.loads", "display_tree.DisplayTree.replaceTreeView", "p_tree.print_tree", "open", "json.dump"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.replaceTreeView", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree"], ["", "", "def", "saveTreeOutline", "(", "self", ",", "p_tree", ",", "directory", "=", "'model'", ",", "uniquefileName", "=", "'trial'", ",", "outlineJson", "=", "True", ")", ":", "\n", "        ", "'''\n            This function saves tree to current directory\n            param:    p_tree    a tree to save\n\n        '''", "\n", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treeOutline_'", "+", "uniquefileName", "+", "'.json'", ")", "\n", "\n", "json_tree", "=", "json", ".", "loads", "(", "p_tree", ".", "print_tree", "(", ")", ")", "\n", "if", "outlineJson", ":", "\n", "            ", "with", "open", "(", "filePath", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "json_tree", ",", "f", ")", "# this can be used for d3js", "\n", "\n", "# creating a tree data for d3js visualization", "\n", "", "", "self", ".", "replaceTreeView", "(", "json_tree", ",", "directory", ",", "uniquefileName", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.replaceTreeView": [[93, 119], ["os.path.join", "os.path.join", "os.path.join", "open", "open", "enumerate", "open.close", "open.close", "os.path.normpath", "json.dumps", "print", "open.write", "open.write"], "methods", ["None"], ["", "def", "replaceTreeView", "(", "self", ",", "json_tree", ",", "directory", "=", "'model'", ",", "uniquefileName", "=", "'trial'", ")", ":", "\n", "        ", "'''\n            creats a tree data for d3js visualization\n            param:\n                json_tree format of a tree to save as html and d3js\n                directory adressss\n        '''", "\n", "oldTreeData", "=", "'var treeData'", "\n", "newTreeData", "=", "'var treeData = ['", "+", "json", ".", "dumps", "(", "json_tree", ")", "+", "'];'", "\n", "\n", "filename_org", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "normpath", "(", "directory", "+", "os", ".", "sep", "+", "os", ".", "pardir", ")", ",", "'view'", ")", "\n", "#filename_org = os.path.join(directory, 'view')", "\n", "filename_org", "=", "os", ".", "path", ".", "join", "(", "filename_org", ",", "'tree_view_org.html'", ")", "\n", "filename_target", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'tree_view_'", "+", "uniquefileName", "+", "'.html'", ")", "\n", "\n", "fin", "=", "open", "(", "filename_org", ",", "\"r\"", ")", "\n", "fout", "=", "open", "(", "filename_target", ",", "\"w\"", ")", "\n", "\n", "for", "num", ",", "line", "in", "enumerate", "(", "fin", ",", "1", ")", ":", "\n", "            ", "if", "oldTreeData", "in", "line", ":", "\n", "                ", "print", "(", "'Model Oultiin Saved - Check replaced HTML line: 41? = line replaced is'", ",", "num", ")", "\n", "fout", ".", "write", "(", "newTreeData", ")", "\n", "", "else", ":", "\n", "                ", "fout", ".", "write", "(", "line", ")", "\n", "", "", "fin", ".", "close", "(", ")", "\n", "fout", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.display_tree.DisplayTree.saveTreeModel": [[121, 133], ["os.path.join", "json.loads", "p_tree.saveTree", "open", "json.dump"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.saveTree"], ["", "def", "saveTreeModel", "(", "self", ",", "p_tree", ",", "directory", "=", "'model'", ",", "uniquefileName", "=", "'trial'", ")", ":", "\n", "        ", "'''\n            This function saves tree to current directory\n            param:\n                p_tree    a tree to save\n                directory adressss\n        '''", "\n", "filePath", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "'treeModel_'", "+", "uniquefileName", "+", "'.json'", ")", "\n", "\n", "json_tree", "=", "json", ".", "loads", "(", "p_tree", ".", "saveTree", "(", ")", ")", "\n", "with", "open", "(", "filePath", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "json_tree", ",", "f", ")", "# this can be used for d3js", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.parameter.parameter_optimization.ParameterOptimization.__init__": [[19, 26], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "'''\n        \n        '''", "\n", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.parameter.parameter_optimization.ParameterOptimization.optimize": [[27, 34], ["src.optimization.parameter.mh.meta_heuristics.Metaheuristics", "src.optimization.parameter.mh.meta_heuristics.Metaheuristics.start"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start"], ["", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "'''\n            use a parametr optimization alogrithm to optimize tree's parameter\n        '''", "\n", "if", "self", ".", "mParams", ".", "n_param_optimizer", "==", "'mh'", ":", "\n", "            ", "mh", "=", "Metaheuristics", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ",", "self", ".", "mTree", ")", "\n", "return", "mh", ".", "start", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs.mcs_opt.TheMCS.__init__": [[23, 32], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "if", "(", "pParams", ".", "n_fun_type", "==", "'Gaussian'", ")", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'all'", "\n", "", "else", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'weights_and_bias'", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs.mcs_opt.TheMCS.optimize": [[34, 82], ["print", "mcs_opt.TheMCS.mEvaluateTree.set_dataset_to_evaluate", "mcs_opt.TheMCS.mTree.getTreeParameters", "print", "mcs_opt.TheMCS.performance_record.append", "len", "stop.append", "numpy.ones", "src.optimization.parameter.mcs.mcs.mcs", "print", "print", "print", "print", "print", "mcs_opt.TheMCS.mTree.setTreeParameters", "len", "src.optimization.parameter.mcs.jones.functions.feval", "mcs_opt.TheMCS.fobj", "mcs_opt.TheMCS.fobj", "pow", "float", "range", "range"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs.mcs.mcs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj"], ["", "", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "'''\n            Run The Multi Coordinate Search algorithm\n            \n        '''", "\n", "print", "(", "'The MCS algorithm:'", ",", "self", ".", "mParams", ".", "n_algo_param", ")", "\n", "self", ".", "mEvaluateTree", ".", "set_dataset_to_evaluate", "(", "'train'", ")", "\n", "\n", "xCurrent", "=", "self", ".", "mTree", ".", "getTreeParameters", "(", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "fcn", "=", "{", "'tree_obj'", ":", "self", ".", "mTree", ",", "\n", "'evaluate_obj'", ":", "self", ".", "mEvaluateTree", ",", "\n", "'max_target_obj'", ":", "self", ".", "mParams", ".", "n_max_target_attr", ",", "\n", "'paramters_obj'", ":", "self", ".", "mParameterToFetch", ",", "\n", "'error_only_obj'", ":", "True", "}", "\n", "\n", "#print('current x:', xCurrent) # too long for large objectives", "\n", "print", "(", "'Best tree parameter length'", ",", "len", "(", "xCurrent", ")", ",", "' to start : '", ",", "feval", "(", "fcn", ",", "xCurrent", ")", ",", "self", ".", "fobj", "(", "xCurrent", ")", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "xCurrent", ",", "False", ")", ")", "\n", "\n", "#setting the mcs parameters", "\n", "min_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "0", "]", "+", "0.1", "\n", "max_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "1", "]", "\n", "n", "=", "len", "(", "xCurrent", ")", "# problem dimension", "\n", "u", "=", "[", "min_x", "for", "indx", "in", "range", "(", "n", ")", "]", "\n", "v", "=", "[", "max_x", "for", "indx", "in", "range", "(", "n", ")", "]", "\n", "\n", "smax", "=", "5", "*", "n", "+", "10", "# number of levels used", "\n", "nf", "=", "50", "*", "pow", "(", "n", ",", "2", ")", "#limit on number of f-calls", "\n", "stop", "=", "[", "3", "*", "n", "]", "# m, integer defining stopping test", "\n", "stop", ".", "append", "(", "float", "(", "\"-inf\"", ")", ")", "# freach, function value to reach", "\n", "\n", "iinit", "=", "1", "# 0: simple initialization list", "\n", "local", "=", "100", "# local = 0: no local search", "\n", "eps", "=", "2.220446049250313e-16", "\n", "gamma", "=", "eps", "# acceptable relative accuracy for local search", "\n", "hess", "=", "np", ".", "ones", "(", "(", "n", ",", "n", ")", ")", "# sparsity pattern of Hessian", "\n", "\n", "#call mcs algorithm", "\n", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ncall", ",", "ncloc", ",", "flag", "=", "mcs", "(", "fcn", ",", "u", ",", "v", ",", "smax", ",", "nf", ",", "stop", ",", "iinit", ",", "local", ",", "gamma", ",", "hess", ")", "\n", "\n", "print", "(", "'The MCS Algorithms Results:'", ")", "\n", "print", "(", "'fglob'", ",", "0.0", ")", "\n", "print", "(", "'fbest'", ",", "fbest", ")", "\n", "print", "(", "'xglob'", ",", "'unknown'", ")", "\n", "print", "(", "'xbest'", ",", "xbest", ")", "\n", "\n", "self", ".", "mTree", ".", "setTreeParameters", "(", "xbest", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "return", "self", ".", "mTree", ",", "self", ".", "performance_record", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs.mcs_opt.TheMCS.fobj": [[83, 85], ["src.optimization.parameter.mh.mh_cost_function.costFunction"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "def", "fobj", "(", "self", ",", "pVector", ",", "only_error", "=", "True", ")", ":", "\n", "        ", "return", "costFunction", "(", "pVector", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ",", "only_error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs.mcs.mcs": [[38, 392], ["src.optimization.parameter.mcs.mcs_fun.chk_bound.check_box_bound", "len", "numpy.multiply().astype", "numpy.multiply().astype", "numpy.any", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.zeros", "numpy.zeros", "numpy.zeros", "src.optimization.parameter.mcs.mcs_fun.initi_func.initbox", "src.optimization.parameter.mcs.mcs_fun.strtsw.strtsw", "sys.exit", "np.zeros.append", "np.zeros.append", "np.zeros.append", "numpy.isinf", "sys.exit", "src.optimization.parameter.mcs.mcs_fun.initi_func.init", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "print", "src.optimization.parameter.mcs.mcs_fun.vertex_func.vertex", "numpy.multiply", "numpy.multiply", "numpy.array", "numpy.zeros", "range", "abs", "abs", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "src.optimization.parameter.mcs.mcs_fun.splrnk.splrnk", "print", "src.optimization.parameter.mcs.mcs_fun.strtsw.strtsw", "numpy.ones", "numpy.ones", "np.zeros.append", "np.zeros.append", "np.zeros.append", "src.optimization.parameter.mcs.mcs_fun.exgain.exgain", "src.optimization.parameter.mcs.mcs_fun.split_func.splinit", "f01.reshape.reshape", "numpy.concatenate", "src.optimization.parameter.mcs.mcs_fun.split_func.split", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "numpy.argsort", "numpy.sort", "range", "copy.deepcopy", "print", "print", "print", "print", "print", "print", "zip", "src.optimization.parameter.mcs.mcs_fun.initi_func.subint", "numpy.array", "min", "min", "len", "len", "xmin.append", "fmi.append", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_locks.chkloc", "src.optimization.parameter.mcs.mcs_fun.initi_func.subint", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_locks.addloc", "src.optimization.parameter.mcs.mcs_fun.basket_func.basket", "src.optimization.parameter.mcs.mcs_fun.initi_func.subint", "src.optimization.parameter.mcs.mcs_fun.initi_func.subint", "zip", "zip", "zip", "src.optimization.parameter.mcs.mcs_fun.lsearch.lsearch", "src.optimization.parameter.mcs.mcs_fun.basket_func.basket1", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_locks.fbestloc", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "len", "xmin.append", "fmi.append", "copy.deepcopy", "copy.deepcopy", "len", "xmin.append", "fmi.append", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_bound.check_box_bound", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.initbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.strtsw.strtsw", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.init", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vertex", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.splrnk.splrnk", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.strtsw.strtsw", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.exgain.exgain", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.splinit", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.subint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_locks.chkloc", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.subint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_locks.addloc", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.basket_func.basket", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.subint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.subint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.lsearch.lsearch", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.basket_func.basket1", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_locks.fbestloc", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr"], ["def", "mcs", "(", "fcn", ",", "u", ",", "v", ",", "smax", ",", "nf", ",", "stop", ",", "iinit", ",", "local", ",", "gamma", ",", "hess", ",", "prt", "=", "1", ")", ":", "\n", "\n", "# global variables", "\n", "#global foptbox nbasket nboxes ncall nglob nsweep nsweepbest optlevel  record xglob xloc", "\n", "# foptbox(1:nglob)  function value(s) of the box(es) containing the (a)", "\n", "#             \tglobal minimizer of a test function", "\n", "# nbasket   \tcounter for boxes in the 'shopping basket'", "\n", "# nboxes      \tcounter for boxes not in the 'shopping basket'", "\n", "# nglob       \tnumber of global minimizers of a test function", "\n", "# nloc\t\t(for local ~= 0) counter of points that have been used", "\n", "# \t\tas starting points for a local search", "\n", "# nsweep      \tsweep counter", "\n", "# nsweepbest    number of sweep in which fbest was updated for the last", "\n", "#\t\ttime", "\n", "# optlevel    \tlevel(s) of the box(es) containing the (a) global", "\n", "#             \tminimum of a test function", "\n", "# record(1:smax-1) record(i) points to the best non-split box at level i", "\n", "#             \t(record list)", "\n", "# xglob(1:n,1:nglob)  xglob(:,i), i=1:nglob, are the global minimizers", "\n", "# of a test function in [u,v]", "\n", "# xloc(1:n,:)\t(for local ~= 0) columns are the points that have been ", "\n", "#\t\tused as starting points for local search", "\n", "\n", "\n", "#%%", "\n", "# check box bounds", "\n", "    ", "if", "check_box_bound", "(", "u", ",", "v", ")", ":", "\n", "        ", "sys", ".", "exit", "(", "'Error MCS main: out of bound'", ")", "\n", "\n", "", "n", "=", "len", "(", "u", ")", "\n", "# initial values for the numbers of function calls (total number/local % search)", "\n", "ncall", "=", "0", "\n", "ncloc", "=", "0", "\n", "\n", "# create indices  ", "\n", "# l indicate the mid point ", "\n", "l", "=", "np", ".", "multiply", "(", "1", ",", "np", ".", "ones", "(", "n", ")", ")", ".", "astype", "(", "int", ")", "# dimension n  i.e, 0 <= i < <n; for range need to add 1 each time", "\n", "# L indicate the end point or (total number of partition of the valie x in the ith dimenstion)", "\n", "# u <= x1 <= xL <= v  in the case of L == 2 (length 3) -> x0 = u (lower bound), x1 = mid point and x2 = v (upper bound)   ", "\n", "L", "=", "np", ".", "multiply", "(", "2", ",", "np", ".", "ones", "(", "n", ")", ")", ".", "astype", "(", "int", ")", "# dimension n  i.e, 0 <= i < <n; for range need to add 1 each time", "\n", "\n", "# definition of the initialization list", "\n", "x0", "=", "[", "]", "\n", "if", "iinit", "==", "0", ":", "\n", "        ", "x0", ".", "append", "(", "u", ")", "#  lower bound point", "\n", "x0", ".", "append", "(", "[", "(", "i", "+", "j", ")", "/", "2", "for", "i", ",", "j", "in", "zip", "(", "u", ",", "v", ")", "]", ")", "#  mid point", "\n", "x0", ".", "append", "(", "v", ")", "# upper bound point", "\n", "x0", "=", "np", ".", "array", "(", "x0", ")", ".", "T", "\n", "", "elif", "iinit", "==", "1", ":", "\n", "        ", "x0", "=", "np", ".", "zeros", "(", "(", "n", ",", "3", ")", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "            ", "if", "u", "[", "i", "]", ">=", "0", ":", "\n", "                ", "x0", "[", "i", ",", "0", "]", "=", "u", "[", "i", "]", "\n", "x0", "[", "i", ",", "1", "]", ",", "x0", "[", "i", ",", "2", "]", "=", "subint", "(", "u", "[", "i", "]", ",", "v", "[", "i", "]", ")", "\n", "x0", "[", "i", ",", "1", "]", "=", "0.5", "*", "(", "x0", "[", "i", ",", "0", "]", "+", "x0", "[", "i", ",", "2", "]", ")", "\n", "", "elif", "v", "[", "i", "]", "<=", "0", ":", "\n", "                ", "x0", "[", "i", ",", "2", "]", "=", "v", "[", "i", "]", "\n", "x0", "[", "i", ",", "1", "]", ",", "x0", "[", "i", ",", "0", "]", "=", "subint", "(", "v", "[", "i", "]", ",", "u", "[", "i", "]", ")", "\n", "x0", "[", "i", ",", "1", "]", "=", "0.5", "*", "(", "x0", "[", "i", ",", "0", "]", "+", "x0", "[", "i", ",", "2", "]", ")", "\n", "", "else", ":", "\n", "                ", "x0", "[", "i", ",", "1", "]", "=", "0", "\n", "_", ",", "x0", "[", "i", ",", "0", "]", ",", "subint", "(", "0", ",", "u", "[", "i", "]", ")", "\n", "_", ",", "x0", "[", "i", ",", "2", "]", ",", "subint", "(", "0", ",", "v", "[", "i", "]", ")", "\n", "", "", "", "elif", "iinit", "==", "2", ":", "\n", "        ", "x0", ".", "append", "(", "[", "(", "i", "*", "5", "+", "j", ")", "/", "6", "for", "i", ",", "j", "in", "zip", "(", "u", ",", "v", ")", "]", ")", "\n", "x0", ".", "append", "(", "[", "0.5", "*", "(", "i", "+", "j", ")", "for", "i", ",", "j", "in", "zip", "(", "u", ",", "v", ")", "]", ")", "\n", "x0", ".", "append", "(", "[", "(", "i", "+", "j", "*", "5", ")", "/", "6", "for", "i", ",", "j", "in", "zip", "(", "u", ",", "v", ")", "]", ")", "\n", "x0", "=", "np", ".", "array", "(", "x0", ")", ".", "T", "\n", "\n", "\n", "# check whether there are infinities in the initialization list", "\n", "", "if", "np", ".", "any", "(", "np", ".", "isinf", "(", "x0", ")", ")", ":", "\n", "        ", "sys", ".", "exit", "(", "'Error- MCS main: infinities in ititialization list'", ")", "\n", "\n", "\n", "# find i*, and f0 that points to x* in the list of intial points in x0", "\n", "", "if", "iinit", "!=", "3", ":", "\n", "        ", "f0", ",", "istar", ",", "ncall1", "=", "init", "(", "fcn", ",", "x0", ",", "l", ",", "L", ",", "n", ")", "\n", "ncall", "=", "ncall", "+", "ncall1", "# increasing number of function call count", "\n", "\n", "#Computing B[x,y] in this case y = v", "\n", "# 1 base vertex", "\n", "# definition of the base vertex of the original box", "\n", "# intial x0 (mid point) is the base of vertex", "\n", "", "x", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "l", "[", "i", "]", "]", "\n", "# 2 oposite vertex - ", "\n", "# definition of the opposite vertex v1 of the original box", "\n", "# selecting one of the corener of the box", "\n", "", "v1", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "abs", "(", "x", "[", "i", "]", "-", "u", "[", "i", "]", ")", ">", "abs", "(", "x", "[", "i", "]", "-", "v", "[", "i", "]", ")", ":", "\n", "#  corener at the lower bound side (left of mid point)", "\n", "            ", "v1", "[", "i", "]", "=", "u", "[", "i", "]", "#  go left", "\n", "", "else", ":", "\n", "# corener of the upper bound side ", "\n", "            ", "v1", "[", "i", "]", "=", "v", "[", "i", "]", "#  go right of mid point", "\n", "\n", "\n", "# some parameters needed for initializing large arrays", "\n", "", "", "step", "=", "1000", "\n", "step1", "=", "10000", "\n", "dim", "=", "step1", "\n", "\n", "# initialization of some large arrays", "\n", "isplit", "=", "np", ".", "zeros", "(", "step1", ")", ".", "astype", "(", "int", ")", "# number indicating ith coardinate split", "\n", "level", "=", "np", ".", "zeros", "(", "step1", ")", ".", "astype", "(", "int", ")", "# number indicating level", "\n", "ipar", "=", "np", ".", "zeros", "(", "step1", ")", ".", "astype", "(", "int", ")", "# number ", "\n", "ichild", "=", "np", ".", "zeros", "(", "step1", ")", ".", "astype", "(", "int", ")", "# number", "\n", "nogain", "=", "np", ".", "zeros", "(", "step1", ")", ".", "astype", "(", "int", ")", "# number", "\n", "\n", "f", "=", "np", ".", "zeros", "(", "(", "2", ",", "step1", ")", ")", "# function value of the splitinhg float value", "\n", "z", "=", "np", ".", "zeros", "(", "(", "2", ",", "step1", ")", ")", "# splitin point float value ", "\n", "\n", "\n", "# initialization of the record list, the counters nboxes, nbasket, m ", "\n", "# and nloc, xloc and the output flag", "\n", "record", "=", "np", ".", "zeros", "(", "smax", ")", "#  global variable record(1:smax-1)", "\n", "nboxes", "=", "0", "#  global variable (we start with 1 box)", "\n", "nbasket", "=", "-", "1", "#  global variable", "\n", "nbasket0", "=", "-", "1", "\n", "nsweepbest", "=", "0", "\n", "nsweep", "=", "0", "#  global variable", "\n", "m", "=", "n", "\n", "record", "[", "0", "]", "=", "1", "#  check 1 of Matlab = 0 of py", "\n", "nloc", "=", "0", "\n", "xloc", "=", "[", "]", "#  global variable", "\n", "flag", "=", "1", "\n", "\n", "\n", "#Initialize the boxes", "\n", "#use of global vaiables global: nboxes nglob xglob", "\n", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "isplit", ",", "p", ",", "xbest", ",", "fbest", ",", "nboxes", "=", "initbox", "(", "x0", ",", "f0", ",", "l", ",", "L", ",", "istar", ",", "u", ",", "v", ",", "isplit", ",", "level", ",", "ipar", ",", "ichild", ",", "f", ",", "nboxes", ",", "prt", ")", "\n", "# generates the boxes in the initialization procedure", "\n", "f0min", "=", "fbest", "\n", "\n", "#print(stop)", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "        ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "        ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "        ", "print", "(", "'glabal minumum as been found :'", ",", "flag", ")", "\n", "#return  xbest,fbest,xmin,fmi,ncall,ncloc,flag", "\n", "# if the (known) minimum function value fglob has been found with the", "\n", "# required tolerance, flag is set to 0 and the program is terminated", "\n", "\n", "# the vector record is updated, and the minimal level s containing non-split boxes is computed", "\n", "", "s", ",", "record", "=", "strtsw", "(", "smax", ",", "level", ",", "f", "[", "0", ",", ":", "]", ",", "nboxes", ",", "record", ")", "\n", "nsweep", "=", "nsweep", "+", "1", ";", "# sweep counter  ", "\n", "\n", "#Check values in MATLAB for these", "\n", "# x0, u, v, l, L, x,v1, f0, istar, f, ipar,level,ichild,f,isplit,p,xbest,fbest,nboxes,nglob,xglob, s,record,nsweep", "\n", "#%%", "\n", "xmin", "=", "[", "]", "\n", "fmi", "=", "[", "]", "\n", "while", "s", "<", "smax", "and", "ncall", "+", "1", "<=", "nf", ":", "\n", "#%%", "\n", "#print('s values',s)", "\n", "        ", "par", "=", "record", "[", "s", "]", "# the best box at level s is the current box", "\n", "# compute the base vertex x, the opposite vertex y, the 'neighboring' ", "\n", "# vertices and their function values needed for quadratic ", "\n", "# interpolation and the vector n0 indicating that the ith coordinate", "\n", "# has been split n0(i) times in the history of the box", "\n", "n0", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "f1", ",", "f2", "=", "vertex", "(", "par", ",", "n", ",", "u", ",", "v", ",", "v1", ",", "x0", ",", "f0", ",", "ipar", ",", "isplit", ",", "ichild", ",", "z", ",", "f", ",", "l", ",", "L", ")", "\n", "\n", "# s 'large'", "\n", "if", "s", ">", "2", "*", "n", "*", "(", "min", "(", "n0", ")", "+", "1", ")", ":", "\n", "# splitting index and splitting value z(2,par) for splitting by", "\n", "# rank are computed", "\n", "# z(2,par) is set to Inf if we split according to the init. list", "\n", "            ", "isplit", "[", "par", "]", ",", "z", "[", "1", ",", "par", "]", "=", "splrnk", "(", "n", ",", "n0", ",", "p", ",", "x", ",", "y", ")", "\n", "splt", "=", "1", "# % indicates that the box is to be split", "\n", "", "else", ":", "\n", "# box has already been marked as not eligible for splitting by expected gain", "\n", "            ", "if", "nogain", "[", "par", "]", ":", "\n", "                ", "splt", "=", "0", "\n", "", "else", ":", "\n", "# splitting by expected gain", "\n", "# compute the expected gain vector e and the potential splitting ", "\n", "# index and splitting value", "\n", "                ", "e", ",", "isplit", "[", "par", "]", ",", "z", "[", "1", ",", "par", "]", "=", "exgain", "(", "n", ",", "n0", ",", "l", ",", "L", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "f", "[", "0", ",", "par", "]", ",", "f0", ",", "f1", ",", "f2", ")", "\n", "fexp", "=", "f", "[", "0", ",", "par", "]", "+", "min", "(", "e", ")", "\n", "if", "fexp", "<", "fbest", ":", "\n", "                    ", "splt", "=", "1", "\n", "", "else", ":", "\n", "                    ", "splt", "=", "0", "# the box is not split since we expect no improvement", "\n", "nogain", "[", "par", "]", "=", "1", "# the box is marked as not eligible for splitting by expected gain", "\n", "#end if nogain", "\n", "#end if s > 2*n*(min(n0)+1)  else        ", "\n", "#print(z[1,par]) # print(f[0,par])", "\n", "#%%", "\n", "", "", "", "if", "splt", "==", "1", ":", "# prepare for splitting", "\n", "            ", "i", "=", "isplit", "[", "par", "]", "#  no deduction beacuse of positive index", "\n", "level", "[", "par", "]", "=", "0", "\n", "#print('check len b:',len(xmin),nbasket,nbasket0)", "\n", "if", "z", "[", "1", ",", "par", "]", "==", "np", ".", "Inf", ":", "# prepare for splitting by initialization list", "\n", "                ", "m", "=", "m", "+", "1", "\n", "z", "[", "1", ",", "par", "]", "=", "m", "\n", "xbest", ",", "fbest", ",", "f01", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "flag", ",", "ncall1", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", "=", "splinit", "(", "fcn", ",", "i", ",", "s", ",", "smax", ",", "par", ",", "x0", ",", "n0", ",", "u", ",", "v", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "L", ",", "l", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "xbest", ",", "fbest", ",", "stop", ",", "prt", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", ")", "\n", "f01", "=", "f01", ".", "reshape", "(", "len", "(", "f01", ")", ",", "1", ")", "\n", "f0", "=", "np", ".", "concatenate", "(", "(", "f0", ",", "f01", ")", ",", "axis", "=", "1", ")", "\n", "ncall", "=", "ncall", "+", "ncall1", "#  print('call spl - 1')", "\n", "", "else", ":", "# prepare for default splitting", "\n", "                ", "z", "[", "0", ",", "par", "]", "=", "x", "[", "i", "]", "\n", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "flag", ",", "ncall1", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", "=", "split", "(", "fcn", ",", "i", ",", "s", ",", "smax", ",", "par", ",", "n0", ",", "u", ",", "v", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "z", "[", ":", ",", "par", "]", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "xbest", ",", "fbest", ",", "stop", ",", "prt", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", ")", "\n", "ncall", "=", "ncall", "+", "ncall1", "# print('call spl - 2')", "\n", "#print('check len a:',len(xmin),nbasket,nbasket0)", "\n", "", "if", "nboxes", ">", "dim", ":", "\n", "                ", "isplit", "=", "np", ".", "concatenate", "(", "(", "isplit", ",", "np", ".", "zeros", "(", "step", ")", ")", ")", "\n", "level", "=", "np", ".", "concatenate", "(", "(", "level", ",", "np", ".", "zeros", "(", "step", ")", ")", ")", "\n", "ipar", "=", "np", ".", "concatenate", "(", "(", "ipar", ",", "np", ".", "zeros", "(", "step", ")", ")", ")", "\n", "ichild", "=", "np", ".", "concatenate", "(", "(", "ichild", ",", "np", ".", "zeros", "(", "step", ")", ")", ")", "\n", "nogain", "=", "np", ".", "concatenate", "(", "(", "nogain", ",", "np", ".", "zeros", "(", "step", ")", ")", ")", "\n", "f", "=", "np", ".", "concatenate", "(", "(", "f", ",", "np", ".", "ones", "(", "(", "2", ",", "step", ")", ")", ")", ",", "axis", "=", "1", ")", "\n", "z", "=", "np", ".", "concatenate", "(", "(", "z", ",", "np", ".", "ones", "(", "(", "2", ",", "step", ")", ")", ")", ",", "axis", "=", "1", ")", "\n", "dim", "=", "nboxes", "+", "step", "\n", "", "if", "not", "flag", ":", "\n", "                ", "break", "\n", "", "", "else", ":", "#% splt=0: no splitting, increase the level by 1        ", "\n", "#%%", "\n", "            ", "if", "s", "+", "1", "<", "smax", ":", "\n", "                ", "level", "[", "par", "]", "=", "s", "+", "1", "\n", "record", "=", "updtrec", "(", "par", ",", "s", "+", "1", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "#  update record", "\n", "", "else", ":", "\n", "                ", "level", "[", "par", "]", "=", "0", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "len", "(", "xmin", ")", "==", "nbasket", ":", "\n", "                    ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "#xmin[:,nbasket] = x", "\n", "fmi", ".", "append", "(", "f", "[", "0", ",", "par", "]", ")", "\n", "", "else", ":", "\n", "                    ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f", "[", "0", ",", "par", "]", "\n", "#print('Level:',level)  #print('Record:',record)", "\n", "#%%", "\n", "#update s to split boxes", "\n", "", "", "", "s", "=", "s", "+", "1", "\n", "while", "s", "<", "smax", ":", "\n", "            ", "if", "record", "[", "s", "]", "==", "0", ":", "\n", "                ", "s", "=", "s", "+", "1", "\n", "", "else", ":", "\n", "                ", "break", "\n", "#%%", "\n", "# if smax is reached, a new sweep is started ", "\n", "", "", "if", "s", "==", "smax", ":", "\n", "            ", "print", "(", "s", ")", "\n", "if", "local", ":", "\n", "#print(fmi, xmin,nbasket0,nbasket)", "\n", "                ", "fmiTemp", "=", "fmi", "[", "nbasket0", "+", "1", ":", "nbasket", "+", "1", "]", "\n", "xminTemp", "=", "xmin", "[", "nbasket0", "+", "1", ":", "nbasket", "+", "1", "]", "\n", "j", "=", "np", ".", "argsort", "(", "fmiTemp", ")", "\n", "fmiTemp", "=", "np", ".", "sort", "(", "fmiTemp", ")", "\n", "xminTemp", "=", "[", "copy", ".", "deepcopy", "(", "xminTemp", "[", "jInd", "]", ")", "for", "jInd", "in", "j", "]", "\n", "fmi", "[", "nbasket0", "+", "1", ":", "nbasket", "+", "1", "]", "=", "fmiTemp", "\n", "xmin", "[", "nbasket0", "+", "1", ":", "nbasket", "+", "1", "]", "=", "xminTemp", "\n", "#print('j, fmi, xmin:',j, fmi, xmin,nbasket0,nbasket, len(xmin))", "\n", "\n", "for", "j", "in", "range", "(", "nbasket0", "+", "1", ",", "nbasket", "+", "1", ")", ":", "\n", "                    ", "x", "=", "copy", ".", "deepcopy", "(", "xmin", "[", "j", "]", ")", "\n", "f1", "=", "copy", ".", "deepcopy", "(", "fmi", "[", "j", "]", ")", "\n", "loc", "=", "chkloc", "(", "nloc", ",", "xloc", ",", "x", ")", "\n", "#print('check lock:',j,x,f1,nloc, xloc,loc)", "\n", "if", "loc", ":", "\n", "#print('chaking basket ',nbasket0)", "\n", "                        ", "nloc", ",", "xloc", "=", "addloc", "(", "nloc", ",", "xloc", ",", "x", ")", "\n", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "x", ",", "f1", ",", "loc", ",", "flag", ",", "ncall1", ",", "nsweep", ",", "nsweepbest", "=", "basket", "(", "fcn", ",", "x", ",", "f1", ",", "xmin", ",", "fmi", ",", "xbest", ",", "fbest", ",", "stop", ",", "nbasket0", ",", "nsweep", ",", "nsweepbest", ")", "\n", "#print(xbest,fbest,xmin,fmi,loc,flag,ncall1)", "\n", "ncall", "=", "ncall", "+", "ncall1", "\n", "if", "not", "flag", ":", "\n", "                            ", "break", "\n", "", "if", "loc", ":", "\n", "                            ", "xmin1", ",", "fmi1", ",", "nc", ",", "flag", ",", "nsweep", ",", "nsweepbest", "=", "lsearch", "(", "fcn", ",", "x", ",", "f1", ",", "f0min", ",", "u", ",", "v", ",", "nf", "-", "ncall", ",", "stop", ",", "local", ",", "gamma", ",", "hess", ",", "nsweep", ",", "nsweepbest", ")", "\n", "ncall", "=", "ncall", "+", "nc", "\n", "ncloc", "=", "ncloc", "+", "nc", "\n", "if", "fmi1", "<", "fbest", ":", "\n", "                                ", "xbest", "=", "copy", ".", "deepcopy", "(", "xmin1", ")", "\n", "fbest", "=", "copy", ".", "deepcopy", "(", "fmi1", ")", "\n", "nsweepbest", "=", "nsweep", "\n", "if", "not", "flag", ":", "\n", "                                    ", "nbasket0", "=", "nbasket0", "+", "1", "\n", "nbasket", "=", "copy", ".", "deepcopy", "(", "nbasket0", ")", "\n", "if", "len", "(", "xmin", ")", "==", "nbasket", ":", "\n", "                                        ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "xmin1", ")", ")", "\n", "fmi", ".", "append", "(", "copy", ".", "deepcopy", "(", "fmi1", ")", ")", "\n", "", "else", ":", "\n", "                                        ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "xmin1", ")", "\n", "fmi", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "fmi1", ")", "\n", "", "break", "\n", "\n", "", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                                    ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                                    ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                                    ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ncall", ",", "ncloc", ",", "flag", "\n", "#end if ", "\n", "#end if fmi1", "\n", "#print('chaking basket 1',nbasket0)", "\n", "", "", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "loc", ",", "flag", ",", "ncall1", ",", "nsweep", ",", "nsweepbest", "=", "basket1", "(", "fcn", ",", "xmin1", ",", "fmi1", ",", "xmin", ",", "fmi", ",", "xbest", ",", "fbest", ",", "stop", ",", "nbasket0", ",", "nsweep", ",", "nsweepbest", ")", "\n", "ncall", "=", "ncall", "+", "ncall1", "\n", "#print(xbest,fbest,xmin,fmi,loc,flag,ncall1)", "\n", "if", "not", "flag", ":", "\n", "                                ", "break", "\n", "", "if", "loc", ":", "\n", "#print('check1:',nbasket0, nbasket,xmin,fmi)", "\n", "                                ", "nbasket0", "=", "nbasket0", "+", "1", "\n", "if", "len", "(", "xmin", ")", "==", "nbasket0", ":", "\n", "                                    ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "xmin1", ")", ")", "\n", "fmi", ".", "append", "(", "copy", ".", "deepcopy", "(", "fmi1", ")", ")", "\n", "", "else", ":", "\n", "                                    ", "xmin", "[", "nbasket0", "]", "=", "copy", ".", "deepcopy", "(", "xmin1", ")", "\n", "fmi", "[", "nbasket0", "]", "=", "copy", ".", "deepcopy", "(", "fmi1", ")", "\n", "#print('check2:',nbasket0, nbasket,xmin,fmi)", "\n", "", "fbest", ",", "xbest", "=", "fbestloc", "(", "fmi", ",", "fbest", ",", "xmin", ",", "xbest", ",", "nbasket0", ",", "stop", ")", "\n", "if", "not", "flag", ":", "\n", "                                    ", "nbasket", "=", "nbasket0", "\n", "break", "\n", "#end for  basket                  ", "\n", "", "", "", "", "", "nbasket", "=", "copy", ".", "deepcopy", "(", "nbasket0", ")", "\n", "if", "not", "flag", ":", "\n", "                    ", "break", "\n", "#end local", "\n", "", "", "s", ",", "record", "=", "strtsw", "(", "smax", ",", "level", ",", "f", "[", "0", ",", ":", "]", ",", "nboxes", ",", "record", ")", "\n", "if", "prt", ":", "\n", "#if nsweep == 1:", "\n", "#    print(', =)", "\n", "#print('nsw   minl   nf     fbest        xbest\\n')", "\n", "\n", "                ", "minlevel", "=", "s", "\n", "print", "(", "'nsweep:'", ",", "nsweep", ")", "\n", "print", "(", "'minlevel:'", ",", "minlevel", ")", "\n", "print", "(", "'ncall:'", ",", "ncall", ")", "\n", "print", "(", "'fbest:'", ",", "fbest", ")", "\n", "print", "(", "'xbest: '", ",", "xbest", ")", "\n", "print", "(", "'\\n'", ")", "\n", "\n", "", "if", "stop", "[", "0", "]", ">", "1", ":", "\n", "                ", "if", "nsweep", "-", "nsweepbest", ">=", "stop", "[", "0", "]", ":", "\n", "                    ", "flag", "=", "3", "\n", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ncall", ",", "ncloc", ",", "flag", "\n", "", "", "nsweep", "=", "nsweep", "+", "1", "\n", "#end if  s ==  max", "\n", "#end while", "\n", "", "", "if", "ncall", ">=", "nf", ":", "\n", "        ", "flag", "=", "2", "\n", "\n", "#    if local:", "\n", "#        print(len(fmi),nbasket)", "\n", "#        if len(fmi) > nbasket:", "\n", "#            for inx in range(nbasket+1,len(fmi)):", "\n", "#                del xmin[inx]", "\n", "#                del fmi[inx]", "\n", "", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ncall", ",", "ncloc", ",", "flag", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.defaults": [[8, 33], ["defaults.gpr", "defaults.bra", "defaults.cam", "defaults.sh5", "defaults.sh7", "defaults.s10", "defaults.hm3", "defaults.hm6", "sys.exit"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.gpr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.bra", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.cam", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.sh5", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.sh7", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.s10", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.hm3", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.hm6"], ["def", "defaults", "(", "name", ")", ":", "\n", "    ", "'''\n    retun defualty values of the functions\n    args:\n        name: function names\n    return functon default values\n    '''", "\n", "if", "name", "==", "'gpr'", ":", "\n", "        ", "return", "gpr", "(", ")", "\n", "", "elif", "name", "==", "'bra'", ":", "\n", "        ", "return", "bra", "(", ")", "\n", "", "elif", "name", "==", "'cam'", ":", "\n", "        ", "return", "cam", "(", ")", "\n", "", "elif", "name", "==", "'sh5'", ":", "\n", "        ", "return", "sh5", "(", ")", "\n", "", "elif", "name", "==", "'sh7'", ":", "\n", "        ", "return", "sh7", "(", ")", "\n", "", "elif", "name", "==", "'s10'", ":", "\n", "        ", "return", "s10", "(", ")", "\n", "", "elif", "name", "==", "'hm3'", ":", "\n", "        ", "return", "hm3", "(", ")", "\n", "", "elif", "name", "==", "'hm6'", ":", "\n", "        ", "return", "hm6", "(", ")", "\n", "", "else", ":", "\n", "        ", "sys", ".", "exit", "(", "'Default: no function available with this name'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.gpr": [[34, 44], ["None"], "function", ["None"], ["", "", "def", "gpr", "(", ")", ":", "\n", "    ", "'''\n        # Goldstein-Price function\n    '''", "\n", "u", "=", "[", "-", "2", ",", "-", "2", "]", "\n", "v", "=", "[", "2", ",", "2", "]", "\n", "nglob", "=", "1", "\n", "fglob", "=", "3", "\n", "xglob", "=", "[", "0", ",", "-", "1.0", "]", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.bra": [[45, 55], ["None"], "function", ["None"], ["", "def", "bra", "(", ")", ":", "\n", "    ", "'''\n        # Branin's function\n    '''", "\n", "u", "=", "[", "-", "5", ",", "0", "]", "\n", "v", "=", "[", "10", ",", "15", "]", "\n", "nglob", "=", "3", "\n", "fglob", "=", "0.397887357729739", "\n", "xglob", "=", "[", "[", "9.42477796", ",", "2.47499998", "]", ",", "[", "-", "3.14159265", ",", "12.27500000", "]", ",", "[", "3.14159265", ",", "2.27500000", "]", "]", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.cam": [[56, 66], ["None"], "function", ["None"], ["", "def", "cam", "(", ")", ":", "\n", "    ", "'''\n        # six camel hump \n    '''", "\n", "u", "=", "[", "-", "3", ",", "-", "2", "]", "# lower bound", "\n", "v", "=", "[", "3", ",", "2", "]", "# upper bound", "\n", "nglob", "=", "2", "\n", "fglob", "=", "-", "1.0316284535", "\n", "xglob", "=", "[", "[", "0.08984201", ",", "-", "0.71265640", "]", ",", "[", "0.71265640", ",", "-", "0.08984201", "]", "]", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.sh5": [[68, 78], ["None"], "function", ["None"], ["", "def", "sh5", "(", ")", ":", "\n", "    ", "'''  \n        # Shekel 5\n    '''", "\n", "u", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "v", "=", "[", "10", ",", "10", ",", "10", ",", "10", "]", "\n", "fglob", "=", "-", "10.1531996790582", "\n", "xglob", "=", "[", "4", ",", "4", ",", "4", ",", "4", "]", "\n", "nglob", "=", "1", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.sh7": [[79, 89], ["None"], "function", ["None"], ["", "def", "sh7", "(", ")", ":", "\n", "    ", "'''\n        # Shekel 7\n    '''", "\n", "u", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "v", "=", "[", "10", ",", "10", ",", "10", ",", "10", "]", "\n", "fglob", "=", "-", "10.4029405668187", "\n", "xglob", "=", "[", "4", ",", "4", ",", "4", ",", "4", "]", "\n", "nglob", "=", "1", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.s10": [[90, 100], ["None"], "function", ["None"], ["", "def", "s10", "(", ")", ":", "\n", "    ", "'''  \n        # Shekel 10\n    '''", "\n", "u", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "v", "=", "[", "10", ",", "10", ",", "10", ",", "10", "]", "\n", "fglob", "=", "-", "10.5364098166920", "\n", "xglob", "=", "[", "4", ",", "4", ",", "4", ",", "4", "]", "\n", "nglob", "=", "1", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.hm3": [[101, 111], ["None"], "function", ["None"], ["", "def", "hm3", "(", ")", ":", "\n", "    ", "'''\n        # Hartman 3\n    '''", "\n", "u", "=", "[", "0", ",", "0", ",", "0", "]", "\n", "v", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "fglob", "=", "-", "3.86278214782076", "\n", "xglob", "=", "[", "0.1", ",", "0.55592003", ",", "0.85218259", "]", "\n", "nglob", "=", "1", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.defaults.hm6": [[112, 122], ["None"], "function", ["None"], ["", "def", "hm6", "(", ")", ":", "\n", "    ", "'''\n        # Hartman 6\n    '''", "\n", "u", "=", "[", "0", ",", "0", ",", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "v", "=", "[", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "]", "\n", "fglob", "=", "-", "3.32236801141551", "\n", "xglob", "=", "[", "0.20168952", ",", "0.15001069", ",", "0.47687398", ",", "0.27533243", ",", "0.31165162", ",", "0.65730054", "]", "\n", "nglob", "=", "1", "\n", "return", "u", ",", "v", ",", "nglob", ",", "fglob", ",", "xglob", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval": [[10, 43], ["functions.costFunction", "functions.glstest", "functions.bra", "functions.cam", "functions.gpr", "functions.sh5", "functions.sh7", "functions.s10", "functions.hm3", "functions.hm6", "print"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.glstest", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.bra", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.cam", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.gpr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.sh5", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.sh7", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.s10", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.hm3", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.hm6"], ["def", "feval", "(", "fcn", ",", "x", ",", "isTree", "=", "True", ")", ":", "\n", "    ", "'''\n        Function definations\n    '''", "\n", "if", "isTree", ":", "\n", "        ", "pParameter", "=", "x", "\n", "pTree", "=", "fcn", "[", "'tree_obj'", "]", "\n", "pData", "=", "fcn", "[", "'evaluate_obj'", "]", "\n", "p_max_target_attr", "=", "fcn", "[", "'max_target_obj'", "]", "\n", "p_eval_parama", "=", "fcn", "[", "'paramters_obj'", "]", "\n", "p_only_error", "=", "fcn", "[", "'error_only_obj'", "]", "\n", "return", "costFunction", "(", "pParameter", ",", "pTree", ",", "pData", ",", "p_max_target_attr", ",", "p_eval_parama", ",", "p_only_error", ")", "\n", "", "else", ":", "\n", "        ", "if", "fcn", "==", "'glstest'", ":", "\n", "            ", "return", "glstest", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'bra'", ":", "\n", "            ", "return", "bra", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'cam'", ":", "\n", "            ", "return", "cam", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'gpr'", ":", "\n", "            ", "return", "gpr", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'sh5'", ":", "\n", "            ", "return", "sh5", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'sh7'", ":", "\n", "            ", "return", "sh7", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'s10'", ":", "\n", "            ", "return", "s10", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'hm3'", ":", "\n", "            ", "return", "hm3", "(", "x", ")", "\n", "", "elif", "fcn", "==", "'hm6'", ":", "\n", "            ", "return", "hm6", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'no funciton with such name implemented'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.costFunction": [[45, 65], ["pTree.setTreeParameters", "pData.getTreePredictedOutputs", "pTree.setTreeParameters", "pData.getTreePredictedOutputs", "pData.getTreeFitness", "pData.getTreeFitness", "pTree.getTreeSize"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "", "", "def", "costFunction", "(", "pParameter", ",", "pTree", ",", "pData", ",", "p_max_target_attr", ",", "eval_parama", "=", "'all'", ",", "only_error", "=", "True", ")", ":", "\n", "    ", "'''\n    computes parameter fitness.\n    args:\n        pParameter:         paramter vector to be set as tree parameter\n        pTree:              tree to be evaluated\n        pData:              training/test data to be evalauated\n        p_max_target_attr:  max number of target attribute to examine number of child of tree trrot\n        eval_parama:        'all' , 'weights' 'weights_and_bias' 'bias' \n    \n    return: (float) error induced on pTree \n    '''", "\n", "if", "only_error", ":", "\n", "        ", "pTree", ".", "setTreeParameters", "(", "pParameter", ",", "p_max_target_attr", ",", "eval_parama", ")", "\n", "_", "=", "pData", ".", "getTreePredictedOutputs", "(", "pTree", ")", "\n", "return", "pData", ".", "getTreeFitness", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "pTree", ".", "setTreeParameters", "(", "pParameter", ",", "p_max_target_attr", ",", "eval_parama", ")", "\n", "_", "=", "pData", ".", "getTreePredictedOutputs", "(", "pTree", ")", "\n", "return", "pData", ".", "getTreeFitness", "(", ")", "+", "[", "pTree", ".", "getTreeSize", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.glstest": [[68, 79], ["numpy.asscalar", "pow", "pow", "math.sin"], "function", ["None"], ["", "", "def", "glstest", "(", "x", ")", ":", "\n", "    ", "cas", "=", "3", "\n", "if", "cas", "==", "1", ":", "\n", "        ", "f", "=", "(", "(", "(", "3", "*", "x", "-", "1", ")", "*", "x", "-", "2", ")", "*", "x", "-", "1", ")", "\n", "", "elif", "cas", "==", "2", ":", "\n", "        ", "f", "=", "pow", "(", "(", "3", "*", "x", "-", "1", ")", ",", "3", ")", "\n", "", "elif", "cas", "==", "3", ":", "\n", "        ", "f", "=", "pow", "(", "(", "3", "*", "x", "-", "1", ")", ",", "2", ")", "\n", "", "elif", "cas", "==", "4", ":", "\n", "        ", "f", "=", "(", "x", "+", "1", ")", "*", "math", ".", "sin", "(", "10", "*", "x", "+", "1", ")", "\n", "", "return", "np", ".", "asscalar", "(", "f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.bra": [[82, 100], ["len", "print", "sys.exit", "pow", "math.cos", "pow"], "function", ["None"], ["", "def", "bra", "(", "x", ")", ":", "\n", "    ", "'''\n        Branin's function\n    '''", "\n", "a", "=", "1", "\n", "b", "=", "5.1", "/", "(", "4", "*", "math", ".", "pi", "*", "math", ".", "pi", ")", "\n", "c", "=", "5", "/", "math", ".", "pi", "\n", "d", "=", "6", "\n", "h", "=", "10", "\n", "ff", "=", "1", "/", "(", "8", "*", "math", ".", "pi", ")", "\n", "if", "len", "(", "x", ")", "!=", "2", ":", "\n", "        ", "print", "(", "'bar function takes only a vector length 2'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "x1", "=", "x", "[", "0", "]", "\n", "x2", "=", "x", "[", "1", "]", "\n", "f", "=", "a", "*", "pow", "(", "(", "x2", "-", "b", "*", "pow", "(", "x1", ",", "2", ")", "+", "c", "*", "x1", "-", "d", ")", ",", "2", ")", "+", "h", "*", "(", "1", "-", "ff", ")", "*", "math", ".", "cos", "(", "x1", ")", "+", "h", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.cam": [[102, 118], ["len", "print", "sys.exit", "pow", "pow", "pow", "pow", "pow"], "function", ["None"], ["", "def", "cam", "(", "x", ")", ":", "\n", "    ", "'''\n    six-hump camel function - dimension n = 2\n    arg:\n        x =  vector do dimention 2\n    '''", "\n", "#print('cam was called')", "\n", "# x is the vector of length 2", "\n", "if", "len", "(", "x", ")", "!=", "2", ":", "\n", "        ", "print", "(", "'cam function takes only a vector length 2'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "x1", "=", "x", "[", "0", "]", "\n", "x2", "=", "x", "[", "1", "]", "\n", "f", "=", "(", "4", "-", "2.1", "*", "pow", "(", "x1", ",", "2", ")", "+", "pow", "(", "x1", ",", "4", ")", "/", "3", ")", "*", "pow", "(", "x1", ",", "2", ")", "+", "x1", "*", "x2", "+", "(", "-", "4", "+", "4", "*", "pow", "(", "x2", ",", "2", ")", ")", "*", "pow", "(", "x2", ",", "2", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.gpr": [[120, 132], ["len", "print", "sys.exit", "pow", "pow", "pow", "pow", "pow", "pow"], "function", ["None"], ["", "def", "gpr", "(", "x", ")", ":", "\n", "    ", "'''\n    # Goldstein-Price function\n    '''", "\n", "if", "len", "(", "x", ")", "!=", "2", ":", "\n", "        ", "print", "(", "'Goldstein function takes only a vector length 2'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "x1", "=", "x", "[", "0", "]", "\n", "x2", "=", "x", "[", "1", "]", "\n", "f", "=", "(", "1", "+", "pow", "(", "(", "x1", "+", "x2", "+", "1", ")", ",", "2", ")", "*", "(", "19", "-", "14", "*", "x1", "+", "3", "*", "pow", "(", "x1", ",", "2", ")", "-", "14", "*", "x2", "+", "6", "*", "x1", "*", "x2", "+", "3", "*", "pow", "(", "x2", ",", "2", ")", ")", ")", "*", "(", "30", "+", "pow", "(", "(", "2", "*", "x1", "-", "3", "*", "x2", ")", ",", "2", ")", "*", "(", "18", "-", "32", "*", "x1", "+", "12", "*", "pow", "(", "x1", ",", "2", ")", "+", "48", "*", "x2", "-", "36", "*", "x1", "*", "x2", "+", "27", "*", "pow", "(", "x2", ",", "2", ")", ")", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.sh5": [[134, 155], ["numpy.asarray", "numpy.asarray", "numpy.zeros", "range", "len", "print", "sys.exit", "sum", "sum"], "function", ["None"], ["", "def", "sh5", "(", "x", ")", ":", "\n", "    ", "'''\n        # Shekel5 function\n    '''", "\n", "if", "len", "(", "x", ")", "!=", "4", ":", "\n", "        ", "print", "(", "'Shekel5 function takes only a vector length 4'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "[", "[", "4.0", ",", "1.0", ",", "8.0", ",", "6.0", ",", "3.0", "]", ",", "\n", "[", "4.0", ",", "1.0", ",", "8.0", ",", "6.0", ",", "7.0", "]", ",", "\n", "[", "4.0", ",", "1.0", ",", "8.0", ",", "6.0", ",", "3.0", "]", ",", "\n", "[", "4.0", ",", "1.0", ",", "8.0", ",", "6.0", ",", "7.0", "]", "]", ")", "\n", "\n", "c", "=", "np", ".", "asarray", "(", "[", "0.1", ",", "0.2", ",", "0.2", ",", "0.4", ",", "0.4", "]", ")", "\n", "\n", "d", "=", "np", ".", "zeros", "(", "5", ")", "\n", "for", "i", "in", "range", "(", "5", ")", ":", "\n", "        ", "b", "=", "(", "x", "-", "a", "[", ":", ",", "i", "]", ")", "**", "2", "\n", "d", "[", "i", "]", "=", "sum", "(", "b", ")", "\n", "", "f", "=", "-", "sum", "(", "(", "c", "+", "d", ")", "**", "(", "-", "1", ")", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.sh7": [[157, 178], ["numpy.asarray", "numpy.asarray", "numpy.zeros", "range", "len", "print", "sys.exit", "sum", "sum"], "function", ["None"], ["", "def", "sh7", "(", "x", ")", ":", "\n", "    ", "'''\n    # Shekel7 function\n    '''", "\n", "if", "len", "(", "x", ")", "!=", "4", ":", "\n", "        ", "print", "(", "'Shekel7 function takes only a vector length 4'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "[", "[", "4", ",", "1", ",", "8", ",", "6", ",", "3", ",", "2", ",", "5", "]", ",", "\n", "[", "4", ",", "1", ",", "8", ",", "6", ",", "7", ",", "9", ",", "5", "]", ",", "\n", "[", "4", ",", "1", ",", "8", ",", "6", ",", "3", ",", "2", ",", "3", "]", ",", "\n", "[", "4", ",", "1", ",", "8", ",", "6", ",", "7", ",", "9", ",", "3", "]", "]", ")", "\n", "\n", "c", "=", "np", ".", "asarray", "(", "[", "0.1", ",", "0.2", ",", "0.2", ",", "0.4", ",", "0.4", ",", "0.6", ",", "0.3", "]", ")", "\n", "\n", "d", "=", "np", ".", "zeros", "(", "7", ")", "\n", "for", "i", "in", "range", "(", "7", ")", ":", "\n", "        ", "b", "=", "(", "x", "-", "a", "[", ":", ",", "i", "]", ")", "**", "2", "\n", "d", "[", "i", "]", "=", "sum", "(", "b", ")", "\n", "", "f", "=", "-", "sum", "(", "(", "c", "+", "d", ")", "**", "(", "-", "1", ")", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.s10": [[181, 202], ["numpy.asarray", "numpy.asarray", "numpy.zeros", "range", "len", "print", "sys.exit", "sum", "sum"], "function", ["None"], ["", "def", "s10", "(", "x", ")", ":", "\n", "    ", "'''\n    # Shekel10 function\n    '''", "\n", "if", "len", "(", "x", ")", "!=", "4", ":", "\n", "        ", "print", "(", "'Shekel10 function takes only a vector length 4'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "[", "[", "4", ",", "1", ",", "8", ",", "6", ",", "3", ",", "2", ",", "5", ",", "8", ",", "6", ",", "7", "]", ",", "\n", "[", "4", ",", "1", ",", "8", ",", "6", ",", "7", ",", "9", ",", "5", ",", "1", ",", "2", ",", "3.6", "]", ",", "\n", "[", "4", ",", "1", ",", "8", ",", "6", ",", "3", ",", "2", ",", "3", ",", "8", ",", "6", ",", "7", "]", ",", "\n", "[", "4", ",", "1", ",", "8", ",", "6", ",", "7", ",", "9", ",", "3", ",", "1", ",", "2", ",", "3.6", "]", "]", ")", "\n", "\n", "c", "=", "np", ".", "asarray", "(", "[", "0.1", ",", "0.2", ",", "0.2", ",", "0.4", ",", "0.4", ",", "0.6", ",", "0.3", ",", "0.7", ",", "0.5", ",", "0.5", "]", ")", "\n", "\n", "d", "=", "np", ".", "zeros", "(", "10", ")", "\n", "for", "i", "in", "range", "(", "10", ")", ":", "\n", "        ", "b", "=", "(", "x", "-", "a", "[", ":", ",", "i", "]", ")", "**", "2", "\n", "d", "[", "i", "]", "=", "sum", "(", "b", ")", "\n", "", "f", "=", "-", "sum", "(", "(", "c", "+", "d", ")", "**", "(", "-", "1", ")", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.hm3": [[204, 227], ["numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.zeros", "range", "len", "print", "sys.exit", "sum", "sum", "numpy.power", "numpy.exp"], "function", ["None"], ["", "def", "hm3", "(", "x", ")", ":", "\n", "    ", "'''\n        # Hartman3 function\n    '''", "\n", "if", "len", "(", "x", ")", "!=", "3", ":", "\n", "        ", "print", "(", "'Hartman3 function takes only a vector length 3'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "[", "[", "3.0", ",", "0.1", ",", "3.0", ",", "0.1", "]", ",", "\n", "[", "10.0", ",", "10.0", ",", "10.0", ",", "10.0", "]", ",", "\n", "[", "30.0", ",", "35.0", ",", "30.0", ",", "35.0", "]", "]", ")", "\n", "\n", "p", "=", "np", ".", "asarray", "(", "[", "[", "0.36890", ",", "0.46990", ",", "0.10910", ",", "0.03815", "]", ",", "\n", "[", "0.11700", ",", "0.43870", ",", "0.87320", ",", "0.57430", "]", ",", "\n", "[", "0.26730", ",", "0.74700", ",", "0.55470", ",", "0.88280", "]", "]", ")", "\n", "\n", "c", "=", "np", ".", "asarray", "(", "[", "1.0", ",", "1.2", ",", "3.0", ",", "3.2", "]", ")", "\n", "\n", "d", "=", "np", ".", "zeros", "(", "4", ")", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "d", "[", "i", "]", "=", "sum", "(", "a", "[", ":", ",", "i", "]", "*", "np", ".", "power", "(", "(", "x", "-", "p", "[", ":", ",", "i", "]", ")", ",", "2", ")", ")", "\n", "", "f", "=", "-", "sum", "(", "c", "*", "np", ".", "exp", "(", "-", "d", ")", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.hm6": [[229, 258], ["numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.zeros", "range", "len", "print", "sys.exit", "sum", "sum", "numpy.power", "numpy.exp"], "function", ["None"], ["", "def", "hm6", "(", "x", ")", ":", "\n", "    ", "'''\n    # Hartman6 function\n    '''", "\n", "if", "len", "(", "x", ")", "!=", "6", ":", "\n", "        ", "print", "(", "'Hartman6 function takes only a vector length 6'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n", "", "a", "=", "np", ".", "asarray", "(", "[", "[", "10.00", ",", "0.05", ",", "3.00", ",", "17.00", "]", ",", "\n", "[", "3.00", ",", "10.00", ",", "3.50", ",", "8.00", "]", ",", "\n", "[", "17.00", ",", "17.00", ",", "1.70", ",", "0.05", "]", ",", "\n", "[", "3.50", ",", "0.10", ",", "10.00", ",", "10.00", "]", ",", "\n", "[", "1.70", ",", "8.00", ",", "17.00", ",", "0.10", "]", ",", "\n", "[", "8.00", ",", "14.00", ",", "8.00", ",", "14.00", "]", "]", ")", "\n", "\n", "p", "=", "np", ".", "asarray", "(", "[", "[", "0.1312", ",", "0.2329", ",", "0.2348", ",", "0.4047", "]", ",", "\n", "[", "0.1696", ",", "0.4135", ",", "0.1451", ",", "0.8828", "]", ",", "\n", "[", "0.5569", ",", "0.8307", ",", "0.3522", ",", "0.8732", "]", ",", "\n", "[", "0.0124", ",", "0.3736", ",", "0.2883", ",", "0.5743", "]", ",", "\n", "[", "0.8283", ",", "0.1004", ",", "0.3047", ",", "0.1091", "]", ",", "\n", "[", "0.5886", ",", "0.9991", ",", "0.6650", ",", "0.0381", "]", "]", ")", "\n", "\n", "c", "=", "np", ".", "asarray", "(", "[", "1.0", ",", "1.2", ",", "3.0", ",", "3.2", "]", ")", "\n", "\n", "d", "=", "np", ".", "zeros", "(", "4", ")", "\n", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "        ", "d", "[", "i", "]", "=", "sum", "(", "a", "[", ":", ",", "i", "]", "*", "np", ".", "power", "(", "(", "x", "-", "p", "[", ":", ",", "i", "]", ")", ",", "2", ")", ")", "\n", "", "f", "=", "-", "sum", "(", "c", "*", "np", ".", "exp", "(", "-", "d", ")", ")", "\n", "return", "f", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.gls.gls": [[23, 144], ["numpy.isscalar", "len", "src.optimization.parameter.mcs.gls.lsrange.lsrange", "src.optimization.parameter.mcs.gls.lsinit.lsinit", "src.optimization.parameter.mcs.gls.lssort.lssort", "type", "alist.tolist.tolist", "type", "flist.tolist.tolist", "min", "src.optimization.parameter.mcs.gls.lsdescent.lsdescent", "src.optimization.parameter.mcs.gls.lsconvex.lsconvex", "src.optimization.parameter.mcs.gls.lsdescent.lsdescent", "src.optimization.parameter.mcs.gls.lssat.lssat", "src.optimization.parameter.mcs.gls.lslocal.lslocal", "src.optimization.parameter.mcs.gls.lspar.lspar", "src.optimization.parameter.mcs.gls.lsnew.lsnew", "src.optimization.parameter.mcs.gls.lssort.lssort", "src.optimization.parameter.mcs.gls.lsquart.lsquart", "src.optimization.parameter.mcs.gls.lssep.lssep"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsrange.lsrange", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsinit.lsinit", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsdescent.lsdescent", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsconvex.lsconvex", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsdescent.lsdescent", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssat.lssat", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lslocal.lslocal", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lspar.lspar", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsnew.lsnew", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsquart.lsquart", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssep.lssep"], ["def", "gls", "(", "func", ",", "xl", ",", "xu", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "nloc", ",", "small", ",", "smax", ",", "prt", "=", "2", ")", ":", "\n", "    ", "'''\n    Global line search main function\n    arg:\n        func -  funciton name which is subjected to optimization\n        xl -  lower bound\n        xu -  upper bound\n        x -  starting point\n        p -  search direction [1 or -1 ? need to check]\n        alist -  list of known steps\n        flist -  funciton values of known steps\n        nloc -  best local optimizal\n        small - tollarance values\n        smax -  search list size\n        prt =  print - unsued in this implementation so far\n    '''", "\n", "#%%    ", "\n", "if", "np", ".", "isscalar", "(", "alist", ")", ":", "\n", "        ", "alist", "=", "[", "alist", "]", "\n", "flist", "=", "[", "flist", "]", "\n", "#print('alist in gls:',alist)", "\n", "#print('flist in gls:',flist)", "\n", "\n", "\n", "", "if", "type", "(", "alist", ")", "!=", "list", ":", "\n", "        ", "alist", "=", "alist", ".", "tolist", "(", ")", "\n", "", "if", "type", "(", "flist", ")", "!=", "list", ":", "\n", "        ", "flist", "=", "flist", ".", "tolist", "(", ")", "\n", "\n", "# golden section fraction is (3-sqrt(5))/2= 0.38196601125011", "\n", "", "short", "=", "0.381966", "#fraction for splitting intervals", "\n", "\n", "# save information for nf computation and extrapolation decision", "\n", "sinit", "=", "len", "(", "alist", ")", "#initial list size", "\n", "\n", "# get 5 starting points (needed for lslocal)", "\n", "bend", "=", "0", "\n", "xl", ",", "xu", ",", "x", ",", "p", ",", "amin", ",", "amax", ",", "scale", "=", "lsrange", "(", "func", ",", "xl", ",", "xu", ",", "x", ",", "p", ",", "prt", ",", "bend", ")", "# find range of useful alp ", "\n", "#plt.plot(aa,ff)", "\n", "alist", ",", "flist", ",", "alp", ",", "alp1", ",", "alp2", ",", "falp", "=", "lsinit", "(", "func", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "scale", ")", "# 2 points needed for lspar and lsnew", "\n", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "nf", "=", "s", "-", "sinit", "# number of function values used", "\n", "\n", "\n", "#print(alist,flist,abest,fbest,fmed,up,down,monotone,minima,nmin,unitlen,s)", "\n", "while", "s", "<", "min", "(", "5", ",", "smax", ")", ":", "\n", "        ", "if", "nloc", "==", "1", ":", "\n", "#print('interpol')", "\n", "# parabolic interpolation step", "\n", "            ", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "alp", ",", "fac", "=", "lspar", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", "\n", "# when s==3 we haven't done a true parabolic step ", "\n", "# and may appear monotonic without being so!", "\n", "if", "s", ">", "3", "and", "monotone", "and", "(", "abest", "==", "amin", "or", "abest", "==", "amax", ")", ":", "\n", "#print('return since monotone')  # ", "\n", "                ", "nf", "=", "s", "-", "sinit", "# number of function values used", "\n", "#lsdraw  ", "\n", "return", "alist", ",", "flist", ",", "nf", "\n", "", "", "else", ":", "\n", "#print('explore')", "\n", "# extrapolation or split", "\n", "            ", "alist", ",", "flist", ",", "alp", ",", "fac", "=", "lsnew", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "s", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fmed", ",", "unitlen", ")", "\n", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "#print('while \\n:')", "\n", "#print(alist,flist,abest,fbest,fmed,up,down,monotone,minima,nmin,unitlen,s) ", "\n", "# end while", "\n", "#%%", "\n", "", "", "saturated", "=", "0", "#is reset in lsquart", "\n", "# shape detection phase", "\n", "if", "nmin", "==", "1", ":", "\n", "        ", "if", "monotone", "and", "(", "abest", "==", "amin", "or", "abest", "==", "amax", ")", ":", "\n", "#if prt>1,disp('return since monotone'); end;", "\n", "            ", "nf", "=", "s", "-", "sinit", "# number of function values used", "\n", "#lsdraw; ", "\n", "#print('return since monotone')", "\n", "return", "alist", ",", "flist", ",", "nf", "\n", "", "if", "s", "==", "5", ":", "\n", "# try quartic interpolation step", "\n", "            ", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "good", ",", "saturated", "=", "lsquart", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", ")", "\n", "# check descent condition \t\t", "\n", "", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lsdescent", "(", "func", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", "\n", "# check convexity\t", "\n", "convex", "=", "lsconvex", "(", "alist", ",", "flist", ",", "nmin", ",", "s", ")", "\n", "if", "convex", ":", "\n", "#print('return since convex')", "\n", "            ", "nf", "=", "s", "-", "sinit", "# number of function values used", "\n", "#lsdraw; ", "\n", "return", "alist", ",", "flist", ",", "nf", "\n", "", "", "sold", "=", "0", "\n", "# refinement phase", "\n", "while", "1", ":", "\n", "#lsdraw", "\n", "#print('***** new refinement iteration *****')", "\n", "# check descent condition \t\t", "\n", "        ", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lsdescent", "(", "func", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", "\n", "# check saturation", "\n", "alp", ",", "saturated", "=", "lssat", "(", "small", ",", "alist", ",", "flist", ",", "alp", ",", "amin", ",", "amax", ",", "s", ",", "saturated", ")", "\n", "if", "saturated", "or", "s", "==", "sold", "or", "s", ">=", "smax", ":", "\n", "            ", "if", "saturated", ":", "\n", "                ", "no_print", "=", "0", "\n", "#print('return since saturated')", "\n", "", "if", "s", "==", "sold", ":", "\n", "                ", "no_print", "=", "0", "\n", "#print('return since s==sold')", "\n", "", "if", "s", ">=", "smax", ":", "\n", "                ", "no_print", "=", "0", "\n", "#print('return since s>=smax')", "\n", "", "break", "\n", "", "sold", "=", "s", "\n", "nminold", "=", "nmin", "#if prt>1,nmin,end;", "\n", "if", "not", "saturated", "and", "nloc", ">", "1", ":", "\n", "# separate close minimizers", "\n", "            ", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssep", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", "\n", "# local interpolation step", "\n", "", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", "=", "lslocal", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", ")", "\n", "if", "nmin", ">", "nminold", ":", "\n", "            ", "saturated", "=", "0", "\n", "#end while", "\n", "#get output information", "\n", "", "", "nf", "=", "s", "-", "sinit", "# number of function values used", "\n", "#print(nf)", "\n", "return", "alist", ",", "flist", ",", "nf", "#  search list,function values,number of fucntion evaluation", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.quartic.quartic": [[12, 14], ["None"], "function", ["None"], ["def", "quartic", "(", "a", ",", "x", ")", ":", "\n", "    ", "return", "(", "(", "(", "a", "[", "0", "]", "*", "x", "+", "a", "[", "1", "]", ")", "*", "x", "+", "a", "[", "2", "]", ")", "*", "x", "+", "a", "[", "3", "]", ")", "*", "x", "+", "a", "[", "4", "]", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsquart.lsquart": [[16, 130], ["src.optimization.parameter.mcs.gls.lslocal.lslocal", "numpy.zeros", "max", "numpy.divide", "numpy.divide", "numpy.where", "max", "len", "numpy.sort", "src.optimization.parameter.mcs.gls.lsguard.lsguard", "src.optimization.parameter.mcs.gls.lsguard.lsguard", "src.optimization.parameter.mcs.gls.lsguard.lsguard", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "src.optimization.parameter.mcs.gls.lssort.lssort", "numpy.linalg.eig", "src.optimization.parameter.mcs.gls.quartic.quartic", "src.optimization.parameter.mcs.gls.quartic.quartic", "max", "max"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lslocal.lslocal", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.quartic.quartic", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.quartic.quartic"], ["def", "lsquart", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", ")", ":", "\n", "    ", "'''\n    '''", "\n", "if", "alist", "[", "0", "]", "==", "alist", "[", "1", "]", ":", "\n", "        ", "f12", "=", "0", "\n", "", "else", ":", "\n", "        ", "f12", "=", "(", "flist", "[", "1", "]", "-", "flist", "[", "0", "]", ")", "/", "(", "alist", "[", "1", "]", "-", "alist", "[", "0", "]", ")", "\n", "\n", "", "if", "alist", "[", "1", "]", "==", "alist", "[", "2", "]", ":", "\n", "        ", "f23", "=", "0", "\n", "", "else", ":", "\n", "        ", "f23", "=", "(", "flist", "[", "2", "]", "-", "flist", "[", "1", "]", ")", "/", "(", "alist", "[", "2", "]", "-", "alist", "[", "1", "]", ")", "# ", "\n", "\n", "", "if", "alist", "[", "2", "]", "==", "alist", "[", "3", "]", ":", "\n", "        ", "f34", "=", "0", "\n", "", "else", ":", "\n", "        ", "f34", "=", "(", "flist", "[", "3", "]", "-", "flist", "[", "2", "]", ")", "/", "(", "alist", "[", "3", "]", "-", "alist", "[", "2", "]", ")", "\n", "\n", "", "if", "alist", "[", "3", "]", "==", "alist", "[", "4", "]", ":", "\n", "        ", "f45", "=", "0", "\n", "", "else", ":", "\n", "        ", "f45", "=", "(", "flist", "[", "4", "]", "-", "flist", "[", "3", "]", ")", "/", "(", "alist", "[", "4", "]", "-", "alist", "[", "3", "]", ")", "\n", "#print(f12,f23,f34,f45)", "\n", "\n", "", "f123", "=", "(", "f23", "-", "f12", ")", "/", "(", "alist", "[", "2", "]", "-", "alist", "[", "0", "]", ")", "\n", "f234", "=", "(", "f34", "-", "f23", ")", "/", "(", "alist", "[", "3", "]", "-", "alist", "[", "1", "]", ")", "\n", "f345", "=", "(", "f45", "-", "f34", ")", "/", "(", "alist", "[", "4", "]", "-", "alist", "[", "2", "]", ")", "\n", "f1234", "=", "(", "f234", "-", "f123", ")", "/", "(", "alist", "[", "3", "]", "-", "alist", "[", "0", "]", ")", "\n", "f2345", "=", "(", "f345", "-", "f234", ")", "/", "(", "alist", "[", "4", "]", "-", "alist", "[", "1", "]", ")", "\n", "f12345", "=", "(", "f2345", "-", "f1234", ")", "/", "(", "alist", "[", "4", "]", "-", "alist", "[", "0", "]", ")", "\n", "#print(f123,f234,f345,f1234,f2345,f12345)", "\n", "\n", "good", "=", "np", ".", "Inf", "\n", "if", "f12345", "<=", "0", ":", "\n", "# quartic not bounded below", "\n", "#print('local step (quartic not bounded below)')", "\n", "        ", "good", "=", "0", "\n", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", "=", "lslocal", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", ")", "\n", "quart", "=", "0", "\n", "", "else", ":", "\n", "#print('quartic step')", "\n", "        ", "quart", "=", "1", "\n", "\n", "", "if", "quart", ":", "\n", "# expand around alist[2]", "\n", "        ", "c", "=", "np", ".", "zeros", "(", "len", "(", "alist", ")", ")", "\n", "c", "[", "0", "]", "=", "f12345", "\n", "c", "[", "1", "]", "=", "f1234", "+", "c", "[", "0", "]", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "0", "]", ")", "\n", "c", "[", "2", "]", "=", "f234", "+", "c", "[", "1", "]", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "3", "]", ")", "\n", "c", "[", "1", "]", "=", "c", "[", "1", "]", "+", "c", "[", "0", "]", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "3", "]", ")", "\n", "c", "[", "3", "]", "=", "f23", "+", "c", "[", "2", "]", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "1", "]", ")", "\n", "c", "[", "2", "]", "=", "c", "[", "2", "]", "+", "c", "[", "1", "]", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "1", "]", ")", "\n", "c", "[", "1", "]", "=", "c", "[", "1", "]", "+", "c", "[", "0", "]", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "1", "]", ")", "\n", "c", "[", "4", "]", "=", "flist", "[", "2", "]", "\n", "#print(c)", "\n", "#if prt>3:", "\n", "#  test_quartic_fit=[flist#quartic(c,alist-alist[2])]", "\n", "\n", "# find critical points of quartic as zeros of gradient", "\n", "cmax", "=", "max", "(", "c", ")", "\n", "c", "=", "np", ".", "divide", "(", "c", ",", "cmax", ")", "\n", "hk", "=", "4", "*", "c", "[", "0", "]", "#", "\n", "compmat", "=", "[", "[", "0", ",", "0", ",", "-", "c", "[", "3", "]", "]", ",", "[", "hk", ",", "0", ",", "-", "2", "*", "c", "[", "2", "]", "]", ",", "[", "0", ",", "hk", ",", "-", "3", "*", "c", "[", "1", "]", "]", "]", "\n", "ev", "=", "np", ".", "divide", "(", "np", ".", "linalg", ".", "eig", "(", "compmat", ")", "[", "0", "]", ",", "hk", ")", "\n", "i", "=", "np", ".", "where", "(", "ev", ".", "imag", "==", "0", ")", "\n", "#print(c,hk,compmat,ev,i)", "\n", "\n", "if", "i", "[", "0", "]", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "# only one minimizer", "\n", "#if prt>1, disp('quartic has only one minimizer')# #", "\n", "            ", "alp", "=", "alist", "[", "2", "]", "+", "ev", "[", "i", "[", "0", "]", "[", "0", "]", "]", "#", "\n", "#if prt>3:", "\n", "# f=quartic(c,ev(i))#", "\n", "#  plot(alp,f,'ro')#", "\n", "", "else", ":", "\n", "# two minimizers", "\n", "            ", "ev", "=", "np", ".", "sort", "(", "ev", ")", "#", "\n", "#print('quartic has two minimizers')# ", "\n", "alp1", "=", "lsguard", "(", "alist", "[", "2", "]", "+", "ev", "[", "0", "]", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", "\n", "alp2", "=", "lsguard", "(", "alist", "[", "2", "]", "+", "ev", "[", "2", "]", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", "\n", "f1", "=", "cmax", "*", "quartic", "(", "c", ",", "alp1", "-", "alist", "[", "2", "]", ")", "\n", "f2", "=", "cmax", "*", "quartic", "(", "c", ",", "alp2", "-", "alist", "[", "2", "]", ")", "\n", "#print(ev,alp1,alp2,f1,f2)", "\n", "#    if prt>3,", "\n", "#      alp3=alist[2]+ev[1]#", "\n", "#      f3=cmax*quartic(c,ev[1])#", "\n", "#      plot(alp1,f1,'ro')#", "\n", "#      plot(alp2,f2,'ro')#", "\n", "#      plot(alp3,f3,'ro')#", "\n", "\n", "# pick extrapolating minimizer if possible ", "\n", "if", "alp2", ">", "alist", "[", "4", "]", "and", "f2", "<", "max", "(", "flist", ")", ":", "\n", "                ", "alp", "=", "alp2", "\n", "", "elif", "alp1", "<", "alist", "[", "0", "]", "and", "f1", "<", "max", "(", "flist", ")", ":", "\n", "                ", "alp", "=", "alp1", "\n", "", "elif", "f2", "<=", "f1", ":", "\n", "                ", "alp", "=", "alp2", "\n", "", "else", ":", "\n", "                ", "alp", "=", "alp1", "\n", "\n", "", "", "if", "max", "(", "[", "i", "==", "alp", "for", "i", "in", "alist", "]", ")", ":", "\n", "# predicted point already known", "\n", "#if prt, disp('quartic predictor already known')# #", "\n", "              ", "quart", "=", "0", "#", "\n", "\n", "", "if", "quart", ":", "\n", "            ", "alp", "=", "lsguard", "(", "alp", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", "\n", "#print('new function value')", "\n", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "#", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "\n", "", "", "return", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "good", ",", "saturated", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lslocal.lslocal": [[12, 198], ["numpy.argsort", "ff.sort", "min", "len", "src.optimization.parameter.mcs.gls.lssort.lssort", "zip", "zip", "zip", "range", "src.optimization.parameter.mcs.gls.lsguard.lsguard", "max", "min", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "len", "src.optimization.parameter.mcs.gls.lsguard.lsguard", "min", "max", "range", "abs", "range", "range", "min", "max", "min", "max", "max", "max"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard"], ["def", "lslocal", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", ")", ":", "\n", "#fmin = min(flist) # unsued", "\n", "    ", "up", "=", "[", "i", "<", "j", "for", "i", ",", "j", "in", "zip", "(", "flist", "[", "0", ":", "s", "-", "1", "]", ",", "flist", "[", "1", ":", "s", "]", ")", "]", "\n", "down", "=", "[", "i", "<=", "j", "for", "i", ",", "j", "in", "zip", "(", "flist", "[", "1", ":", "s", "]", ",", "flist", "[", "0", ":", "s", "-", "1", "]", ")", "]", "\n", "down", "[", "s", "-", "2", "]", "=", "(", "flist", "[", "s", "-", "1", "]", "<", "flist", "[", "s", "-", "2", "]", ")", "\n", "minima", "=", "[", "i", "and", "j", "for", "i", ",", "j", "in", "zip", "(", "up", "+", "[", "True", "]", ",", "[", "True", "]", "+", "down", ")", "]", "\n", "imin", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "minima", ")", ")", "if", "minima", "[", "i", "]", "]", "\n", "#print(up,down,minima,imin)", "\n", "\n", "# consider nloc best local minima only", "\n", "ff", "=", "[", "flist", "[", "i", "]", "for", "i", "in", "imin", "]", "\n", "perm", "=", "np", ".", "argsort", "(", "ff", ")", "\n", "ff", ".", "sort", "(", ")", "\n", "\n", "imin", "=", "[", "imin", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "nind", "=", "min", "(", "nloc", ",", "len", "(", "imin", ")", ")", "\n", "imin", "=", "imin", "[", "nind", "-", "1", ":", ":", "-", "1", "]", "# best point last for final improvement", "\n", "#if prt>3: ", "\n", "#  disp([alist#flist])#", "\n", "#  disp([num2str(nloc),' best local minimizers at [a#f]:'])#", "\n", "#  disp([imin#alist(imin)#flist(imin)])#", "\n", "#elif prt>2,", "\n", "#  disp([num2str(nloc),' best local minimizers at [a#f]:'])#", "\n", "#  disp([alist(imin)#flist(imin)])#", "\n", "##", "\n", "\n", "nadd", "=", "0", "#\t\t\t# number of added points", "\n", "nsat", "=", "0", "#\t\t\t# number of saturated points", "\n", "\n", "for", "i", "in", "imin", ":", "\n", "# select nearest five points for local formula", "\n", "        ", "if", "i", "<=", "1", ":", "\n", "            ", "ind", "=", "[", "j", "for", "j", "in", "range", "(", "5", ")", "]", "\n", "ii", "=", "i", "#", "\n", "", "elif", "i", ">=", "s", "-", "2", ":", "\n", "            ", "ind", "=", "[", "j", "for", "j", "in", "range", "(", "s", "-", "5", ",", "s", ")", "]", "\n", "ii", "=", "i", "-", "(", "s", "-", "1", ")", "+", "4", "\n", "", "else", ":", "\n", "            ", "ind", "=", "[", "j", "for", "j", "in", "range", "(", "i", "-", "2", ",", "i", "+", "3", ")", "]", "\n", "ii", "=", "2", "\n", "# in natural order", "\n", "", "aa", "=", "[", "alist", "[", "i", "]", "for", "i", "in", "ind", "]", "\n", "# the local minimum is at ff(ii)", "\n", "ff", "=", "[", "flist", "[", "i", "]", "for", "i", "in", "ind", "]", "\n", "\n", "# get divided differences ", "\n", "f12", "=", "(", "ff", "[", "1", "]", "-", "ff", "[", "0", "]", ")", "/", "(", "aa", "[", "1", "]", "-", "aa", "[", "0", "]", ")", "\n", "f23", "=", "(", "ff", "[", "2", "]", "-", "ff", "[", "1", "]", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "1", "]", ")", "\n", "f34", "=", "(", "ff", "[", "3", "]", "-", "ff", "[", "2", "]", ")", "/", "(", "aa", "[", "3", "]", "-", "aa", "[", "2", "]", ")", "\n", "f45", "=", "(", "ff", "[", "4", "]", "-", "ff", "[", "3", "]", ")", "/", "(", "aa", "[", "4", "]", "-", "aa", "[", "3", "]", ")", "\n", "f123", "=", "(", "f23", "-", "f12", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "0", "]", ")", "\n", "f234", "=", "(", "f34", "-", "f23", ")", "/", "(", "aa", "[", "3", "]", "-", "aa", "[", "1", "]", ")", "\n", "f345", "=", "(", "f45", "-", "f34", ")", "/", "(", "aa", "[", "4", "]", "-", "aa", "[", "2", "]", ")", "\n", "#print(f12,f23,f34,f45,f123,f234,f345)", "\n", "\n", "# decide on action", "\n", "# cas=-1: \tno local refinement at boundary", "\n", "# cas=0: \tuse parabolic minimizer", "\n", "# cas=1: \tuse higher order predictor in i-2:i+1", "\n", "# cas=5: \tuse higher order predictor in i-1:i+2", "\n", "# select formula on convex interval", "\n", "if", "ii", "==", "0", ":", "# boundary minimum", "\n", "# parabolic minimizer or extrapolation step", "\n", "            ", "cas", "=", "0", "#", "\n", "if", "f123", ">", "0", "and", "f123", "<", "np", ".", "Inf", ":", "\n", "                ", "alp", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", "-", "f23", "/", "f123", ")", "\n", "if", "alp", "<", "amin", ":", "\n", "                    ", "cas", "=", "-", "1", "\n", "", "", "else", ":", "\n", "                ", "alp", "=", "-", "np", ".", "Inf", "\n", "if", "alist", "[", "0", "]", "==", "amin", "and", "flist", "[", "1", "]", "<", "flist", "[", "2", "]", ":", "\n", "                    ", "cas", "=", "-", "1", "\n", "", "", "alp", "=", "lsguard", "(", "alp", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", "#", "\n", "", "elif", "ii", "==", "4", ":", "# boundary minimum", "\n", "# parabolic minimizer or extrapolation step", "\n", "            ", "cas", "=", "0", "#", "\n", "if", "f345", ">", "0", "and", "f345", "<", "np", ".", "Inf", ":", "\n", "                ", "alp", "=", "0.5", "*", "(", "aa", "[", "2", "]", "+", "aa", "[", "3", "]", "-", "f34", "/", "f345", ")", "#", "\n", "if", "alp", ">", "amax", ":", "\n", "                    ", "cas", "=", "-", "1", "##", "\n", "", "", "else", ":", "\n", "                ", "alp", "=", "np", ".", "Inf", "#", "\n", "if", "alist", "[", "s", "-", "1", "]", "==", "amax", "and", "flist", "[", "s", "-", "2", "]", "<", "flist", "[", "s", "-", "3", "]", ":", "\n", "                    ", "cas", "=", "-", "1", "\n", "", "", "alp", "=", "lsguard", "(", "alp", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", "\n", "", "elif", "not", "(", "f234", ">", "0", "and", "f234", "<", "np", ".", "Inf", ")", ":", "\n", "# parabolic minimizer", "\n", "            ", "cas", "=", "0", "#", "\n", "if", "ii", "<", "2", ":", "\n", "                ", "alp", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", "-", "f23", "/", "f123", ")", "#", "\n", "", "else", ":", "\n", "                ", "alp", "=", "0.5", "*", "(", "aa", "[", "2", "]", "+", "aa", "[", "3", "]", "-", "f34", "/", "f345", ")", "\n", "\n", "", "", "elif", "not", "(", "f123", ">", "0", "and", "f123", "<", "np", ".", "Inf", ")", ":", "\n", "            ", "if", "f345", ">", "0", "and", "f345", "<", "np", ".", "Inf", ":", "\n", "                ", "cas", "=", "5", "#\t\t# use 2345", "\n", "", "else", ":", "\n", "# parabolic minimizer", "\n", "                ", "cas", "=", "0", "#", "\n", "alp", "=", "0.5", "*", "(", "aa", "[", "2", "]", "+", "aa", "[", "3", "]", "-", "f34", "/", "f234", ")", "# ", "\n", "", "", "elif", "f345", ">", "0", "and", "f345", "<", "np", ".", "Inf", "and", "ff", "[", "1", "]", ">", "ff", "[", "3", "]", ":", "\n", "            ", "cas", "=", "5", "#\t\t# use 2345", "\n", "", "else", ":", "\n", "            ", "cas", "=", "1", "#\t\t# use 1234", "\n", "#end ii", "\n", "\n", "\n", "", "if", "cas", "==", "0", ":", "\n", "# parabolic minimizer might extrapolate at the boundary", "\n", "            ", "alp", "=", "max", "(", "amin", ",", "min", "(", "alp", ",", "amax", ")", ")", "\n", "", "elif", "cas", "==", "1", ":", "\n", "# higher order minimizer using 1234", "\n", "            ", "if", "ff", "[", "1", "]", "<", "ff", "[", "2", "]", ":", "\n", "# compute f1x4=f134", "\n", "                ", "f13", "=", "(", "ff", "[", "2", "]", "-", "ff", "[", "0", "]", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "0", "]", ")", "\n", "f1x4", "=", "(", "f34", "-", "f13", ")", "/", "(", "aa", "[", "3", "]", "-", "aa", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "# compute f1x4=f124", "\n", "                ", "f24", "=", "(", "ff", "[", "3", "]", "-", "ff", "[", "1", "]", ")", "/", "(", "aa", "[", "3", "]", "-", "aa", "[", "1", "]", ")", "#", "\n", "f1x4", "=", "(", "f24", "-", "f12", ")", "/", "(", "aa", "[", "3", "]", "-", "aa", "[", "0", "]", ")", "#", "\n", "#end if ff[1]<ff[2]", "\n", "", "alp", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", "-", "f23", "/", "(", "f123", "+", "f234", "-", "f1x4", ")", ")", "#", "\n", "if", "alp", "<=", "min", "(", "aa", ")", "or", "alp", ">=", "max", "(", "aa", ")", ":", "\n", "                ", "cas", "=", "0", "#", "\n", "alp", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", "-", "f23", "/", "max", "(", "f123", ",", "f234", ")", ")", "#", "\n", "#if prt>1, disp('predictor outside interval')#", "\n", "", "", "elif", "cas", "==", "5", ":", "\n", "# higher order minimizer using 2345", "\n", "            ", "if", "ff", "[", "2", "]", "<", "ff", "[", "3", "]", ":", "\n", "# compute f2x5=f245", "\n", "                ", "f24", "=", "(", "ff", "[", "3", "]", "-", "ff", "[", "1", "]", ")", "/", "(", "aa", "[", "3", "]", "-", "aa", "[", "1", "]", ")", "\n", "f2x5", "=", "(", "f45", "-", "f24", ")", "/", "(", "aa", "[", "4", "]", "-", "aa", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "# compute f2x5=f235", "\n", "                ", "f35", "=", "(", "ff", "[", "4", "]", "-", "ff", "[", "2", "]", ")", "/", "(", "aa", "[", "4", "]", "-", "aa", "[", "2", "]", ")", "#", "\n", "f2x5", "=", "(", "f35", "-", "f23", ")", "/", "(", "aa", "[", "4", "]", "-", "aa", "[", "1", "]", ")", "#", "\n", "#end if ff[2]<ff[3]", "\n", "", "alp", "=", "0.5", "*", "(", "aa", "[", "2", "]", "+", "aa", "[", "3", "]", "-", "f34", "/", "(", "f234", "+", "f345", "-", "f2x5", ")", ")", "#", "\n", "if", "alp", "<=", "min", "(", "aa", ")", "or", "alp", ">=", "max", "(", "aa", ")", ":", "\n", "                ", "cas", "=", "0", "#", "\n", "alp", "=", "0.5", "*", "(", "aa", "[", "2", "]", "+", "aa", "[", "3", "]", "-", "f34", "/", "max", "(", "f234", ",", "f345", ")", ")", "#  ", "\n", "#end", "\n", "#end if cas", "\n", "\n", "# tolerance for accepting new step", "\n", "", "", "if", "cas", "<", "0", "or", "flist", "[", "i", "]", ">", "fmed", ":", "\n", "            ", "alptol", "=", "0", "#", "\n", "", "elif", "cas", ">=", "0", ":", "\n", "            ", "if", "i", "==", "0", ":", "# minimum boundry", "\n", "                ", "alptol", "=", "small", "*", "(", "alist", "[", "2", "]", "-", "alist", "[", "0", "]", ")", "\n", "", "elif", "i", "==", "s", "-", "1", ":", "# maximim boundry", "\n", "                ", "alptol", "=", "small", "*", "(", "alist", "[", "s", "-", "1", "]", "-", "alist", "[", "s", "-", "3", "]", ")", "# s is the length to index", "\n", "", "else", ":", "# somwhere in between", "\n", "                ", "alptol", "=", "small", "*", "(", "alist", "[", "i", "+", "1", "]", "-", "alist", "[", "i", "-", "1", "]", ")", "# i is index", "\n", "", "", "close", "=", "(", "min", "(", "[", "abs", "(", "i", "-", "alp", ")", "for", "i", "in", "alist", "]", ")", "<=", "alptol", ")", "\n", "\n", "if", "cas", "<", "0", "or", "close", ":", "\n", "            ", "nsat", "=", "nsat", "+", "1", "\n", "#        if prt>2, ", "\n", "#            if cas<0, disp('no local refinement at boundary')#", "\n", "#        elif alptol>0:", "\n", "#            disp('predicted point close to known point')#", "\n", "#        else:", "\n", "#            disp('predicted point matches known point')#", "\n", "\n", "", "saturated", "=", "(", "nsat", "==", "nind", ")", "\n", "# check if saturated and best point changes", "\n", "final", "=", "saturated", "and", "not", "max", "(", "[", "i", "==", "alp", "for", "i", "in", "alist", "]", ")", "\n", "if", "cas", ">=", "0", "and", "(", "final", "or", "not", "close", ")", ":", "\n", "#if prt>1, disp(['add local point at alp=',num2str(alp)])##", "\n", "# add point to the list", "\n", "            ", "nadd", "=", "nadd", "+", "1", "#", "\n", "# new function value", "\n", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "#", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "# no sort since this would destroy old index set!!!", "\n", "#if prt>1, abest_anew_xnew=[alist(i),alp,(x+alp*p)']##", "\n", "#end if", "\n", "#end for", "\n", "", "", "if", "nadd", ":", "\n", "        ", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "#    if prt>1,", "\n", "#        if saturated, disp(['saturated at s = ',num2str(s)])#", "\n", "#        else disp(['not saturated at s = ',num2str(s)])#", "\n", "", "return", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "saturated", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsinit.lsinit": [[6, 66], ["min", "max", "len", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "sys.exit", "max", "max", "len", "sys.exit", "len", "min", "min", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval"], ["def", "lsinit", "(", "func", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "scale", ")", ":", "\n", "    ", "'''\n        Line search intilization\n    '''", "\n", "alp", "=", "0", "\n", "alp1", "=", "0", "\n", "alp2", "=", "0", "\n", "falp", "=", "0", "\n", "\n", "if", "len", "(", "alist", ")", "==", "0", ":", "\n", "# evaluate at absolutely smallest point", "\n", "        ", "alp", "=", "0", "\n", "if", "amin", ">", "0", ":", "\n", "            ", "alp", "=", "amin", "\n", "", "if", "amax", "<", "0", ":", "\n", "            ", "alp", "=", "amax", "\n", "# new function value", "\n", "", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "", "elif", "len", "(", "alist", ")", "==", "1", ":", "\n", "# evaluate at absolutely smallest point", "\n", "        ", "alp", "=", "0", "\n", "if", "amin", ">", "0", ":", "\n", "            ", "alp", "=", "amin", "\n", "", "if", "amax", "<", "0", ":", "\n", "            ", "alp", "=", "amax", "\n", "", "if", "alist", "[", "0", "]", "!=", "alp", ":", "\n", "# new function value", "\n", "            ", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "\n", "# alist and f lis are set -  now comut min and max", "\n", "", "", "aamin", "=", "min", "(", "alist", ")", "# scalr", "\n", "aamax", "=", "max", "(", "alist", ")", "# scalr", "\n", "if", "amin", ">", "aamin", "or", "amax", "<", "aamax", ":", "\n", "#print(alist, amin, amax)", "\n", "        ", "sys", ".", "exit", "(", "'GLS Error: non-admissible step in alist'", ")", "\n", "\n", "# establish correct scale", "\n", "", "if", "aamax", "-", "aamin", "<=", "scale", ":", "\n", "        ", "alp1", "=", "max", "(", "amin", ",", "min", "(", "-", "scale", ",", "amax", ")", ")", "# scalr", "\n", "alp2", "=", "max", "(", "amin", ",", "min", "(", "+", "scale", ",", "amax", ")", ")", "# scalr", "\n", "alp", "=", "np", ".", "Inf", "# scalr", "\n", "\n", "if", "aamin", "-", "alp1", ">=", "alp2", "-", "aamax", ":", "\n", "            ", "alp", "=", "alp1", "\n", "", "if", "alp2", "-", "aamax", ">=", "aamin", "-", "alp1", ":", "\n", "            ", "alp", "=", "alp2", "\n", "", "if", "alp", "<", "aamin", "or", "alp", ">", "aamax", ":", "\n", "# new function value", "\n", "            ", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "", "", "if", "len", "(", "alist", ")", "==", "1", ":", "\n", "#print(scale,aamin,aamax,alp1,alp2)", "\n", "        ", "sys", ".", "exit", "(", "'GLS Error: lsinit bug: no second point found'", ")", "\n", "\n", "", "return", "alist", ",", "flist", ",", "alp", ",", "alp1", ",", "alp2", ",", "falp", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssep.lssep": [[13, 63], ["range", "src.optimization.parameter.mcs.gls.lssort.lssort", "print", "src.optimization.parameter.mcs.gls.lsnew.lsnew", "src.optimization.parameter.mcs.gls.lssort.lssort", "len", "len", "numpy.argsort", "ff.sort", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "zip", "zip", "zip", "zip", "range", "min", "len", "range"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsnew.lsnew", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval"], ["def", "lssep", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", ":", "\n", "    ", "'''\n    '''", "\n", "nsep", "=", "0", "\n", "while", "nsep", "<", "nmin", ":", "\n", "# find intervals where the monotonicity behavior of both", "\n", "# adjacent intervals is opposite", "\n", "        ", "down", "=", "[", "i", "<", "j", "for", "i", ",", "j", "in", "zip", "(", "flist", "[", "1", ":", "s", "]", ",", "flist", "[", "0", ":", "s", "-", "1", "]", ")", "]", "\n", "sep", "=", "[", "i", "and", "j", "and", "k", "for", "i", ",", "j", ",", "k", "in", "zip", "(", "[", "True", ",", "True", "]", "+", "down", ",", "[", "False", "]", "+", "up", "+", "[", "False", "]", ",", "down", "+", "[", "True", ",", "True", "]", ")", "]", "\n", "temp_sep", "=", "[", "i", "and", "j", "and", "k", "for", "i", ",", "j", ",", "k", "in", "zip", "(", "[", "True", ",", "True", "]", "+", "up", ",", "[", "False", "]", "+", "down", "+", "[", "False", "]", ",", "up", "+", "[", "True", ",", "True", "]", ")", "]", "\n", "sep", "=", "[", "i", "or", "j", "for", "i", ",", "j", "in", "zip", "(", "sep", ",", "temp_sep", ")", "]", "\n", "\n", "ind", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "sep", ")", ")", "if", "sep", "[", "i", "]", "]", "\n", "\n", "if", "len", "(", "ind", ")", "==", "0", ":", "\n", "#print('break ind is empty',ind)", "\n", "            ", "break", "\n", "\n", "# i = 0  will naver come here ", "\n", "", "aa", "=", "[", "0.5", "*", "(", "alist", "[", "i", "]", "+", "alist", "[", "i", "-", "1", "]", ")", "for", "i", "in", "ind", "]", "# interval midpoints", "\n", "if", "len", "(", "aa", ")", ">", "nloc", ":", "\n", "# select nloc best interval midpoints", "\n", "            ", "ff", "=", "[", "min", "(", "flist", "[", "i", "]", ",", "flist", "[", "j", "]", ")", "for", "i", ",", "j", "in", "ind", "]", "\n", "ind", "=", "np", ".", "argsort", "(", "ff", ")", "\n", "ff", ".", "sort", "(", ")", "\n", "aa", "=", "[", "aa", "[", "ind", "[", "i", "]", "]", "for", "i", "in", "range", "(", "0", ",", "nloc", ")", "]", "\n", "\n", "", "for", "alp", "in", "aa", ":", "\n", "#print(alp)", "\n", "#if prt>2, disp(['separate minimizer at ',num2str(alp)]); #", "\n", "# new function value", "\n", "            ", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "nsep", "=", "nsep", "+", "1", "\n", "if", "nsep", ">=", "nmin", ":", "\n", "                ", "break", "\n", "#end for", "\n", "", "", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "#end while", "\n", "\n", "# instead of unnecessary separation, add some global points", "\n", "", "for", "times", "in", "range", "(", "0", ",", "nmin", "-", "nsep", ")", ":", "\n", "        ", "print", "(", "times", ")", "\n", "# extrapolation or split", "\n", "#print('extrapolation')", "\n", "alist", ",", "flist", ",", "alp", ",", "fac", "=", "lsnew", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "s", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fmed", ",", "unitlen", ")", "\n", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "\n", "", "return", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsrange.lsrange": [[16, 91], ["numpy.abs", "numpy.divide", "min", "numpy.max", "sys.exit", "type", "numpy.asarray", "type", "numpy.asarray", "numpy.asarray", "numpy.asarray", "sys.exit", "numpy.abs", "numpy.divide", "min", "range", "range", "numpy.abs", "type", "type", "len", "sys.exit", "len", "max", "min", "min", "max", "max", "min", "min", "max"], "function", ["None"], ["def", "lsrange", "(", "func", ",", "xl", ",", "xu", ",", "x", ",", "p", ",", "prt", ",", "bend", ")", ":", "\n", "    ", "'''\n        Defining line search range\n    '''", "\n", "if", "np", ".", "max", "(", "np", ".", "abs", "(", "p", ")", ")", "==", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'GLS Error: zero search direction in line search'", ")", "\n", "\n", "# find sensible step size scale", "\n", "", "if", "type", "(", "p", ")", "!=", "np", ".", "ndarray", ":", "\n", "        ", "if", "type", "(", "p", ")", "!=", "list", ":", "\n", "            ", "p", "=", "[", "p", "]", "\n", "", "p", "=", "np", ".", "asarray", "(", "p", ")", "\n", "\n", "", "if", "type", "(", "x", ")", "!=", "np", ".", "ndarray", ":", "\n", "        ", "if", "type", "(", "x", ")", "!=", "list", ":", "\n", "            ", "x", "=", "[", "x", "]", "\n", "xl", "=", "[", "xl", "]", "\n", "xu", "=", "[", "xu", "]", "\n", "", "x", "=", "np", ".", "asarray", "(", "x", ")", "\n", "xl", "=", "np", ".", "asarray", "(", "xl", ")", "\n", "xu", "=", "np", ".", "asarray", "(", "xu", ")", "\n", "\n", "# this is test for python", "\n", "", "if", "x", ".", "shape", "!=", "p", ".", "shape", ":", "\n", "        ", "sys", ".", "exit", "(", "'GLS Error: dim of x and p does not match: program is going to fail'", ")", "\n", "\n", "", "pp", "=", "np", ".", "abs", "(", "p", "[", "p", "!=", "0", "]", ")", "\n", "u", "=", "np", ".", "divide", "(", "np", ".", "abs", "(", "x", "[", "p", "!=", "0", "]", ")", ",", "pp", ")", "\n", "scale", "=", "min", "(", "u", ")", "\n", "\n", "if", "scale", "==", "0", ":", "\n", "        ", "u", "[", "u", "==", "0", "]", "=", "np", ".", "divide", "(", "1", ",", "pp", "[", "u", "==", "0", "]", ")", "\n", "scale", "=", "min", "(", "u", ")", "\n", "\n", "", "if", "not", "bend", ":", "\n", "# find range of useful alp in truncated line search", "\n", "        ", "amin", "=", "-", "np", ".", "Inf", "\n", "amax", "=", "np", ".", "Inf", "\n", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "            ", "if", "p", "[", "i", "]", ">", "0", ":", "\n", "                ", "amin", "=", "max", "(", "amin", ",", "(", "xl", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "amax", "=", "min", "(", "amax", ",", "(", "xu", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "", "elif", "p", "[", "i", "]", "<", "0", ":", "\n", "                ", "amin", "=", "max", "(", "amin", ",", "(", "xu", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "amax", "=", "min", "(", "amax", ",", "(", "xl", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "\n", "", "", "if", "amin", ">", "amax", ":", "\n", "            ", "sys", ".", "exit", "(", "'GLS Error: no admissible step in line search'", ")", "\n", "#return ", "\n", "# not needed if do not print any thing", "\n", "#        if prt:", "\n", "#            aa = amin + np.arange(101)*(amax - amin)/100", "\n", "#            ff=[]", "\n", "#            for alp in aa:", "\n", "#                xx = np.asarray([max(xl[i],min(x[i]+alp*p[i],xu[i])) for i in  range(len(x))])", "\n", "#                ff.append(feval(func,xx))", "\n", "", "", "else", ":", "\n", "# find range of useful alp in bent line search", "\n", "        ", "amin", "=", "np", ".", "Inf", "\n", "amax", "=", "-", "np", ".", "Inf", "\n", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", ":", "\n", "            ", "if", "p", "[", "i", "]", ">", "0", ":", "\n", "                ", "amin", "=", "min", "(", "amin", ",", "(", "xl", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "amax", "=", "max", "(", "amax", ",", "(", "xu", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "", "elif", "p", "[", "i", "]", "<", "0", ":", "\n", "                ", "amin", "=", "min", "(", "amin", ",", "(", "xu", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "amax", "=", "max", "(", "amax", ",", "(", "xl", "[", "i", "]", "-", "x", "[", "i", "]", ")", "/", "p", "[", "i", "]", ")", "\n", "#        if prt:", "\n", "#            aa = amin +  np.arange(101)*(amax - amin)/100 ", "\n", "#            ff=[]", "\n", "#            for alp in aa:", "\n", "#                xx = max(xl, min(x+alp*p,xu)) ", "\n", "#                ff.append(feval(func,xx))", "\n", "\n", "", "", "", "return", "xl", ",", "xu", ",", "x", ",", "p", ",", "amin", ",", "amax", ",", "scale", "#,aa,ff", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsdescent.lsdescent": [[8, 49], ["max", "min", "numpy.argmin", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "src.optimization.parameter.mcs.gls.lssort.lssort", "min"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort"], ["def", "lsdescent", "(", "func", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", ":", "\n", "    ", "cont", "=", "max", "(", "[", "i", "==", "0", "for", "i", "in", "alist", "]", ")", "# condition for continue", "\n", "\n", "if", "cont", ":", "\n", "        ", "fbest", "=", "min", "(", "flist", ")", "\n", "i", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "if", "alist", "[", "i", "]", "<", "0", ":", "\n", "            ", "if", "alist", "[", "i", "]", ">=", "4", "*", "alist", "[", "i", "+", "1", "]", ":", "\n", "                ", "cont", "=", "0", "# ", "\n", "", "", "elif", "alist", "[", "i", "]", ">", "0", ":", "\n", "            ", "if", "alist", "[", "i", "]", "<", "4", "*", "alist", "[", "i", "-", "1", "]", ":", "\n", "                ", "cont", "=", "0", "# ", "\n", "", "", "else", ":", "\n", "            ", "if", "i", "==", "0", ":", "# lowest point", "\n", "                ", "fbest", "=", "flist", "[", "1", "]", "\n", "", "elif", "i", "==", "s", "-", "1", ":", "# last point", "\n", "                ", "fbest", "=", "flist", "[", "s", "-", "2", "]", "\n", "", "else", ":", "\n", "                ", "fbest", "=", "min", "(", "flist", "[", "i", "-", "1", "]", ",", "flist", "[", "i", "+", "1", "]", ")", "\n", "\n", "", "", "", "if", "cont", ":", "\n", "# force local descent step", "\n", "        ", "if", "alist", "[", "i", "]", "!=", "0", ":", "\n", "            ", "alp", "=", "alist", "[", "i", "]", "/", "3", "\n", "", "elif", "i", "==", "s", "-", "1", ":", "\n", "            ", "alp", "=", "alist", "[", "s", "-", "2", "]", "/", "3", "\n", "", "elif", "i", "==", "0", ":", "\n", "            ", "alp", "=", "alist", "[", "1", "]", "/", "3", "\n", "", "else", ":", "\n", "# split wider adjacent interval", "\n", "            ", "if", "alist", "[", "i", "+", "1", "]", "-", "alist", "[", "i", "]", ">", "alist", "[", "i", "]", "-", "alist", "[", "i", "-", "1", "]", ":", "\n", "                ", "alp", "=", "alist", "[", "i", "+", "1", "]", "/", "3", "\n", "", "else", ":", "\n", "                ", "alp", "=", "alist", "[", "i", "-", "1", "]", "/", "3", "\n", "# new function value", "\n", "", "", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "#print('descent check: new point at ',alp)  #", "\n", "", "return", "alist", ",", "flist", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort": [[3, 42], ["numpy.argsort().tolist", "alist.sort", "len", "sum", "min", "numpy.argmin", "numpy.median", "len", "min", "max", "numpy.argsort", "zip", "zip", "sum", "sum", "zip", "al.remove", "numpy.abs", "range", "numpy.subtract", "len"], "function", ["None"], ["def", "lssort", "(", "alist", ",", "flist", ")", ":", "\n", "    ", "'''\n    '''", "\n", "perm", "=", "np", ".", "argsort", "(", "alist", ")", ".", "tolist", "(", ")", "\n", "alist", ".", "sort", "(", ")", "\n", "flist", "=", "[", "flist", "[", "i", "]", "for", "i", "in", "perm", "]", "\n", "\n", "s", "=", "len", "(", "alist", ")", "\n", "\n", "# find number of strict local minima, etc.", "\n", "#up = [flist[0:s-1] < flist[1:s]]", "\n", "up", "=", "[", "i", "<", "j", "for", "i", ",", "j", "in", "zip", "(", "flist", "[", "0", ":", "s", "-", "1", "]", ",", "flist", "[", "1", ":", "s", "]", ")", "]", "\n", "#down = [flist[1:s] <= flist[0:s-1]]", "\n", "down", "=", "[", "i", "<=", "j", "for", "i", ",", "j", "in", "zip", "(", "flist", "[", "1", ":", "s", "]", ",", "flist", "[", "0", ":", "s", "-", "1", "]", ")", "]", "\n", "if", "len", "(", "down", ")", "==", "1", ":", "\n", "        ", "down", "[", "0", "]", "=", "flist", "[", "s", "-", "1", "]", "<", "flist", "[", "s", "-", "2", "]", "\n", "", "else", ":", "\n", "        ", "down", "[", "s", "-", "2", "]", "=", "flist", "[", "s", "-", "1", "]", "<", "flist", "[", "s", "-", "2", "]", "\n", "\n", "", "monotone", "=", "(", "sum", "(", "up", ")", "==", "0", "or", "sum", "(", "down", ")", "==", "0", ")", "\n", "minima", "=", "[", "i", "and", "j", "for", "i", ",", "j", "in", "zip", "(", "up", "+", "[", "True", "]", ",", "[", "True", "]", "+", "down", ")", "]", "\n", "nmin", "=", "sum", "(", "minima", ")", "\n", "\n", "fbest", "=", "min", "(", "flist", ")", "\n", "i", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "\n", "abest", "=", "alist", "[", "i", "]", "\n", "fmed", "=", "np", ".", "median", "(", "flist", ")", "\n", "\n", "# distance from best minimum to next", "\n", "if", "nmin", ">", "1", ":", "\n", "        ", "al", "=", "[", "alist", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "minima", ")", ")", "if", "minima", "[", "i", "]", "==", "True", "]", "\n", "if", "abest", "in", "al", ":", "\n", "            ", "al", ".", "remove", "(", "abest", ")", "\n", "", "unitlen", "=", "min", "(", "np", ".", "abs", "(", "np", ".", "subtract", "(", "al", ",", "abest", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "unitlen", "=", "max", "(", "abest", "-", "alist", "[", "0", "]", ",", "alist", "[", "s", "-", "1", "]", "-", "abest", ")", "\n", "\n", "", "return", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard": [[8, 29], ["asort.sort", "len", "max", "max", "min", "min", "abs", "abs"], "function", ["None"], ["def", "lsguard", "(", "alp", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", ":", "\n", "    ", "asort", "=", "alist", "\n", "asort", ".", "sort", "(", ")", "\n", "s", "=", "len", "(", "asort", ")", "\n", "\n", "# enforce extrapolation to be cautious", "\n", "al", "=", "asort", "[", "0", "]", "-", "(", "asort", "[", "s", "-", "1", "]", "-", "asort", "[", "0", "]", ")", "/", "small", "\n", "au", "=", "asort", "[", "s", "-", "1", "]", "+", "(", "asort", "[", "s", "-", "1", "]", "-", "asort", "[", "0", "]", ")", "/", "small", "\n", "alp", "=", "max", "(", "al", ",", "min", "(", "alp", ",", "au", ")", ")", "\n", "alp", "=", "max", "(", "amin", ",", "min", "(", "alp", ",", "amax", ")", ")", "\n", "\n", "# enforce some distance from end points", "\n", "# \tfactor 1/3 ensures equal spacing if s=2 and the third point", "\n", "# \tin a safeguarded extrapolation is the maximum.", "\n", "if", "abs", "(", "alp", "-", "asort", "[", "0", "]", ")", "<", "small", "*", "(", "asort", "[", "1", "]", "-", "asort", "[", "0", "]", ")", ":", "\n", "      ", "alp", "=", "(", "2", "*", "asort", "[", "0", "]", "+", "asort", "[", "1", "]", ")", "/", "3", "\n", "\n", "", "if", "abs", "(", "alp", "-", "asort", "[", "s", "-", "1", "]", ")", "<", "small", "*", "(", "asort", "[", "s", "-", "1", "]", "-", "asort", "[", "s", "-", "1", "-", "1", "]", ")", ":", "\n", "      ", "alp", "=", "(", "2", "*", "asort", "[", "s", "-", "1", "]", "+", "asort", "[", "s", "-", "1", "-", "1", "]", ")", "/", "3", "\n", "\n", "", "return", "alp", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lspar.lspar": [[11, 77], ["src.optimization.parameter.mcs.gls.lssort.lssort", "src.optimization.parameter.mcs.gls.lsnew.lsnew", "min", "numpy.argmin", "src.optimization.parameter.mcs.gls.lsguard.lsguard", "src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "copy.deepcopy", "src.optimization.parameter.mcs.gls.lsnew.lsnew", "min", "range", "range", "range", "abs"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssort.lssort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsnew.lsnew", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsguard.lsguard", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsnew.lsnew"], ["def", "lspar", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ")", ":", "\n", "    ", "cont", "=", "1", "# continue?", "\n", "fac", "=", "short", "\n", "if", "s", "<", "3", ":", "\n", "        ", "alist", ",", "flist", ",", "alp", ",", "fac", "=", "lsnew", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "s", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fmed", ",", "unitlen", ")", "\n", "cont", "=", "0", "#", "\n", "\n", "#print('cond:',cont)", "\n", "", "if", "cont", ":", "\n", "# select three points for parabolic interpolation", "\n", "        ", "fmin", "=", "min", "(", "flist", ")", "# unused", "\n", "i", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "if", "i", "<=", "1", ":", "# first two", "\n", "            ", "ind", "=", "[", "j", "for", "j", "in", "range", "(", "3", ")", "]", "\n", "ii", "=", "copy", ".", "deepcopy", "(", "i", ")", "\n", "", "elif", "i", ">=", "s", "-", "2", ":", "# last two", "\n", "            ", "ind", "=", "[", "j", "for", "j", "in", "range", "(", "s", "-", "2", "-", "1", ",", "s", ")", "]", "\n", "ii", "=", "i", "-", "(", "s", "-", "1", ")", "+", "2", "# corrections for index", "\n", "", "else", ":", "\n", "            ", "ind", "=", "[", "j", "for", "j", "in", "range", "(", "ii", "-", "1", ",", "i", "+", "1", ")", "]", "\n", "ii", "=", "2", "-", "1", "# -1 for index", "\n", "\n", "# in natural order", "\n", "", "aa", "=", "[", "alist", "[", "j", "]", "for", "j", "in", "ind", "]", "\n", "# the local minimum is at ff(ii)", "\n", "ff", "=", "[", "flist", "[", "j", "]", "for", "j", "in", "ind", "]", "\n", "\n", "# get divided differences ", "\n", "f12", "=", "(", "ff", "[", "1", "]", "-", "ff", "[", "0", "]", ")", "/", "(", "aa", "[", "1", "]", "-", "aa", "[", "0", "]", ")", "\n", "f23", "=", "(", "ff", "[", "2", "]", "-", "ff", "[", "1", "]", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "1", "]", ")", "\n", "f123", "=", "(", "f23", "-", "f12", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "0", "]", ")", "\n", "\n", "# handle concave case", "\n", "if", "not", "(", "f123", ">", "0", ")", ":", "\n", "            ", "alist", ",", "flist", ",", "alp", ",", "fac", "=", "lsnew", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "s", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fmed", ",", "unitlen", ")", "\n", "#alist,flist,abest,fbest,fmed,up,down,monotone,minima,nmin,unitlen,s = lssort(alist,flist)", "\n", "cont", "=", "0", "\n", "\n", "", "", "if", "cont", ":", "\n", "# parabolic minimizer", "\n", "        ", "alp0", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", "-", "f23", "/", "f123", ")", "\n", "alp", "=", "lsguard", "(", "alp0", ",", "alist", ",", "amax", ",", "amin", ",", "small", ")", "\n", "alptol", "=", "small", "*", "(", "aa", "[", "2", "]", "-", "aa", "[", "0", "]", ")", "\n", "\n", "\n", "# handle infinities and close predictor", "\n", "if", "f123", "==", "np", ".", "Inf", "or", "min", "(", "[", "abs", "(", "i", "-", "alp", ")", "for", "i", "in", "alist", "]", ")", "<=", "alptol", ":", "\n", "# split best interval", "\n", "#if prt>1, disp('split best interval'); #", "\n", "            ", "if", "ii", "==", "0", "or", "(", "ii", "==", "1", "and", "(", "aa", "[", "1", "]", ">=", "0.5", "*", "(", "aa", "[", "0", "]", "+", "aa", "[", "2", "]", ")", ")", ")", ":", "\n", "                ", "alp", "=", "0.5", "*", "(", "aa", "[", "0", "]", "+", "aa", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "alp", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "np_print", "=", "alp0", "\n", "#print('parabolic predictor: alp0 = ',alp0)", "\n", "\n", "# add point to the list     # new function value", "\n", "", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "#if prt>1, abest_anew_xnew=[alist(i),alp,(x+alp*p)']; #     ", "\n", "#alist,flist,abest,fbest,fmed,up,down,monotone,minima,nmin,unitlen,s = lssort(alist,flist)", "\n", "\n", "", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", "=", "lssort", "(", "alist", ",", "flist", ")", "\n", "return", "alist", ",", "flist", ",", "abest", ",", "fbest", ",", "fmed", ",", "up", ",", "down", ",", "monotone", ",", "minima", ",", "nmin", ",", "unitlen", ",", "s", ",", "alp", ",", "fac", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsconvex.lsconvex": [[3, 20], ["range"], "function", ["None"], ["def", "lsconvex", "(", "alist", ",", "flist", ",", "nmin", ",", "s", ")", ":", "\n", "    ", "if", "nmin", ">", "1", ":", "\n", "        ", "convex", "=", "0", "\n", "", "else", ":", "\n", "        ", "convex", "=", "1", "\n", "for", "i", "in", "range", "(", "1", ",", "s", "-", "1", ")", ":", "\n", "            ", "f12", "=", "(", "flist", "[", "i", "]", "-", "flist", "[", "i", "-", "1", "]", ")", "/", "(", "alist", "[", "i", "]", "-", "alist", "[", "i", "-", "1", "]", ")", "\n", "f13", "=", "(", "flist", "[", "i", "]", "-", "flist", "[", "i", "+", "1", "]", ")", "/", "(", "alist", "[", "i", "]", "-", "alist", "[", "i", "+", "1", "]", ")", "\n", "f123", "=", "(", "f13", "-", "f12", ")", "/", "(", "alist", "[", "i", "+", "1", "]", "-", "alist", "[", "i", "-", "1", "]", ")", "\n", "if", "f123", "<", "0", ":", "\n", "#print('not convex')", "\n", "                ", "convex", "=", "0", "\n", "break", "\n", "", "", "if", "convex", ":", "\n", "            ", "nothing_to_do", "=", "'done!'", "\n", "#print('convex')", "\n", "", "", "return", "convex", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssplit.lssplit": [[7, 18], ["None"], "function", ["None"], ["def", "lssplit", "(", "i", ",", "alist", ",", "flist", ",", "short", ")", ":", "\n", "    ", "if", "flist", "[", "i", "]", "<", "flist", "[", "i", "+", "1", "]", ":", "\n", "        ", "fac", "=", "short", "\n", "", "elif", "flist", "[", "i", "]", ">", "flist", "[", "i", "+", "1", "]", ":", "\n", "        ", "fac", "=", "1", "-", "short", "\n", "", "else", ":", "\n", "        ", "fac", "=", "0.5", "\n", "\n", "", "alp", "=", "alist", "[", "i", "]", "+", "fac", "*", "(", "alist", "[", "i", "+", "1", "]", "-", "alist", "[", "i", "]", ")", "\n", "#if prt>2, disp(['split at ',num2str(alp)]); end;", "\n", "return", "alp", ",", "fac", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lsnew.lsnew": [[13, 73], ["src.optimization.parameter.mcs.jones.functions.feval", "alist.append", "flist.append", "max", "max", "max", "min", "numpy.argmax", "max", "src.optimization.parameter.mcs.gls.lssplit.lssplit", "max", "zip", "zip", "range", "len", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssplit.lssplit"], ["def", "lsnew", "(", "func", ",", "nloc", ",", "small", ",", "sinit", ",", "short", ",", "x", ",", "p", ",", "s", ",", "alist", ",", "flist", ",", "amin", ",", "amax", ",", "alp", ",", "abest", ",", "fmed", ",", "unitlen", ")", ":", "\n", "\n", "    ", "if", "alist", "[", "0", "]", "<=", "amin", ":", "\n", "# leftmost point already at boundary", "\n", "        ", "leftok", "=", "0", "\n", "", "elif", "flist", "[", "0", "]", ">=", "max", "(", "fmed", ",", "flist", "[", "1", "]", ")", ":", "\n", "# bad leftmost point", "\n", "# extrapolate only if no scale known or global search\t", "\n", "        ", "leftok", "=", "(", "sinit", "==", "1", "or", "nloc", ">", "1", ")", "\n", "", "else", ":", "\n", "# good interior leftmost point", "\n", "        ", "leftok", "=", "1", "\n", "\n", "", "if", "alist", "[", "s", "-", "1", "]", ">=", "amax", ":", "\n", "# rightmost point already at boundary", "\n", "        ", "rightok", "=", "0", "\n", "", "elif", "flist", "[", "s", "-", "1", "]", ">=", "max", "(", "fmed", ",", "flist", "[", "s", "-", "2", "]", ")", ":", "\n", "# bad rightmost point", "\n", "# extrapolate only if no scale known or global search\t", "\n", "        ", "rightok", "=", "(", "sinit", "==", "1", "or", "nloc", ">", "1", ")", "\n", "", "else", ":", "\n", "# good interior rightmost point", "\n", "        ", "rightok", "=", "1", "\n", "\n", "# number of intervals used in extrapolation step", "\n", "", "if", "sinit", "==", "1", ":", "\n", "        ", "step", "=", "s", "-", "1", "\n", "", "else", ":", "\n", "        ", "step", "=", "1", "\n", "\n", "", "fac", "=", "short", "\n", "# do the step", "\n", "if", "leftok", "and", "(", "flist", "[", "0", "]", "<", "flist", "[", "s", "-", "1", "]", "or", "(", "not", "rightok", ")", ")", ":", "\n", "#if prt>1, disp('extrapolate at left end point'); #", "\n", "        ", "extra", "=", "1", "\n", "al", "=", "alist", "[", "0", "]", "-", "(", "alist", "[", "0", "+", "step", "]", "-", "alist", "[", "0", "]", ")", "/", "small", "\n", "alp", "=", "max", "(", "amin", ",", "al", ")", "\n", "", "elif", "rightok", ":", "\n", "#if prt>1, disp('extrapolate at right end point'); #", "\n", "        ", "extra", "=", "1", ";", "\n", "au", "=", "alist", "[", "s", "-", "1", "]", "+", "(", "alist", "[", "s", "-", "1", "]", "-", "alist", "[", "s", "-", "1", "-", "step", "]", ")", "/", "small", "\n", "alp", "=", "min", "(", "au", ",", "amax", ")", "\n", "", "else", ":", "\n", "# no extrapolation", "\n", "#if prt>1, disp('split relatively widest interval'); #", "\n", "        ", "extra", "=", "0", "\n", "lenth", "=", "[", "i", "-", "j", "for", "i", ",", "j", "in", "zip", "(", "alist", "[", "1", ":", "s", "]", ",", "alist", "[", "0", ":", "s", "-", "1", "]", ")", "]", "\n", "dist", "=", "[", "max", "(", "i", ",", "j", ",", "k", ")", "for", "i", ",", "j", ",", "k", "in", "zip", "(", "[", "i", "-", "abest", "for", "i", "in", "alist", "[", "1", ":", "s", "]", "]", ",", "[", "abest", "-", "i", "for", "i", "in", "alist", "[", "0", ":", "s", "-", "1", "]", "]", ",", "(", "unitlen", "*", "np", ".", "ones", "(", "s", "-", "1", ")", ")", ".", "tolist", "(", ")", ")", "]", "\n", "wid", "=", "[", "lenth", "[", "i", "]", "/", "dist", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "lenth", ")", ")", "]", "\n", "i", "=", "np", ".", "argmax", "(", "wid", ")", "\n", "wid", "=", "max", "(", "wid", ")", "\n", "alp", ",", "fac", "=", "lssplit", "(", "i", ",", "alist", ",", "flist", ",", "short", ")", "\n", "\n", "# new function value", "\n", "", "falp", "=", "feval", "(", "func", ",", "x", "+", "alp", "*", "p", ")", "\n", "alist", ".", "append", "(", "alp", ")", "\n", "flist", ".", "append", "(", "falp", ")", "\n", "\n", "\n", "return", "alist", ",", "flist", ",", "alp", ",", "fac", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.lssat.lssat": [[5, 37], ["min", "numpy.argmin", "max", "range", "range", "min", "abs"], "function", ["None"], ["def", "lssat", "(", "small", ",", "alist", ",", "flist", ",", "alp", ",", "amin", ",", "amax", ",", "s", ",", "saturated", ")", ":", "\n", "    ", "cont", "=", "saturated", "#", "\n", "\n", "if", "cont", ":", "\n", "# check boundary minimizer", "\n", "        ", "fmin", "=", "min", "(", "flist", ")", "\n", "i", "=", "np", ".", "argmin", "(", "flist", ")", "#", "\n", "if", "i", "==", "0", "or", "i", "==", "s", "-", "1", ":", "\n", "            ", "cont", "=", "0", "\n", "\n", "", "", "if", "cont", ":", "\n", "# select three points for parabolic interpolation", "\n", "        ", "aa", "=", "[", "alist", "[", "j", "]", "for", "j", "in", "range", "(", "i", "-", "1", ",", "i", "+", "1", "+", "1", ")", "]", "\n", "ff", "=", "[", "flist", "[", "j", "]", "for", "j", "in", "range", "(", "i", "-", "1", ",", "i", "+", "1", "+", "1", ")", "]", "\n", "\n", "# get divided differences ", "\n", "f12", "=", "(", "ff", "[", "1", "]", "-", "ff", "[", "0", "]", ")", "/", "(", "aa", "[", "1", "]", "-", "aa", "[", "0", "]", ")", "#", "\n", "f23", "=", "(", "ff", "[", "2", "]", "-", "ff", "[", "1", "]", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "1", "]", ")", "#", "\n", "f123", "=", "(", "f23", "-", "f12", ")", "/", "(", "aa", "[", "2", "]", "-", "aa", "[", "0", "]", ")", "#", "\n", "\n", "if", "f123", ">", "0", ":", "\n", "# parabolic minimizer", "\n", "            ", "alp", "=", "0.5", "*", "(", "aa", "[", "1", "]", "+", "aa", "[", "2", "]", "-", "f23", "/", "f123", ")", "#", "\n", "alp", "=", "max", "(", "amin", ",", "min", "(", "alp", ",", "amax", ")", ")", "#", "\n", "alptol", "=", "small", "*", "(", "aa", "[", "2", "]", "-", "aa", "[", "0", "]", ")", "#", "\n", "saturated", "=", "(", "abs", "(", "alist", "[", "i", "]", "-", "alp", ")", "<=", "alptol", ")", "\n", "", "else", ":", "\n", "            ", "saturated", "=", "0", "\n", "", "if", "not", "saturated", ":", "\n", "            ", "no_print", "=", "0", "\n", "#print('saturation check negative')", "\n", "", "", "return", "alp", ",", "saturated", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldldown.ldldown": [[10, 41], ["numpy.asarray", "numpy.asarray", "numpy.asarray", "src.optimization.parameter.mcs.minq.ldlrk1.ldlrk1", "scipy.sparse.coo_matrix().toarray", "scipy.sparse.coo_matrix().toarray", "len", "numpy.concatenate", "numpy.concatenate", "numpy.asarray", "range", "range", "scipy.sparse.coo_matrix", "len", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "scipy.sparse.coo_matrix", "scipy.sparse.coo_matrix().toarray", "scipy.sparse.coo_matrix().toarray", "scipy.sparse.coo_matrix", "scipy.sparse.coo_matrix"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldlrk1.ldlrk1"], ["def", "ldldown", "(", "L", ",", "d", ",", "j", ")", ":", "\n", "    ", "n", "=", "d", ".", "shape", "[", "0", "]", "\n", "if", "j", "<", "n", ":", "\n", "        ", "I", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "j", ")", "]", "\n", "K", "=", "[", "i", "for", "i", "in", "range", "(", "j", "+", "1", ",", "n", ")", "]", "\n", "\n", "LKK", "=", "np", ".", "asarray", "(", "[", "[", "L", "[", "i", ",", "j", "]", "for", "j", "in", "K", "]", "for", "i", "in", "K", "]", ")", "\n", "dK", "=", "np", ".", "asarray", "(", "[", "d", "[", "i", "]", "for", "i", "in", "K", "]", ")", "\n", "LKj", "=", "np", ".", "asarray", "(", "[", "L", "[", "i", ",", "j", "]", "for", "i", "in", "K", "]", ")", "\n", "LKK", ",", "dK", ",", "_", "=", "ldlrk1", "(", "LKK", ",", "dK", ",", "d", "[", "j", "]", ",", "LKj", ")", "\n", "d", "[", "K", "]", "=", "dK", "\n", "# work around expensive sparse L(K,K)=LKK", "\n", "r1", "=", "L", "[", "I", ",", ":", "]", "\n", "r2", "=", "sparse", ".", "coo_matrix", "(", "(", "1", ",", "n", ")", ")", ".", "toarray", "(", ")", "\n", "if", "len", "(", "I", ")", "==", "0", ":", "\n", "            ", "r3", "=", "np", ".", "concatenate", "(", "(", "sparse", ".", "coo_matrix", "(", "(", "n", "-", "j", "-", "1", ",", "1", ")", ")", ".", "toarray", "(", ")", ",", "LKK", ")", ",", "axis", "=", "1", ")", "\n", "L", "=", "np", ".", "concatenate", "(", "(", "r2", ",", "r3", ")", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "LKI", "=", "np", ".", "asarray", "(", "[", "[", "L", "[", "i", ",", "j", "]", "for", "j", "in", "I", "]", "for", "i", "in", "K", "]", ")", "\n", "#LKI = LKI.reshape((len(L[K,I]),1))", "\n", "if", "len", "(", "K", ")", "!=", "0", ":", "\n", "                ", "r3", "=", "np", ".", "concatenate", "(", "(", "LKI", ",", "sparse", ".", "coo_matrix", "(", "(", "n", "-", "j", "-", "1", ",", "1", ")", ")", ".", "toarray", "(", ")", ",", "LKK", ")", ",", "axis", "=", "1", ")", "\n", "#r1.shape, r2.shape, r3.shape", "\n", "L", "=", "np", ".", "concatenate", "(", "(", "r1", ",", "r2", ",", "r3", ")", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "                ", "L", "=", "np", ".", "concatenate", "(", "(", "r1", ",", "r2", ")", ",", "axis", "=", "0", ")", "\n", "", "", "L", "[", "j", ",", "j", "]", "=", "1", "\n", "", "else", ":", "\n", "        ", "L", "[", "n", "-", "1", ",", "0", ":", "n", "-", "1", "]", "=", "sparse", ".", "coo_matrix", "(", "(", "1", ",", "n", "-", "1", ")", ")", ".", "toarray", "(", ")", "\n", "", "d", "[", "j", "]", "=", "1", "\n", "return", "L", ",", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minqdef.minqdef": [[4, 61], ["numpy.linalg.cholesky", "numpy.divide", "numpy.dot", "numpy.linalg.solve", "numpy.zeros", "numpy.asarray", "optimization.parameter.mcs.minq.minq.minq", "numpy.linalg.solve", "numpy.dot", "min", "optimization.parameter.mcs.minq.minq.minq", "numpy.dot", "numpy.dot", "min", "np.linalg.cholesky.diagonal", "numpy.dot", "numpy.zeros", "numpy.dot", "numpy.dot", "numpy.add", "numpy.linalg.solve", "numpy.dot", "numpy.dot", "numpy.add", "numpy.dot", "numpy.dot", "numpy.add", "numpy.dot", "numpy.count_nonzero", "numpy.dot", "abs().reshape", "min", "range", "numpy.dot", "numpy.count_nonzero", "numpy.dot", "abs().reshape", "min", "range", "numpy.count_nonzero", "numpy.dot", "abs().reshape", "min", "range", "range", "abs", "abs().reshape", "len", "len", "abs", "range", "abs", "abs().reshape", "len", "len", "abs", "abs().reshape", "len", "len", "abs", "range", "abs", "len", "abs", "abs", "numpy.squrt", "len", "abs", "len", "abs", "len", "abs", "len", "numpy.count_nonzero"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq"], ["def", "minqdef", "(", "c", ",", "G", ",", "A", ",", "b", ",", "eq", ",", "prt", ")", ":", "\n", "    ", "eps", "=", "2.2204e-16", "\n", "\n", "m", "=", "A", ".", "shape", "[", "0", "]", "\n", "n", "=", "A", ".", "shape", "[", "1", "]", "\n", "\n", "R", "=", "np", ".", "linalg", ".", "cholesky", "(", "G", ")", "\n", "\n", "A0", "=", "np", ".", "divide", "(", "A", ",", "R", ".", "diagonal", "(", ")", ")", "\n", "GG", "=", "np", ".", "dot", "(", "A0", ",", "A0", ".", "T", ")", "\n", "c0", "=", "np", ".", "linalg", ".", "solve", "(", "R", ".", "T", ",", "c", ")", "\n", "cc", "=", "-", "b", "-", "np", ".", "dot", "(", "A0", ",", "c0", ")", "\n", "yo", "=", "np", ".", "Inf", "+", "np", ".", "zeros", "(", "m", ")", "\n", "yu", "=", "np", ".", "zeros", "(", "m", ")", "\n", "yu", "=", "np", ".", "asarray", "(", "[", "-", "yo", "[", "i", "]", "if", "eq", "[", "i", "]", "else", "yu", "[", "i", "]", "for", "i", "in", "range", "(", "eq", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n", "y", ",", "fct", ",", "ier", "=", "minq", "(", "0", ",", "cc", ",", "GG", ",", "yu", ",", "yo", ",", "prt", ")", "\n", "\n", "x", "=", "np", ".", "linalg", ".", "solve", "(", "R", ",", "(", "np", ".", "dot", "(", "A0", ".", "T", ",", "y", ")", "-", "c0", ")", ")", "#R\\(A0'*y-c0);", "\n", "if", "ier", "==", "99", ":", "\n", "        ", "return", "x", ",", "y", ",", "ier", "\n", "\n", "# check for accuracy", "\n", "", "res", "=", "np", ".", "dot", "(", "A", ",", "x", ")", "-", "b", "\n", "ressmall", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "np", ".", "count_nonzero", "(", "A", ")", ",", "eps", ")", ",", "np", ".", "add", "(", "np", ".", "dot", "(", "abs", "(", "A", ")", ",", "abs", "(", "x", ")", ".", "reshape", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", ")", ",", "abs", "(", "b", ")", ".", "reshape", "(", "len", "(", "b", ")", ",", "1", ")", ")", ")", "\n", "res", "=", "[", "min", "(", "res", "[", "i", "]", ",", "0", ")", "if", "not", "eq", "[", "i", "]", "else", "res", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", "\n", "\n", "if", "min", "(", "[", "abs", "(", "res", "[", "i", "]", ")", "<=", "ressmall", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", ")", ":", "\n", "# accuracy satisfactory", "\n", "        ", "ier", "=", "0", "#", "\n", "return", "x", ",", "y", ",", "ier", "\n", "\n", "\n", "# one step of iterative refinement", "\n", "\n", "", "dy", ",", "fct", ",", "ier", "=", "minq", "(", "0", ",", "-", "res", ",", "GG", ",", "yu", "-", "y", ",", "yo", "-", "y", ",", "prt", ")", "\n", "x", "=", "x", "+", "np", ".", "linalg", ".", "solve", "(", "R", ",", "(", "np", ".", "dot", "(", "A0", ".", "T", ",", "dy", ")", ")", ")", "# x=x+R\\(A0'*dy);", "\n", "y", "=", "y", "+", "dy", "\n", "\n", "#% check for accuracy", "\n", "res", "=", "np", ".", "dot", "(", "A", ",", "x", ")", "-", "b", "\n", "ressmall", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "np", ".", "count_nonzero", "(", "A", ")", ",", "eps", ")", ",", "np", ".", "add", "(", "np", ".", "dot", "(", "abs", "(", "A", ")", ",", "abs", "(", "x", ")", ".", "reshape", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", ")", ",", "abs", "(", "b", ")", ".", "reshape", "(", "len", "(", "b", ")", ",", "1", ")", ")", ")", "\n", "res", "=", "[", "min", "(", "res", "[", "i", "]", ",", "0", ")", "if", "not", "eq", "[", "i", "]", "else", "res", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", "\n", "\n", "# check for accuracy", "\n", "res", "=", "np", ".", "dot", "(", "A", ",", "x", ")", "-", "b", "\n", "ressmall", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "np", ".", "count_nonzero", "(", "A", ")", ",", "eps", ")", ",", "np", ".", "add", "(", "np", ".", "dot", "(", "abs", "(", "A", ")", ",", "abs", "(", "x", ")", ".", "reshape", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", ")", ",", "abs", "(", "b", ")", ".", "reshape", "(", "len", "(", "b", ")", ",", "1", ")", ")", ")", "\n", "res", "=", "[", "min", "(", "res", "[", "i", "]", ",", "0", ")", "if", "not", "eq", "[", "i", "]", "else", "res", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", "\n", "\n", "if", "min", "(", "[", "abs", "(", "res", "[", "i", "]", ")", "<=", "(", "np", ".", "squrt", "(", "np", ".", "count_nonzero", "(", "A", ")", ")", "*", "ressmall", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", ")", ":", "\n", "# accuracy satisfactory", "\n", "        ", "ier", "=", "0", "\n", "", "else", ":", "\n", "# feasible set probably empty", "\n", "        ", "ier", "=", "1", "\n", "\n", "", "return", "x", ",", "y", ",", "ier", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq": [[7, 256], ["numpy.asarray", "numpy.zeros", "numpy.eye", "numpy.ones", "numpy.zeros", "print", "print", "print", "print", "locals", "numpy.zeros", "scipy.sparse.spdiags().toarray", "sum", "numpy.zeros", "print", "numpy.zeros", "max", "numpy.linalg.norm", "sys.exit", "numpy.dot", "numpy.dot", "src.optimization.parameter.mcs.minq.getalp.getalp", "numpy.dot", "min", "range", "scipy.sparse.spdiags", "numpy.zeros", "numpy.dot", "len", "src.optimization.parameter.mcs.minq.minqsub.minqsub", "numpy.diag", "min"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.getalp.getalp", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minqsub.minqsub"], ["def", "minq", "(", "gam", ",", "c", ",", "G", ",", "xu", ",", "xo", ",", "prt", ")", ":", "\n", "    ", "'''\n    # minimizes an affine quadratic form subject to simple bounds,\n    # using coordinate searches and reduced subspace minimizations\n    # using LDL^T factorization updates\n    #    min    fct  =  gam + c^T x + 0.5 x^T G x \n    #    s.t.   x in [xu,xo]    # xu <= xo is assumed\n    # where G is a symmetric n x n matrix, not necessarily definite\n    # (if G is indefinite, only a local minimum is found)\n    #\n    # if G is sparse, it is assumed that the ordering is such that\n    # a sparse modified Cholesky factorization is feasible\n    #\n    # prt\tprintlevel\n    # xx\tinitial guess (optional)\n    #\n    # x\tminimizer (but unbounded direction if ier = 1)\n    # fct\toptimal function value\n    # ier\t0  (local minimizer found)\n    # \t1  (unbounded below)\n    # \t99 (maxit exceeded)\n    # \t-1 (input error)\n    #\n    # calls getalp.m, ldl*.m, minqsub.m, pr01.m\n    '''", "\n", "#%%", "\n", "#gam,c,G,xu,xo,prt = 0,cc,G,yu,yo,prt #  SHOULD BE CLOSE FATER DEBUGGING", "\n", "\n", "#% initialization ", "\n", "convex", "=", "0", "\n", "n", "=", "G", ".", "shape", "[", "0", "]", "\n", "\n", "# check input data for consistency", "\n", "ier", "=", "0", "\n", "if", "G", ".", "shape", "[", "1", "]", "!=", "n", ":", "\n", "        ", "ier", "=", "-", "1", "\n", "print", "(", "'minq: Hessian has wrong dimension'", ")", "\n", "x", "=", "np", ".", "NAN", "+", "np", ".", "zeros", "(", "n", ")", "\n", "fct", "=", "np", ".", "NAN", "\n", "nsub", "=", "-", "1", "\n", "return", "x", ",", "fct", ",", "ier", "\n", "\n", "", "if", "c", ".", "shape", "[", "0", "]", "!=", "n", ":", "\n", "        ", "ier", "=", "-", "1", "\n", "print", "(", "'minq: linear term has wrong dimension'", ")", "\n", "\n", "", "if", "xu", ".", "shape", "[", "0", "]", "!=", "n", ":", "\n", "        ", "ier", "=", "-", "1", "\n", "print", "(", "'minq: lower bound has wrong dimension'", ")", "\n", "\n", "", "if", "xo", ".", "shape", "[", "0", "]", "!=", "n", ":", "\n", "        ", "ier", "=", "-", "1", "\n", "print", "(", "'minq: lower bound has wrong dimension'", ")", "\n", "\n", "", "if", "'xx'", "in", "locals", "(", ")", ":", "\n", "        ", "if", "xx", ".", "shape", "[", "0", "]", "!=", "n", ":", "\n", "            ", "ier", "=", "-", "1", "\n", "print", "(", "'minq: lower bound has wrong dimension'", ")", "\n", "", "", "else", ":", "\n", "# initialize trial point xx, function value fct and gradient g", "\n", "# cold start with absolutely smallest feasible point", "\n", "        ", "xx", "=", "np", ".", "zeros", "(", "n", ")", "\n", "\n", "", "if", "ier", "==", "-", "1", ":", "\n", "        ", "x", "=", "np", ".", "NAN", "+", "np", ".", "zeros", "(", "n", ")", "\n", "fct", "=", "np", ".", "NAN", "\n", "nsub", "=", "-", "1", "\n", "return", "x", ",", "fct", ",", "ier", "\n", "\n", "", "maxit", "=", "3", "*", "n", "# maximal number of iterations", "\n", "# this limits the work to about 1+4*maxit/n matrix multiplies", "\n", "# usually at most 2*n iterations are needed for convergence", "\n", "nitrefmax", "=", "3", "# maximal number of iterative refinement steps", "\n", "\n", "# force starting point into the box", "\n", "xx", "=", "np", ".", "asarray", "(", "[", "max", "(", "xu", "[", "i", "]", ",", "min", "(", "xx", "[", "i", "]", ",", "xo", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "len", "(", "xx", ")", ")", "]", ")", "\n", "\n", "# regularization for low rank problems", "\n", "eps", "=", "2.2204e-16", "\n", "hpeps", "=", "100", "*", "eps", "# perturbation in last two digits", "\n", "G", "=", "G", "+", "spdiags", "(", "hpeps", "*", "np", ".", "diag", "(", "G", ")", ",", "0", ",", "n", ",", "n", ")", ".", "toarray", "(", ")", "\n", "\n", "# initialize LDL^T factorization of G_KK", "\n", "K", "=", "np", ".", "zeros", "(", "n", ",", "dtype", "=", "bool", ")", "# initially no rows in factorization", "\n", "L", "=", "np", ".", "eye", "(", "n", ")", "\n", "dd", "=", "np", ".", "ones", "(", "n", ")", "\n", "\n", "# dummy initialization of indicator of free variables", "\n", "# will become correct after first coordinate search", "\n", "free", "=", "np", ".", "zeros", "(", "n", ",", "dtype", "=", "bool", ")", "\n", "nfree", "=", "0", "\n", "nfree_old", "=", "-", "1", "\n", "\n", "fct", "=", "np", ".", "Inf", "# best function value", "\n", "nsub", "=", "0", "# number of subspace steps", "\n", "unfix", "=", "1", "# allow variables to be freed in csearch?", "\n", "nitref", "=", "0", "# no iterative refinement steps so far", "\n", "improvement", "=", "1", "# improvement expected", "\n", "\n", "#print(gam,c,G,xu,xo,xx,K,L,dd)", "\n", "#%%", "\n", "# main loop: alternating coordinate and subspace searches ", "\n", "while", "1", ":", "\n", "#print('enter main loop')   #", "\n", "        ", "if", "np", ".", "linalg", ".", "norm", "(", "xx", ",", "np", ".", "inf", ")", "==", "np", ".", "inf", ":", "\n", "            ", "sys", ".", "exit", "(", "'infinite xx in minq.m'", ")", "\n", "\n", "", "g", "=", "np", ".", "dot", "(", "G", ",", "xx", ")", "+", "c", "\n", "fctnew", "=", "gam", "+", "np", ".", "dot", "(", "0.5", "*", "xx", ".", "T", ",", "(", "c", "+", "g", ")", ")", "\n", "#print(g,fctnew)", "\n", "if", "not", "improvement", ":", "\n", "# good termination ", "\n", "# print('terminate: no improvement in coordinate search')   ", "\n", "            ", "ier", "=", "0", "\n", "break", "\n", "", "elif", "nitref", ">", "nitrefmax", ":", "\n", "# good termination ", "\n", "# print('terminate: nitref>nitrefmax')", "\n", "            ", "ier", "=", "0", "\n", "break", "\n", "", "elif", "nitref", ">", "0", "and", "nfree_old", "==", "nfree", "and", "fctnew", ">=", "fct", ":", "# Ok Chacked", "\n", "# good termination ", "\n", "# print('terminate: nitref>0 and nfree_old == nfree and fctnew >= fct')   ", "\n", "            ", "ier", "=", "0", "\n", "break", "\n", "", "elif", "nitref", "==", "0", ":", "\n", "            ", "x", "=", "xx", "\n", "fct", "=", "min", "(", "fct", ",", "fctnew", ")", "\n", "", "else", ":", "# more accurate g and hence f if nitref>0", "\n", "            ", "x", "=", "xx", "\n", "fct", "=", "fctnew", "\n", "\n", "\n", "", "if", "nitref", "==", "0", "and", "nsub", ">=", "maxit", ":", "# ok checked", "\n", "#print('incomplete minimization, too many iterations, iteration limit exceeded maxit')", "\n", "            ", "ier", "=", "99", "\n", "break", "\n", "#print(g,x,fct,fctnew)", "\n", "#%%----------------------------------------------------------------------", "\n", "# coordinate search", "\n", "\n", "", "count", "=", "0", "# number of consecutive free steps", "\n", "k", "=", "-", "1", "# current coordinate searched (initilize to -index for python array shake)", "\n", "while", "1", ":", "\n", "            ", "while", "count", "<=", "n", ":", "# ok checked", "\n", "# find next free index (or next index if unfix)", "\n", "                ", "count", "=", "count", "+", "1", "\n", "if", "k", "==", "n", "-", "1", ":", "\n", "                    ", "k", "=", "-", "1", "# reset k to -1 for python array first index", "\n", "", "k", "=", "k", "+", "1", "# increase k", "\n", "if", "free", "[", "k", "]", "or", "unfix", ":", "\n", "                    ", "break", "\n", "# end while count <= n", "\n", "", "", "if", "count", ">", "n", ":", "\n", "#print('complete sweep performed without fixing a new active bound')", "\n", "                ", "break", "\n", "\n", "#print(k)            ", "\n", "", "q", "=", "G", "[", ":", ",", "k", "]", "\n", "alpu", "=", "xu", "[", "k", "]", "-", "x", "[", "k", "]", "\n", "alpo", "=", "xo", "[", "k", "]", "-", "x", "[", "k", "]", "# bounds on step", "\n", "#print(q,alpu,alpo)", "\n", "\n", "# find step size", "\n", "alp", ",", "lba", ",", "uba", ",", "ier", "=", "getalp", "(", "alpu", ",", "alpo", ",", "g", "[", "k", "]", ",", "q", "[", "k", "]", ")", "\n", "\n", "if", "ier", ":", "\n", "                ", "x", "=", "np", ".", "zeros", "(", "n", ")", "\n", "if", "lba", ":", "\n", "                    ", "x", "[", "k", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "                    ", "x", "[", "k", "]", "=", "1", "\n", "\n", "", "return", "x", ",", "fct", ",", "ier", "\n", "#print(x,fct,ier,nsub)", "\n", "break", "\n", "#end itr", "\n", "\n", "", "xnew", "=", "x", "[", "k", "]", "+", "alp", "\n", "if", "prt", "and", "nitref", ">", "0", ":", "\n", "                ", "xnew", ",", "alp", "\n", "\n", "", "if", "lba", "or", "xnew", "<=", "xu", "[", "k", "]", ":", "# ok checked", "\n", "# lower bound active", "\n", "#if prt>2: print([num2str[k], ' at lower bound'])   #", "\n", "                ", "if", "alpu", "!=", "0", ":", "\n", "                    ", "x", "[", "k", "]", "=", "xu", "[", "k", "]", "\n", "g", "=", "g", "+", "alpu", "*", "q", "\n", "count", "=", "0", "\n", "", "free", "[", "k", "]", "=", "0", "\n", "", "elif", "uba", "or", "xnew", ">=", "xo", "[", "k", "]", ":", "# OK checked", "\n", "# upper bound active", "\n", "#if prt>2, print([num2str[k], ' at upper bound'])   #", "\n", "                ", "if", "alpo", "!=", "0", ":", "\n", "                    ", "x", "[", "k", "]", "=", "xo", "[", "k", "]", "\n", "g", "=", "g", "+", "alpo", "*", "q", "\n", "count", "=", "0", "\n", "", "free", "[", "k", "]", "=", "0", "\n", "", "else", ":", "\n", "# no bound active", "\n", "#if prt>2, print([num2str[k], ' free'])   #", "\n", "                ", "if", "alp", "!=", "0.0", ":", "\n", "                    ", "if", "prt", ">", "1", "and", "not", "free", "[", "k", "]", ":", "\n", "                        ", "unfixstep", "=", "[", "x", "[", "k", "]", ",", "alp", "]", "\n", "", "x", "[", "k", "]", "=", "xnew", "\n", "g", "=", "g", "+", "alp", "*", "q", "\n", "free", "[", "k", "]", "=", "1", "\n", "#end if bound check", "\n", "#print(g)", "\n", "# end while of coordinate search", "\n", "\n", "\n", "", "", "", "nfree", "=", "sum", "(", "free", ")", "\n", "if", "(", "unfix", "and", "nfree_old", "==", "nfree", ")", ":", "\n", "# in exact arithmetic, we are already optimal", "\n", "# recompute gradient for iterative refinement", "\n", "            ", "g", "=", "np", ".", "dot", "(", "G", ",", "x", ")", "+", "c", "\n", "nitref", "=", "nitref", "+", "1", "\n", "#if prt>0:", "\n", "#    print('optimum found   iterative refinement tried')  ", "\n", "", "else", ":", "\n", "            ", "nitref", "=", "0", "\n", "", "nfree_old", "=", "nfree", "\n", "gain_cs", "=", "fct", "-", "gam", "-", "np", ".", "dot", "(", "0.5", "*", "x", ".", "T", ",", "(", "c", "+", "g", ")", ")", "\n", "improvement", "=", "(", "gain_cs", ">", "0", "or", "not", "unfix", ")", "\n", "# subspace search", "\n", "xx", "=", "x", "\n", "#%%", "\n", "if", "not", "improvement", "or", "nitref", ">", "nitrefmax", ":", "\n", "# optimal point found - nothing done", "\n", "            ", "nothing_to_do", "=", "'done!'", "\n", "", "elif", "nitref", ">", "nitrefmax", ":", "\n", "# enough refinement steps - nothing done", "\n", "            ", "nothing_to_do", "=", "'done!'", "\n", "", "elif", "nfree", "==", "0", ":", "\n", "# no free variables - no subspace step taken", "\n", "# print('no free variables - no subspace step taken')", "\n", "            ", "unfix", "=", "1", "\n", "", "else", ":", "\n", "# take a subspace step", "\n", "            ", "subdone", "=", "0", "\n", "nsub", ",", "free", ",", "L", ",", "dd", ",", "K", ",", "G", ",", "n", ",", "g", ",", "x", ",", "xo", ",", "xu", ",", "convex", ",", "xx", ",", "fct", ",", "nfree", ",", "alp", ",", "alpu", ",", "alpo", ",", "lba", ",", "uba", ",", "ier", ",", "unfix", ",", "subdone", "=", "minqsub", "(", "nsub", ",", "free", ",", "L", ",", "dd", ",", "K", ",", "G", ",", "n", ",", "g", ",", "x", ",", "xo", ",", "xu", ",", "convex", ",", "xx", ",", "fct", ",", "nfree", ",", "unfix", ",", "alp", ",", "alpu", ",", "alpo", ",", "lba", ",", "uba", ",", "ier", ",", "subdone", ")", "\n", "if", "not", "subdone", ":", "\n", "                ", "return", "x", ",", "fct", ",", "ier", "\n", "", "if", "ier", ":", "\n", "#print(itr)", "\n", "                ", "return", "x", ",", "fct", ",", "ier", "\n", "# end while of main loop", "\n", "", "", "", "return", "x", ",", "fct", ",", "ier", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldlrk1.ldlrk1": [[10, 68], ["numpy.asarray", "numpy.dot", "range", "range", "range", "numpy.zeros", "numpy.asarray", "numpy.asarray", "numpy.linalg.solve", "numpy.asarray", "len", "len", "pow", "range", "range", "range", "len"], "function", ["None"], ["def", "ldlrk1", "(", "L", ",", "d", ",", "alp", ",", "u", ")", ":", "\n", "    ", "p", "=", "[", "]", "\n", "if", "alp", "==", "0", ":", "\n", "        ", "return", "L", ",", "d", ",", "p", "\n", "\n", "\n", "#    tempL= L ", "\n", "#    tempd= d", "\n", "#    tempu = u", "\n", "##   ", "\n", "#    p=[]", "\n", "#    L = LKK", "\n", "#    d = dK", "\n", "#    alp = d[j] #-delta", "\n", "#    u = LKj #w", "\n", "\n", "", "eps", "=", "2.2204e-16", "\n", "n", "=", "u", ".", "shape", "[", "0", "]", "\n", "neps", "=", "n", "*", "eps", "\n", "\n", "# save old factorization", "\n", "L0", "=", "L", "\n", "d0", "=", "d", "\n", "\n", "# update", "\n", "for", "k", "in", "[", "i", "for", "i", "in", "range", "(", "n", ")", "if", "u", "[", "i", "]", "!=", "0", "]", ":", "\n", "        ", "delta", "=", "d", "[", "k", "]", "+", "alp", "*", "pow", "(", "u", "[", "k", "]", ",", "2", ")", "\n", "if", "alp", "<", "0", "and", "delta", "<=", "neps", ":", "\n", "# update not definite", "\n", "            ", "p", "=", "np", ".", "zeros", "(", "n", ")", "\n", "p", "[", "k", "]", "=", "1", "\n", "p0Krange", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "k", "+", "1", ")", "]", "\n", "p0K", "=", "np", ".", "asarray", "(", "[", "p", "[", "i", "]", "for", "i", "in", "p0Krange", "]", ")", "\n", "L0K", "=", "np", ".", "asarray", "(", "[", "[", "L", "[", "i", ",", "j", "]", "for", "j", "in", "p0Krange", "]", "for", "i", "in", "p0Krange", "]", ")", "\n", "p0K", "=", "np", ".", "linalg", ".", "solve", "(", "L0K", ",", "p0K", ")", "\n", "p", "=", "np", ".", "asarray", "(", "[", "p0K", "[", "i", "]", "if", "(", "i", "in", "p0Krange", ")", "else", "p", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "p", ")", ")", "]", ")", "\n", "# restore original factorization", "\n", "L", "=", "L0", "\n", "d", "=", "d0", "\n", "return", "L", ",", "d", ",", "p", "\n", "\n", "", "q", "=", "d", "[", "k", "]", "/", "delta", "\n", "d", "[", "k", "]", "=", "delta", "\n", "# in C, the following 3 lines would be done in a single loop", "\n", "ind", "=", "[", "i", "for", "i", "in", "range", "(", "k", "+", "1", ",", "n", ")", "]", "\n", "LindK", "=", "np", ".", "asarray", "(", "[", "L", "[", "i", ",", "k", "]", "for", "i", "in", "ind", "]", ")", "#.reshape((len(ind),1))", "\n", "uk", "=", "u", "[", "k", "]", "#.reshape((1,1))", "\n", "c", "=", "np", ".", "dot", "(", "LindK", ",", "uk", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "ind", ")", ")", ":", "\n", "            ", "L", "[", "ind", "[", "i", "]", ",", "k", "]", "=", "LindK", "[", "i", "]", "*", "q", "+", "(", "alp", "*", "u", "[", "k", "]", "/", "delta", ")", "*", "u", "[", "ind", "[", "i", "]", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "ind", ")", ")", ":", "\n", "            ", "u", "[", "ind", "[", "i", "]", "]", "=", "u", "[", "ind", "[", "i", "]", "]", "-", "c", "[", "i", "]", "\n", "\n", "", "alp", "=", "alp", "*", "q", "\n", "if", "alp", "==", "0", ":", "\n", "            ", "break", "\n", "", "", "return", "L", ",", "d", ",", "p", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minqsep.minqsep": [[6, 85], ["scipy.sparse.spdiags().toarray", "numpy.dot", "numpy.zeros", "numpy.asarray", "optimization.parameter.mcs.minq.minq.minq", "numpy.dot", "min", "optimization.parameter.mcs.minq.minq.minq", "numpy.dot", "min", "min", "sys.exit", "numpy.linalg.solve", "numpy.dot", "numpy.zeros", "numpy.dot", "numpy.dot", "numpy.add", "numpy.dot", "numpy.dot", "numpy.add", "scipy.sparse.spdiags", "numpy.dot", "numpy.count_nonzero", "numpy.dot", "abs().reshape", "min", "range", "numpy.dot", "numpy.count_nonzero", "numpy.dot", "abs().reshape", "min", "range", "range", "abs", "abs().reshape", "len", "len", "abs", "range", "abs", "abs().reshape", "len", "len", "abs", "range", "abs", "len", "abs", "numpy.squrt", "len", "abs", "len", "abs", "len", "numpy.count_nonzero"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq"], ["def", "minqsep", "(", "c", ",", "d", ",", "A", ",", "b", ",", "eq", ",", "prt", ")", ":", "\n", "    ", "'''\n        # minimizes a definite separable quadratic form\n        # subject to linear constraints\n        #    min    fct = c^T x + 0.5 x^T G x \n        #    s.t.   A x >= b, with equality at indices with eq=1\n        # where D=diag(d) is a definite n x n diagonal matrix\n        #\n        # if A is sparse, it is assumed that the ordering is such that\n        # a sparse Cholesky factorization of AA^T is feasible\n        #\n        # eq    characteristic vector of equalities\n        # prt\tprintlevel\n        # xx\tguess (optional)\n        #\n        # x\tminimizer (but unbounded direction if ier=1)\n        # y     Lagrange multiplier satisfying the KKT conditions\n        #       Dx=A^Ty-c, inf(y,Ax-b)=0 at indices with eq=0\n        # ier\t0  (global minimizer found)\n        # \t1  (approximate solution# feasible set probably empty)\n        # \t99 (approximate solution# maxit exceeded)\n        #\n        # Method: apply minq.m to the dual\n        #    min  0.5*(A^Ty-c)^TD^(-1)(A^Ty-c)-b^Ty \n        #    s.t. y(~eq)>=0\n        # x is recovered as x=D^(-1)(A^Ty-c)\n    '''", "\n", "#%%", "\n", "eps", "=", "2.2204e-16", "\n", "if", "min", "(", "d", ")", "<=", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'diagonal must be positive'", ")", "\n", "\n", "", "m", "=", "A", ".", "shape", "[", "0", "]", "\n", "n", "=", "A", ".", "shape", "[", "1", "]", "\n", "\n", "D", "=", "spdiags", "(", "d", ",", "0", ",", "n", ",", "n", ")", ".", "toarray", "(", ")", "\n", "G", "=", "np", ".", "dot", "(", "A", ",", "np", ".", "linalg", ".", "solve", "(", "D", ",", "A", ".", "T", ")", ")", "\n", "cc", "=", "-", "b", "-", "np", ".", "dot", "(", "A", ",", "(", "c", "/", "d", ")", ")", "\n", "yo", "=", "np", ".", "Inf", "+", "np", ".", "zeros", "(", "m", ")", "\n", "yu", "=", "np", ".", "zeros", "(", "m", ")", "\n", "yu", "=", "np", ".", "asarray", "(", "[", "-", "yo", "[", "i", "]", "if", "eq", "[", "i", "]", "else", "yu", "[", "i", "]", "for", "i", "in", "range", "(", "eq", ".", "shape", "[", "0", "]", ")", "]", ")", "\n", "\n", "#print(D,G,cc,yo,yu)", "\n", "#%%", "\n", "y", ",", "fct", ",", "ier", "=", "minq", "(", "0", ",", "cc", ",", "G", ",", "yu", ",", "yo", ",", "prt", ")", "\n", "\n", "x", "=", "(", "np", ".", "dot", "(", "A", ".", "T", ",", "y", ")", "-", "c", ")", "/", "d", "\n", "if", "ier", "==", "99", ":", "\n", "        ", "return", "x", ",", "y", ",", "ier", "\n", "\n", "# check for accuracy", "\n", "", "res", "=", "np", ".", "dot", "(", "A", ",", "x", ")", "-", "b", "\n", "ressmall", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "np", ".", "count_nonzero", "(", "A", ")", ",", "eps", ")", ",", "np", ".", "add", "(", "np", ".", "dot", "(", "abs", "(", "A", ")", ",", "abs", "(", "x", ")", ".", "reshape", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", ")", ",", "abs", "(", "b", ")", ".", "reshape", "(", "len", "(", "b", ")", ",", "1", ")", ")", ")", "\n", "res", "=", "[", "min", "(", "res", "[", "i", "]", ",", "0", ")", "if", "not", "eq", "[", "i", "]", "else", "res", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", "\n", "\n", "if", "min", "(", "[", "abs", "(", "res", "[", "i", "]", ")", "<=", "ressmall", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", ")", ":", "\n", "# accuracy satisfactory", "\n", "        ", "ier", "=", "0", "#", "\n", "return", "x", ",", "y", ",", "ier", "\n", "\n", "# one step of iterative refinement", "\n", "\n", "", "dy", ",", "fct", ",", "ier", "=", "minq", "(", "0", ",", "-", "res", ",", "G", ",", "yu", "-", "y", ",", "yo", "-", "y", ",", "prt", ")", "\n", "x", "=", "(", "np", ".", "dot", "(", "A", ".", "T", ",", "y", ")", "-", "c", ")", "/", "d", "\n", "y", "=", "y", "+", "dy", "\n", "\n", "# check for accuracy", "\n", "res", "=", "np", ".", "dot", "(", "A", ",", "x", ")", "-", "b", "\n", "ressmall", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "np", ".", "count_nonzero", "(", "A", ")", ",", "eps", ")", ",", "np", ".", "add", "(", "np", ".", "dot", "(", "abs", "(", "A", ")", ",", "abs", "(", "x", ")", ".", "reshape", "(", "(", "len", "(", "x", ")", ",", "1", ")", ")", ")", ",", "abs", "(", "b", ")", ".", "reshape", "(", "len", "(", "b", ")", ",", "1", ")", ")", ")", "\n", "res", "=", "[", "min", "(", "res", "[", "i", "]", ",", "0", ")", "if", "not", "eq", "[", "i", "]", "else", "res", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", "\n", "\n", "if", "min", "(", "[", "abs", "(", "res", "[", "i", "]", ")", "<=", "(", "np", ".", "squrt", "(", "np", ".", "count_nonzero", "(", "A", ")", ")", "*", "ressmall", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "res", ")", ")", "]", ")", ":", "\n", "# accuracy satisfactory", "\n", "        ", "ier", "=", "0", "\n", "", "else", ":", "\n", "# feasible set probably empty", "\n", "        ", "ier", "=", "1", "\n", "\n", "", "return", "x", ",", "y", ",", "ier", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.getalp.getalp": [[2, 55], ["abs"], "function", ["None"], ["def", "getalp", "(", "alpu", ",", "alpo", ",", "gTp", ",", "pTGp", ")", ":", "\n", "    ", "'''\n        #get minimizer alp in [alpu,alpo] for a univariate quadratic\n        #\tq(alp)=alp*gTp+0.5*alp^2*pTGp\n        #lba\tlower bound active\n        #uba\tupper bound active\n        #\n        #ier\t 0 (finite minimizer) \n        #\t 1 (unbounded minimum)\n    '''", "\n", "#alpu,alpo,gTp,pTGp = alpu,alpo,g[k],q[k] #  SHOULD BE CLOSE ATER DEBUGGING - OK", "\n", "\n", "lba", "=", "False", "\n", "uba", "=", "False", "\n", "\n", "#determine unboundedness", "\n", "ier", "=", "0", "\n", "if", "alpu", "==", "-", "np", ".", "Inf", "and", "(", "pTGp", "<", "0", "or", "(", "pTGp", "==", "0", "and", "gTp", ">", "0", ")", ")", ":", "\n", "        ", "ier", "=", "1", "\n", "lba", "=", "True", "\n", "", "if", "alpo", "==", "np", ".", "Inf", "and", "(", "pTGp", "<", "0", "or", "(", "pTGp", "==", "0", "and", "gTp", "<", "0", ")", ")", ":", "\n", "        ", "ier", "=", "1", "\n", "uba", "=", "True", "\n", "", "if", "ier", ":", "\n", "        ", "alp", "=", "np", ".", "NAN", "\n", "return", "alp", ",", "lba", ",", "uba", ",", "ier", "\n", "\n", "#determine activity", "\n", "", "if", "pTGp", "==", "0", "and", "gTp", "==", "0", ":", "\n", "        ", "alp", "=", "0", "\n", "", "elif", "pTGp", "<=", "0", ":", "\n", "#concave case minimal at a bound", "\n", "        ", "if", "alpu", "==", "-", "np", ".", "Inf", ":", "\n", "            ", "lba", "=", "False", "\n", "", "elif", "alpo", "==", "np", ".", "Inf", ":", "\n", "            ", "lba", "=", "True", "\n", "", "else", ":", "\n", "            ", "lba", "=", "(", "2", "*", "gTp", "+", "(", "alpu", "+", "alpo", ")", "*", "pTGp", ">", "0", ")", "\n", "# end  alpu == -np.Inf", "\n", "", "uba", "=", "not", "lba", "\n", "", "else", ":", "\n", "        ", "alp", "=", "-", "gTp", "/", "pTGp", "#unconstrained optimal step", "\n", "lba", "=", "(", "alp", "<=", "alpu", ")", "#lower bound active", "\n", "uba", "=", "(", "alp", ">=", "alpo", ")", "#upper bound active", "\n", "\n", "", "if", "lba", ":", "\n", "        ", "alp", "=", "alpu", "\n", "", "if", "uba", ":", "\n", "        ", "alp", "=", "alpo", "\n", "\n", "", "if", "abs", "(", "alp", ")", "==", "np", ".", "Inf", ":", "\n", "        ", "gTp", ",", "pTGp", ",", "alpu", ",", "alpo", ",", "alp", ",", "lba", ",", "uba", ",", "ier", "\n", "", "return", "alp", ",", "lba", ",", "uba", ",", "ier", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldlup.ldlup": [[14, 102], ["numpy.asarray", "numpy.linalg.solve", "numpy.divide", "numpy.zeros", "numpy.asarray", "numpy.dot", "numpy.asarray", "len", "numpy.asarray", "numpy.asarray", "numpy.divide", "numpy.asarray", "numpy.asarray", "src.optimization.parameter.mcs.minq.ldlrk1.ldlrk1", "len", "numpy.asarray", "np.concatenate.reshape", "numpy.concatenate", "numpy.concatenate", "w.reshape.reshape", "q.reshape", "numpy.dot", "numpy.multiply", "numpy.dot", "numpy.subtract", "numpy.linalg.solve", "numpy.asarray", "range", "range", "numpy.asarray", "numpy.subtract", "len", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "len", "np.multiply.flatten", "np.dot.flatten", "numpy.zeros().tolist", "numpy.dot", "L[].tolist", "len", "L[].reshape", "len", "q.tolist", "numpy.zeros().tolist", "numpy.linalg.solve().tolist", "np.zeros.T.tolist", "w.reshape.reshape", "len", "np.linalg.solve.flatten().tolist", "numpy.zeros", "len", "numpy.zeros", "numpy.linalg.solve", "np.linalg.solve.flatten"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldlrk1.ldlrk1"], ["def", "ldlup", "(", "L", ",", "d", ",", "j", ",", "g", ")", ":", "\n", "\n", "#tempg = g", "\n", "#L,d,j,g = L,dd,j,p", "\n", "\n", "    ", "p", "=", "[", "]", "\n", "eps", "=", "2.2204e-16", "\n", "n", "=", "d", ".", "shape", "[", "0", "]", "\n", "I", "=", "[", "i", "for", "i", "in", "range", "(", "0", ",", "j", ")", "]", "\n", "K", "=", "[", "i", "for", "i", "in", "range", "(", "j", "+", "1", ",", "n", ")", "]", "\n", "\n", "if", "j", "==", "0", ":", "\n", "        ", "v", "=", "np", ".", "zeros", "(", "0", ")", "\n", "delta", "=", "g", "[", "j", "]", "\n", "if", "delta", "<=", "n", "*", "eps", ":", "\n", "            ", "p", "=", "np", ".", "asarray", "(", "[", "1", "]", "+", "np", ".", "zeros", "(", "n", "-", "1", ")", ".", "tolist", "(", ")", ")", "\n", "#if test, ", "\n", "#  A,p", "\n", "#  Nenner=abs(p)'*abs(A)*abs(p) ", "\n", "#  if Nenner==0, indef1=0 ,else indef1=(p'*A*p)/Nenner, #", "\n", "#  disp('leave ldlup at 1')", "\n", "return", "L", ",", "d", ",", "p", "\n", "#end if delta", "\n", "", "w", "=", "[", "g", "[", "i", "]", "/", "delta", "for", "i", "in", "K", "]", "\n", "L", "[", "j", ",", "I", "]", "=", "v", ".", "T", "\n", "d", "[", "j", "]", "=", "delta", "\n", "p", "=", "np", ".", "asarray", "(", "p", ")", "\n", "return", "L", ",", "d", ",", "p", "\n", "# now j>1, K nonempty", "\n", "", "LII", "=", "np", ".", "asarray", "(", "[", "[", "L", "[", "i", ",", "j", "]", "for", "j", "in", "I", "]", "for", "i", "in", "I", "]", ")", "\n", "gI", "=", "[", "g", "[", "i", "]", "for", "i", "in", "I", "]", "\n", "u", "=", "np", ".", "linalg", ".", "solve", "(", "LII", ",", "gI", ")", "\n", "dI", "=", "[", "d", "[", "i", "]", "for", "i", "in", "I", "]", "\n", "v", "=", "np", ".", "divide", "(", "u", ",", "dI", ")", "\n", "delta", "=", "g", "[", "j", "]", "-", "np", ".", "dot", "(", "u", ".", "T", ",", "v", ")", "\n", "#print(LII,u,v,delta) # LII,u,v,del", "\n", "\n", "if", "delta", "<=", "n", "*", "eps", ":", "\n", "        ", "p", "=", "np", ".", "asarray", "(", "np", ".", "linalg", ".", "solve", "(", "LII", ".", "T", ",", "v", ")", ".", "tolist", "(", ")", "+", "[", "-", "1", "]", "+", "np", ".", "zeros", "(", "n", "-", "j", "-", "1", ")", ".", "tolist", "(", ")", ")", "\n", "#if test, ", "\n", "#A,p", "\n", "#indef1=(p'*A*p)/(abs(p)'*abs(A)*abs(p))", "\n", "#disp('leave ldlup at 2')", "\n", "return", "L", ",", "d", ",", "p", "\n", "\n", "", "if", "len", "(", "K", ")", "!=", "0", ":", "\n", "        ", "LKI", "=", "np", ".", "asarray", "(", "[", "[", "L", "[", "i", ",", "j", "]", "for", "j", "in", "I", "]", "for", "i", "in", "K", "]", ")", "\n", "gK", "=", "np", ".", "asarray", "(", "[", "g", "[", "i", "]", "for", "i", "in", "K", "]", ")", "\n", "w", "=", "np", ".", "divide", "(", "np", ".", "subtract", "(", "gK", ",", "np", ".", "dot", "(", "LKI", ",", "u", ")", ")", ",", "delta", ")", "\n", "LKK", "=", "np", ".", "asarray", "(", "[", "[", "L", "[", "i", ",", "j", "]", "for", "j", "in", "K", "]", "for", "i", "in", "K", "]", ")", "\n", "dK", "=", "np", ".", "asarray", "(", "[", "d", "[", "i", "]", "for", "i", "in", "K", "]", ")", "\n", "#print(LKI,w,LKK,dK,w)", "\n", "# call ldlrk1", "\n", "LKK", ",", "dK", ",", "q", "=", "ldlrk1", "(", "LKK", ",", "dK", ",", "-", "delta", ",", "w", ")", "\n", "d", "[", "K", "]", "=", "dK", "\n", "", "else", ":", "\n", "        ", "q", "=", "[", "]", "\n", "\n", "\n", "", "if", "len", "(", "q", ")", "==", "0", ":", "\n", "# work around expensive sparse L(K,K)=LKK", "\n", "#r1 = np.asarray([[L[i,j] for j in range(L.shape[1])] for i in I])", "\n", "        ", "r1", "=", "L", "[", "I", ",", ":", "]", "\n", "r2", "=", "np", ".", "asarray", "(", "v", ".", "T", ".", "tolist", "(", ")", "+", "[", "1", "]", "+", "L", "[", "j", ",", "K", "]", ".", "tolist", "(", ")", ")", "\n", "r2", "=", "r2", ".", "reshape", "(", "(", "1", ",", "len", "(", "r2", ")", ")", ")", "\n", "if", "len", "(", "K", ")", "!=", "0", ":", "\n", "            ", "r3", "=", "np", ".", "concatenate", "(", "(", "LKI", ",", "w", ".", "reshape", "(", "len", "(", "w", ")", ",", "1", ")", ",", "LKK", ")", ",", "axis", "=", "1", ")", "\n", "#r1.shape, r2.shape, r3.shape", "\n", "L", "=", "np", ".", "concatenate", "(", "(", "r1", ",", "r2", ",", "r3", ")", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "            ", "L", "=", "np", ".", "concatenate", "(", "(", "r1", ",", "r2", ")", ",", "axis", "=", "0", ")", "\n", "", "d", "[", "j", "]", "=", "delta", "\n", "", "else", ":", "\n", "# work around expensive sparse L(K,K)=LKK", "\n", "        ", "r1", "=", "L", "[", "0", ":", "j", "+", "1", ",", ":", "]", "\n", "r2", "=", "np", ".", "concatenate", "(", "(", "LKI", ",", "L", "[", "K", ",", "j", "]", ".", "reshape", "(", "len", "(", "L", "[", "K", ",", "j", "]", ")", ",", "1", ")", ",", "LKK", ")", ",", "axis", "=", "1", ")", "\n", "#r1.shape, r2.shape, ", "\n", "L", "=", "np", ".", "concatenate", "(", "(", "r1", ",", "r2", ")", ",", "axis", "=", "0", ")", "\n", "w", "=", "w", ".", "reshape", "(", "(", "len", "(", "w", ")", ",", "1", ")", ")", "\n", "q", ".", "reshape", "(", "(", "len", "(", "q", ")", ")", ",", "1", ")", "\n", "pi", "=", "np", ".", "dot", "(", "w", ".", "T", ",", "q", ")", "\n", "piv", "=", "np", ".", "multiply", "(", "pi", ",", "v", ")", "\n", "LKIq", "=", "np", ".", "dot", "(", "LKI", ".", "T", ",", "q", ")", "\n", "pivLKIq", "=", "np", ".", "subtract", "(", "piv", ".", "flatten", "(", ")", ",", "LKIq", ".", "flatten", "(", ")", ")", "\n", "piSolve", "=", "np", ".", "linalg", ".", "solve", "(", "LII", ".", "T", ",", "pivLKIq", ")", "\n", "p", "=", "np", ".", "asarray", "(", "piSolve", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "+", "(", "-", "1", "*", "pi", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "+", "q", ".", "tolist", "(", ")", ")", "\n", "#retrun value", "\n", "", "return", "L", ",", "d", ",", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minqsub.minqsub": [[8, 110], ["numpy.asarray", "max", "min", "numpy.dot", "numpy.dot", "numpy.dot", "src.optimization.parameter.mcs.minq.getalp.getalp", "range", "sum", "src.optimization.parameter.mcs.minq.ldldown.ldldown", "numpy.zeros", "src.optimization.parameter.mcs.minq.ldlup.ldlup", "numpy.zeros", "numpy.asarray", "numpy.linalg.solve", "numpy.divide", "numpy.multiply", "len", "numpy.subtract", "numpy.subtract", "sys.exit", "numpy.abs", "abs", "numpy.dot", "max", "numpy.zeros", "len", "range", "range", "numpy.asarray", "len", "numpy.linalg.solve", "range", "numpy.abs", "abs", "sys.exit", "len", "len", "len", "range", "range", "len", "range", "range", "range", "range", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.getalp.getalp", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldldown.ldldown", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.ldlup.ldlup"], ["def", "minqsub", "(", "nsub", ",", "free", ",", "L", ",", "dd", ",", "K", ",", "G", ",", "n", ",", "g", ",", "x", ",", "xo", ",", "xu", ",", "convex", ",", "xx", ",", "fct", ",", "nfree", ",", "unfix", ",", "alp", ",", "alpu", ",", "alpo", ",", "lba", ",", "uba", ",", "ier", ",", "subdone", ")", ":", "\n", "#nsub,fct,G,L,dd,K,g,xo,xu,x,xx,n,alpu,alpo,convex,alp,lba,uba,ier,free,nfree", "\n", "    ", "nsub", "=", "nsub", "+", "1", "\n", "eps", "=", "2.2204e-16", "\n", "# downdate factorization", "\n", "freelK", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "free", ")", ")", "if", "(", "free", "<", "K", ")", "[", "i", "]", "==", "True", "]", "\n", "for", "j", "in", "freelK", ":", "# list of newly active indices", "\n", "#print(j)", "\n", "        ", "L", ",", "dd", "=", "ldldown", "(", "L", ",", "dd", ",", "j", ")", "\n", "K", "[", "j", "]", "=", "False", "\n", "\n", "# update factorization or find indefinite search direchtion", "\n", "", "definite", "=", "1", "\n", "freeuK", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "free", ")", ")", "if", "(", "free", ">", "K", ")", "[", "i", "]", "==", "True", "]", "\n", "for", "j", "in", "freeuK", ":", "# list of newly freed indices", "\n", "#print(j)    ", "\n", "# later: speed up the following by passing K to ldlup.m!", "\n", "        ", "p", "=", "np", ".", "zeros", "(", "n", ")", "\n", "if", "n", ">", "1", ":", "\n", "            ", "p", "=", "np", ".", "asarray", "(", "[", "G", "[", "i", ",", "j", "]", "if", "K", "[", "i", "]", "==", "True", "else", "p", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "K", ")", ")", "]", ")", "\n", "", "p", "[", "j", "]", "=", "G", "[", "j", ",", "j", "]", "\n", "L", ",", "dd", ",", "p", "=", "ldlup", "(", "L", ",", "dd", ",", "j", ",", "p", ")", "\n", "definite", "=", "(", "len", "(", "p", ")", "==", "0", ")", "\n", "if", "not", "definite", ":", "\n", "#print('indefinite or illconditioned step') # ", "\n", "            ", "break", "\n", "", "K", "[", "j", "]", "=", "True", "\n", "\n", "\n", "", "if", "definite", ":", "\n", "# find reduced Newton direction ", "\n", "        ", "p", "=", "np", ".", "zeros", "(", "n", ")", "\n", "p", "=", "np", ".", "asarray", "(", "[", "g", "[", "i", "]", "if", "K", "[", "i", "]", "==", "True", "else", "p", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "K", ")", ")", "]", ")", "\n", "\n", "LPsolve", "=", "np", ".", "linalg", ".", "solve", "(", "L", ",", "p", ")", "\n", "LPsolve", "=", "np", ".", "divide", "(", "LPsolve", ",", "dd", ")", "\n", "p", "=", "np", ".", "multiply", "(", "-", "1", ",", "np", ".", "linalg", ".", "solve", "(", "L", ".", "T", ",", "LPsolve", ")", ")", "\n", "\n", "# set tiny entries to zero ", "\n", "", "p", "=", "(", "x", "+", "p", ")", "-", "x", "\n", "ind", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "p", ")", ")", "if", "p", "[", "i", "]", "!=", "0", "]", "\n", "if", "len", "(", "ind", ")", "==", "0", ":", "\n", "# zero direction", "\n", "#print('zero direction') #", "\n", "        ", "unfix", "=", "1", "\n", "subdone", "=", "0", "\n", "return", "nsub", ",", "free", ",", "L", ",", "dd", ",", "K", ",", "G", ",", "n", ",", "g", ",", "x", ",", "xo", ",", "xu", ",", "convex", ",", "xx", ",", "fct", ",", "nfree", ",", "alp", ",", "alpu", ",", "alpo", ",", "lba", ",", "uba", ",", "ier", ",", "unfix", ",", "subdone", "\n", "\n", "# find range of step sizes", "\n", "", "pp", "=", "np", ".", "asarray", "(", "[", "p", "[", "i", "]", "for", "i", "in", "ind", "]", ")", "\n", "oo", "=", "np", ".", "subtract", "(", "[", "xo", "[", "i", "]", "for", "i", "in", "ind", "]", ",", "[", "x", "[", "i", "]", "for", "i", "in", "ind", "]", ")", "/", "pp", "\n", "uu", "=", "np", ".", "subtract", "(", "[", "xu", "[", "i", "]", "for", "i", "in", "ind", "]", ",", "[", "x", "[", "i", "]", "for", "i", "in", "ind", "]", ")", "/", "pp", "\n", "alpu", "=", "max", "(", "[", "oo", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "pp", "[", "i", "]", "<", "0", "]", "+", "[", "uu", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "pp", "[", "i", "]", ">", "0", "]", "+", "[", "-", "np", ".", "inf", "]", ")", "\n", "alpo", "=", "min", "(", "[", "oo", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "pp", "[", "i", "]", ">", "0", "]", "+", "[", "uu", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "pp", "[", "i", "]", "<", "0", "]", "+", "[", "np", ".", "inf", "]", ")", "\n", "if", "alpo", "<=", "0", "or", "alpu", ">=", "0", ":", "\n", "        ", "sys", ".", "exit", "(", "'programming error: no alp'", ")", "\n", "\n", "# find step size ", "\n", "", "gTp", "=", "np", ".", "dot", "(", "g", ".", "T", ",", "p", ")", "\n", "agTp", "=", "np", ".", "dot", "(", "np", ".", "abs", "(", "g", ")", ".", "T", ",", "np", ".", "abs", "(", "p", ")", ")", "\n", "if", "abs", "(", "gTp", ")", "<", "100", "*", "eps", "*", "agTp", ":", "\n", "# linear term consists of roundoff only", "\n", "        ", "gTp", "=", "0", "\n", "\n", "", "pTGp", "=", "np", ".", "dot", "(", "p", ".", "T", ",", "np", ".", "dot", "(", "G", ",", "p", ")", ")", "\n", "if", "convex", ":", "\n", "        ", "pTGp", "=", "max", "(", "0", ",", "pTGp", ")", "\n", "", "if", "not", "definite", "and", "pTGp", ">", "0", ":", "\n", "#if prt, disp(['tiny pTGp = ',num2str(pTGp),' set to zero'])  #", "\n", "        ", "pTGp", "=", "0", "\n", "\n", "", "alp", ",", "lba", ",", "uba", ",", "ier", "=", "getalp", "(", "alpu", ",", "alpo", ",", "gTp", ",", "pTGp", ")", "\n", "\n", "if", "ier", ":", "\n", "        ", "x", "=", "np", ".", "zeros", "(", "n", ")", "\n", "if", "lba", ":", "\n", "            ", "x", "=", "-", "p", "\n", "", "else", ":", "\n", "            ", "x", "=", "p", "\n", "", "return", "nsub", ",", "free", ",", "L", ",", "dd", ",", "K", ",", "G", ",", "n", ",", "g", ",", "x", ",", "xo", ",", "xu", ",", "convex", ",", "xx", ",", "fct", ",", "nfree", ",", "alp", ",", "alpu", ",", "alpo", ",", "lba", ",", "uba", ",", "ier", ",", "unfix", ",", "subdone", "\n", "\n", "", "unfix", "=", "not", "(", "lba", "or", "uba", ")", "# allow variables to be freed in csearch?    ", "\n", "# update of xx", "\n", "for", "k", "in", "range", "(", "0", ",", "len", "(", "ind", ")", ")", ":", "\n", "# avoid roundoff for active bounds ", "\n", "        ", "ik", "=", "ind", "[", "k", "]", "\n", "if", "alp", "==", "uu", "[", "k", "]", ":", "\n", "            ", "xx", "[", "ik", "]", "=", "xu", "[", "ik", "]", "\n", "free", "[", "ik", "]", "=", "0", "\n", "", "elif", "alp", "==", "oo", "[", "k", "]", ":", "\n", "            ", "xx", "[", "ik", "]", "=", "xo", "[", "ik", "]", "\n", "free", "[", "ik", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "xx", "[", "ik", "]", "=", "xx", "[", "ik", "]", "+", "alp", "*", "p", "[", "ik", "]", "\n", "\n", "", "if", "abs", "(", "xx", "[", "ik", "]", ")", "==", "np", ".", "Inf", ":", "\n", "            ", "ik", ",", "alp", ",", "p", "[", "ik", "]", "\n", "sys", ".", "exit", "(", "'infinite xx in minq'", ")", "\n", "\n", "", "", "nfree", "=", "sum", "(", "free", ")", "\n", "subdone", "=", "1", "\n", "return", "nsub", ",", "free", ",", "L", ",", "dd", ",", "K", ",", "G", ",", "n", ",", "g", ",", "x", ",", "xo", ",", "xu", ",", "convex", ",", "xx", ",", "fct", ",", "nfree", ",", "alp", ",", "alpu", ",", "alpo", ",", "lba", ",", "uba", ",", "ier", ",", "unfix", ",", "subdone", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq_data.minq_data": [[11, 95], ["numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "range", "range", "range"], "function", ["None"], ["def", "minq_data", "(", ")", ":", "\n", "    ", "'''\n        Store data for testing\n    '''", "\n", "A", "=", "[", "[", "0.814723686393179", ",", "0.157613081677548", ",", "0.655740699156587", ",", "0.706046088019609", ",", "0.438744359656398", ",", "0.276025076998578", ",", "0.751267059305653", "]", ",", "\n", "[", "0.905791937075619", ",", "0.970592781760616", ",", "0.0357116785741896", ",", "0.0318328463774207", ",", "0.381558457093008", ",", "0.679702676853675", ",", "0.255095115459269", "]", ",", "\n", "[", "0.126986816293506", ",", "0.957166948242946", ",", "0.849129305868777", ",", "0.276922984960890", ",", "0.765516788149002", ",", "0.655098003973841", ",", "0.505957051665142", "]", ",", "\n", "[", "0.913375856139019", ",", "0.485375648722841", ",", "0.933993247757551", ",", "0.0461713906311539", ",", "0.795199901137063", ",", "0.162611735194631", ",", "0.699076722656686", "]", ",", "\n", "[", "0.632359246225410", ",", "0.800280468888800", ",", "0.678735154857774", ",", "0.0971317812358475", ",", "0.186872604554379", ",", "0.118997681558377", ",", "0.890903252535799", "]", ",", "\n", "[", "0.0975404049994095", ",", "0.141886338627215", ",", "0.757740130578333", ",", "0.823457828327293", ",", "0.489764395788231", ",", "0.498364051982143", ",", "0.959291425205444", "]", ",", "\n", "[", "0.278498218867048", ",", "0.421761282626275", ",", "0.743132468124916", ",", "0.694828622975817", ",", "0.445586200710900", ",", "0.959743958516081", ",", "0.547215529963803", "]", ",", "\n", "[", "0.546881519204984", ",", "0.915735525189067", ",", "0.392227019534168", ",", "0.317099480060861", ",", "0.646313010111265", ",", "0.340385726666133", ",", "0.138624442828679", "]", ",", "\n", "[", "0.957506835434298", ",", "0.792207329559554", ",", "0.655477890177557", ",", "0.950222048838355", ",", "0.709364830858073", ",", "0.585267750979777", ",", "0.149294005559057", "]", ",", "\n", "[", "0.964888535199277", ",", "0.959492426392903", ",", "0.171186687811562", ",", "0.0344460805029088", ",", "0.754686681982361", ",", "0.223811939491137", ",", "0.257508254123736", "]", "]", "\n", "\n", "act", "=", "[", "False", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "\n", "b", "=", "[", "-", "18.6901875124796", ",", "\n", "-", "16.8904362435920", ",", "\n", "-", "15.8986255422475", ",", "\n", "-", "20.0976357102413", ",", "\n", "-", "16.1907062323890", ",", "\n", "-", "14.0867817199556", ",", "\n", "-", "16.6956324488426", ",", "\n", "-", "15.3834804641446", ",", "\n", "-", "23.7579747751283", ",", "\n", "-", "17.6097197484953", "]", "\n", "\n", "c", "=", "[", "0.840717255983663", ",", "\n", "0.254282178971531", ",", "\n", "0.814284826068816", ",", "\n", "0.243524968724989", ",", "\n", "0.929263623187228", ",", "\n", "0.349983765984809", ",", "\n", "0.196595250431208", "]", "\n", "\n", "d", "=", "[", "0.251083857976031", ",", "\n", "0.616044676146639", ",", "\n", "0.473288848902729", ",", "\n", "0.351659507062997", ",", "\n", "0.830828627896291", ",", "\n", "0.585264091152724", ",", "\n", "0.549723608291140", "]", "\n", "\n", "eq", "=", "[", "True", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "eq", "[", "0", "]", "=", "False", "\n", "\n", "m", "=", "10", "\n", "n", "=", "7", "\n", "p", "=", "0.800000000000000", "\n", "\n", "res", "=", "[", "0", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "\n", "xdes", "=", "[", "-", "9.69457699840680", ",", "\n", "-", "3.87769787266741", ",", "\n", "-", "4.87405027591913", ",", "\n", "-", "4.03608230757349", ",", "\n", "-", "2.82517769931242", ",", "\n", "-", "3.38217719527464", ",", "\n", "-", "2.61124230764327", "]", "\n", "\n", "ydes", "=", "[", "0.117193663829810", ",", "\n", "-", "0.514160981179627", ",", "\n", "-", "0.0427997708892788", ",", "\n", "-", "0.0462709057215047", ",", "\n", "-", "0.419554153024643", ",", "\n", "-", "0.232178359274779", ",", "\n", "-", "0.724145710436936", ",", "\n", "-", "0.746049881333393", ",", "\n", "-", "0.269202446991027", ",", "\n", "-", "0.0208327698979889", "]", "\n", "\n", "A", "=", "np", ".", "asarray", "(", "A", ")", "\n", "act", "=", "np", ".", "asarray", "(", "act", ")", "\n", "b", "=", "np", ".", "asarray", "(", "b", ")", "\n", "c", "=", "np", ".", "asarray", "(", "c", ")", "\n", "d", "=", "np", ".", "asarray", "(", "d", ")", "\n", "eq", "=", "np", ".", "asarray", "(", "eq", ")", "\n", "res", "=", "np", ".", "asarray", "(", "res", ")", "\n", "xdes", "=", "np", ".", "asarray", "(", "xdes", ")", "\n", "ydes", "=", "np", ".", "asarray", "(", "ydes", ")", "\n", "\n", "\n", "return", "A", ",", "act", ",", "b", ",", "c", ",", "d", ",", "eq", ",", "m", ",", "n", ",", "p", ",", "res", ",", "xdes", ",", "ydes", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.basket_func.basket": [[9, 82], ["numpy.zeros", "range", "numpy.sort", "numpy.argsort", "range", "len", "numpy.linalg.norm", "numpy.subtract", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.jones.functions.feval", "max", "min", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "min", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr"], ["def", "basket", "(", "fcn", ",", "x", ",", "f", ",", "xmin", ",", "fmi", ",", "xbest", ",", "fbest", ",", "stop", ",", "nbasket", ",", "nsweep", ",", "nsweepbest", ")", ":", "\n", "    ", "'''\n    '''", "\n", "loc", "=", "1", "\n", "flag", "=", "1", "\n", "ncall", "=", "0", "\n", "if", "not", "nbasket", ":", "\n", "        ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "x", ",", "f", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "\n", "", "dist", "=", "np", ".", "zeros", "(", "nbasket", "+", "1", ")", "\n", "for", "k", "in", "range", "(", "len", "(", "dist", ")", ")", ":", "\n", "        ", "dist", "[", "k", "]", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "subtract", "(", "x", ",", "xmin", "[", "k", "]", ")", ")", "\n", "\n", "", "dist1", "=", "np", ".", "sort", "(", "dist", ")", "\n", "ind", "=", "np", ".", "argsort", "(", "dist", ")", "\n", "\n", "for", "k", "in", "range", "(", "nbasket", "+", "1", ")", ":", "\n", "        ", "i", "=", "ind", "[", "k", "]", "\n", "if", "fmi", "[", "i", "]", "<=", "f", ":", "\n", "            ", "p", "=", "xmin", "[", "i", "]", "-", "x", "\n", "y1", "=", "x", "+", "1", "/", "3", "*", "p", "\n", "f1", "=", "feval", "(", "fcn", ",", "y1", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "if", "f1", "<=", "f", ":", "\n", "                ", "y2", "=", "x", "+", "2", "/", "3", "*", "p", "\n", "f2", "=", "feval", "(", "fcn", ",", "y2", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "if", "f2", ">", "max", "(", "f1", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                    ", "if", "f1", "<", "f", ":", "\n", "                        ", "x", "=", "y1", "\n", "f", "=", "f1", "\n", "if", "f", "<", "fbest", ":", "\n", "                            ", "fbest", "=", "f", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "nsweepbest", "=", "nsweep", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                                ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                                ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                                ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "x", ",", "f", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "", "", "", "", "else", ":", "\n", "                    ", "if", "f1", "<", "min", "(", "f2", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                        ", "f", "=", "f1", "\n", "x", "=", "copy", ".", "deepcopy", "(", "y1", ")", "\n", "if", "f", "<", "fbest", ":", "\n", "                            ", "fbest", "=", "f", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "nsweepbest", "=", "nsweep", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                                ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                                ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                                ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "x", ",", "f", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "", "", "elif", "f2", "<", "min", "(", "f1", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                            ", "f", "=", "f2", "\n", "x", "=", "copy", ".", "deepcopy", "(", "y2", ")", "\n", "if", "f", "<", "fbest", ":", "\n", "                                ", "fbest", "=", "f", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "nsweepbest", "=", "nsweep", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                                    ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                                    ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                                    ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "x", ",", "f", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "", "", "", "else", ":", "\n", "                            ", "loc", "=", "0", "\n", "break", "\n", "\n", "", "", "", "", "", "", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "x", ",", "f", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.basket_func.basket1": [[84, 164], ["numpy.zeros", "range", "numpy.sort", "numpy.argsort", "range", "len", "numpy.linalg.norm", "src.optimization.parameter.mcs.jones.functions.feval", "numpy.subtract", "max", "src.optimization.parameter.mcs.jones.functions.feval", "max", "min", "copy.deepcopy", "min", "copy.deepcopy", "copy.deepcopy", "min", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "min", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "min", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "min", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr"], ["", "def", "basket1", "(", "fcn", ",", "x", ",", "f", ",", "xmin", ",", "fmi", ",", "xbest", ",", "fbest", ",", "stop", ",", "nbasket", ",", "nsweep", ",", "nsweepbest", ")", ":", "\n", "    ", "'''\n    '''", "\n", "loc", "=", "1", "\n", "flag", "=", "1", "\n", "ncall", "=", "0", "\n", "if", "not", "nbasket", ":", "\n", "        ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "\n", "", "dist", "=", "np", ".", "zeros", "(", "nbasket", "+", "1", ")", "\n", "for", "k", "in", "range", "(", "len", "(", "dist", ")", ")", ":", "\n", "        ", "dist", "[", "k", "]", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "subtract", "(", "x", ",", "xmin", "[", "k", "]", ")", ")", "\n", "\n", "", "dist1", "=", "np", ".", "sort", "(", "dist", ")", "\n", "ind", "=", "np", ".", "argsort", "(", "dist", ")", "\n", "\n", "for", "k", "in", "range", "(", "nbasket", "+", "1", ")", ":", "\n", "        ", "i", "=", "ind", "[", "k", "]", "\n", "p", "=", "xmin", "[", "i", "]", "-", "x", "\n", "y1", "=", "x", "+", "1", "/", "3", "*", "p", "\n", "f1", "=", "feval", "(", "fcn", ",", "y1", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "if", "f1", "<=", "max", "(", "fmi", "[", "i", "]", ",", "f", ")", ":", "\n", "            ", "y2", "=", "x", "+", "2", "/", "3", "*", "p", "\n", "f2", "=", "feval", "(", "fcn", ",", "y2", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "if", "f2", "<=", "max", "(", "f1", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                ", "if", "f", "<", "min", "(", "min", "(", "f1", ",", "f2", ")", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                    ", "fmi", "[", "i", "]", "=", "f", "\n", "xmin", "[", "i", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "if", "fmi", "[", "i", "]", "<", "fbest", ":", "\n", "                        ", "fbest", "=", "copy", ".", "deepcopy", "(", "fmi", "[", "i", "]", ")", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "xmin", "[", "i", "]", ")", "\n", "nsweepbest", "=", "nsweep", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                            ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                            ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                            ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "#end fmi[i] < fbest:", "\n", "", "", "loc", "=", "0", "\n", "break", "\n", "", "elif", "f1", "<", "min", "(", "min", "(", "f", ",", "f2", ")", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                    ", "fmi", "[", "i", "]", "=", "f1", "\n", "xmin", "[", "i", "]", "=", "copy", ".", "deepcopy", "(", "y1", ")", "\n", "if", "fmi", "[", "i", "]", "<", "fbest", ":", "\n", "                        ", "fbest", "=", "copy", ".", "deepcopy", "(", "fmi", "[", "i", "]", ")", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "xmin", "[", "i", "]", ")", "\n", "nsweepbest", "=", "copy", ".", "deepcopy", "(", "nsweep", ")", "\n", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                            ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                            ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                            ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "#end fmi[i] < fbest: elif", "\n", "", "", "loc", "=", "0", "\n", "break", "\n", "", "elif", "f2", "<", "min", "(", "min", "(", "f", ",", "f1", ")", ",", "fmi", "[", "i", "]", ")", ":", "\n", "                    ", "fmi", "[", "i", "]", "=", "f2", "\n", "xmin", "[", "i", "]", "=", "copy", ".", "deepcopy", "(", "y2", ")", "\n", "if", "fmi", "[", "i", "]", "<", "fbest", ":", "\n", "                        ", "fbest", "=", "copy", ".", "deepcopy", "(", "fmi", "[", "i", "]", ")", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "xmin", "[", "i", "]", ")", "\n", "nsweepbest", "=", "nsweep", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                            ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                            ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "1", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                            ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "\n", "#end elseif ", "\n", "", "", "loc", "=", "0", "\n", "break", "\n", "", "else", ":", "\n", "                    ", "loc", "=", "0", "\n", "break", "\n", "", "", "", "", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "loc", ",", "flag", ",", "ncall", ",", "nsweep", ",", "nsweepbest", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox": [[4, 10], ["None"], "function", ["None"], ["def", "genbox", "(", "par", ",", "level0", ",", "nchild", ",", "f0", ")", ":", "\n", "    ", "ipar", "=", "par", "#  set parent box index", "\n", "level", "=", "level0", "#  set level value of the box", "\n", "ichild", "=", "nchild", "#  set number of child", "\n", "f", "=", "f0", "# set optimal value of the box", "\n", "return", "ipar", ",", "level", ",", "ichild", ",", "f", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.hessian.hessian": [[2, 11], ["pow", "pow"], "function", ["None"], ["def", "hessian", "(", "i", ",", "k", ",", "x", ",", "x0", ",", "f", ",", "f0", ",", "g", ",", "G", ")", ":", "\n", "    ", "'''\n    computes the element G(i,k) of the Hessian of the local quadratic model\n    '''", "\n", "#print(i,x[i],x0[i],f,f,g[i],G[i,i])", "\n", "#print(k,x[k],x0[k],f,f,g[k],G[k,k]) ", "\n", "h", "=", "f", "-", "f0", "-", "g", "[", "i", "]", "*", "(", "x", "[", "i", "]", "-", "x0", "[", "i", "]", ")", "-", "g", "[", "k", "]", "*", "(", "x", "[", "k", "]", "-", "x0", "[", "k", "]", ")", "-", "0.5", "*", "G", "[", "i", ",", "i", "]", "*", "(", "pow", "(", "(", "x", "[", "i", "]", "-", "x0", "[", "i", "]", ")", ",", "2", ")", ")", "-", "0.5", "*", "G", "[", "k", ",", "k", "]", "*", "pow", "(", "(", "x", "[", "k", "]", "-", "x0", "[", "k", "]", ")", ",", "2", ")", "\n", "h", "=", "h", "/", "(", "x", "[", "i", "]", "-", "x0", "[", "i", "]", ")", "/", "(", "x", "[", "k", "]", "-", "x0", "[", "k", "]", ")", "\n", "return", "h", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_bound.check_box_bound": [[3, 12], ["print", "print"], "function", ["None"], ["def", "check_box_bound", "(", "u", ",", "v", ")", ":", "\n", "    ", "if", "v", "<", "u", ":", "# upper bound < lowerbound", "\n", "        ", "print", "(", "'incompatible box bounds'", ")", "\n", "return", "True", "#  Program should stop", "\n", "", "elif", "(", "u", "==", "v", ")", ":", "\n", "        ", "print", "(", "'degenerate box bound'", ")", "\n", "return", "True", "#  Program should stop", "\n", "", "else", ":", "\n", "        ", "return", "False", "#  Program should runn", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_locks.chkloc": [[5, 12], ["range", "numpy.array_equal"], "function", ["None"], ["def", "chkloc", "(", "nloc", ",", "xloc", ",", "x", ")", ":", "\n", "    ", "loc", "=", "1", "\n", "for", "k", "in", "range", "(", "nloc", ")", ":", "\n", "        ", "if", "np", ".", "array_equal", "(", "x", ",", "xloc", "[", "k", "]", ")", ":", "\n", "            ", "loc", "=", "0", "\n", "break", "\n", "", "", "return", "loc", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_locks.addloc": [[14, 18], ["xloc.append", "copy.deepcopy"], "function", ["None"], ["", "def", "addloc", "(", "nloc", ",", "xloc", ",", "x", ")", ":", "\n", "    ", "nloc", "=", "nloc", "+", "1", "\n", "xloc", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "\n", "return", "nloc", ",", "xloc", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_locks.fbestloc": [[20, 26], ["copy.deepcopy", "copy.deepcopy"], "function", ["None"], ["", "def", "fbestloc", "(", "fmi", ",", "fbest", ",", "xmin", ",", "xbest", ",", "nbasket0", ",", "stop", ")", ":", "\n", "    ", "if", "fmi", "[", "nbasket0", "]", "<", "fbest", ":", "\n", "        ", "fbest", "=", "copy", ".", "deepcopy", "(", "fmi", "[", "nbasket0", "]", ")", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "xmin", "[", "nbasket0", "]", ")", "\n", "#flag = chrelerr(fbest,stop)", "\n", "", "return", "fbest", ",", "xbest", "#, flag", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vertex": [[8, 151], ["numpy.multiply", "numpy.multiply", "numpy.multiply", "numpy.multiply", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.ones", "int", "src.optimization.parameter.mcs.mcs_fun.split_func.split1", "vertex_func.vert3", "int", "abs", "vertex_func.vert1", "src.optimization.parameter.mcs.mcs_fun.updtf.updtf", "vertex_func.vert2", "src.optimization.parameter.mcs.mcs_fun.updtf.updtf", "math.ceil", "math.floor", "math.ceil", "int", "copy.deepcopy", "int", "src.optimization.parameter.mcs.mcs_fun.updtf.updtf", "abs", "vertex_func.vert1", "vertex_func.vert2", "math.floor", "vertex_func.vert3", "abs", "abs", "abs", "src.optimization.parameter.mcs.mcs_fun.split_func.split1", "abs", "abs", "abs"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split1", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert3", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert1", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtf.updtf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert2", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtf.updtf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtf.updtf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert1", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert2", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert3", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split1"], ["def", "vertex", "(", "j", ",", "n", ",", "u", ",", "v", ",", "v1", ",", "x0", ",", "f0", ",", "ipar", ",", "isplit", ",", "ichild", ",", "z", ",", "f", ",", "l", ",", "L", ")", ":", "\n", "    ", "'''\n        # initialization\n        # The coordinates of x, y, x1 and x2 are initially set to Inf to \n        # indicate that these quantities haven't been found yet in the course of\n        # pursuing the history of box j\n    '''", "\n", "x", "=", "np", ".", "multiply", "(", "np", ".", "Inf", ",", "np", ".", "ones", "(", "n", ")", ")", "\n", "y", "=", "np", ".", "multiply", "(", "np", ".", "Inf", ",", "np", ".", "ones", "(", "n", ")", ")", "\n", "x1", "=", "np", ".", "multiply", "(", "np", ".", "Inf", ",", "np", ".", "ones", "(", "n", ")", ")", "\n", "x2", "=", "np", ".", "multiply", "(", "np", ".", "Inf", ",", "np", ".", "ones", "(", "n", ")", ")", "\n", "f1", "=", "np", ".", "zeros", "(", "n", ")", "\n", "f2", "=", "np", ".", "zeros", "(", "n", ")", "\n", "# counting tthe number of time boxes has been split in ith direction", "\n", "n0", "=", "np", ".", "zeros", "(", "n", ")", "\n", "fold", "=", "f", "[", "0", ",", "j", "]", "\n", "m", "=", "j", "\n", "\n", "while", "m", ">", "0", ":", "\n", "        ", "if", "isplit", "[", "ipar", "[", "m", "]", "]", "<", "0", ":", "\n", "            ", "i", "=", "int", "(", "abs", "(", "isplit", "[", "ipar", "[", "m", "]", "]", ")", ")", "-", "1", "#  negative 1 for making index fit to array in python", "\n", "", "else", ":", "\n", "            ", "i", "=", "int", "(", "abs", "(", "isplit", "[", "ipar", "[", "m", "]", "]", ")", ")", "#  no negative ", "\n", "\n", "", "n0", "[", "i", "]", "=", "n0", "[", "i", "]", "+", "1", "# increase the counting tthe number of time boxes has been split in ith direction", "\n", "\n", "# ichild holds value from level 1 and not from level 0 there > 0 is ok", "\n", "if", "ichild", "[", "m", "]", "==", "1", ":", "\n", "            ", "if", "x", "[", "i", "]", "==", "np", ".", "Inf", "or", "x", "[", "i", "]", "==", "z", "[", "0", ",", "ipar", "[", "m", "]", "]", ":", "\n", "                ", "x", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", "=", "vert1", "(", "1", ",", "z", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "f", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "f1", ",", "f2", ",", "fold", "=", "updtf", "(", "n", ",", "i", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ",", "fold", ",", "f", "[", "0", ",", "ipar", "[", "m", "]", "]", ")", "\n", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", "=", "vert2", "(", "0", ",", "x", "[", "i", "]", ",", "z", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "f", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", ")", "\n", "", "", "elif", "ichild", "[", "m", "]", ">=", "2", ":", "\n", "            ", "f1", ",", "f2", ",", "fold", "=", "updtf", "(", "n", ",", "i", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ",", "fold", ",", "f", "[", "0", ",", "ipar", "[", "m", "]", "]", ")", "\n", "if", "x", "[", "i", "]", "==", "np", ".", "Inf", "or", "x", "[", "i", "]", "==", "z", "[", "1", ",", "ipar", "[", "m", "]", "]", ":", "\n", "                ", "x", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", "=", "vert1", "(", "0", ",", "z", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "f", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                ", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", "=", "vert2", "(", "1", ",", "x", "[", "i", "]", ",", "z", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "f", "[", ":", ",", "ipar", "[", "m", "]", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", ")", "\n", "\n", "# ichild holds value from level 1 and not from level 0 there > 0 is ok", "\n", "", "", "if", "1", "<=", "ichild", "[", "m", "]", "and", "ichild", "[", "m", "]", "<=", "2", "and", "y", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "            ", "y", "[", "i", "]", "=", "split1", "(", "z", "[", "0", ",", "ipar", "[", "m", "]", "]", ",", "z", "[", "1", ",", "ipar", "[", "m", "]", "]", ",", "f", "[", "0", ",", "ipar", "[", "m", "]", "]", ",", "f", "[", "1", ",", "ipar", "[", "m", "]", "]", ")", "\n", "\n", "# ichild holds value from level 1 and not from level 0 there > 0 is ok", "\n", "", "if", "ichild", "[", "m", "]", "<", "0", ":", "\n", "# box m was generated by splitting according to the init. list", "\n", "# x0[i,j1] = ith coordinate of the base vertex of box m", "\n", "# the ith coordinate of the opposite vertex is the golden section ", "\n", "# split of x0[i,j2] and x0[i,j2+1] for 1 <= j2 <= L[i] - 1, it is ", "\n", "# u[i] for j1 = 1 and v[i] for j2 = L[i] ", "\n", "# x0[i,j1+j3] = ith coordinate of the 'neighboring vertex'", "\n", "            ", "if", "u", "[", "i", "]", "<", "x0", "[", "i", ",", "0", "]", ":", "\n", "                ", "j1", "=", "math", ".", "ceil", "(", "abs", "(", "ichild", "[", "m", "]", ")", "/", "2", ")", "\n", "j2", "=", "math", ".", "floor", "(", "abs", "(", "ichild", "[", "m", "]", ")", "/", "2", ")", "\n", "if", "(", "abs", "(", "ichild", "[", "m", "]", ")", "/", "2", "<", "j1", "and", "j1", ">", "0", ")", "or", "j1", "==", "L", "[", "i", "]", "+", "1", ":", "\n", "                    ", "j3", "=", "-", "1", "\n", "", "else", ":", "\n", "                    ", "j3", "=", "1", "\n", "", "", "else", ":", "\n", "                ", "j1", "=", "math", ".", "floor", "(", "abs", "(", "ichild", "[", "m", "]", ")", "/", "2", ")", "+", "1", "\n", "j2", "=", "math", ".", "ceil", "(", "abs", "(", "ichild", "[", "m", "]", ")", "/", "2", ")", "\n", "if", "abs", "(", "ichild", "[", "m", "]", ")", "/", "2", "+", "1", ">", "j1", "and", "j1", "<", "L", "[", "i", "]", "+", "1", ":", "\n", "                    ", "j3", "=", "1", "\n", "", "else", ":", "\n", "                    ", "j3", "=", "-", "1", "\n", "#reduce index by 1 to fit to the dimenstion length for o to n-1", "\n", "", "", "j1", "-=", "1", "\n", "j2", "-=", "1", "\n", "\n", "if", "int", "(", "isplit", "[", "ipar", "[", "m", "]", "]", ")", "<", "0", ":", "# box m was generated in the init. procedure", "\n", "                ", "k", "=", "copy", ".", "deepcopy", "(", "i", ")", "\n", "", "else", ":", "\n", "# box m was generated by a later split according to the init.", "\n", "# list; k points to the corresponding function values  ", "\n", "                ", "k", "=", "int", "(", "z", "[", "0", ",", "ipar", "[", "m", "]", "]", ")", "\n", "\n", "", "if", "j1", "!=", "l", "[", "i", "]", "or", "(", "x", "[", "i", "]", "!=", "np", ".", "Inf", "and", "x", "[", "i", "]", "!=", "x0", "[", "i", ",", "l", "[", "i", "]", "]", ")", ":", "\n", "                ", "f1", ",", "f2", ",", "fold", "=", "updtf", "(", "n", ",", "i", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ",", "fold", ",", "f0", "[", "l", "[", "i", "]", ",", "k", "]", ")", "\n", "\n", "", "if", "x", "[", "i", "]", "==", "np", ".", "Inf", "or", "x", "[", "i", "]", "==", "x0", "[", "i", ",", "j1", "]", ":", "\n", "                ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "]", "\n", "if", "x1", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "                    ", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", "=", "vert3", "(", "j1", ",", "x0", "[", "i", ",", ":", "]", ",", "f0", "[", ":", ",", "k", "]", ",", "L", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", ")", "\n", "", "elif", "x2", "[", "i", "]", "==", "np", ".", "Inf", "and", "x1", "[", "i", "]", "!=", "x0", "[", "i", ",", "j1", "+", "j3", "]", ":", "\n", "                    ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "+", "j3", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "+", "j3", ",", "k", "]", "\n", "", "elif", "x2", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "                    ", "if", "j1", "!=", "1", "and", "j1", "!=", "L", "[", "i", "]", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "-", "j3", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "-", "j3", ",", "k", "]", "\n", "", "else", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "+", "2", "*", "j3", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "+", "2", "*", "j3", ",", "k", "]", "\n", "#end j1 != 1", "\n", "#end x1[i] == np.Inf", "\n", "", "", "", "else", ":", "\n", "                ", "if", "x1", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "                    ", "x1", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "]", "\n", "f1", "[", "i", "]", "=", "f1", "[", "i", "]", "+", "f0", "[", "j1", ",", "k", "]", "\n", "if", "x", "[", "i", "]", "!=", "x0", "[", "i", ",", "j1", "+", "j3", "]", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "+", "j3", "]", ";", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "+", "j3", ",", "k", "]", "\n", "# end  if x[i] != x0[i,j1+j3]", "\n", "", "", "elif", "x2", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "                    ", "if", "x1", "[", "i", "]", "!=", "x0", "[", "i", ",", "j1", "]", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", ",", "k", "]", "\n", "", "elif", "x", "[", "i", "]", "!=", "x0", "[", "i", ",", "j1", "+", "j3", "]", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "+", "j3", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "+", "j3", ",", "k", "]", "\n", "", "else", ":", "\n", "                        ", "if", "j1", "!=", "1", "and", "j1", "!=", "L", "[", "i", "]", ":", "\n", "                            ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "-", "j3", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "-", "j3", ",", "k", "]", "\n", "", "else", ":", "\n", "                            ", "x2", "[", "i", "]", "=", "x0", "[", "i", ",", "j1", "+", "2", "*", "j3", "]", "\n", "f2", "[", "i", "]", "=", "f2", "[", "i", "]", "+", "f0", "[", "j1", "+", "2", "*", "j3", ",", "k", "]", "\n", "# end j1 != 1 and j1 != L[i]", "\n", "# end x1[i] != x0[i,j1]", "\n", "#end x1[i] == np.Inf", "\n", "#end  x[i] == np.Inf or x[i] == x0[i,j1]", "\n", "", "", "", "", "if", "y", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "                ", "if", "j2", "==", "-", "1", ":", "#  make it nagative since in python index case it can become nagative", "\n", "                    ", "y", "[", "i", "]", "=", "u", "[", "i", "]", "\n", "", "elif", "j2", "==", "L", "[", "i", "]", ":", "\n", "                    ", "y", "[", "i", "]", "=", "v", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "y", "[", "i", "]", "=", "split1", "(", "x0", "[", "i", ",", "j2", "]", ",", "x0", "[", "i", ",", "j2", "+", "1", "]", ",", "f0", "[", "j2", ",", "k", "]", ",", "f0", "[", "j2", "+", "1", ",", "k", "]", ")", "\n", "#end", "\n", "#end if yi", "\n", "# end if ichild[m] < 0", "\n", "", "", "", "m", "=", "ipar", "[", "m", "]", "\n", "# end while", "\n", "", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "x", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "            ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "l", "[", "i", "]", "]", "\n", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", "=", "vert3", "(", "l", "[", "i", "]", ",", "x0", "[", "i", ",", ":", "]", ",", "f0", "[", ":", ",", "i", "]", ",", "L", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", ",", "f1", "[", "i", "]", ",", "f2", "[", "i", "]", ")", "\n", "\n", "", "if", "y", "[", "i", "]", "==", "np", ".", "Inf", ":", "\n", "            ", "y", "[", "i", "]", "=", "v1", "[", "i", "]", "\n", "\n", "", "", "return", "n0", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "f1", ",", "f2", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert1": [[154, 169], ["None"], "function", ["None"], ["", "def", "vert1", "(", "j", ",", "z", ",", "f", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ")", ":", "\n", "    ", "if", "j", "==", "0", ":", "\n", "        ", "j1", "=", "1", "# go to right to mid mid point ", "\n", "", "else", ":", "\n", "        ", "j1", "=", "0", "# go to left end", "\n", "\n", "", "x", "=", "z", "[", "j1", "]", "\n", "if", "x1", "==", "np", ".", "Inf", ":", "\n", "        ", "x1", "=", "z", "[", "j", "]", "\n", "f1", "=", "f1", "+", "f", "[", "j", "]", "\n", "", "elif", "x2", "==", "np", ".", "Inf", "and", "x1", "!=", "z", "[", "j", "]", ":", "\n", "        ", "x2", "=", "z", "[", "j", "]", "\n", "f2", "=", "f2", "+", "f", "[", "j", "]", "\n", "\n", "", "return", "x", ",", "x1", ",", "x2", ",", "f1", ",", "f2", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert2": [[171, 192], ["None"], "function", ["None"], ["", "def", "vert2", "(", "j", ",", "x", ",", "z", ",", "f", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ")", ":", "\n", "    ", "if", "j", "==", "0", ":", "\n", "        ", "j1", "=", "1", "# go to right mid point", "\n", "", "else", ":", "\n", "        ", "j1", "=", "0", "# go to left endpoint", "\n", "\n", "", "if", "x1", "==", "np", ".", "Inf", ":", "\n", "        ", "x1", "=", "z", "[", "j", "]", "\n", "f1", "=", "f1", "+", "f", "[", "j", "]", "\n", "if", "x", "!=", "z", "[", "j1", "]", ":", "\n", "            ", "x2", "=", "z", "[", "j1", "]", "\n", "f2", "=", "f2", "+", "f", "[", "j1", "]", "\n", "#end", "\n", "", "", "elif", "x2", "==", "np", ".", "Inf", "and", "x1", "!=", "z", "[", "j", "]", ":", "\n", "        ", "x2", "=", "z", "[", "j", "]", "\n", "f2", "=", "f2", "+", "f", "[", "j", "]", "\n", "", "elif", "x2", "==", "np", ".", "Inf", ":", "\n", "        ", "x2", "=", "z", "[", "j1", "]", "\n", "f2", "=", "f2", "+", "f", "[", "j1", "]", "\n", "#end", "\n", "", "return", "x1", ",", "x2", ",", "f1", ",", "f2", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.vertex_func.vert3": [[195, 211], ["None"], "function", ["None"], ["", "def", "vert3", "(", "j", ",", "x0", ",", "f0", ",", "L", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ")", ":", "\n", "    ", "if", "j", "==", "0", ":", "\n", "        ", "k1", "=", "1", "# go right to 1 if already at left end (right end)", "\n", "k2", "=", "2", "# go right if already at left end (exterme right end)", "\n", "", "elif", "j", "==", "L", ":", "\n", "        ", "k1", "=", "L", "-", "2", "# go left to 0 (left end)", "\n", "k2", "=", "L", "-", "1", "# go right to 2 (right end)", "\n", "", "else", ":", "\n", "        ", "k1", "=", "j", "-", "1", "# go left to 0 (left end)", "\n", "k2", "=", "j", "+", "1", "# go right to 2 (right end)", "\n", "#end if", "\n", "", "x1", "=", "x0", "[", "k1", "]", "\n", "x2", "=", "x0", "[", "k2", "]", "\n", "f1", "=", "f1", "+", "f0", "[", "k1", "]", "\n", "f2", "=", "f2", "+", "f0", "[", "k2", "]", "\n", "return", "x1", ",", "x2", ",", "f1", ",", "f2", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.splinit": [[13, 116], ["len", "numpy.zeros", "range", "range", "range", "max", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "len", "xmin.append", "fmi.append", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "len", "xmin.append", "fmi.append", "copy.deepcopy", "len", "xmin.append", "fmi.append", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "copy.deepcopy", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr"], ["def", "splinit", "(", "fcn", ",", "i", ",", "s", ",", "smax", ",", "par", ",", "x0", ",", "n0", ",", "u", ",", "v", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "L", ",", "l", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "xbest", ",", "fbest", ",", "stop", ",", "prt", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", ")", ":", "\n", "    ", "'''\n    % splits box # par at level s according to the initialization list\n    % in the ith coordinate and inserts its children and their parameters\n    % in the list \n    '''", "\n", "\n", "# initialization ", "\n", "ncall", "=", "0", "\n", "n", "=", "len", "(", "x", ")", "\n", "f0", "=", "np", ".", "zeros", "(", "max", "(", "L", ")", "+", "1", ")", "\n", "flag", "=", "1", "\n", "\n", "for", "j", "in", "range", "(", "L", "[", "i", "]", "+", "1", ")", ":", "\n", "        ", "if", "j", "!=", "l", "[", "i", "]", ":", "\n", "            ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "j", "]", "\n", "f0", "[", "j", "]", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "if", "f0", "[", "j", "]", "<", "fbest", ":", "\n", "                ", "fbest", "=", "f0", "[", "j", "]", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "nsweepbest", "=", "copy", ".", "deepcopy", "(", "nsweep", ")", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                    ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                    ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "2", "]", ")", "\n", "", "if", "not", "flag", ":", "\n", "                    ", "return", "xbest", ",", "fbest", ",", "f0", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "flag", ",", "ncall", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", "\n", "", "", "", "else", ":", "\n", "            ", "f0", "[", "j", "]", "=", "f", "[", "0", ",", "par", "]", "\n", "#end j != l[i]", "\n", "#end for j", "\n", "", "", "if", "s", "+", "1", "<", "smax", ":", "\n", "        ", "nchild", "=", "0", "\n", "if", "u", "[", "i", "]", "<", "x0", "[", "i", ",", "0", "]", ":", "# in that case the box at the boundary gets level s + 1", "\n", "            ", "nchild", "=", "nchild", "+", "1", "\n", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "1", ",", "-", "nchild", ",", "f0", "[", "0", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "#end if ui <  xo[i,0]", "\n", "", "for", "j", "in", "range", "(", "L", "[", "i", "]", ")", ":", "\n", "            ", "nchild", "=", "nchild", "+", "1", "\n", "#splval = split1(x0[i,j],x0[i,j+1],f0[j],f0[j+1])", "\n", "if", "f0", "[", "j", "]", "<=", "f0", "[", "j", "+", "1", "]", "or", "s", "+", "2", "<", "smax", ":", "\n", "                ", "nboxes", "=", "nboxes", "+", "1", "\n", "if", "f0", "[", "j", "]", "<=", "f0", "[", "j", "+", "1", "]", ":", "\n", "                    ", "level0", "=", "s", "+", "1", "\n", "", "else", ":", "\n", "                    ", "level0", "=", "s", "+", "2", "\n", "#end if f0", "\n", "# the box with the smaller function value gets level s + 1, the one with", "\n", "# the larger function value level s + 2", "\n", "", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "level0", ",", "-", "nchild", ",", "f0", "[", "j", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "", "else", ":", "\n", "                ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "j", "]", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "                    ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "\n", "fmi", ".", "append", "(", "f0", "[", "j", "]", ")", "\n", "", "else", ":", "\n", "                    ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f0", "[", "j", "]", "\n", "#end if f0[j] <= f0[j+1]  or s + 2 < smax", "\n", "", "", "nchild", "=", "nchild", "+", "1", "\n", "if", "f0", "[", "j", "+", "1", "]", "<", "f0", "[", "j", "]", "or", "s", "+", "2", "<", "smax", ":", "\n", "                ", "nboxes", "=", "nboxes", "+", "1", "\n", "if", "f0", "[", "j", "+", "1", "]", "<", "f0", "[", "j", "]", ":", "\n", "                    ", "level0", "=", "s", "+", "1", "\n", "", "else", ":", "\n", "                    ", "level0", "=", "s", "+", "2", "\n", "#end", "\n", "", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "level0", ",", "-", "nchild", ",", "f0", "[", "j", "+", "1", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "", "else", ":", "\n", "                ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "j", "+", "1", "]", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "                    ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "\n", "fmi", ".", "append", "(", "f0", "[", "j", "+", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f0", "[", "j", "+", "1", "]", "\n", "#end f0[j+1] < f0[j]", "\n", "#end for", "\n", "", "", "", "if", "x0", "[", "i", ",", "L", "[", "i", "]", "]", "<", "v", "[", "i", "]", ":", "# in that case the box at the boundary gets level s + 1", "\n", "            ", "nchild", "=", "nchild", "+", "1", "\n", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "1", ",", "-", "nchild", ",", "f0", "[", "L", "[", "i", "]", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "##end if x0 < vi", "\n", "", "", "else", ":", "\n", "        ", "for", "j", "in", "range", "(", "L", "[", "i", "]", "+", "1", ")", ":", "\n", "            ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "j", "]", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "                ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "\n", "fmi", ".", "append", "(", "f0", "[", "j", "]", ")", "\n", "", "else", ":", "\n", "                ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f0", "[", "j", "]", "\n", "#end  s+1 < smax", "\n", "", "", "", "return", "xbest", ",", "fbest", ",", "f0", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "flag", ",", "ncall", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split": [[118, 237], ["len", "src.optimization.parameter.mcs.jones.functions.feval", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "len", "xmin.append", "fmi.append", "len", "xmin.append", "fmi.append", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "abs", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "len", "xmin.append", "fmi.append", "copy.deepcopy", "len", "xmin.append", "fmi.append", "copy.deepcopy", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.updtrec.updtrec", "copy.deepcopy", "copy.deepcopy", "abs", "len", "xmin.append", "fmi.append", "copy.deepcopy", "numpy.sqrt", "copy.deepcopy", "copy.deepcopy"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec"], ["", "def", "split", "(", "fcn", ",", "i", ",", "s", ",", "smax", ",", "par", ",", "n0", ",", "u", ",", "v", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "z", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "xbest", ",", "fbest", ",", "stop", ",", "prt", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", ")", ":", "\n", "    ", "'''\n        split function\n    '''", "\n", "ncall", "=", "0", "\n", "n", "=", "len", "(", "x", ")", "\n", "\n", "flag", "=", "1", "\n", "x", "[", "i", "]", "=", "z", "[", "1", "]", "\n", "f", "[", "1", ",", "par", "]", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "#print('fbest:',fbest)", "\n", "\n", "if", "f", "[", "1", ",", "par", "]", "<", "fbest", ":", "\n", "        ", "fbest", "=", "copy", ".", "deepcopy", "(", "f", "[", "1", ",", "par", "]", ")", "\n", "xbest", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "nsweepbest", "=", "copy", ".", "deepcopy", "(", "nsweep", ")", "\n", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "            ", "flag", "=", "chrelerr", "(", "fbest", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "            ", "flag", "=", "chvtr", "(", "fbest", ",", "stop", "[", "2", "]", ")", "\n", "#end", "\n", "", "if", "not", "flag", ":", "\n", "            ", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "flag", ",", "ncall", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", "\n", "#end if f-par < best", "\n", "#splval = split1(z[0],z[1],f[0,par],f[1,par])", "\n", "\n", "", "", "if", "s", "+", "1", "<", "smax", ":", "\n", "        ", "if", "f", "[", "0", ",", "par", "]", "<=", "f", "[", "1", ",", "par", "]", ":", "\n", "            ", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "1", ",", "1", ",", "f", "[", "0", ",", "par", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "if", "s", "+", "2", "<", "smax", ":", "\n", "                ", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "2", ",", "2", ",", "f", "[", "1", ",", "par", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "", "else", ":", "\n", "                ", "x", "[", "i", "]", "=", "z", "[", "1", "]", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "                    ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "#xmin[:,nbasket] = x", "\n", "fmi", ".", "append", "(", "f", "[", "1", ",", "par", "]", ")", "#fmi[nbasket] = f[1,par]", "\n", "", "else", ":", "\n", "                    ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f", "[", "1", ",", "par", "]", "\n", "#end if s+2 < smax", "\n", "", "", "", "else", ":", "\n", "            ", "if", "s", "+", "2", "<", "smax", ":", "\n", "                ", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "2", ",", "1", ",", "f", "[", "0", ",", "par", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "", "else", ":", "\n", "                ", "x", "[", "i", "]", "=", "z", "[", "0", "]", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "                    ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "\n", "fmi", ".", "append", "(", "f", "[", "0", ",", "par", "]", ")", "\n", "", "else", ":", "\n", "                    ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f", "[", "0", ",", "par", "]", "\n", "# end s+2", "\n", "", "", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "1", ",", "2", ",", "f", "[", "1", ",", "par", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "# end if f[0,par] <= f[1,par] else ", "\n", "\n", "#if the third box is larger than the smaller of the other two boxes,", "\n", "# it gets level s + 1 otherwise it gets level s + 2", "\n", "", "if", "z", "[", "1", "]", "!=", "y", "[", "i", "]", ":", "\n", "            ", "if", "abs", "(", "z", "[", "1", "]", "-", "y", "[", "i", "]", ")", ">", "abs", "(", "z", "[", "1", "]", "-", "z", "[", "0", "]", ")", "*", "(", "3", "-", "np", ".", "sqrt", "(", "5", ")", ")", "*", "0.5", ":", "\n", "                ", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "1", ",", "3", ",", "f", "[", "1", ",", "par", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "", "else", ":", "\n", "                ", "if", "s", "+", "2", "<", "smax", ":", "\n", "                    ", "nboxes", "=", "nboxes", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "s", "+", "2", ",", "3", ",", "f", "[", "1", ",", "par", "]", ")", "\n", "record", "=", "updtrec", "(", "nboxes", ",", "level", "[", "nboxes", "]", ",", "f", "[", "0", ",", ":", "]", ",", "record", ")", "\n", "", "else", ":", "\n", "                    ", "x", "[", "i", "]", "=", "z", "[", "1", "]", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "                        ", "xmin", ".", "append", "(", "copy", ".", "deepcopy", "(", "x", ")", ")", "# xmin[:,nbasket] = x", "\n", "fmi", ".", "append", "(", "copy", ".", "deepcopy", "(", "f", "[", "1", ",", "par", "]", ")", ")", "# fmi[nbasket] = f[1,par]", "\n", "", "else", ":", "\n", "                        ", "xmin", "[", "nbasket", "]", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "[", "nbasket", "]", "=", "f", "[", "1", ",", "par", "]", "\n", "#end abs", "\n", "#end z1 ! = ", "\n", "", "", "", "", "", "else", ":", "\n", "#print(i,x,z)", "\n", "        ", "xi1", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "xi2", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "\n", "xi1", "[", "i", "]", "=", "z", "[", "0", "]", "\n", "#print(xi1)", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "            ", "xmin", ".", "append", "(", "xi1", ")", "#xmin[:,nbasket] = x", "\n", "fmi", ".", "append", "(", "f", "[", "0", ",", "par", "]", ")", "\n", "", "else", ":", "\n", "            ", "xmin", "[", "nbasket", "]", "=", "xi1", "\n", "fmi", "[", "nbasket", "]", "=", "f", "[", "0", ",", "par", "]", "\n", "\n", "", "xi2", "[", "i", "]", "=", "z", "[", "1", "]", "\n", "#print(xi2)", "\n", "nbasket", "=", "nbasket", "+", "1", "\n", "if", "(", "len", "(", "xmin", ")", "==", "nbasket", ")", ":", "\n", "            ", "xmin", ".", "append", "(", "xi2", ")", "\n", "fmi", ".", "append", "(", "f", "[", "1", ",", "par", "]", ")", "\n", "", "else", ":", "\n", "            ", "xmin", "[", "nbasket", "]", "=", "xi2", "\n", "fmi", "[", "nbasket", "]", "=", "f", "[", "1", ",", "par", "]", "\n", "# end if s+1 < smax", "\n", "#print('operating on min 1')", "\n", "#print(f[0,par], f[1,par], fmi, xmin)", "\n", "#print('operating on min 1')", "\n", "", "", "return", "xbest", ",", "fbest", ",", "xmin", ",", "fmi", ",", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "flag", ",", "ncall", ",", "record", ",", "nboxes", ",", "nbasket", ",", "nsweepbest", ",", "nsweep", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split1": [[239, 244], ["math.sqrt", "math.sqrt"], "function", ["None"], ["", "def", "split1", "(", "x1", ",", "x2", ",", "f1", ",", "f2", ")", ":", "\n", "    ", "if", "f1", "<=", "f2", ":", "\n", "      ", "return", "x1", "+", "0.5", "*", "(", "-", "1", "+", "math", ".", "sqrt", "(", "5", ")", ")", "*", "(", "x2", "-", "x1", ")", "\n", "", "else", ":", "\n", "      ", "return", "x1", "+", "0.5", "*", "(", "3", "-", "math", ".", "sqrt", "(", "5", ")", ")", "*", "(", "x2", "-", "x1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split2": [[246, 258], ["src.optimization.parameter.mcs.mcs_fun.sign.sign", "abs", "abs", "abs", "abs", "src.optimization.parameter.mcs.mcs_fun.sign.sign"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.sign.sign", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.sign.sign"], ["", "", "def", "split2", "(", "x", ",", "y", ")", ":", "\n", "    ", "'''\n    % determines a value x1 for splitting the interval [min(x,y),max(x,y)]\n    % is modeled on the function subint with safeguards for infinite y\n    '''", "\n", "x2", "=", "y", "\n", "if", "x", "==", "0", "and", "abs", "(", "y", ")", ">", "1000", ":", "\n", "        ", "x2", "=", "sign", "(", "y", ")", "\n", "", "elif", "x", "!=", "0", "and", "abs", "(", "y", ")", ">", "100", "*", "abs", "(", "x", ")", ":", "\n", "        ", "x2", "=", "10", "*", "sign", "(", "y", ")", "*", "abs", "(", "x", ")", "\n", "", "x1", "=", "x", "+", "2", "*", "(", "x2", "-", "x", ")", "/", "3", "\n", "return", "x1", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.triple.triple": [[8, 120], ["len", "numpy.zeros", "range", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "range", "numpy.zeros", "len", "range", "len", "copy.deepcopy", "copy.deepcopy", "numpy.zeros", "len", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.mcs_fun.polint.polint1", "range", "range", "len", "range", "range", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "len", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.mcs_fun.hessian.hessian", "len", "copy.deepcopy", "copy.deepcopy", "range", "np.zeros.", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint1", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.hessian.hessian"], ["def", "triple", "(", "fcn", ",", "x", ",", "f", ",", "x1", ",", "x2", ",", "u", ",", "v", ",", "hess", ",", "G", ",", "setG", "=", "False", ")", ":", "\n", "    ", "nf", "=", "0", "\n", "n", "=", "len", "(", "x", ")", "\n", "g", "=", "np", ".", "zeros", "(", "n", ")", "\n", "nargin", "=", "10", "\n", "if", "setG", ":", "\n", "        ", "nargin", "=", "9", "\n", "G", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", "\n", "\n", "", "ind", "=", "[", "i", "for", "i", "in", "range", "(", "n", ")", "if", "(", "u", "[", "i", "]", "<", "x", "[", "i", "]", "and", "x", "[", "i", "]", "<", "v", "[", "i", "]", ")", "]", "\n", "ind1", "=", "[", "i", "for", "i", "in", "range", "(", "n", ")", "if", "(", "x", "[", "i", "]", "<=", "u", "[", "i", "]", "or", "x", "[", "i", "]", ">=", "v", "[", "i", "]", ")", "]", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "ind1", ")", ")", ":", "\n", "        ", "g", "[", "ind1", "[", "j", "]", "]", "=", "0", "\n", "for", "k", "in", "range", "(", "n", ")", ":", "\n", "            ", "G", "[", "ind1", "[", "j", "]", ",", "k", "]", "=", "0", "\n", "G", "[", "k", ",", "ind1", "[", "j", "]", "]", "=", "0", "\n", "\n", "", "", "if", "len", "(", "ind", ")", "<=", "1", ":", "\n", "        ", "xtrip", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "ftrip", "=", "copy", ".", "deepcopy", "(", "f", ")", "\n", "if", "len", "(", "ind", ")", "!=", "0", ":", "\n", "            ", "for", "i", "in", "ind", ":", "\n", "                ", "g", "[", "i", "]", "=", "1", "\n", "G", "[", "i", ",", "i", "]", "=", "1", "\n", "", "", "return", "xtrip", ",", "ftrip", ",", "g", ",", "G", ",", "x1", ",", "x2", ",", "nf", "\n", "# end if", "\n", "\n", "", "if", "setG", ":", "\n", "#print('reset G')", "\n", "        ", "G", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", "\n", "\n", "", "xtrip", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "ftrip", "=", "copy", ".", "deepcopy", "(", "f", ")", "\n", "xtripnew", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "ftripnew", "=", "copy", ".", "deepcopy", "(", "f", ")", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "ind", ")", ")", ":", "\n", "        ", "i", "=", "ind", "[", "j", "]", "\n", "x", "=", "copy", ".", "deepcopy", "(", "xtrip", ")", "\n", "f", "=", "copy", ".", "deepcopy", "(", "ftrip", ")", "\n", "\n", "x", "[", "i", "]", "=", "x1", "[", "i", "]", "\n", "f1", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "\n", "x", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "f2", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "nf", "=", "nf", "+", "2", "\n", "g", "[", "i", "]", ",", "G", "[", "i", ",", "i", "]", "=", "polint1", "(", "[", "xtrip", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", "]", ",", "[", "f", ",", "f1", ",", "f2", "]", ")", "\n", "if", "f1", "<=", "f2", ":", "\n", "            ", "if", "f1", "<", "ftrip", ":", "\n", "                ", "ftripnew", "=", "copy", ".", "deepcopy", "(", "f1", ")", "\n", "xtripnew", "[", "i", "]", "=", "x1", "[", "i", "]", "\n", "", "", "else", ":", "\n", "            ", "if", "f2", "<", "ftrip", ":", "\n", "                ", "ftripnew", "=", "copy", ".", "deepcopy", "(", "f2", ")", "\n", "xtripnew", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "\n", "", "", "if", "nargin", "<", "10", ":", "\n", "            ", "k1", "=", "-", "1", "\n", "if", "f1", "<=", "f2", ":", "\n", "                ", "x", "[", "i", "]", "=", "x1", "[", "i", "]", "\n", "", "else", ":", "\n", "                ", "x", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "\n", "", "for", "k", "in", "range", "(", "i", ")", ":", "\n", "                ", "if", "hess", "[", "i", ",", "k", "]", ":", "\n", "                    ", "if", "xtrip", "[", "k", "]", ">", "u", "[", "k", "]", "and", "xtrip", "[", "k", "]", "<", "v", "[", "k", "]", "and", "(", "len", "(", "[", "m", "for", "m", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "ind", "[", "m", "]", "==", "k", "]", ")", "!=", "0", ")", ":", "\n", "                        ", "q1", "=", "ftrip", "+", "g", "[", "k", "]", "*", "(", "x1", "[", "k", "]", "-", "xtrip", "[", "k", "]", ")", "+", "0.5", "*", "G", "[", "k", ",", "k", "]", "*", "(", "x1", "[", "k", "]", "-", "xtrip", "[", "k", "]", ")", "**", "2", "\n", "q2", "=", "ftrip", "+", "g", "[", "k", "]", "*", "(", "x2", "[", "k", "]", "-", "xtrip", "[", "k", "]", ")", "+", "0.5", "*", "G", "[", "k", ",", "k", "]", "*", "(", "x2", "[", "k", "]", "-", "xtrip", "[", "k", "]", ")", "**", "2", "\n", "if", "q1", "<=", "q2", ":", "\n", "                            ", "x", "[", "k", "]", "=", "x1", "[", "k", "]", "\n", "", "else", ":", "\n", "                            ", "x", "[", "k", "]", "=", "x2", "[", "k", "]", "\n", "", "f12", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "nf", "=", "nf", "+", "1", "\n", "G", "[", "i", ",", "k", "]", "=", "hessian", "(", "i", ",", "k", ",", "x", ",", "xtrip", ",", "f12", ",", "ftrip", ",", "g", ",", "G", ")", "\n", "#print(G[i,k])", "\n", "G", "[", "k", ",", "i", "]", "=", "G", "[", "i", ",", "k", "]", "\n", "if", "f12", "<", "ftripnew", ":", "\n", "                            ", "ftripnew", "=", "copy", ".", "deepcopy", "(", "f12", ")", "\n", "xtripnew", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "k1", "=", "k", "\n", "", "x", "[", "k", "]", "=", "xtrip", "[", "k", "]", "\n", "#end if xtrip", "\n", "", "", "else", ":", "\n", "                    ", "G", "[", "i", ",", "k", "]", "=", "0", "\n", "G", "[", "k", ",", "i", "]", "=", "0", "\n", "#end hess[i,k]", "\n", "#end for k in i-1", "\n", "#end narg", "\n", "", "", "", "if", "ftripnew", "<", "ftrip", ":", "\n", "            ", "if", "x1", "[", "i", "]", "==", "xtripnew", "[", "i", "]", ":", "\n", "                ", "x1", "[", "i", "]", "=", "xtrip", "[", "i", "]", "\n", "", "else", ":", "\n", "                ", "x2", "[", "i", "]", "=", "xtrip", "[", "i", "]", "\n", "", "if", "nargin", "<", "10", "and", "k1", ">", "-", "1", ":", "\n", "                ", "if", "xtripnew", "[", "k1", "]", "==", "x1", "[", "k1", "]", ":", "\n", "                    ", "x1", "[", "k1", "]", "=", "xtrip", "[", "k1", "]", "\n", "", "else", ":", "\n", "                    ", "x2", "[", "k1", "]", "=", "xtrip", "[", "k1", "]", "\n", "", "", "for", "k", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "                ", "if", "(", "len", "(", "[", "m", "for", "m", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "ind", "[", "m", "]", "==", "k", "]", ")", "!=", "0", ")", ":", "\n", "                    ", "g", "[", "k", "]", "=", "g", "[", "k", "]", "+", "G", "[", "i", ",", "k", "]", "*", "(", "xtripnew", "[", "i", "]", "-", "xtrip", "[", "i", "]", ")", "\n", "if", "nargin", "<", "10", "and", "k1", ">", "-", "1", ":", "\n", "                        ", "g", "[", "k", "]", "=", "g", "[", "k", "]", "+", "G", "(", "k1", ",", "k", ")", "*", "(", "xtripnew", "[", "k1", "]", "-", "xtrip", "[", "k1", "]", ")", "\n", "#end if empty", "\n", "", "", "", "xtrip", "=", "copy", ".", "deepcopy", "(", "xtripnew", ")", "\n", "ftrip", "=", "copy", ".", "deepcopy", "(", "ftripnew", ")", "\n", "# end ftripnew", "\n", "#en for j in ind", "\n", "", "", "return", "xtrip", ",", "ftrip", ",", "g", ",", "G", ",", "x1", ",", "x2", ",", "nf", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.csearch.csearch": [[9, 191], ["len", "numpy.ones", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "range", "min", "numpy.zeros", "src.optimization.parameter.mcs.mcs_fun.polint.polint1", "copy.deepcopy", "range", "copy.deepcopy", "copy.deepcopy", "max", "range", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.gls.gls.gls", "numpy.argmin", "min", "numpy.argmin", "min", "range", "len", "abs", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.jones.functions.feval", "copy.deepcopy", "copy.deepcopy", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.mcs_fun.hessian.hessian", "copy.deepcopy", "src.optimization.parameter.mcs.jones.functions.feval", "range", "range", "copy.deepcopy", "len", "abs", "len", "range", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint1", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.gls.gls", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.hessian.hessian", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval"], ["def", "csearch", "(", "fcn", ",", "x", ",", "f", ",", "u", ",", "v", ",", "hess", ")", ":", "\n", "    ", "n", "=", "len", "(", "x", ")", "\n", "x", "=", "[", "min", "(", "v", "[", "i", "]", ",", "max", "(", "x", "[", "i", "]", ",", "u", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", "]", "\n", "\n", "nfcsearch", "=", "0", "\n", "smaxls", "=", "6", "\n", "small", "=", "0.1", "\n", "nloc", "=", "1", "\n", "hess", "=", "np", ".", "ones", "(", "(", "n", ",", "n", ")", ")", "\n", "xmin", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "fmi", "=", "copy", ".", "deepcopy", "(", "f", ")", "\n", "xminnew", "=", "copy", ".", "deepcopy", "(", "xmin", ")", "\n", "fminew", "=", "copy", ".", "deepcopy", "(", "fmi", ")", "\n", "g", "=", "np", ".", "zeros", "(", "n", ")", "\n", "ind0", "=", "[", "]", "\n", "\n", "x1", "=", "np", ".", "zeros", "(", "n", ")", "\n", "x2", "=", "np", ".", "zeros", "(", "n", ")", "\n", "G", "=", "np", ".", "zeros", "(", "(", "n", ",", "n", ")", ")", "\n", "eps", "=", "2.220446049250313e-16", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "p", "=", "np", ".", "zeros", "(", "n", ")", "\n", "p", "[", "i", "]", "=", "1", "\n", "if", "xmin", "[", "i", "]", ":", "\n", "            ", "delta", "=", "eps", "**", "(", "1", "/", "3", ")", "*", "abs", "(", "xmin", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "            ", "delta", "=", "eps", "**", "(", "1", "/", "3", ")", "\n", "", "linesearch", "=", "True", "\n", "if", "xmin", "[", "i", "]", "<=", "u", "[", "i", "]", ":", "\n", "            ", "f1", "=", "feval", "(", "fcn", ",", "xmin", "+", "delta", "*", "p", ")", "\n", "nfcsearch", "=", "nfcsearch", "+", "1", "\n", "if", "f1", ">=", "fmi", ":", "\n", "                ", "f2", "=", "feval", "(", "fcn", ",", "xmin", "+", "2", "*", "delta", "*", "p", ")", "\n", "nfcsearch", "=", "nfcsearch", "+", "1", "\n", "x1", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "delta", "\n", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "2", "*", "delta", "\n", "if", "f2", ">=", "fmi", ":", "\n", "                    ", "xminnew", "[", "i", "]", "=", "xmin", "[", "i", "]", "\n", "fminew", "=", "fmi", "\n", "", "else", ":", "\n", "                    ", "xminnew", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "fminew", "=", "copy", ".", "deepcopy", "(", "f2", ")", "\n", "", "linesearch", "=", "False", "\n", "", "else", ":", "\n", "                ", "alist", "=", "[", "0", ",", "delta", "]", "\n", "flist", "=", "[", "fmi", ",", "f1", "]", "\n", "", "", "elif", "xmin", "[", "i", "]", ">=", "v", "[", "i", "]", ":", "\n", "            ", "f1", "=", "feval", "(", "fcn", ",", "xmin", "-", "delta", "*", "p", ")", "\n", "nfcsearch", "=", "nfcsearch", "+", "1", "\n", "if", "f1", ">=", "fmi", ":", "\n", "                ", "f2", "=", "feval", "(", "fcn", ",", "xmin", "-", "2", "*", "delta", "*", "p", ")", "\n", "nfcsearch", "=", "nfcsearch", "+", "1", "\n", "x1", "[", "i", "]", "=", "xmin", "[", "i", "]", "-", "delta", "\n", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "-", "2", "*", "delta", "\n", "if", "f2", ">=", "fmi", ":", "\n", "                    ", "xminnew", "[", "i", "]", "=", "xmin", "[", "i", "]", "\n", "fminew", "=", "fmi", "\n", "", "else", ":", "\n", "                    ", "xminnew", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "fminew", "=", "f2", "\n", "", "linesearch", "=", "False", "\n", "", "else", ":", "\n", "                ", "alist", "=", "[", "0", ",", "-", "delta", "]", "#  ", "\n", "flist", "=", "[", "fmi", ",", "f1", "]", "#  ", "\n", "", "", "else", ":", "\n", "            ", "alist", "=", "0", "\n", "flist", "=", "fmi", "\n", "\n", "", "if", "linesearch", ":", "\n", "#print('line search:',xmin)", "\n", "            ", "alist", ",", "flist", ",", "nfls", "=", "gls", "(", "fcn", ",", "u", ",", "v", ",", "xmin", ",", "p", ",", "alist", ",", "flist", ",", "nloc", ",", "small", ",", "smaxls", ")", "\n", "nfcsearch", "=", "nfcsearch", "+", "nfls", "#print('test gls') #print(alist,flist)", "\n", "\n", "j", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "fminew", "=", "min", "(", "flist", ")", "#print(fminew,j)", "\n", "\n", "if", "fminew", "==", "fmi", ":", "\n", "                ", "j", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "alist", ")", ")", "if", "not", "alist", "[", "inx", "]", "]", "[", "0", "]", "\n", "\n", "", "ind", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "alist", ")", ")", "if", "abs", "(", "alist", "[", "inx", "]", "-", "alist", "[", "j", "]", ")", "<", "delta", "]", "#print(ind)", "\n", "ind1", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "ind", ")", ")", "if", "ind", "[", "inx", "]", "==", "j", "]", "#print(ind1)", "\n", "\n", "for", "inx", "in", "ind1", ":", "\n", "                ", "del", "ind", "[", "inx", "]", "\n", "\n", "", "for", "inx", "in", "ind", ":", "\n", "                ", "del", "alist", "[", "inx", "]", "\n", "del", "flist", "[", "inx", "]", "\n", "\n", "", "j", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "fminew", "=", "min", "(", "flist", ")", "\n", "xminnew", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "]", "#print('test csearch')  #print(flist,j,fminew, xminnew)", "\n", "if", "i", "==", "0", "or", "not", "alist", "[", "j", "]", ":", "#", "\n", "                ", "if", "j", "==", "0", ":", "\n", "                    ", "x1", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "1", "]", "\n", "f1", "=", "flist", "[", "1", "]", "\n", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "2", "]", "\n", "f2", "=", "flist", "[", "2", "]", "\n", "", "elif", "j", "==", "len", "(", "alist", ")", "-", "1", ":", "\n", "                    ", "x1", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "-", "1", "]", "\n", "f1", "=", "flist", "[", "j", "-", "1", "]", "\n", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "-", "2", "]", "\n", "f2", "=", "flist", "[", "j", "-", "2", "]", "\n", "", "else", ":", "\n", "#print(xmin[i],alist[j-1],alist[j+1])", "\n", "                    ", "x1", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "-", "1", "]", "\n", "f1", "=", "flist", "[", "j", "-", "1", "]", "\n", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "+", "1", "]", "\n", "f2", "=", "flist", "[", "j", "+", "1", "]", "\n", "#end if j == 0 elsif, else    ", "\n", "", "xmin", "[", "i", "]", "=", "xminnew", "[", "i", "]", "\n", "fmi", "=", "copy", ".", "deepcopy", "(", "fminew", ")", "\n", "", "else", ":", "\n", "                ", "x1", "[", "i", "]", "=", "xminnew", "[", "i", "]", "\n", "f1", "=", "copy", ".", "deepcopy", "(", "fminew", ")", "\n", "if", "xmin", "[", "i", "]", "<", "x1", "[", "i", "]", "and", "j", "<", "len", "(", "alist", ")", "-", "1", ":", "\n", "                    ", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "+", "1", "]", "\n", "f2", "=", "flist", "[", "j", "+", "1", "]", "\n", "", "elif", "j", "==", "0", ":", "\n", "                    ", "if", "alist", "[", "j", "+", "1", "]", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "+", "1", "]", "\n", "f2", "=", "flist", "[", "j", "+", "1", "]", "\n", "", "else", ":", "\n", "                        ", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "+", "2", "]", "\n", "f2", "=", "flist", "[", "j", "+", "2", "]", "\n", "", "", "elif", "alist", "[", "j", "-", "1", "]", ":", "\n", "                    ", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "-", "1", "]", "\n", "f2", "=", "flist", "[", "j", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "-", "2", "]", "\n", "f2", "=", "flist", "[", "j", "-", "2", "]", "\n", "#end if linesearch", "\n", "", "", "", "g", "[", "i", "]", ",", "G", "[", "i", ",", "i", "]", "=", "polint1", "(", "[", "xmin", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", "]", ",", "[", "fmi", ",", "f1", ",", "f2", "]", ")", "\n", "x", "=", "copy", ".", "deepcopy", "(", "xmin", ")", "\n", "k1", "=", "-", "1", "\n", "if", "f1", "<=", "f2", ":", "\n", "            ", "x", "[", "i", "]", "=", "x1", "[", "i", "]", "\n", "", "else", ":", "\n", "            ", "x", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "", "for", "k", "in", "range", "(", "i", ")", ":", "\n", "            ", "if", "hess", "[", "i", ",", "k", "]", ":", "\n", "                ", "q1", "=", "fmi", "+", "g", "[", "k", "]", "*", "(", "x1", "[", "k", "]", "-", "xmin", "[", "k", "]", ")", "+", "0.5", "*", "G", "[", "k", ",", "k", "]", "*", "(", "x1", "[", "k", "]", "-", "xmin", "[", "k", "]", ")", "**", "2", "\n", "q2", "=", "fmi", "+", "g", "[", "k", "]", "*", "(", "x2", "[", "k", "]", "-", "xmin", "[", "k", "]", ")", "+", "0.5", "*", "G", "[", "k", ",", "k", "]", "*", "(", "x2", "[", "k", "]", "-", "xmin", "[", "k", "]", ")", "**", "2", "\n", "if", "q1", "<=", "q2", ":", "\n", "                    ", "x", "[", "k", "]", "=", "x1", "[", "k", "]", "\n", "", "else", ":", "\n", "                    ", "x", "[", "k", "]", "=", "x2", "[", "k", "]", "\n", "", "f12", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "nfcsearch", "=", "nfcsearch", "+", "1", "\n", "G", "[", "i", ",", "k", "]", "=", "hessian", "(", "i", ",", "k", ",", "x", ",", "xmin", ",", "f12", ",", "fmi", ",", "g", ",", "G", ")", "#  ", "\n", "G", "[", "k", ",", "i", "]", "=", "G", "[", "i", ",", "k", "]", "\n", "if", "f12", "<", "fminew", ":", "\n", "                    ", "fminew", "=", "f12", "\n", "xminnew", "=", "copy", ".", "deepcopy", "(", "x", ")", "\n", "k1", "=", "k", "\n", "", "x", "[", "k", "]", "=", "xmin", "[", "k", "]", "\n", "", "else", ":", "\n", "                ", "G", "[", "i", ",", "k", "]", "=", "0", "\n", "G", "[", "k", ",", "i", "]", "=", "0", "\n", "# end for k in i        ", "\n", "", "", "if", "fminew", "<=", "fmi", ":", "\n", "            ", "if", "x1", "[", "i", "]", "==", "xminnew", "[", "i", "]", ":", "\n", "                ", "x1", "[", "i", "]", "=", "xmin", "[", "i", "]", "\n", "", "elif", "x2", "[", "i", "]", "==", "xminnew", "[", "i", "]", ":", "\n", "                ", "x2", "[", "i", "]", "=", "xmin", "[", "i", "]", "\n", "", "if", "k1", ">", "-", "1", ":", "\n", "                ", "if", "xminnew", "[", "k1", "]", "==", "x1", "[", "k1", "]", ":", "\n", "                    ", "x1", "[", "k1", "]", "=", "xmin", "[", "k1", "]", "\n", "", "elif", "xminnew", "[", "k1", "]", "==", "x2", "[", "k1", "]", ":", "\n", "                    ", "x2", "[", "k1", "]", "=", "xmin", "[", "k1", "]", "\n", "#print('xmins',k1,xminnew[i],xmin[i])  ", "\n", "", "", "for", "k", "in", "range", "(", "i", "+", "1", ")", ":", "\n", "                ", "g", "[", "k", "]", "=", "g", "[", "k", "]", "+", "G", "[", "i", ",", "k", "]", "*", "(", "xminnew", "[", "i", "]", "-", "xmin", "[", "i", "]", ")", "\n", "if", "k1", ">", "-", "1", ":", "\n", "                    ", "g", "[", "k", "]", "=", "g", "[", "k", "]", "+", "G", "[", "k1", ",", "k", "]", "*", "(", "xminnew", "[", "k1", "]", "-", "xmin", "[", "k1", "]", ")", "\n", "#end for k in i", "\n", "", "", "", "xmin", "=", "copy", ".", "deepcopy", "(", "xminnew", ")", "\n", "fmi", "=", "copy", ".", "deepcopy", "(", "fminew", ")", "\n", "#print('check',i)  print(g[i], G[i,i])", "\n", "#end for i", "\n", "", "return", "xmin", ",", "fmi", ",", "g", ",", "G", ",", "nfcsearch", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.neighbor.neighbor": [[1, 16], ["max", "min", "range", "range", "range", "range", "len", "len", "len", "len"], "function", ["None"], ["def", "neighbor", "(", "x", ",", "delta", ",", "u", ",", "v", ")", ":", "\n", "    ", "'''\n        computes 'neighbors' x1 and x2 of x needed for making triple search \n        and building a local quadratic model such that x(i), x1(i), x2(i) are\n        pairwise distinct for i = 1,...,n\n    '''", "\n", "i1", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", "if", "x", "[", "i", "]", "==", "u", "[", "i", "]", "]", "\n", "i2", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", "if", "x", "[", "i", "]", "==", "v", "[", "i", "]", "]", "\n", "x1", "=", "[", "max", "(", "u", "[", "i", "]", ",", "x", "[", "i", "]", "-", "delta", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", "]", "\n", "x2", "=", "[", "min", "(", "x", "[", "i", "]", "+", "delta", "[", "i", "]", ",", "v", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "x", ")", ")", "]", "\n", "for", "i", "in", "i1", ":", "\n", "        ", "x1", "[", "i", "]", "=", "x", "[", "i", "]", "+", "2", "*", "delta", "[", "i", "]", "\n", "", "for", "i", "in", "i2", ":", "\n", "        ", "x2", "[", "i", "]", "=", "x", "[", "i", "]", "-", "2", "*", "delta", "[", "i", "]", "\n", "", "return", "x1", ",", "x2", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.exgain.exgain": [[7, 60], ["numpy.zeros", "range", "src.optimization.parameter.mcs.mcs_fun.polint.polint", "src.optimization.parameter.mcs.mcs_fun.initi_func.subint", "min", "max", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadmin", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadpol", "min"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.subint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadmin", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol"], ["def", "exgain", "(", "n", ",", "n0", ",", "l", ",", "L", ",", "x", ",", "y", ",", "x1", ",", "x2", ",", "fx", ",", "f0", ",", "f1", ",", "f2", ")", ":", "\n", "    ", "'''\n    % determines the splitting index, the splitting value and the expected\n    % gain vector e for (potentially) splitting a box by expected gain\n    % Input:\n    % n        dimension of the problem\n    % n0(1:n)  the ith coordinate has been split n0(i) times in the history\n    %          of the box\n    % l(1:n)   pointer to the initial point of the initialization list\n    % L(1:n)   lengths of the initialization list\n    % x(1:n)   base vertex of the box\n    % y(1:n)   opposite vertex of the box\n    % x1(1:n), x2(1:n), f1(1:n), f2(1:n)\n    %          x1(i) and x2(i) and the corresponding function values f1(i)\n    %          and f2(i) used for quadratic interpolation in the ith\n    %          coordinate \n    % fx       function value at the base vertex\n    % f0(1:max(L),1:n)  function values appertaining to the init. list\n    % Output:\n    % e(1:n)   e(i) maximal expected gain in function value by changing \n    %          coordinate i\n    % isplit   splitting index\n    % splval   = Inf  if n0(isplit) = 0\n    %          = splitting value  otherwise\n    '''", "\n", "\n", "e", "=", "np", ".", "zeros", "(", "n", ")", "# initialization", "\n", "emin", "=", "np", ".", "Inf", ";", "# initialization", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "n0", "[", "i", "]", "==", "0", ":", "\n", "# expected gain for splitting according to the initialization list", "\n", "            ", "e", "[", "i", "]", "=", "min", "(", "f0", "[", "0", ":", "L", "[", "i", "]", "+", "1", ",", "i", "]", ")", "-", "f0", "[", "l", "[", "i", "]", ",", "i", "]", "\n", "\n", "if", "e", "[", "i", "]", "<", "emin", ":", "\n", "                ", "emin", "=", "e", "[", "i", "]", "\n", "isplit", "=", "i", "\n", "splval", "=", "np", ".", "Inf", "\n", "", "", "else", ":", "\n", "            ", "z1", "=", "[", "x", "[", "i", "]", ",", "x1", "[", "i", "]", ",", "x2", "[", "i", "]", "]", "\n", "z2", "=", "[", "0", ",", "f1", "[", "i", "]", "-", "fx", ",", "f2", "[", "i", "]", "-", "fx", "]", "\n", "d", "=", "polint", "(", "z1", ",", "z2", ")", "\n", "# safeguard against splitting too close to x(i)", "\n", "eta1", ",", "eta2", "=", "subint", "(", "x", "[", "i", "]", ",", "y", "[", "i", "]", ")", "\n", "xi1", "=", "min", "(", "eta1", ",", "eta2", ")", "\n", "xi2", "=", "max", "(", "eta1", ",", "eta2", ")", "\n", "z", "=", "quadmin", "(", "xi1", ",", "xi2", ",", "d", ",", "z1", ")", "\n", "e", "[", "i", "]", "=", "quadpol", "(", "z", ",", "d", ",", "z1", ")", "\n", "if", "e", "[", "i", "]", "<", "emin", ":", "\n", "                ", "emin", "=", "e", "[", "i", "]", "\n", "isplit", "=", "i", "\n", "splval", "=", "z", "\n", "\n", "", "", "", "return", "e", ",", "isplit", ",", "splval", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr": [[2, 10], ["max", "abs"], "function", ["None"], ["def", "chrelerr", "(", "fbest", ",", "stop", ")", ":", "\n", "    ", "fglob", "=", "stop", "[", "1", "]", "\n", "if", "fbest", "-", "fglob", "<=", "max", "(", "stop", "[", "0", "]", "*", "abs", "(", "fglob", ")", ",", "stop", "[", "2", "]", ")", ":", "\n", "        ", "flag", "=", "0", "\n", "", "else", ":", "\n", "        ", "flag", "=", "1", "\n", "\n", "", "return", "flag", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr": [[12, 19], ["None"], "function", ["None"], ["", "def", "chvtr", "(", "f", ",", "vtr", ")", ":", "\n", "    ", "if", "f", "<=", "vtr", ":", "\n", "        ", "flag", "=", "0", "\n", "", "else", ":", "\n", "        ", "flag", "=", "1", "\n", "\n", "", "return", "flag", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadmin": [[3, 23], ["quadratic_func.quadpol", "quadratic_func.quadpol", "quadratic_func.quadpol", "quadratic_func.quadpol"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol"], ["def", "quadmin", "(", "a", ",", "b", ",", "d", ",", "x0", ")", ":", "\n", "    ", "if", "d", "[", "2", "]", "==", "0", ":", "\n", "        ", "if", "d", "[", "1", "]", ">", "0", ":", "\n", "            ", "x", "=", "a", "\n", "", "else", ":", "\n", "            ", "x", "=", "b", "\n", "", "", "elif", "d", "[", "2", "]", ">", "0", ":", "\n", "        ", "x1", "=", "0.5", "*", "(", "x0", "[", "0", "]", "+", "x0", "[", "1", "]", ")", "-", "0.5", "*", "d", "[", "1", "]", "/", "d", "[", "2", "]", "\n", "if", "a", "<=", "x1", "and", "x1", "<=", "b", ":", "\n", "            ", "x", "=", "x1", "\n", "", "elif", "quadpol", "(", "a", ",", "d", ",", "x0", ")", "<", "quadpol", "(", "b", ",", "d", ",", "x0", ")", ":", "\n", "            ", "x", "=", "a", "\n", "", "else", ":", "\n", "            ", "x", "=", "b", "\n", "", "", "else", ":", "\n", "        ", "if", "quadpol", "(", "a", ",", "d", ",", "x0", ")", "<", "quadpol", "(", "b", ",", "d", ",", "x0", ")", ":", "\n", "            ", "x", "=", "a", "\n", "", "else", ":", "\n", "            ", "x", "=", "b", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol": [[26, 31], ["None"], "function", ["None"], ["", "def", "quadpol", "(", "x", ",", "d", ",", "x0", ")", ":", "\n", "    ", "'''\n        evaluates the quadratic polynomial\n    '''", "\n", "return", "d", "[", "0", "]", "+", "d", "[", "1", "]", "*", "(", "x", "-", "x0", "[", "0", "]", ")", "+", "d", "[", "2", "]", "*", "(", "x", "-", "x0", "[", "0", "]", ")", "*", "(", "x", "-", "x0", "[", "1", "]", ")", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.lsearch.lsearch": [[15, 229], ["len", "numpy.asarray", "src.optimization.parameter.mcs.mcs_fun.csearch.csearch", "copy.deepcopy", "copy.deepcopy", "numpy.asarray", "src.optimization.parameter.mcs.minq.minq.minq", "numpy.subtract", "numpy.linalg.norm", "numpy.dot", "max", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "max", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.gls.gls.gls", "numpy.argmin", "min", "numpy.asarray", "src.optimization.parameter.mcs.mcs_fun.neighbor.neighbor", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "numpy.asarray", "numpy.asarray", "src.optimization.parameter.mcs.minq.minq.minq", "numpy.linalg.norm", "numpy.dot", "min", "min", "range", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "min", "min", "range", "numpy.dot", "copy.deepcopy", "numpy.dot", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "range", "numpy.abs", "max", "len", "range", "numpy.asarray", "range", "src.optimization.parameter.mcs.mcs_fun.neighbor.neighbor", "src.optimization.parameter.mcs.mcs_fun.triple.triple", "src.optimization.parameter.mcs.mcs_fun.triple.triple", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "copy.deepcopy", "src.optimization.parameter.mcs.jones.functions.feval", "src.optimization.parameter.mcs.gls.gls.gls", "numpy.argmin", "min", "numpy.asarray", "max", "range", "min", "range", "numpy.dot", "numpy.dot", "max", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "abs", "abs", "range", "abs", "range", "range", "len", "len", "copy.deepcopy", "src.optimization.parameter.mcs.jones.functions.feval", "sum", "len", "len", "abs", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "max", "min", "numpy.linalg.norm", "len", "numpy.dot", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chrelerr", "abs", "max", "range", "numpy.abs", "max", "len", "numpy.dot", "min", "range", "len", "len", "len", "len", "range", "numpy.zeros", "src.optimization.parameter.mcs.gls.gls.gls", "numpy.argmin", "min", "max", "abs", "range", "range", "range", "numpy.dot", "numpy.dot", "range", "max", "src.optimization.parameter.mcs.mcs_fun.chk_flag.chvtr", "min", "len", "abs", "abs", "range", "abs", "range", "len", "min", "range", "len", "len", "len", "numpy.dot", "len", "min", "range", "len", "len", "len", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.csearch.csearch", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.gls.gls", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.neighbor.neighbor", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.minq.minq.minq", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.neighbor.neighbor", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.triple.triple", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.triple.triple", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.gls.gls", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chrelerr", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gls.gls.gls", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.chk_flag.chvtr"], ["def", "lsearch", "(", "fcn", ",", "x", ",", "f", ",", "f0", ",", "u", ",", "v", ",", "nf", ",", "stop", ",", "maxstep", ",", "gamma", ",", "hess", ",", "nsweep", ",", "nsweepbest", ")", ":", "\n", "    ", "ncall", "=", "0", "# ", "\n", "n", "=", "len", "(", "x", ")", "# ", "\n", "x0", "=", "np", ".", "asarray", "(", "[", "min", "(", "max", "(", "u", "[", "i", "]", ",", "0", ")", ",", "v", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "u", ")", ")", "]", ")", "#  % absolutely smallest point", "\n", "\n", "flag", "=", "1", "# ", "\n", "eps0", "=", "0.001", "# ", "\n", "nloc", "=", "1", "# ", "\n", "small", "=", "0.1", "# ", "\n", "smaxls", "=", "15", "# ", "\n", "\n", "xmin", ",", "fmi", ",", "g", ",", "G", ",", "nfcsearch", "=", "csearch", "(", "fcn", ",", "x", ",", "f", ",", "u", ",", "v", ",", "hess", ")", "\n", "\n", "xmin", "=", "[", "max", "(", "u", "[", "i", "]", ",", "min", "(", "xmin", "[", "i", "]", ",", "v", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "ncall", "=", "ncall", "+", "nfcsearch", "\n", "xold", "=", "copy", ".", "deepcopy", "(", "xmin", ")", "# deep copy is must here", "\n", "fold", "=", "copy", ".", "deepcopy", "(", "fmi", ")", "\n", "#print('csearch ends with:') # print(xmin,fmi,g,G,nfcsearch)", "\n", "\n", "eps", "=", "2.220446049250313e-16", "\n", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "        ", "flag", "=", "chrelerr", "(", "fmi", ",", "stop", ")", "# ", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "        ", "flag", "=", "chvtr", "(", "fmi", ",", "stop", "[", "1", "]", ")", "# ", "\n", "\n", "", "if", "not", "flag", ":", "\n", "        ", "return", "xmin", ",", "fmi", ",", "ncall", ",", "flag", ",", "nsweep", ",", "nsweepbest", "\n", "\n", "", "d", "=", "np", ".", "asarray", "(", "[", "min", "(", "min", "(", "xmin", "[", "i", "]", "-", "u", "[", "i", "]", ",", "v", "[", "i", "]", "-", "xmin", "[", "i", "]", ")", ",", "0.25", "*", "(", "1", "+", "abs", "(", "x", "[", "i", "]", "-", "x0", "[", "i", "]", ")", ")", ")", "for", "i", "in", "range", "(", "n", ")", "]", ")", "\n", "# Calling MINQ function # print(fmi,g,G,-d,d,0)", "\n", "p", ",", "_", ",", "_", "=", "minq", "(", "fmi", ",", "g", ",", "G", ",", "-", "d", ",", "d", ",", "0", ")", "# print('minq') # print(p) ", "\n", "\n", "x", "=", "[", "max", "(", "u", "[", "i", "]", ",", "min", "(", "xmin", "[", "i", "]", "+", "p", "[", "i", "]", ",", "v", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "n", ")", "]", "\n", "p", "=", "np", ".", "subtract", "(", "x", ",", "xmin", ")", "# project search direction to box", "\n", "\n", "if", "np", ".", "linalg", ".", "norm", "(", "p", ")", ":", "\n", "        ", "f1", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "alist", "=", "[", "0", ",", "1", "]", "\n", "flist", "=", "[", "fmi", ",", "f1", "]", "\n", "fpred", "=", "fmi", "+", "np", ".", "dot", "(", "g", ".", "T", ",", "p", ")", "+", "np", ".", "dot", "(", "0.5", ",", "np", ".", "dot", "(", "p", ".", "T", ",", "np", ".", "dot", "(", "G", ",", "p", ")", ")", ")", "\n", "alist", ",", "flist", ",", "nfls", "=", "gls", "(", "fcn", ",", "u", ",", "v", ",", "xmin", ",", "p", ",", "alist", ",", "flist", ",", "nloc", ",", "small", ",", "smaxls", ")", "\n", "ncall", "=", "ncall", "+", "nfls", "\n", "\n", "i", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "fminew", "=", "min", "(", "flist", ")", "\n", "if", "fminew", "==", "fmi", ":", "\n", "            ", "i", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "alist", ")", ")", "if", "not", "alist", "[", "i", "]", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "fmi", "=", "copy", ".", "deepcopy", "(", "fminew", ")", "\n", "\n", "", "xmin", "=", "xmin", "+", "np", ".", "dot", "(", "alist", "[", "i", "]", ",", "p", ")", "\n", "xmin", "=", "np", ".", "asarray", "(", "[", "max", "(", "u", "[", "i", "]", ",", "min", "(", "xmin", "[", "i", "]", ",", "v", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "n", ")", "]", ")", "\n", "gain", "=", "f", "-", "fmi", "\n", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "            ", "flag", "=", "chrelerr", "(", "fmi", ",", "stop", ")", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "            ", "flag", "=", "chvtr", "(", "fmi", ",", "stop", "[", "1", "]", ")", "\n", "\n", "", "if", "not", "flag", ":", "\n", "            ", "return", "xmin", ",", "fmi", ",", "ncall", ",", "flag", ",", "nsweep", ",", "nsweepbest", "\n", "\n", "", "if", "fold", "==", "fmi", ":", "\n", "            ", "r", "=", "0", "\n", "", "elif", "fold", "==", "fpred", ":", "\n", "            ", "r", "=", "0.5", "\n", "", "else", ":", "\n", "            ", "r", "=", "(", "fold", "-", "fmi", ")", "/", "(", "fold", "-", "fpred", ")", "\n", "", "", "else", ":", "\n", "        ", "gain", "=", "f", "-", "fmi", "\n", "r", "=", "0", "\n", "\n", "", "diag", "=", "0", "\n", "ind", "=", "[", "i", "for", "i", "in", "range", "(", "n", ")", "if", "(", "u", "[", "i", "]", "<", "xmin", "[", "i", "]", "and", "xmin", "[", "i", "]", "<", "v", "[", "i", "]", ")", "]", "\n", "b", "=", "np", ".", "dot", "(", "np", ".", "abs", "(", "g", ")", ".", "T", ",", "[", "max", "(", "abs", "(", "xmin", "[", "i", "]", ")", ",", "abs", "(", "xold", "[", "i", "]", ")", ")", "for", "i", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", ")", "# print('chek b')  print(g,xmin,xold) # print(b)", "\n", "nstep", "=", "0", "\n", "\n", "#print('ncall',nf, ncall, maxstep, len(ind),fmi, gain, r)", "\n", "while", "(", "ncall", "<", "nf", ")", "and", "(", "nstep", "<", "maxstep", ")", "and", "(", "(", "diag", "or", "len", "(", "ind", ")", "<", "n", ")", "or", "(", "stop", "[", "0", "]", "==", "0", "and", "fmi", "-", "gain", "<=", "stop", "[", "1", "]", ")", "or", "(", "b", ">=", "gamma", "*", "(", "f0", "-", "f", ")", "and", "gain", ">", "0", ")", ")", ":", "\n", "#print('while')", "\n", "        ", "nstep", "=", "nstep", "+", "1", "\n", "delta", "=", "[", "abs", "(", "xmin", "[", "i", "]", ")", "*", "eps", "**", "(", "1", "/", "3", ")", "for", "i", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", "\n", "#print('delta:',xmin, delta)        ", "\n", "j", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "delta", ")", ")", "if", "(", "not", "delta", "[", "inx", "]", ")", "]", "\n", "if", "len", "(", "j", ")", "!=", "0", ":", "\n", "            ", "for", "inx", "in", "j", ":", "\n", "                ", "delta", "[", "inx", "]", "=", "eps", "**", "(", "1", "/", "3", ")", "*", "1", "\n", "\n", "", "", "x1", ",", "x2", "=", "neighbor", "(", "xmin", ",", "delta", ",", "u", ",", "v", ")", "\n", "f", "=", "copy", ".", "deepcopy", "(", "fmi", ")", "\n", "\n", "if", "len", "(", "ind", ")", "<", "n", "and", "(", "b", "<", "gamma", "*", "(", "f0", "-", "f", ")", "or", "(", "not", "gain", ")", ")", ":", "\n", "            ", "ind1", "=", "[", "i", "for", "i", "in", "range", "(", "len", "(", "u", ")", ")", "if", "(", "xmin", "[", "i", "]", "==", "u", "[", "i", "]", "or", "xmin", "[", "i", "]", "==", "v", "[", "i", "]", ")", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "ind1", ")", ")", ":", "\n", "                ", "i", "=", "ind1", "[", "k", "]", "\n", "x", "=", "copy", ".", "deepcopy", "(", "xmin", ")", "\n", "if", "xmin", "[", "i", "]", "==", "u", "[", "i", "]", ":", "\n", "                    ", "x", "[", "i", "]", "=", "x2", "[", "i", "]", "\n", "", "else", ":", "\n", "                    ", "x", "[", "i", "]", "=", "x1", "[", "i", "]", "\n", "", "f1", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "\n", "if", "f1", "<", "fmi", ":", "\n", "                    ", "alist", "=", "[", "0", ",", "x", "[", "i", "]", ",", "-", "xmin", "[", "i", "]", "]", "\n", "flist", "=", "[", "fmi", ",", "f1", "]", "\n", "p", "=", "np", ".", "zeros", "(", "n", ")", "\n", "p", "[", "i", "]", "=", "1", "\n", "alist", ",", "flist", ",", "nfls", "=", "gls", "(", "fcn", ",", "u", ",", "v", ",", "xmin", ",", "p", ",", "alist", ",", "flist", ",", "nloc", ",", "small", ",", "6", ")", "\n", "ncall", "=", "ncall", "+", "nfls", "\n", "j", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "fminew", "=", "min", "(", "flist", ")", "# ", "\n", "if", "fminew", "==", "fmi", ":", "\n", "                        ", "j", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "alist", ")", ")", "if", "(", "not", "alist", "[", "inx", "]", ")", "]", "[", "0", "]", "\n", "", "else", ":", "\n", "                        ", "fmi", "=", "fminew", "\n", "", "xmin", "[", "i", "]", "=", "xmin", "[", "i", "]", "+", "alist", "[", "j", "]", "\n", "", "else", ":", "\n", "                    ", "ind1", "[", "k", "]", "=", "-", "1", "\n", "#end for", "\n", "", "", "xmin", "=", "np", ".", "asarray", "(", "[", "max", "(", "u", "[", "inx", "]", ",", "min", "(", "xmin", "[", "inx", "]", ",", "v", "[", "inx", "]", ")", ")", "for", "inx", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", ")", "\n", "if", "not", "sum", "(", "ind1", ")", ":", "\n", "                ", "break", "\n", "\n", "", "for", "inx", "in", "range", "(", "len", "(", "delta", ")", ")", ":", "\n", "                ", "delta", "[", "inx", "]", "=", "abs", "(", "xmin", "[", "inx", "]", ")", "*", "eps", "**", "(", "1", "/", "3", ")", "\n", "", "j", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "delta", ")", ")", "if", "(", "not", "delta", "[", "inx", "]", ")", "]", "\n", "if", "len", "(", "j", ")", "!=", "0", ":", "\n", "                ", "for", "inx", "in", "j", ":", "\n", "                    ", "delta", "[", "inx", "]", "=", "eps", "**", "(", "1", "/", "3", ")", "*", "1", "\n", "#end if", "\n", "", "", "x1", ",", "x2", "=", "neighbor", "(", "xmin", ",", "delta", ",", "u", ",", "v", ")", "\n", "#end if", "\n", "#print('r',r)", "\n", "", "if", "abs", "(", "r", "-", "1", ")", ">", "0.25", "or", "(", "not", "gain", ")", "or", "(", "b", "<", "gamma", "*", "(", "f0", "-", "f", ")", ")", ":", "\n", "            ", "xmin", ",", "fmi", ",", "g", ",", "G", ",", "x1", ",", "x2", ",", "nftriple", "=", "triple", "(", "fcn", ",", "xmin", ",", "fmi", ",", "x1", ",", "x2", ",", "u", ",", "v", ",", "hess", ",", "0", ",", "True", ")", "\n", "ncall", "=", "ncall", "+", "nftriple", "\n", "diag", "=", "0", "\n", "", "else", ":", "\n", "            ", "xmin", ",", "fmi", ",", "g", ",", "G", ",", "x1", ",", "x2", ",", "nftriple", "=", "triple", "(", "fcn", ",", "xmin", ",", "fmi", ",", "x1", ",", "x2", ",", "u", ",", "v", ",", "hess", ",", "G", ")", "\n", "ncall", "=", "ncall", "+", "nftriple", "\n", "diag", "=", "1", "\n", "#end if", "\n", "#print(nftriple)", "\n", "", "xold", "=", "copy", ".", "deepcopy", "(", "xmin", ")", "\n", "fold", "=", "copy", ".", "deepcopy", "(", "fmi", ")", "\n", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "            ", "flag", "=", "chrelerr", "(", "fmi", ",", "stop", ")", "# ", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "            ", "flag", "=", "chvtr", "(", "fmi", ",", "stop", "[", "1", "]", ")", "# ", "\n", "\n", "", "if", "not", "flag", ":", "\n", "            ", "return", "xmin", ",", "fmi", ",", "ncall", ",", "flag", ",", "nsweep", ",", "nsweepbest", "\n", "", "if", "r", "<", "0.25", ":", "\n", "            ", "d", "=", "0.5", "*", "d", "\n", "", "elif", "r", ">", "0.75", ":", "\n", "            ", "d", "=", "2", "*", "d", "\n", "\n", "", "minusd", "=", "np", ".", "asarray", "(", "[", "max", "(", "-", "d", "[", "jnx", "]", ",", "u", "[", "jnx", "]", "-", "xmin", "[", "jnx", "]", ")", "for", "jnx", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", ")", "\n", "mind", "=", "np", ".", "asarray", "(", "[", "min", "(", "d", "[", "jnx", "]", ",", "v", "[", "jnx", "]", "-", "xmin", "[", "jnx", "]", ")", "for", "jnx", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", ")", "\n", "p", ",", "_", ",", "_", "=", "minq", "(", "fmi", ",", "g", ",", "G", ",", "minusd", ",", "mind", ",", "0", ")", "\n", "\n", "#print(p, np.linalg.norm(p))", "\n", "if", "not", "(", "np", ".", "linalg", ".", "norm", "(", "p", ")", ")", "and", "(", "not", "diag", ")", "and", "(", "len", "(", "ind", ")", "==", "n", ")", ":", "\n", "            ", "break", "\n", "\n", "", "if", "np", ".", "linalg", ".", "norm", "(", "p", ")", ":", "\n", "#print(g, p, G)", "\n", "            ", "fpred", "=", "fmi", "+", "np", ".", "dot", "(", "g", ".", "T", ",", "p", ")", "+", "np", ".", "dot", "(", "0.5", ",", "np", ".", "dot", "(", "p", ".", "T", ",", "np", ".", "dot", "(", "G", ",", "p", ")", ")", ")", "\n", "x", "=", "copy", ".", "deepcopy", "(", "xmin", "+", "p", ")", "\n", "f1", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "\n", "alist", "=", "[", "0", ",", "1", "]", "\n", "flist", "=", "[", "fmi", ",", "f1", "]", "\n", "alist", ",", "flist", ",", "nfls", "=", "gls", "(", "fcn", ",", "u", ",", "v", ",", "xmin", ",", "p", ",", "alist", ",", "flist", ",", "nloc", ",", "small", ",", "smaxls", ")", "\n", "ncall", "=", "ncall", "+", "nfls", "\n", "argmin", "=", "np", ".", "argmin", "(", "flist", ")", "\n", "fmi", "=", "min", "(", "flist", ")", "\n", "xmin", "=", "[", "xmin", "[", "jnx", "]", "+", "alist", "[", "argmin", "]", "*", "p", "[", "jnx", "]", "for", "jnx", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", "\n", "xmin", "=", "np", ".", "asarray", "(", "[", "max", "(", "u", "[", "jnx", "]", ",", "min", "(", "xmin", "[", "jnx", "]", ",", "v", "[", "jnx", "]", ")", ")", "for", "jnx", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", ")", "\n", "if", "stop", "[", "0", "]", ">", "0", "and", "stop", "[", "0", "]", "<", "1", ":", "\n", "                ", "flag", "=", "chrelerr", "(", "fmi", ",", "stop", ")", "# ", "\n", "", "elif", "stop", "[", "0", "]", "==", "0", ":", "\n", "                ", "flag", "=", "chvtr", "(", "fmi", ",", "stop", "[", "1", "]", ")", "# ", "\n", "", "if", "not", "flag", ":", "\n", "                ", "return", "xmin", ",", "fmi", ",", "ncall", ",", "flag", ",", "nsweep", ",", "nsweepbest", "\n", "\n", "", "gain", "=", "f", "-", "fmi", "\n", "if", "fold", "==", "fmi", ":", "\n", "                ", "r", "=", "0", "\n", "", "elif", "fold", "==", "fpred", ":", "\n", "                ", "r", "=", "0.5", "\n", "", "else", ":", "\n", "                ", "r", "=", "(", "fold", "-", "fmi", ")", "/", "(", "fold", "-", "fpred", ")", ";", "\n", "", "if", "fmi", "<", "fold", ":", "\n", "                ", "fac", "=", "abs", "(", "1", "-", "1", "/", "r", ")", "# ", "\n", "eps0", "=", "max", "(", "eps", ",", "min", "(", "fac", "*", "eps0", ",", "0.001", ")", ")", "# ", "\n", "", "else", ":", "\n", "                ", "eps0", "=", "0.001", "# ", "\n", "", "", "else", ":", "\n", "            ", "gain", "=", "f", "-", "fmi", "\n", "if", "(", "not", "gain", ")", ":", "\n", "                ", "eps0", "=", "0.001", "\n", "fac", "=", "np", ".", "Inf", "\n", "r", "=", "0", "\n", "#end not gain", "\n", "#end if norm p", "\n", "", "", "ind", "=", "[", "inx", "for", "inx", "in", "range", "(", "len", "(", "u", ")", ")", "if", "(", "u", "[", "inx", "]", "<", "xmin", "[", "inx", "]", "and", "xmin", "[", "inx", "]", "<", "v", "[", "inx", "]", ")", "]", "\n", "b", "=", "np", ".", "dot", "(", "np", ".", "abs", "(", "g", ")", ".", "T", ",", "[", "max", "(", "abs", "(", "xmin", "[", "inx", "]", ")", ",", "abs", "(", "xold", "[", "inx", "]", ")", ")", "for", "inx", "in", "range", "(", "len", "(", "xmin", ")", ")", "]", ")", "\n", "#end while", "\n", "", "return", "xmin", ",", "fmi", ",", "ncall", ",", "flag", ",", "nsweep", ",", "nsweepbest", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtf.updtf": [[3, 12], ["range"], "function", ["None"], ["def", "updtf", "(", "n", ",", "i", ",", "x1", ",", "x2", ",", "f1", ",", "f2", ",", "fold", ",", "f", ")", ":", "\n", "    ", "for", "i1", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "i1", "!=", "i", ":", "\n", "            ", "if", "x1", "[", "i1", "]", "==", "np", ".", "Inf", ":", "\n", "                ", "f1", "[", "i1", "]", "=", "f1", "[", "i1", "]", "+", "fold", "-", "f", "\n", "", "if", "x2", "[", "i1", "]", "==", "np", ".", "Inf", ":", "\n", "                ", "f2", "[", "i1", "]", "=", "f2", "[", "i1", "]", "+", "fold", "-", "f", "\n", "", "", "", "fold", "=", "f", "\n", "return", "f1", ",", "f2", ",", "fold", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.strtsw.strtsw": [[3, 27], ["numpy.zeros().astype", "range", "numpy.zeros"], "function", ["None"], ["def", "strtsw", "(", "smax", ",", "level", ",", "f", ",", "nboxes", ",", "record", ")", ":", "\n", "    ", "'''\n    # global nboxes record\n    % nboxes - number of boxes not in the `shopping basket'\n    % record(1:smax-1)  vector pointing to the best non-split box at each\n    %              level; record(s) = 0 if there is no non-split box at \n    %              level s (record list)\n    '''", "\n", "#% initialization", "\n", "record", "=", "np", ".", "zeros", "(", "smax", ")", ".", "astype", "(", "int", ")", "\n", "s", "=", "smax", "\n", "for", "j", "in", "range", "(", "nboxes", "+", "1", ")", ":", "\n", "# recording non-split boxes", "\n", "        ", "if", "level", "[", "j", "]", ">", "0", ":", "# level denoted  0 < s < smax ", "\n", "            ", "if", "level", "[", "j", "]", "<", "s", ":", "\n", "                ", "s", "=", "level", "[", "j", "]", "# assigning level ", "\n", "\n", "", "if", "not", "record", "[", "level", "[", "j", "]", "]", ":", "\n", "                ", "record", "[", "level", "[", "j", "]", "]", "=", "j", "\n", "#print('for ',level[j],j)", "\n", "", "elif", "f", "[", "j", "]", "<", "f", "[", "record", "[", "level", "[", "j", "]", "]", "]", ":", "\n", "                ", "record", "[", "level", "[", "j", "]", "]", "=", "j", "\n", "#print(level[j],j)", "\n", "", "", "", "return", "s", ",", "record", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.subint": [[6, 19], ["abs", "abs", "src.optimization.parameter.mcs.mcs_fun.sign.sign", "abs", "abs", "src.optimization.parameter.mcs.mcs_fun.sign.sign"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.sign.sign", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.sign.sign"], ["def", "subint", "(", "x1", ",", "x2", ")", ":", "\n", "    ", "'''\n    computes [min(x,y),max(x,y)] that are neither too close nor too far away from x \n    '''", "\n", "f", "=", "1000", ";", "\n", "if", "f", "*", "abs", "(", "x1", ")", "<", "1", ":", "\n", "        ", "if", "abs", "(", "x2", ")", ">", "f", ":", "\n", "            ", "x2", "=", "sign", "(", "x2", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "abs", "(", "x2", ")", ">", "f", ":", "\n", "            ", "x2", "=", "10", "*", "sign", "(", "x2", ")", "*", "abs", "(", "x1", ")", "\n", "", "", "x1", "=", "x1", "+", "(", "x2", "-", "x1", ")", "/", "10", "\n", "return", "x1", ",", "x2", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.init": [[22, 68], ["numpy.zeros", "range", "src.optimization.parameter.mcs.jones.functions.feval", "numpy.zeros", "numpy.zeros().astype", "range", "range", "numpy.zeros", "src.optimization.parameter.mcs.jones.functions.feval"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.jones.functions.feval"], ["", "def", "init", "(", "fcn", ",", "x0", ",", "l", ",", "L", ",", "n", ")", ":", "\n", "    ", "'''\n     computes the function values corresponding to the initialization list\n     and the pointer istar to the final best point x^* of the init. list\n    '''", "\n", "ncall", "=", "0", "#  set number of function call to 0    ", "\n", "\n", "# fetch intial point x0  ", "\n", "x", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "#  feteching int the mid point; ", "\n", "        ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "l", "[", "i", "]", "]", "# value at l[i] is the indeces of mid point", "\n", "# x0 (inital point)", "\n", "#x = x.astype(int)", "\n", "\n", "", "f1", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "# increasing the number of function call by 1", "\n", "\n", "f0", "=", "np", ".", "zeros", "(", "(", "L", "[", "0", "]", "+", "1", ",", "n", ")", ")", "\n", "f0", "[", "l", "[", "0", "]", ",", "0", "]", "=", "f1", "# computing f(x) at intial point x0", "\n", "\n", "# searching for x*  =  x0 (inital point)", "\n", "# i* the pointer in the list indicating the potision (indecies ) of x*", "\n", "istar", "=", "np", ".", "zeros", "(", "n", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# for all cordinate k (in this case i) in dim n", "\n", "#for k = 1 to n (in this case 0 to n-1)", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "istar", "[", "i", "]", "=", "l", "[", "i", "]", "# set i* to mid point", "\n", "for", "j", "in", "range", "(", "L", "[", "i", "]", "+", "1", ")", ":", "# 1 added to make index value also work as an array length", "\n", "            ", "if", "j", "==", "l", "[", "i", "]", ":", "\n", "                ", "if", "i", "!=", "0", ":", "\n", "                    ", "f0", "[", "j", ",", "i", "]", "=", "f0", "[", "istar", "[", "i", "-", "1", "]", ",", "i", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "j", "]", "\n", "f0", "[", "j", ",", "i", "]", "=", "feval", "(", "fcn", ",", "x", ")", "\n", "ncall", "=", "ncall", "+", "1", "# increasing the number of cfunction call by 1 each time", "\n", "#print(i+1,j+1,x,f0[j,i])", "\n", "if", "f0", "[", "j", ",", "i", "]", "<", "f1", ":", "\n", "                    ", "f1", "=", "f0", "[", "j", ",", "i", "]", "\n", "istar", "[", "i", "]", "=", "j", "\n", "# end search in list ", "\n", "# update x*", "\n", "", "", "", "x", "[", "i", "]", "=", "x0", "[", "i", ",", "istar", "[", "i", "]", "]", "\n", "#end for k = 1:n  ", "\n", "", "return", "f0", ",", "istar", ",", "ncall", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.initi_func.initbox": [[77, 206], ["len", "numpy.zeros", "range", "numpy.zeros().astype", "numpy.zeros", "range", "src.optimization.parameter.mcs.mcs_fun.polint.polint", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadmin", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadpol", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadmin", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadpol", "range", "numpy.argmax", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "src.optimization.parameter.mcs.mcs_fun.genbox.genbox", "numpy.zeros", "src.optimization.parameter.mcs.mcs_fun.polint.polint", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadmin", "min", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadmin", "max", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadpol", "src.optimization.parameter.mcs.mcs_fun.quadratic_func.quadpol"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadmin", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadmin", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.genbox.genbox", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadmin", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadmin", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.quadratic_func.quadpol"], ["def", "initbox", "(", "x0", ",", "f0", ",", "l", ",", "L", ",", "istar", ",", "u", ",", "v", ",", "isplit", ",", "level", ",", "ipar", ",", "ichild", ",", "f", ",", "nboxes", ",", "prt", ")", ":", "\n", "    ", "'''\n        generates the boxes in the initialization procedure\n    \n    '''", "\n", "n", "=", "len", "(", "u", ")", "\n", "# intilize the ith histopy with the folowing:", "\n", "# parent  box index, ", "\n", "# level of parent box, ", "\n", "# split index of the parent box, ", "\n", "# number of child", "\n", "# ", "\n", "\n", "# parent of the ith box ", "\n", "# it is the index into the number of boxex ", "\n", "ipar", "[", "0", "]", "=", "-", "1", "#  parent box is index -1 for the root box", "\n", "# history level o the parent box: initilize to 1 as the 0 < level s < smax of root box is 1", "\n", "# indicate box 0 with level value s = 1", "\n", "level", "[", "0", "]", "=", "1", "\n", "# ichild indicate the child of box 0 ", "\n", "ichild", "[", "0", "]", "=", "1", "\n", "# optimi value of the box is x0", "\n", "f", "[", "0", ",", "0", "]", "=", "f0", "[", "l", "[", "0", "]", ",", "0", "]", "\n", "# intilize partent box  = 0", "\n", "par", "=", "0", "# index of the parent box (biously 0 in this case as box index start with z)", "\n", "\n", "\n", "var", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "#print('parent box',par)", "\n", "# boxes split in the init. procedure get a negative splitting index of the ith coordinate (dimension)", "\n", "        ", "isplit", "[", "par", "]", "=", "-", "i", "-", "1", "# set a negative index value", "\n", "nchild", "=", "0", "\n", "# check if x left endpoint is > lower bound (left endpoint)", "\n", "# if so - genetrate a box", "\n", "if", "x0", "[", "i", ",", "0", "]", ">", "u", "[", "i", "]", ":", "\n", "            ", "nboxes", "=", "nboxes", "+", "1", "# one extra box is generated for the parent box", "\n", "nchild", "=", "nchild", "+", "1", "# therefore incerase number of child by 1 of the parent box", "\n", "# set parent of this ith box split in the ithe direction (dimension)", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "level", "[", "par", "]", "+", "1", ",", "-", "nchild", ",", "f0", "[", "0", ",", "i", "]", ")", "\n", "# end if", "\n", "\n", "", "if", "L", "[", "i", "]", "==", "2", ":", "\n", "            ", "v1", "=", "v", "[", "i", "]", "\n", "", "else", ":", "\n", "            ", "v1", "=", "x0", "[", "i", ",", "2", "]", "\n", "# end if", "\n", "\n", "# pollynomial interpolation to get three points for", "\n", "", "d", "=", "polint", "(", "x0", "[", "i", ",", "0", ":", "3", "]", ",", "f0", "[", "0", ":", "3", ",", "i", "]", ")", "\n", "xl", "=", "quadmin", "(", "u", "[", "i", "]", ",", "v1", ",", "d", ",", "x0", "[", "i", ",", "0", ":", "3", "]", ")", "\n", "fl", "=", "quadpol", "(", "xl", ",", "d", ",", "x0", "[", "i", ",", "0", ":", "3", "]", ")", "\n", "xu", "=", "quadmin", "(", "u", "[", "i", "]", ",", "v1", ",", "-", "d", ",", "x0", "[", "i", ",", "0", ":", "3", "]", ")", "\n", "fu", "=", "quadpol", "(", "xu", ",", "d", ",", "x0", "[", "i", ",", "0", ":", "3", "]", ")", "\n", "\n", "if", "istar", "[", "i", "]", "==", "0", ":", "\n", "            ", "if", "xl", "<", "x0", "[", "i", ",", "0", "]", ":", "\n", "                ", "par1", "=", "nboxes", "# label of the current box for the next coordinate ", "\n", "", "else", ":", "\n", "                ", "par1", "=", "nboxes", "+", "1", "\n", "#end istart", "\n", "\n", "", "", "for", "j", "in", "range", "(", "L", "[", "i", "]", ")", ":", "\n", "            ", "nboxes", "=", "nboxes", "+", "1", "\n", "nchild", "=", "nchild", "+", "1", "\n", "if", "f0", "[", "j", ",", "i", "]", "<=", "f0", "[", "j", "+", "1", ",", "i", "]", ":", "\n", "                ", "s", "=", "1", "\n", "", "else", ":", "\n", "                ", "s", "=", "2", "\n", "", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "level", "[", "par", "]", "+", "s", ",", "-", "nchild", ",", "f0", "[", "j", ",", "i", "]", ")", "\n", "#if prt: splval = split1(x0[i,j],x0[i,j+1],f0[j,i],f0[j+1,i])", "\n", "\n", "if", "j", ">=", "1", ":", "\n", "                ", "if", "istar", "[", "i", "]", "==", "j", ":", "\n", "                    ", "if", "xl", "<=", "x0", "[", "i", ",", "j", "]", ":", "\n", "                        ", "par1", "=", "nboxes", "-", "1", "# label of the current box for the next coordinate ", "\n", "", "else", ":", "\n", "                        ", "par1", "=", "nboxes", "\n", "#end istar", "\n", "", "", "if", "j", "<=", "L", "[", "i", "]", "-", "2", ":", "\n", "                    ", "d", "=", "polint", "(", "x0", "[", "i", ",", "j", ":", "j", "+", "1", "]", ",", "f0", "[", "j", ":", "j", "+", "1", ",", "i", "]", ")", "\n", "if", "j", "<", "L", "[", "i", "]", "-", "2", ":", "\n", "                        ", "u1", "=", "x0", "[", "i", ",", "j", "+", "1", "]", "\n", "", "else", ":", "\n", "                        ", "u1", "=", "v", "[", "i", "]", "\n", "# end if", "\n", "", "xl", "=", "quadmin", "(", "x0", "[", "i", ",", "j", "]", ",", "u1", ",", "d", ",", "x0", "[", "i", ",", "j", ":", "j", "+", "1", "]", ")", "\n", "fl", "=", "min", "(", "quadpol", "(", "xl", ",", "d", ",", "x0", "[", "i", ",", "j", ":", "j", "+", "1", "]", ")", ",", "fl", ")", "\n", "xu", "=", "quadmin", "(", "x0", "[", "i", ",", "j", "]", ",", "u1", ",", "-", "d", ",", "x0", "[", "i", ",", "j", ":", "j", "+", "1", "]", ")", "\n", "fu", "=", "max", "(", "quadpol", "(", "xu", ",", "d", ",", "x0", "[", "i", ",", "j", ":", "j", "+", "1", "]", ")", ",", "fu", ")", "\n", "#end j < Li -2", "\n", "# end if j > = 1", "\n", "", "", "nboxes", "=", "nboxes", "+", "1", "\n", "nchild", "=", "nchild", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "level", "[", "par", "]", "+", "3", "-", "s", ",", "-", "nchild", ",", "f0", "[", "j", "+", "1", ",", "i", "]", ")", "\n", "#end for j", "\n", "", "if", "x0", "[", "i", ",", "L", "[", "i", "]", "]", "<", "v", "[", "i", "]", ":", "\n", "            ", "nboxes", "=", "nboxes", "+", "1", "\n", "nchild", "=", "nchild", "+", "1", "\n", "ipar", "[", "nboxes", "]", ",", "level", "[", "nboxes", "]", ",", "ichild", "[", "nboxes", "]", ",", "f", "[", "0", ",", "nboxes", "]", "=", "genbox", "(", "par", ",", "level", "[", "par", "]", "+", "1", ",", "-", "nchild", ",", "f0", "[", "L", "[", "i", "]", ",", "i", "]", ")", "\n", "\n", "", "if", "istar", "[", "i", "]", "==", "L", "[", "i", "]", ":", "\n", "            ", "if", "x0", "[", "i", ",", "L", "[", "i", "]", "]", "<", "v", "[", "i", "]", ":", "\n", "                ", "if", "xl", "<=", "x0", "[", "i", ",", "L", "[", "i", "]", "]", ":", "\n", "                    ", "par1", "=", "nboxes", "-", "1", "# label of the current box for the next coordinate ", "\n", "", "else", ":", "\n", "                    ", "par1", "=", "nboxes", "\n", "#end if xl < x0", "\n", "", "", "else", ":", "\n", "                ", "par1", "=", "nboxes", "\n", "#end if x0 < v", "\n", "#end if istart", "\n", "", "", "var", "[", "i", "]", "=", "fu", "-", "fl", "\n", "\n", "# the quadratic model is taken as a crude measure of the variability in the ith component", "\n", "level", "[", "par", "]", "=", "0", "# box is marked as split", "\n", "par", "=", "par1", "\n", "#end for", "\n", "", "fbest", "=", "f0", "[", "istar", "[", "n", "-", "1", "]", ",", "n", "-", "1", "]", "#best function value after the init. procedure", "\n", "p", "=", "np", ".", "zeros", "(", "n", ")", ".", "astype", "(", "int", ")", "\n", "xbest", "=", "np", ".", "zeros", "(", "n", ")", "\n", "#print(nboxes)", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "#var0 = max(var) ", "\n", "        ", "p", "[", "i", "]", "=", "np", ".", "argmax", "(", "var", ")", "\n", "var", "[", "p", "[", "i", "]", "]", "=", "-", "1", "\n", "xbest", "[", "i", "]", "=", "x0", "[", "i", ",", "istar", "[", "i", "]", "]", "# best point after the init. procedured", "\n", "\n", "", "return", "ipar", ",", "level", ",", "ichild", ",", "f", ",", "isplit", ",", "p", ",", "xbest", ",", "fbest", ",", "nboxes", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint": [[3, 18], ["numpy.zeros"], "function", ["None"], ["def", "polint", "(", "x", ",", "f", ")", ":", "\n", "    ", "'''\n     quadratic polynomial interpolation\n     args: \n         x(1:3)  3 pairwise distinct support points\n         f(1:3)  corresponding function values\n    return:\n        d(1:3)  the interpolating polynomial is given by\n    '''", "\n", "d", "=", "np", ".", "zeros", "(", "3", ")", "\n", "d", "[", "0", "]", "=", "f", "[", "0", "]", "\n", "d", "[", "1", "]", "=", "(", "f", "[", "1", "]", "-", "f", "[", "0", "]", ")", "/", "(", "x", "[", "1", "]", "-", "x", "[", "0", "]", ")", "\n", "f12", "=", "(", "f", "[", "2", "]", "-", "f", "[", "1", "]", ")", "/", "(", "x", "[", "2", "]", "-", "x", "[", "1", "]", ")", "\n", "d", "[", "2", "]", "=", "(", "f12", "-", "d", "[", "1", "]", ")", "/", "(", "x", "[", "2", "]", "-", "x", "[", "0", "]", ")", "\n", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.polint.polint1": [[20, 31], ["None"], "function", ["None"], ["", "def", "polint1", "(", "x", ",", "f", ")", ":", "\n", "    ", "'''\n        quadratic polynomial interpolation\n    '''", "\n", "f13", "=", "(", "f", "[", "2", "]", "-", "f", "[", "0", "]", ")", "/", "(", "x", "[", "2", "]", "-", "x", "[", "0", "]", ")", "\n", "f12", "=", "(", "f", "[", "1", "]", "-", "f", "[", "0", "]", ")", "/", "(", "x", "[", "1", "]", "-", "x", "[", "0", "]", ")", "\n", "f23", "=", "(", "f", "[", "2", "]", "-", "f", "[", "1", "]", ")", "/", "(", "x", "[", "2", "]", "-", "x", "[", "1", "]", ")", "\n", "\n", "g", "=", "f13", "+", "f12", "-", "f23", "\n", "G", "=", "2", "*", "(", "f13", "-", "f12", ")", "/", "(", "x", "[", "2", "]", "-", "x", "[", "1", "]", ")", "\n", "return", "g", ",", "G", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.splrnk.splrnk": [[5, 37], ["range", "src.optimization.parameter.mcs.mcs_fun.split_func.split2"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split2"], ["def", "splrnk", "(", "n", ",", "n0", ",", "p", ",", "x", ",", "y", ")", ":", "\n", "    ", "'''# determines the splitting index and splitting value for splitting a\n    % box by rank\n    % Input:\n    % n        dimension of the problem\n    % n0(1:n)  coordinate i has been split n0(i) times in the history of the\n    %          box to split\n    % p(1:n)   ranking of estimated variability of the function in the \n    %          different coordinates\n    % x(1:n)   base vertex of the box\n    % y(1:n)   opposite vertex of the box\n    % Output:\n    % isplit   splitting index\n    % splval   = Inf  if n0(isplit) = 0 (indicates that the box has to be\n    %                 split according to the initialization list)\n    %          = splitting value  otherwise\n    '''", "\n", "\n", "isplit", "=", "0", "\n", "n1", "=", "n0", "[", "0", "]", "\n", "p1", "=", "p", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "n", ")", ":", "\n", "        ", "if", "n0", "[", "i", "]", "<", "n1", "or", "(", "n0", "[", "i", "]", "==", "n1", "and", "p", "[", "i", "]", "<", "p1", ")", ":", "\n", "            ", "isplit", "=", "i", "\n", "n1", "=", "n0", "[", "i", "]", "\n", "p1", "=", "p", "[", "i", "]", "\n", "", "", "if", "n1", ">", "0", ":", "\n", "        ", "splval", "=", "split2", "(", "x", "[", "isplit", "]", ",", "y", "[", "isplit", "]", ")", "\n", "", "else", ":", "\n", "     ", "splval", "=", "np", ".", "Inf", "\n", "# end", "\n", "", "return", "isplit", ",", "splval", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.sign.sign": [[2, 12], ["None"], "function", ["None"], ["def", "sign", "(", "x", ")", ":", "\n", "    ", "'''\n        Finds the sign of the interger\n    '''", "\n", "if", "x", ">", "0", ":", "\n", "        ", "return", "1", "\n", "", "elif", "x", "==", "0", ":", "\n", "        ", "return", "0", "\n", "", "else", ":", "\n", "        ", "return", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.updtrec.updtrec": [[2, 21], ["len"], "function", ["None"], ["def", "updtrec", "(", "j", ",", "s", ",", "f", ",", "record", ")", ":", "\n", "    ", "'''\n        % Input:\n        % j           label of a box\n        % s           its level\n        % f           vector containing the base vertex function values of the\n        %             already defined boxes\n        % updates the pointer record(s) to the best non-split box at level s\n        #global record      % record list\n    '''", "\n", "if", "len", "(", "record", ")", "<", "s", ":", "\n", "        ", "record", "[", "s", "]", "=", "j", "\n", "", "elif", "record", "[", "s", "]", "==", "0", ":", "\n", "        ", "record", "[", "s", "]", "=", "j", "\n", "", "elif", "f", "[", "j", "]", "<", "f", "[", "record", "[", "s", "]", "]", ":", "\n", "        ", "record", "[", "s", "]", "=", "j", "\n", "\n", "#print(j,s,record[s])", "\n", "", "return", "record", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mh.meta_heuristics.Metaheuristics.__init__": [[22, 26], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mh.meta_heuristics.Metaheuristics.start": [[28, 51], ["src.optimization.parameter.mcs.mcs_opt.TheMCS", "src.optimization.parameter.mcs.mcs_opt.TheMCS.optimize", "src.optimization.parameter.mh.algo.sa.SimulatedAnnealing", "src.optimization.parameter.mh.algo.sa.SimulatedAnnealing.optimize", "src.optimization.parameter.mh.algo.de.DifferentialEvolution", "src.optimization.parameter.mh.algo.de.DifferentialEvolution.optimize", "src.optimization.parameter.mh.algo.bsd.BernstainSearchDE", "src.optimization.parameter.mh.algo.bsd.BernstainSearchDE.optimize", "src.optimization.parameter.mh.algo.pso.PSO", "src.optimization.parameter.mh.algo.pso.PSO.optimize"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize"], ["", "def", "start", "(", "self", ")", ":", "\n", "        ", "'''\n             Optimizae a vector using \n        '''", "\n", "if", "self", ".", "mParams", ".", "n_algo_param", "==", "'mcs'", ":", "#'mcs'", "\n", "            ", "mcs", "=", "TheMCS", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ",", "self", ".", "mTree", ")", "\n", "return", "mcs", ".", "optimize", "(", ")", "\n", "\n", "", "if", "self", ".", "mParams", ".", "n_algo_param", "==", "'sa'", ":", "# 'sa'", "\n", "            ", "sa", "=", "SimulatedAnnealing", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ",", "self", ".", "mTree", ")", "\n", "return", "sa", ".", "optimize", "(", ")", "\n", "\n", "", "if", "self", ".", "mParams", ".", "n_algo_param", "==", "'de'", ":", "\n", "            ", "de", "=", "DifferentialEvolution", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ",", "self", ".", "mTree", ")", "\n", "return", "de", ".", "optimize", "(", ")", "\n", "\n", "", "if", "self", ".", "mParams", ".", "n_algo_param", "==", "'bsde'", ":", "#'bsde'", "\n", "            ", "bsde", "=", "BernstainSearchDE", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ",", "self", ".", "mTree", ")", "\n", "return", "bsde", ".", "optimize", "(", ")", "\n", "\n", "", "if", "self", ".", "mParams", ".", "n_algo_param", "==", "'pso'", ":", "#'pso'", "\n", "            ", "pso", "=", "PSO", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ",", "self", ".", "mTree", ")", "\n", "return", "pso", ".", "optimize", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mh.mh_cost_function.costFunction": [[9, 29], ["pTree.setTreeParameters", "pData.getTreePredictedOutputs", "pTree.setTreeParameters", "pData.getTreePredictedOutputs", "pData.getTreeFitness", "pData.getTreeFitness", "pTree.getTreeSize"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["def", "costFunction", "(", "pParameter", ",", "pTree", ",", "pData", ",", "p_max_target_attr", ",", "eval_parama", "=", "'all'", ",", "only_error", "=", "True", ")", ":", "\n", "    ", "'''\n    computes parameter fitness.\n    args:\n        pParameter:         paramter vector to be set as tree parameter\n        pTree:              tree to be evaluated\n        pData:              training/test data to be evalauated\n        p_max_target_attr:  max number of target attribute to examine number of child of tree trrot\n        eval_parama:        'all' , 'weights' 'weights_and_bias' 'bias' \n    \n    return: (float) error induced on pTree \n    '''", "\n", "if", "only_error", ":", "\n", "        ", "pTree", ".", "setTreeParameters", "(", "pParameter", ",", "p_max_target_attr", ",", "eval_parama", ")", "\n", "_", "=", "pData", ".", "getTreePredictedOutputs", "(", "pTree", ")", "\n", "return", "pData", ".", "getTreeFitness", "(", ")", "[", "0", "]", "\n", "", "else", ":", "\n", "        ", "pTree", ".", "setTreeParameters", "(", "pParameter", ",", "p_max_target_attr", ",", "eval_parama", ")", "\n", "_", "=", "pData", ".", "getTreePredictedOutputs", "(", "pTree", ")", "\n", "return", "pData", ".", "getTreeFitness", "(", ")", "+", "[", "pTree", ".", "getTreeSize", "(", ")", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mh.misc.bound_check": [[8, 32], ["len", "range", "print", "len"], "function", ["None"], ["def", "bound_check", "(", "bound", ",", "parameter", ")", ":", "\n", "    ", "'''\n     Check min and max of an element in the parameter\n     args:\n         param:     bound           is a list of two items: [min, max]\n         param:     parameter       is vector of real values\n     return:  a parameter set to boundary of the papremater\n    '''", "\n", "if", "len", "(", "bound", ")", ">=", "2", ":", "\n", "        ", "minimum", "=", "bound", "[", "0", "]", "\n", "maximum", "=", "bound", "[", "1", "]", "\n", "\n", "for", "elm", "in", "range", "(", "len", "(", "parameter", ")", ")", ":", "\n", "            ", "if", "parameter", "[", "elm", "]", "<", "minimum", ":", "\n", "# if the element of paramter is less then min value then set it ot min value", "\n", "                ", "parameter", "[", "elm", "]", "=", "minimum", "\n", "", "if", "parameter", "[", "elm", "]", ">", "maximum", ":", "\n", "# if the element of paramter is greter then max value then set it ot max value", "\n", "                ", "parameter", "[", "elm", "]", "=", "maximum", "\n", "", "", "", "else", ":", "\n", "        ", "print", "(", "'First argument of bound_check takes a list of two items [min, max]'", ")", "\n", "\n", "# return the parameter with or without check", "\n", "", "return", "parameter", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.sa.SimulatedAnnealing.__init__": [[31, 40], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "if", "(", "pParams", ".", "n_fun_type", "==", "'Gaussian'", ")", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'all'", "\n", "", "else", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'weights_and_bias'", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.sa.SimulatedAnnealing.optimize": [[43, 136], ["print", "sa.SimulatedAnnealing.mEvaluateTree.set_dataset_to_evaluate", "sa.SimulatedAnnealing.mTree.getTreeParameters", "print", "sa.SimulatedAnnealing.performance_record.append", "copy.deepcopy", "sa.SimulatedAnnealing.fobj", "range", "sa.SimulatedAnnealing.mTree.setTreeParameters", "len", "sa.SimulatedAnnealing.fobj", "sa.SimulatedAnnealing.fobj", "math.log", "math.log", "range", "sa.SimulatedAnnealing.performance_record.append", "sa.SimulatedAnnealing.fix_boundry", "sa.SimulatedAnnealing.fobj", "abs", "sa.SimulatedAnnealing.fobj", "numpy.mod", "print", "math.exp", "random.random", "copy.deepcopy", "random.random"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fix_boundry", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj"], ["", "", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "'''\n            Run Simulated Annealing optimization\n            \n        '''", "\n", "print", "(", "'The Simulated Annealing: '", ",", "self", ".", "mParams", ".", "n_algo_param", ")", "\n", "self", ".", "mEvaluateTree", ".", "set_dataset_to_evaluate", "(", "'train'", ")", "\n", "\n", "currParameter", "=", "self", ".", "mTree", ".", "getTreeParameters", "(", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "print", "(", "'Best tree parameter length'", ",", "len", "(", "currParameter", ")", ",", "' to start : '", ",", "self", ".", "fobj", "(", "currParameter", ")", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "currParameter", ",", "False", ")", ")", "\n", "\n", "min_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "0", "]", "\n", "max_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "1", "]", "\n", "# SA Parameter", "\n", "# Number of cycles", "\n", "n", "=", "self", ".", "mParams", ".", "n_param_opt_max_itr", "\n", "# Number of trials per cycle", "\n", "m", "=", "self", ".", "mParams", ".", "n_mh_pop_size", "\n", "# Number of accepted solutions", "\n", "na", "=", "0.0", "\n", "# Probability of accepting worse solution at the start", "\n", "p1", "=", "0.7", "\n", "# Probability of accepting worse solution at the end", "\n", "pLast", "=", "0.001", "\n", "# Initial temperature", "\n", "t1", "=", "-", "1.0", "/", "math", ".", "log", "(", "p1", ")", "\n", "# Final temperature", "\n", "tLast", "=", "-", "1.0", "/", "math", ".", "log", "(", "pLast", ")", "\n", "# Fractional reduction every cycle", "\n", "frac", "=", "(", "tLast", "/", "t1", ")", "**", "(", "1.0", "/", "(", "n", "-", "1.0", ")", ")", "\n", "\n", "# Initialize x", "\n", "x_start", "=", "copy", ".", "deepcopy", "(", "currParameter", ")", "\n", "# Current best results so far", "\n", "xc", "=", "x_start", "\n", "fc", "=", "self", ".", "fobj", "(", "x_start", ")", "\n", "# Record the best", "\n", "xbest", "=", "x_start", "\n", "fbest", "=", "fc", "\n", "\n", "na", "=", "na", "+", "1.0", "\n", "# Current temperature", "\n", "t", "=", "t1", "\n", "# DeltaE Average", "\n", "DeltaE_avg", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "#print('Cycle: ' + str(i) + ' with Temperature: ' + str(t))", "\n", "            ", "for", "j", "in", "range", "(", "m", ")", ":", "\n", "# Generate new trial points", "\n", "                ", "xi", "=", "[", "x", "+", "random", ".", "random", "(", ")", "-", "0.5", "for", "x", "in", "xc", "]", "\n", "# Clip to upper and lower bounds", "\n", "xi", "=", "self", ".", "fix_boundry", "(", "xi", ",", "min_x", ",", "max_x", ")", "\n", "fxi", "=", "self", ".", "fobj", "(", "xi", ")", "\n", "DeltaE", "=", "abs", "(", "fxi", "-", "fc", ")", "\n", "if", "(", "fxi", ">", "fc", ")", ":", "\n", "# Initialize DeltaE_avg if a worse solution was found", "\n", "#   on the first iteration", "\n", "                    ", "if", "(", "i", "==", "0", "and", "j", "==", "0", ")", ":", "DeltaE_avg", "=", "DeltaE", "\n", "# objective function is worse", "\n", "# generate probability of acceptance", "\n", "p", "=", "math", ".", "exp", "(", "-", "DeltaE", "/", "(", "DeltaE_avg", "*", "t", ")", ")", "\n", "# determine whether to accept worse point", "\n", "if", "(", "random", ".", "random", "(", ")", "<", "p", ")", ":", "\n", "# accept the worse solution", "\n", "                        ", "accept", "=", "True", "\n", "", "else", ":", "\n", "# don't accept the worse solution", "\n", "                        ", "accept", "=", "False", "\n", "", "", "else", ":", "\n", "# objective function is lower, automatically accept", "\n", "                    ", "accept", "=", "True", "\n", "", "if", "(", "accept", "==", "True", ")", ":", "\n", "# update currently accepted solution", "\n", "                    ", "xc", "=", "xi", "\n", "fc", "=", "fxi", "\n", "if", "(", "fc", "<", "fbest", ")", ":", "\n", "                        ", "xbest", "=", "copy", ".", "deepcopy", "(", "xc", ")", "\n", "fbest", "=", "fc", "\n", "# increment number of accepted solutions", "\n", "", "na", "=", "na", "+", "1.0", "\n", "# update DeltaE_avg", "\n", "DeltaE_avg", "=", "(", "DeltaE_avg", "*", "(", "na", "-", "1.0", ")", "+", "DeltaE", ")", "/", "na", "\n", "\n", "# Lower the temperature for next cycle", "\n", "", "", "t", "=", "frac", "*", "t", "\n", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "xbest", ",", "False", ")", ")", "\n", "if", "(", "np", ".", "mod", "(", "i", ",", "10", ")", "==", "0", ")", ":", "\n", "                ", "print", "(", "'MH Itr: '", ",", "i", ",", "' best: '", ",", "fbest", ")", "\n", "#iteration finished", "\n", "\n", "", "", "self", ".", "mTree", ".", "setTreeParameters", "(", "xbest", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "return", "self", ".", "mTree", ",", "self", ".", "performance_record", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.sa.SimulatedAnnealing.fobj": [[138, 140], ["src.optimization.parameter.mh.mh_cost_function.costFunction"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "def", "fobj", "(", "self", ",", "pVector", ",", "only_error", "=", "True", ")", ":", "\n", "        ", "return", "costFunction", "(", "pVector", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ",", "only_error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.sa.SimulatedAnnealing.fix_boundry": [[141, 148], ["range", "len"], "methods", ["None"], ["", "def", "fix_boundry", "(", "self", ",", "alist", ",", "min_x", "=", "0.0", ",", "max_x", "=", "1.0", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "alist", ")", ")", ":", "\n", "            ", "if", "alist", "[", "i", "]", "<", "min_x", ":", "\n", "                ", "alist", "[", "i", "]", "=", "min_x", "\n", "", "if", "alist", "[", "i", "]", ">", "max_x", ":", "\n", "                ", "alist", "[", "i", "]", "=", "max_x", "\n", "", "", "return", "alist", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.de.DifferentialEvolution.__init__": [[22, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "if", "(", "pParams", ".", "n_fun_type", "==", "'Gaussian'", ")", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'all'", "\n", "", "else", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'weights_and_bias'", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.de.DifferentialEvolution.optimize": [[34, 105], ["print", "de.DifferentialEvolution.mEvaluateTree.set_dataset_to_evaluate", "de.DifferentialEvolution.mTree.getTreeParameters", "print", "de.DifferentialEvolution.performance_record.append", "len", "numpy.random.rand", "numpy.asarray", "numpy.argmin", "range", "de.DifferentialEvolution.mTree.setTreeParameters", "len", "de.DifferentialEvolution.fobj", "de.DifferentialEvolution.fobj", "range", "de.DifferentialEvolution.performance_record.append", "de.DifferentialEvolution.fobj", "de.DifferentialEvolution.fix_boundry", "range", "de.DifferentialEvolution.fobj", "de.DifferentialEvolution.fobj", "numpy.mod", "print", "len", "random.random", "range", "numpy.random.choice", "zip", "zip", "v_trial.append", "v_trial.append"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fix_boundry", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj"], ["", "", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "'''\n            Run Defrential evoltion optimization\n        '''", "\n", "print", "(", "'The Deferential Evolution:'", ",", "self", ".", "mParams", ".", "n_algo_param", ")", "\n", "self", ".", "mEvaluateTree", ".", "set_dataset_to_evaluate", "(", "'train'", ")", "\n", "\n", "currParameter", "=", "self", ".", "mTree", ".", "getTreeParameters", "(", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "print", "(", "'Best tree parameter length'", ",", "len", "(", "currParameter", ")", ",", "' to start : '", ",", "self", ".", "fobj", "(", "currParameter", ")", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "currParameter", ",", "False", ")", ")", "\n", "\n", "min_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "0", "]", "+", "0.1", "\n", "max_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "1", "]", "\n", "# DE Parameter", "\n", "mut", "=", "0.8", "\n", "crossp", "=", "0.7", "\n", "\n", "popsize", "=", "self", ".", "mParams", ".", "n_mh_pop_size", "\n", "#dimension of the solution", "\n", "dimensions", "=", "len", "(", "currParameter", ")", "\n", "# random initial population", "\n", "pop", "=", "np", ".", "random", ".", "rand", "(", "popsize", ",", "dimensions", ")", "\n", "pop", "[", "0", "]", "=", "currParameter", "\n", "#min_b, max_b = np.asarray(bounds).T", "\n", "#diff = np.fabs(min_b - max_b)", "\n", "#pop_denorm = min_b + pop * diff", "\n", "fitness", "=", "np", ".", "asarray", "(", "[", "self", ".", "fobj", "(", "ind", ")", "for", "ind", "in", "pop", "]", ")", "\n", "\n", "best_idx", "=", "np", ".", "argmin", "(", "fitness", ")", "\n", "best", "=", "pop", "[", "best_idx", "]", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "mParams", ".", "n_param_opt_max_itr", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "popsize", ")", ":", "\n", "                ", "idxs", "=", "[", "idx", "for", "idx", "in", "range", "(", "popsize", ")", "if", "idx", "!=", "j", "]", "\n", "x_1", ",", "x_2", ",", "x_3", "=", "pop", "[", "np", ".", "random", ".", "choice", "(", "idxs", ",", "3", ",", "replace", "=", "False", ")", "]", "\n", "x_t", "=", "pop", "[", "j", "]", "\n", "#--- MUTATION (step #3.A) ---------------------+", "\n", "# subtract x3 from x2, and create a new vector (x_diff)", "\n", "x_diff", "=", "[", "x_2_i", "-", "x_3_i", "for", "x_2_i", ",", "x_3_i", "in", "zip", "(", "x_2", ",", "x_3", ")", "]", "\n", "# multiply x_diff by the mutation factor (F) and add to x_1", "\n", "v_donor", "=", "[", "x_1_i", "+", "mut", "*", "x_diff_i", "for", "x_1_i", ",", "x_diff_i", "in", "zip", "(", "x_1", ",", "x_diff", ")", "]", "\n", "v_donor", "=", "self", ".", "fix_boundry", "(", "v_donor", ",", "min_x", ",", "max_x", ")", "\n", "#--- RECOMBINATION (step #3.B) ----------------+", "\n", "v_trial", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "x_t", ")", ")", ":", "\n", "                    ", "crossover", "=", "random", ".", "random", "(", ")", "\n", "if", "crossover", "<=", "crossp", ":", "\n", "                        ", "v_trial", ".", "append", "(", "v_donor", "[", "k", "]", ")", "\n", "", "else", ":", "\n", "                        ", "v_trial", ".", "append", "(", "x_t", "[", "k", "]", ")", "\n", "#--- GREEDY SELECTION (step #3.C) -------------+", "\n", "", "", "f", "=", "self", ".", "fobj", "(", "v_trial", ")", "\n", "if", "f", "<", "fitness", "[", "j", "]", ":", "\n", "                    ", "fitness", "[", "j", "]", "=", "f", "\n", "pop", "[", "j", "]", "=", "v_trial", "\n", "if", "f", "<", "fitness", "[", "best_idx", "]", ":", "\n", "                        ", "best_idx", "=", "j", "\n", "best", "=", "v_trial", "\n", "#print('MH Itr:',i,' has a new best : ', f)", "\n", "\n", "", "", "", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "best", ",", "False", ")", ")", "\n", "if", "(", "np", ".", "mod", "(", "i", ",", "10", ")", "==", "0", ")", ":", "\n", "                ", "print", "(", "'MH Itr: '", ",", "i", ",", "' best: '", ",", "fitness", "[", "best_idx", "]", ")", "\n", "#iteration finished", "\n", "\n", "", "", "self", ".", "mTree", ".", "setTreeParameters", "(", "best", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "#currParameter = self.mTree.getTreeParameters(self.mParams.n_max_target_attr, self.mParameterToFetch)", "\n", "#print('Check sum: ',np.sum(np.subtract(currParameter,best)))", "\n", "#print('LAST Best tree parameter length', len(currParameter) ,' to Finish : ', self.fobj(currParameter))", "\n", "\n", "return", "self", ".", "mTree", ",", "self", ".", "performance_record", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.de.DifferentialEvolution.fobj": [[107, 109], ["src.optimization.parameter.mh.mh_cost_function.costFunction"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "def", "fobj", "(", "self", ",", "pVector", ",", "only_error", "=", "True", ")", ":", "\n", "        ", "return", "costFunction", "(", "pVector", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ",", "only_error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.de.DifferentialEvolution.fix_boundry": [[110, 117], ["range", "len"], "methods", ["None"], ["", "def", "fix_boundry", "(", "self", ",", "alist", ",", "min_x", "=", "0.1", ",", "max_x", "=", "1.0", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "alist", ")", ")", ":", "\n", "            ", "if", "alist", "[", "i", "]", "<", "min_x", ":", "\n", "                ", "alist", "[", "i", "]", "=", "min_x", "\n", "", "if", "alist", "[", "i", "]", ">", "max_x", ":", "\n", "                ", "alist", "[", "i", "]", "=", "max_x", "\n", "", "", "return", "alist", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.__init__": [[21, 30], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "if", "(", "pParams", ".", "n_fun_type", "==", "'Gaussian'", ")", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'all'", "\n", "", "else", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'weights_and_bias'", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.optimize": [[33, 107], ["print", "bsd.BernstainSearchDE.mEvaluateTree.set_dataset_to_evaluate", "bsd.BernstainSearchDE.mTree.getTreeParameters", "print", "bsd.BernstainSearchDE.performance_record.append", "len", "numpy.random.rand", "numpy.asarray", "numpy.argmin", "range", "bsd.BernstainSearchDE.mTree.setTreeParameters", "len", "bsd.BernstainSearchDE.fobj", "bsd.BernstainSearchDE.fobj", "numpy.zeros", "range", "numpy.random.rand", "range", "bsd.BernstainSearchDE.performance_record.append", "bsd.BernstainSearchDE.fobj", "bsd.BernstainSearchDE.getAlpha", "int", "numpy.random.choice", "pow", "numpy.random.rand", "pow", "numpy.random.choice", "numpy.random.choice", "pow", "len", "bsd.BernstainSearchDE.fix_boundry", "bsd.BernstainSearchDE.fobj", "bsd.BernstainSearchDE.fobj", "numpy.mod", "print", "numpy.ceil", "numpy.random.rand", "pow", "abs", "numpy.random.randn", "range", "numpy.random.rand", "numpy.random.rand", "pow", "sum", "sum", "sum", "range", "numpy.random.randn"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.getAlpha", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fix_boundry", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj"], ["", "", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "'''\n            Run Bernstain Search Deferential Evolution optimization\n            \n        '''", "\n", "print", "(", "'The Bernstain Search Deferential Evolution: '", ",", "self", ".", "mParams", ".", "n_algo_param", ")", "\n", "self", ".", "mEvaluateTree", ".", "set_dataset_to_evaluate", "(", "'train'", ")", "\n", "\n", "currParameter", "=", "self", ".", "mTree", ".", "getTreeParameters", "(", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "print", "(", "'Best tree parameter length'", ",", "len", "(", "currParameter", ")", ",", "' to start : '", ",", "self", ".", "fobj", "(", "currParameter", ")", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "currParameter", ",", "False", ")", ")", "\n", "\n", "min_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "0", "]", "\n", "max_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "1", "]", "\n", "\n", "N", "=", "self", ".", "mParams", ".", "n_mh_pop_size", "\n", "#dimension of the solution", "\n", "D", "=", "len", "(", "currParameter", ")", "\n", "# random initial population", "\n", "pop", "=", "np", ".", "random", ".", "rand", "(", "N", ",", "D", ")", "\n", "#min_b, max_b = np.asarray(bounds).T", "\n", "#diff = np.fabs(min_b - max_b)", "\n", "#pop_denorm = min_b + pop * diff", "\n", "fitness", "=", "np", ".", "asarray", "(", "[", "self", ".", "fobj", "(", "ind", ")", "for", "ind", "in", "pop", "]", ")", "\n", "\n", "best_idx", "=", "np", ".", "argmin", "(", "fitness", ")", "\n", "best", "=", "pop", "[", "best_idx", "]", "\n", "\n", "for", "itr", "in", "range", "(", "self", ".", "mParams", ".", "n_param_opt_max_itr", ")", ":", "\n", "            ", "M", "=", "np", ".", "zeros", "(", "(", "N", ",", "D", ")", ")", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "                ", "alpha", "=", "self", ".", "getAlpha", "(", ")", "\n", "select", "=", "int", "(", "np", ".", "ceil", "(", "alpha", "*", "D", ")", ")", "\n", "u", "=", "np", ".", "random", ".", "choice", "(", "[", "x", "for", "x", "in", "range", "(", "D", ")", "]", ",", "select", ",", "replace", "=", "False", ")", "\n", "for", "k", "in", "u", ":", "\n", "                    ", "M", "[", "i", ",", "k", "]", "=", "1", "\n", "\n", "", "", "if", "pow", "(", "np", ".", "random", ".", "rand", "(", ")", ",", "3", ")", "<", "np", ".", "random", ".", "rand", "(", ")", ":", "\n", "                ", "F", "=", "pow", "(", "np", ".", "random", ".", "rand", "(", "1", ",", "D", ")", ",", "3", ")", "*", "abs", "(", "pow", "(", "np", ".", "random", ".", "randn", "(", "1", ",", "D", ")", ",", "3", ")", ")", "\n", "", "else", ":", "\n", "                ", "F", "=", "pow", "(", "np", ".", "random", ".", "randn", "(", "N", ",", "1", ")", ",", "3", ")", "\n", "\n", "", "sequence", "=", "[", "x", "for", "x", "in", "range", "(", "N", ")", "]", "\n", "while", "True", ":", "\n", "                ", "L1", "=", "np", ".", "random", ".", "choice", "(", "sequence", ",", "N", ",", "replace", "=", "False", ")", "\n", "L2", "=", "np", ".", "random", ".", "choice", "(", "sequence", ",", "N", ",", "replace", "=", "False", ")", "\n", "if", "sum", "(", "L1", "==", "sequence", ")", "==", "0", "and", "sum", "(", "L1", "==", "L2", ")", "==", "0", "and", "sum", "(", "L2", "==", "sequence", ")", "==", "0", ":", "\n", "#print('break')", "\n", "                    ", "break", "\n", "\n", "", "", "w1", "=", "np", ".", "random", ".", "rand", "(", "N", ",", "D", ")", "\n", "E", "=", "w1", "*", "pop", "[", "L1", ",", ":", "]", "+", "(", "1", "-", "w1", ")", "*", "pop", "[", "L2", ",", ":", "]", "\n", "\n", "w2", "=", "1", "-", "pow", "(", "np", ".", "random", ".", "rand", "(", "N", ",", "1", ")", ",", "3", ")", "\n", "v_trial", "=", "pop", "+", "F", "*", "M", "*", "(", "w2", "*", "E", "+", "(", "1", "-", "w2", ")", "*", "best", "-", "pop", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "v_trial", ")", ")", ":", "\n", "                ", "v_trial", "[", "i", "]", "=", "self", ".", "fix_boundry", "(", "v_trial", "[", "i", "]", ",", "min_x", ",", "max_x", ")", "\n", "#--- GREEDY SELECTION (step #3.C) -------------+", "\n", "f", "=", "self", ".", "fobj", "(", "v_trial", "[", "i", "]", ")", "\n", "if", "f", "<", "fitness", "[", "i", "]", ":", "\n", "                    ", "fitness", "[", "i", "]", "=", "f", "\n", "pop", "[", "i", "]", "=", "v_trial", "[", "i", "]", "\n", "if", "f", "<", "fitness", "[", "best_idx", "]", ":", "\n", "                        ", "best_idx", "=", "i", "\n", "best", "=", "v_trial", "[", "i", "]", "\n", "#print('MH Itr:',i,' has a new best : ', f)", "\n", "\n", "", "", "", "self", ".", "performance_record", ".", "append", "(", "self", ".", "fobj", "(", "best", ",", "False", ")", ")", "\n", "if", "(", "np", ".", "mod", "(", "itr", ",", "10", ")", "==", "0", ")", ":", "\n", "                ", "print", "(", "'MH Itr: '", ",", "itr", ",", "' best: '", ",", "fitness", "[", "best_idx", "]", ")", "\n", "#iteration finished", "\n", "\n", "", "", "self", ".", "mTree", ".", "setTreeParameters", "(", "best", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "return", "self", ".", "mTree", ",", "self", ".", "performance_record", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fobj": [[109, 111], ["src.optimization.parameter.mh.mh_cost_function.costFunction"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "def", "fobj", "(", "self", ",", "pVector", ",", "only_error", "=", "True", ")", ":", "\n", "        ", "return", "costFunction", "(", "pVector", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ",", "only_error", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.fix_boundry": [[112, 119], ["range", "len"], "methods", ["None"], ["", "def", "fix_boundry", "(", "self", ",", "alist", ",", "min_x", "=", "0.0", ",", "max_x", "=", "1.0", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "alist", ")", ")", ":", "\n", "            ", "if", "alist", "[", "i", "]", "<", "min_x", ":", "\n", "                ", "alist", "[", "i", "]", "=", "min_x", "\n", "", "if", "alist", "[", "i", "]", ">", "max_x", ":", "\n", "                ", "alist", "[", "i", "]", "=", "max_x", "\n", "", "", "return", "alist", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.bsd.BernstainSearchDE.getAlpha": [[120, 132], ["numpy.random.rand", "numpy.ceil", "pow", "pow", "pow", "numpy.random.rand"], "methods", ["None"], ["", "def", "getAlpha", "(", "self", ")", ":", "\n", "        ", "beta", "=", "np", ".", "random", ".", "rand", "(", ")", "\n", "kappa", "=", "np", ".", "ceil", "(", "3", "*", "(", "pow", "(", "np", ".", "random", ".", "rand", "(", ")", ",", "3", ")", ")", ")", "\n", "if", "kappa", "==", "1", ":", "\n", "#case 1", "\n", "            ", "return", "pow", "(", "beta", ",", "2", ")", "\n", "", "if", "kappa", "==", "2", ":", "\n", "#case 2", "\n", "            ", "return", "2", "*", "(", "1", "-", "beta", ")", "*", "beta", "\n", "", "if", "kappa", "==", "3", ":", "\n", "#case 3", "\n", "            ", "return", "pow", "(", "(", "1", "-", "beta", ")", ",", "2", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.Particle.__init__": [[24, 29], ["random.uniform", "range", "random.random", "len"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_x", ",", "max_x", ",", "currParameter", ")", ":", "\n", "# intialize positition from using the randum pertubation to the best particle", "\n", "        ", "self", ".", "mPosition", "=", "[", "min_x", "+", "(", "max_x", "-", "min_x", ")", "*", "random", ".", "random", "(", ")", "for", "x", "in", "currParameter", "]", "\n", "#self.mPosition = [min_x + (max_x - min_x)*random.random() + x for x in currParameter]", "\n", "self", ".", "mVelocity", "=", "[", "random", ".", "uniform", "(", "-", "1", ",", "1", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "currParameter", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.Particle.evaluate": [[30, 38], ["None"], "methods", ["None"], ["", "def", "evaluate", "(", "self", ",", "pCostPotition", ")", ":", "\n", "        ", "self", ".", "mCostPosition", "=", "pCostPotition", "\n", "# determine if it is trhe best particle", "\n", "# If fun(x) < fun(p), then set p = x. ", "\n", "# This step ensures p has the best position the particle has seen.", "\n", "if", "self", ".", "mCostPosition", "<", "self", ".", "mCostPositionBest", "or", "self", ".", "mCostPositionBest", "==", "-", "1", ":", "\n", "            ", "self", ".", "mPositionBest", "=", "self", ".", "mPosition", "\n", "self", ".", "mCostPositionBest", "=", "self", ".", "mCostPosition", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.Particle.update_velocity": [[40, 57], ["range", "len", "random.uniform", "random.uniform"], "methods", ["None"], ["", "", "def", "update_velocity", "(", "self", ",", "pPositionGroupBest", ",", "w", "=", "0.729", ",", "c1", "=", "1.49445", ",", "c2", "=", "1.49445", ")", ":", "\n", "        ", "'''\n        Updateing particle velocity\n        args:\n            Group best position:  a vector of best position\n            w=0.5       # constant inertia weight (how much to weigh the previous velocity)\n            c1=1        # cognative constant\n            c2=2        # social constant\n        '''", "\n", "# v = W*v + c1*u1.*(p-x) + c2*u2.*(g-x).", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mPosition", ")", ")", ":", "\n", "            ", "u1", "=", "random", ".", "uniform", "(", "0", ",", "1", ")", "\n", "u2", "=", "random", ".", "uniform", "(", "0", ",", "1", ")", "\n", "\n", "vel_cognitive", "=", "c1", "*", "u1", "*", "(", "self", ".", "mPositionBest", "[", "i", "]", "-", "self", ".", "mPosition", "[", "i", "]", ")", "# self best pos - curr pos", "\n", "vel_social", "=", "c2", "*", "u2", "*", "(", "pPositionGroupBest", "[", "i", "]", "-", "self", ".", "mPosition", "[", "i", "]", ")", "# self best pos group - curr pos", "\n", "self", ".", "mVelocity", "[", "i", "]", "=", "w", "*", "self", ".", "mVelocity", "[", "i", "]", "+", "vel_cognitive", "+", "vel_social", "# inartia +  congnative + social", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.Particle.update_position": [[59, 78], ["range", "len"], "methods", ["None"], ["", "", "def", "update_position", "(", "self", ",", "min_x", "=", "0.0", ",", "max_x", "=", "1.0", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mPosition", ")", ")", ":", "\n", "# Update the position x = x + v.", "\n", "            ", "self", ".", "mPosition", "[", "i", "]", "=", "self", ".", "mPosition", "[", "i", "]", "+", "self", ".", "mVelocity", "[", "i", "]", "\n", "\n", "# Enforce the bounds. ", "\n", "# If any component of x is outside a bound, set it equal to that bound. ", "\n", "# For those components that were just set to a bound, ", "\n", "# if the velocity v of that component points outside the bound, set that velocity component to zero.", "\n", "if", "self", ".", "mPosition", "[", "i", "]", "<", "min_x", ":", "\n", "                ", "self", ".", "mPosition", "[", "i", "]", "=", "min_x", "\n", "if", "self", ".", "mVelocity", "[", "i", "]", "<", "min_x", ":", "\n", "                    ", "self", ".", "mVelocity", "[", "i", "]", "=", "0.0", "\n", "\n", "# adjust maximum position if necessary", "\n", "", "", "if", "self", ".", "mPosition", "[", "i", "]", ">", "max_x", ":", "\n", "                ", "self", ".", "mPosition", "[", "i", "]", "=", "max_x", "\n", "if", "self", ".", "mVelocity", "[", "i", "]", ">", "max_x", ":", "\n", "                    ", "self", ".", "mVelocity", "[", "i", "]", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.PSO.__init__": [[95, 105], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ",", "pTree", ")", ":", "\n", "        ", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mTree", "=", "pTree", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "\n", "if", "(", "pParams", ".", "n_fun_type", "==", "'Gaussian'", ")", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'all'", "\n", "", "else", ":", "\n", "            ", "self", ".", "mParameterToFetch", "=", "'weights_and_bias'", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.PSO.optimize": [[108, 168], ["print", "pso.PSO.mEvaluateTree.set_dataset_to_evaluate", "pso.PSO.mTree.getTreeParameters", "len", "print", "pso.PSO.evaluate", "pso.PSO.performance_record.append", "pso.PSO.mTree.setTreeParameters", "src.optimization.parameter.mh.mh_cost_function.costFunction", "pso.Particle", "src.optimization.parameter.mh.mh_cost_function.costFunction", "pso.PSO.performance_record.append", "range", "pso.PSO.evaluate", "particle.update_velocity", "particle.update_position", "src.optimization.parameter.mh.mh_cost_function.costFunction", "numpy.mod", "print", "float"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.PSO.evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.PSO.evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.Particle.update_velocity", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.Particle.update_position", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "", "def", "optimize", "(", "self", ")", ":", "\n", "        ", "'''\n            Run Particle Swarm Optimization optimization\n        '''", "\n", "print", "(", "'Particle Swarm Optimization:'", ",", "self", ".", "mParams", ".", "n_algo_param", ")", "\n", "self", ".", "mEvaluateTree", ".", "set_dataset_to_evaluate", "(", "'train'", ")", "\n", "currParameter", "=", "self", ".", "mTree", ".", "getTreeParameters", "(", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "self", ".", "dimension", "=", "len", "(", "currParameter", ")", "\n", "print", "(", "'Best tree parameter length'", ",", "self", ".", "dimension", ",", "' to start : '", ",", "costFunction", "(", "currParameter", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", ")", "\n", "\n", "self", ".", "min_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "0", "]", "-", "0.5", "\n", "self", ".", "max_x", "=", "self", ".", "mParams", ".", "n_weight_range", "[", "1", "]", "-", "0.5", "\n", "\n", "nSwarm", "=", "[", "Particle", "(", "self", ".", "min_x", ",", "self", ".", "max_x", ",", "currParameter", ")", "for", "i", "in", "range", "(", "self", ".", "mParams", ".", "n_mh_pop_size", ")", "]", "\n", "# Set one particle from best", "\n", "nSwarm", "[", "0", "]", ".", "mPosition", "=", "currParameter", "\n", "self", ".", "evaluate", "(", "nSwarm", "[", "0", "]", ")", "\n", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "currParameter", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ",", "False", ")", ")", "\n", "\n", "nPositionGroupBest", "=", "[", "]", "# best position for group", "\n", "nCostGroupBest", "=", "-", "1", "# best error for group", "\n", "\n", "#pso paramters", "\n", "w", "=", "1.0", "\n", "wdamp", "=", "0.99", "\n", "c1", "=", "1.49445", "\n", "c2", "=", "1.49445", "\n", "# begin optimization loop", "\n", "itr", "=", "0", "\n", "while", "itr", "<", "self", ".", "mParams", ".", "n_param_opt_max_itr", ":", "\n", "# evaluate swarm", "\n", "            ", "for", "particle", "in", "nSwarm", ":", "\n", "                ", "self", ".", "evaluate", "(", "particle", ")", "\n", "\n", "# determine if current particle is the best (Group)", "\n", "# If fun(x) < fun(g), then set g = x and fun(g) = fun(x). ", "\n", "# This step ensures b has the best objective function in the swarm, and d has the best location.", "\n", "if", "particle", ".", "mCostPosition", "<", "nCostGroupBest", "or", "nCostGroupBest", "==", "-", "1", ":", "\n", "                    ", "nPositionGroupBest", "=", "particle", ".", "mPosition", "# set Group best position", "\n", "nCostGroupBest", "=", "float", "(", "particle", ".", "mCostPosition", ")", "# set Group best error", "\n", "#print('Itr ', itr, ' new Best : ',nCostGroupBest)", "\n", "\n", "# cycle through swarm and update velocities and position", "\n", "", "", "for", "particle", "in", "nSwarm", ":", "\n", "                ", "particle", ".", "update_velocity", "(", "nPositionGroupBest", ",", "w", ",", "c1", ",", "c2", ")", "\n", "particle", ".", "update_position", "(", "self", ".", "min_x", ",", "self", ".", "max_x", ")", "\n", "\n", "# inartia dampening", "\n", "", "w", "=", "w", "*", "wdamp", "\n", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "nPositionGroupBest", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ",", "False", ")", ")", "\n", "if", "(", "np", ".", "mod", "(", "itr", ",", "10", ")", "==", "0", ")", ":", "\n", "                ", "print", "(", "'MH Itr: '", ",", "itr", ",", "' best: '", ",", "nCostGroupBest", ")", "\n", "\n", "", "itr", "+=", "1", "\n", "\n", "\n", "", "self", ".", "mTree", ".", "setTreeParameters", "(", "nPositionGroupBest", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", "\n", "return", "self", ".", "mTree", ",", "self", ".", "performance_record", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.PSO.evaluate": [[172, 174], ["particle.evaluate", "src.optimization.parameter.mh.mh_cost_function.costFunction"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.algo.pso.PSO.evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "def", "evaluate", "(", "self", ",", "particle", ")", ":", "\n", "        ", "particle", ".", "evaluate", "(", "costFunction", "(", "particle", ".", "mPosition", ",", "self", ".", "mTree", ",", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ".", "n_max_target_attr", ",", "self", ".", "mParameterToFetch", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.__init__": [[20, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pParams", ")", ":", "\n", "        ", "'''\n            Contractor of the genetic operator\n        '''", "\n", "self", ".", "mParams", "=", "pParams", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.crossoverTree": [[28, 97], ["copy.deepcopy", "copy.deepcopy", "len", "len", "copy.deepcopy.getFunNodesList", "copy.deepcopy.getFunNodesList", "random.randrange", "random.randrange", "first_SubTree.getParentNode", "second_SubTree.getParentNode", "first_SubTree.getParentNode.replaceSubTree", "second_SubTree.getParentNode.replaceSubTree", "first_SubTree.setParentNode", "second_SubTree.setParentNode", "copy.deepcopy.inspectChildNodes", "copy.deepcopy.inspectChildNodes", "print", "print", "print", "copy.deepcopy.getFunNodesList", "copy.deepcopy.getFunNodesList", "print", "print", "print", "copy.deepcopy.getFunNodesList", "print", "copy.deepcopy.getFunNodesList", "print", "p_tree_p1.getTreeSize", "p_tree_p2.getTreeSize", "copy.deepcopy.getTreeSize", "copy.deepcopy.getTreeSize", "copy.deepcopy.getFunNodesList", "copy.deepcopy.getFunNodesList", "print", "print"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getParentNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getParentNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.replaceSubTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.replaceSubTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.setParentNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.setParentNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList"], ["", "def", "crossoverTree", "(", "self", ",", "p_tree_p1", ",", "p_tree_p2", ",", "Check_crossover", "=", "False", ")", ":", "\n", "        ", "'''\n           Crossover operation of two parent tree \n           param:    p_tree_p1          first parent tree\n           param:    p_tree_p2          second parent tree\n           param:    check_crossove     print masages of corssove\n        '''", "\n", "first_Tree", "=", "copy", ".", "deepcopy", "(", "p_tree_p1", ")", "\n", "second_Tree", "=", "copy", ".", "deepcopy", "(", "p_tree_p2", ")", "\n", "xoverTrue", "=", "False", "\n", "max_target_attr", "=", "self", ".", "mParams", ".", "n_max_target_attr", "\n", "first_funNodes_count", "=", "len", "(", "first_Tree", ".", "getFunNodesList", "(", ")", ")", "\n", "second_funNodes_count", "=", "len", "(", "second_Tree", ".", "getFunNodesList", "(", ")", ")", "\n", "if", "(", "max_target_attr", "==", "1", "and", "(", "first_funNodes_count", "==", "0", "or", "second_funNodes_count", "==", "0", ")", ")", "or", "(", "max_target_attr", ">", "1", "and", "(", "first_funNodes_count", "<=", "max_target_attr", "or", "second_funNodes_count", "<=", "max_target_attr", ")", ")", ":", "\n", "            ", "if", "(", "Check_crossover", ")", ":", "\n", "                ", "print", "(", "'Tree inequality'", ",", "first_funNodes_count", ",", "second_funNodes_count", ",", "self", ".", "mParams", ".", "n_max_target_attr", ")", "\n", "", "return", "first_Tree", ",", "second_Tree", ",", "False", "\n", "", "else", ":", "\n", "            ", "if", "(", "Check_crossover", ")", ":", "\n", "                ", "print", "(", "'\\nSuffcient nodes for crossover:'", ",", "first_funNodes_count", ",", "'and '", ",", "second_funNodes_count", ")", "\n", "# a ranong seslion of subtree, i.e., a function node", "\n", "", "first_Subtree_Index", "=", "random", ".", "randrange", "(", "first_funNodes_count", ")", "\n", "second_Subtree_Index", "=", "random", ".", "randrange", "(", "second_funNodes_count", ")", "\n", "if", "(", "Check_crossover", ")", ":", "\n", "                ", "print", "(", "'Indices'", ",", "first_Subtree_Index", ",", "'and'", ",", "second_Subtree_Index", ")", "\n", "\n", "# retriving a function node means all the nodes under the object of this function node will be copyied", "\n", "", "first_SubTree", "=", "first_Tree", ".", "getFunNodesList", "(", ")", "[", "first_Subtree_Index", "]", "\n", "second_SubTree", "=", "second_Tree", ".", "getFunNodesList", "(", ")", "[", "second_Subtree_Index", "]", "\n", "if", "(", "Check_crossover", ")", ":", "\n", "                ", "print", "(", "'First subtrre in the list: '", ",", "first_SubTree", "in", "first_Tree", ".", "getFunNodesList", "(", ")", ")", "\n", "print", "(", "'Second subtrre in the list: '", ",", "second_SubTree", "in", "second_Tree", ".", "getFunNodesList", "(", ")", ")", "\n", "\n", "# selecting parents of two subtree to rplace thir child", "\n", "", "first_SubTree_Parent", "=", "first_SubTree", ".", "getParentNode", "(", ")", "\n", "second_SubTree_Parent", "=", "second_SubTree", ".", "getParentNode", "(", ")", "\n", "if", "(", "Check_crossover", ")", ":", "\n", "                ", "if", "(", "first_SubTree_Parent", "in", "first_Tree", ".", "getFunNodesList", "(", ")", ")", ":", "\n", "                    ", "print", "(", "'First Subtre: Parent is among the children of the tree'", ")", "\n", "", "else", ":", "\n", "                    ", "if", "(", "first_SubTree_Parent", "==", "first_Tree", ".", "m_root", ")", ":", "\n", "                        ", "print", "(", "'First Subtre: Parent is the root'", ")", "\n", "\n", "", "", "if", "(", "second_SubTree_Parent", "in", "second_Tree", ".", "getFunNodesList", "(", ")", ")", ":", "\n", "                    ", "print", "(", "'Second Subtre: Parent is among the children of the tree'", ")", "\n", "", "else", ":", "\n", "                    ", "if", "(", "second_SubTree_Parent", "==", "second_Tree", ".", "m_root", ")", ":", "\n", "                        ", "print", "(", "'Second Subtre: Parent is the root'", ")", "\n", "\n", "# replcae the subtrees old - new ", "\n", "", "", "", "first_SubTree_Parent", ".", "replaceSubTree", "(", "first_SubTree", ",", "second_SubTree", ")", "\n", "second_SubTree_Parent", ".", "replaceSubTree", "(", "second_SubTree", ",", "first_SubTree", ")", "\n", "\n", "# reset the parents of the subtrees", "\n", "first_SubTree", ".", "setParentNode", "(", "second_SubTree_Parent", ")", "\n", "second_SubTree", ".", "setParentNode", "(", "first_SubTree_Parent", ")", "\n", "\n", "# inspect the tree to fill the function nodes", "\n", "first_Tree", ".", "inspectChildNodes", "(", ")", "\n", "second_Tree", ".", "inspectChildNodes", "(", ")", "\n", "\n", "if", "(", "p_tree_p1", ".", "getTreeSize", "(", ")", "+", "p_tree_p2", ".", "getTreeSize", "(", ")", "==", "first_Tree", ".", "getTreeSize", "(", ")", "+", "second_Tree", ".", "getTreeSize", "(", ")", ")", ":", "\n", "#print('All good with crossover')", "\n", "                ", "xoverTrue", "=", "True", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Crossover operation needs varification'", ")", "\n", "# End els-if - check crossover tree operation print", "\n", "\n", "", "return", "first_Tree", ",", "second_Tree", ",", "xoverTrue", "\n", "# End if-else corrover operation", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.verifyCrossover": [[101, 137], ["print", "json.loads", "print", "anytree.importer.DictImporter", "anytree.importer.DictImporter.import_", "print", "json.loads", "print", "anytree.importer.DictImporter", "anytree.importer.DictImporter.import_", "print", "print", "json.loads", "print", "anytree.importer.DictImporter", "anytree.importer.DictImporter.import_", "print", "json.loads", "print", "anytree.importer.DictImporter", "anytree.importer.DictImporter.import_", "print", "print", "print", "print", "n_tree_1.print_tree", "n_tree_1.getTreeSize", "anytree.RenderTree", "n_tree_2.print_tree", "n_tree_2.getTreeSize", "anytree.RenderTree", "first_Tree.print_tree", "first_Tree.getTreeSize", "anytree.RenderTree", "second_Tree.print_tree", "second_Tree.getTreeSize", "anytree.RenderTree", "n_tree_1.getTreeSize", "n_tree_2.getTreeSize", "first_Tree.getTreeSize", "second_Tree.getTreeSize"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "", "def", "verifyCrossover", "(", "self", ",", "n_tree_1", ",", "n_tree_2", ",", "first_Tree", ",", "second_Tree", ",", "is_crossover_done", ")", ":", "\n", "        ", "if", "(", "is_crossover_done", ")", ":", "\n", "            ", "print", "(", "'\\nTrees before crossover:'", ")", "\n", "json_tree", "=", "json", ".", "loads", "(", "n_tree_1", ".", "print_tree", "(", ")", ")", "\n", "print", "(", "\"The tree 1 (copy of priginal) structure for \"", ",", "n_tree_1", ".", "getTreeSize", "(", ")", ",", "' nodes is:\\n'", ")", "\n", "importer", "=", "DictImporter", "(", ")", "\n", "root", "=", "importer", ".", "import_", "(", "json_tree", ")", "\n", "print", "(", "RenderTree", "(", "root", ")", ")", "\n", "\n", "# We have two trees -  n_tree_1 and n_tree_2", "\n", "json_tree", "=", "json", ".", "loads", "(", "n_tree_2", ".", "print_tree", "(", ")", ")", "\n", "print", "(", "\"\\nThe tree 2 structure for \"", ",", "n_tree_2", ".", "getTreeSize", "(", ")", ",", "' nodes is:\\n'", ")", "\n", "importer", "=", "DictImporter", "(", ")", "\n", "root", "=", "importer", ".", "import_", "(", "json_tree", ")", "\n", "print", "(", "RenderTree", "(", "root", ")", ")", "\n", "\n", "print", "(", "'Trees after crossover:'", ")", "\n", "\n", "json_tree", "=", "json", ".", "loads", "(", "first_Tree", ".", "print_tree", "(", ")", ")", "\n", "print", "(", "\"The copied tree structure for \"", ",", "first_Tree", ".", "getTreeSize", "(", ")", ",", "' nodes is:\\n'", ")", "\n", "importer", "=", "DictImporter", "(", ")", "\n", "root", "=", "importer", ".", "import_", "(", "json_tree", ")", "\n", "print", "(", "RenderTree", "(", "root", ")", ")", "\n", "\n", "json_tree", "=", "json", ".", "loads", "(", "second_Tree", ".", "print_tree", "(", ")", ")", "\n", "print", "(", "\"The copied tree structure for \"", ",", "second_Tree", ".", "getTreeSize", "(", ")", ",", "' nodes is:\\n'", ")", "\n", "importer", "=", "DictImporter", "(", ")", "\n", "root", "=", "importer", ".", "import_", "(", "json_tree", ")", "\n", "print", "(", "RenderTree", "(", "root", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'Crossover: Operation was NOT perfromed'", ")", "\n", "\n", "", "if", "(", "n_tree_1", ".", "getTreeSize", "(", ")", "+", "n_tree_2", ".", "getTreeSize", "(", ")", "==", "first_Tree", ".", "getTreeSize", "(", ")", "+", "second_Tree", ".", "getTreeSize", "(", ")", ")", ":", "\n", "            ", "print", "(", "'\\nCrossover: Operation was perfromed'", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'\\nCrossover operation needs varification'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutation": [[141, 158], ["copy.deepcopy", "random.choice", "genetic_operators.GeneticOperator.mutationOneLeaf", "genetic_operators.GeneticOperator.mutationAllLeaf", "genetic_operators.GeneticOperator.mutatationSubTree", "genetic_operators.GeneticOperator.mutationGrowSubTree"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutationOneLeaf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutationAllLeaf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutatationSubTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutationGrowSubTree"], ["", "", "def", "mutation", "(", "self", ",", "p_tree", ")", ":", "\n", "        ", "'''\n            Randomly selecting a mutation type over \n            param:    p_tree    a tree for mutation\n        '''", "\n", "tree", "=", "copy", ".", "deepcopy", "(", "p_tree", ")", "\n", "\n", "# generating a random number to randomly chooase a mutation type", "\n", "rand_num", "=", "random", ".", "choice", "(", "[", "0", ",", "1", ",", "2", ",", "3", "]", ")", "\n", "if", "(", "rand_num", "==", "0", ")", ":", "\n", "            ", "return", "self", ".", "mutationOneLeaf", "(", "tree", ")", "\n", "", "if", "(", "rand_num", "==", "1", ")", ":", "\n", "            ", "return", "self", ".", "mutationAllLeaf", "(", "tree", ")", "\n", "", "if", "(", "rand_num", "==", "2", ")", ":", "\n", "            ", "return", "self", ".", "mutatationSubTree", "(", "tree", ")", "\n", "", "if", "(", "rand_num", "==", "3", ")", ":", "\n", "            ", "return", "self", ".", "mutationGrowSubTree", "(", "tree", ")", "\n", "# End mutation", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutationOneLeaf": [[161, 176], ["random.randrange", "random.randrange", "node.setInputAttribute", "len", "tree.getLeafNodesList", "tree.getLeafNodesList"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setInputAttribute", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList"], ["", "", "def", "mutationOneLeaf", "(", "self", ",", "tree", ")", ":", "\n", "        ", "'''\n            Mutate ONLY one randon leaf in the tree\n        '''", "\n", "#print('mutatate: one leaf')", "\n", "#Select a leaf node in the tree to  be replaced ny a random attr", "\n", "index_rand_leaf", "=", "random", ".", "randrange", "(", "len", "(", "tree", ".", "getLeafNodesList", "(", ")", ")", ")", "\n", "# Fetching that (randentify) node object from the tree leaf node list", "\n", "node", "=", "tree", ".", "getLeafNodesList", "(", ")", "[", "index_rand_leaf", "]", "\n", "#Generating a randon attribute index", "\n", "input_rand_attr", "=", "random", ".", "randrange", "(", "0", ",", "self", ".", "mParams", ".", "n_max_input_attr", ",", "1", ")", "\n", "# Setting /replaceing the old index by the new index", "\n", "node", ".", "setInputAttribute", "(", "input_rand_attr", ")", "\n", "#print('At node ', index_rand_leaf, ' new attr is: ',input_rand_attr)", "\n", "return", "tree", "# returning mutated tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutationAllLeaf": [[178, 191], ["tree.getLeafNodesList", "random.randrange", "node.setInputAttribute"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setInputAttribute"], ["", "def", "mutationAllLeaf", "(", "self", ",", "tree", ")", ":", "\n", "        ", "'''\n            Muate all leaf node of the tree\n        '''", "\n", "#print('mutatate: all leaves')", "\n", "#Iterating over all leaf node in the tree", "\n", "for", "node", "in", "tree", ".", "getLeafNodesList", "(", ")", ":", "\n", "#Generating a random attribute for the leaf node", "\n", "            ", "input_rand_attr", "=", "random", ".", "randrange", "(", "0", ",", "self", ".", "mParams", ".", "n_max_input_attr", ",", "1", ")", "\n", "#replacing the old leaf node by new leaf node", "\n", "node", ".", "setInputAttribute", "(", "input_rand_attr", ")", "\n", "\n", "", "return", "tree", "# returning mutated tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutatationSubTree": [[193, 222], ["len", "random.randrange", "subTree.getParentNode", "random.uniform", "random.randrange", "subTree.getParentNode.removeAndReplace", "tree.inspectChildNodes", "tree.getFunNodesList", "tree.getFunNodesList", "tree.m_root.m_ChildrenList.__contains__"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getParentNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.removeAndReplace", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList"], ["", "def", "mutatationSubTree", "(", "self", ",", "tree", ")", ":", "\n", "        ", "'''\n            Mutate a subtree\n        '''", "\n", "#print('mutatate: delete a subtree')", "\n", "# get the length of the function node - total subtrees in the tree", "\n", "n_funNodes_count", "=", "len", "(", "tree", ".", "getFunNodesList", "(", ")", ")", "\n", "if", "n_funNodes_count", "<", "self", ".", "mParams", ".", "n_max_target_attr", ":", "\n", "            ", "return", "tree", "\n", "#Else", "\n", "#select a subtree from the tree to prune", "\n", "", "subtree_Index", "=", "random", ".", "randrange", "(", "n_funNodes_count", ")", "\n", "# retriving a function node means all the nodes under the object of this function node will be copyied", "\n", "subTree", "=", "tree", ".", "getFunNodesList", "(", ")", "[", "subtree_Index", "]", "\n", "# Do not prune root's child", "\n", "if", "(", "self", ".", "mParams", ".", "n_max_target_attr", ">", "1", "and", "tree", ".", "m_root", ".", "m_ChildrenList", ".", "__contains__", "(", "subTree", ")", ")", ":", "\n", "            ", "return", "tree", "# returning unmutated tree", "\n", "#Else", "\n", "#Fetch the parent of the selected subtree", "\n", "", "subTree_parent_node", "=", "subTree", ".", "getParentNode", "(", ")", "\n", "# tree edge weight between uniformaly taken between 0 and 1                ", "\n", "n_weight", "=", "random", ".", "uniform", "(", "self", ".", "mParams", ".", "n_weight_range", "[", "0", "]", ",", "self", ".", "mParams", ".", "n_weight_range", "[", "1", "]", ")", "\n", "# generate a randon input attr", "\n", "n_input_rand_attr", "=", "random", ".", "randrange", "(", "self", ".", "mParams", ".", "n_max_input_attr", ")", "\n", "#Replace finctionnide by a leaf node", "\n", "subTree_parent_node", ".", "removeAndReplace", "(", "subTree", ",", "n_weight", ",", "n_input_rand_attr", ")", "\n", "tree", ".", "inspectChildNodes", "(", ")", "\n", "#print('The function node', subtree_Index , 'was replaced by a leaf node', n_funNodes_count)", "\n", "return", "tree", "# returning mutated tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutationGrowSubTree": [[224, 239], ["random.randrange", "leaf_node.getParentNode", "leaf_node.getParentNode.removeAndGrow", "tree.inspectChildNodes", "len", "tree.getLeafNodesList", "tree.getLeafNodesList"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getParentNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.removeAndGrow", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList"], ["", "def", "mutationGrowSubTree", "(", "self", ",", "tree", ")", ":", "\n", "        ", "'''\n            Remove a leaf node and grow a subtree\n        '''", "\n", "\n", "#print('mutatate: grow a leaf node')", "\n", "#Select a leaf node in the tree to  be replaced ny a random attr", "\n", "index_rand_leaf", "=", "random", ".", "randrange", "(", "len", "(", "tree", ".", "getLeafNodesList", "(", ")", ")", ")", "\n", "# Fetching that (randentify) node object from the tree leaf node list", "\n", "leaf_node", "=", "tree", ".", "getLeafNodesList", "(", ")", "[", "index_rand_leaf", "]", "\n", "#Fetch the parenm node of the selected leaf node", "\n", "parent_node", "=", "leaf_node", ".", "getParentNode", "(", ")", "\n", "parent_node", ".", "removeAndGrow", "(", "leaf_node", ",", "self", ".", "mParams", ")", "\n", "tree", ".", "inspectChildNodes", "(", ")", "\n", "return", "tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.individual.Individual.__init__": [[21, 30], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "mTree", "=", "None", "\n", "self", ".", "mCost", "=", "[", "]", "\n", "self", ".", "mRank", "=", "[", "]", "\n", "self", ".", "mDominationSet", "=", "[", "]", "\n", "self", ".", "mDominatedCount", "=", "[", "]", "\n", "self", ".", "mNormalizedCost", "=", "[", "]", "\n", "self", ".", "mAssociatedRef", "=", "[", "]", "\n", "self", ".", "mDistanceToAssociatedRef", "=", "[", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values": [[13, 25], ["len", "len", "values.index", "sorted_list.append", "min", "values.index", "values.index", "min", "min"], "function", ["None"], ["\n", "if", "len", "(", "bound", ")", ">=", "2", ":", "\n", "        ", "minimum", "=", "bound", "[", "0", "]", "\n", "maximum", "=", "bound", "[", "1", "]", "\n", "\n", "for", "elm", "in", "range", "(", "len", "(", "parameter", ")", ")", ":", "\n", "            ", "if", "parameter", "[", "elm", "]", "<", "minimum", ":", "\n", "# if the element of paramter is less then min value then set it ot min value", "\n", "                ", "parameter", "[", "elm", "]", "=", "minimum", "\n", "", "if", "parameter", "[", "elm", "]", ">", "maximum", ":", "\n", "# if the element of paramter is greter then max value then set it ot max value", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.index_of": [[27, 32], ["range", "len"], "function", ["None"], ["", "", "", "else", ":", "\n", "        ", "print", "(", "'First argument of bound_check takes a list of two items [min, max]'", ")", "\n", "\n", "# return the parameter with or without check", "\n", "", "return", "parameter", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.unique_elements": [[34, 48], ["unique_list.append", "print"], "function", ["None"], []], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.index_in_list": [[49, 55], ["index_list.append", "pList.index"], "function", ["None"], []], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.preserve_diversity": [[56, 67], ["misc.sort_by_values", "round", "pop.mTree.getTreeSize", "misc.index_in_list", "misc.unique_elements", "range", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.index_in_list", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.unique_elements"], []], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction": [[8, 37], ["pEvaluation.set_dataset_to_evaluate", "pEvaluation.getTreePredictedOutputs", "pEvaluation.set_dataset_to_evaluate", "pEvaluation.getTreePredictedOutputs", "pEvaluation.set_dataset_to_evaluate", "pEvaluation.getTreePredictedOutputs", "pEvaluation.getTreeFitness", "pEvaluation.set_dataset_to_evaluate", "pEvaluation.getTreePredictedOutputs", "pTree.getTreeSize", "pEvaluation.getTreeFitness", "pEvaluation.getTreeFitness", "pEvaluation.getTreeFitness", "pTree.getTreeSize"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["def", "costFunction", "(", "pEvaluation", ",", "pSet", ",", "pTree", ",", "pObjs", "=", "2", ",", "only_error", "=", "True", ")", ":", "\n", "    ", "'''\n        Compute a vector of objective functions\n        args:\n            param:  pEvaluation  data to evaluate\n            param:  pSet type of dataset\n            param:  pTree the tree on which to evaluate \n            param:  pObjs defult is 2 for nsga-2 and nsga-3 \n    '''", "\n", "if", "only_error", ":", "\n", "        ", "if", "pObjs", "==", "1", ":", "\n", "            ", "pEvaluation", ".", "set_dataset_to_evaluate", "(", "pSet", ")", "\n", "_", "=", "pEvaluation", ".", "getTreePredictedOutputs", "(", "pTree", ")", "#  collected output prediction note used here", "\n", "return", "[", "pEvaluation", ".", "getTreeFitness", "(", ")", "[", "0", "]", "]", "\n", "\n", "", "if", "pObjs", "==", "2", ":", "\n", "            ", "pEvaluation", ".", "set_dataset_to_evaluate", "(", "pSet", ")", "\n", "_", "=", "pEvaluation", ".", "getTreePredictedOutputs", "(", "pTree", ")", "#  collected output prediction note used here", "\n", "return", "[", "pEvaluation", ".", "getTreeFitness", "(", ")", "[", "0", "]", ",", "pTree", ".", "getTreeSize", "(", ")", "]", "\n", "", "", "else", ":", "\n", "        ", "if", "pObjs", "==", "1", ":", "\n", "            ", "pEvaluation", ".", "set_dataset_to_evaluate", "(", "pSet", ")", "\n", "_", "=", "pEvaluation", ".", "getTreePredictedOutputs", "(", "pTree", ")", "#  collected output prediction note used here", "\n", "return", "pEvaluation", ".", "getTreeFitness", "(", ")", "\n", "\n", "", "if", "pObjs", "==", "2", ":", "\n", "            ", "pEvaluation", ".", "set_dataset_to_evaluate", "(", "pSet", ")", "\n", "_", "=", "pEvaluation", ".", "getTreePredictedOutputs", "(", "pTree", ")", "#  collected output prediction note used here", "\n", "return", "pEvaluation", ".", "getTreeFitness", "(", ")", "+", "[", "pTree", ".", "getTreeSize", "(", ")", "]", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.__init__": [[20, 26], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ")", ":", "\n", "        ", "'''\n        \n        '''", "\n", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.structure_optimization.StructureOptimization.optimize": [[27, 45], ["print", "src.optimization.structure.gp.gp.GP", "src.optimization.structure.gp.gp.GP.start", "print", "src.optimization.structure.nsgpii.nsgp_ii.NSGPII", "src.optimization.structure.nsgpii.nsgp_ii.NSGPII.start", "print", "src.optimization.structure.nsgpiii.nsgp_iii.NSGPIII", "src.optimization.structure.nsgpiii.nsgp_iii.NSGPIII.start"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start"], ["", "def", "optimize", "(", "self", ",", "directory", ",", "trail", ")", ":", "\n", "        ", "'''\n            Call an optimization anlogrithm\n        '''", "\n", "if", "self", ".", "mParams", ".", "n_algo_structure", "==", "'gp'", ":", "\n", "            ", "print", "(", "'Evaluating tree using GP....'", ")", "\n", "gp", "=", "GP", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ")", "\n", "return", "gp", ".", "start", "(", "directory", ",", "trail", ")", "\n", "\n", "", "if", "self", ".", "mParams", ".", "n_algo_structure", "==", "'nsgp_2'", ":", "\n", "            ", "print", "(", "'Evaluating tree using NSGP-II....'", ")", "\n", "nsgpii", "=", "NSGPII", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ")", "\n", "return", "nsgpii", ".", "start", "(", "directory", ",", "trail", ")", "\n", "\n", "", "if", "self", ".", "mParams", ".", "n_algo_structure", "==", "'nsgp_3'", ":", "\n", "            ", "print", "(", "'Evaluating tree using NSGP-III....'", ")", "\n", "nsgpiii", "=", "NSGPIII", "(", "self", ".", "mEvaluateTree", ",", "self", ".", "mParams", ")", "\n", "return", "nsgpiii", ".", "start", "(", "directory", ",", "trail", ")", "\n", "#return None", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.crowding_distance.crowding_distance": [[11, 46], ["len", "range", "src.optimization.structure.misc.sort_by_values", "range", "range", "len", "len", "range", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values"], ["def", "crowding_distance", "(", "P", ",", "front", ")", ":", "\n", "    ", "'''\n        Recieves a population and its a set of nondominated solutions (form front 0 to ...)\n        args:\n            param:    P              population\n            param:    front = I     front  (index of individuals in P) a nondominated sorted front\n        \n        return: distance\n    '''", "\n", "#P = population", "\n", "#l = len(front) # l = |I| , i.e., inds_in_this_font", "\n", "distance", "=", "[", "0", "for", "i", "in", "range", "(", "0", ",", "len", "(", "front", ")", ")", "]", "# for each i, set I[i]distance = 0", "\n", "no_obj", "=", "len", "(", "P", "[", "0", "]", ".", "mCost", ")", "\n", "\n", "# Initilize a infinit -  here we have very large number", "\n", "distance", "[", "0", "]", "=", "99999999999", "\n", "distance", "[", "len", "(", "front", ")", "-", "1", "]", "=", "99999999999", "\n", "#for each objective m", "\n", "for", "m", "in", "range", "(", "no_obj", ")", ":", "\n", "#fetch values of the objetcive functions", "\n", "        ", "values", "=", "[", "P", "[", "i", "]", ".", "mCost", "[", "m", "]", "for", "i", "in", "range", "(", "len", "(", "P", ")", ")", "]", "\n", "#sort for values of the objecive m", "\n", "sortedFont", "=", "sort_by_values", "(", "front", ",", "values", "[", ":", "]", ")", "\n", "#fmin = min(values)", "\n", "#fmax = max(values)", "\n", "fmin", "=", "values", "[", "sortedFont", "[", "0", "]", "]", "\n", "fmax", "=", "values", "[", "sortedFont", "[", "len", "(", "front", ")", "-", "1", "]", "]", "\n", "# for i = 2 to l -1 -  here indext start fron 1", "\n", "for", "k", "in", "range", "(", "1", ",", "len", "(", "front", ")", "-", "1", ")", ":", "\n", "            ", "if", "fmax", "-", "fmin", "==", "0", ":", "\n", "                ", "distance", "[", "k", "]", "=", "99999999999", "\n", "", "else", ":", "\n", "                ", "distance", "[", "k", "]", "=", "distance", "[", "k", "]", "+", "(", "values", "[", "sortedFont", "[", "k", "+", "1", "]", "]", "-", "values", "[", "sortedFont", "[", "k", "-", "1", "]", "]", ")", "/", "(", "fmax", "-", "fmin", ")", "\n", "\n", "", "", "", "return", "distance", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.fast_non_dominated_sort.fast_non_dominated_sort": [[8, 114], ["len", "range", "len", "range", "front.append", "range", "range", "range", "len", "range", "len", "len", "len", "front[].append", "len", "S[].append", "Q.append"], "function", ["None"], ["def", "fast_non_dominated_sort", "(", "P", ",", "OPTIMIZATION", "=", "'MIN'", ")", ":", "\n", "    ", "'''\n        Compute fast non dominated sorting: \n            Deb K, Pratap A, Agarwal S, et al. \n            A fast and elitist multiobjective genetic algorithm: NSGA-II. \n            IEEE transactions on Evolutionary Computation, 2002, 6(2): 182-197.\n        args:\n            param:    p_pop             population\n            param:    OPTIMIZATION      takes 'MIN' or MAX\n        return:  nondominated sorted sets - font 0 to ...\n    '''", "\n", "\n", "#P = population # ONLY open for a test case", "\n", "no_objectives", "=", "len", "(", "P", "[", "0", "]", ".", "mCost", ")", "\n", "# initilize NULL set that will hold all solutions that dominate a solution p in P", "\n", "S", "=", "[", "[", "]", "for", "i", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", "]", "# Empty/NULL set", "\n", "front", "=", "[", "[", "]", "]", "# Initilize Empty Font sets", "\n", "\n", "# DOMINATION COUNT:", "\n", "# the number of solutions which dominates the soultion p in P", "\n", "n", "=", "[", "0", "for", "i", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", "]", "#  Initilize to zero :  ", "\n", "\n", "rank", "=", "[", "0", "for", "i", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", "]", "#  Initilize rank to zero", "\n", "\n", "# for each p in P", "\n", "for", "p", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", ":", "\n", "        ", "S", "[", "p", "]", "=", "[", "]", "# set of solutions (qs) that are dominated by p in P", "\n", "n", "[", "p", "]", "=", "0", "# the number of solutions (number of qs) which dominates the soultion p in P", "\n", "# for each q in P ", "\n", "for", "q", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", ":", "\n", "#Alternatively", "\n", "#            values1p = P[p].getFunctionValues()[0]", "\n", "#            values1q = P[q].getFunctionValues()[0]", "\n", "#            ", "\n", "#            values2p = P[p].getFunctionValues()[1]", "\n", "#            values2q = P[q].getFunctionValues()[1]", "\n", "#            ", "\n", "#            if (values1p > values1q and values2p > values2q) or (values1p >= values1q and values2p > values2q) or (values1p > values1q and values2p >= values2q):", "\n", "#                if q not in S[p]:", "\n", "#                    S[p].append(q)", "\n", "#            elif (values1q > values1p and values2q > values2p) or (values1q >= values1p and values2q > values2p) or (values1q > values1p and values2q >= values2p):", "\n", "#                n[p] = n[p] + 1  ", "\n", "\n", "            ", "dom_less", ",", "dom_equl", ",", "dom_more", "=", "0", ",", "0", ",", "0", "\n", "for", "k", "in", "range", "(", "0", ",", "no_objectives", ")", ":", "\n", "# count all objectives for which p's value is LOWER than q's values", "\n", "                ", "if", "(", "P", "[", "p", "]", ".", "mCost", "[", "k", "]", "<", "P", "[", "q", "]", ".", "mCost", "[", "k", "]", ")", ":", "\n", "                    ", "dom_less", "+=", "1", "# p dominates", "\n", "# count all objectives for which p's value is EQUAL to than q's values", "\n", "", "if", "(", "P", "[", "p", "]", ".", "mCost", "[", "k", "]", "==", "P", "[", "q", "]", ".", "mCost", "[", "k", "]", ")", ":", "\n", "                    ", "dom_equl", "+=", "1", "# drwa between p and q", "\n", "# count all objectives for which p's value is HIGHER than q's values", "\n", "", "if", "(", "P", "[", "p", "]", ".", "mCost", "[", "k", "]", ">", "P", "[", "q", "]", ".", "mCost", "[", "k", "]", ")", ":", "\n", "                    ", "dom_more", "+=", "1", "# q dominates", "\n", "\n", "", "", "if", "(", "OPTIMIZATION", "==", "'MIN'", ")", ":", "\n", "# dom_more == 0 means that we could not find for any objective for which p has a HIGHER value than q", "\n", "# atleast for one or objectives p has a LOWER obj values than q, hence p (wins) dominates q", "\n", "                ", "p_dominats_q", "=", "dom_more", "\n", "# For minimization search for dom_less == 0 means we could not find any objective for which p has LOWER value tha q ", "\n", "# i.e., atlease for one or more objective p has HIGHER values than q, hence q (wins) dominats", "\n", "p_dominated_by_q", "=", "dom_less", "\n", "\n", "", "if", "(", "OPTIMIZATION", "==", "'MAX'", ")", ":", "\n", "# dom_less == 0 means that we could not find for any objective for which p has a LOWER value than q", "\n", "# atleast for one or objectives p has a HIGHER obj values than q, hence p (wins) dominates q", "\n", "                ", "p_dominats_q", "=", "dom_less", "\n", "# For minimization search for dom_less == 0 means we could not find any objective for which p has HIGHER value tha q ", "\n", "# i.e., atlease for one or more objective p has LOWER values than q, hence q (wins) dominats", "\n", "p_dominated_by_q", "=", "dom_more", "\n", "\n", "\n", "\n", "# set of solutions (qs) dominated by p", "\n", "", "if", "(", "p_dominats_q", "==", "0", "and", "dom_equl", "!=", "no_objectives", ")", ":", "\n", "# Add q to the set of solution dominated by p", "\n", "                ", "if", "q", "not", "in", "S", "[", "p", "]", ":", "\n", "                    ", "S", "[", "p", "]", ".", "append", "(", "q", ")", "\n", "#the number of solutions (number of qs) which dominates the soultion p in P", "\n", "", "", "if", "(", "p_dominated_by_q", "==", "0", "and", "dom_equl", "!=", "no_objectives", ")", ":", "\n", "# q dominates p ", "\n", "                ", "n", "[", "p", "]", "=", "n", "[", "p", "]", "+", "1", "#  increament the doination counter of p            ", "\n", "#END of K", "\n", "\n", "# check if p belongs to first front", "\n", "", "", "if", "n", "[", "p", "]", "==", "0", ":", "\n", "            ", "rank", "[", "p", "]", "=", "0", "\n", "if", "p", "not", "in", "front", "[", "0", "]", ":", "\n", "                ", "front", "[", "0", "]", ".", "append", "(", "p", ")", "\n", "\n", "", "", "", "i", "=", "0", "# initilize forn counter", "\n", "# while font is not NULL", "\n", "while", "(", "front", "[", "i", "]", "!=", "[", "]", ")", ":", "\n", "        ", "Q", "=", "[", "]", "\n", "for", "p", "in", "front", "[", "i", "]", ":", "\n", "            ", "for", "q", "in", "S", "[", "p", "]", ":", "\n", "                ", "n", "[", "q", "]", "=", "n", "[", "q", "]", "-", "1", "\n", "if", "(", "n", "[", "q", "]", "==", "0", ")", ":", "\n", "                    ", "rank", "[", "q", "]", "=", "i", "+", "1", "\n", "if", "q", "not", "in", "Q", ":", "\n", "                        ", "Q", ".", "append", "(", "q", ")", "\n", "", "", "", "", "i", "=", "i", "+", "1", "\n", "front", ".", "append", "(", "Q", ")", "\n", "\n", "", "del", "front", "[", "len", "(", "front", ")", "-", "1", "]", "\n", "return", "front", "\n", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.nsgp_ii.NSGPII.__init__": [[36, 44], ["src.optimization.structure.individual.Individual"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ")", ":", "\n", "        ", "'''\n            Setting param for nsga to run\n        '''", "\n", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mBestIndividual", "=", "Individual", "(", ")", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.nsgp_ii.NSGPII.start": [[46, 184], ["print", "nsgp_ii.NSGPII.setBestTree", "nsgp_ii.NSGPII.performance_record.append", "nsgp_ii.NSGPII.setBestTree", "src.optimization.structure.individual.Individual", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.misc.preserve_diversity", "src.optimization.structure.nsgpii.fast_non_dominated_sort.fast_non_dominated_sort", "range", "src.optimization.structure.nsgpii.fast_non_dominated_sort.fast_non_dominated_sort", "range", "range", "nsgp_ii.NSGPII.setBestTree", "nsgp_ii.NSGPII.performance_record.append", "src.reporting.plots.plotParetoFront", "src.reporting.plots.saveGPIteration", "range", "sort_by_values", "len", "src.optimization.structure.individual.Individual", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.misc.preserve_diversity.append", "len", "crowding_distance_values.append", "copy.deepcopy", "len", "src.optimization.structure.genetic_operators.GeneticOperator", "len", "crowding_distance_values_gen.append", "len", "sort_by_values", "front.reverse", "copy.deepcopy", "src.optimization.structure.cost_functions.costFunction", "src.reporting.plots.saveGPIteration", "src.optimization.structure.nsgpii.crowding_distance.crowding_distance", "range", "random.randint", "random.randint", "copy.deepcopy", "copy.deepcopy", "src.optimization.structure.genetic_operators.GeneticOperator.crossoverTree", "random.randint", "copy.deepcopy", "src.optimization.structure.genetic_operators.GeneticOperator.mutation", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "src.optimization.structure.nsgpii.crowding_distance.crowding_distance", "index_of", "new_solution.append", "len", "str", "range", "range", "len", "random.random", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "range", "range", "len", "sort_by_values", "len", "len", "range", "round", "len", "len", "sort_by_values", "len", "range", "range", "len", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.preserve_diversity", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.fast_non_dominated_sort.fast_non_dominated_sort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.fast_non_dominated_sort.fast_non_dominated_sort", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotParetoFront", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.crowding_distance.crowding_distance", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.crossoverTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.crowding_distance.crowding_distance", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.index_of", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values"], ["", "def", "start", "(", "self", ",", "directory", ",", "trail", ")", ":", "\n", "\n", "        ", "pop_size", "=", "self", ".", "mParams", ".", "n_max_population", "\n", "\n", "print", "(", "'NSGPII initial population: Tree index [Error, Size]'", ")", "\n", "# STEP 1: INITIALIZE POPULATION -------------------------------------------------------------------------", "\n", "# 1a. Empty individuals - population is a objeect of individuals", "\n", "nPopulation", "=", "[", "Individual", "(", ")", "for", "i", "in", "range", "(", "0", ",", "pop_size", ")", "]", "# Empty population         ", "\n", "# 1b. Create individual tree and evaluate fitness of each individual tree ", "\n", "for", "pop", "in", "nPopulation", ":", "\n", "            ", "n_tree", "=", "NeuralTree", "(", ")", "#  initating a class of tree", "\n", "n_tree", ".", "genrateGenericRandomTree", "(", "self", ".", "mParams", ")", "\n", "pop", ".", "mTree", "=", "n_tree", "\n", "pop", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "pop", ".", "mTree", ",", "2", ")", "#  1 for one objetive", "\n", "#print('Tree', nPopulation.index(pop), '[',round(pop.mCost[0], 2), pop.mTree.getTreeSize(),']')        ", "\n", "# 1c. Sortining of the population according to their approximation error/ classifcation error", "\n", "", "nPopulation", "=", "[", "nPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "nPopulation", "]", ")", "]", "\n", "#print('\\nInitial sorted population: Tree index [Error Size]')", "\n", "#for pop in nPopulation:", "\n", "#print('Tree', nPopulation.index(pop), '[',round(pop.mCost[0], 2), pop.mTree.getTreeSize(),']')", "\n", "\n", "self", ".", "setBestTree", "(", "nPopulation", "[", "0", "]", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "self", ".", "mBestIndividual", ".", "mTree", ",", "2", ",", "False", ")", ")", "\n", "\n", "itr", "=", "0", "\n", "while", "(", "itr", "<", "self", ".", "mParams", ".", "n_max_itrations", ")", ":", "\n", "            ", "nPopulation", "=", "preserve_diversity", "(", "nPopulation", ",", "pop_size", ")", "\n", "#print(' # diverse inds = ', len(nPopulation), end=' ')", "\n", "#generate new individuals if number of diverse individuals less than total population size", "\n", "while", "(", "len", "(", "nPopulation", ")", "<", "pop_size", ")", ":", "\n", "                ", "ind", "=", "Individual", "(", ")", "\n", "n_tree", "=", "NeuralTree", "(", ")", "#  initating a class of tree", "\n", "n_tree", ".", "genrateGenericRandomTree", "(", "self", ".", "mParams", ")", "\n", "ind", ".", "mTree", "=", "n_tree", "\n", "ind", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "ind", ".", "mTree", ",", "2", ")", "#  1 for one objetive", "\n", "nPopulation", ".", "append", "(", "ind", ")", "\n", "\n", "# Non dominated sorting", "\n", "", "non_dominated_sorted_solution", "=", "fast_non_dominated_sort", "(", "nPopulation", ",", "self", ".", "mParams", ".", "n_optimization", ")", "\n", "#print(\"\\nThe best front for Generation number \", itr, \" is\", len(non_dominated_sorted_solution[0]),\" : \", non_dominated_sorted_solution[0])", "\n", "#for values in non_dominated_sorted_solution[0]:", "\n", "#    print([round(x,3) for x in nPopulation[values].mCost], end = \" \")", "\n", "\n", "crowding_distance_values", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "non_dominated_sorted_solution", ")", ")", ":", "\n", "                ", "crowding_distance_values", ".", "append", "(", "crowding_distance", "(", "nPopulation", ",", "non_dominated_sorted_solution", "[", "i", "]", "[", ":", "]", ")", ")", "\n", "\n", "#STEP 2: Generating offsprings ---------------------------------------------------------------------", "\n", "# 2a. copy population in to itrPopulation", "\n", "", "itrPopulation", "=", "[", "copy", ".", "deepcopy", "(", "nPopulation", "[", "i", "]", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", "\n", "countCorssover", ",", "countMutation", "=", "0", ",", "0", "\n", "while", "(", "len", "(", "itrPopulation", ")", "<", "2", "*", "pop_size", ")", ":", "\n", "# 2b. creating reference for crossopver and mutation oprators", "\n", "                ", "operator", "=", "GeneticOperator", "(", "self", ".", "mParams", ")", "\n", "if", "self", ".", "mParams", ".", "n_prob_crossover", "/", "2.0", "<", "random", ".", "random", "(", ")", "and", "countCorssover", "<", "2", "*", "round", "(", "self", ".", "mParams", ".", "n_prob_crossover", "*", "pop_size", "/", "2", ")", ":", "\n", "# CROSSOVER OPERATION", "\n", "#print('crossover')", "\n", "                    ", "p1", "=", "random", ".", "randint", "(", "0", ",", "pop_size", "-", "1", ")", "\n", "p2", "=", "random", ".", "randint", "(", "0", ",", "pop_size", "-", "1", ")", "\n", "\n", "nParentTree1", "=", "copy", ".", "deepcopy", "(", "nPopulation", "[", "p1", "]", ".", "mTree", ")", "\n", "nParentTree2", "=", "copy", ".", "deepcopy", "(", "nPopulation", "[", "p2", "]", ".", "mTree", ")", "\n", "\n", "firstTree", ",", "secondTree", ",", "is_crossover_done", "=", "operator", ".", "crossoverTree", "(", "nParentTree1", ",", "nParentTree2", ")", "\n", "if", "is_crossover_done", ":", "\n", "                        ", "child1", "=", "Individual", "(", ")", "\n", "child1", ".", "mTree", "=", "firstTree", "\n", "child1", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child1", ".", "mTree", ",", "2", ")", "\n", "itrPopulation", ".", "append", "(", "child1", ")", "\n", "\n", "child2", "=", "Individual", "(", ")", "\n", "child2", ".", "mTree", "=", "secondTree", "\n", "child2", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child2", ".", "mTree", ",", "2", ")", "\n", "itrPopulation", ".", "append", "(", "child2", ")", "\n", "countCorssover", "+=", "2", "\n", "# just for cleaning up -  not necessary", "\n", "del", "nParentTree1", ",", "nParentTree2", ",", "firstTree", ",", "secondTree", ",", "child1", ",", "child2", "\n", "", "", "else", ":", "\n", "# MUTATION OPEARATION", "\n", "#print('mutation')", "\n", "                    ", "p1", "=", "random", ".", "randint", "(", "0", ",", "pop_size", "-", "1", ")", "\n", "nParentTree", "=", "copy", ".", "deepcopy", "(", "nPopulation", "[", "p1", "]", ".", "mTree", ")", "\n", "m_tree", "=", "operator", ".", "mutation", "(", "nParentTree", ")", "\n", "child", "=", "Individual", "(", ")", "\n", "child", ".", "mTree", "=", "m_tree", "\n", "child", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child", ".", "mTree", ",", "2", ")", "\n", "itrPopulation", ".", "append", "(", "child", ")", "\n", "countMutation", "+=", "1", "\n", "#Generating offsprings END---------------------------------------------------------------------", "\n", "\n", "#Non dominated sorting", "\n", "", "", "non_dominated_sorted_solution_gen", "=", "fast_non_dominated_sort", "(", "itrPopulation", ",", "self", ".", "mParams", ".", "n_optimization", ")", "\n", "#crowding distance computation", "\n", "crowding_distance_values_gen", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "non_dominated_sorted_solution_gen", ")", ")", ":", "\n", "                ", "crowding_distance_values_gen", ".", "append", "(", "crowding_distance", "(", "itrPopulation", ",", "non_dominated_sorted_solution_gen", "[", "i", "]", "[", ":", "]", ")", ")", "\n", "#print(crowding_distance_values_gen)", "\n", "\n", "", "new_solution", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "non_dominated_sorted_solution_gen", ")", ")", ":", "\n", "#SORTING of the forn", "\n", "#Retriving postion (index) of the individuals in the nondominated font", "\n", "                ", "non_dominated_sorted_solution_gen_indIndexList", "=", "[", "index_of", "(", "non_dominated_sorted_solution_gen", "[", "i", "]", "[", "j", "]", ",", "non_dominated_sorted_solution_gen", "[", "i", "]", ")", "for", "j", "in", "range", "(", "0", ",", "len", "(", "non_dominated_sorted_solution_gen", "[", "i", "]", ")", ")", "]", "\n", "#Sortining front index by its crowding distance values", "\n", "front_assending_order_indexList", "=", "sort_by_values", "(", "non_dominated_sorted_solution_gen_indIndexList", "[", ":", "]", ",", "crowding_distance_values_gen", "[", "i", "]", "[", ":", "]", ")", "\n", "# retriving index of individuals based on the sorted position(index) of the individual in the nondominated font", "\n", "front", "=", "[", "non_dominated_sorted_solution_gen", "[", "i", "]", "[", "front_assending_order_indexList", "[", "j", "]", "]", "for", "j", "in", "range", "(", "0", ",", "len", "(", "non_dominated_sorted_solution_gen", "[", "i", "]", ")", ")", "]", "\n", "#reverse the list to get the decending order of crowding distance", "\n", "front", ".", "reverse", "(", ")", "\n", "# Consider the indeividual into new population", "\n", "for", "value", "in", "front", ":", "\n", "                    ", "new_solution", ".", "append", "(", "value", ")", "\n", "if", "(", "len", "(", "new_solution", ")", "==", "pop_size", ")", ":", "\n", "                        ", "break", "\n", "", "", "if", "(", "len", "(", "new_solution", ")", "==", "pop_size", ")", ":", "\n", "                    ", "break", "\n", "\n", "", "", "nPopulation", "=", "[", "copy", ".", "deepcopy", "(", "itrPopulation", "[", "i", "]", ")", "for", "i", "in", "new_solution", "]", "\n", "del", "itrPopulation", "\n", "print_best", "=", "self", ".", "setBestTree", "(", "[", "nPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "nPopulation", "]", ")", "]", "[", "0", "]", ",", "itr", "+", "1", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "self", ".", "mBestIndividual", ".", "mTree", ",", "2", ",", "False", ")", ")", "\n", "#if(int(np.mod(itr,10)) == 0) and not print_best:", "\n", "#    print('GP Itr', itr+1, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),']')", "\n", "if", "False", ":", "#if Save Itration = True", "\n", "                ", "saveGPIteration", "(", "nPopulation", ",", "directory", ",", "trail", ",", "str", "(", "itr", ")", ",", "'nsgp_2_'", ")", "\n", "", "itr", "=", "itr", "+", "1", "\n", "# WHILE ENDS HERE", "\n", "", "print_best", "=", "self", ".", "setBestTree", "(", "[", "nPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "nPopulation", "]", ")", "]", "[", "0", "]", ",", "itr", ")", "\n", "\n", "#print('GP Itr', itr+1, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),']')", "\n", "plotFinal", "=", "True", "\n", "if", "plotFinal", ":", "\n", "            ", "x", "=", "[", "nPopulation", "[", "i", "]", ".", "mCost", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "nPopulation", ")", ")", "]", "\n", "y", "=", "[", "nPopulation", "[", "i", "]", ".", "mCost", "[", "1", "]", "for", "i", "in", "range", "(", "len", "(", "nPopulation", ")", ")", "]", "\n", "plotParetoFront", "(", "x", ",", "y", ",", "directory", ",", "trail", ",", "'nsgp_2_'", ")", "\n", "saveGPIteration", "(", "nPopulation", ",", "directory", ",", "trail", ",", "'final'", ",", "'nsgp_2_'", ")", "\n", "\n", "", "return", "self", ".", "mBestIndividual", ".", "mTree", ",", "nPopulation", ",", "self", ".", "performance_record", "# returning the best tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpii.nsgp_ii.NSGPII.setBestTree": [[186, 207], ["nsgp_ii.NSGPII.mBestIndividual.mTree.getTreeSize", "pIndividual.mTree.getTreeSize"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "def", "setBestTree", "(", "self", ",", "pIndividual", ",", "itr", "=", "0", ")", ":", "\n", "        ", "'''\n            Compare the current individial tree with the best Tree found so far\n            arges:\n                param:  pIndividual  an individual tree\n        '''", "\n", "print_best", "=", "False", "\n", "if", "self", ".", "mBestIndividual", ".", "mTree", "==", "None", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "", "if", "self", ".", "mBestIndividual", ".", "mCost", "[", "0", "]", ">", "pIndividual", ".", "mCost", "[", "0", "]", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "", "if", "self", ".", "mBestIndividual", ".", "mCost", "[", "0", "]", "==", "pIndividual", ".", "mCost", "[", "0", "]", "and", "self", ".", "mBestIndividual", ".", "mTree", ".", "getTreeSize", "(", ")", ">", "pIndividual", ".", "mTree", ".", "getTreeSize", "(", ")", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.sortAndSelectPopulation.sortAndSelectPopulation": [[15, 81], ["src.optimization.structure.nsgpiii.normalizePopulation.normalizePopulation", "src.optimization.structure.nsgpiii.nonDominatedSorting.nonDominatedSorting", "src.optimization.structure.nsgpiii.associateToReferencePoint.associateToReferencePoint", "range", "src.optimization.structure.nsgpiii.nonDominatedSorting.nonDominatedSorting", "len", "len", "newPopulation.extend", "numpy.argmin", "newPopulation.append", "numpy.argmin", "random.randint", "nLastFront.remove", "len", "len", "len", "associtedFromLastFront.append", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.normalizePopulation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nonDominatedSorting.nonDominatedSorting", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.associateToReferencePoint.associateToReferencePoint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nonDominatedSorting.nonDominatedSorting"], ["def", "sortAndSelectPopulation", "(", "pPopulation", ",", "pParams", ",", "pOptimization", "=", "'MIN'", ")", ":", "\n", "    ", "'''\n        Population sorting and selection method calls\n    '''", "\n", "nPopulation", ",", "nParams", "=", "normalizePopulation", "(", "pPopulation", ",", "pParams", ")", "\n", "\n", "nPopulation", ",", "nFront", "=", "nonDominatedSorting", "(", "nPopulation", ",", "pOptimization", ")", "\n", "\n", "#    for f in nFront:", "\n", "#        print(np.add(f,1))", "\n", "\n", "\n", "if", "len", "(", "nPopulation", ")", "==", "nParams", ".", "nPop", ":", "\n", "        ", "return", "nPopulation", ",", "nFront", ",", "nParams", "\n", "\n", "\n", "", "nPopulation", ",", "dist", ",", "rho", "=", "associateToReferencePoint", "(", "nPopulation", ",", "nParams", ")", "\n", "\n", "#    for pop in nPopulation:", "\n", "#        print(pop.mAssociatedRef+1) # tested ok", "\n", "\n", "newPopulation", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "nFront", ")", ")", ":", "\n", "        ", "if", "len", "(", "newPopulation", ")", "+", "len", "(", "nFront", "[", "i", "]", ")", ">", "nParams", ".", "nPop", ":", "\n", "            ", "nLastFront", "=", "nFront", "[", "i", "]", "\n", "break", "\n", "#Extent newpopulation by adding all population in Front i", "\n", "", "newPopulation", ".", "extend", "(", "[", "nPopulation", "[", "popIndex", "]", "for", "popIndex", "in", "nFront", "[", "i", "]", "]", ")", "\n", "\n", "\n", "# Adding individuals from last front to the population", "\n", "", "while", "True", ":", "\n", "\n", "        ", "rhoMinIndex", "=", "np", ".", "argmin", "(", "rho", ")", "\n", "associtedFromLastFront", "=", "[", "]", "\n", "for", "popIndex", "in", "nLastFront", ":", "\n", "            ", "if", "nPopulation", "[", "popIndex", "]", ".", "mAssociatedRef", "==", "rhoMinIndex", ":", "\n", "                ", "associtedFromLastFront", ".", "append", "(", "popIndex", ")", "\n", "\n", "\n", "", "", "if", "not", "associtedFromLastFront", ":", "\n", "            ", "rho", "[", "rhoMinIndex", "]", "=", "np", ".", "Inf", "\n", "continue", "\n", "\n", "", "if", "rho", "[", "rhoMinIndex", "]", "==", "0", ":", "\n", "            ", "distToRhoMinIndexList", "=", "[", "dist", "[", "inexInLastFront", "]", "[", "rhoMinIndex", "]", "for", "inexInLastFront", "in", "associtedFromLastFront", "]", "\n", "newMemberIndex", "=", "np", ".", "argmin", "(", "distToRhoMinIndexList", ")", "\n", "", "else", ":", "\n", "            ", "newMemberIndex", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "associtedFromLastFront", ")", "-", "1", ")", "\n", "\n", "", "memberToAdd", "=", "associtedFromLastFront", "[", "newMemberIndex", "]", "\n", "\n", "if", "memberToAdd", "in", "nLastFront", ":", "\n", "            ", "nLastFront", ".", "remove", "(", "memberToAdd", ")", "\n", "\n", "", "newPopulation", ".", "append", "(", "nPopulation", "[", "memberToAdd", "]", ")", "\n", "\n", "rho", "[", "rhoMinIndex", "]", "=", "rho", "[", "rhoMinIndex", "]", "+", "1", "\n", "\n", "if", "len", "(", "newPopulation", ")", ">=", "nParams", ".", "nPop", ":", "\n", "            ", "break", "\n", "\n", "\n", "", "", "nPopulation", ",", "nFront", "=", "nonDominatedSorting", "(", "newPopulation", ",", "pOptimization", ")", "\n", "\n", "return", "nPopulation", ",", "nFront", ",", "nParams", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.generateReferencePoints.generateReferencePoints": [[11, 15], ["generateReferencePoints.getFixedRowSumIntegerMatrix", "Zr.transpose.transpose", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.generateReferencePoints.getFixedRowSumIntegerMatrix"], ["def", "generateReferencePoints", "(", "M", ",", "p", ")", ":", "\n", "    ", "Zr", "=", "getFixedRowSumIntegerMatrix", "(", "M", ",", "p", ")", "\n", "Zr", "=", "Zr", ".", "transpose", "(", ")", "\n", "return", "np", ".", "divide", "(", "Zr", ",", "p", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.generateReferencePoints.getFixedRowSumIntegerMatrix": [[17, 43], ["range", "print", "math.floor", "print", "generateReferencePoints.getFixedRowSumIntegerMatrix", "numpy.asmatrix", "np.append.astype", "numpy.asmatrix", "np.append.transpose", "numpy.append", "numpy.ones", "numpy.append", "len"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.generateReferencePoints.getFixedRowSumIntegerMatrix"], ["", "def", "getFixedRowSumIntegerMatrix", "(", "M", ",", "RowSum", ")", ":", "\n", "    ", "if", "M", "<", "1", ":", "\n", "        ", "print", "(", "'M cannot be less than 1.'", ")", "\n", "\n", "", "if", "math", ".", "floor", "(", "M", ")", "!=", "M", ":", "\n", "        ", "print", "(", "'M must be an integer.'", ")", "\n", "\n", "", "if", "M", "==", "1", ":", "\n", "        ", "return", "[", "RowSum", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "RowSum", "+", "1", ")", ":", "\n", "        ", "B", "=", "getFixedRowSumIntegerMatrix", "(", "M", "-", "1", ",", "RowSum", "-", "i", ")", "\n", "B", "=", "np", ".", "asmatrix", "(", "B", ")", "\n", "#print(len(B))", "\n", "itrMat", "=", "i", "*", "np", ".", "ones", "(", "len", "(", "B", ")", ")", "\n", "itrMat", "=", "itrMat", ".", "astype", "(", "int", ")", "\n", "itrMat", "=", "np", ".", "asmatrix", "(", "itrMat", ")", "\n", "itrMat", "=", "itrMat", ".", "transpose", "(", ")", "\n", "itrMat", "=", "np", ".", "append", "(", "itrMat", ",", "B", ",", "axis", "=", "1", ")", "\n", "#print(itrMat)", "\n", "if", "i", "==", "0", ":", "\n", "            ", "A", "=", "itrMat", "#  To make sure A is a matrix", "\n", "", "else", ":", "\n", "            ", "A", "=", "np", ".", "append", "(", "A", ",", "itrMat", ",", "axis", "=", "0", ")", "# Appending each itrMat as an row to itself", "\n", "\n", "", "", "return", "A", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.associateToReferencePoint.associateToReferencePoint": [[10, 39], ["numpy.zeros", "numpy.zeros", "range", "len", "range", "numpy.min", "numpy.argmin", "len", "numpy.asanyarray", "numpy.asmatrix", "numpy.linalg.norm", "numpy.divide", "numpy.subtract", "numpy.linalg.norm", "numpy.transpose", "numpy.dot", "numpy.dot"], "function", ["None"], ["def", "associateToReferencePoint", "(", "pPopulation", ",", "pParams", ")", ":", "\n", "    ", "'''\n        Method for the associating solution to the refernce points\n    '''", "\n", "\n", "Zr", "=", "pParams", ".", "Zr", "\n", "nZr", "=", "pParams", ".", "nZr", "\n", "rho", "=", "np", ".", "zeros", "(", "nZr", ")", "\n", "\n", "dist", "=", "np", ".", "zeros", "(", "(", "len", "(", "pPopulation", ")", ",", "nZr", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "pPopulation", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "nZr", ")", ":", "\n", "#Compute reference line w", "\n", "            ", "w", "=", "np", ".", "asanyarray", "(", "np", ".", "divide", "(", "Zr", "[", ":", ",", "j", "]", ",", "np", ".", "linalg", ".", "norm", "(", "Zr", "[", ":", ",", "j", "]", ")", ")", ")", "\n", "z", "=", "np", ".", "asmatrix", "(", "pPopulation", "[", "i", "]", ".", "mNormalizedCost", ")", "\n", "# compute distance between an individual and the reference point", "\n", "dist", "[", "i", ",", "j", "]", "=", "np", ".", "linalg", ".", "norm", "(", "np", ".", "subtract", "(", "np", ".", "transpose", "(", "z", ")", ",", "np", ".", "dot", "(", "np", ".", "dot", "(", "w", ",", "z", ")", ",", "w", ")", ")", ")", "\n", "\n", "", "dmin", "=", "np", ".", "min", "(", "dist", "[", "i", ",", ":", "]", ")", "\n", "dminIndex", "=", "np", ".", "argmin", "(", "dist", "[", "i", ",", ":", "]", ")", "\n", "\n", "# assign refernce ", "\n", "pPopulation", "[", "i", "]", ".", "mAssociatedRef", "=", "dminIndex", "\n", "pPopulation", "[", "i", "]", ".", "mDistanceToAssociatedRef", "=", "dmin", "\n", "# conting number of reference point assosiation", "\n", "rho", "[", "dminIndex", "]", "=", "rho", "[", "dminIndex", "]", "+", "1", "\n", "\n", "", "return", "pPopulation", ",", "dist", ",", "rho", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nonDominatedSorting.nonDominatedSorting": [[8, 106], ["len", "range", "range", "len", "range", "front.append", "len", "range", "range", "range", "len", "range", "len", "len", "len", "front[].append", "len", "S[].append", "Q.append"], "function", ["None"], ["def", "nonDominatedSorting", "(", "P", ",", "OPTIMIZATION", "=", "'MIN'", ")", ":", "\n", "    ", "'''\n        Compute fast non dominated sorting: \n            Deb K, Pratap A, Agarwal S, et al. \n            A fast and elitist multiobjective genetic algorithm: NSGA-II. \n            IEEE transactions on Evolutionary Computation, 2002, 6(2): 182-197.\n        args:\n            param:    p_pop             population\n            param:    OPTIMIZATION      takes 'MIN' or MAX\n        return:  nondominated sorted sets - font 0 to ...\n    '''", "\n", "no_objectives", "=", "len", "(", "P", "[", "0", "]", ".", "mCost", ")", "\n", "# initilize NULL set that will hold all solutions that dominate a solution p in P", "\n", "S", "=", "[", "[", "]", "for", "i", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", "]", "# Empty/NULL set", "\n", "front", "=", "[", "[", "]", "]", "# Initilize Empty Font sets", "\n", "\n", "# DOMINATION COUNT:", "\n", "# the number of solutions which dominates the soultion p in P", "\n", "n", "=", "[", "0", "for", "i", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", "]", "#  Initilize to zero :  ", "\n", "\n", "rank", "=", "[", "0", "for", "i", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", "]", "#  Initilize rank to zero", "\n", "\n", "# for each p in P", "\n", "for", "p", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", ":", "\n", "        ", "S", "[", "p", "]", "=", "[", "]", "# set of solutions (qs) that are dominated by p in P", "\n", "n", "[", "p", "]", "=", "0", "# the number of solutions (number of qs) which dominates the soultion p in P", "\n", "# for each q in P ", "\n", "for", "q", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", ":", "\n", "\n", "            ", "dom_less", ",", "dom_equl", ",", "dom_more", "=", "0", ",", "0", ",", "0", "\n", "for", "k", "in", "range", "(", "0", ",", "no_objectives", ")", ":", "\n", "# count all objectives for which p's value is LOWER than q's values", "\n", "                ", "if", "(", "P", "[", "p", "]", ".", "mCost", "[", "k", "]", "<", "P", "[", "q", "]", ".", "mCost", "[", "k", "]", ")", ":", "\n", "                    ", "dom_less", "+=", "1", "# p dominates", "\n", "# count all objectives for which p's value is EQUAL to than q's values", "\n", "", "if", "(", "P", "[", "p", "]", ".", "mCost", "[", "k", "]", "==", "P", "[", "q", "]", ".", "mCost", "[", "k", "]", ")", ":", "\n", "                    ", "dom_equl", "+=", "1", "# drwa between p and q", "\n", "# count all objectives for which p's value is HIGHER than q's values", "\n", "", "if", "(", "P", "[", "p", "]", ".", "mCost", "[", "k", "]", ">", "P", "[", "q", "]", ".", "mCost", "[", "k", "]", ")", ":", "\n", "                    ", "dom_more", "+=", "1", "# q dominates", "\n", "\n", "", "", "if", "(", "OPTIMIZATION", "==", "'MIN'", ")", ":", "\n", "# dom_more == 0 means that we could not find for any objective for which p has a HIGHER value than q", "\n", "# atleast for one or objectives p has a LOWER obj values than q, hence p (wins) dominates q", "\n", "                ", "p_dominats_q", "=", "dom_more", "\n", "# For minimization search for dom_less == 0 means we could not find any objective for which p has LOWER value tha q ", "\n", "# i.e., atlease for one or more objective p has HIGHER values than q, hence q (wins) dominats", "\n", "p_dominated_by_q", "=", "dom_less", "\n", "\n", "", "if", "(", "OPTIMIZATION", "==", "'MAX'", ")", ":", "\n", "# dom_less == 0 means that we could not find for any objective for which p has a LOWER value than q", "\n", "# atleast for one or objectives p has a HIGHER obj values than q, hence p (wins) dominates q", "\n", "                ", "p_dominats_q", "=", "dom_less", "\n", "# For minimization search for dom_less == 0 means we could not find any objective for which p has HIGHER value tha q ", "\n", "# i.e., atlease for one or more objective p has LOWER values than q, hence q (wins) dominats", "\n", "p_dominated_by_q", "=", "dom_more", "\n", "\n", "\n", "\n", "# set of solutions (qs) dominated by p", "\n", "", "if", "(", "p_dominats_q", "==", "0", "and", "dom_equl", "!=", "no_objectives", ")", ":", "\n", "# Add q to the set of solution dominated by p", "\n", "                ", "if", "q", "not", "in", "S", "[", "p", "]", ":", "\n", "                    ", "S", "[", "p", "]", ".", "append", "(", "q", ")", "\n", "#the number of solutions (number of qs) which dominates the soultion p in P", "\n", "", "", "if", "(", "p_dominated_by_q", "==", "0", "and", "dom_equl", "!=", "no_objectives", ")", ":", "\n", "# q dominates p ", "\n", "                ", "n", "[", "p", "]", "=", "n", "[", "p", "]", "+", "1", "#  increament the counter of p for p dominated by qs ", "\n", "#END of K", "\n", "\n", "# check if p belongs to first front", "\n", "", "", "if", "n", "[", "p", "]", "==", "0", ":", "\n", "            ", "rank", "[", "p", "]", "=", "0", "\n", "if", "p", "not", "in", "front", "[", "0", "]", ":", "\n", "                ", "front", "[", "0", "]", ".", "append", "(", "p", ")", "\n", "\n", "", "", "", "i", "=", "0", "# initilize forn counter", "\n", "# while font is not NULL", "\n", "while", "(", "front", "[", "i", "]", "!=", "[", "]", ")", ":", "\n", "        ", "Q", "=", "[", "]", "\n", "for", "p", "in", "front", "[", "i", "]", ":", "\n", "            ", "for", "q", "in", "S", "[", "p", "]", ":", "\n", "                ", "n", "[", "q", "]", "=", "n", "[", "q", "]", "-", "1", "\n", "if", "(", "n", "[", "q", "]", "==", "0", ")", ":", "\n", "                    ", "rank", "[", "q", "]", "=", "i", "+", "1", "\n", "if", "q", "not", "in", "Q", ":", "\n", "                        ", "Q", ".", "append", "(", "q", ")", "\n", "", "", "", "", "i", "=", "i", "+", "1", "\n", "front", ".", "append", "(", "Q", ")", "\n", "\n", "", "del", "front", "[", "len", "(", "front", ")", "-", "1", "]", "\n", "\n", "for", "p", "in", "range", "(", "0", ",", "len", "(", "P", ")", ")", ":", "\n", "        ", "P", "[", "p", "]", ".", "mDominationSet", "=", "S", "[", "p", "]", "\n", "P", "[", "p", "]", ".", "mDominatedCount", "=", "n", "[", "p", "]", "\n", "P", "[", "p", "]", ".", "mRank", "=", "rank", "[", "p", "]", "\n", "\n", "", "return", "P", ",", "front", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.normalizePopulation": [[10, 51], ["normalizePopulation.updateIdealPoint", "normalizePopulation.performScalarizing", "range", "range", "nfp.append", "normalizePopulation.findHyperplaneIntercepts", "normalizePopulation.maxInObjectives", "len", "len", "numpy.divide().tolist", "numpy.subtract().tolist", "normalizePopulation.maxInObjectives", "numpy.divide", "numpy.subtract", "numpy.asanyarray"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.updateIdealPoint", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.performScalarizing", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.findHyperplaneIntercepts", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.maxInObjectives", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.maxInObjectives"], ["def", "normalizePopulation", "(", "pPopulation", ",", "pParams", ")", ":", "\n", "    ", "'''\n        Normalkization of the population\n        args:\n            param:    pPopulation       population  informations\n            param:    pParams           set of referncepoints parameters\n        return:  normailizaed population\n    '''", "\n", "# Computer ideal points, i,e. Zmin_i for i = 1 to M objectives", "\n", "pParams", ".", "zmin", "=", "updateIdealPoint", "(", "pPopulation", ",", "pParams", ".", "zmin", ")", "\n", "\n", "# Transplate objectives, i.e. objective_values_i - zmin_i , for i = 1 to M objectives", "\n", "nfp", "=", "[", "]", "# list of list ", "\n", "for", "pop", "in", "pPopulation", ":", "\n", "        ", "nfp", ".", "append", "(", "np", ".", "subtract", "(", "pop", ".", "mCost", ",", "pParams", ".", "zmin", ")", ".", "tolist", "(", ")", ")", "\n", "\n", "# Computer extream points, i.e., Zmax_i for i = 1 to M objectives, ", "\n", "", "pParams", "=", "performScalarizing", "(", "nfp", ",", "pParams", ")", "\n", "\n", "# Computer intercepts a_i", "\n", "nInterceptFound", "=", "True", "\n", "try", ":", "\n", "        ", "nZnadir_point", "=", "findHyperplaneIntercepts", "(", "pParams", ".", "zmax", ",", "pParams", ".", "zmin", ")", "\n", "", "except", ":", "\n", "        ", "nInterceptFound", "=", "False", "\n", "\n", "# if no nZnadir_point found , fall back to worst objective  ", "\n", "", "if", "not", "nInterceptFound", ":", "\n", "        ", "nZnadir_point", "=", "maxInObjectives", "(", "pPopulation", ")", "\n", "\n", "# nZnadir_point must be significantly larger in each objective ", "\n", "", "epsilin_ndir", "=", "10", "**", "-", "6", "\n", "for", "i", "in", "range", "(", "len", "(", "nZnadir_point", ")", ")", ":", "\n", "        ", "if", "nZnadir_point", "[", "i", "]", "-", "pParams", ".", "zmin", "[", "i", "]", "<", "epsilin_ndir", ":", "\n", "            ", "nZnadir_point", "[", "i", "]", "=", "maxInObjectives", "(", "pPopulation", ")", "[", "i", "]", "\n", "\n", "# Normalize objectives by deviding translated objectives by intercept a_i", "\n", "", "", "for", "i", "in", "range", "(", "len", "(", "pPopulation", ")", ")", ":", "\n", "        ", "pPopulation", "[", "i", "]", ".", "mNormalizedCost", "=", "np", ".", "divide", "(", "np", ".", "asanyarray", "(", "nfp", "[", "i", "]", ")", ",", "nZnadir_point", ")", ".", "tolist", "(", ")", "\n", "\n", "", "return", "pPopulation", ",", "pParams", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.updateIdealPoint": [[52, 68], ["len", "numpy.minimum().tolist", "range", "numpy.minimum", "len"], "function", ["None"], ["", "def", "updateIdealPoint", "(", "pPopulation", ",", "pPrevZmin", ")", ":", "\n", "    ", "'''\n        Updateing ideal points for the refernce - which is the minimum cost of all \n        args:\n            param:    pPopulation       population  informations\n            param:    pPrevZmin         previous referncepoint mean\n        return:  reference point mean\n    '''", "\n", "if", "len", "(", "pPrevZmin", ")", "==", "0", ":", "\n", "        ", "pPrevZmin", "=", "[", "np", ".", "Inf", "for", "j", "in", "range", "(", "len", "(", "pPopulation", "[", "0", "]", ".", "mCost", ")", ")", "]", "# assign inf to each obj functions", "\n", "\n", "", "nZmin", "=", "pPrevZmin", "\n", "for", "pop", "in", "pPopulation", ":", "\n", "        ", "nZmin", "=", "np", ".", "minimum", "(", "nZmin", ",", "pop", ".", "mCost", ")", ".", "tolist", "(", ")", "\n", "\n", "", "return", "nZmin", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.performScalarizing": [[69, 103], ["len", "range", "len", "numpy.zeros().tolist", "normalizePopulation.getScalarizingVector", "min", "s.index", "s.append", "numpy.zeros", "range", "numpy.max", "numpy.divide"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.getScalarizingVector"], ["", "def", "performScalarizing", "(", "pfp", ",", "pParams", ")", ":", "\n", "    ", "'''\n    perfromaing scalrization\n    Args: \n        pfp: translated objective values\n        pParam:  contains zmean and slo used to retun zmax (extrem points)\n        return pParam (Zmax and smin)\n    '''", "\n", "nObj", "=", "len", "(", "pfp", "[", "0", "]", ")", "# number of objectives", "\n", "\n", "if", "len", "(", "pParams", ".", "smin", ")", "!=", "0", ":", "\n", "        ", "zmax", "=", "pParams", ".", "zmax", "\n", "smin", "=", "pParams", ".", "smin", "\n", "", "else", ":", "\n", "        ", "zmax", "=", "np", ".", "zeros", "(", "(", "nObj", ",", "nObj", ")", ")", ".", "tolist", "(", ")", "\n", "smin", "=", "[", "np", ".", "Inf", "for", "j", "in", "range", "(", "nObj", ")", "]", "\n", "\n", "", "for", "j", "in", "range", "(", "nObj", ")", ":", "\n", "        ", "w", "=", "getScalarizingVector", "(", "nObj", ",", "j", ")", "\n", "s", "=", "[", "]", "\n", "for", "fpVector", "in", "pfp", ":", "\n", "            ", "s", ".", "append", "(", "np", ".", "max", "(", "np", ".", "divide", "(", "fpVector", ",", "w", ")", ")", ")", "\n", "\n", "", "sminj", "=", "min", "(", "s", ")", "\n", "indxOfsmin", "=", "s", ".", "index", "(", "sminj", ")", "\n", "\n", "if", "sminj", "<", "smin", "[", "j", "]", ":", "\n", "            ", "zmax", "[", "j", "]", "=", "pfp", "[", "indxOfsmin", "]", "\n", "smin", "[", "j", "]", "=", "sminj", "\n", "\n", "", "", "pParams", ".", "zmax", "=", "zmax", "\n", "pParams", ".", "smin", "=", "smin", "\n", "\n", "return", "pParams", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.getScalarizingVector": [[105, 118], ["numpy.ones"], "function", ["None"], ["", "def", "getScalarizingVector", "(", "p_obj", ",", "p_index_j", ")", ":", "\n", "    ", "'''\n        Scalrized vectotr\n        args:\n            param:    p_obj          number of objectives\n            param:    p_index_j      the index to be scalarized\n        return sclarized vector\n    '''", "\n", "epsilon", "=", "10", "**", "-", "10", "\n", "w", "=", "(", "epsilon", "*", "np", ".", "ones", "(", "p_obj", ")", ")", ".", "tolist", "(", ")", "\n", "w", "[", "p_index_j", "]", "=", "1", "\n", "\n", "return", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.findHyperplaneIntercepts": [[119, 130], ["numpy.asmatrix", "numpy.ones", "numpy.linalg.inv", "numpy.dot", "numpy.asarray().flatten", "numpy.add", "numpy.asarray", "numpy.divide"], "function", ["None"], ["", "def", "findHyperplaneIntercepts", "(", "zmax", ",", "zmin", ")", ":", "\n", "    ", "'''\n        Computing hyperplane intercepts\n    '''", "\n", "zmax", "=", "np", ".", "asmatrix", "(", "zmax", ")", "\n", "ones", "=", "np", ".", "ones", "(", "zmax", ".", "shape", "[", "1", "]", ")", "\n", "zmaxInvs", "=", "np", ".", "linalg", ".", "inv", "(", "zmax", ")", "\n", "plane", "=", "np", ".", "dot", "(", "ones", ",", "zmaxInvs", ")", "\n", "intercept", "=", "np", ".", "asarray", "(", "np", ".", "divide", "(", "1", ",", "plane", ")", ")", ".", "flatten", "(", ")", "\n", "znadir", "=", "np", ".", "add", "(", "intercept", ",", "zmin", ")", "\n", "return", "znadir", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.normalizePopulation.maxInObjectives": [[132, 144], ["numpy.maximum().tolist", "range", "len", "numpy.maximum"], "function", ["None"], ["", "def", "maxInObjectives", "(", "pPopulation", ")", ":", "\n", "    ", "'''\n        Updateing ideal points for the refernce - which is the minimum cost of all \n        args:\n            param:    pPopulation       population  informations\n            param:    pPrevZmin         previous referncepoint mean\n        return:  maximum in objective\n    '''", "\n", "nMaxInObj", "=", "[", "0", "for", "j", "in", "range", "(", "len", "(", "pPopulation", "[", "0", "]", ".", "mCost", ")", ")", "]", "# assign inf to each obj functions", "\n", "for", "pop", "in", "pPopulation", ":", "\n", "        ", "nMaxInObj", "=", "np", ".", "maximum", "(", "nMaxInObj", ",", "pop", ".", "mCost", ")", ".", "tolist", "(", ")", "\n", "", "return", "nMaxInObj", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.params.Params.__init__": [[18, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pPop", ",", "pZr", ",", "pnZr", ",", "pZmin", ",", "pZmax", ",", "pSmin", ")", ":", "\n", "        ", "self", ".", "nPop", "=", "pPop", "\n", "self", ".", "Zr", "=", "pZr", "\n", "self", ".", "nZr", "=", "pnZr", "\n", "self", ".", "zmin", "=", "pZmin", "\n", "self", ".", "zmax", "=", "pZmax", "\n", "self", ".", "smin", "=", "pSmin", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nsgp_iii.NSGPIII.__init__": [[63, 87], ["round", "src.optimization.structure.individual.Individual", "round"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ")", ":", "\n", "        ", "'''\n            Setting param for nsgp to run\n        '''", "\n", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "\n", "# optimization type minimization and maximization", "\n", "self", ".", "mOptimization", "=", "self", ".", "mParams", ".", "n_optimization", "\n", "# Setup for Number of objectives in the test functions              ", "\n", "\n", "# NSGA    Parameter setting", "\n", "self", ".", "mDivision", "=", "self", ".", "mParams", ".", "n_division", "#  number of division/sprade of the points between 0 and 1 for an objective function ", "\n", "self", ".", "mMaxIt", "=", "self", ".", "mParams", ".", "n_max_itrations", "# Maximum Number of Iterations", "\n", "self", ".", "mPop", "=", "self", ".", "mParams", ".", "n_max_population", "# Population Size", "\n", "\n", "self", ".", "pCrossover", "=", "self", ".", "mParams", ".", "n_prob_crossover", "# Crossover Percentage", "\n", "self", ".", "mCrossover", "=", "2", "*", "round", "(", "self", ".", "pCrossover", "*", "self", ".", "mPop", "/", "2", ")", "# Number of Parnets (Offsprings)", "\n", "self", ".", "pMutation", "=", "1.0", "-", "self", ".", "pCrossover", "# Mutation Percentage", "\n", "self", ".", "mMutation", "=", "round", "(", "self", ".", "pMutation", "*", "self", ".", "mPop", ")", "# Number of Mutants", "\n", "\n", "self", ".", "mBestIndividual", "=", "Individual", "(", ")", "\n", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "", "def", "start", "(", "self", ",", "directory", ",", "trail", ")", ":", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nsgp_iii.NSGPIII.start": [[87, 114], ["src.optimization.structure.nsgpiii.generateReferencePoints.generateReferencePoints", "src.optimization.structure.nsgpiii.params.Params", "nsgp_iii.NSGPIII.setBestTree", "nsgp_iii.NSGPIII.performance_record.append", "src.optimization.structure.nsgpiii.sortAndSelectPopulation.sortAndSelectPopulation", "nsgp_iii.NSGPIII.nsgpLoop", "src.optimization.structure.individual.Individual", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.cost_functions.costFunction", "range", "sort_by_values", "range", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.generateReferencePoints.generateReferencePoints", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.sortAndSelectPopulation.sortAndSelectPopulation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nsgp_iii.NSGPIII.nsgpLoop", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values"], ["", "def", "start", "(", "self", ",", "directory", ",", "trail", ")", ":", "\n", "\n", "        ", "'''\n            Initilization\n        '''", "\n", "# Generating initial refernce points systmaticaly", "\n", "mZr", "=", "generateReferencePoints", "(", "self", ".", "mParams", ".", "n_max_objectives", ",", "self", ".", "mDivision", ")", "#  tested OK      ", "\n", "# collecting and initilizing reference points values ", "\n", "self", ".", "cParams", "=", "Params", "(", "self", ".", "mPop", ",", "mZr", ",", "mZr", ".", "shape", "[", "1", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", ")", "\n", "\n", "# Creating initial populations", "\n", "self", ".", "mPopulation", "=", "[", "Individual", "(", ")", "for", "i", "in", "range", "(", "0", ",", "self", ".", "mPop", ")", "]", "# Empty population", "\n", "# Generating population fron a unifiorm distribution", "\n", "for", "pop", "in", "self", ".", "mPopulation", ":", "\n", "            ", "n_tree", "=", "NeuralTree", "(", ")", "#  initating a class of tree", "\n", "n_tree", ".", "genrateGenericRandomTree", "(", "self", ".", "mParams", ")", "\n", "pop", ".", "mTree", "=", "n_tree", "\n", "pop", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "pop", ".", "mTree", ")", "\n", "\n", "# 1c. Sortining of the population according to their approximation error/ classifcation error", "\n", "", "self", ".", "mPopulation", "=", "[", "self", ".", "mPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "self", ".", "mPopulation", "]", ")", "]", "\n", "\n", "self", ".", "setBestTree", "(", "self", ".", "mPopulation", "[", "0", "]", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "self", ".", "mBestIndividual", ".", "mTree", ",", "2", ",", "False", ")", ")", "\n", "\n", "self", ".", "mPopulation", ",", "self", ".", "mF", ",", "self", ".", "cParams", "=", "sortAndSelectPopulation", "(", "self", ".", "mPopulation", ",", "self", ".", "cParams", ",", "self", ".", "mOptimization", ")", "\n", "return", "self", ".", "nsgpLoop", "(", "directory", ",", "trail", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nsgp_iii.NSGPIII.nsgpLoop": [[116, 204], ["int", "range", "src.optimization.structure.misc.preserve_diversity", "src.optimization.structure.nsgpiii.sortAndSelectPopulation.sortAndSelectPopulation", "nsgp_iii.NSGPIII.setBestTree", "nsgp_iii.NSGPIII.performance_record.append", "src.reporting.plots.plotParetoFront", "src.reporting.plots.plotParetoFront", "src.reporting.plots.saveGPIteration", "len", "src.optimization.structure.individual.Individual", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "src.optimization.structure.cost_functions.costFunction", "nsgp_iii.NSGPIII.mPopulation.append", "copy.deepcopy", "len", "src.optimization.structure.genetic_operators.GeneticOperator", "src.optimization.structure.cost_functions.costFunction", "int", "src.reporting.plots.saveGPIteration", "range", "random.randint", "random.randint", "copy.deepcopy", "copy.deepcopy", "src.optimization.structure.genetic_operators.GeneticOperator.crossoverTree", "random.randint", "copy.deepcopy", "src.optimization.structure.genetic_operators.GeneticOperator.mutation", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "numpy.mod", "str", "len", "random.random", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "round", "sort_by_values", "range", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.preserve_diversity", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.sortAndSelectPopulation.sortAndSelectPopulation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotParetoFront", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotParetoFront", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.crossoverTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values"], ["", "def", "nsgpLoop", "(", "self", ",", "directory", ",", "trail", ")", ":", "\n", "        ", "'''\n            Loop through genetic process\n        '''", "\n", "save_interval", "=", "int", "(", "self", ".", "mMaxIt", "*", "0.1", ")", "\n", "for", "itr", "in", "range", "(", "self", ".", "mMaxIt", ")", ":", "\n", "            ", "self", ".", "mPopulation", "=", "preserve_diversity", "(", "self", ".", "mPopulation", ",", "self", ".", "mPop", ")", "\n", "#print(' # diverse inds = ', len(self.mPopulation), end=' ')", "\n", "#generate new individuals if number of diverse individuals less than total population size", "\n", "while", "(", "len", "(", "self", ".", "mPopulation", ")", "<", "self", ".", "mPop", ")", ":", "\n", "                ", "ind", "=", "Individual", "(", ")", "\n", "n_tree", "=", "NeuralTree", "(", ")", "#  initating a class of tree", "\n", "n_tree", ".", "genrateGenericRandomTree", "(", "self", ".", "mParams", ")", "\n", "ind", ".", "mTree", "=", "n_tree", "\n", "ind", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "ind", ".", "mTree", ",", "2", ")", "#  1 for one objetive", "\n", "self", ".", "mPopulation", ".", "append", "(", "ind", ")", "\n", "\n", "#STEP 2: Generating offsprings ---------------------------------------------------------------------", "\n", "# 2a. copy population in to itrPopulation", "\n", "", "itrPopulation", "=", "[", "copy", ".", "deepcopy", "(", "self", ".", "mPopulation", "[", "i", "]", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mPopulation", ")", ")", "]", "\n", "countCorssover", ",", "countMutation", "=", "0", ",", "0", "\n", "while", "(", "len", "(", "itrPopulation", ")", "<", "2", "*", "self", ".", "mPop", ")", ":", "\n", "# 2b. creating reference for crossopver and mutation oprators", "\n", "                ", "operator", "=", "GeneticOperator", "(", "self", ".", "mParams", ")", "\n", "if", "self", ".", "mParams", ".", "n_prob_crossover", "/", "2.0", "<", "random", ".", "random", "(", ")", "and", "countCorssover", "<", "2", "*", "round", "(", "self", ".", "mParams", ".", "n_prob_crossover", "*", "self", ".", "mPop", "/", "2", ")", ":", "\n", "# CROSSOVER OPERATION", "\n", "#print('crossover')", "\n", "                    ", "p1", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "mPop", "-", "1", ")", "\n", "p2", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "mPop", "-", "1", ")", "\n", "\n", "nParentTree1", "=", "copy", ".", "deepcopy", "(", "self", ".", "mPopulation", "[", "p1", "]", ".", "mTree", ")", "\n", "nParentTree2", "=", "copy", ".", "deepcopy", "(", "self", ".", "mPopulation", "[", "p2", "]", ".", "mTree", ")", "\n", "\n", "firstTree", ",", "secondTree", ",", "is_crossover_done", "=", "operator", ".", "crossoverTree", "(", "nParentTree1", ",", "nParentTree2", ")", "\n", "if", "is_crossover_done", ":", "\n", "                        ", "child1", "=", "Individual", "(", ")", "\n", "child1", ".", "mTree", "=", "firstTree", "\n", "child1", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child1", ".", "mTree", ",", "2", ")", "\n", "itrPopulation", ".", "append", "(", "child1", ")", "\n", "\n", "child2", "=", "Individual", "(", ")", "\n", "child2", ".", "mTree", "=", "secondTree", "\n", "child2", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child2", ".", "mTree", ",", "2", ")", "\n", "itrPopulation", ".", "append", "(", "child2", ")", "\n", "countCorssover", "+=", "2", "\n", "# just for cleaning up -  not necessary", "\n", "del", "nParentTree1", ",", "nParentTree2", ",", "firstTree", ",", "secondTree", ",", "child1", ",", "child2", "\n", "", "", "else", ":", "\n", "# MUTATION OPEARATION", "\n", "#print('mutation')", "\n", "                    ", "p1", "=", "random", ".", "randint", "(", "0", ",", "self", ".", "mPop", "-", "1", ")", "\n", "nParentTree", "=", "copy", ".", "deepcopy", "(", "self", ".", "mPopulation", "[", "p1", "]", ".", "mTree", ")", "\n", "m_tree", "=", "operator", ".", "mutation", "(", "nParentTree", ")", "\n", "child", "=", "Individual", "(", ")", "\n", "child", ".", "mTree", "=", "m_tree", "\n", "child", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child", ".", "mTree", ",", "2", ")", "\n", "itrPopulation", ".", "append", "(", "child", ")", "\n", "countMutation", "+=", "1", "\n", "#Generating offsprings END---------------------------------------------------------------------", "\n", "# SAVE - all populaion and for post processing", "\n", "", "", "self", ".", "mPopulation", ",", "self", ".", "mF", ",", "self", ".", "cParams", "=", "sortAndSelectPopulation", "(", "itrPopulation", ",", "self", ".", "cParams", ",", "self", ".", "mOptimization", ")", "\n", "# Iteration Information", "\n", "#print('Iteration ', itr,' Number of F1 Members = ', len(self.mF[0]))", "\n", "#for f in self.mF[0]:", "\n", "#print([self.mPopulation[f].mCost[0],self.mPopulation[f].mCost[1]], end=' ')", "\n", "#print('\\n')", "\n", "print_best", "=", "self", ".", "setBestTree", "(", "[", "self", ".", "mPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "mPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "self", ".", "mPopulation", "]", ")", "]", "[", "0", "]", ",", "itr", "+", "1", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "self", ".", "mBestIndividual", ".", "mTree", ",", "2", ",", "False", ")", ")", "\n", "#if(int(np.mod(itr,10)) == 0) and not print_best:", "\n", "#    print('GP Itr', itr+1, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),']')", "\n", "if", "(", "int", "(", "np", ".", "mod", "(", "itr", ",", "save_interval", ")", ")", "==", "0", ")", ":", "#if Save Itration = True", "\n", "                ", "saveGPIteration", "(", "self", ".", "mPopulation", ",", "directory", ",", "trail", ",", "str", "(", "itr", ")", ",", "'nsgp_3_'", ")", "\n", "\n", "#Ploting the last front", "\n", "", "", "if", "True", ":", "# plotFinal = True ", "\n", "# ploting only the font", "\n", "            ", "x", "=", "[", "self", ".", "mPopulation", "[", "popIndex", "]", ".", "mCost", "[", "0", "]", "for", "popIndex", "in", "self", ".", "mF", "[", "0", "]", "]", "\n", "y", "=", "[", "self", ".", "mPopulation", "[", "popIndex", "]", ".", "mCost", "[", "1", "]", "for", "popIndex", "in", "self", ".", "mF", "[", "0", "]", "]", "\n", "plotParetoFront", "(", "x", ",", "y", ",", "directory", ",", "trail", ",", "'nsgp_3_'", ",", "'treeParetoFront_'", ")", "\n", "# ploting the whole population", "\n", "x", "=", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "self", ".", "mPopulation", "]", "\n", "y", "=", "[", "pop", ".", "mCost", "[", "1", "]", "for", "pop", "in", "self", ".", "mPopulation", "]", "\n", "plotParetoFront", "(", "x", ",", "y", ",", "directory", ",", "trail", ",", "'nsgp_3_'", ")", "\n", "saveGPIteration", "(", "self", ".", "mPopulation", ",", "directory", ",", "trail", ",", "'final'", ",", "'nsgp_3_'", ")", "\n", "\n", "\n", "\n", "", "return", "self", ".", "mBestIndividual", ".", "mTree", ",", "self", ".", "mPopulation", ",", "self", ".", "performance_record", "# returning the best tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.nsgpiii.nsgp_iii.NSGPIII.setBestTree": [[205, 231], ["nsgp_iii.NSGPIII.mBestIndividual.mTree.getTreeSize", "pIndividual.mTree.getTreeSize"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "def", "setBestTree", "(", "self", ",", "pIndividual", ",", "itr", "=", "0", ")", ":", "\n", "        ", "'''\n            Compare the current individial tree with the best Tree found so far\n            arges:\n                param:  pIndividual  an individual tree\n        '''", "\n", "print_best", "=", "False", "\n", "if", "self", ".", "mBestIndividual", ".", "mTree", "==", "None", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "", "if", "self", ".", "mBestIndividual", ".", "mCost", "[", "0", "]", ">", "pIndividual", ".", "mCost", "[", "0", "]", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "", "if", "self", ".", "mBestIndividual", ".", "mCost", "[", "0", "]", "==", "pIndividual", ".", "mCost", "[", "0", "]", "and", "self", ".", "mBestIndividual", ".", "mTree", ".", "getTreeSize", "(", ")", ">", "pIndividual", ".", "mTree", ".", "getTreeSize", "(", ")", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "#if print_best:", "\n", "#    print('GP Itr', itr, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),'] this is new best')", "\n", "\n", "", "return", "print_best", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.__init__": [[32, 40], ["src.optimization.structure.individual.Individual"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "pEvaluateTree", ",", "pParams", ")", ":", "\n", "        ", "'''\n            Setting param for nsgp to run\n        '''", "\n", "self", ".", "mEvaluateTree", "=", "pEvaluateTree", "\n", "self", ".", "mParams", "=", "pParams", "\n", "self", ".", "mBestIndividual", "=", "Individual", "(", ")", "\n", "self", ".", "performance_record", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start": [[42, 149], ["print", "gp.GP.setBestTree", "gp.GP.performance_record.append", "src.optimization.structure.individual.Individual", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.misc.preserve_diversity", "gp.GP.setBestTree", "gp.GP.performance_record.append", "src.reporting.plots.plotParetoFront", "src.reporting.plots.saveGPIteration", "range", "sort_by_values", "copy.deepcopy", "len", "src.optimization.structure.genetic_operators.GeneticOperator", "len", "src.optimization.structure.individual.Individual", "src.tree.neural_tree.NeuralTree", "src.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "src.optimization.structure.cost_functions.costFunction", "src.optimization.structure.misc.preserve_diversity.append", "copy.deepcopy", "src.optimization.structure.cost_functions.costFunction", "src.reporting.plots.saveGPIteration", "nPopulation[].mTree.getTreeSize", "range", "random.randint", "random.randint", "copy.deepcopy", "copy.deepcopy", "src.optimization.structure.genetic_operators.GeneticOperator.crossoverTree", "random.randint", "copy.deepcopy", "src.optimization.structure.genetic_operators.GeneticOperator.mutation", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "range", "sort_by_values", "str", "range", "range", "len", "random.random", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "src.optimization.structure.individual.Individual", "src.optimization.structure.cost_functions.costFunction", "itrPopulation.append", "len", "len", "range", "round", "len", "range", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.preserve_diversity", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.plotParetoFront", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.plots.saveGPIteration", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.crossoverTree", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.genetic_operators.GeneticOperator.mutation", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.misc.sort_by_values", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.structure.cost_functions.costFunction"], ["", "def", "start", "(", "self", ",", "directory", ",", "trail", ")", ":", "\n", "\n", "        ", "pop_size", "=", "self", ".", "mParams", ".", "n_max_population", "\n", "\n", "print", "(", "'GP initial population: Tree index [Error, Size]'", ")", "\n", "# STEP 1: INITIALIZE POPULATION -------------------------------------------------------------------------", "\n", "# 1a. Empty individuals - population is a objeect of individuals", "\n", "nPopulation", "=", "[", "Individual", "(", ")", "for", "i", "in", "range", "(", "0", ",", "pop_size", ")", "]", "# Empty population", "\n", "# 1b. Create individual tree and evaluate fitness of each individual tree", "\n", "for", "pop", "in", "nPopulation", ":", "\n", "            ", "n_tree", "=", "NeuralTree", "(", ")", "#  initating a class of tree", "\n", "n_tree", ".", "genrateGenericRandomTree", "(", "self", ".", "mParams", ")", "\n", "pop", ".", "mTree", "=", "n_tree", "\n", "pop", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "pop", ".", "mTree", ",", "1", ")", "#  2 for two objetive", "\n", "#print('Tree', nPopulation.index(pop), '[',round(pop.mCost[0], 2), pop.mTree.getTreeSize(),']')", "\n", "# 1c. Sortining of the population according to their approximation error/ classifcation error", "\n", "", "nPopulation", "=", "[", "nPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "nPopulation", "]", ")", "]", "\n", "#print('\\nInitial sorted population: Tree index [Error Size]')", "\n", "#for pop in nPopulation:", "\n", "#print('Tree', nPopulation.index(pop), '[',round(pop.mCost[0], 2), pop.mTree.getTreeSize(),']')", "\n", "\n", "self", ".", "setBestTree", "(", "nPopulation", "[", "0", "]", ")", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "self", ".", "mBestIndividual", ".", "mTree", ",", "2", ",", "False", ")", ")", "\n", "\n", "itr", "=", "0", "\n", "while", "(", "itr", "<", "self", ".", "mParams", ".", "n_max_itrations", ")", ":", "\n", "#STEP 2: Generating offsprings ---------------------------------------------------------------------", "\n", "# 2a. copy population in to itrPopulation", "\n", "            ", "itrPopulation", "=", "[", "copy", ".", "deepcopy", "(", "nPopulation", "[", "i", "]", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", "\n", "countCorssover", ",", "countMutation", "=", "0", ",", "0", "\n", "while", "(", "len", "(", "itrPopulation", ")", "<", "2", "*", "pop_size", ")", ":", "\n", "# 2b. creating reference for crossopver and mutation oprators", "\n", "                ", "operator", "=", "GeneticOperator", "(", "self", ".", "mParams", ")", "\n", "if", "self", ".", "mParams", ".", "n_prob_crossover", "/", "2.0", "<", "random", ".", "random", "(", ")", "and", "countCorssover", "<", "2", "*", "round", "(", "self", ".", "mParams", ".", "n_prob_crossover", "*", "pop_size", "/", "2", ")", ":", "\n", "# CROSSOVER OPERATION", "\n", "#print('crossover')", "\n", "                    ", "p1", "=", "random", ".", "randint", "(", "0", ",", "pop_size", "-", "1", ")", "\n", "p2", "=", "random", ".", "randint", "(", "0", ",", "pop_size", "-", "1", ")", "\n", "\n", "nParentTree1", "=", "copy", ".", "deepcopy", "(", "nPopulation", "[", "p1", "]", ".", "mTree", ")", "\n", "nParentTree2", "=", "copy", ".", "deepcopy", "(", "nPopulation", "[", "p2", "]", ".", "mTree", ")", "\n", "\n", "firstTree", ",", "secondTree", ",", "is_crossover_done", "=", "operator", ".", "crossoverTree", "(", "nParentTree1", ",", "nParentTree2", ")", "\n", "if", "is_crossover_done", ":", "\n", "                        ", "child1", "=", "Individual", "(", ")", "\n", "child1", ".", "mTree", "=", "firstTree", "\n", "child1", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child1", ".", "mTree", ",", "1", ")", "\n", "itrPopulation", ".", "append", "(", "child1", ")", "\n", "\n", "child2", "=", "Individual", "(", ")", "\n", "child2", ".", "mTree", "=", "secondTree", "\n", "child2", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child2", ".", "mTree", ",", "1", ")", "\n", "itrPopulation", ".", "append", "(", "child2", ")", "\n", "countCorssover", "+=", "2", "\n", "# just for cleaning up -  not necessary", "\n", "del", "nParentTree1", ",", "nParentTree2", ",", "firstTree", ",", "secondTree", ",", "child1", ",", "child2", "\n", "", "", "else", ":", "\n", "# MUTATION OPEARATION", "\n", "#print('mutation')", "\n", "                    ", "p1", "=", "random", ".", "randint", "(", "0", ",", "pop_size", "-", "1", ")", "\n", "nParentTree", "=", "copy", ".", "deepcopy", "(", "nPopulation", "[", "p1", "]", ".", "mTree", ")", "\n", "m_tree", "=", "operator", ".", "mutation", "(", "nParentTree", ")", "\n", "child", "=", "Individual", "(", ")", "\n", "child", ".", "mTree", "=", "m_tree", "\n", "child", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "child", ".", "mTree", ",", "1", ")", "\n", "itrPopulation", ".", "append", "(", "child", ")", "\n", "countMutation", "+=", "1", "\n", "\n", "#STEP 3:  Mainatain Elitisum and diversity and sorting a pop_size", "\n", "", "", "nDiversePop", "=", "preserve_diversity", "(", "itrPopulation", ",", "pop_size", ")", "\n", "#print(' # diverse inds = ', len(nDiversePop), end=' ')", "\n", "#for pop in nDiversePop:", "\n", "#print('Tree [',round(pop.mCost[0], 2), pop.mTree.getTreeSize(),']')", "\n", "\n", "#generate new individuals if number of diverse individuals less than total population size", "\n", "while", "(", "len", "(", "nDiversePop", ")", "<", "pop_size", ")", ":", "\n", "                ", "ind", "=", "Individual", "(", ")", "\n", "n_tree", "=", "NeuralTree", "(", ")", "#  initating a class of tree", "\n", "n_tree", ".", "genrateGenericRandomTree", "(", "self", ".", "mParams", ")", "\n", "ind", ".", "mTree", "=", "n_tree", "\n", "ind", ".", "mCost", "=", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "ind", ".", "mTree", ",", "1", ")", "#  1 for one objetive", "\n", "nDiversePop", ".", "append", "(", "ind", ")", "\n", "\n", "", "nPopulation", "=", "[", "copy", ".", "deepcopy", "(", "nDiversePop", "[", "i", "]", ")", "for", "i", "in", "range", "(", "0", ",", "pop_size", ")", "]", "\n", "# 3b. Sortining of the current population according to their approximation error/ classifcation error", "\n", "nPopulation", "=", "[", "nPopulation", "[", "i", "]", "for", "i", "in", "sort_by_values", "(", "[", "i", "for", "i", "in", "range", "(", "0", ",", "len", "(", "nPopulation", ")", ")", "]", ",", "[", "pop", ".", "mCost", "[", "0", "]", "for", "pop", "in", "nPopulation", "]", ")", "]", "\n", "print_best", "=", "self", ".", "setBestTree", "(", "nPopulation", "[", "0", "]", ",", "itr", "+", "1", ")", "\n", "itrPopulation", "=", "[", "]", "# reset the iteration population", "\n", "#print(costFunction(self.mEvaluateTree, 'train', self.mBestIndividual.mTree, 2, False))", "\n", "self", ".", "performance_record", ".", "append", "(", "costFunction", "(", "self", ".", "mEvaluateTree", ",", "'train'", ",", "self", ".", "mBestIndividual", ".", "mTree", ",", "2", ",", "False", ")", ")", "\n", "#if(int(np.mod(itr,10)) == 0) and not print_best:", "\n", "#    print('GP Itr', itr+1, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),']')", "\n", "\n", "if", "False", ":", "#if Save Itration = True", "\n", "                ", "saveGPIteration", "(", "nPopulation", ",", "directory", ",", "trail", ",", "str", "(", "itr", ")", ")", "\n", "", "itr", "=", "itr", "+", "1", "\n", "\n", "\n", "#print('GP Itr', itr+1, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),']')", "\n", "", "if", "True", ":", "#plotFinal = True", "\n", "            ", "x", "=", "[", "nPopulation", "[", "i", "]", ".", "mCost", "[", "0", "]", "for", "i", "in", "range", "(", "len", "(", "nPopulation", ")", ")", "]", "\n", "y", "=", "[", "nPopulation", "[", "i", "]", ".", "mTree", ".", "getTreeSize", "(", ")", "for", "i", "in", "range", "(", "len", "(", "nPopulation", ")", ")", "]", "\n", "plotParetoFront", "(", "x", ",", "y", ",", "directory", ",", "trail", ")", "\n", "saveGPIteration", "(", "nPopulation", ",", "directory", ",", "trail", ",", "'final'", ")", "\n", "\n", "# returning the best tree, population, perfromance record for each iteration", "\n", "", "return", "self", ".", "mBestIndividual", ".", "mTree", ",", "nPopulation", ",", "self", ".", "performance_record", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.setBestTree": [[151, 177], ["gp.GP.mBestIndividual.mTree.getTreeSize", "pIndividual.mTree.getTreeSize"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "def", "setBestTree", "(", "self", ",", "pIndividual", ",", "itr", "=", "0", ")", ":", "\n", "        ", "'''\n            Compare the current individial tree with the best Tree found so far\n            arges:\n                param:  pIndividual  an individual tree\n        '''", "\n", "print_best", "=", "False", "\n", "if", "self", ".", "mBestIndividual", ".", "mTree", "==", "None", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "", "if", "self", ".", "mBestIndividual", ".", "mCost", "[", "0", "]", ">", "pIndividual", ".", "mCost", "[", "0", "]", ":", "# and abs(self.mBestIndividual.mCost[0] - pIndividual.mCost[0]) < 0.000001:", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "", "if", "self", ".", "mBestIndividual", ".", "mCost", "[", "0", "]", "==", "pIndividual", ".", "mCost", "[", "0", "]", "and", "self", ".", "mBestIndividual", ".", "mTree", ".", "getTreeSize", "(", ")", ">", "pIndividual", ".", "mTree", ".", "getTreeSize", "(", ")", ":", "\n", "            ", "self", ".", "mBestIndividual", ".", "mTree", "=", "pIndividual", ".", "mTree", "\n", "self", ".", "mBestIndividual", ".", "mCost", "=", "pIndividual", ".", "mCost", "\n", "print_best", "=", "True", "\n", "\n", "#if print_best:", "\n", "#    print('GP Itr', itr, 'best tree [',  round(self.mBestIndividual.mCost[0], 5), self.mBestIndividual.mTree.getTreeSize(),'] this is new best')", "\n", "\n", "", "return", "print_best", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.__init__": [[20, 26], ["print", "argparse.ArgumentParser"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "'''\n            intiate a parser\n        '''", "\n", "print", "(", "'Gatterning paramters...'", ")", "\n", "self", ".", "mParser", "=", "argparse", ".", "ArgumentParser", "(", ")", "# parser accumulats all parametrs ", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setData": [[27, 98], ["setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "print", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "preprocessing.LabelBinarizer", "preprocessing.LabelBinarizer.fit", "preprocessing.LabelBinarizer.transform", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "src.dataloader.data_processing.DataProcessing.normalize_data.astype", "src.dataloader.data_processing.DataProcessing.normalize_data", "int", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "src.dataloader.data_processing.DataProcessing.normalize_data", "numpy.asarray", "int", "numpy.where", "numpy.where"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.normalize_data", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.normalize_data"], ["", "def", "setData", "(", "self", ",", "data_file", ",", "data", ",", "p_problem_type", "=", "'Classification'", ",", "normalize", "=", "[", "0.0", ",", "1.0", "]", ",", "normlize_data", "=", "False", ")", ":", "\n", "        ", "'''\n            Setting data sets parametre\n        '''", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_dataset_name'", ",", "default", "=", "data_file", ",", "type", "=", "str", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_problem_type'", ",", "default", "=", "p_problem_type", ",", "type", "=", "str", ")", "\n", "print", "(", "' --- Preprocessing loded data --- '", ")", "\n", "#Creating/ Setting the imput data Matrix        ", "\n", "# input values data structuer used is -> float64", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_is_data_normlized'", ",", "default", "=", "normlize_data", ",", "type", "=", "bool", ")", "\n", "if", "normlize_data", ":", "\n", "            ", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_norm_min'", ",", "default", "=", "normalize", "[", "0", "]", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_norm_max'", ",", "default", "=", "normalize", "[", "1", "]", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_input_min'", ",", "default", "=", "data", ".", "feature_min", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_input_max'", ",", "default", "=", "data", ".", "feature_max", ",", "type", "=", "float", ")", "\n", "if", "data_file", "==", "\"mnist.csv\"", ":", "\n", "                ", "data_input_values", "=", "data", ".", "data", "\n", "data_input_values", "=", "data_input_values", ".", "astype", "(", "'float32'", ")", "\n", "data_input_values", "/=", "255", "# normalizing by deviding by heighst intensity", "\n", "", "else", ":", "\n", "                ", "data_input_values", "=", "DataProcessing", ".", "normalize_data", "(", "data", ".", "data", ",", "normalize", "[", "0", "]", ",", "normalize", "[", "1", "]", ")", "\n", "", "", "else", ":", "\n", "            ", "data_input_values", "=", "data", ".", "data", "\n", "", "data_input_names", "=", "data", ".", "feature_names", "# input names data structuer is -> list ", "\n", "data_input_attrs", "=", "data_input_values", ".", "shape", "[", "1", "]", "# number of input attributes -> int retirve from columns number of input values", "\n", "\n", "\n", "#setting number of columns (attributes) in the dataset", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_input_values'", ",", "default", "=", "data_input_values", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_input_names'", ",", "default", "=", "data_input_names", ",", "type", "=", "str", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_input_attr'", ",", "default", "=", "int", "(", "data_input_attrs", ")", ",", "type", "=", "int", ")", "\n", "\n", "# preprocessing of the target columns - this should be further  automated ", "\n", "#fetching raw data target", "\n", "data_target_raw", "=", "data", ".", "target", "\n", "if", "(", "p_problem_type", "==", "'Classification'", ")", ":", "\n", "#set the taget names for classification problem", "\n", "            ", "data_traget_names", "=", "data", ".", "target_names", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_target_names'", ",", "default", "=", "data_traget_names", ",", "type", "=", "str", ")", "\n", "\n", "# Creating taget column", "\n", "#Source code:  https://scikit-learn.org/stable/modules/preprocessing_targets.html", "\n", "#print('    --- Class lavel binarization ---')", "\n", "from", "sklearn", "import", "preprocessing", "\n", "le", "=", "preprocessing", ".", "LabelBinarizer", "(", ")", "\n", "le", ".", "fit", "(", "data_target_raw", ")", "\n", "#transform single column target to multicolimn target column ", "\n", "data_target_values", "=", "le", ".", "transform", "(", "data_target_raw", ")", "\n", "#print(data_target_values)", "\n", "if", "(", "data_target_values", ".", "shape", "[", "1", "]", "==", "1", ")", ":", "\n", "#print('Changed label')", "\n", "                ", "data_target_values", "=", "np", ".", "asarray", "(", "[", "np", ".", "where", "(", "data", ".", "target", "==", "0", ",", "1", ",", "0", ")", ",", "np", ".", "where", "(", "data", ".", "target", "==", "1", ",", "1", ",", "0", ")", "]", ")", ".", "T", "\n", "\n", "", "data_traget_attrs", "=", "data_target_values", ".", "shape", "[", "1", "]", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_target_values'", ",", "default", "=", "data_target_values", ",", "type", "=", "float", ")", "\n", "# set the number or of output columns equivalent to number of classes", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_target_attr'", ",", "default", "=", "int", "(", "data_traget_attrs", ")", ",", "type", "=", "int", ")", "\n", "", "else", ":", "\n", "            ", "if", "normlize_data", ":", "\n", "                ", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_target_min'", ",", "default", "=", "data", ".", "target_min", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_target_max'", ",", "default", "=", "data", ".", "target_max", ",", "type", "=", "float", ")", "\n", "data_target_values", "=", "DataProcessing", ".", "normalize_data", "(", "data_target_raw", ",", "normalize", "[", "0", "]", ",", "normalize", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "data_target_values", "=", "data_target_raw", "\n", "\n", "", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_target_values'", ",", "default", "=", "data_target_values", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_data_target_names'", ",", "default", "=", "[", "'output'", "]", ",", "type", "=", "str", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_target_attr'", ",", "default", "=", "1", ",", "type", "=", "int", ")", "\n", "\n", "", "self", ".", "mParser", ".", "add_argument", "(", "'--n_validation_method'", ",", "default", "=", "'holdout'", ",", "type", "=", "str", ",", "choices", "=", "[", "'holdout'", ",", "'holdout_val'", ",", "'k_fold'", ",", "'five_x_two_fold'", "]", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_validation_folds'", ",", "default", "=", "10", ",", "type", "=", "int", ",", "choices", "=", "[", "2", ",", "5", ",", "10", ",", "'...'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setTreeParameters": [[99, 111], ["print", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument"], "methods", ["None"], ["", "def", "setTreeParameters", "(", "self", ")", ":", "\n", "        ", "'''\n            Setting tree paramters\n        '''", "\n", "print", "(", "'Setting tree paramters...'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_children'", ",", "default", "=", "5", ",", "type", "=", "int", ",", "choices", "=", "[", "2", ",", "3", ",", "4", ",", "'...'", "]", ",", "help", "=", "'maximum number of child for a node'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_depth'", ",", "default", "=", "5", ",", "type", "=", "int", ",", "choices", "=", "[", "2", ",", "3", ",", "4", ",", "'...'", "]", ",", "help", "=", "'depth of the tree:'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_weight_range'", ",", "default", "=", "[", "0", ",", "1", "]", ",", "type", "=", "float", ",", "choices", "=", "[", "[", "0", ",", "1", "]", ",", "[", "-", "1", ",", "1", "]", "]", ",", "help", "=", "'tree edge weights and bias range'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_out_fun_type'", ",", "default", "=", "'sigmoid'", ",", "type", "=", "str", ",", "choices", "=", "[", "'Gaussian'", ",", "'tanh'", ",", "'sigmoid'", ",", "'ReLU'", ",", "'softmax'", "]", ",", "help", "=", "'can be same as internam function nodes'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_fun_type'", ",", "default", "=", "'sigmoid'", ",", "type", "=", "str", ",", "choices", "=", "[", "'Gaussian'", ",", "'tanh'", ",", "'sigmoid'", ",", "'ReLU'", ",", "'softmax'", "]", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_fun_range'", ",", "default", "=", "[", "0", ",", "1", "]", ",", "type", "=", "float", ",", "help", "=", "'used for Guassin function only at the moment, center and width range'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_int_leaf_rate'", ",", "default", "=", "0.5", ",", "type", "=", "float", ",", "help", "=", "'leaf genration rate for interna nodes'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setStructureOptimization": [[113, 126], ["print", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument"], "methods", ["None"], ["", "def", "setStructureOptimization", "(", "self", ")", ":", "\n", "        ", "'''\n            Set structuer optimization algorithms\n        '''", "\n", "print", "(", "'Setting structure optimization paramters...'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_itrations'", ",", "default", "=", "10", ",", "type", "=", "int", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_population'", ",", "default", "=", "20", ",", "type", "=", "int", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_algo_structure'", ",", "default", "=", "'gp'", ",", "type", "=", "str", ",", "choices", "=", "[", "'gp'", ",", "'nsgp_2'", ",", "'nsgp_3'", "]", ")", "# ", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_optimization'", ",", "default", "=", "'MIN'", ",", "type", "=", "str", ",", "choices", "=", "[", "'MIN'", ",", "'MAX'", "]", ",", "help", "=", "'minimization porblem -> MIN and otherwise'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_max_objectives'", ",", "default", "=", "2", ",", "type", "=", "int", ",", "help", "=", "'max objective in the problem domain or in the tree itself, eg 2 for tree imples tree erro and tree size'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_division'", ",", "default", "=", "10", ",", "type", "=", "int", ",", "help", "=", "'number p > 0 of reference points for an objective function in NSGA-III algorithm'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_prob_crossover'", ",", "default", "=", "0.8", ",", "type", "=", "float", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_prob_mutation'", ",", "default", "=", "0.2", ",", "type", "=", "float", ",", "help", "=", "'mutation probability is 1 - crossover probability'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setParamterOptimization": [[127, 147], ["print", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument", "setting_params.SettingParamter.mParser.add_argument"], "methods", ["None"], ["", "def", "setParamterOptimization", "(", "self", ",", "optimizar", ")", ":", "\n", "        ", "'''\n            Set algorithms and parameter optimization pareamters\n        '''", "\n", "print", "(", "'Setting weights optimization paramters...'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_param_optimizer'", ",", "default", "=", "optimizar", ",", "choices", "=", "[", "'gd'", ",", "'mh'", "]", ",", "type", "=", "str", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_param_opt_max_itr'", ",", "default", "=", "50", ",", "type", "=", "int", ")", "\n", "if", "optimizar", "==", "'gd'", ":", "\n", "            ", "self", ".", "mParser", ".", "add_argument", "(", "'--n_algo_param'", ",", "default", "=", "'adam'", ",", "type", "=", "str", ",", "choices", "=", "[", "'gd'", ",", "'momentum_gd'", ",", "'nesterov_accelerated_gd'", ",", "'adagrad'", ",", "'rmsprop'", ",", "'adam'", "]", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_eval_mode'", ",", "default", "=", "'stochastic'", ",", "type", "=", "str", ",", "choices", "=", "[", "'batch'", ",", "'stochastic'", "]", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_precision'", ",", "default", "=", "0.00001", ",", "type", "=", "float", ",", "help", "=", "'termonation tolarane'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_eta'", ",", "default", "=", "0.1", ",", "type", "=", "float", ",", "help", "=", "'gradient descent learning rate'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_gamma'", ",", "default", "=", "0.9", ",", "type", "=", "float", ",", "help", "=", "'gradient descent momentum rate'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_eps'", ",", "default", "=", "1e-8", ",", "type", "=", "float", ",", "help", "=", "'gradient epsilon'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_beta'", ",", "default", "=", "0.9", ",", "type", "=", "float", ",", "help", "=", "'gradient beta'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_beta1'", ",", "default", "=", "0.9", ",", "type", "=", "float", ",", "help", "=", "'gradient beta'", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_gd_beta2'", ",", "default", "=", "0.9", ",", "type", "=", "float", ",", "help", "=", "'gradient beta'", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "mParser", ".", "add_argument", "(", "'--n_algo_param'", ",", "default", "=", "'mcs'", ",", "type", "=", "str", ",", "choices", "=", "[", "'mcs'", ",", "'de'", ",", "'sa'", ",", "'bsde'", ",", "'pso'", ",", "'abc'", "]", ")", "\n", "self", ".", "mParser", ".", "add_argument", "(", "'--n_mh_pop_size'", ",", "default", "=", "20", ",", "type", "=", "int", ")", "\n", "#self.mParser.add_argument('--n_mh_algo_de_mut', default =  0.8, type=float, help= 'betweeen 0 and 1')", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.checkParameters": [[151, 201], ["print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print", "print"], "methods", ["None"], ["", "", "def", "checkParameters", "(", "self", ",", "params", ")", ":", "\n", "        ", "print", "(", "'Chaking paramters:'", ")", "\n", "\n", "print", "(", "'Check data: '", ")", "\n", "print", "(", "'  PARAM: problem type          : '", ",", "params", ".", "n_problem_type", ")", "\n", "print", "(", "'  PARAM: exs in instance sapce : '", ",", "params", ".", "n_data_input_values", ".", "shape", "[", "0", "]", ")", "\n", "print", "(", "'  PARAM: max input attributes  : '", ",", "params", ".", "n_max_input_attr", ")", "\n", "print", "(", "'  PARAM: max input attributes  : '", ",", "params", ".", "n_data_input_names", ")", "\n", "print", "(", "'  PARAM: max output attributes : '", ",", "params", ".", "n_max_target_attr", ")", "\n", "print", "(", "'  PARAM: max output attributes : '", ",", "params", ".", "n_data_target_names", ")", "\n", "print", "(", "'  PARAM: max output attributes : '", ",", "params", ".", "n_validation_method", ")", "\n", "print", "(", "'  PARAM: data normalization    : '", ",", "params", ".", "n_is_data_normlized", ")", "\n", "if", "params", ".", "n_is_data_normlized", ":", "\n", "            ", "print", "(", "'  PARAM: norm min              : '", ",", "params", ".", "n_data_norm_min", ")", "\n", "print", "(", "'  PARAM: norm max              : '", ",", "params", ".", "n_data_norm_max", ")", "\n", "print", "(", "'  PARAM: data inputs min       : '", ",", "params", ".", "n_data_input_min", ")", "\n", "print", "(", "'  PARAM: data inputs max       : '", ",", "params", ".", "n_data_input_max", ")", "\n", "if", "params", ".", "n_problem_type", "!=", "'Classification'", ":", "\n", "                ", "print", "(", "'  PARAM: data target min       : '", ",", "params", ".", "n_data_target_min", ")", "\n", "print", "(", "'  PARAM: data target max       : '", ",", "params", ".", "n_data_target_max", ")", "\n", "\n", "\n", "", "", "print", "(", "'\\nCheck Tree paramters:'", ")", "\n", "print", "(", "'  PARAM: max node children     : '", ",", "params", ".", "n_max_children", ")", "\n", "print", "(", "'  PARAM: max tree depth        : '", ",", "params", ".", "n_max_depth", ")", "\n", "print", "(", "'  PARAM: edge weight range     : '", ",", "params", ".", "n_weight_range", ")", "\n", "print", "(", "'  PARAM: node function type    : '", ",", "params", ".", "n_fun_type", ")", "\n", "print", "(", "'  PARAM: func value range      : '", ",", "params", ".", "n_fun_range", ")", "\n", "\n", "print", "(", "'\\nCheck Structur oprimization paramters:'", ")", "\n", "print", "(", "'  PARAM: algo for structure opt: '", ",", "params", ".", "n_algo_structure", ")", "\n", "print", "(", "'  PARAM: optimization type     : '", ",", "params", ".", "n_optimization", ")", "\n", "print", "(", "'  PARAM: max population        : '", ",", "params", ".", "n_max_population", ")", "\n", "print", "(", "'  PARAM: max iterations        : '", ",", "params", ".", "n_max_itrations", ")", "\n", "print", "(", "'  PARAM: max objectives        : '", ",", "params", ".", "n_max_objectives", ")", "\n", "print", "(", "'  PARAM: division of obj       : '", ",", "params", ".", "n_division", ")", "\n", "print", "(", "'  PARAM: crossover probability : '", ",", "params", ".", "n_prob_crossover", ")", "\n", "print", "(", "'  PARAM: mutation probability  : '", ",", "params", ".", "n_prob_mutation", ")", "\n", "\n", "\n", "print", "(", "'\\nCheck Parameter oprimization paramters:'", ")", "\n", "print", "(", "'  PARAM: param evaluation itr  : '", ",", "params", ".", "n_param_opt_max_itr", ")", "\n", "print", "(", "'  PARAM: gd algorithm          : '", ",", "params", ".", "n_algo_param", ")", "\n", "if", "params", ".", "n_param_optimizer", "==", "'gd'", ":", "\n", "            ", "print", "(", "'  PARAM: gd evaluation mode    : '", ",", "params", ".", "n_gd_eval_mode", ")", "\n", "print", "(", "'  PARAM: gd precision          : '", ",", "params", ".", "n_gd_precision", ")", "\n", "print", "(", "'  PARAM: gd learning rate      : '", ",", "params", ".", "n_gd_eta", ")", "\n", "print", "(", "'  PARAM: gd momentum rate      : '", ",", "params", ".", "n_gd_gamma", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "'  PARAM: mh population         : '", ",", "params", ".", "n_mh_pop_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setParameter": [[202, 217], ["print", "src.dataloader.data_processing.DataProcessing", "src.dataloader.data_processing.DataProcessing.load_data", "setting_params.SettingParamter", "setting_params.SettingParamter.setData", "setting_params.SettingParamter.setTreeParameters", "setting_params.SettingParamter.setStructureOptimization", "setting_params.SettingParamter.setParamterOptimization", "SettingParamter.mParser.parse_args"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.load_data", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setData", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setStructureOptimization", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.setting.setting_params.SettingParamter.setParamterOptimization"], ["", "", "def", "setParameter", "(", "data_file", "=", "'input_a_file.csv'", ",", "n_problem_type", "=", "'Classification'", ",", "param_opt", "=", "'gd'", ",", "is_norm", "=", "False", ",", "normalize", "=", "[", "0.0", ",", "1.0", "]", ")", ":", "\n", "        ", "print", "(", "'Setiing problem...'", ")", "\n", "dataProcessing", "=", "DataProcessing", "(", ")", "\n", "data", "=", "dataProcessing", ".", "load_data", "(", "n_problem_type", ",", "data_file", ")", "\n", "#%", "\n", "setParams", "=", "SettingParamter", "(", ")", "\n", "setParams", ".", "setData", "(", "data_file", ",", "data", ",", "n_problem_type", ",", "normalize", ",", "is_norm", ")", "\n", "setParams", ".", "setTreeParameters", "(", ")", "\n", "setParams", ".", "setStructureOptimization", "(", ")", "\n", "setParams", ".", "setParamterOptimization", "(", "param_opt", ")", "\n", "\n", "#Retriving paramters", "\n", "params", "=", "setParams", ".", "mParser", ".", "parse_args", "(", ")", "\n", "#setParams.checkParameters(params)#  checking paramters", "\n", "return", "params", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.__init__": [[46, 74], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p_problem_type", ",", "\n", "p_data_train_inputs", ",", "\n", "p_data_test_inputs", ",", "\n", "p_data_val_inputs", ",", "\n", "p_data_train_targets", ",", "\n", "p_data_test_targets", ",", "\n", "p_data_val_targets", ",", "\n", "p_target_attr_count", ",", "\n", "p_target_class_names", ",", "\n", "p_data_denorm_params", "=", "[", "]", ")", ":", "\n", "        ", "'''\n        Set tree and dataset infromation\n        args:\n            params: p_tree, p_data_input_TO_tree, p_target_attr_count, p_problem_type\n        '''", "\n", "self", ".", "m_problem_type", "=", "p_problem_type", "\n", "\n", "self", ".", "m_data_train_inputs", "=", "p_data_train_inputs", "\n", "self", ".", "m_data_test_inputs", "=", "p_data_test_inputs", "\n", "self", ".", "m_data_val_inputs", "=", "p_data_val_inputs", "\n", "\n", "self", ".", "m_data_train_targets", "=", "p_data_train_targets", "\n", "self", ".", "m_data_test_targets", "=", "p_data_test_targets", "\n", "self", ".", "m_data_val_targets", "=", "p_data_val_targets", "\n", "\n", "self", ".", "m_target_attr_count", "=", "p_target_attr_count", "\n", "self", ".", "m_traget_class_names", "=", "p_target_class_names", "\n", "self", ".", "m_data_denorm_params", "=", "p_data_denorm_params", "\n", "#                       [params.n_is_data_normlized, ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getPartitionSeprated": [[78, 80], ["None"], "methods", ["None"], ["", "def", "getPartitionSeprated", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "m_data_train_inputs", ",", "self", ".", "m_data_test_inputs", ",", "self", ".", "m_data_train_targets", ",", "self", ".", "m_data_test_targets", "\n", "#-------------------------------------------------------------------------------------------------------------        ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.set_dataset_to_evaluate": [[81, 111], ["None"], "methods", ["None"], ["", "def", "set_dataset_to_evaluate", "(", "self", ",", "p_dataset_to_use", ")", ":", "\n", "        ", "'''\n        This method set type of set to use in the tree used \n        args:\n            param:    p_dataset_to_use    string value\n        '''", "\n", "# set input and traget as training set sets", "\n", "if", "(", "p_dataset_to_use", "==", "'train'", ")", ":", "\n", "#print('Training data setting...')", "\n", "# reset the variables", "\n", "            ", "self", ".", "m_data_input_TO_tree", "=", "None", "\n", "self", ".", "m_data_target_TO_tree", "=", "None", "\n", "self", ".", "m_data_input_TO_tree", "=", "self", ".", "m_data_train_inputs", "\n", "self", ".", "m_data_target_TO_tree", "=", "self", ".", "m_data_train_targets", "\n", "# set input and traget as test sets", "\n", "", "if", "(", "p_dataset_to_use", "==", "'test'", ")", ":", "\n", "#print('Testing data setting...')", "\n", "# reset the variables", "\n", "            ", "self", ".", "m_data_input_TO_tree", "=", "None", "\n", "self", ".", "m_data_target_TO_tree", "=", "None", "\n", "self", ".", "m_data_input_TO_tree", "=", "self", ".", "m_data_test_inputs", "\n", "self", ".", "m_data_target_TO_tree", "=", "self", ".", "m_data_test_targets", "\n", "# set input and traget as validation set sets", "\n", "", "if", "(", "p_dataset_to_use", "==", "'val'", ")", ":", "\n", "#print('Validating data setting...')", "\n", "# reset the variables", "\n", "            ", "self", ".", "m_data_input_TO_tree", "=", "None", "\n", "self", ".", "m_data_target_TO_tree", "=", "None", "\n", "self", ".", "m_data_input_TO_tree", "=", "self", ".", "m_data_val_inputs", "\n", "self", ".", "m_data_target_TO_tree", "=", "self", ".", "m_data_val_targets", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreePredictedOutputs": [[113, 155], ["numpy.array", "n_list_data_prediction_OF_tree.append", "multiprocessing.Pipe", "multiprocessing.Process", "jobs.append", "pipe_list.append", "multiprocessing.Process.start", "proc.join", "x.recv", "p_treeToEvalute.getOutput"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.gp.gp.GP.start", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getOutput"], ["", "", "def", "getTreePredictedOutputs", "(", "self", ",", "p_treeToEvalute", ")", ":", "\n", "        ", "'''\n            Evaluate tree fitness for a input datasets return the predicted output\n            args:\n                param: p_tree takes a tree object to evaluate its fitenss (predicted outputs)\n                \n            return:    a(an) matrix/array of tree prediction  rows x column\n        '''", "\n", "multiprocessing_eval", "=", "False", "# -> No multiprocessing since small computaiion is not efficent in MP", "\n", "n_list_data_prediction_OF_tree", "=", "[", "]", "\n", "if", "not", "multiprocessing_eval", ":", "\n", "            ", "for", "v_input_vector", "in", "self", ".", "m_data_input_TO_tree", ":", "\n", "                ", "n_list_data_prediction_OF_tree", ".", "append", "(", "p_treeToEvalute", ".", "getOutput", "(", "v_input_vector", ",", "self", ".", "m_target_attr_count", ")", ")", "\n", "", "", "else", ":", "# Multiprocessing not efficent for small computation", "\n", "# test revealse it is not efficient", "\n", "            ", "jobs", "=", "[", "]", "\n", "pipe_list", "=", "[", "]", "\n", "#manager = mp.Manager()", "\n", "#return_list = manager.list()", "\n", "for", "v_input_vector", "in", "self", ".", "m_data_input_TO_tree", ":", "\n", "                ", "recv_end", ",", "send_end", "=", "mp", ".", "Pipe", "(", "False", ")", "\n", "p", "=", "mp", ".", "Process", "(", "target", "=", "getTreeOutOnSingleVector", ",", "args", "=", "(", "p_treeToEvalute", ",", "v_input_vector", ",", "self", ".", "m_target_attr_count", ",", "send_end", ")", ")", "\n", "#p = mp.Process(target=getTreeOutOnSingleVector, args=(p_treeToEvalute, v_input_vector, self.m_target_attr_count, return_list))", "\n", "jobs", ".", "append", "(", "p", ")", "\n", "pipe_list", ".", "append", "(", "recv_end", ")", "\n", "p", ".", "start", "(", ")", "\n", "\n", "", "for", "proc", "in", "jobs", ":", "\n", "                ", "proc", ".", "join", "(", ")", "\n", "#recieves computed results", "\n", "", "n_list_data_prediction_OF_tree", "=", "[", "x", ".", "recv", "(", ")", "for", "x", "in", "pipe_list", "]", "\n", "#n_list_data_prediction_OF_tree = [x for x in return_list]", "\n", "\n", "#print(return_list)", "\n", "#print(len(self.m_data_input_TO_tree), len(return_list))", "\n", "#for i in range(len(self.m_data_input_TO_tree)):            ", "\n", "#    n_list_data_prediction_OF_tree.append(return_list[i])", "\n", "\n", "#converting list to an array / matrix", "\n", "", "self", ".", "m_data_prediction_OF_tree", "=", "np", ".", "array", "(", "n_list_data_prediction_OF_tree", ")", "\n", "# return the prediction - this may or many not be used by the a function", "\n", "return", "self", ".", "m_data_prediction_OF_tree", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.getTreeFitness": [[157, 166], ["evaluate_tree.EvaluateTree.compareTrueAndPred"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.compareTrueAndPred"], ["", "def", "getTreeFitness", "(", "self", ")", ":", "\n", "        ", "'''\n            Evaluate fitnees score of the tree\n            args:\n                param:    p_prediction_OF_tree    takes an arry/matrix of predicted out of the tree\n                \n            return:    (float) - score of the tree\n        '''", "\n", "return", "self", ".", "compareTrueAndPred", "(", "self", ".", "m_data_target_TO_tree", ",", "self", ".", "m_data_prediction_OF_tree", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.compareTrueAndPred": [[169, 180], ["src.reporting.perfromance_metrices.Perfromance", "src.reporting.perfromance_metrices.Perfromance.measures"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.measures"], ["", "def", "compareTrueAndPred", "(", "self", ",", "p_true_target", ",", "p_tree_predictions", ")", ":", "\n", "        ", "'''\n            Compae the the actual and prediction and report back the accuract/mean_sqaure_error\n            args:\n                param:    p_true_target            (float) mx n true traget \n                param:    p_tree_predictions       (float) mx n predicted traget \n                \n            return: (float) error/fitness in terms of error rate or mease sqaured error of the tree -> 0 best\n        '''", "\n", "performance", "=", "Perfromance", "(", "self", ".", "m_problem_type", ",", "p_true_target", ",", "p_tree_predictions", ",", "self", ".", "m_traget_class_names", ")", "\n", "return", "performance", ".", "measures", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.EvaluateTree.plot": [[181, 203], ["src.reporting.perfromance_metrices.Perfromance", "src.reporting.perfromance_metrices.Perfromance.getConfusionMatrixPlot", "src.reporting.perfromance_metrices.Perfromance", "src.reporting.perfromance_metrices.Perfromance.getScatterPlot", "src.dataloader.data_processing.DataProcessing.denormalize_data", "src.dataloader.data_processing.DataProcessing.denormalize_data"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.getConfusionMatrixPlot", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.reporting.perfromance_metrices.Perfromance.getScatterPlot", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.denormalize_data", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.dataloader.data_processing.DataProcessing.denormalize_data"], ["", "def", "plot", "(", "self", ",", "directory", ",", "trail", ",", "norm_or_no_corr_line", "=", "False", ")", ":", "\n", "        ", "'''\n         Plot metric for classification and regression repending upon \n        '''", "\n", "if", "self", ".", "m_problem_type", "==", "'Classification'", ":", "\n", "            ", "performance", "=", "Perfromance", "(", "self", ".", "m_problem_type", ",", "self", ".", "m_data_target_TO_tree", ",", "self", ".", "m_data_prediction_OF_tree", ",", "self", ".", "m_traget_class_names", ")", "\n", "performance", ".", "getConfusionMatrixPlot", "(", "directory", ",", "trail", ",", "norm_or_no_corr_line", ")", "\n", "", "else", ":", "\n", "            ", "p_true_target", "=", "self", ".", "m_data_target_TO_tree", "\n", "p_tree_predictions", "=", "self", ".", "m_data_prediction_OF_tree", "\n", "if", "self", ".", "m_data_denorm_params", "[", "0", "]", ":", "\n", "#print('PRINT NORM', np.min(p_true_target), np.max(p_true_target), np.min(p_tree_predictions), np.max(p_tree_predictions), )", "\n", "                ", "p_true_target", "=", "DataProcessing", ".", "denormalize_data", "(", "p_true_target", ",", "\n", "self", ".", "m_data_denorm_params", "[", "1", "]", ",", "self", ".", "m_data_denorm_params", "[", "2", "]", ",", "\n", "self", ".", "m_data_denorm_params", "[", "3", "]", ",", "self", ".", "m_data_denorm_params", "[", "4", "]", ")", "\n", "p_tree_predictions", "=", "DataProcessing", ".", "denormalize_data", "(", "p_tree_predictions", ",", "\n", "self", ".", "m_data_denorm_params", "[", "1", "]", ",", "self", ".", "m_data_denorm_params", "[", "2", "]", ",", "\n", "self", ".", "m_data_denorm_params", "[", "3", "]", ",", "self", ".", "m_data_denorm_params", "[", "4", "]", ")", "\n", "#print('PRINT DENORM', np.min(p_true_target), np.max(p_true_target), np.min(p_tree_predictions), np.max(p_tree_predictions), )", "\n", "\n", "", "performance", "=", "Perfromance", "(", "self", ".", "m_problem_type", ",", "p_true_target", ",", "p_tree_predictions", ",", "self", ".", "m_traget_class_names", ")", "\n", "performance", ".", "getScatterPlot", "(", "directory", ",", "trail", ",", "norm_or_no_corr_line", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.evaluate_tree.getTreeOutOnSingleVector": [[205, 208], ["send_end.send", "p_treeToEvalute.getOutput"], "function", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getOutput"], ["", "", "", "def", "getTreeOutOnSingleVector", "(", "p_treeToEvalute", ",", "v_input_vector", ",", "p_target_attr_count", ",", "send_end", ")", ":", "\n", "#return_list.append(p_treeToEvalute.getOutput(v_input_vector, p_target_attr_count)) ", "\n", "    ", "send_end", ".", "send", "(", "p_treeToEvalute", ".", "getOutput", "(", "v_input_vector", ",", "p_target_attr_count", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.__init__": [[22, 31], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p_function_param", ",", "p_net_weighted_sum", ",", "p_bias", ")", ":", "\n", "        ", "'''\n            Constractor that sets the param values\n            param: p_function_para is the parameter of the desfined function\n            param: p_net_weighted_sum is the value on which activatin/quasing/transfer function is to be applied.  \n        '''", "\n", "self", ".", "m_function_param", "=", "p_function_param", "\n", "self", ".", "m_net_wighted_sum", "=", "p_net_weighted_sum", "\n", "self", ".", "m_bias", "=", "p_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.value": [[32, 52], ["activation_fun.ActivationFunction.m_function_param.__contains__", "activation_fun.ActivationFunction.m_function_param.__contains__", "activation_fun.ActivationFunction.m_function_param.__contains__", "activation_fun.ActivationFunction.m_function_param.__contains__", "activation_fun.ActivationFunction.m_function_param.__contains__", "activation_fun.ActivationFunction.Gaussian", "activation_fun.ActivationFunction.tanh", "activation_fun.ActivationFunction.sigmoid", "activation_fun.ActivationFunction.ReLU", "activation_fun.ActivationFunction.softmax"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.Gaussian", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.tanh", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.sigmoid", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.ReLU", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.softmax"], ["", "def", "value", "(", "self", ")", ":", "\n", "        ", "'''\n           Implementation of of different functions       \n        '''", "\n", "#check what function is at the node", "\n", "if", "(", "self", ".", "m_function_param", ".", "__contains__", "(", "'Gaussian'", ")", ")", ":", "\n", "#print('Using Gaussian')", "\n", "            ", "return", "self", ".", "Gaussian", "(", ")", "\n", "", "if", "(", "self", ".", "m_function_param", ".", "__contains__", "(", "'tanh'", ")", ")", ":", "\n", "#print('Using tanh')", "\n", "            ", "return", "self", ".", "tanh", "(", ")", "\n", "", "if", "(", "self", ".", "m_function_param", ".", "__contains__", "(", "'sigmoid'", ")", ")", ":", "\n", "#print('Using sigmoid')", "\n", "            ", "return", "self", ".", "sigmoid", "(", ")", "\n", "", "if", "(", "self", ".", "m_function_param", ".", "__contains__", "(", "'ReLU'", ")", ")", ":", "\n", "#print('Using ReLU')", "\n", "            ", "return", "self", ".", "ReLU", "(", ")", "\n", "", "if", "(", "self", ".", "m_function_param", ".", "__contains__", "(", "'softmax'", ")", ")", ":", "\n", "#print('Using softmax')", "\n", "            ", "return", "self", ".", "softmax", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.Gaussian": [[54, 71], ["random.uniform", "float", "math.exp", "math.sqrt"], "methods", ["None"], ["", "", "def", "Gaussian", "(", "self", ")", ":", "\n", "        ", "'''\n            Implementation of Gausian function\n            Guassian function is from: \n                https://docs.scipy.org/doc/scipy/reference/stats.html\n            Node that Guassiab function has no use of bias\n        '''", "\n", "#Define the consants", "\n", "x", "=", "self", ".", "m_net_wighted_sum", "\n", "mu", "=", "self", ".", "m_function_param", "[", "0", "]", "\n", "sigma", "=", "self", ".", "m_function_param", "[", "1", "]", "\n", "if", "sigma", "==", "0", ":", "\n", "            ", "sigma", "=", "random", ".", "uniform", "(", "0.1", ",", "1.0", ")", "# this was the error", "\n", "self", ".", "m_function_param", "[", "1", "]", "=", "sigma", "\n", "# See defination of Gaussian here: https://en.wikipedia.org/wiki/Gaussian_function", "\n", "", "x", "=", "float", "(", "x", "-", "mu", ")", "/", "sigma", "# e -(1/2)((x-mu)/sigma)^2", "\n", "return", "math", ".", "exp", "(", "-", "x", "*", "x", "/", "2.0", ")", "/", "math", ".", "sqrt", "(", "2.0", "*", "math", ".", "pi", ")", "/", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.tanh": [[72, 83], ["numpy.tanh"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.tanh"], ["", "def", "tanh", "(", "self", ")", ":", "\n", "        ", "'''\n            Implementation of tanh function\n            tanh function is from: \n                http://mathworld.wolfram.com/HyperbolicTangent.html\n        '''", "\n", "#Define the consants", "\n", "wx", "=", "self", ".", "m_net_wighted_sum", "\n", "b", "=", "self", ".", "m_bias", "\n", "x", "=", "wx", "+", "b", "\n", "return", "np", ".", "tanh", "(", "x", ")", "\n", "#return (math.exp(x) - math.exp(-x))/(math.exp(x) + math.exp(-x))", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.sigmoid": [[85, 99], ["math.exp", "math.exp"], "methods", ["None"], ["", "def", "sigmoid", "(", "self", ")", ":", "\n", "        ", "'''\n            Implementation of sigmoid function\n            sigmoid function is from: \n                https://en.wikipedia.org/wiki/Sigmoid_function\n        '''", "\n", "#Define the consants", "\n", "wx", "=", "self", ".", "m_net_wighted_sum", "\n", "b", "=", "self", ".", "m_bias", "\n", "x", "=", "wx", "+", "b", "\n", "\n", "if", "x", "<", "0", ":", "\n", "            ", "return", "1", "-", "1", "/", "(", "1", "+", "math", ".", "exp", "(", "x", ")", ")", "\n", "", "return", "1.0", "/", "(", "1.0", "+", "math", ".", "exp", "(", "-", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.ReLU": [[102, 113], ["max"], "methods", ["None"], ["", "def", "ReLU", "(", "self", ")", ":", "\n", "        ", "'''\n            Implementation of ReLU function\n            ReLU function is from: \n                https://en.wikipedia.org/wiki/Sigmoid_function\n        '''", "\n", "#Define the consants", "\n", "wx", "=", "self", ".", "m_net_wighted_sum", "\n", "b", "=", "self", ".", "m_bias", "\n", "x", "=", "wx", "+", "b", "\n", "return", "max", "(", "0", ",", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.softmax": [[114, 127], ["None"], "methods", ["None"], ["", "def", "softmax", "(", "self", ")", ":", "\n", "        ", "'''\n            Implementation of ReLU function\n            ReLU function is from: \n                https://en.wikipedia.org/wiki/Sigmoid_function\n        '''", "\n", "#Define the consants", "\n", "wx", "=", "self", ".", "m_net_wighted_sum", "\n", "b", "=", "self", ".", "m_bias", "\n", "x", "=", "wx", "+", "b", "\n", "# Softmans is not used in this case as it dependts on other output nodes - ", "\n", "# this can only be used at output layrof a calssifcation pronblem sor its impley return x", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.__init__": [[31, 49], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p_weight", ",", "p_bias", ",", "p_fun_params", ",", "p_children", ",", "p_parent_node", ",", "p_depth", ")", ":", "\n", "        ", "'''\n        Genreating the Function node through its constrcutor\n            :parm    p_weight           weigth of the eadge connecting leaf node\n            :parm    p_children         number of children of this function node\n            :parm    p_depth            current depth of the function node\n            :parm    p_parent_node      parent node of this function node\n            :parm    p_fun_params       list pof paramter a function takes\n        \n        '''", "\n", "self", ".", "m_depth", "=", "p_depth", "\n", "self", ".", "m_edge_weight", "=", "p_weight", "\n", "self", ".", "m_bias", "=", "p_bias", "\n", "self", ".", "m_children", "=", "p_children", "\n", "self", ".", "m_ChildrenList", "=", "[", "]", "# clear list before appending to it.", "\n", "# At least three parameters a,b,c -> a and b paramters of the activation fun at the fun node, c is function type", "\n", "self", ".", "m_FunctionParams", "=", "[", "p", "for", "p", "in", "p_fun_params", "]", "# will create ne objects", "\n", "self", ".", "m_parent_node", "=", "p_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.genrateChildren": [[52, 135], ["range", "range", "random.uniform", "random.uniform", "random.uniform", "random.randrange", "src.tree.leaf_node.LeafNode", "function_node.FunctionNode.m_ChildrenList.append", "random.uniform", "random.uniform", "function_node.FunctionNode", "function_node.FunctionNode.genrateChildren", "function_node.FunctionNode.m_ChildrenList.append", "random.randrange", "random.random", "random.randrange", "src.tree.leaf_node.LeafNode", "function_node.FunctionNode.m_ChildrenList.append", "function_node.FunctionNode", "function_node.FunctionNode.genrateChildren", "function_node.FunctionNode.m_ChildrenList.append", "random.uniform", "random.uniform", "random.randrange"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.genrateChildren", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.genrateChildren"], ["", "def", "genrateChildren", "(", "self", ",", "params", ",", "p_current_depth", ")", ":", "\n", "        ", "'''\n            Genrates a random tree. It is recursive procedue for tree generation.\n                :parm    p_max_input_attr       maximum number of input attributes\n                :pram    p_max_children         maximumn number of children one node can take\n                :pram    p_max_depth            maximum depth of the whole tree\n                :pram    p_weight_range         edge weight's range\n                :pram    m_current_depth        current depth of the tree\n        '''", "\n", "\n", "p_max_target_attr", "=", "params", ".", "n_max_target_attr", "\n", "p_max_input_attr", "=", "params", ".", "n_max_input_attr", "\n", "p_max_children", "=", "params", ".", "n_max_children", "\n", "p_max_depth", "=", "params", ".", "n_max_depth", "\n", "p_weight_range", "=", "params", ".", "n_weight_range", "\n", "p_fun_range", "=", "params", ".", "n_fun_range", "\n", "p_fun_type", "=", "params", ".", "n_fun_type", "\n", "p_out_fun_type", "=", "params", ".", "n_out_fun_type", "\n", "\n", "if", "(", "p_current_depth", "<", "p_max_depth", ")", ":", "\n", "#iterate through number of childern of this (current, i.e., self) function node", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "m_children", ")", ":", "\n", "                ", "n_weight", "=", "random", ".", "uniform", "(", "p_weight_range", "[", "0", "]", ",", "p_weight_range", "[", "1", "]", ")", "# tree edge weight between uniformaly taken between 0 and 1   ", "\n", "n_bias", "=", "random", ".", "uniform", "(", "p_weight_range", "[", "0", "]", ",", "p_weight_range", "[", "1", "]", ")", "# tree bias weight between uniformaly taken between 0 and 1   ", "\n", "n_min_child", "=", "2", "# in any case min number of childrren will be 2 for a node", "\n", "# a,b,c -> a and b paramters of the activation fun at the fun node, c is function type", "\n", "# only used for tanh and sigmoid", "\n", "n_fun_params", "=", "[", "random", ".", "uniform", "(", "p_fun_range", "[", "0", "]", ",", "p_fun_range", "[", "1", "]", ")", ",", "# mean of Gaussian function", "\n", "random", ".", "uniform", "(", "0.1", ",", "1", ")", ",", "# Sigma of Gaussian function", "\n", "p_fun_type", "]", "\n", "\n", "# Child node generation function as well as leaf nodes  ", "\n", "if", "(", "p_max_target_attr", ">", "1", "and", "p_current_depth", "==", "0", ")", ":", "\n", "# For multiple class problem - i.e., target has more than has one column (outputs)", "\n", "# We make sure all the child of roots are a function node and not a leaf node", "\n", "\n", "# generating random number of chid for this function node  ", "\n", "                    ", "n_children_range", "=", "p_max_children", "-", "n_min_child", "# compute range for randomize number of child for a node", "\n", "n_children", "=", "n_min_child", "+", "random", ".", "randrange", "(", "n_children_range", ")", "# random children numbner (ensure atleast 2 child)", "\n", "\n", "if", "p_out_fun_type", "==", "'softmax'", ":", "\n", "                        ", "n_fun_params", "=", "[", "random", ".", "uniform", "(", "p_fun_range", "[", "0", "]", ",", "p_fun_range", "[", "1", "]", ")", ",", "# unused for softmax", "\n", "random", ".", "uniform", "(", "0.1", ",", "1.0", ")", ",", "# unused for softmax /tanh/sigmoid", "\n", "p_out_fun_type", "]", "\n", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "", "n_funNode", "=", "FunctionNode", "(", "n_weight", ",", "n_bias", ",", "n_fun_params", ",", "n_children", ",", "self", ",", "p_current_depth", ")", "#parent of this node is self                    ", "\n", "# recurrrsion", "\n", "n_funNode", ".", "genrateChildren", "(", "params", ",", "p_current_depth", "+", "1", ")", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_funNode", ")", "\n", "", "else", ":", "\n", "# For single class (typicaly regression problem root can function as well as leaf nodes                  ", "\n", "# a random choice between next node is leaf or a function", "\n", "# probalistice descision to generate a leaf node or a function node", "\n", "                    ", "if", "(", "random", ".", "random", "(", ")", "<", "params", ".", "n_int_leaf_rate", ")", ":", "\n", "# generate a leaf child of self as parent", "\n", "                        ", "n_num", "=", "random", ".", "randrange", "(", "p_max_input_attr", ")", "# random number to determine a leef node or a function  node child", "\n", "n_leafnode", "=", "LeafNode", "(", "n_weight", ",", "n_num", ",", "self", ")", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_leafnode", ")", "\n", "", "else", ":", "\n", "# generate a function node (child) of the current node (self as a parent)", "\n", "# compute number of children for the new function node", "\n", "                        ", "n_children_range", "=", "p_max_children", "-", "n_min_child", "# compute range for randomize number of child for a node", "\n", "n_children", "=", "n_min_child", "+", "random", ".", "randrange", "(", "n_children_range", ")", "# random children numbner (ensure atleast ", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "n_funNode", "=", "FunctionNode", "(", "n_weight", ",", "n_bias", ",", "n_fun_params", ",", "n_children", ",", "self", ",", "p_current_depth", ")", "#parent of this node is self", "\n", "\n", "# recurrrsion", "\n", "n_funNode", ".", "genrateChildren", "(", "params", ",", "p_current_depth", "+", "1", ")", "\n", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_funNode", ")", "\n", "# End of if-else for problistic decision", "\n", "# End for multi class problem", "\n", "#end of for loop for all p_max_children", "\n", "", "", "", "", "else", ":", "\n", "# generate only leaf node when max depth is reached", "\n", "# iterate through number of children of this function node", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "m_children", ")", ":", "\n", "                ", "n_weight", "=", "random", ".", "uniform", "(", "p_weight_range", "[", "0", "]", ",", "p_weight_range", "[", "1", "]", ")", "# tree edge weight between uniformaly taken between 0 and 1   ", "\n", "# this generate random input attr number (p_max_input_attr is exlusive)", "\n", "n_input_num", "=", "random", ".", "randrange", "(", "p_max_input_attr", ")", "\n", "n_leafnode", "=", "LeafNode", "(", "n_weight", ",", "n_input_num", ",", "self", ")", "#  leaf node does not contain bias", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_leafnode", ")", "\n", "#end for loop", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.print_node": [[141, 169], ["range", "len", "print", "str", "node.print_node"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.print_node"], ["", "", "", "def", "print_node", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Printing function node childs - or collecting them in a JSON format.\n                :param p_depth    current depth of the tree\n        '''", "\n", "#print(\"(\" + str(p_depth) + \"\",end=\" \")", "\n", "for", "i", "in", "range", "(", "p_depth", ")", ":", "\n", "            ", "if", "(", "False", ")", ":", "# false becuase it was used just for testing", "\n", "                ", "print", "(", "\"-\"", ",", "end", "=", "\" \"", ")", "# I do print only for testing", "\n", "\n", "#print(\" +\" + str(self.m_children))", "\n", "", "", "jason_string", "=", "\"\\\"name\\\":\"", "+", "\"\\\"f \"", "+", "str", "(", "self", ".", "m_children", ")", "+", "\"\\\",\"", "\n", "\n", "jason_string", "=", "jason_string", "+", "\"\\\"children\\\":[\"", "\n", "\n", "listLength", "=", "len", "(", "self", ".", "m_ChildrenList", ")", "\n", "conut_loop", "=", "0", "\n", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "#node.print_node(p_depth + 1)", "\n", "            ", "jason_string", "=", "jason_string", "+", "\"{\"", "+", "node", ".", "print_node", "(", "p_depth", "+", "1", ")", "\n", "\n", "conut_loop", "=", "conut_loop", "+", "1", "\n", "if", "(", "conut_loop", "<", "listLength", ")", ":", "\n", "                ", "jason_string", "=", "jason_string", "+", "\",\"", "# no comma for the last child in the list.", "\n", "\n", "", "", "jason_string", "=", "jason_string", "+", "\" ]\"", "\n", "\n", "return", "jason_string", "+", "\"}\"", "\n", "# end printing function nodes", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.saveNode": [[172, 200], ["range", "len", "print", "str", "node.saveNode", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.saveNode"], ["", "def", "saveNode", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Saving function node childs - or collecting them in a JSON format.\n                :param p_depth    current depth of the tree\n        '''", "\n", "#print(\"(\" + str(p_depth) + \"\",end=\" \")", "\n", "for", "i", "in", "range", "(", "p_depth", ")", ":", "\n", "            ", "if", "(", "False", ")", ":", "# false becuase it was used just for testing", "\n", "                ", "print", "(", "\"-\"", ",", "end", "=", "\" \"", ")", "# I do print only for testing", "\n", "\n", "#print(\" +\" + str(self.m_children))", "\n", "", "", "jason_string", "=", "\"\\\"name\\\":\"", "+", "\"\\\"f:\"", "+", "str", "(", "self", ".", "m_children", ")", "+", "\"; e:\"", "+", "str", "(", "self", ".", "m_edge_weight", ")", "+", "\"; b:\"", "+", "str", "(", "self", ".", "m_bias", ")", "+", "\"; p:\"", "+", "str", "(", "self", ".", "m_FunctionParams", ")", "+", "\"\\\",\"", "\n", "\n", "jason_string", "=", "jason_string", "+", "\"\\\"children\\\":[\"", "\n", "\n", "listLength", "=", "len", "(", "self", ".", "m_ChildrenList", ")", "\n", "conut_loop", "=", "0", "\n", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "#node.print_node(p_depth + 1)", "\n", "            ", "jason_string", "=", "jason_string", "+", "\"{\"", "+", "node", ".", "saveNode", "(", "p_depth", "+", "1", ")", "\n", "\n", "conut_loop", "=", "conut_loop", "+", "1", "\n", "if", "(", "conut_loop", "<", "listLength", ")", ":", "\n", "                ", "jason_string", "=", "jason_string", "+", "\",\"", "# no comma for the last child in the list.", "\n", "\n", "", "", "jason_string", "=", "jason_string", "+", "\" ]\"", "\n", "\n", "return", "jason_string", "+", "\"}\"", "\n", "# end printing function nodes", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.retriveChildrenOriginal": [[204, 251], ["object", "isinstance", "print", "isinstance", "print", "int", "float", "src.tree.leaf_node.LeafNode", "function_node.FunctionNode.m_ChildrenList.append", "item.get", "len", "n_list_names.split.split.split", "float", "float", "ast.literal_eval", "function_node.FunctionNode", "function_node.FunctionNode.retriveChildren", "function_node.FunctionNode.m_ChildrenList.append", "len", "item.get", "len", "item.get", "[].split", "[].split", "n_list_names[].split", "n_list_names[].split", "n_list_names[].split", "item[].split", "item[].split"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.retriveChildren", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split"], ["", "def", "retriveChildrenOriginal", "(", "self", ",", "myjson", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Retrive children from the json file\n        '''", "\n", "#print('retriving tree data')", "\n", "_NUL", "=", "object", "(", ")", "# unique value guaranteed to never be in JSON data", "\n", "if", "isinstance", "(", "myjson", ",", "dict", ")", ":", "\n", "            ", "print", "(", "'dictionary operation not in use in this case'", ")", "\n", "for", "jsonkey", "in", "myjson", ":", "\n", "                ", "jsonvalue", "=", "myjson", "[", "jsonkey", "]", "\n", "print", "(", "'perhaps not require to use it - is you seee this as print - somthing wrong'", ",", "jsonvalue", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "myjson", ",", "list", ")", ":", "\n", "#print('list operation')", "\n", "            ", "for", "item", "in", "myjson", ":", "\n", "#iterate over all item (each iteam is a dictionary) in the list of children", "\n", "#check if the item is leaf ", "\n", "                ", "if", "(", "len", "(", "item", ")", "==", "1", "and", "(", "item", ".", "get", "(", "'children'", ",", "_NUL", ")", "is", "_NUL", ")", ")", ":", "\n", "#if dictitionary has 1 iteams and children is _NUL then its a leaf node", "\n", "# generate a leaf child of self as parent", "\n", "                    ", "index", "=", "0", "# 0 is index of attribute", "\n", "edge", "=", "1", "# 1 is index of attribute", "\n", "n_num", "=", "int", "(", "item", "[", "'name'", "]", ".", "split", "(", "';'", ")", "[", "index", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "n_weight", "=", "float", "(", "item", "[", "'name'", "]", ".", "split", "(", "';'", ")", "[", "edge", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "n_leafnode", "=", "LeafNode", "(", "n_weight", ",", "n_num", ",", "self", ")", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_leafnode", ")", "\n", "\n", "", "if", "(", "len", "(", "item", ")", "==", "2", "and", "(", "item", ".", "get", "(", "'children'", ",", "_NUL", ")", "is", "not", "_NUL", ")", ")", ":", "\n", "#generate function node                          ", "\n", "                    ", "n_fun_children", "=", "item", ".", "get", "(", "'children'", ")", "# fetch the list of children", "\n", "n_children", "=", "len", "(", "item", "[", "'children'", "]", ")", "# this is the length of children list", "\n", "# n_children length can  be also found alternatively  using -> n_list_names position 0 ", "\n", "\n", "n_list_names", "=", "item", "[", "'name'", "]", "\n", "n_list_names", "=", "n_list_names", ".", "split", "(", "';'", ")", "\n", "\n", "# n_list_names - > one is the weight", "\n", "n_edge_weight", "=", "float", "(", "n_list_names", "[", "1", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# n_list_names - > two is the function paramter", "\n", "n_bias_weight", "=", "float", "(", "n_list_names", "[", "2", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# n_list_names - > three is the function paramter", "\n", "n_fun_params", "=", "ast", ".", "literal_eval", "(", "n_list_names", "[", "3", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "n_funNode", "=", "FunctionNode", "(", "n_edge_weight", ",", "n_bias_weight", ",", "n_fun_params", ",", "n_children", ",", "self", ",", "p_depth", ")", "\n", "n_funNode", ".", "retriveChildren", "(", "n_fun_children", ",", "p_depth", "+", "1", ")", "\n", "# after all reacursion the child list will be saved here", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_funNode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.retriveChildren": [[253, 311], ["object", "isinstance", "print", "isinstance", "print", "int", "float", "src.tree.leaf_node.LeafNode", "function_node.FunctionNode.m_ChildrenList.append", "item.get", "len", "n_list_names.split.split.split", "float", "float", "n_list_string.replace().split.replace().split.replace", "n_list_string.replace().split.replace().split.replace", "n_list_string.replace().split.replace().split.replace().split", "function_node.FunctionNode", "function_node.FunctionNode.retriveChildren", "function_node.FunctionNode.m_ChildrenList.append", "len", "item.get", "len", "item.get", "str", "float", "float", "[].split", "[].split", "n_list_names[].split", "n_list_names[].split", "n_list_string.replace().split.replace().split.replace", "n_list_names[].split", "item[].split", "item[].split"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.retriveChildren", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split"], ["", "", "", "", "def", "retriveChildren", "(", "self", ",", "myjson", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Retrive children from the json file\n        '''", "\n", "#print('retriving tree data')", "\n", "_NUL", "=", "object", "(", ")", "# unique value guaranteed to never be in JSON data", "\n", "if", "isinstance", "(", "myjson", ",", "dict", ")", ":", "\n", "            ", "print", "(", "'dictionary operation not in use in this case'", ")", "\n", "for", "jsonkey", "in", "myjson", ":", "\n", "                ", "jsonvalue", "=", "myjson", "[", "jsonkey", "]", "\n", "print", "(", "'perhaps not require to use it - is you seee this as print - somthing wrong'", ",", "jsonvalue", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "myjson", ",", "list", ")", ":", "\n", "#print('list operation')", "\n", "            ", "for", "item", "in", "myjson", ":", "\n", "#iterate over all item (each iteam is a dictionary) in the list of children", "\n", "#check if the item is leaf ", "\n", "                ", "if", "(", "len", "(", "item", ")", "==", "1", "and", "(", "item", ".", "get", "(", "'children'", ",", "_NUL", ")", "is", "_NUL", ")", ")", ":", "\n", "#if dictitionary has 1 iteams and children is _NUL then its a leaf node", "\n", "# generate a leaf child of self as parent", "\n", "                    ", "index", "=", "0", "# 0 is index of attribute", "\n", "edge", "=", "1", "# 1 is index of attribute", "\n", "n_num", "=", "int", "(", "item", "[", "'name'", "]", ".", "split", "(", "';'", ")", "[", "index", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "n_weight", "=", "float", "(", "item", "[", "'name'", "]", ".", "split", "(", "';'", ")", "[", "edge", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "n_leafnode", "=", "LeafNode", "(", "n_weight", ",", "n_num", ",", "self", ")", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_leafnode", ")", "\n", "\n", "", "if", "(", "len", "(", "item", ")", "==", "2", "and", "(", "item", ".", "get", "(", "'children'", ",", "_NUL", ")", "is", "not", "_NUL", ")", ")", ":", "\n", "#generate function node                          ", "\n", "                    ", "n_fun_children", "=", "item", ".", "get", "(", "'children'", ")", "# fetch the list of children", "\n", "n_children", "=", "len", "(", "item", "[", "'children'", "]", ")", "# this is the length of children list", "\n", "# n_children length can  be also found alternatively  using -> n_list_names position 0 ", "\n", "\n", "n_list_names", "=", "item", "[", "'name'", "]", "\n", "n_list_names", "=", "n_list_names", ".", "split", "(", "';'", ")", "\n", "\n", "# n_list_names - > one is the weight", "\n", "n_edge_weight", "=", "float", "(", "n_list_names", "[", "1", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# n_list_names - > two is the function paramter", "\n", "n_bias_weight", "=", "float", "(", "n_list_names", "[", "2", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# n_list_names - > three is the function paramter", "\n", "\n", "strVal", "=", "str", "(", "n_list_names", "[", "3", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "+", "\"\"", "\n", "#print(strVal)", "\n", "n_list_string", "=", "strVal", "\n", "n_list_string", "=", "n_list_string", ".", "replace", "(", "\"[\"", ",", "\"\"", ")", "\n", "n_list_string", "=", "n_list_string", ".", "replace", "(", "\"]\"", ",", "\"\"", ")", "\n", "n_list_string", "=", "n_list_string", ".", "replace", "(", "\" \"", ",", "\"\"", ")", ".", "split", "(", "','", ")", "\n", "#n_fun_params = ast.literal_eval(n_list_names[3].split(':')[1])", "\n", "n_fun_params", "=", "[", "float", "(", "n_list_string", "[", "0", "]", ")", ",", "float", "(", "n_list_string", "[", "1", "]", ")", ",", "n_list_string", "[", "2", "]", "]", "\n", "#print(n_fun_params)", "\n", "\n", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "n_funNode", "=", "FunctionNode", "(", "n_edge_weight", ",", "n_bias_weight", ",", "n_fun_params", ",", "n_children", ",", "self", ",", "p_depth", ")", "\n", "n_funNode", ".", "retriveChildren", "(", "n_fun_children", ",", "p_depth", "+", "1", ")", "\n", "# after all reacursion the child list will be saved here", "\n", "self", ".", "m_ChildrenList", ".", "append", "(", "n_funNode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.inspect_node": [[313, 331], ["node.isLeaf", "node.inspect_node", "p_tree.addLeafNodesList", "node.inspect_node", "p_tree.addFunNodesList"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.isLeaf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.inspect_node", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.addLeafNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.inspect_node", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.addFunNodesList"], ["", "", "", "", "def", "inspect_node", "(", "self", ",", "p_tree", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Inpects current function node -  This function will inspect all node\n                :parame   p_tree        tree passed as a paramter\n                :param    p_depth       current depth of the tree\n            \n        '''", "\n", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "# if print_message = True it print node type (except for root node) so toal print will one less that toatal nodes", "\n", "            ", "print_message", "=", "False", "\n", "if", "(", "node", ".", "isLeaf", "(", "print_message", ")", ")", ":", "\n", "# add leaf child", "\n", "                ", "node", ".", "inspect_node", "(", "p_tree", ",", "p_depth", "+", "1", ")", "\n", "p_tree", ".", "addLeafNodesList", "(", "node", ")", "\n", "", "else", ":", "\n", "#add function child", "\n", "                ", "node", ".", "inspect_node", "(", "p_tree", ",", "p_depth", "+", "1", ")", "\n", "p_tree", ".", "addFunNodesList", "(", "node", ")", "\n", "# ---------------------------------------------------------------------------------------------------------------------------                ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getLeafNodesValue": [[332, 347], ["node_count.append", "node.isLeaf", "out_noeds_inputs_attr.append", "node.getLeafNodesValue", "node.getInputAttribute"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.isLeaf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getLeafNodesValue", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getInputAttribute"], ["", "", "", "def", "getLeafNodesValue", "(", "self", ",", "out_noeds_inputs_attr", ",", "node_count", ")", ":", "\n", "        ", "'''\n            Retiriving the corrent nodes all input attributes value\n            params:\n                out_noeds_inputs_attr: is a list\n        '''", "\n", "\n", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "            ", "node_count", ".", "append", "(", "1", ")", "\n", "if", "(", "node", ".", "isLeaf", "(", ")", ")", ":", "\n", "                ", "out_noeds_inputs_attr", ".", "append", "(", "node", ".", "getInputAttribute", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "node", ".", "getLeafNodesValue", "(", "out_noeds_inputs_attr", ",", "node_count", ")", "\n", "\n", "", "", "return", "out_noeds_inputs_attr", ",", "node_count", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.copyNode": [[349, 359], ["function_node.FunctionNode", "FunctionNode.m_ChildrenList.append", "nodes.copyNode"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.copyNode"], ["", "def", "copyNode", "(", "self", ",", "p_nodes", ")", ":", "\n", "        ", "'''\n            return a copy nodes \n        '''", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "node", "=", "FunctionNode", "(", "self", ".", "m_edge_weight", ",", "self", ".", "m_bias", ",", "self", ".", "m_FunctionParams", ",", "self", ".", "m_children", ",", "p_nodes", ",", "self", ".", "m_depth", ")", "\n", "for", "nodes", "in", "self", ".", "m_ChildrenList", ":", "\n", "            ", "node", ".", "m_ChildrenList", ".", "append", "(", "nodes", ".", "copyNode", "(", "node", ")", ")", "\n", "\n", "", "return", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setParentNode": [[361, 366], ["None"], "methods", ["None"], ["", "def", "setParentNode", "(", "self", ",", "p_parent_node", ")", ":", "\n", "        ", "'''\n            setting parent node information\n        '''", "\n", "self", ".", "m_parent_node", "=", "p_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getParentNode": [[368, 373], ["None"], "methods", ["None"], ["", "def", "getParentNode", "(", "self", ")", ":", "\n", "        ", "'''\n            Refturn parent node information\n        '''", "\n", "return", "self", ".", "m_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getDepth": [[375, 380], ["None"], "methods", ["None"], ["", "def", "getDepth", "(", "self", ")", ":", "\n", "        ", "'''\n            Return current depth of the tree\n        '''", "\n", "return", "self", ".", "m_depth", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.replaceSubTree": [[382, 391], ["function_node.FunctionNode.m_ChildrenList.__contains__", "print", "function_node.FunctionNode.m_ChildrenList.index"], "methods", ["None"], ["", "def", "replaceSubTree", "(", "self", ",", "p_old_nodes", ",", "p_new_nodes", ")", ":", "\n", "        ", "'''\n            replace subtree of the parent node\n        '''", "\n", "if", "(", "self", ".", "m_ChildrenList", ".", "__contains__", "(", "p_old_nodes", ")", ")", ":", "\n", "            ", "self", ".", "m_ChildrenList", "[", "self", ".", "m_ChildrenList", ".", "index", "(", "p_old_nodes", ")", "]", "=", "p_new_nodes", "\n", "#print('subtree is replaced')", "\n", "", "else", ":", "\n", "            ", "print", "(", "'no replacments'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.removeAndReplace": [[393, 408], ["function_node.FunctionNode.m_ChildrenList.__contains__", "src.tree.leaf_node.LeafNode", "print", "function_node.FunctionNode.m_ChildrenList.index"], "methods", ["None"], ["", "", "def", "removeAndReplace", "(", "self", ",", "p_fun_node_to_replace", ",", "p_weight", ",", "p_input_rand_attr", ")", ":", "\n", "        ", "'''\n            Remove function node-> p_fun_node \n            And\n            Replace by p_fun_node by a leaf node-> p_leaf_node\n            param:    p_fun_node_to_replace     a finction node\n            param:    p_weight_range            weight of the leaf node\n            param:    p_input_rand_attr         random input attr index at the leaf node\n        '''", "\n", "if", "(", "self", ".", "m_ChildrenList", ".", "__contains__", "(", "p_fun_node_to_replace", ")", ")", ":", "\n", "            ", "by_leaf_node", "=", "LeafNode", "(", "p_weight", ",", "p_input_rand_attr", ",", "self", ")", "\n", "self", ".", "m_ChildrenList", "[", "self", ".", "m_ChildrenList", ".", "index", "(", "p_fun_node_to_replace", ")", "]", "=", "by_leaf_node", "\n", "#print('subtree is replaced')", "\n", "", "else", ":", "\n", "            ", "print", "(", "'no replacments'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.removeAndGrow": [[410, 449], ["function_node.FunctionNode.m_ChildrenList.__contains__", "random.uniform", "random.uniform", "function_node.FunctionNode", "function_node.FunctionNode.genrateChildren", "print", "random.uniform", "random.uniform", "random.randrange", "function_node.FunctionNode.m_ChildrenList.index"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.genrateChildren"], ["", "", "def", "removeAndGrow", "(", "self", ",", "p_leaf_node_to_replace", ",", "params", ")", ":", "\n", "        ", "'''\n            Remove leaf node node p_leaf_node_to_replace\n            And\n            Replace by a subtree\n            param:    p_leaf_node_to_replace    node to be replaced \n            param:    prams                     set of input paramters\n        '''", "\n", "if", "(", "self", ".", "m_ChildrenList", ".", "__contains__", "(", "p_leaf_node_to_replace", ")", ")", ":", "\n", "#selected node is removed from the self child list", "\n", "#index_in_m_ChildrenList = self.m_ChildrenList.index(p_leaf_node_to_replace)", "\n", "#self.m_ChildrenList.remove(p_leaf_node_to_replace)", "\n", "\n", "            ", "p_max_children", "=", "params", ".", "n_max_children", "\n", "p_weight_range", "=", "params", ".", "n_weight_range", "\n", "p_fun_range", "=", "params", ".", "n_fun_range", "\n", "p_fun_type", "=", "params", ".", "n_fun_type", "\n", "\n", "n_weight", "=", "random", ".", "uniform", "(", "p_weight_range", "[", "0", "]", ",", "p_weight_range", "[", "1", "]", ")", "# tree edge weight between uniformaly taken between 0 and 1                ", "\n", "n_bias", "=", "random", ".", "uniform", "(", "p_weight_range", "[", "0", "]", ",", "p_weight_range", "[", "1", "]", ")", "# tree bias weight between uniformaly taken between 0 and 1   ", "\n", "n_min_child", "=", "2", "# in any case min number of childrren will be 2 for a node", "\n", "# a,b,c -> a and b paramters of the activation fun at the fun node, c is function type", "\n", "n_fun_params", "=", "[", "random", ".", "uniform", "(", "p_fun_range", "[", "0", "]", ",", "p_fun_range", "[", "1", "]", ")", ",", "# mean of Gaussian ", "\n", "random", ".", "uniform", "(", "0.1", ",", "1.0", ")", ",", "# sigma of Gaussian  ", "\n", "p_fun_type", "]", "\n", "\n", "# generating random number of chid for this function node  ", "\n", "n_children_range", "=", "p_max_children", "-", "n_min_child", "# compute range for randomize number of child for a node", "\n", "n_children", "=", "n_min_child", "+", "random", ".", "randrange", "(", "n_children_range", ")", "# random children numbner (ensure atleast             ", "\n", "# generate a children of the", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "n_fun_node", "=", "FunctionNode", "(", "n_weight", ",", "n_bias", ",", "n_fun_params", ",", "n_children", ",", "self", ",", "self", ".", "m_depth", ")", "#parent of this node is self                    ", "\n", "# recurrrsion", "\n", "n_fun_node", ".", "genrateChildren", "(", "params", ",", "self", ".", "m_depth", "+", "1", ")", "\n", "# add to the childeren list of the parent node", "\n", "self", ".", "m_ChildrenList", "[", "self", ".", "m_ChildrenList", ".", "index", "(", "p_leaf_node_to_replace", ")", "]", "=", "n_fun_node", "\n", "#self.m_ChildrenList.append(n_fun_node)", "\n", "", "else", ":", "\n", "            ", "print", "(", "'no replacments'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getEdgeWeight": [[451, 456], ["None"], "methods", ["None"], ["", "", "def", "getEdgeWeight", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_edge_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getDeltaEdgeWeight": [[458, 463], ["None"], "methods", ["None"], ["", "def", "getDeltaEdgeWeight", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_delta_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setEdgeWeight": [[465, 470], ["None"], "methods", ["None"], ["", "def", "setEdgeWeight", "(", "self", ",", "pEdgeWeight", ")", ":", "\n", "        ", "'''\n            Setting wedge weight\n        '''", "\n", "self", ".", "m_edge_weight", "=", "pEdgeWeight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias": [[472, 477], ["None"], "methods", ["None"], ["", "def", "getBias", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getDeltaBias": [[479, 484], ["None"], "methods", ["None"], ["", "def", "getDeltaBias", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_delta_bias", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias": [[486, 491], ["None"], "methods", ["None"], ["", "def", "setBias", "(", "self", ",", "pBias", ")", ":", "\n", "        ", "'''\n            Setting wedge weight\n        '''", "\n", "self", ".", "m_bias", "=", "pBias", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getMultiNodeOutput": [[493, 512], ["net_root_child_outputs.append", "node.getSingleNodeOutput"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getSingleNodeOutput"], ["", "def", "getMultiNodeOutput", "(", "self", ",", "p_input_attr_val", ")", ":", "\n", "        ", "'''\n            Function return tree output \n                either the child nodes of the tree -  multi input single output (MISO) problem\n                or the root node of the tree -  mulit input multi output (MIMO) problem\n            param:    p_input_attr_val          input example vector \n            param:    p_output_attr_count       target columns number - equivalent to number of classes\n        '''", "\n", "#MULITI OUTPUT - REGRSSION / CLASSIFICATION Problem for each child node", "\n", "#Evaluate the function nodes output for a given inputs data ", "\n", "# iterate for all child nodes of this corrent node", "\n", "# for the first call it starts with all child nodes of the root.", "\n", "# so for calssifciation problem all child node of the root will be taken           ", "\n", "net_root_child_outputs", "=", "[", "]", "# list for the ", "\n", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "            ", "net_root_child_outputs", ".", "append", "(", "node", ".", "getSingleNodeOutput", "(", "p_input_attr_val", ")", ")", "\n", "\n", "#return output for each class (each child of the root)", "\n", "", "return", "net_root_child_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getSingleNodeOutput": [[514, 533], ["src.tree.activation_fun.ActivationFunction", "src.tree.activation_fun.ActivationFunction.value", "src.tree.activation_fun.ActivationFunction.value", "node.getEdgeWeight", "node.getSingleNodeOutput"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.value", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.activation_fun.ActivationFunction.value", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getSingleNodeOutput"], ["", "def", "getSingleNodeOutput", "(", "self", ",", "p_input_attr_val", ")", ":", "\n", "        ", "'''\n            Evaluate the function nodes output for a given inputs data \n                param:    p_input_attr_val          input example vector \n            '''", "\n", "net_node_weighted_sum_of_inputs", "=", "0.0", "# list for the ", "\n", "# iterate for all child nodes of this current node", "\n", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "#weighted sum of all incomining values of the children", "\n", "# Its a recurssion here - ", "\n", "# IF the node is function it will call itself \"getSingleNodeOutput()\" in function_node.py ", "\n", "# IF a leaf it will call leaf node \"getSingleNodeOutput()\" in leaf_node.py", "\n", "            ", "net_node_weighted_sum_of_inputs", "=", "net_node_weighted_sum_of_inputs", "+", "node", ".", "getEdgeWeight", "(", ")", "*", "node", ".", "getSingleNodeOutput", "(", "p_input_attr_val", ")", "\n", "\n", "# compute activation of the current node node based on its activation function", "\n", "", "node_activation", "=", "ActivationFunction", "(", "self", ".", "m_FunctionParams", ",", "net_node_weighted_sum_of_inputs", ",", "self", ".", "m_bias", ")", "\n", "self", ".", "m_activation", "=", "node_activation", ".", "value", "(", ")", "\n", "#print('Activation:', self.m_activation)", "\n", "return", "node_activation", ".", "value", "(", ")", "\n", "#END of single node output", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setDeltaJ": [[536, 573], ["function_node.FunctionNode.m_FunctionParams.__contains__", "function_node.FunctionNode.m_FunctionParams.__contains__", "function_node.FunctionNode.m_FunctionParams.__contains__", "function_node.FunctionNode.m_FunctionParams.__contains__", "function_node.FunctionNode.m_FunctionParams.__contains__", "node.isLeaf", "node.setDeltaJ"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.isLeaf", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDeltaJ"], ["", "def", "setDeltaJ", "(", "self", ",", "y", "=", "[", "]", ",", "ypred", "=", "[", "]", ",", "j", "=", "0", ",", "isOutputNode", "=", "False", ")", ":", "\n", "        ", "'''\n            Compuute and sets the nodes delta j velaue that will we used to computer weight change\n            args:\n                param:  d = y  -        desired output\n                param:  o = ypred       predicted output\n                prams:  j               index in the case of ouput node\n                prams:  isOutputNode    set to false by defualt for hidden node the hidden function nodes takes no arguemnt \n        '''", "\n", "if", "isOutputNode", ":", "\n", "#print('Out ',j,':', y[j], ypred[j], self.m_FunctionParams.__contains__('sigmoid'), end = ' ')", "\n", "            ", "if", "(", "self", ".", "m_FunctionParams", ".", "__contains__", "(", "'softmax'", ")", ")", ":", "# [ypred[j] -y[j]]*ypred[j]*ypred[j]", "\n", "                ", "self", ".", "m_delta_j", "=", "(", "ypred", "[", "j", "]", "-", "y", "[", "j", "]", ")", "\n", "\n", "", "if", "(", "self", ".", "m_FunctionParams", ".", "__contains__", "(", "'sigmoid'", ")", ")", ":", "# [ypred[j] -y[j]]*ypred[j]*ypred[j]", "\n", "                ", "self", ".", "m_delta_j", "=", "(", "ypred", "[", "j", "]", "-", "y", "[", "j", "]", ")", "*", "ypred", "[", "j", "]", "*", "(", "1.0", "-", "ypred", "[", "j", "]", ")", "\n", "\n", "", "if", "(", "self", ".", "m_FunctionParams", ".", "__contains__", "(", "'tanh'", ")", ")", ":", "# -[ypred[j] -y[j]]*ypred[j]*ypred[j]", "\n", "                ", "self", ".", "m_delta_j", "=", "(", "-", "1.0", "*", "(", "ypred", "[", "j", "]", "-", "y", "[", "j", "]", ")", ")", "*", "ypred", "[", "j", "]", "*", "ypred", "[", "j", "]", "\n", "\n", "", "", "else", ":", "# for all hidden nodes", "\n", "            ", "hj", "=", "self", ".", "m_activation", "#  the nodes own activation ", "\n", "delta_k", "=", "self", ".", "m_parent_node", ".", "m_delta_j", "#  delata of the higher/ paren nodes", "\n", "wjk", "=", "self", ".", "m_edge_weight", "#  weight leads to the parent node (uper/higher layer)            ", "\n", "\n", "#print('H ', hj, delta_k, wjk, self.m_FunctionParams.__contains__('sigmoid'), end = ' ')", "\n", "if", "(", "self", ".", "m_FunctionParams", ".", "__contains__", "(", "'sigmoid'", ")", ")", ":", "#  yj[1.0-yj]*deltak*wk", "\n", "                ", "self", ".", "m_delta_j", "=", "hj", "*", "(", "1.0", "-", "hj", ")", "*", "delta_k", "*", "wjk", "\n", "\n", "", "if", "(", "self", ".", "m_FunctionParams", ".", "__contains__", "(", "'tanh'", ")", ")", ":", "#  -yj*yj*deltak*wk ", "\n", "                ", "self", ".", "m_delta_j", "=", "(", "-", "1.0", "*", "hj", "*", "hj", ")", "*", "delta_k", "*", "wjk", "\n", "\n", "#print('del_j', self.m_delta_j)", "\n", "\n", "", "", "for", "node", "in", "self", ".", "m_ChildrenList", ":", "\n", "            ", "if", "(", "not", "node", ".", "isLeaf", "(", ")", ")", ":", "\n", "                ", "node", ".", "setDeltaJ", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setGradient": [[575, 589], ["None"], "methods", ["None"], ["", "", "", "def", "setGradient", "(", "self", ",", "p_input_attr_val", "=", "[", "]", ",", "both_w_n_b", "=", "True", ")", ":", "\n", "        ", "'''\n            for function node gradient of weight has its own activation as the input\n        '''", "\n", "if", "both_w_n_b", ":", "\n", "# FOR NON OUTPUT Function nodes (for leaf node check in leaf function)", "\n", "            ", "yi", "=", "self", ".", "m_activation", "# activation of the corrent node act as an input for the next nodes (parent node)", "\n", "del_j", "=", "self", ".", "m_parent_node", ".", "m_delta_j", "#  delta_j of parent node backproagate to previous layer", "\n", "#print('gradient: ',yi, del_j)", "\n", "self", ".", "m_delta_weight", "=", "del_j", "*", "yi", "\n", "self", ".", "m_delta_bias", "=", "self", ".", "m_delta_j", "\n", "", "else", ":", "\n", "# FOR OUTPUT function nodes", "\n", "            ", "self", ".", "m_delta_bias", "=", "self", ".", "m_delta_j", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.__init__": [[15, 20], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p_weight", ",", "p_parent_node", ")", ":", "\n", "        ", "'''\n        '''", "\n", "self", ".", "m_edge_weight", "=", "p_weight", "\n", "self", ".", "m_parent_node", "=", "p_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.print_node": [[21, 23], ["print"], "methods", ["None"], ["", "def", "print_node", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "print", "(", "'Overide this methods'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.saveNode": [[24, 26], ["print"], "methods", ["None"], ["", "def", "saveNode", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "print", "(", "'Overide this methods'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.inspect_node": [[27, 29], ["print"], "methods", ["None"], ["", "def", "inspect_node", "(", "self", ",", "p_tree", ",", "p_depth", ")", ":", "\n", "        ", "print", "(", "'Overide inspect_node methods'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.isLeaf": [[30, 34], ["print"], "methods", ["None"], ["", "def", "isLeaf", "(", "self", ",", "p_toPrintNodeType", "=", "False", ")", ":", "\n", "        ", "if", "(", "p_toPrintNodeType", ")", ":", "\n", "            ", "print", "(", "'Function node'", ")", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.copyNode": [[35, 40], ["print"], "methods", ["None"], ["", "def", "copyNode", "(", "self", ",", "p_node", ")", ":", "\n", "        ", "'''\n            Copy node taks one paramter\n        '''", "\n", "print", "(", "'Overide copyNode methods'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.setParentNode": [[41, 46], ["None"], "methods", ["None"], ["", "def", "setParentNode", "(", "self", ",", "p_parent_node", ")", ":", "\n", "        ", "'''\n            setting parent node information\n        '''", "\n", "self", ".", "m_parent_node", "=", "p_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getParentNode": [[47, 52], ["None"], "methods", ["None"], ["", "def", "getParentNode", "(", "self", ")", ":", "\n", "        ", "'''\n            Refturn parent node information\n        '''", "\n", "return", "self", ".", "m_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getEdgeWeight": [[53, 58], ["None"], "methods", ["None"], ["", "def", "getEdgeWeight", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_edge_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getDeltaEdgeWeight": [[59, 64], ["None"], "methods", ["None"], ["", "def", "getDeltaEdgeWeight", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_delta_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.setEdgeWeight": [[65, 70], ["None"], "methods", ["None"], ["", "def", "setEdgeWeight", "(", "self", ",", "pEdgeWeight", ")", ":", "\n", "        ", "'''\n            set wedge weight\n        '''", "\n", "self", ".", "m_edge_weight", "=", "pEdgeWeight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getSingleNodeOutput": [[72, 78], ["print"], "methods", ["None"], ["", "def", "getSingleNodeOutput", "(", "self", ",", "p_input_attr_val", ")", ":", "\n", "        ", "'''\n            Output of a sngle node \n        '''", "\n", "print", "(", "'Override defult - refgression output method'", ")", "\n", "return", "-", "999.000", "# intentinally given a rubish value becuase it will override", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getMultiNodeOutput": [[79, 85], ["print"], "methods", ["None"], ["", "def", "getMultiNodeOutput", "(", "self", ",", "p_input_attr_val", ")", ":", "\n", "        ", "'''\n            Output of a sngle node \n        '''", "\n", "print", "(", "'Override defult - refgression output method'", ")", "\n", "return", "[", "]", "# intentinally given a rubish value becuase it will override", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.setGradient": [[86, 91], ["None"], "methods", ["None"], ["", "def", "setGradient", "(", "self", ",", "p_input_attr_val", "=", "[", "]", ",", "both_w_n_b", "=", "True", ")", ":", "\n", "        ", "'''\n            Seting weight change\n        '''", "\n", "self", ".", "m_delta_weight", "=", "-", "999.000", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.__init__": [[31, 38], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "m_root", "=", "None", "# inialize root node         ", "\n", "self", ".", "FunNodesList", "=", "[", "]", "# list of function nodes", "\n", "self", ".", "LeafNodesList", "=", "[", "]", "# list of leef nodes ", "\n", "self", ".", "m_max_children", "=", "0", "\n", "self", ".", "m_depth", "=", "0", "\n", "self", ".", "m_treeFitness", "=", "999", "# arbitary value to set fitness", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.genrateGenericRandomTree": [[40, 91], ["src.tree.function_node.FunctionNode", "neural_tree.NeuralTree.m_root.genrateChildren", "neural_tree.NeuralTree.inspectChildNodes", "random.randrange", "random.uniform", "random.uniform", "random.uniform", "random.uniform"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.genrateChildren", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes"], ["", "def", "genrateGenericRandomTree", "(", "self", ",", "params", ")", ":", "\n", "        ", "'''\n            Generates a random tree         \n                :param    m_max_input_attr     maximum number of input variable (attributes) in the data set\n                :param    m_max_children       maximum number of childs one node can takes\n                :param    m_max_depth          maximum depth/height of the tree\n        '''", "\n", "p_max_target_attr", "=", "params", ".", "n_max_target_attr", "\n", "p_max_children", "=", "params", ".", "n_max_children", "\n", "p_fun_range", "=", "params", ".", "n_fun_range", "\n", "p_fun_type", "=", "params", ".", "n_fun_type", "\n", "p_out_fun_type", "=", "params", ".", "n_out_fun_type", "\n", "\n", "# Strict ROOT function type setting for regression problem whoose output is normalized between 0 and 1, use Guassian function", "\n", "# if it is not already set to Guassian or sigmoid", "\n", "#if p_max_target_attr == 1 and (p_fun_type != 'Gaussian' or p_fun_type != 'sigmoid'): # root node for a regression  probl", "\n", "#    p_fun_type = 'Gaussian'", "\n", "\n", "n_root_weight", "=", "1.0", "# Fix weight for root node (not to  be used anyway - it's only for Function Node to work)", "\n", "n_root_bias", "=", "1.0", "# Fix bias for root node (not to  be used anyway - it's only for Function Node to work)", "\n", "n_min_child", "=", "2", "# setting minimum nodes for a node in the tree is 2", "\n", "n_arity_range", "=", "p_max_children", "-", "n_min_child", "# compute range for randomize number of child for a node", "\n", "\n", "# Check number of outputs of the proble", "\n", "if", "(", "p_max_target_attr", ">", "1", ")", ":", "\n", "            ", "n_children", "=", "p_max_target_attr", "# fix the number of child of a tree for a classification problem", "\n", "", "else", ":", "\n", "            ", "n_children", "=", "n_min_child", "+", "random", ".", "randrange", "(", "n_arity_range", ")", "# random children numbner (ensure atleast 2 child)", "\n", "\n", "# a,b,c -> a and b paramters of the activation fun at the fun node, c is function type", "\n", "# Function params are mostly used for Guassian function", "\n", "", "if", "p_out_fun_type", "==", "'softmax'", ":", "\n", "            ", "n_fun_params", "=", "[", "random", ".", "uniform", "(", "p_fun_range", "[", "0", "]", ",", "p_fun_range", "[", "1", "]", ")", ",", "# unused for softmax", "\n", "random", ".", "uniform", "(", "0.1", ",", "1.0", ")", ",", "# unused for softmax /tanh/sigmoid", "\n", "p_out_fun_type", "]", "#  this can be anny thing Gaussing and tanh, sigm etc.", "\n", "", "else", ":", "\n", "            ", "n_fun_params", "=", "[", "random", ".", "uniform", "(", "p_fun_range", "[", "0", "]", ",", "p_fun_range", "[", "1", "]", ")", ",", "\n", "random", ".", "uniform", "(", "0.1", ",", "1.0", ")", ",", "\n", "p_fun_type", "]", "\n", "\n", "\n", "# Intialize root node of the tree  and set parten as none   ", "\n", "", "n_current_depth", "=", "-", "1", "# Set depth as -1 for root node since root do not have a parent node - None", "\n", "# Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "self", ".", "m_root", "=", "FunctionNode", "(", "n_root_weight", ",", "n_root_bias", ",", "n_fun_params", ",", "n_children", ",", "None", ",", "n_current_depth", ")", "\n", "\n", "n_current_depth", "=", "0", "# re -set current depth (root node depth)  to zero                ", "\n", "# Generate children of the tree - gerenate the whole tree in recursive mannen", "\n", "self", ".", "m_root", ".", "genrateChildren", "(", "params", ",", "n_current_depth", ")", "\n", "\n", "self", ".", "inspectChildNodes", "(", ")", "# calling a function withing the class to inspect", "\n", "#End defination generic Random tree    ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.print_tree": [[94, 99], ["neural_tree.NeuralTree.m_root.print_node"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.print_node"], ["", "def", "print_tree", "(", "self", ")", ":", "\n", "        ", "'''\n        print the tree in JSON formate - It will create a dictnary\n        '''", "\n", "return", "\"{ \"", "+", "self", ".", "m_root", ".", "print_node", "(", "0", ")", "# returns a JSON string", "\n", "# End defniation print_tree", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.saveTree": [[102, 107], ["neural_tree.NeuralTree.m_root.saveNode"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.saveNode"], ["", "def", "saveTree", "(", "self", ")", ":", "\n", "        ", "'''\n        Save the tree in JSON formate - It will create a dictnary\n        '''", "\n", "return", "\"{ \"", "+", "self", ".", "m_root", ".", "saveNode", "(", "0", ")", "# returns a JSON string", "\n", "# End defniation print_tree", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.retrive_JSON_TreeOriginal": [[111, 152], ["object", "isinstance", "print", "p_json_tree.get", "print", "n_list_names.split.split.split", "len", "float", "float", "ast.literal_eval", "src.tree.function_node.FunctionNode", "neural_tree.NeuralTree.m_root.retriveChildren", "neural_tree.NeuralTree.inspectChildNodes", "print", "print", "len", "len", "n_list_names[].split", "n_list_names[].split", "n_list_names[].split"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.retriveChildren", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split"], ["", "def", "retrive_JSON_TreeOriginal", "(", "self", ",", "p_json_tree", ")", ":", "\n", "        ", "'''\n        retrive the tree in JSON formate - It will create a dictnary\n        '''", "\n", "_NUL", "=", "object", "(", ")", "# unique value guaranteed to never be in JSON data", "\n", "if", "isinstance", "(", "p_json_tree", ",", "dict", ")", ":", "\n", "            ", "n_root_children", "=", "p_json_tree", ".", "get", "(", "'children'", ",", "_NUL", ")", "# _NUL if key not present", "\n", "if", "n_root_children", "is", "not", "_NUL", ":", "\n", "                ", "n_list_names", "=", "p_json_tree", "[", "'name'", "]", "\n", "n_list_names", "=", "n_list_names", ".", "split", "(", "';'", ")", "\n", "if", "(", "len", "(", "n_list_names", ")", "<", "4", "and", "len", "(", "n_list_names", ")", ">", "4", ")", ":", "\n", "                    ", "print", "(", "'Please input a correct tree mode file treeModel.json'", ")", "\n", "return", "None", "\n", "\n", "# names - > zero is number of children", "\n", "#n_children = int(n_list_names[0].split(':')[1])", "\n", "# Alternatively can number of children taken from children size", "\n", "", "n_children", "=", "len", "(", "p_json_tree", "[", "'children'", "]", ")", "\n", "# names - > one is the weight", "\n", "n_root_weight", "=", "float", "(", "n_list_names", "[", "1", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# names - > two is the bias", "\n", "n_root_bias", "=", "float", "(", "n_list_names", "[", "2", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# names - > three is the function paramter", "\n", "n_fun_params", "=", "ast", ".", "literal_eval", "(", "n_list_names", "[", "3", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "\n", "\n", "\n", "n_current_depth", "=", "-", "1", "# Set depth as -1 for root node", "\n", "# set parent None: # Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "self", ".", "m_root", "=", "FunctionNode", "(", "n_root_weight", ",", "n_root_bias", ",", "n_fun_params", ",", "n_children", ",", "None", ",", "n_current_depth", ")", "\n", "\n", "n_current_depth", "=", "0", "#", "\n", "self", ".", "m_root", ".", "retriveChildren", "(", "n_root_children", ",", "n_current_depth", ")", "\n", "#print('retrviving root child')    ", "\n", "self", ".", "inspectChildNodes", "(", ")", "# calling a function withing the class to inspect", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Root has not children \\'key\\' somting wrong with the input file'", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "'Require json file loaded as a dictinary format'", ")", "\n", "\n", "", "print", "(", "'Tree succefully retirived'", ")", "\n", "# End defniation print_tree", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.retrive_JSON_Tree": [[155, 202], ["object", "isinstance", "p_json_tree.get", "print", "n_list_names.split.split.split", "len", "float", "float", "n_list_string.replace().split.replace().split.replace", "n_list_string.replace().split.replace().split.replace", "n_list_string.replace().split.replace().split.replace().split", "src.tree.function_node.FunctionNode", "neural_tree.NeuralTree.m_root.retriveChildren", "neural_tree.NeuralTree.inspectChildNodes", "print", "print", "str", "float", "float", "len", "len", "n_list_names[].split", "n_list_names[].split", "n_list_string.replace().split.replace().split.replace", "n_list_names[].split"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.retriveChildren", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.mcs_fun.split_func.split"], ["", "def", "retrive_JSON_Tree", "(", "self", ",", "p_json_tree", ")", ":", "\n", "        ", "'''\n        retrive the tree in JSON formate - It will create a dictnary\n        '''", "\n", "_NUL", "=", "object", "(", ")", "# unique value guaranteed to never be in JSON data", "\n", "if", "isinstance", "(", "p_json_tree", ",", "dict", ")", ":", "\n", "            ", "n_root_children", "=", "p_json_tree", ".", "get", "(", "'children'", ",", "_NUL", ")", "# _NUL if key not present", "\n", "if", "n_root_children", "is", "not", "_NUL", ":", "\n", "                ", "n_list_names", "=", "p_json_tree", "[", "'name'", "]", "\n", "n_list_names", "=", "n_list_names", ".", "split", "(", "';'", ")", "\n", "if", "(", "len", "(", "n_list_names", ")", "<", "4", "and", "len", "(", "n_list_names", ")", ">", "4", ")", ":", "\n", "                    ", "print", "(", "'Please input a correct tree mode file treeModel.json'", ")", "\n", "return", "None", "\n", "\n", "# names - > zero is number of children", "\n", "#n_children = int(n_list_names[0].split(':')[1])", "\n", "# Alternatively can number of children taken from children size", "\n", "", "n_children", "=", "len", "(", "p_json_tree", "[", "'children'", "]", ")", "\n", "# names - > one is the weight", "\n", "n_root_weight", "=", "float", "(", "n_list_names", "[", "1", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# names - > two is the bias", "\n", "n_root_bias", "=", "float", "(", "n_list_names", "[", "2", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "# names - > three is the function paramter", "\n", "#print(n_list_names)", "\n", "#print(n_list_names[3])", "\n", "strVal", "=", "str", "(", "n_list_names", "[", "3", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "+", "\"\"", "\n", "#print(strVal)", "\n", "n_list_string", "=", "strVal", "\n", "n_list_string", "=", "n_list_string", ".", "replace", "(", "\"[\"", ",", "\"\"", ")", "\n", "n_list_string", "=", "n_list_string", ".", "replace", "(", "\"]\"", ",", "\"\"", ")", "\n", "n_list_string", "=", "n_list_string", ".", "replace", "(", "\" \"", ",", "\"\"", ")", ".", "split", "(", "','", ")", "\n", "n_fun_params", "=", "[", "float", "(", "n_list_string", "[", "0", "]", ")", ",", "float", "(", "n_list_string", "[", "1", "]", ")", ",", "n_list_string", "[", "2", "]", "]", "\n", "#print(n_fun_params)", "\n", "\n", "\n", "n_current_depth", "=", "-", "1", "# Set depth as -1 for root node", "\n", "# set parent None: # Function Node = WEIGHT, BIAS, FUN_PARMS, #CHILDREN, PARENT, DEPTH", "\n", "self", ".", "m_root", "=", "FunctionNode", "(", "n_root_weight", ",", "n_root_bias", ",", "n_fun_params", ",", "n_children", ",", "None", ",", "n_current_depth", ")", "\n", "\n", "n_current_depth", "=", "0", "#", "\n", "self", ".", "m_root", ".", "retriveChildren", "(", "n_root_children", ",", "n_current_depth", ")", "\n", "#print('retrviving root child')    ", "\n", "self", ".", "inspectChildNodes", "(", ")", "# calling a function withing the class to inspect", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Root has not children \\'key\\' somting wrong with the input file'", ")", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "'Require json file loaded as a dictinary format'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes": [[208, 216], ["neural_tree.NeuralTree.FunNodesList.clear", "neural_tree.NeuralTree.LeafNodesList.clear", "neural_tree.NeuralTree.m_root.inspect_node"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.inspect_node"], ["", "", "def", "inspectChildNodes", "(", "self", ")", ":", "\n", "        ", "'''\n            Thi function inspect function nodes and leaf nodes and create a list of them\n        '''", "\n", "self", ".", "FunNodesList", ".", "clear", "(", ")", "\n", "self", ".", "LeafNodesList", ".", "clear", "(", ")", "\n", "self", ".", "m_depth", "=", "0", "\n", "self", ".", "m_root", ".", "inspect_node", "(", "self", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.addLeafNodesList": [[218, 224], ["neural_tree.NeuralTree.LeafNodesList.append"], "methods", ["None"], ["", "def", "addLeafNodesList", "(", "self", ",", "p_LeafNode", ")", ":", "\n", "        ", "'''\n            add leaf child \n                :param    p_LeafNode    an object of leaf nodes\n        '''", "\n", "self", ".", "LeafNodesList", ".", "append", "(", "p_LeafNode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList": [[226, 231], ["None"], "methods", ["None"], ["", "def", "getLeafNodesList", "(", "self", ")", ":", "\n", "        ", "'''\n            return leaf child nodes list\n        '''", "\n", "return", "self", ".", "LeafNodesList", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.addFunNodesList": [[233, 240], ["neural_tree.NeuralTree.FunNodesList.append"], "methods", ["None"], ["", "def", "addFunNodesList", "(", "self", ",", "p_FuntNode", ")", ":", "\n", "        ", "'''\n            add function node child \n                :param    p_FuntNode    an object of function nodes\n            \n        '''", "\n", "self", ".", "FunNodesList", ".", "append", "(", "p_FuntNode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getFunNodesList": [[242, 248], ["None"], "methods", ["None"], ["", "def", "getFunNodesList", "(", "self", ")", ":", "\n", "        ", "'''\n            return function node child list\n            \n        '''", "\n", "return", "self", ".", "FunNodesList", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeInputFeatuereProperties": [[249, 308], ["neural_tree.NeuralTree.getLeafNodesList", "list", "input_featuer_names[].tolist", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "tree_feature_properties.update", "type", "numpy.array", "outputs_names.tolist.tolist.tolist", "root_node_input_attr_all.append", "numpy.unique", "root_node_each_featuers_count.append", "neural_tree.NeuralTree.getTreeSize", "type", "node.getInputAttribute", "root_node_input_attr_all.count", "node.getLeafNodesValue", "each_out_nodes_feature_all.append", "numpy.unique", "each_out_nodes_feature_unique.append", "each_out_nodes_feature_unique_names.append", "each_out_nodes_each_feature_count.append", "neural_tree.NeuralTree.append", "neural_tree.NeuralTree.getTreeSize", "list", "input_featuer_names[].tolist", "this_node_each_feature_count.append", "numpy.unique", "out_noeds_inputs_attr.count", "len"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getLeafNodesList", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getInputAttribute", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getLeafNodesValue", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize"], ["", "def", "getTreeInputFeatuereProperties", "(", "self", ",", "p_target_attr_count", ",", "input_featuer_names", ",", "outputs_names", ")", ":", "\n", "        ", "if", "type", "(", "input_featuer_names", ")", "==", "list", ":", "\n", "            ", "input_featuer_names", "=", "np", ".", "array", "(", "input_featuer_names", ")", "\n", "\n", "", "if", "not", "(", "type", "(", "outputs_names", ")", "==", "list", ")", ":", "\n", "            ", "outputs_names", "=", "outputs_names", ".", "tolist", "(", ")", "\n", "\n", "", "root_node_input_attr_all", "=", "[", "]", "\n", "for", "node", "in", "self", ".", "getLeafNodesList", "(", ")", ":", "\n", "            ", "root_node_input_attr_all", ".", "append", "(", "node", ".", "getInputAttribute", "(", ")", ")", "\n", "\n", "", "root_node_unique_featuers", "=", "list", "(", "np", ".", "unique", "(", "root_node_input_attr_all", ")", ")", "\n", "root_node_unique_featuers_names", "=", "input_featuer_names", "[", "np", ".", "unique", "(", "root_node_input_attr_all", ")", "]", ".", "tolist", "(", ")", "\n", "root_node_each_featuers_count", "=", "[", "]", "\n", "for", "value", "in", "root_node_unique_featuers", ":", "\n", "            ", "root_node_each_featuers_count", ".", "append", "(", "root_node_input_attr_all", ".", "count", "(", "value", ")", ")", "\n", "\n", "", "if", "p_target_attr_count", "==", "1", ":", "\n", "            ", "each_out_nodes_feature_all", "=", "root_node_input_attr_all", "\n", "each_out_nodes_feature_unique", "=", "root_node_unique_featuers", "\n", "each_out_nodes_feature_unique_names", "=", "root_node_unique_featuers_names", "\n", "each_out_nodes_each_feature_count", "=", "root_node_each_featuers_count", "\n", "each_out_nodes_feature_count", "=", "self", ".", "getTreeSize", "(", ")", "\n", "\n", "", "else", ":", "\n", "            ", "each_out_nodes_feature_all", "=", "[", "]", "\n", "each_out_nodes_feature_unique", "=", "[", "]", "\n", "each_out_nodes_feature_unique_names", "=", "[", "]", "\n", "each_out_nodes_feature_count", "=", "[", "]", "\n", "each_out_nodes_each_feature_count", "=", "[", "]", "\n", "for", "node", "in", "self", ".", "m_root", ".", "m_ChildrenList", ":", "\n", "                ", "out_noeds_inputs_attr", "=", "[", "]", "\n", "node_count", "=", "[", "]", "\n", "out_noeds_inputs_attr", ",", "node_count", "=", "node", ".", "getLeafNodesValue", "(", "out_noeds_inputs_attr", ",", "node_count", ")", "\n", "# collecting nodes in a list ", "\n", "each_out_nodes_feature_all", ".", "append", "(", "out_noeds_inputs_attr", ")", "\n", "this_node_unique_featuers", "=", "np", ".", "unique", "(", "out_noeds_inputs_attr", ")", "\n", "each_out_nodes_feature_unique", ".", "append", "(", "list", "(", "this_node_unique_featuers", ")", ")", "\n", "each_out_nodes_feature_unique_names", ".", "append", "(", "input_featuer_names", "[", "this_node_unique_featuers", "]", ".", "tolist", "(", ")", ")", "\n", "this_node_each_feature_count", "=", "[", "]", "\n", "for", "value", "in", "this_node_unique_featuers", ":", "\n", "                    ", "this_node_each_feature_count", ".", "append", "(", "out_noeds_inputs_attr", ".", "count", "(", "value", ")", ")", "\n", "", "each_out_nodes_each_feature_count", ".", "append", "(", "this_node_each_feature_count", ")", "\n", "each_out_nodes_feature_count", ".", "append", "(", "len", "(", "node_count", ")", "+", "1", ")", "\n", "\n", "", "", "tree_feature_properties", "=", "{", "}", "\n", "tree_feature_properties", ".", "update", "(", "{", "'tree_out_nodes'", ":", "outputs_names", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'tree_featueres_all'", ":", "root_node_input_attr_all", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'tree_featueres_unique'", ":", "root_node_unique_featuers", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'tree_featueres_unique_names'", ":", "root_node_unique_featuers_names", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'tree_each_featuere_count'", ":", "root_node_each_featuers_count", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'tree_size_overall'", ":", "self", ".", "getTreeSize", "(", ")", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'each_out_node_featueres_all'", ":", "each_out_nodes_feature_all", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'each_out_node_featueres_unique'", ":", "each_out_nodes_feature_unique", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'each_out_node_featueres_unique_names'", ":", "each_out_nodes_feature_unique_names", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'each_out_node_each_featueres_count'", ":", "each_out_nodes_each_feature_count", "}", ")", "\n", "tree_feature_properties", ".", "update", "(", "{", "'each_out_node_size'", ":", "each_out_nodes_feature_count", "}", ")", "\n", "\n", "return", "tree_feature_properties", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDepth": [[310, 316], ["None"], "methods", ["None"], ["", "def", "setDepth", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            setting variavle depth o the tree\n                :param    p_depth current depth set after inspection of the tree\n        '''", "\n", "self", ".", "m_depth", "=", "p_depth", "\n", "#----------------------------------------------------------------------------------------------------------   ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getDepth": [[317, 322], ["None"], "methods", ["None"], ["", "def", "getDepth", "(", "self", ")", ":", "\n", "        ", "'''\n            returning tree current depth\n        '''", "\n", "return", "self", ".", "m_depth", "\n", "#----------------------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeFitness": [[323, 330], ["None"], "methods", ["None"], ["", "def", "setTreeFitness", "(", "self", ",", "p_fitness", ")", ":", "\n", "        ", "'''\n            set the fitness of the tree\n            (depend on the objective function user RMSE of Error Rate)\n                :param    p_fitness    RMSE or Erorr rate of tree for a training data\n        '''", "\n", "self", ".", "m_treeFitness", "=", "p_fitness", "\n", "#----------------------------------------------------------------------------------------------------------   ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFitness": [[331, 337], ["None"], "methods", ["None"], ["", "def", "getTreeFitness", "(", "self", ")", ":", "\n", "        ", "'''\n            return fitness of the tree\n            (depend on the objective function user RMSE of Error Rate)\n        '''", "\n", "return", "self", ".", "m_treeFitness", "\n", "#----------------------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeSize": [[338, 343], ["len", "len"], "methods", ["None"], ["", "def", "getTreeSize", "(", "self", ")", ":", "\n", "        ", "'''\n            Retrun total number of nodes in the tree (i.e a root node have)        \n        '''", "\n", "return", "len", "(", "self", ".", "FunNodesList", ")", "+", "len", "(", "self", ".", "LeafNodesList", ")", "+", "1", "# + 1 for root node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeFuncNodeSize": [[345, 350], ["len"], "methods", ["None"], ["", "def", "getTreeFuncNodeSize", "(", "self", ")", ":", "\n", "        ", "'''\n            Retrun total number of nodes in the tree (i.e a root node have)        \n        '''", "\n", "return", "len", "(", "self", ".", "FunNodesList", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeLeafNodeSize": [[352, 357], ["len"], "methods", ["None"], ["", "def", "getTreeLeafNodeSize", "(", "self", ")", ":", "\n", "        ", "'''\n            Retrun total number of nodes in the tree (i.e a root node have)        \n        '''", "\n", "return", "len", "(", "self", ".", "LeafNodesList", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.copy_Tree": [[359, 372], ["neural_tree.NeuralTree", "neural_tree.NeuralTree.m_root.copyNode", "neural_tree.NeuralTree.inspectChildNodes"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.copyNode", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.inspectChildNodes"], ["", "def", "copy_Tree", "(", "self", ")", ":", "\n", "        ", "'''\n            returen a copy of itself with new instance / refernce to objects\n        '''", "\n", "# returning a new tree object - other old object will be modified", "\n", "n_tree", "=", "NeuralTree", "(", ")", "\n", "\n", "n_tree", ".", "m_max_children", "=", "self", ".", "m_max_children", "\n", "n_tree", ".", "m_depth", "=", "self", ".", "m_depth", "\n", "n_tree", ".", "m_treeFitness", "=", "self", ".", "m_treeFitness", "\n", "n_tree", ".", "m_root", "=", "self", ".", "m_root", ".", "copyNode", "(", "None", ")", "\n", "n_tree", ".", "inspectChildNodes", "(", ")", "\n", "return", "n_tree", "\n", "#----------------------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getOutput": [[373, 394], ["neural_tree.NeuralTree.m_root.m_FunctionParams.__contains__", "neural_tree.NeuralTree.m_root.getSingleNodeOutput", "neural_tree.NeuralTree.softmax", "neural_tree.NeuralTree.m_root.getMultiNodeOutput", "neural_tree.NeuralTree.m_root.getMultiNodeOutput"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getSingleNodeOutput", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.softmax", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getMultiNodeOutput", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.node.Node.getMultiNodeOutput"], ["", "def", "getOutput", "(", "self", ",", "p_input_attr_val", ",", "p_target_attr_count", ")", ":", "\n", "        ", "'''\n            Evaluate tree output for a given inputs data\n            param:    p_input_attr_val          input example vector \n            param:    p_output_attr_count       target columns number - equivalent to number of classes\n        '''", "\n", "if", "(", "p_target_attr_count", ">", "1", ")", ":", "\n", "            ", "'''\n            MULITI OUTPUT - REGRSSION / CLASSIFICATION Problem for each child node\n            Evaluate the function nodes output for a given inputs data     \n            '''", "\n", "if", "(", "self", ".", "m_root", ".", "m_FunctionParams", ".", "__contains__", "(", "'softmax'", ")", ")", ":", "\n", "                ", "return", "self", ".", "softmax", "(", "self", ".", "m_root", ".", "getMultiNodeOutput", "(", "p_input_attr_val", ")", ")", "\n", "", "else", ":", "\n", "                ", "return", "self", ".", "m_root", ".", "getMultiNodeOutput", "(", "p_input_attr_val", ")", "\n", "", "", "else", ":", "\n", "            ", "'''\n            SINGLE OUTPUT For regression / clasification and normal node output use this function\n            Evaluate the function nodes output for a given inputs data \n            '''", "\n", "return", "self", ".", "m_root", ".", "getSingleNodeOutput", "(", "p_input_attr_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getTreeParameters": [[396, 491], ["nParameters.append", "range", "range", "nParameters.append", "neural_tree.NeuralTree.m_root.getBias", "nParameters.append", "nParameters.append", "funParams.__contains__", "nParameters.append", "nParameters.append", "node.getEdgeWeight", "nParameters.append", "nParameters.append", "nParameters.append", "len", "node.getEdgeWeight", "nParameters.append", "node.getBias", "len", "neural_tree.NeuralTree.m_root.getBias", "nParameters.append", "node.getBias", "node.getEdgeWeight", "nParameters.append", "print", "node.getEdgeWeight", "node.getEdgeWeight", "nParameters.append", "nParameters.append", "node.getEdgeWeight", "nParameters.append", "nParameters.append", "node.getEdgeWeight", "node.getEdgeWeight", "nParameters.append", "neural_tree.NeuralTree.m_root.getBias", "node.getBias", "node.getEdgeWeight"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight"], ["", "", "def", "getTreeParameters", "(", "self", ",", "p_target_attr_count", ",", "pRerival", "=", "'all'", ")", ":", "\n", "        ", "'''\n            Retriving tree parameters\n            args:\n                param: p_target_attr_count number of output class. for classification it should be 2 or more. \n                For regression MUST be 1\n            Returns a vector of edge and function parameters values\n        '''", "\n", "nParameters", "=", "[", "]", "\n", "if", "pRerival", "==", "'all'", ":", "#  retrive Weight, Bias, and Function params", "\n", "# For single output problem - ROOT NODE's parameters (Bias and Function_params) are usefull (not weight)", "\n", "# Else all root node's parameters are useless", "\n", "            ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# NO WEIGHT beacuse root is output node and its weight has no use", "\n", "# TAKE ROOT BIAS", "\n", "                ", "nParameters", ".", "append", "(", "self", ".", "m_root", ".", "getBias", "(", ")", ")", "\n", "funParams", "=", "self", ".", "m_root", ".", "m_FunctionParams", "# TAKE ROOT FUN PARAMS", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "funParams", ")", "-", "1", ")", ":", "\n", "                    ", "nParameters", ".", "append", "(", "funParams", "[", "i", "]", ")", "# adding a and b of fun params", "\n", "\n", "# FUNCTION NODES - Retrive weight, bias, and func prameters [a and b] from the function list", "\n", "", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "                ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# For single output problem, root node is the output node ", "\n", "# Hence all its children function nodes are hidden nodes. This their weights are usefull ", "\n", "                    ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "# # take all hidden function node's (roots any child node) weights", "\n", "", "else", ":", "\n", "# For multi output problem root node is useless and all roots imediate child nodes are function nodes", "\n", "# Hence take ONLY NON-ROOT child weights", "\n", "                    ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# NOT a ROOT's Imediate child", "\n", "                        ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "# TAKE WEIGHTS ONLY for NON OUTPUT NODE", "\n", "\n", "\n", "# check if node is NOT Gausian", "\n", "", "", "funParams", "=", "node", ".", "m_FunctionParams", "# TAKE NODE's FUN PARAMS", "\n", "if", "(", "not", "funParams", ".", "__contains__", "(", "'Gaussian'", ")", ")", ":", "\n", "# Retriving Function bias ", "\n", "                    ", "nParameters", ".", "append", "(", "node", ".", "getBias", "(", ")", ")", "# TAKE NODE's BIAS", "\n", "\n", "# Retriving function params", "\n", "", "for", "i", "in", "range", "(", "0", ",", "len", "(", "funParams", ")", "-", "1", ")", ":", "\n", "                    ", "nParameters", ".", "append", "(", "funParams", "[", "i", "]", ")", "\n", "\n", "# LEAF NODES - retrive weight and prameters a, b from the function list", "\n", "", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "                ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "\n", "\n", "", "", "elif", "pRerival", "==", "'weights_and_bias'", ":", "\n", "            ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# NO WEIGHT only # TAKE ROOT BIAS", "\n", "                ", "nParameters", ".", "append", "(", "self", ".", "m_root", ".", "getBias", "(", ")", ")", "\n", "\n", "# retrive fnction node weights and prameters a, b from the function list", "\n", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# Retriving weights", "\n", "                ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# for single output problem take all its child weights", "\n", "                    ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "\n", "", "else", ":", "\n", "# for multi output  problem only take non roots child weights", "\n", "                    ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# NOT IN ROOT CHILD -> ok", "\n", "                        ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "# TAKE WEIGHTS ONLY for NON OUTPUT NODE", "\n", "# Retriving bias for all function nodes", "\n", "", "", "nParameters", ".", "append", "(", "node", ".", "getBias", "(", ")", ")", "# TAKE NODE's BIAS", "\n", "\n", "# retrive leaf node weights - it has no bias", "\n", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "                ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "\n", "\n", "", "", "elif", "pRerival", "==", "'weights'", ":", "\n", "# retrive fnction node weights and prameters a, b from the function list", "\n", "            ", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# Retriving weights", "\n", "                ", "if", "p_target_attr_count", "==", "1", ":", "# for regression proble take all its child weights", "\n", "                    ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "\n", "", "else", ":", "# if multi output  problem only take non roots child weights", "\n", "                    ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# NOT IN ROOT CHILD -> ok", "\n", "                        ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "# TAKE WEIGHTS ONLY for NON OUTPUT NODE", "\n", "\n", "# retrive leaf node weights", "\n", "", "", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "                ", "nParameters", ".", "append", "(", "node", ".", "getEdgeWeight", "(", ")", ")", "\n", "\n", "", "", "elif", "pRerival", "==", "'bias'", ":", "\n", "            ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# NO WEIGHT only # TAKE ROOT BIAS", "\n", "                ", "nParameters", ".", "append", "(", "self", ".", "m_root", ".", "getBias", "(", ")", ")", "\n", "# retrive fnction node weights and prameters a, b from the function list", "\n", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# Retriving bias for all function nodes", "\n", "                ", "nParameters", ".", "append", "(", "node", ".", "getBias", "(", ")", ")", "# TAKE NODE's BIAS", "\n", "", "", "else", ":", "\n", "            ", "print", "(", "'please input one of these: all, weights_and_bias,  weights,  bias'", ")", "\n", "# return accumulated parameters", "\n", "", "return", "nParameters", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setTreeParameters": [[493, 591], ["neural_tree.NeuralTree.m_root.setBias", "range", "range", "node.setEdgeWeight", "neural_tree.NeuralTree.m_root.setBias", "node.setBias", "node.setEdgeWeight", "node.setEdgeWeight", "neural_tree.NeuralTree.m_root.setBias", "node.setBias", "node.setEdgeWeight", "funParams.__contains__", "node.setBias", "node.setEdgeWeight", "node.setEdgeWeight", "len", "node.setEdgeWeight", "len", "node.setEdgeWeight", "node.setEdgeWeight"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.setBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight"], ["", "def", "setTreeParameters", "(", "self", ",", "pParameters", ",", "p_target_attr_count", ",", "pSet", "=", "'all'", ")", ":", "\n", "        ", "'''\n            Set tree edges with the vector pEdgeWeightsVec\n        '''", "\n", "if", "pSet", "==", "'all'", ":", "# set Weight, Bias, and Function params", "\n", "            ", "indx", "=", "0", "\n", "# setting roots function parameters only for regeression problem", "\n", "if", "p_target_attr_count", "==", "1", ":", "\n", "# ROOT  NODE's bias and parameter only usefull in regression problems", "\n", "                ", "self", ".", "m_root", ".", "setBias", "(", "pParameters", "[", "indx", "]", ")", "# SET ROOT's BIAS", "\n", "indx", "+=", "1", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "m_root", ".", "m_FunctionParams", ")", "-", "1", ")", ":", "\n", "                    ", "self", ".", "m_root", ".", "m_FunctionParams", "[", "i", "]", "=", "pParameters", "[", "indx", "]", "\n", "indx", "+=", "1", "\n", "# set function node weights and prameters a, b from the function list", "\n", "", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# SET nodes weights", "\n", "                ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# For single output problem child weights were taken so will be set", "\n", "                    ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "", "else", ":", "\n", "# For multi output problem problem only non roots child weights were taken ", "\n", "# so only non roots child weight will be set", "\n", "                    ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# SET Weight only for node NOT IN ROOT CHILD -> ok", "\n", "                        ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "\n", "# check if node is NOT Gausian", "\n", "", "", "funParams", "=", "node", ".", "m_FunctionParams", "\n", "if", "(", "not", "funParams", ".", "__contains__", "(", "'Gaussian'", ")", ")", ":", "\n", "# SET nodes bias", "\n", "                    ", "node", ".", "setBias", "(", "pParameters", "[", "indx", "]", ")", "# SET ROOT BIAS", "\n", "indx", "+=", "1", "\n", "\n", "#SET nodes function params", "\n", "", "for", "i", "in", "range", "(", "0", ",", "len", "(", "self", ".", "m_root", ".", "m_FunctionParams", ")", "-", "1", ")", ":", "\n", "                    ", "node", ".", "m_FunctionParams", "[", "i", "]", "=", "pParameters", "[", "indx", "]", "\n", "indx", "+=", "1", "\n", "\n", "# set leaf node weights", "\n", "", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "                ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "\n", "", "", "if", "pSet", "==", "'weights_and_bias'", ":", "\n", "            ", "indx", "=", "0", "\n", "if", "p_target_attr_count", "==", "1", ":", "\n", "# ROOT  NODE's bias and parameter only usefull in regression problems", "\n", "                ", "self", ".", "m_root", ".", "setBias", "(", "pParameters", "[", "indx", "]", ")", "# SET ROOT's BIAS", "\n", "indx", "+=", "1", "\n", "# set node weights ", "\n", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# SET nodes weights", "\n", "                ", "if", "p_target_attr_count", "==", "1", ":", "# for regression problem child weights were taken so will be set", "\n", "                    ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "", "else", ":", "# if classification problem only take non roots child weights", "\n", "                    ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# SET Weight only for node NOT IN ROOT CHILD -> ok", "\n", "                        ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "# SET nodes bias", "\n", "", "", "node", ".", "setBias", "(", "pParameters", "[", "indx", "]", ")", "# SET ROOT BIAS", "\n", "indx", "+=", "1", "\n", "# set leaf node weights", "\n", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "                ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "\n", "", "", "if", "pSet", "==", "'weights'", ":", "\n", "            ", "indx", "=", "0", "\n", "# set node weights ", "\n", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# SET nodes weights", "\n", "                ", "if", "p_target_attr_count", "==", "1", ":", "# for regression problem child weights were taken so will be set", "\n", "                    ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "", "else", ":", "# if classification problem only take non roots child weights", "\n", "                    ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# SET Weight only for node NOT IN ROOT CHILD -> ok", "\n", "                        ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "\n", "# set leaf node weights", "\n", "", "", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "                ", "node", ".", "setEdgeWeight", "(", "pParameters", "[", "indx", "]", ")", "\n", "indx", "+=", "1", "\n", "\n", "", "", "if", "pSet", "==", "'bias'", ":", "\n", "            ", "indx", "=", "0", "\n", "if", "p_target_attr_count", "==", "1", ":", "\n", "# ROOT  NODE's bias and parameter only usefull in regression problems", "\n", "                ", "self", ".", "m_root", ".", "setBias", "(", "pParameters", "[", "indx", "]", ")", "# SET ROOT's BIAS", "\n", "indx", "+=", "1", "\n", "# set node weights ", "\n", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# SET nodes bias", "\n", "                ", "node", ".", "setBias", "(", "pParameters", "[", "indx", "]", ")", "# SET ROOT BIAS", "\n", "indx", "+=", "1", "\n", "#END of function setWeight", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getGradient": [[594, 608], ["neural_tree.NeuralTree.getOutput", "neural_tree.NeuralTree.setDeltaJ", "neural_tree.NeuralTree.setGradient", "neural_tree.NeuralTree.getDeltaWeightandBias", "type"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getOutput", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDeltaJ", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getDeltaWeightandBias"], ["", "", "", "def", "getGradient", "(", "self", ",", "x", ",", "y", ",", "p_target_attr_count", ")", ":", "\n", "        ", "ypred", "=", "self", ".", "getOutput", "(", "x", ",", "p_target_attr_count", ")", "\n", "#print('y_pred: ', ypred, y, type(ypred), type(y))", "\n", "if", "(", "type", "(", "ypred", ")", "is", "not", "list", ")", ":", "\n", "            ", "ypred", "=", "[", "ypred", "]", "\n", "y", "=", "[", "y", "]", "\n", "\n", "#if p_target_attr_count > 1:", "\n", "#    ypred = self.softmax(ypred)", "\n", "#print(ypred[0])", "\n", "\n", "", "self", ".", "setDeltaJ", "(", "y", ",", "ypred", ",", "p_target_attr_count", ")", "\n", "self", ".", "setGradient", "(", "x", ",", "p_target_attr_count", ")", "\n", "return", "self", ".", "getDeltaWeightandBias", "(", "p_target_attr_count", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.softmax": [[610, 613], ["numpy.exp", "numpy.sum"], "methods", ["None"], ["", "def", "softmax", "(", "self", ",", "x", ")", ":", "\n", "        ", "exps", "=", "np", ".", "exp", "(", "x", ")", "\n", "return", "exps", "/", "np", ".", "sum", "(", "exps", ")", "\n", "#----------------------------------------------------------------------------------------------------------", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDeltaJ": [[614, 630], ["neural_tree.NeuralTree.m_root.setDeltaJ", "node.setDeltaJ", "neural_tree.NeuralTree.m_root.m_ChildrenList.index"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDeltaJ", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDeltaJ"], ["", "def", "setDeltaJ", "(", "self", ",", "y", ",", "ypred", ",", "p_target_attr_count", ")", ":", "\n", "        ", "'''\n            Setting delta_j of each function node of the tree\n            param:  x                       input example vector \n            param:  y                       output vector (target)\n            param:  y_pred                  tree output vector \n            param:  p_target_attr_count        target columns number - equivalent to number of classes\n        '''", "\n", "if", "p_target_attr_count", "==", "1", ":", "\n", "# Root node delta j is only useful for single output problems", "\n", "#print('root delta: ')", "\n", "            ", "self", ".", "m_root", ".", "setDeltaJ", "(", "y", ",", "ypred", ",", "0", ",", "True", ")", "\n", "", "else", ":", "\n", "            ", "for", "node", "in", "self", ".", "m_root", ".", "m_ChildrenList", ":", "\n", "#print('root ',  self.m_root.m_ChildrenList.index(node),' delta: ')", "\n", "                ", "node", ".", "setDeltaJ", "(", "y", ",", "ypred", ",", "self", ".", "m_root", ".", "m_ChildrenList", ".", "index", "(", "node", ")", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setGradient": [[633, 663], ["neural_tree.NeuralTree.m_root.setGradient", "node.setGradient", "node.setGradient", "node.setGradient", "node.setGradient"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient"], ["", "", "", "def", "setGradient", "(", "self", ",", "x", ",", "p_target_attr_count", ")", ":", "\n", "        ", "'''\n            Setting delta_j of each function node of the tree\n            param:  p_target_attr_count        target columns number - equivalent to number of classes\n        '''", "\n", "if", "p_target_attr_count", "==", "1", ":", "\n", "# No need to use gradient of weight for the output node but gradient of bias is necessary", "\n", "            ", "self", ".", "m_root", ".", "setGradient", "(", "[", "]", ",", "False", ")", "# for output nodes we set only bias -so set both w and b = False", "\n", "#print('delta_j',self.m_root.m_delta_j)", "\n", "\n", "# For all function node of the root node ", "\n", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "#print('delta_j',node.m_parent_node.m_delta_j)", "\n", "            ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# for single output problem, all child (of root) takes weight and biad. ", "\n", "# Hence we set delta_weight and delta_bias ", "\n", "                ", "node", ".", "setGradient", "(", ")", "\n", "", "else", ":", "\n", "# if multi output problem only set non roots child take weights and bias. ", "\n", "# Hence we set delta weights and delta_bias", "\n", "                ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# NOT IN ROOT CHILD -> ok", "\n", "# for NON OUTPUT nodes delta_weight and delta_bias are nececcary", "\n", "                    ", "node", ".", "setGradient", "(", ")", "\n", "", "else", ":", "\n", "# for OUTPUT nodes only delta_bias are nececcary", "\n", "                    ", "node", ".", "setGradient", "(", "[", "]", ",", "False", ")", "# for output nodes we set only bias -soe set both w and b = False", "\n", "\n", "# For all leaf node only weights are necessary", "\n", "", "", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "            ", "node", ".", "setGradient", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getDeltaWeightandBias": [[665, 689], ["nGrad.append", "nGrad.append", "nGrad.append", "neural_tree.NeuralTree.m_root.getDeltaBias", "nGrad.append", "node.getDeltaBias", "node.getDeltaEdgeWeight", "node.getDeltaEdgeWeight", "nGrad.append", "node.getDeltaEdgeWeight"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getDeltaBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.function_node.FunctionNode.getDeltaBias", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getDeltaEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getDeltaEdgeWeight", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getDeltaEdgeWeight"], ["", "", "def", "getDeltaWeightandBias", "(", "self", ",", "p_target_attr_count", ")", ":", "\n", "        ", "nGrad", "=", "[", "]", "\n", "if", "p_target_attr_count", "==", "1", ":", "\n", "# NO WEIGHT only # TAKE ROOT BIAS", "\n", "            ", "nGrad", ".", "append", "(", "self", ".", "m_root", ".", "getDeltaBias", "(", ")", ")", "\n", "\n", "# retrive fnction node weights and prameters a, b from the function list", "\n", "", "for", "node", "in", "self", ".", "FunNodesList", ":", "\n", "# Retriving weights", "\n", "            ", "if", "p_target_attr_count", "==", "1", ":", "\n", "# for single output problem take all its child weights", "\n", "                ", "nGrad", ".", "append", "(", "node", ".", "getDeltaEdgeWeight", "(", ")", ")", "\n", "", "else", ":", "\n", "# for multi output  problem only take non roots child weights", "\n", "                ", "if", "(", "node", "not", "in", "self", ".", "m_root", ".", "m_ChildrenList", ")", ":", "# NOT IN ROOT CHILD -> ok", "\n", "                    ", "nGrad", ".", "append", "(", "node", ".", "getDeltaEdgeWeight", "(", ")", ")", "# TAKE WEIGHTS ONLY for NON OUTPUT NODE", "\n", "# Retriving bias for all function nodes", "\n", "", "", "nGrad", ".", "append", "(", "node", ".", "getDeltaBias", "(", ")", ")", "# TAKE NODE's BIAS", "\n", "\n", "# retrive leaf node weights - it has no bias", "\n", "", "for", "node", "in", "self", ".", "LeafNodesList", ":", "\n", "            ", "nGrad", ".", "append", "(", "node", ".", "getDeltaEdgeWeight", "(", ")", ")", "\n", "\n", "", "return", "nGrad", "", "", "", ""]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.__init__": [[14, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "p_weight", ",", "p_input_attr", ",", "p_parent_node", ")", ":", "\n", "        ", "'''\n            Genrating a leaf node through its constructor\n                :parm    m_weight           weigth of the eadge connecting leaf node\n                :parm    m_input            the input attribute to be considered at the leaf node\n                :parm    m_parent_node      parent node of the leaf node\n        \n        '''", "\n", "self", ".", "m_edge_weight", "=", "p_weight", "\n", "self", ".", "m_input_attr", "=", "p_input_attr", ";", "\n", "self", ".", "m_parent_node", "=", "p_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.isLeaf": [[27, 31], ["print"], "methods", ["None"], ["", "def", "isLeaf", "(", "self", ",", "p_toPrintNodeType", "=", "False", ")", ":", "\n", "        ", "if", "(", "p_toPrintNodeType", ")", ":", "\n", "            ", "print", "(", "'Leaf node'", ")", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.print_node": [[33, 44], ["range", "print", "str"], "methods", ["None"], ["", "def", "print_node", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Printing only leaf nodes (returnining leaf node string)\n                :param p_depth    current depth of the tree\n        '''", "\n", "for", "i", "in", "range", "(", "p_depth", ")", ":", "\n", "            ", "if", "(", "False", ")", ":", "\n", "                ", "print", "(", "\"-\"", ",", "end", "=", "\" \"", ")", "\n", "\n", "#print(\" :\" + str(self.m_input_attr))", "\n", "", "", "return", "\"\\\"name\\\":\"", "+", "\"\\\" i \"", "+", "str", "(", "self", ".", "m_input_attr", ")", "+", "\"\\\" }\"", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.saveNode": [[45, 56], ["range", "print", "str", "str"], "methods", ["None"], ["", "def", "saveNode", "(", "self", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Printing only leaf nodes (returnining leaf node string)\n                :param p_depth    current depth of the tree\n        '''", "\n", "for", "i", "in", "range", "(", "p_depth", ")", ":", "\n", "            ", "if", "(", "False", ")", ":", "\n", "                ", "print", "(", "\"-\"", ",", "end", "=", "\" \"", ")", "\n", "\n", "#print(\" :\" + str(self.m_input_attr))", "\n", "", "", "return", "\"\\\"name\\\":\"", "+", "\"\\\" i:\"", "+", "str", "(", "self", ".", "m_input_attr", ")", "+", "\"; e:\"", "+", "str", "(", "self", ".", "m_edge_weight", ")", "+", "\"\\\" }\"", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.inspect_node": [[57, 66], ["p_tree.getDepth", "p_tree.setDepth"], "methods", ["home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.getDepth", "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.neural_tree.NeuralTree.setDepth"], ["", "def", "inspect_node", "(", "self", ",", "p_tree", ",", "p_depth", ")", ":", "\n", "        ", "'''\n            Inpects current function node\n                :parame   p_tree        tree passed as a paramter\n                :param    p_depth       current depth of the tree\n            \n        '''", "\n", "if", "(", "p_depth", ">", "p_tree", ".", "getDepth", "(", ")", ")", ":", "\n", "            ", "p_tree", ".", "setDepth", "(", "p_depth", ")", "\n", "# end inspect node (leaf)    ", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.copyNode": [[68, 75], ["leaf_node.LeafNode"], "methods", ["None"], ["", "", "def", "copyNode", "(", "self", ",", "p_node", ")", ":", "\n", "        ", "'''\n            return leaf node copy with its parent node being p_node\n        '''", "\n", "#new object of leaf node", "\n", "node", "=", "LeafNode", "(", "self", ".", "m_edge_weight", ",", "self", ".", "m_input_attr", ",", "p_node", ")", "\n", "return", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setInputAttribute": [[76, 81], ["None"], "methods", ["None"], ["", "def", "setInputAttribute", "(", "self", ",", "p_input_attr", ")", ":", "\n", "        ", "'''\n            Replacing previous input attrivute number wth p_input_attr\n        '''", "\n", "self", ".", "m_input_attr", "=", "p_input_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getInputAttribute": [[82, 87], ["None"], "methods", ["None"], ["", "def", "getInputAttribute", "(", "self", ")", ":", "\n", "        ", "'''\n            Returning the leaf node input attr index\n        '''", "\n", "return", "self", ".", "m_input_attr", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getParentNode": [[89, 94], ["None"], "methods", ["None"], ["", "def", "getParentNode", "(", "self", ")", ":", "\n", "        ", "'''\n            Refturn parent node information\n        '''", "\n", "return", "self", ".", "m_parent_node", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getEdgeWeight": [[95, 100], ["None"], "methods", ["None"], ["", "def", "getEdgeWeight", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_edge_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getDeltaEdgeWeight": [[101, 106], ["None"], "methods", ["None"], ["", "def", "getDeltaEdgeWeight", "(", "self", ")", ":", "\n", "        ", "'''\n            Return edge weight of the node\n        '''", "\n", "return", "self", ".", "m_delta_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setEdgeWeight": [[107, 112], ["None"], "methods", ["None"], ["", "def", "setEdgeWeight", "(", "self", ",", "pEdgeWeight", ")", ":", "\n", "        ", "'''\n            Setting wedge weight\n        '''", "\n", "self", ".", "m_edge_weight", "=", "pEdgeWeight", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.getSingleNodeOutput": [[113, 119], ["None"], "methods", ["None"], ["", "def", "getSingleNodeOutput", "(", "self", ",", "p_input_attr_val", ")", ":", "\n", "        ", "'''\n            Return value of the value at the index m_input_attr from the leaf node \n            param:    p_input_attr_val    input vector \n        '''", "\n", "return", "p_input_attr_val", "[", "self", ".", "m_input_attr", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.vojha-code_multi-output-neural-tree.tree.leaf_node.LeafNode.setGradient": [[120, 127], ["None"], "methods", ["None"], ["", "def", "setGradient", "(", "self", ",", "p_input_attr_val", "=", "[", "]", ",", "both_w_n_b", "=", "True", ")", ":", "\n", "        ", "'''\n            for Leaf node node gradient of weight has its own input value as the input\n        '''", "\n", "xi", "=", "p_input_attr_val", "[", "self", ".", "m_input_attr", "]", "#  inut to the next layer", "\n", "del_j", "=", "self", ".", "m_parent_node", ".", "m_delta_j", "#  delta_j of the next layer (gradient of the parent node)", "\n", "self", ".", "m_delta_weight", "=", "del_j", "*", "xi", "\n", "", "", ""]]}