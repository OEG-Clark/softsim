{"home.repos.pwc.inspect_result.koustuvsinha_clutrr.None.generator.generate_rows": [[15, 54], ["tqdm.tqdm", "range", "tqdm.tqdm.close", "print", "actors.ancestry.Ancestry", "relations.builder.RelationBuilder", "relations.builder.RelationBuilder.init_family", "relations.builder.RelationBuilder.make_single_story", "stories.extend", "abstracts.extend", "relation_paths.extend", "len", "random.sample", "rows.append", "tqdm.tqdm.update", "len", "len"], "function", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.init_family", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.make_single_story"], ["def", "generate_rows", "(", "args", ")", ":", "\n", "# generate", "\n", "    ", "pb", "=", "tqdm", "(", "total", "=", "args", ".", "num_rows", ")", "\n", "num_stories", "=", "args", ".", "num_rows", "\n", "stories_left", "=", "num_stories", "\n", "stories", "=", "[", "]", "\n", "abstracts", "=", "[", "]", "\n", "relation_paths", "=", "[", "]", "\n", "anc_num", "=", "0", "\n", "while", "stories_left", ">", "0", ":", "\n", "        ", "anc_num", "+=", "1", "\n", "anc", "=", "Ancestry", "(", "max_levels", "=", "args", ".", "max_levels", ",", "\n", "min_child", "=", "args", ".", "min_child", ",", "\n", "max_child", "=", "args", ".", "max_child", ",", "\n", "relationship_type", "=", "store", ".", "relationship_type", ")", "\n", "rb", "=", "RelationBuilder", "(", "boundary", "=", "args", ".", "boundary", ",", "\n", "min_distractor_relations", "=", "args", ".", "min_distractor_relations", ",", "\n", "backward", "=", "args", ".", "backward", ")", "\n", "rb", ".", "init_family", "(", "anc", ")", "\n", "sts", ",", "abs", ",", "relp", "=", "rb", ".", "make_single_story", "(", "args", ".", "relation_length", ",", "stories_left", ")", "\n", "stories", ".", "extend", "(", "sts", ")", "\n", "abstracts", ".", "extend", "(", "abs", ")", "\n", "relation_paths", ".", "extend", "(", "relp", ")", "\n", "stories_left", "=", "num_stories", "-", "len", "(", "stories", ")", "\n", "\n", "", "rows", "=", "[", "]", "\n", "# aggregating", "\n", "for", "sindx", "in", "range", "(", "len", "(", "stories", ")", ")", ":", "\n", "        ", "if", "sindx", ">", "num_stories", ":", "\n", "            ", "break", "\n", "", "story", "=", "stories", "[", "sindx", "]", "\n", "# shuffle the story", "\n", "story", "=", "random", ".", "sample", "(", "story", ",", "len", "(", "story", ")", ")", "\n", "story", "=", "'. '", ".", "join", "(", "story", ")", "+", "'.'", "\n", "rows", ".", "append", "(", "[", "story", ",", "abstracts", "[", "sindx", "]", ",", "relation_paths", "[", "sindx", "]", "]", ")", "\n", "pb", ".", "update", "(", "1", ")", "\n", "", "pb", ".", "close", "(", ")", "\n", "print", "(", "\"{} ancestries created\"", ".", "format", "(", "anc_num", ")", ")", "\n", "return", "rows", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.None.generator.current_config_path_stats": [[56, 99], ["actors.ancestry.Ancestry", "relations.builder.RelationBuilder", "relations.builder.RelationBuilder.init_family", "relations.builder.RelationBuilder.calc_all_pairs", "path_rel.items", "len", "range", "path_rel[].append", "print", "set", "print", "print", "pprint.pprint", "len", "relations.builder.RelationBuilder.connected_forward.has_edge", "len"], "function", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.init_family", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.calc_all_pairs"], ["", "def", "current_config_path_stats", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Calculate the max path for the current configuration\n    :return:\n    \"\"\"", "\n", "anc", "=", "Ancestry", "(", "max_levels", "=", "args", ".", "max_levels", ",", "\n", "min_child", "=", "args", ".", "min_child", ",", "\n", "max_child", "=", "args", ".", "max_child", ",", "\n", "relationship_type", "=", "store", ".", "relationship_type", ")", "\n", "taken_names", "=", "anc", ".", "taken_names", "\n", "rb", "=", "RelationBuilder", "(", "boundary", "=", "args", ".", "boundary", ",", "\n", "min_distractor_relations", "=", "args", ".", "min_distractor_relations", ",", "\n", "backward", "=", "args", ".", "backward", ")", "\n", "rb", ".", "init_family", "(", "anc", ")", "\n", "all_paths", ",", "path_stats", "=", "rb", ".", "calc_all_pairs", "(", "num_relations", "=", "args", ".", "relation_length", ")", "\n", "path_rel", "=", "{", "}", "\n", "for", "path", "in", "all_paths", ":", "\n", "        ", "long_path", "=", "path", "[", "2", "]", "\n", "len_long_path", "=", "len", "(", "long_path", ")", "\n", "if", "len_long_path", "not", "in", "path_rel", ":", "\n", "            ", "path_rel", "[", "len_long_path", "]", "=", "[", "]", "\n", "", "path_str", "=", "''", "\n", "for", "mi", "in", "range", "(", "len_long_path", "-", "1", ")", ":", "\n", "            ", "na", "=", "long_path", "[", "mi", "]", "\n", "nb", "=", "long_path", "[", "mi", "+", "1", "]", "\n", "weight", "=", "rb", ".", "inv_rel_type", "[", "rb", ".", "connected_family", "[", "na", "]", "[", "nb", "]", "[", "'weight'", "]", "]", "\n", "if", "not", "rb", ".", "connected_forward", ".", "has_edge", "(", "na", ",", "nb", ")", "and", "weight", "not", "in", "[", "'sibling'", ",", "'SO'", "]", ":", "\n", "                ", "weight", "=", "'inv-'", "+", "weight", "\n", "", "path_str", "+=", "' -- <{}> -- '", ".", "format", "(", "weight", ")", "\n", "", "nb", "=", "long_path", "[", "len_long_path", "-", "1", "]", "\n", "fw", "=", "rb", ".", "inv_rel_type", "[", "rb", ".", "connected_family", "[", "long_path", "[", "0", "]", "]", "[", "nb", "]", "[", "'weight'", "]", "]", "\n", "path_str", "+=", "' ===> {}'", ".", "format", "(", "fw", ")", "\n", "path_rel", "[", "len_long_path", "]", ".", "append", "(", "path_str", ")", "\n", "", "for", "key", ",", "val", "in", "path_rel", ".", "items", "(", ")", ":", "\n", "        ", "print", "(", "\"Relation length : {}\"", ".", "format", "(", "key", "-", "1", ")", ")", "\n", "uniq_paths", "=", "set", "(", "val", ")", "\n", "print", "(", "\"Unique paths : {}\"", ".", "format", "(", "len", "(", "uniq_paths", ")", ")", ")", "\n", "print", "(", "\"With gender : {}\"", ".", "format", "(", "len", "(", "uniq_paths", ")", "*", "2", ")", ")", "\n", "if", "args", ".", "verbose", ":", "\n", "            ", "pprint", ".", "pprint", "(", "uniq_paths", ")", "\n", "#for up in uniq_paths:", "\n", "#    print(up, val.count(up))", "\n", "", "", "return", "path_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.None.args.get_args": [[3, 21], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "\"--num_rows\"", ",", "default", "=", "5000", ",", "type", "=", "int", ",", "help", "=", "'number of rows'", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_levels\"", ",", "default", "=", "3", ",", "type", "=", "int", ",", "help", "=", "\"max number of levels\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--min_child\"", ",", "default", "=", "3", ",", "type", "=", "int", ",", "help", "=", "\"max number of children per node\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--max_child\"", ",", "default", "=", "3", ",", "type", "=", "int", ",", "help", "=", "\"max number of children per node\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--abstracts\"", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "\"Abstract lines per relation\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--boundary\"", ",", "default", "=", "True", ",", "action", "=", "'store_true'", ",", "help", "=", "'Boundary in entities'", ")", "\n", "parser", ".", "add_argument", "(", "\"--output\"", ",", "default", "=", "\"gen_m3\"", ",", "type", "=", "str", ",", "help", "=", "'Prefix of the output file'", ")", "\n", "parser", ".", "add_argument", "(", "\"--min_distractor_relations\"", ",", "default", "=", "8", ",", "type", "=", "int", ",", "help", "=", "\"Distractor relations about entities\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--relation_length\"", ",", "default", "=", "3", ",", "type", "=", "int", ",", "help", "=", "\"Max relation path length\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--backward\"", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ",", "help", "=", "'if true then consider backward paths too'", ")", "\n", "parser", ".", "add_argument", "(", "\"--train_test_split\"", ",", "default", "=", "0.8", ",", "type", "=", "float", ",", "help", "=", "\"Training and testing split\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--calc\"", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ",", "help", "=", "\"Calculate max path\"", ")", "\n", "parser", ".", "add_argument", "(", "\"-v\"", ",", "\"--verbose\"", ",", "default", "=", "False", ",", "action", "=", "'store_true'", ",", "\n", "help", "=", "'print the paths'", ")", "\n", "\n", "return", "parser", ".", "parse_args", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.pairwise": [[7, 16], ["itertools.tee", "next", "zip"], "function", ["None"], ["def", "pairwise", "(", "iterable", ")", ":", "\n", "    ", "\"\"\"\n    Recipe from itertools\n    :param iterable:\n    :return: \"s -> (s0,s1), (s1,s2), (s2, s3), ...\"\n    \"\"\"", "\n", "a", ",", "b", "=", "it", ".", "tee", "(", "iterable", ")", "\n", "next", "(", "b", ",", "None", ")", "\n", "return", "zip", "(", "a", ",", "b", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.prob_dist": [[17, 25], ["row_dict[].append", "len", "len", "row_dict.items"], "function", ["None"], ["", "def", "prob_dist", "(", "rows", ")", ":", "\n", "    ", "row_dict", "=", "{", "}", "\n", "for", "row", "in", "rows", ":", "\n", "        ", "if", "row", "[", "-", "1", "]", "not", "in", "row_dict", ":", "\n", "            ", "row_dict", "[", "row", "[", "-", "1", "]", "]", "=", "[", "]", "\n", "", "row_dict", "[", "row", "[", "-", "1", "]", "]", ".", "append", "(", "row", "[", ":", "2", "]", ")", "\n", "", "rel_probs", "=", "{", "k", ":", "(", "len", "(", "v", ")", "/", "len", "(", "rows", ")", ")", "for", "k", ",", "v", "in", "row_dict", ".", "items", "(", ")", "}", "\n", "return", "rel_probs", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.split_train_test": [[26, 43], ["utils.prob_dist", "range", "numpy.random.choice", "utils.prob_dist", "utils.prob_dist", "len", "int", "len", "set", "set"], "function", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.prob_dist", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.prob_dist", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.prob_dist"], ["", "def", "split_train_test", "(", "args", ",", "rows", ")", ":", "\n", "# split training testing", "\n", "    ", "r1", "=", "prob_dist", "(", "rows", ")", "\n", "indices", "=", "range", "(", "len", "(", "rows", ")", ")", "\n", "mask_i", "=", "np", ".", "random", ".", "choice", "(", "indices", ",", "\n", "int", "(", "len", "(", "indices", ")", "*", "args", ".", "train_test_split", ")", ",", "\n", "replace", "=", "False", ")", "\n", "test_indices", "=", "[", "i", "for", "i", "in", "indices", "if", "i", "not", "in", "set", "(", "mask_i", ")", "]", "\n", "train_indices", "=", "[", "i", "for", "i", "in", "indices", "if", "i", "in", "set", "(", "mask_i", ")", "]", "\n", "train_rows", "=", "[", "rows", "[", "ti", "]", "for", "ti", "in", "train_indices", "]", "\n", "r_train", "=", "prob_dist", "(", "train_rows", ")", "\n", "test_rows", "=", "[", "rows", "[", "ti", "]", "for", "ti", "in", "test_indices", "]", "\n", "r_test", "=", "prob_dist", "(", "test_rows", ")", "\n", "train_rows", "=", "[", "row", "[", ":", "-", "1", "]", "for", "row", "in", "train_rows", "]", "\n", "test_rows", "=", "[", "row", "[", ":", "-", "1", "]", "for", "row", "in", "test_rows", "]", "\n", "\n", "return", "train_rows", ",", "test_rows", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.write2file": [[44, 52], ["open", "vars", "csv.writer", "csv.writer.writerow", "fp.write", "csv.writer.writerow", "getattr"], "function", ["None"], ["", "def", "write2file", "(", "args", ",", "rows", ",", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "for", "argi", "in", "vars", "(", "args", ")", ":", "\n", "            ", "fp", ".", "write", "(", "'# {} {}\\n'", ".", "format", "(", "argi", ",", "getattr", "(", "args", ",", "argi", ")", ")", ")", "\n", "", "writer", "=", "csv", ".", "writer", "(", "fp", ")", "\n", "writer", ".", "writerow", "(", "[", "'story'", ",", "'summary'", "]", ")", "\n", "for", "row", "in", "rows", ":", "\n", "            ", "writer", ".", "writerow", "(", "row", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.sanity_check": [[53, 58], ["pandas.read_csv", "print", "len", "len", "len"], "function", ["None"], ["", "", "", "def", "sanity_check", "(", "filename", ",", "rows", ")", ":", "\n", "## sanity check", "\n", "    ", "df", "=", "pd", ".", "read_csv", "(", "filename", ",", "skip_blank_lines", "=", "True", ",", "comment", "=", "'#'", ")", "\n", "print", "(", "'Total rows : {}'", ".", "format", "(", "len", "(", "df", ")", ")", ")", "\n", "assert", "len", "(", "rows", ")", "==", "len", "(", "df", ")", "", "", ""]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.__init__": [[16, 32], ["store.relationship_type.items"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "boundary", "=", "False", ",", "\n", "min_distractor_relations", "=", "3", ",", "\n", "backward", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Initialize relationbuilder class with a relationship file\n        :param relations_file: json file containing relationship placeholders\n        :param boundary: if True then put borders around name: `[name]`\n        :param backward: if true, then connect nodes in both directions\n        \"\"\"", "\n", "self", ".", "relations_obj", "=", "store", ".", "relations_store", "\n", "self", ".", "inv_rel_type", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "store", ".", "relationship_type", ".", "items", "(", ")", "}", "\n", "self", ".", "family", "=", "None", "\n", "self", ".", "siblings", "=", "[", "]", "\n", "self", ".", "boundary", "=", "boundary", "\n", "self", ".", "backward", "=", "backward", "\n", "self", ".", "min_distractor_relations", "=", "min_distractor_relations", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.init_family": [[33, 42], ["builder.RelationBuilder.extract_siblings", "builder.RelationBuilder.connect_everyone"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.extract_siblings", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.connect_everyone"], ["", "def", "init_family", "(", "self", ",", "anc", ")", ":", "\n", "        ", "\"\"\"\n        Initial family\n        :param anc: Ancestry object\n        :return: None\n        \"\"\"", "\n", "self", ".", "family", "=", "anc", ".", "family", "\n", "self", ".", "siblings", "=", "self", ".", "extract_siblings", "(", ")", "\n", "self", ".", "connect_everyone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.connect_everyone": [[43, 66], ["list", "networkx.DiGraph", "networkx.DiGraph", "itertools.combinations", "networkx.dfs_preorder_nodes", "networkx.Graph", "builder.RelationBuilder.get_weight", "networkx.Graph.add_edge", "networkx.DiGraph.add_edge", "networkx.Graph.add_node", "networkx.DiGraph.add_node", "networkx.Graph.add_node", "networkx.DiGraph.add_node"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.get_weight"], ["", "def", "connect_everyone", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Convert the family tree into a almost fully connected graph by calculating the relations\n        :return:\n        \"\"\"", "\n", "nodes", "=", "list", "(", "nx", ".", "dfs_preorder_nodes", "(", "self", ".", "family", ",", "0", ")", ")", "\n", "connected_graph", "=", "nx", ".", "DiGraph", "(", ")", "\n", "connected_forward_graph", "=", "nx", ".", "DiGraph", "(", ")", "\n", "if", "self", ".", "backward", ":", "\n", "            ", "connected_graph", "=", "nx", ".", "Graph", "(", ")", "\n", "", "for", "node_a", ",", "node_b", "in", "it", ".", "combinations", "(", "nodes", ",", "2", ")", ":", "\n", "            ", "weight", "=", "self", ".", "get_weight", "(", "node_a", ",", "node_b", ")", "\n", "if", "weight", ">=", "0", "and", "weight", "in", "self", ".", "inv_rel_type", ":", "\n", "                ", "if", "node_a", "not", "in", "connected_graph", ":", "\n", "                    ", "connected_graph", ".", "add_node", "(", "node_a", ",", "data", "=", "self", ".", "family", ".", "node", "[", "node_a", "]", "[", "'data'", "]", ")", "\n", "connected_forward_graph", ".", "add_node", "(", "node_a", ",", "data", "=", "self", ".", "family", ".", "node", "[", "node_a", "]", "[", "'data'", "]", ")", "\n", "", "if", "node_b", "not", "in", "connected_graph", ":", "\n", "                    ", "connected_graph", ".", "add_node", "(", "node_b", ",", "data", "=", "self", ".", "family", ".", "node", "[", "node_b", "]", "[", "'data'", "]", ")", "\n", "connected_forward_graph", ".", "add_node", "(", "node_b", ",", "data", "=", "self", ".", "family", ".", "node", "[", "node_b", "]", "[", "'data'", "]", ")", "\n", "", "connected_graph", ".", "add_edge", "(", "node_a", ",", "node_b", ",", "weight", "=", "weight", ")", "\n", "connected_forward_graph", ".", "add_edge", "(", "node_a", ",", "node_b", ",", "weight", "=", "weight", ")", "\n", "", "", "self", ".", "connected_family", "=", "connected_graph", "\n", "self", ".", "connected_forward", "=", "connected_forward_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.get_weight": [[67, 92], ["networkx.shortest_path", "len", "sum", "utils.utils.pairwise"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.pairwise"], ["", "def", "get_weight", "(", "self", ",", "node_a", ",", "node_b", ")", ":", "\n", "        ", "\"\"\"\n        Given two nodes of a graph, build a relation text from the store\n        :param node_a: networkx node, e_1\n        :param node_b: networkx node, e_2\n        :return: weight of the relation\n        \"\"\"", "\n", "# determine the relation", "\n", "try", ":", "\n", "            ", "path", "=", "nx", ".", "shortest_path", "(", "self", ".", "family", ",", "node_a", ",", "node_b", ")", "\n", "if", "len", "(", "path", ")", "==", "2", ":", "\n", "# direct path", "\n", "                ", "weight", "=", "self", ".", "family", "[", "node_a", "]", "[", "node_b", "]", "[", "'weight'", "]", "\n", "return", "weight", "\n", "", "else", ":", "\n", "# indirect path", "\n", "                ", "weight", "=", "sum", "(", "[", "self", ".", "family", "[", "na", "]", "[", "nb", "]", "[", "'weight'", "]", "for", "na", ",", "nb", "in", "pairwise", "(", "path", ")", "]", ")", "\n", "return", "weight", "\n", "", "", "except", "nx", ".", "NetworkXNoPath", "as", "e", ":", "\n", "# no direct path exists, check if they are siblings", "\n", "            ", "for", "sibling", "in", "self", ".", "siblings", ":", "\n", "                ", "if", "node_a", "in", "sibling", "and", "node_b", "in", "sibling", ":", "\n", "                    ", "weight", "=", "0", "\n", "return", "weight", "\n", "", "", "return", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.stringify": [[94, 128], ["random.choice", "random.choice.replace", "text.replace.replace.replace", "builder.RelationBuilder.connected_forward.has_edge"], "methods", ["None"], ["", "", "def", "stringify", "(", "self", ",", "node_a", ",", "node_b", ")", ":", "\n", "        ", "\"\"\"\n        Stitch together relationships\n        :param node_a:\n        :param node_b:\n        :return:\n        \"\"\"", "\n", "# if edge (node_a -> node_b) is not present in forward graph,", "\n", "# switch them", "\n", "flip", "=", "False", "\n", "if", "not", "self", ".", "connected_forward", ".", "has_edge", "(", "node_a", ",", "node_b", ")", ":", "\n", "            ", "tmp", "=", "node_a", "\n", "node_a", "=", "node_b", "\n", "node_b", "=", "tmp", "\n", "flip", "=", "True", "\n", "# get node attributes", "\n", "", "node_a_attr", "=", "self", ".", "connected_family", ".", "node", "[", "node_a", "]", "[", "'data'", "]", "\n", "node_b_attr", "=", "self", ".", "connected_family", ".", "node", "[", "node_b", "]", "[", "'data'", "]", "\n", "weight", "=", "self", ".", "connected_family", "[", "node_a", "]", "[", "node_b", "]", "[", "'weight'", "]", "\n", "relation", "=", "self", ".", "inv_rel_type", "[", "weight", "]", "\n", "placeholders", "=", "self", ".", "relations_obj", "[", "relation", "]", "[", "node_b_attr", ".", "gender", "]", "\n", "flip_relation", "=", "relation", "+", "'_rev'", "\n", "if", "flip", "and", "flip_relation", "in", "self", ".", "relations_obj", ":", "\n", "            ", "placeholders", "=", "self", ".", "relations_obj", "[", "flip_relation", "]", "[", "node_a_attr", ".", "gender", "]", "\n", "", "placeholder", "=", "random", ".", "choice", "(", "placeholders", ")", "\n", "node_a_name", "=", "node_a_attr", ".", "name", "\n", "node_b_name", "=", "node_b_attr", ".", "name", "\n", "assert", "node_a_name", "!=", "node_b_name", "\n", "if", "self", ".", "boundary", ":", "\n", "            ", "node_a_name", "=", "'[{}]'", ".", "format", "(", "node_a_name", ")", "\n", "node_b_name", "=", "'[{}]'", ".", "format", "(", "node_b_name", ")", "\n", "", "text", "=", "placeholder", ".", "replace", "(", "'e_1'", ",", "node_a_name", ")", "\n", "text", "=", "text", ".", "replace", "(", "'e_2'", ",", "node_b_name", ")", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.extract_siblings": [[129, 143], ["collections.defaultdict", "builder.RelationBuilder.family.nodes", "collections.defaultdict.values", "lineage[].append", "len", "siblings.append", "frozenset", "frozenset", "builder.RelationBuilder.family.predecessors", "builder.RelationBuilder.family.successors"], "methods", ["None"], ["", "def", "extract_siblings", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Extract the siblings and store them in a variable\n        Source: https://stackoverflow.com/questions/39328963/how-to-identify-unconnected-siblings-in-a-graph\n        :return: None\n        \"\"\"", "\n", "lineage", "=", "defaultdict", "(", "list", ")", "\n", "siblings", "=", "[", "]", "\n", "for", "node", "in", "self", ".", "family", ".", "nodes", "(", ")", ":", "\n", "            ", "lineage", "[", "frozenset", "(", "self", ".", "family", ".", "predecessors", "(", "node", ")", ")", ",", "frozenset", "(", "self", ".", "family", ".", "successors", "(", "node", ")", ")", "]", ".", "append", "(", "node", ")", "\n", "", "for", "i", "in", "lineage", ".", "values", "(", ")", ":", "\n", "            ", "if", "len", "(", "i", ")", ">", "1", ":", "\n", "                ", "siblings", ".", "append", "(", "i", ")", "\n", "", "", "return", "siblings", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.make_story": [[144, 189], ["list.split", "list", "list", "itertools.combinations", "filter", "len", "networkx.dfs_preorder_nodes", "builder.RelationBuilder.get_weight", "random.sample", "NotImplementedError", "random.sample.append", "len", "len", "len", "builder.RelationBuilder.stringify", "story_w[].append", "random.sample.extend", "len", "builder.RelationBuilder.stringify", "len", "random.sample", "len", "len"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.get_weight", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.stringify", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.stringify"], ["", "def", "make_story", "(", "self", ",", "mode", "=", "'story'", ",", "lines", "=", "-", "1", ",", "allowed_relations", "=", "''", ")", ":", "\n", "        ", "\"\"\"\n        Generate story\n        :param mode: if story, only use \"child\" and \"SO\" relations. if abstract, only use \"grand\" and \"sibling\" relations\n        :param allowed_relations: Allowed relations is a string separated by comma on which relations should feature in the abstract\n        :return: text of the story\n        \"\"\"", "\n", "allowed_relations", "=", "allowed_relations", ".", "split", "(", "','", ")", "\n", "allowed_relations", "=", "list", "(", "filter", "(", "None", ",", "allowed_relations", ")", ")", "\n", "if", "len", "(", "allowed_relations", ")", "==", "0", ":", "\n", "            ", "allowed_relations", "=", "[", "'sibling'", ",", "'grand'", ",", "'in-laws'", "]", "\n", "", "allowed_relations", "=", "[", "store", ".", "relationship_type", "[", "ar", "]", "for", "ar", "in", "allowed_relations", "]", "\n", "nodes", "=", "list", "(", "nx", ".", "dfs_preorder_nodes", "(", "self", ".", "family", ",", "0", ")", ")", "\n", "story", "=", "[", "]", "\n", "story_w", "=", "{", "}", "\n", "for", "node_a", ",", "node_b", "in", "it", ".", "combinations", "(", "nodes", ",", "2", ")", ":", "\n", "            ", "node_a_obj", "=", "self", ".", "family", ".", "node", "[", "node_a", "]", "[", "'data'", "]", "\n", "node_b_obj", "=", "self", ".", "family", ".", "node", "[", "node_b", "]", "[", "'data'", "]", "\n", "if", "node_a_obj", ".", "name", "==", "node_b_obj", ".", "name", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\"no same nodes can be in the sentence\"", ")", "\n", "", "weight", "=", "self", ".", "get_weight", "(", "node_a", ",", "node_b", ")", "\n", "if", "mode", "==", "'story'", "and", "weight", "in", "[", "store", ".", "relationship_type", "[", "'SO'", "]", ",", "store", ".", "relationship_type", "[", "'child'", "]", "]", ":", "\n", "                ", "story", ".", "append", "(", "self", ".", "stringify", "(", "node_a_obj", ",", "node_b_obj", ",", "weight", ")", ")", "\n", "", "elif", "mode", "==", "'abstract'", "and", "weight", "in", "allowed_relations", ":", "\n", "                ", "if", "weight", "not", "in", "story_w", ":", "\n", "                    ", "story_w", "[", "weight", "]", "=", "[", "]", "\n", "", "story_w", "[", "weight", "]", ".", "append", "(", "self", ".", "stringify", "(", "node_a_obj", ",", "node_b_obj", ",", "weight", ")", ")", "\n", "", "", "if", "mode", "==", "'abstract'", ":", "\n", "# check if all relations are present", "\n", "            ", "if", "len", "(", "allowed_relations", ")", "!=", "len", "(", "story_w", ")", ":", "\n", "                ", "story", "=", "[", "]", "\n", "", "else", ":", "\n", "                ", "story", "=", "[", "]", "\n", "for", "w", "in", "allowed_relations", ":", "\n", "                    ", "if", "len", "(", "story_w", "[", "w", "]", ")", "<", "lines", ":", "\n", "                        ", "story", "=", "[", "]", "\n", "break", "\n", "", "story", ".", "extend", "(", "random", ".", "sample", "(", "story_w", "[", "w", "]", ",", "lines", ")", ")", "\n", "#story = random.sample(story, lines)", "\n", "", "if", "len", "(", "story", ")", ">", "0", ":", "\n", "                    ", "assert", "len", "(", "story", ")", "==", "lines", "*", "len", "(", "allowed_relations", ")", "\n", "", "", "", "else", ":", "\n", "            ", "story", "=", "random", ".", "sample", "(", "story", ",", "len", "(", "story", ")", ")", "\n", "", "story", "=", "'. '", ".", "join", "(", "story", ")", "\n", "return", "story", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.calc_all_pairs": [[190, 218], ["list", "itertools.combinations", "max", "min", "networkx.dfs_preorder_nodes", "networkx.all_simple_paths", "len", "len", "len", "path_lens.count", "builder.RelationBuilder.connected_family.has_edge", "range", "all_pairs.append"], "methods", ["None"], ["", "def", "calc_all_pairs", "(", "self", ",", "num_relations", "=", "3", ")", ":", "\n", "        ", "\"\"\"\n        Given a connected graph, calculate all possible pairs of\n        paths, i.e all simple paths\n        :return:\n        \"\"\"", "\n", "nodes", "=", "list", "(", "nx", ".", "dfs_preorder_nodes", "(", "self", ".", "connected_family", ",", "0", ")", ")", "\n", "all_pairs", "=", "[", "]", "\n", "for", "node_a", ",", "node_b", "in", "it", ".", "combinations", "(", "nodes", ",", "2", ")", ":", "\n", "            ", "for", "path", "in", "nx", ".", "all_simple_paths", "(", "self", ".", "connected_family", ",", "node_a", ",", "node_b", ",", "cutoff", "=", "num_relations", ")", ":", "\n", "                ", "path_len", "=", "len", "(", "path", ")", "\n", "if", "path_len", "==", "num_relations", "+", "1", ":", "\n", "                    ", "min_path", "=", "[", "path", "[", "0", "]", ",", "path", "[", "-", "1", "]", "]", "\n", "if", "self", ".", "connected_family", ".", "has_edge", "(", "min_path", "[", "0", "]", ",", "min_path", "[", "1", "]", ")", ":", "\n", "                        ", "all_pairs", ".", "append", "(", "(", "node_a", ",", "node_b", ",", "path", ",", "min_path", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "continue", "\n", "# calculate path stats", "\n", "", "", "", "path_lens", "=", "[", "len", "(", "path_pairs", "[", "2", "]", ")", "-", "1", "for", "path_pairs", "in", "all_pairs", "]", "\n", "max_paths", "=", "max", "(", "path_lens", ")", "\n", "min_paths", "=", "min", "(", "path_lens", ")", "\n", "path_stats", "=", "{", "\n", "'max_path'", ":", "max_paths", ",", "\n", "'min_path'", ":", "min_paths", ",", "\n", "'num_path'", ":", "len", "(", "all_pairs", ")", ",", "\n", "'path_counts'", ":", "[", "path_lens", ".", "count", "(", "pi", ")", "for", "pi", "in", "range", "(", "min_paths", ",", "max_paths", "+", "1", ")", "]", "\n", "}", "\n", "return", "all_pairs", ",", "path_stats", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.make_single_story": [[219, 262], ["builder.RelationBuilder.calc_all_pairs", "len", "enumerate", "stories.append", "abstracts.append", "relation_path.append", "utils.utils.pairwise", "builder.RelationBuilder.stringify", "story.append", "story.extend", "builder.RelationBuilder.stringify", "story.extend", "builder.RelationBuilder._get_attributes", "builder.RelationBuilder._get_attributes", "builder.RelationBuilder.connected_forward.has_edge"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.calc_all_pairs", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.utils.utils.pairwise", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.stringify", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder.stringify", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder._get_attributes", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder._get_attributes"], ["", "def", "make_single_story", "(", "self", ",", "num_relations", "=", "6", ",", "num_stories", "=", "10", ")", ":", "\n", "        ", "\"\"\"\n        In single story mode, there will be only one abstract per story\n        Idea: Select any two nodes, get its longest connected path, form the story out of the path,\n        then form the abstract from the shortest connected path\n        :param: min_relations: min path of relations to consider\n        :param: max_relations: max path of relations to consider\n        :return:\n        \"\"\"", "\n", "stories", "=", "[", "]", "\n", "abstracts", "=", "[", "]", "\n", "relation_path", "=", "[", "]", "# for debugging purposes", "\n", "# for all pairs, calculate the min paths and max paths", "\n", "all_pairs", ",", "_", "=", "self", ".", "calc_all_pairs", "(", "num_relations", "=", "num_relations", ")", "\n", "if", "len", "(", "all_pairs", ")", "==", "0", ":", "\n", "            ", "return", "[", "]", ",", "[", "]", "\n", "# create story-abstract pairs", "\n", "", "for", "path_pairs", "in", "all_pairs", ":", "\n", "            ", "node_a", ",", "node_b", ",", "max_path", ",", "min_path", "=", "path_pairs", "\n", "story", "=", "[", "]", "\n", "path_str", "=", "''", "\n", "for", "pi", ",", "(", "na", ",", "nb", ")", "in", "enumerate", "(", "pairwise", "(", "max_path", ")", ")", ":", "\n", "                ", "text", "=", "self", ".", "stringify", "(", "na", ",", "nb", ")", "\n", "story", ".", "append", "(", "text", ")", "\n", "if", "pi", "==", "0", ":", "\n", "                    ", "story", ".", "extend", "(", "self", ".", "_get_attributes", "(", "self", ".", "connected_family", ".", "node", "[", "na", "]", "[", "'data'", "]", ")", ")", "\n", "", "story", ".", "extend", "(", "self", ".", "_get_attributes", "(", "self", ".", "connected_family", ".", "node", "[", "nb", "]", "[", "'data'", "]", ")", ")", "\n", "weight", "=", "self", ".", "inv_rel_type", "[", "self", ".", "connected_family", "[", "na", "]", "[", "nb", "]", "[", "'weight'", "]", "]", "\n", "if", "not", "self", ".", "connected_forward", ".", "has_edge", "(", "na", ",", "nb", ")", "and", "weight", "not", "in", "[", "'sibling'", ",", "'SO'", "]", ":", "\n", "                    ", "weight", "=", "'inv-'", "+", "weight", "\n", "", "path_str", "+=", "' -- <{}> -- '", ".", "format", "(", "weight", ")", "\n", "#story = '. '.join(story) + '.'", "\n", "", "abstract", "=", "self", ".", "stringify", "(", "node_a", ",", "node_b", ")", "+", "'.'", "\n", "fw", "=", "self", ".", "inv_rel_type", "[", "self", ".", "connected_family", "[", "node_a", "]", "[", "node_b", "]", "[", "'weight'", "]", "]", "\n", "path_str", "+=", "' ===> {}'", ".", "format", "(", "fw", ")", "\n", "stories", ".", "append", "(", "story", ")", "\n", "abstracts", ".", "append", "(", "abstract", ")", "\n", "relation_path", ".", "append", "(", "path_str", ")", "\n", "num_stories", "=", "-", "1", "\n", "\n", "if", "num_stories", "==", "0", ":", "\n", "                ", "break", "\n", "", "", "return", "stories", ",", "abstracts", ",", "relation_path", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.relations.builder.RelationBuilder._get_attributes": [[263, 275], ["len", "random.randint", "random.sample", "node.attributes.keys", "node.attributes.items"], "methods", ["None"], ["", "def", "_get_attributes", "(", "self", ",", "node", ":", "Actor", ")", ":", "\n", "        ", "\"\"\"\n        Select min_attr number of attribute text\n        :param node:\n        :param min_attr:\n        :return:\n        \"\"\"", "\n", "num_attributes", "=", "len", "(", "node", ".", "attributes", ")", "\n", "num_select", "=", "random", ".", "randint", "(", "self", ".", "min_distractor_relations", ",", "num_attributes", ")", "\n", "sel_keys", "=", "random", ".", "sample", "(", "node", ".", "attributes", ".", "keys", "(", ")", ",", "num_select", ")", "\n", "sel_attributes", "=", "[", "v", "for", "k", ",", "v", "in", "node", ".", "attributes", ".", "items", "(", ")", "if", "k", "in", "sel_keys", "]", "\n", "return", "sel_attributes", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.store.store.Store.__init__": [[5, 23], ["json.load", "json.load", "set", "os.path.dirname().split", "open", "open", "os.path.join", "os.path.join", "store.Store.attribute_store.items", "os.path.dirname", "os.path.realpath"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "base_path", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "realpath", "(", "__file__", ")", ")", ".", "split", "(", "'store'", ")", "[", "0", "]", "\n", "self", ".", "attribute_store", "=", "json", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "base_path", ",", "'store'", ",", "'attribute_store.json'", ")", ")", ")", "\n", "self", ".", "relations_store", "=", "json", ".", "load", "(", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "base_path", ",", "'store'", ",", "'relations_store.json'", ")", ")", ")", "\n", "\n", "## Relationship type has basic values 0,1 and 2, whereas the", "\n", "## rest should be inferred. Like, child + child = 4 = grand", "\n", "self", ".", "relationship_type", "=", "{", "\n", "'SO'", ":", "1", ",", "\n", "'child'", ":", "2", ",", "\n", "'sibling'", ":", "0", ",", "\n", "'in-laws'", ":", "3", ",", "\n", "'grand'", ":", "4", ",", "\n", "'no-relation'", ":", "-", "1", "\n", "}", "\n", "\n", "attr_names", "=", "[", "v", "[", "\"options\"", "]", "for", "k", ",", "v", "in", "self", ".", "attribute_store", ".", "items", "(", ")", "]", "\n", "self", ".", "attr_names", "=", "set", "(", "[", "x", "for", "p", "in", "attr_names", "for", "x", "in", "p", "]", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.__init__": [[16, 28], ["networkx.DiGraph", "ancestry.Ancestry.simulate", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.simulate"], ["def", "__init__", "(", "self", ",", "max_levels", "=", "1", ",", "min_child", "=", "1", ",", "max_child", "=", "3", ",", "p_marry", "=", "1", ",", "\n", "relationship_type", "=", "{", "'SO'", ":", "1", ",", "'child'", ":", "2", "}", ",", "taken_names", "=", "None", ")", ":", "\n", "        ", "self", ".", "family", "=", "nx", ".", "DiGraph", "(", ")", "\n", "self", ".", "max_levels", "=", "max_levels", "\n", "self", ".", "min_child", "=", "min_child", "\n", "self", ".", "max_child", "=", "max_child", "\n", "self", ".", "p_marry", "=", "p_marry", "\n", "self", ".", "relationship_type", "=", "relationship_type", "\n", "self", ".", "levels", "=", "0", "# keep track of the levels", "\n", "self", ".", "node_ct", "=", "0", "\n", "self", ".", "taken_names", "=", "taken_names", "if", "taken_names", "else", "copy", ".", "deepcopy", "(", "store", ".", "attr_names", ")", "# keep track of names which are already taken", "\n", "self", ".", "simulate", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.simulate": [[29, 61], ["random.randint", "ancestry.Ancestry.add_members", "range", "numpy.random.choice", "ancestry.Ancestry.add_members", "ancestry.Ancestry.make_relation", "random.randint", "ancestry.Ancestry.add_members", "generation_nodes.extend", "len", "ancestry.Ancestry.toggle_gender", "ancestry.Ancestry.make_relation", "ancestry.Ancestry.make_relation"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.add_members", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.add_members", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.make_relation", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.add_members", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.toggle_gender", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.make_relation", "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.make_relation"], ["", "def", "simulate", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Main function to run the simulation to create a family tree\n\n        :return:\n        \"\"\"", "\n", "self", ".", "node_ct", "=", "0", "\n", "self", ".", "levels", "=", "random", ".", "randint", "(", "1", ",", "self", ".", "max_levels", ")", "\n", "# we are root, for now just add one head of family", "\n", "gender", "=", "'male'", "\n", "nodes", "=", "self", ".", "add_members", "(", "gender", "=", "gender", ",", "num", "=", "1", ")", "\n", "parents", "=", "nodes", "\n", "\n", "for", "level", "in", "range", "(", "self", ".", "max_levels", ")", ":", "\n", "# build generation", "\n", "            ", "generation_nodes", "=", "[", "]", "\n", "for", "node", "in", "parents", ":", "\n", "# marry with probability p_marry", "\n", "                ", "decision_marry", "=", "np", ".", "random", ".", "choice", "(", "[", "True", ",", "False", "]", ",", "1", ",", "p", "=", "[", "self", ".", "p_marry", ",", "1", "-", "self", ".", "p_marry", "]", ")", "\n", "if", "decision_marry", ":", "\n", "# add the partner", "\n", "                    ", "nodes", "=", "self", ".", "add_members", "(", "gender", "=", "self", ".", "toggle_gender", "(", "node", ")", ",", "num", "=", "1", ")", "\n", "self", ".", "make_relation", "(", "node", ",", "nodes", "[", "0", "]", ",", "relation", "=", "'SO'", ")", "\n", "# add the children for this parent", "\n", "num_childs", "=", "random", ".", "randint", "(", "self", ".", "min_child", ",", "self", ".", "max_child", ")", "\n", "child_nodes", "=", "self", ".", "add_members", "(", "num", "=", "num_childs", ")", "\n", "if", "len", "(", "child_nodes", ")", ">", "0", ":", "\n", "                        ", "for", "ch_node", "in", "child_nodes", ":", "\n", "                            ", "self", ".", "make_relation", "(", "node", ",", "ch_node", ",", "relation", "=", "'child'", ")", "\n", "self", ".", "make_relation", "(", "nodes", "[", "0", "]", ",", "ch_node", ",", "relation", "=", "'child'", ")", "\n", "", "", "generation_nodes", ".", "extend", "(", "child_nodes", ")", "\n", "", "", "parents", "=", "generation_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.add_members": [[64, 88], ["range", "names.get_first_name", "ancestry.Ancestry.taken_names.add", "actors.actor.Actor", "added_nodes.append", "ancestry.Ancestry.family.add_node", "random.choice", "names.get_first_name"], "methods", ["None"], ["", "", "def", "add_members", "(", "self", ",", "gender", "=", "'male'", ",", "num", "=", "1", ")", ":", "\n", "        ", "\"\"\"\n        Add members into family\n        :param gender: male/female. if num > 1 then randomize\n        :param num: default 1.\n        :return: list of node ids added, new node id\n        \"\"\"", "\n", "node_ct", "=", "self", ".", "node_ct", "\n", "added_nodes", "=", "[", "]", "\n", "for", "x", "in", "range", "(", "num", ")", ":", "\n", "            ", "if", "num", ">", "1", ":", "\n", "                ", "gender", "=", "random", ".", "choice", "(", "[", "'male'", ",", "'female'", "]", ")", "\n", "# select a name that is not taken", "\n", "", "name", "=", "names", ".", "get_first_name", "(", "gender", "=", "gender", ")", "\n", "while", "name", "in", "self", ".", "taken_names", ":", "\n", "                ", "name", "=", "names", ".", "get_first_name", "(", "gender", "=", "gender", ")", "\n", "", "self", ".", "taken_names", ".", "add", "(", "name", ")", "\n", "node", "=", "Actor", "(", "\n", "name", "=", "name", ",", "gender", "=", "gender", ",", "node_id", "=", "node_ct", ")", "\n", "added_nodes", ".", "append", "(", "node", ")", "\n", "self", ".", "family", ".", "add_node", "(", "node_ct", ",", "data", "=", "node", ")", "\n", "node_ct", "+=", "1", "\n", "", "self", ".", "node_ct", "=", "node_ct", "\n", "return", "added_nodes", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.make_relation": [[89, 98], ["ancestry.Ancestry.family.add_edge"], "methods", ["None"], ["", "def", "make_relation", "(", "self", ",", "node_a", ",", "node_b", ",", "relation", "=", "'SO'", ")", ":", "\n", "        ", "\"\"\"\n        Add a relation between two nodes\n        :param node_a: integer id of the node\n        :param node_b: integer id of the node\n        :param relation: either SO->1, or child->2\n        :return:\n        \"\"\"", "\n", "self", ".", "family", ".", "add_edge", "(", "node_a", ".", "node_id", ",", "node_b", ".", "node_id", ",", "weight", "=", "self", ".", "relationship_type", "[", "relation", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.ancestry.Ancestry.toggle_gender": [[99, 104], ["None"], "methods", ["None"], ["", "def", "toggle_gender", "(", "self", ",", "node", ")", ":", "\n", "        ", "if", "node", ".", "gender", "==", "'male'", ":", "\n", "            ", "return", "'female'", "\n", "", "else", ":", "\n", "            ", "return", "'male'", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.actor.Actor.__init__": [[12, 30], ["actor.Actor.fill_attributes"], "methods", ["home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.actor.Actor.fill_attributes"], ["def", "__init__", "(", "self", ",", "gender", "=", "'male'", ",", "name", "=", "''", ",", "node_id", "=", "0", ")", ":", "\n", "        ", "self", ".", "gender", "=", "gender", "\n", "self", ".", "name", "=", "name", "\n", "self", ".", "node_id", "=", "node_id", "\n", "## irrelevant attributes", "\n", "## also make the irrelevant attributes random. Not every entity will have them all", "\n", "self", ".", "attributes", "=", "{", "\n", "'work'", ":", "''", ",", "\n", "'school'", ":", "''", ",", "\n", "'location_born'", ":", "''", ",", "\n", "'social_media_active'", ":", "False", ",", "\n", "'social_media_preferred'", ":", "''", ",", "\n", "'political_views'", ":", "''", ",", "\n", "'hobby'", ":", "''", ",", "\n", "'sport'", ":", "''", ",", "\n", "}", "\n", "self", ".", "attribute_store", "=", "store", ".", "attribute_store", "\n", "self", ".", "fill_attributes", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.actor.Actor.fill_attributes": [[31, 39], ["actor.Actor.attribute_store.items", "random.choice", "random.choice", "random.choice.replace().replace", "random.choice.replace"], "methods", ["None"], ["", "def", "fill_attributes", "(", "self", ")", ":", "\n", "        ", "for", "key", ",", "val", "in", "self", ".", "attribute_store", ".", "items", "(", ")", ":", "\n", "            ", "random_val", "=", "random", ".", "choice", "(", "val", "[", "'options'", "]", ")", "\n", "random_attr", "=", "'[{}]'", ".", "format", "(", "random_val", ")", "\n", "name", "=", "'[{}]'", ".", "format", "(", "self", ".", "name", ")", "\n", "random_placeholder", "=", "random", ".", "choice", "(", "val", "[", "'placeholders'", "]", ")", "\n", "text", "=", "random_placeholder", ".", "replace", "(", "'e_x'", ",", "name", ")", ".", "replace", "(", "'attr_x'", ",", "random_attr", ")", "\n", "self", ".", "attributes", "[", "key", "]", "=", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.actor.Actor.__repr__": [[40, 43], ["None"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"<Actor name:{} gender:{} node_id:{}\"", ".", "format", "(", "\n", "self", ".", "name", ",", "self", ".", "gender", ",", "self", ".", "node_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.koustuvsinha_clutrr.actors.actor.Actor.__str__": [[44, 47], ["None"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "\"Actor node, name: {}, gender : {}, node_id : {}\"", ".", "format", "(", "\n", "self", ".", "name", ",", "self", ".", "gender", ",", "self", ".", "node_id", "\n", ")", "\n"]]}