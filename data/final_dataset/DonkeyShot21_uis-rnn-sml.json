{"home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.None.demo.diarization_experiment": [[29, 91], ["numpy.load", "numpy.load", "test_data[].tolist", "test_data[].tolist", "uisrnn.UISRNN", "torch.utils.tensorboard.SummaryWriter", "range", "uisrnn.UISRNN.rnn_model.share_memory", "torch.Pool", "mp.Pool.imap", "enumerate", "mp.Pool.close", "torch.utils.tensorboard.SummaryWriter.close", "print", "print", "uisrnn.UISRNN.fit", "uisrnn.UISRNN.save", "uisrnn.compute_sequence_match_accuracy", "predicted_cluster_ids.append", "test_record.append", "print", "print", "print", "print", "print", "uisrnn.output_result", "loss.items", "functools.partial", "torch.utils.tensorboard.SummaryWriter.add_scalar", "len"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.fit", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.save", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.evals.compute_sequence_match_accuracy", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.output_result"], ["def", "diarization_experiment", "(", "model_args", ",", "training_args", ",", "inference_args", ")", ":", "\n", "  ", "\"\"\"Experiment pipeline.\n\n  Load data --> train model --> test model --> output result\n\n  Args:\n    model_args: model configurations\n    training_args: training configurations\n    inference_args: inference configurations\n  \"\"\"", "\n", "# data loading", "\n", "train_data", "=", "np", ".", "load", "(", "'./data/toy_training_data.npz'", ",", "allow_pickle", "=", "True", ")", "\n", "test_data", "=", "np", ".", "load", "(", "'./data/toy_testing_data.npz'", ",", "allow_pickle", "=", "True", ")", "\n", "train_sequence", "=", "train_data", "[", "'train_sequence'", "]", "\n", "train_cluster_id", "=", "train_data", "[", "'train_cluster_id'", "]", "\n", "test_sequences", "=", "test_data", "[", "'test_sequences'", "]", ".", "tolist", "(", ")", "\n", "test_cluster_ids", "=", "test_data", "[", "'test_cluster_ids'", "]", ".", "tolist", "(", ")", "\n", "\n", "# model init", "\n", "model", "=", "uisrnn", ".", "UISRNN", "(", "model_args", ")", "\n", "# model.load(SAVED_MODEL_NAME) # to load a checkpoint", "\n", "# tensorboard writer init", "\n", "writer", "=", "SummaryWriter", "(", ")", "\n", "\n", "# training", "\n", "for", "epoch", "in", "range", "(", "training_args", ".", "epochs", ")", ":", "\n", "    ", "stats", "=", "model", ".", "fit", "(", "train_sequence", ",", "train_cluster_id", ",", "training_args", ")", "\n", "# add to tensorboard", "\n", "for", "loss", ",", "cur_iter", "in", "stats", ":", "\n", "      ", "for", "loss_name", ",", "loss_value", "in", "loss", ".", "items", "(", ")", ":", "\n", "        ", "writer", ".", "add_scalar", "(", "'loss/'", "+", "loss_name", ",", "loss_value", ",", "cur_iter", ")", "\n", "# save the mdoel", "\n", "", "", "model", ".", "save", "(", "SAVED_MODEL_NAME", ")", "\n", "\n", "# testing", "\n", "", "predicted_cluster_ids", "=", "[", "]", "\n", "test_record", "=", "[", "]", "\n", "# predict sequences in parallel", "\n", "model", ".", "rnn_model", ".", "share_memory", "(", ")", "\n", "pool", "=", "mp", ".", "Pool", "(", "NUM_WORKERS", ",", "maxtasksperchild", "=", "None", ")", "\n", "pred_gen", "=", "pool", ".", "imap", "(", "\n", "func", "=", "partial", "(", "model", ".", "predict", ",", "args", "=", "inference_args", ")", ",", "\n", "iterable", "=", "test_sequences", ")", "\n", "# collect and score predicitons", "\n", "for", "idx", ",", "predicted_cluster_id", "in", "enumerate", "(", "pred_gen", ")", ":", "\n", "    ", "accuracy", "=", "uisrnn", ".", "compute_sequence_match_accuracy", "(", "\n", "test_cluster_ids", "[", "idx", "]", ",", "predicted_cluster_id", ")", "\n", "predicted_cluster_ids", ".", "append", "(", "predicted_cluster_id", ")", "\n", "test_record", ".", "append", "(", "(", "accuracy", ",", "len", "(", "test_cluster_ids", "[", "idx", "]", ")", ")", ")", "\n", "print", "(", "'Ground truth labels:'", ")", "\n", "print", "(", "test_cluster_ids", "[", "idx", "]", ")", "\n", "print", "(", "'Predicted labels:'", ")", "\n", "print", "(", "predicted_cluster_id", ")", "\n", "print", "(", "'-'", "*", "80", ")", "\n", "\n", "# close multiprocessing pool", "\n", "", "pool", ".", "close", "(", ")", "\n", "# close tensorboard writer", "\n", "writer", ".", "close", "(", ")", "\n", "\n", "print", "(", "'Finished diarization experiment'", ")", "\n", "print", "(", "uisrnn", ".", "output_result", "(", "model_args", ",", "training_args", ",", "test_record", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.None.demo.main": [[93, 97], ["uisrnn.parse_arguments", "demo.diarization_experiment"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.arguments.parse_arguments", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.None.demo.diarization_experiment"], ["", "def", "main", "(", ")", ":", "\n", "  ", "\"\"\"The main function.\"\"\"", "\n", "model_args", ",", "training_args", ",", "inference_args", "=", "uisrnn", ".", "parse_arguments", "(", ")", "\n", "diarization_experiment", "(", "model_args", ",", "training_args", ",", "inference_args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.evals.get_list_inverse_index": [[20, 38], ["dict", "enumerate", "isinstance", "TypeError"], "function", ["None"], ["def", "get_list_inverse_index", "(", "unique_ids", ")", ":", "\n", "  ", "\"\"\"Get value to position index from a list of unique ids.\n\n  Args:\n    unique_ids: A list of unique integers of strings.\n\n  Returns:\n    result: a dict from value to position\n\n  Raises:\n    TypeError: If unique_ids is not a list.\n  \"\"\"", "\n", "if", "not", "isinstance", "(", "unique_ids", ",", "list", ")", ":", "\n", "    ", "raise", "TypeError", "(", "'unique_ids must be a list'", ")", "\n", "", "result", "=", "dict", "(", ")", "\n", "for", "i", ",", "unique_id", "in", "enumerate", "(", "unique_ids", ")", ":", "\n", "    ", "result", "[", "unique_id", "]", "=", "i", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.evals.compute_sequence_match_accuracy": [[40, 74], ["sorted", "sorted", "evals.get_list_inverse_index", "evals.get_list_inverse_index", "numpy.zeros", "zip", "scipy.optimize.linear_sum_assignment", "count_matrix[].sum", "TypeError", "ValueError", "set", "set", "len", "isinstance", "isinstance", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.evals.get_list_inverse_index", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.evals.get_list_inverse_index"], ["", "def", "compute_sequence_match_accuracy", "(", "sequence1", ",", "sequence2", ")", ":", "\n", "  ", "\"\"\"Compute the accuracy between two sequences by finding optimal matching.\n\n  Args:\n    sequence1: A list of integers or strings.\n    sequence2: A list of integers or strings.\n\n  Returns:\n    accuracy: sequence matching accuracy as a number in [0.0, 1.0]\n\n  Raises:\n    TypeError: If sequence1 or sequence2 is not list.\n    ValueError: If sequence1 and sequence2 are not same size.\n  \"\"\"", "\n", "if", "not", "isinstance", "(", "sequence1", ",", "list", ")", "or", "not", "isinstance", "(", "sequence2", ",", "list", ")", ":", "\n", "    ", "raise", "TypeError", "(", "'sequence1 and sequence2 must be lists'", ")", "\n", "", "if", "not", "sequence1", "or", "len", "(", "sequence1", ")", "!=", "len", "(", "sequence2", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\n", "'sequence1 and sequence2 must have the same non-zero length'", ")", "\n", "# get unique ids from sequences", "\n", "", "unique_ids1", "=", "sorted", "(", "set", "(", "sequence1", ")", ")", "\n", "unique_ids2", "=", "sorted", "(", "set", "(", "sequence2", ")", ")", "\n", "inverse_index1", "=", "get_list_inverse_index", "(", "unique_ids1", ")", "\n", "inverse_index2", "=", "get_list_inverse_index", "(", "unique_ids2", ")", "\n", "# get the count matrix", "\n", "count_matrix", "=", "np", ".", "zeros", "(", "(", "len", "(", "unique_ids1", ")", ",", "len", "(", "unique_ids2", ")", ")", ")", "\n", "for", "item1", ",", "item2", "in", "zip", "(", "sequence1", ",", "sequence2", ")", ":", "\n", "    ", "index1", "=", "inverse_index1", "[", "item1", "]", "\n", "index2", "=", "inverse_index2", "[", "item2", "]", "\n", "count_matrix", "[", "index1", ",", "index2", "]", "+=", "1.0", "\n", "", "row_index", ",", "col_index", "=", "optimize", ".", "linear_sum_assignment", "(", "-", "count_matrix", ")", "\n", "optimal_match_count", "=", "count_matrix", "[", "row_index", ",", "col_index", "]", ".", "sum", "(", ")", "\n", "accuracy", "=", "optimal_match_count", "/", "len", "(", "sequence1", ")", "\n", "return", "accuracy", "\n", "", ""]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.arguments.str2bool": [[21, 28], ["argparse.ArgumentTypeError", "value.lower", "value.lower"], "function", ["None"], ["def", "str2bool", "(", "value", ")", ":", "\n", "  ", "\"\"\"A function to convert string to bool value.\"\"\"", "\n", "if", "value", ".", "lower", "(", ")", "in", "{", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", "}", ":", "\n", "    ", "return", "True", "\n", "", "if", "value", ".", "lower", "(", ")", "in", "{", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", "}", ":", "\n", "    ", "return", "False", "\n", "", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.arguments.parse_arguments": [[30, 229], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser", "argparse.ArgumentParser.parse_args", "argparse.ArgumentParser.parse_known_args", "argparse.ArgumentParser.parse_known_args", "argparse.ArgumentParser.parse_known_args"], "function", ["None"], ["", "def", "parse_arguments", "(", ")", ":", "\n", "  ", "\"\"\"Parse arguments.\n\n  Returns:\n    A tuple of:\n\n      - `model_args`: model arguments\n      - `training_args`: training arguments\n      - `inference_args`: inference arguments\n  \"\"\"", "\n", "# model configurations", "\n", "model_parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Model configurations.'", ",", "add_help", "=", "False", ")", "\n", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--observation_dim'", ",", "\n", "default", "=", "_DEFAULT_OBSERVATION_DIM", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The dimension of the embeddings (e.g. d-vectors).'", ")", "\n", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--rnn_hidden_size'", ",", "\n", "default", "=", "512", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The number of nodes for each RNN layer.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--rnn_depth'", ",", "\n", "default", "=", "1", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The number of RNN layers.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--fc_depth'", ",", "\n", "default", "=", "1", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The number of fully connected layers.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--rnn_dropout'", ",", "\n", "default", "=", "0.2", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The dropout rate for all RNN layers.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--non_lin'", ",", "\n", "default", "=", "True", ",", "\n", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether to use non linearity after linear layers or not.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--transition_bias'", ",", "\n", "default", "=", "None", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The value of p0, corresponding to Eq. (6) in the '", "\n", "'paper. If the value is given, we will fix to this value. If the '", "\n", "'value is None, we will estimate it from training data '", "\n", "'using Eq. (13) in the paper.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--crp_alpha'", ",", "\n", "default", "=", "None", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The value of alpha for the Chinese restaurant process (CRP), '", "\n", "'corresponding to Eq. (7) in the paper.  If the value is given,'", "\n", "'we will fix to this value. If the value is None, we will estimate '", "\n", "'it from training data.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--sigma2'", ",", "\n", "default", "=", "None", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The value of sigma squared, corresponding to Eq. (11) in the '", "\n", "'paper. If the value is given, we will fix to this value. If the '", "\n", "'value is None, we will estimate it from training data.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--verbosity'", ",", "\n", "default", "=", "2", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'How verbose will the logging information be. Higher value '", "\n", "'represents more verbose information. A general guideline: '", "\n", "'0 for errors; 1 for finishing important steps; '", "\n", "'2 for finishing less important steps; 3 or above for debugging '", "\n", "'information.'", ")", "\n", "model_parser", ".", "add_argument", "(", "\n", "'--enable_cuda'", ",", "\n", "default", "=", "True", ",", "\n", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether we should use CUDA if it is avaiable. If False, we will '", "\n", "'always use CPU.'", ")", "\n", "\n", "# training configurations", "\n", "training_parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Training configurations.'", ",", "add_help", "=", "False", ")", "\n", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--optimizer'", ",", "\n", "'-o'", ",", "\n", "default", "=", "'adam'", ",", "\n", "choices", "=", "[", "'adam'", "]", ",", "\n", "help", "=", "'The optimizer for training.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--learning_rate'", ",", "\n", "'-l'", ",", "\n", "default", "=", "1e-3", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The leaning rate for training.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--train_iteration'", ",", "\n", "'-t'", ",", "\n", "default", "=", "20000", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The total number of training iterations.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--epochs'", ",", "\n", "'-e'", ",", "\n", "default", "=", "10", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The total number of training epochs.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--batch_size'", ",", "\n", "'-b'", ",", "\n", "default", "=", "10", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The batch size for training.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--num_permutations'", ",", "\n", "default", "=", "10", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The number of permutations per utterance sampled in the training '", "\n", "'data.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--sigma_alpha'", ",", "\n", "default", "=", "1.0", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The inverse gamma shape for estimating sigma2. This value is only '", "\n", "'meaningful when sigma2 is not given, and estimated from data.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--sigma_beta'", ",", "\n", "default", "=", "1.0", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The inverse gamma scale for estimating sigma2. This value is only '", "\n", "'meaningful when sigma2 is not given, and estimated from data.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--regularization_weight'", ",", "\n", "'-r'", ",", "\n", "default", "=", "1e-5", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'The network regularization multiplicative.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--grad_max_norm'", ",", "\n", "default", "=", "5.0", ",", "\n", "type", "=", "float", ",", "\n", "help", "=", "'Max norm of the gradient.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--enforce_cluster_id_uniqueness'", ",", "\n", "default", "=", "True", ",", "\n", "type", "=", "str2bool", ",", "\n", "help", "=", "'Whether to enforce cluster ID uniqueness across different '", "\n", "'training sequences. Only effective when the first input to fit() '", "\n", "'is a list of sequences. In general, assume the cluster IDs for two '", "\n", "'sequences are [a, b] and [a, c]. If the `a` from the two sequences '", "\n", "'are not the same label, then this arg should be True.'", ")", "\n", "training_parser", ".", "add_argument", "(", "\n", "'--loss_samples'", ",", "\n", "default", "=", "-", "1", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'if loss_samples > 0 then it represents the number of embeddings '", "\n", "'to be sampled in the Sample Mean Loss otherwise it will be ignored '", "\n", "'and the loss will be computed as per the original UIS-RNN'", ")", "\n", "\n", "# inference configurations", "\n", "inference_parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "description", "=", "'Inference configurations.'", ",", "add_help", "=", "False", ")", "\n", "\n", "inference_parser", ".", "add_argument", "(", "\n", "'--beam_size'", ",", "\n", "'-s'", ",", "\n", "default", "=", "10", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The beam search size for inference.'", ")", "\n", "inference_parser", ".", "add_argument", "(", "\n", "'--look_ahead'", ",", "\n", "default", "=", "1", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'The number of look ahead steps during inference.'", ")", "\n", "inference_parser", ".", "add_argument", "(", "\n", "'--test_iteration'", ",", "\n", "default", "=", "2", ",", "\n", "type", "=", "int", ",", "\n", "help", "=", "'During inference, we concatenate M duplicates of the test '", "\n", "'sequence, and run inference on this concatenated sequence. '", "\n", "'Then we return the inference results on the last duplicate as the '", "\n", "'final prediction for the test sequence.'", ")", "\n", "\n", "# a super parser for sanity checks", "\n", "super_parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "parents", "=", "[", "model_parser", ",", "training_parser", ",", "inference_parser", "]", ")", "\n", "\n", "# get arguments", "\n", "super_parser", ".", "parse_args", "(", ")", "\n", "model_args", ",", "_", "=", "model_parser", ".", "parse_known_args", "(", ")", "\n", "training_args", ",", "_", "=", "training_parser", ".", "parse_known_args", "(", ")", "\n", "inference_args", ",", "_", "=", "inference_parser", ".", "parse_known_args", "(", ")", "\n", "\n", "return", "(", "model_args", ",", "training_args", ",", "inference_args", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.CoreRNN.__init__": [[32, 44], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.Linear", "torch.nn.Linear", "range"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "hidden_size", ",", "rnn_depth", ",", "fc_depth", ",", "\n", "observation_dim", ",", "dropout", "=", "0", ",", "non_lin", "=", "True", ")", ":", "\n", "    ", "super", "(", "CoreRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "non_lin", "=", "non_lin", "\n", "if", "rnn_depth", ">=", "2", ":", "\n", "      ", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "input_dim", ",", "hidden_size", ",", "rnn_depth", ",", "dropout", "=", "dropout", ")", "\n", "", "else", ":", "\n", "      ", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "input_dim", ",", "hidden_size", ",", "rnn_depth", ")", "\n", "", "self", ".", "linears", "=", "nn", ".", "ModuleList", "(", "\n", "[", "nn", ".", "Linear", "(", "hidden_size", ",", "hidden_size", ")", "for", "_", "in", "range", "(", "fc_depth", ")", "]", ")", "\n", "self", ".", "last_linear", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "observation_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.CoreRNN.forward": [[45, 55], ["uisrnn.CoreRNN.gru", "isinstance", "uisrnn.CoreRNN.last_linear", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "layer", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_seq", ",", "hidden", "=", "None", ")", ":", "\n", "    ", "out", ",", "hidden", "=", "self", ".", "gru", "(", "input_seq", ",", "hidden", ")", "\n", "if", "isinstance", "(", "out", ",", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "PackedSequence", ")", ":", "\n", "      ", "out", ",", "_", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pad_packed_sequence", "(", "out", ",", "batch_first", "=", "False", ")", "\n", "", "for", "layer", "in", "self", ".", "linears", ":", "\n", "        ", "out", "=", "layer", "(", "out", ")", "\n", "if", "self", ".", "non_lin", ":", "\n", "          ", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "", "", "mean", "=", "self", ".", "last_linear", "(", "out", ")", "\n", "return", "mean", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.__init__": [[60, 73], ["source.mean_set.copy", "source.hidden_set.copy", "source.trace.copy", "source.block_counts.copy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "source", "=", "None", ")", ":", "\n", "    ", "if", "not", "source", ":", "\n", "      ", "self", ".", "mean_set", "=", "[", "]", "\n", "self", ".", "hidden_set", "=", "[", "]", "\n", "self", ".", "neg_likelihood", "=", "0", "\n", "self", ".", "trace", "=", "[", "]", "\n", "self", ".", "block_counts", "=", "[", "]", "\n", "", "else", ":", "\n", "      ", "self", ".", "mean_set", "=", "source", ".", "mean_set", ".", "copy", "(", ")", "\n", "self", ".", "hidden_set", "=", "source", ".", "hidden_set", ".", "copy", "(", ")", "\n", "self", ".", "trace", "=", "source", ".", "trace", ".", "copy", "(", ")", "\n", "self", ".", "block_counts", "=", "source", ".", "block_counts", ".", "copy", "(", ")", "\n", "self", ".", "neg_likelihood", "=", "source", ".", "neg_likelihood", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append": [[74, 80], ["uisrnn.BeamState.mean_set.append", "uisrnn.BeamState.hidden_set.append", "uisrnn.BeamState.block_counts.append", "uisrnn.BeamState.trace.append", "mean.clone", "hidden.clone"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append"], ["", "", "def", "append", "(", "self", ",", "mean", ",", "hidden", ",", "cluster", ")", ":", "\n", "    ", "\"\"\"Append new item to the BeamState.\"\"\"", "\n", "self", ".", "mean_set", ".", "append", "(", "mean", ".", "clone", "(", ")", ")", "\n", "self", ".", "hidden_set", ".", "append", "(", "hidden", ".", "clone", "(", ")", ")", "\n", "self", ".", "block_counts", ".", "append", "(", "1", ")", "\n", "self", ".", "trace", ".", "append", "(", "cluster", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.__init__": [[85, 114], ["torch.device", "torch.device", "torch.device", "torch.device", "CoreRNN().to", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "uisrnn.utils.Logger", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "uisrnn.CoreRNN", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.cuda.is_available", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.ones", "torch.ones", "torch.ones", "torch.ones"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "    ", "\"\"\"Construct the UISRNN object.\n\n    Args:\n      args: Model configurations. See `arguments.py` for details.\n    \"\"\"", "\n", "self", ".", "observation_dim", "=", "args", ".", "observation_dim", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "\n", "'cuda:0'", "if", "(", "torch", ".", "cuda", ".", "is_available", "(", ")", "and", "args", ".", "enable_cuda", ")", "else", "'cpu'", ")", "\n", "self", ".", "rnn_model", "=", "CoreRNN", "(", "self", ".", "observation_dim", ",", "args", ".", "rnn_hidden_size", ",", "\n", "args", ".", "rnn_depth", ",", "args", ".", "fc_depth", ",", "\n", "self", ".", "observation_dim", ",", "args", ".", "rnn_dropout", ",", "\n", "args", ".", "non_lin", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "self", ".", "rnn_init_hidden", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "zeros", "(", "args", ".", "rnn_depth", ",", "1", ",", "args", ".", "rnn_hidden_size", ")", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "# booleans indicating which variables are trainable", "\n", "self", ".", "estimate_sigma2", "=", "(", "args", ".", "sigma2", "is", "None", ")", "\n", "self", ".", "estimate_transition_bias", "=", "(", "args", ".", "transition_bias", "is", "None", ")", "\n", "self", ".", "estimate_crp_alpha", "=", "(", "args", ".", "crp_alpha", "is", "None", ")", "\n", "# initial values of variables", "\n", "sigma2", "=", "_INITIAL_SIGMA2_VALUE", "if", "self", ".", "estimate_sigma2", "else", "args", ".", "sigma2", "\n", "self", ".", "sigma2", "=", "nn", ".", "Parameter", "(", "\n", "sigma2", "*", "torch", ".", "ones", "(", "self", ".", "observation_dim", ")", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "self", ".", "transition_bias", "=", "args", ".", "transition_bias", "\n", "self", ".", "transition_bias_denominator", "=", "0.0", "\n", "self", ".", "crp_alpha", "=", "args", ".", "crp_alpha", "\n", "self", ".", "crp_alpha_denominator", "=", "0.0", "\n", "self", ".", "logger", "=", "utils", ".", "Logger", "(", "args", ".", "verbosity", ")", "\n", "self", ".", "current_iter", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._get_optimizer": [[116, 141], ["torch.optim.Adam", "torch.optim.Adam", "params.append", "uisrnn.UISRNN.rnn_model.parameters"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append"], ["", "def", "_get_optimizer", "(", "self", ",", "optimizer", ",", "learning_rate", ")", ":", "\n", "    ", "\"\"\"Get optimizer for UISRNN.\n\n    Args:\n      optimizer: string - name of the optimizer.\n      learning_rate: - learning rate for the entire model.\n        We do not customize learning rate for separate parts.\n\n    Returns:\n      a pytorch \"optim\" object\n    \"\"\"", "\n", "params", "=", "[", "\n", "{", "\n", "'params'", ":", "self", ".", "rnn_model", ".", "parameters", "(", ")", "\n", "}", ",", "# rnn parameters", "\n", "{", "\n", "'params'", ":", "self", ".", "rnn_init_hidden", "\n", "}", "# rnn initial hidden state", "\n", "]", "\n", "if", "self", ".", "estimate_sigma2", ":", "# train sigma2", "\n", "      ", "params", ".", "append", "(", "{", "\n", "'params'", ":", "self", ".", "sigma2", "\n", "}", ")", "# variance parameters", "\n", "", "assert", "optimizer", "==", "'adam'", ",", "'Only adam optimizer is supported.'", "\n", "return", "optim", ".", "Adam", "(", "params", ",", "lr", "=", "learning_rate", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.save": [[142, 157], ["torch.save", "torch.save", "torch.save", "torch.save", "uisrnn.UISRNN.rnn_model.state_dict", "uisrnn.UISRNN.rnn_init_hidden.detach().cpu().numpy", "uisrnn.UISRNN.sigma2.detach().cpu().numpy", "uisrnn.UISRNN.rnn_init_hidden.detach().cpu", "uisrnn.UISRNN.sigma2.detach().cpu", "uisrnn.UISRNN.rnn_init_hidden.detach", "uisrnn.UISRNN.sigma2.detach"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.save", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.save", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.save", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.save"], ["", "def", "save", "(", "self", ",", "filepath", ")", ":", "\n", "    ", "\"\"\"Save the model to a file.\n\n    Args:\n      filepath: the path of the file.\n    \"\"\"", "\n", "torch", ".", "save", "(", "{", "\n", "'rnn_state_dict'", ":", "self", ".", "rnn_model", ".", "state_dict", "(", ")", ",", "\n", "'rnn_init_hidden'", ":", "self", ".", "rnn_init_hidden", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "'transition_bias'", ":", "self", ".", "transition_bias", ",", "\n", "'transition_bias_denominator'", ":", "self", ".", "transition_bias_denominator", ",", "\n", "'crp_alpha'", ":", "self", ".", "crp_alpha", ",", "\n", "'crp_alpha_denominator'", ":", "self", ".", "crp_alpha_denominator", ",", "\n", "'sigma2'", ":", "self", ".", "sigma2", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "'current_iter'", ":", "self", ".", "current_iter", "}", ",", "filepath", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load": [[158, 182], ["torch.load", "torch.load", "torch.load", "torch.load", "uisrnn.UISRNN.rnn_model.load_state_dict", "torch.nn.Parameter", "torch.nn.Parameter", "float", "float", "float", "float", "torch.nn.Parameter", "torch.nn.Parameter", "int", "uisrnn.UISRNN.logger.print", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy().to", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.load", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print"], ["", "def", "load", "(", "self", ",", "filepath", ")", ":", "\n", "    ", "\"\"\"Load the model from a file.\n\n    Args:\n      filepath: the path of the file.\n    \"\"\"", "\n", "var_dict", "=", "torch", ".", "load", "(", "filepath", ")", "\n", "self", ".", "rnn_model", ".", "load_state_dict", "(", "var_dict", "[", "'rnn_state_dict'", "]", ")", "\n", "self", ".", "rnn_init_hidden", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "from_numpy", "(", "var_dict", "[", "'rnn_init_hidden'", "]", ")", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "self", ".", "transition_bias", "=", "float", "(", "var_dict", "[", "'transition_bias'", "]", ")", "\n", "self", ".", "transition_bias_denominator", "=", "float", "(", "\n", "var_dict", "[", "'transition_bias_denominator'", "]", ")", "\n", "self", ".", "crp_alpha", "=", "float", "(", "var_dict", "[", "'crp_alpha'", "]", ")", "\n", "self", ".", "crp_alpha_denominator", "=", "float", "(", "var_dict", "[", "'crp_alpha_denominator'", "]", ")", "\n", "self", ".", "sigma2", "=", "nn", ".", "Parameter", "(", "\n", "torch", ".", "from_numpy", "(", "var_dict", "[", "'sigma2'", "]", ")", ".", "to", "(", "self", ".", "device", ")", ")", "\n", "self", ".", "current_iter", "=", "int", "(", "var_dict", "[", "'current_iter'", "]", ")", "\n", "\n", "self", ".", "logger", ".", "print", "(", "\n", "3", ",", "'Loaded model with transition_bias={}, crp_alpha={}, sigma2={}, '", "\n", "'rnn_init_hidden={}'", ".", "format", "(", "\n", "self", ".", "transition_bias", ",", "self", ".", "crp_alpha", ",", "var_dict", "[", "'sigma2'", "]", ",", "\n", "var_dict", "[", "'rnn_init_hidden'", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.fit_concatenated": [[183, 332], ["isinstance", "uisrnn.UISRNN.rnn_model.train", "uisrnn.UISRNN._get_optimizer", "uisrnn.utils.resize_sequence", "range", "uisrnn.UISRNN.logger.print", "TypeError", "numpy.array", "TypeError", "ValueError", "ValueError", "ValueError", "len", "ValueError", "uisrnn.utils.pack_sequence", "uisrnn.UISRNN.zero_grad", "uisrnn.UISRNN.rnn_init_hidden.repeat", "uisrnn.UISRNN.rnn_model", "torch.cumsum", "torch.cumsum", "torch.cumsum", "torch.cumsum", "mean.view.view.size", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "mean.view.view.view", "uisrnn.loss_func.weighted_mse_loss", "torch.sum().squeeze", "torch.sum().squeeze", "torch.sum().squeeze", "torch.sum().squeeze", "uisrnn.loss_func.sigma2_prior_loss", "uisrnn.loss_func.regularization_loss", "loss.backward", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "uisrnn.UISRNN.step", "uisrnn.UISRNN.sigma2.data.clamp_", "train_loss.append", "isinstance", "isinstance", "numpy.array.dtype.name.startswith", "uisrnn.utils.pack_sequence", "torch.diag", "torch.diag", "torch.diag", "torch.diag", "mean.view.view.view", "uisrnn.UISRNN.rnn_model.parameters", "uisrnn.UISRNN.rnn_model.parameters", "uisrnn.UISRNN.logger.print", "float", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "numpy.remainder", "torch.arange().float().to", "torch.arange().float().to", "torch.arange().float().to", "torch.arange().float().to", "float", "float", "float", "float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange().float", "torch.arange", "torch.arange", "torch.arange", "torch.arange"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._get_optimizer", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.resize_sequence", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.pack_sequence", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.weighted_mse_loss", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.sigma2_prior_loss", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.regularization_loss", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.pack_sequence", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print"], ["", "def", "fit_concatenated", "(", "self", ",", "train_sequence", ",", "train_cluster_id", ",", "args", ")", ":", "\n", "    ", "\"\"\"Fit UISRNN model to concatenated sequence and cluster_id.\n\n    Args:\n      train_sequence: the training observation sequence, which is a\n        2-dim numpy array of real numbers, of size `N * D`.\n\n        - `N`: summation of lengths of all utterances.\n        - `D`: observation dimension.\n\n        For example,\n      ```\n      train_sequence =\n      [[1.2 3.0 -4.1 6.0]    --> an entry of speaker #0 from utterance 'iaaa'\n       [0.8 -1.1 0.4 0.5]    --> an entry of speaker #1 from utterance 'iaaa'\n       [-0.2 1.0 3.8 5.7]    --> an entry of speaker #0 from utterance 'iaaa'\n       [3.8 -0.1 1.5 2.3]    --> an entry of speaker #0 from utterance 'ibbb'\n       [1.2 1.4 3.6 -2.7]]   --> an entry of speaker #0 from utterance 'ibbb'\n      ```\n        Here `N=5`, `D=4`.\n\n        We concatenate all training utterances into this single sequence.\n      train_cluster_id: the speaker id sequence, which is 1-dim list or\n        numpy array of strings, of size `N`.\n        For example,\n      ```\n      train_cluster_id =\n        ['iaaa_0', 'iaaa_1', 'iaaa_0', 'ibbb_0', 'ibbb_0']\n      ```\n        'iaaa_0' means the entry belongs to speaker #0 in utterance 'iaaa'.\n\n        Note that the order of entries within an utterance are preserved,\n        and all utterances are simply concatenated together.\n      args: Training configurations. See `arguments.py` for details.\n\n    Raises:\n      TypeError: If train_sequence or train_cluster_id is of wrong type.\n      ValueError: If train_sequence or train_cluster_id has wrong dimension.\n    \"\"\"", "\n", "# check type", "\n", "if", "(", "not", "isinstance", "(", "train_sequence", ",", "np", ".", "ndarray", ")", "or", "\n", "train_sequence", ".", "dtype", "!=", "float", ")", ":", "\n", "      ", "raise", "TypeError", "(", "'train_sequence should be a numpy array of float type.'", ")", "\n", "", "if", "isinstance", "(", "train_cluster_id", ",", "list", ")", ":", "\n", "      ", "train_cluster_id", "=", "np", ".", "array", "(", "train_cluster_id", ")", "\n", "", "if", "(", "not", "isinstance", "(", "train_cluster_id", ",", "np", ".", "ndarray", ")", "or", "\n", "not", "train_cluster_id", ".", "dtype", ".", "name", ".", "startswith", "(", "(", "'str'", ",", "'unicode'", ")", ")", ")", ":", "\n", "      ", "raise", "TypeError", "(", "'train_cluster_id type be a numpy array of strings.'", ")", "\n", "# check dimension", "\n", "", "if", "train_sequence", ".", "ndim", "!=", "2", ":", "\n", "      ", "raise", "ValueError", "(", "'train_sequence must be 2-dim array.'", ")", "\n", "", "if", "train_cluster_id", ".", "ndim", "!=", "1", ":", "\n", "      ", "raise", "ValueError", "(", "'train_cluster_id must be 1-dim array.'", ")", "\n", "# check length and size", "\n", "", "train_total_length", ",", "observation_dim", "=", "train_sequence", ".", "shape", "\n", "if", "observation_dim", "!=", "self", ".", "observation_dim", ":", "\n", "      ", "raise", "ValueError", "(", "'train_sequence does not match the dimension specified '", "\n", "'by args.observation_dim.'", ")", "\n", "", "if", "train_total_length", "!=", "len", "(", "train_cluster_id", ")", ":", "\n", "      ", "raise", "ValueError", "(", "'train_sequence length is not equal to '", "\n", "'train_cluster_id length.'", ")", "\n", "\n", "", "self", ".", "rnn_model", ".", "train", "(", ")", "\n", "optimizer", "=", "self", ".", "_get_optimizer", "(", "optimizer", "=", "args", ".", "optimizer", ",", "\n", "learning_rate", "=", "args", ".", "learning_rate", ")", "\n", "\n", "sub_sequences", ",", "seq_lengths", "=", "utils", ".", "resize_sequence", "(", "\n", "sequence", "=", "train_sequence", ",", "\n", "cluster_id", "=", "train_cluster_id", ",", "\n", "num_permutations", "=", "args", ".", "num_permutations", ")", "\n", "\n", "# For batch learning, pack the entire dataset.", "\n", "if", "args", ".", "batch_size", "is", "None", ":", "\n", "      ", "packed_train_sequence", ",", "rnn_truth", "=", "utils", ".", "pack_sequence", "(", "\n", "sub_sequences", ",", "\n", "seq_lengths", ",", "\n", "args", ".", "batch_size", ",", "\n", "self", ".", "observation_dim", ",", "\n", "self", ".", "device", ",", "\n", "args", ".", "loss_samples", ")", "\n", "", "train_loss", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "args", ".", "train_iteration", ")", ":", "\n", "      ", "self", ".", "current_iter", "+=", "1", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "# For online learning, pack a subset in each iteration.", "\n", "if", "args", ".", "batch_size", "is", "not", "None", ":", "\n", "        ", "packed_train_sequence", ",", "rnn_truth", "=", "utils", ".", "pack_sequence", "(", "\n", "sub_sequences", ",", "\n", "seq_lengths", ",", "\n", "args", ".", "batch_size", ",", "\n", "self", ".", "observation_dim", ",", "\n", "self", ".", "device", ",", "\n", "args", ".", "loss_samples", ")", "\n", "", "hidden", "=", "self", ".", "rnn_init_hidden", ".", "repeat", "(", "1", ",", "args", ".", "batch_size", ",", "1", ")", "\n", "mean", ",", "_", "=", "self", ".", "rnn_model", "(", "packed_train_sequence", ",", "hidden", ")", "\n", "# use mean to predict", "\n", "mean", "=", "torch", ".", "cumsum", "(", "mean", ",", "dim", "=", "0", ")", "\n", "mean_size", "=", "mean", ".", "size", "(", ")", "\n", "mean", "=", "torch", ".", "mm", "(", "\n", "torch", ".", "diag", "(", "\n", "1.0", "/", "torch", ".", "arange", "(", "1", ",", "mean_size", "[", "0", "]", "+", "1", ")", ".", "float", "(", ")", ".", "to", "(", "self", ".", "device", ")", ")", ",", "\n", "mean", ".", "view", "(", "mean_size", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "mean", "=", "mean", ".", "view", "(", "mean_size", ")", "\n", "\n", "# Likelihood part.", "\n", "loss1", "=", "loss_func", ".", "weighted_mse_loss", "(", "\n", "input_tensor", "=", "(", "rnn_truth", "!=", "0", ")", ".", "float", "(", ")", "*", "mean", "[", ":", "-", "1", ",", ":", ",", ":", "]", ",", "\n", "target_tensor", "=", "rnn_truth", ",", "\n", "weight", "=", "1", "/", "(", "2", "*", "self", ".", "sigma2", ")", ")", "\n", "\n", "# Sigma2 prior part.", "\n", "weight", "=", "(", "(", "(", "rnn_truth", "!=", "0", ")", ".", "float", "(", ")", "*", "mean", "[", ":", "-", "1", ",", ":", ",", ":", "]", "-", "rnn_truth", ")", "\n", "**", "2", ")", ".", "view", "(", "-", "1", ",", "observation_dim", ")", "\n", "num_non_zero", "=", "torch", ".", "sum", "(", "(", "weight", "!=", "0", ")", ".", "float", "(", ")", ",", "dim", "=", "0", ")", ".", "squeeze", "(", ")", "\n", "loss2", "=", "loss_func", ".", "sigma2_prior_loss", "(", "\n", "num_non_zero", ",", "args", ".", "sigma_alpha", ",", "args", ".", "sigma_beta", ",", "self", ".", "sigma2", ")", "\n", "\n", "# Regularization part.", "\n", "loss3", "=", "loss_func", ".", "regularization_loss", "(", "\n", "self", ".", "rnn_model", ".", "parameters", "(", ")", ",", "args", ".", "regularization_weight", ")", "\n", "\n", "loss", "=", "loss1", "+", "loss2", "+", "loss3", "\n", "loss", ".", "backward", "(", ")", "\n", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "self", ".", "rnn_model", ".", "parameters", "(", ")", ",", "args", ".", "grad_max_norm", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "# avoid numerical issues", "\n", "self", ".", "sigma2", ".", "data", ".", "clamp_", "(", "min", "=", "1e-6", ")", "\n", "\n", "if", "(", "np", ".", "remainder", "(", "self", ".", "current_iter", ",", "10", ")", "==", "0", "or", "\n", "self", ".", "current_iter", "==", "args", ".", "train_iteration", "-", "1", ")", ":", "\n", "        ", "self", ".", "logger", ".", "print", "(", "\n", "2", ",", "\n", "'Iter: {:d}  \\t'", "\n", "'Training Loss: {:.4f}    \\n'", "\n", "'    Negative Log Likelihood: {:.4f}\\t'", "\n", "'Sigma2 Prior: {:.4f}\\t'", "\n", "'Regularization: {:.4f}'", ".", "format", "(", "\n", "self", ".", "current_iter", ",", "\n", "float", "(", "loss", ".", "data", ")", ",", "\n", "float", "(", "loss1", ".", "data", ")", ",", "\n", "float", "(", "loss2", ".", "data", ")", ",", "\n", "float", "(", "loss3", ".", "data", ")", ")", ")", "\n", "yield", "{", "'total'", ":", "loss", ".", "data", ",", "\n", "'nll'", ":", "loss1", ".", "data", ",", "\n", "'s2p'", ":", "loss2", ".", "data", ",", "\n", "'regular'", ":", "loss3", ".", "data", "}", ",", "self", ".", "current_iter", "\n", "", "train_loss", ".", "append", "(", "float", "(", "loss1", ".", "data", ")", ")", "# only save the likelihood part", "\n", "", "self", ".", "logger", ".", "print", "(", "\n", "1", ",", "'Done training with {} iterations'", ".", "format", "(", "args", ".", "train_iteration", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.fit": [[334, 421], ["isinstance", "uisrnn.utils.concatenate_training_data", "uisrnn.UISRNN.fit_concatenated", "isinstance", "uisrnn.utils.estimate_transition_bias", "uisrnn.utils.estimate_crp_alpha", "uisrnn.UISRNN.logger.print", "TypeError"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.concatenate_training_data", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.fit_concatenated", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.estimate_transition_bias", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.estimate_crp_alpha", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print"], ["", "def", "fit", "(", "self", ",", "train_sequences", ",", "train_cluster_ids", ",", "args", ")", ":", "\n", "    ", "\"\"\"Fit UISRNN model.\n\n    Args:\n      train_sequences: Either a list of training sequences, or a single\n        concatenated training sequence:\n\n        1. train_sequences is list, and each element is a 2-dim numpy array\n           of real numbers, of size: `length * D`.\n           The length varies among different sequences, but the D is the same.\n           In speaker diarization, each sequence is the sequence of speaker\n           embeddings of one utterance.\n        2. train_sequences is a single concatenated sequence, which is a\n           2-dim numpy array of real numbers. See `fit_concatenated()`\n           for more details.\n      train_cluster_ids: Ground truth labels for train_sequences:\n\n        1. if train_sequences is a list, this must also be a list of the same\n           size, each element being a 1-dim list or numpy array of strings.\n        2. if train_sequences is a single concatenated sequence, this\n           must also be the concatenated 1-dim list or numpy array of strings\n      args: Training configurations. See `arguments.py` for details.\n\n    Raises:\n      TypeError: If train_sequences or train_cluster_ids is of wrong type.\n    \"\"\"", "\n", "if", "isinstance", "(", "train_sequences", ",", "np", ".", "ndarray", ")", ":", "\n", "# train_sequences is already the concatenated sequence", "\n", "      ", "if", "self", ".", "estimate_transition_bias", ":", "\n", "# see issue #55: https://github.com/google/uis-rnn/issues/55", "\n", "        ", "self", ".", "logger", ".", "print", "(", "\n", "2", ",", "\n", "'Warning: transition_bias cannot be correctly estimated from a '", "\n", "'concatenated sequence; train_sequences will be treated as a '", "\n", "'single sequence. This can lead to inaccurate estimation of '", "\n", "'transition_bias. Please, consider estimating transition_bias '", "\n", "'before concatenating the sequences and passing it as argument.'", ")", "\n", "", "train_sequences", "=", "[", "train_sequences", "]", "\n", "train_cluster_ids", "=", "[", "train_cluster_ids", "]", "\n", "", "elif", "isinstance", "(", "train_sequences", ",", "list", ")", ":", "\n", "# train_sequences is a list of un-concatenated sequences", "\n", "# we will concatenate it later, after estimating transition_bias", "\n", "      ", "pass", "\n", "", "else", ":", "\n", "      ", "raise", "TypeError", "(", "'train_sequences must be a list or numpy.ndarray'", ")", "\n", "\n", "# estimate transition_bias", "\n", "", "if", "self", ".", "estimate_transition_bias", ":", "\n", "      ", "(", "transition_bias", ",", "\n", "transition_bias_denominator", ")", "=", "utils", ".", "estimate_transition_bias", "(", "\n", "train_cluster_ids", ")", "\n", "# set or update transition_bias", "\n", "if", "self", ".", "transition_bias", "is", "None", ":", "\n", "        ", "self", ".", "transition_bias", "=", "transition_bias", "\n", "self", ".", "transition_bias_denominator", "=", "transition_bias_denominator", "\n", "", "else", ":", "\n", "        ", "self", ".", "transition_bias", "=", "(", "\n", "self", ".", "transition_bias", "*", "self", ".", "transition_bias_denominator", "+", "\n", "transition_bias", "*", "transition_bias_denominator", ")", "/", "(", "\n", "self", ".", "transition_bias_denominator", "+", "transition_bias_denominator", ")", "\n", "self", ".", "transition_bias_denominator", "+=", "transition_bias_denominator", "\n", "\n", "# estimate crp_alpha", "\n", "", "", "if", "self", ".", "estimate_crp_alpha", ":", "\n", "      ", "(", "crp_alpha", ",", "\n", "crp_alpha_denominator", ")", "=", "utils", ".", "estimate_crp_alpha", "(", "train_cluster_ids", ")", "\n", "# set or update crp_alpha", "\n", "if", "self", ".", "crp_alpha", "is", "None", ":", "\n", "        ", "self", ".", "crp_alpha", "=", "crp_alpha", "\n", "self", ".", "crp_alpha_denominator", "=", "crp_alpha_denominator", "\n", "", "else", ":", "\n", "        ", "self", ".", "crp_alpha", "=", "(", "\n", "self", ".", "crp_alpha", "*", "self", ".", "crp_alpha_denominator", "+", "\n", "crp_alpha", "*", "crp_alpha_denominator", ")", "/", "(", "\n", "self", ".", "crp_alpha_denominator", "+", "crp_alpha", ")", "\n", "self", ".", "crp_alpha_denominator", "+=", "crp_alpha_denominator", "\n", "\n", "# concatenate train_sequences", "\n", "", "", "(", "concatenated_train_sequence", ",", "\n", "concatenated_train_cluster_id", ")", "=", "utils", ".", "concatenate_training_data", "(", "\n", "train_sequences", ",", "\n", "train_cluster_ids", ",", "\n", "args", ".", "enforce_cluster_id_uniqueness", ",", "\n", "True", ")", "\n", "\n", "return", "self", ".", "fit_concatenated", "(", "\n", "concatenated_train_sequence", ",", "concatenated_train_cluster_id", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._update_beam_state": [[422, 488], ["uisrnn.BeamState", "enumerate", "len", "float", "len", "uisrnn.loss_func.weighted_mse_loss().cpu().detach().numpy", "uisrnn.UISRNN.rnn_model", "hidden.clone", "BeamState.trace.append", "torch.autograd.Variable().unsqueeze().unsqueeze().to", "torch.autograd.Variable().unsqueeze().unsqueeze().to", "uisrnn.UISRNN.rnn_model", "uisrnn.loss_func.weighted_mse_loss().cpu().detach().numpy", "uisrnn.UISRNN.rnn_model", "uisrnn.BeamState.append", "numpy.log", "look_ahead_seq[].unsqueeze().unsqueeze", "numpy.log", "look_ahead_seq[].unsqueeze().unsqueeze", "uisrnn.loss_func.weighted_mse_loss().cpu().detach", "numpy.log", "mean.clone", "torch.autograd.Variable().unsqueeze().unsqueeze", "torch.autograd.Variable().unsqueeze().unsqueeze", "uisrnn.loss_func.weighted_mse_loss().cpu().detach", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "look_ahead_seq[].unsqueeze", "sum", "look_ahead_seq[].unsqueeze", "uisrnn.loss_func.weighted_mse_loss().cpu", "sum", "torch.autograd.Variable().unsqueeze", "torch.autograd.Variable().unsqueeze", "uisrnn.loss_func.weighted_mse_loss().cpu", "uisrnn.loss_func.weighted_mse_loss", "numpy.array", "torch.autograd.Variable", "torch.autograd.Variable", "uisrnn.loss_func.weighted_mse_loss", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "torch.squeeze", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.weighted_mse_loss", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.weighted_mse_loss"], ["", "def", "_update_beam_state", "(", "self", ",", "beam_state", ",", "look_ahead_seq", ",", "cluster_seq", ")", ":", "\n", "    ", "\"\"\"Update a beam state given a look ahead sequence and known cluster\n    assignments.\n\n    Args:\n      beam_state: A BeamState object.\n      look_ahead_seq: Look ahead sequence, size: look_ahead*D.\n        look_ahead: number of step to look ahead in the beam search.\n        D: observation dimension\n      cluster_seq: Cluster assignment sequence for look_ahead_seq.\n\n    Returns:\n      new_beam_state: An updated BeamState object.\n    \"\"\"", "\n", "\n", "loss", "=", "0", "\n", "new_beam_state", "=", "BeamState", "(", "beam_state", ")", "\n", "for", "sub_idx", ",", "cluster", "in", "enumerate", "(", "cluster_seq", ")", ":", "\n", "      ", "if", "cluster", ">", "len", "(", "new_beam_state", ".", "mean_set", ")", ":", "# invalid trace", "\n", "        ", "new_beam_state", ".", "neg_likelihood", "=", "float", "(", "'inf'", ")", "\n", "break", "\n", "", "elif", "cluster", "<", "len", "(", "new_beam_state", ".", "mean_set", ")", ":", "# existing cluster", "\n", "        ", "last_cluster", "=", "new_beam_state", ".", "trace", "[", "-", "1", "]", "\n", "loss", "=", "loss_func", ".", "weighted_mse_loss", "(", "\n", "input_tensor", "=", "torch", ".", "squeeze", "(", "new_beam_state", ".", "mean_set", "[", "cluster", "]", ")", ",", "\n", "target_tensor", "=", "look_ahead_seq", "[", "sub_idx", ",", ":", "]", ",", "\n", "weight", "=", "1", "/", "(", "2", "*", "self", ".", "sigma2", ")", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "if", "cluster", "==", "last_cluster", ":", "\n", "          ", "loss", "-=", "np", ".", "log", "(", "1", "-", "self", ".", "transition_bias", ")", "\n", "", "else", ":", "\n", "          ", "loss", "-=", "np", ".", "log", "(", "self", ".", "transition_bias", ")", "+", "np", ".", "log", "(", "\n", "new_beam_state", ".", "block_counts", "[", "cluster", "]", ")", "-", "np", ".", "log", "(", "\n", "sum", "(", "new_beam_state", ".", "block_counts", ")", "+", "self", ".", "crp_alpha", ")", "\n", "# update new mean and new hidden", "\n", "", "mean", ",", "hidden", "=", "self", ".", "rnn_model", "(", "\n", "look_ahead_seq", "[", "sub_idx", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "new_beam_state", ".", "hidden_set", "[", "cluster", "]", ")", "\n", "new_beam_state", ".", "mean_set", "[", "cluster", "]", "=", "(", "new_beam_state", ".", "mean_set", "[", "cluster", "]", "*", "(", "\n", "(", "np", ".", "array", "(", "new_beam_state", ".", "trace", ")", "==", "cluster", ")", ".", "sum", "(", ")", "-", "\n", "1", ")", ".", "astype", "(", "float", ")", "+", "mean", ".", "clone", "(", ")", ")", "/", "(", "\n", "np", ".", "array", "(", "new_beam_state", ".", "trace", ")", "==", "cluster", ")", ".", "sum", "(", ")", ".", "astype", "(", "\n", "float", ")", "# use mean to predict", "\n", "new_beam_state", ".", "hidden_set", "[", "cluster", "]", "=", "hidden", ".", "clone", "(", ")", "\n", "if", "cluster", "!=", "last_cluster", ":", "\n", "          ", "new_beam_state", ".", "block_counts", "[", "cluster", "]", "+=", "1", "\n", "", "new_beam_state", ".", "trace", ".", "append", "(", "cluster", ")", "\n", "", "else", ":", "# new cluster", "\n", "        ", "init_input", "=", "autograd", ".", "Variable", "(", "\n", "torch", ".", "zeros", "(", "self", ".", "observation_dim", ")", "\n", ")", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "mean", ",", "hidden", "=", "self", ".", "rnn_model", "(", "init_input", ",", "\n", "self", ".", "rnn_init_hidden", ")", "\n", "loss", "=", "loss_func", ".", "weighted_mse_loss", "(", "\n", "input_tensor", "=", "torch", ".", "squeeze", "(", "mean", ")", ",", "\n", "target_tensor", "=", "look_ahead_seq", "[", "sub_idx", ",", ":", "]", ",", "\n", "weight", "=", "1", "/", "(", "2", "*", "self", ".", "sigma2", ")", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "loss", "-=", "np", ".", "log", "(", "self", ".", "transition_bias", ")", "+", "np", ".", "log", "(", "\n", "self", ".", "crp_alpha", ")", "-", "np", ".", "log", "(", "\n", "sum", "(", "new_beam_state", ".", "block_counts", ")", "+", "self", ".", "crp_alpha", ")", "\n", "# update new min and new hidden", "\n", "mean", ",", "hidden", "=", "self", ".", "rnn_model", "(", "\n", "look_ahead_seq", "[", "sub_idx", ",", ":", "]", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "0", ")", ",", "\n", "hidden", ")", "\n", "new_beam_state", ".", "append", "(", "mean", ",", "hidden", ",", "cluster", ")", "\n", "", "new_beam_state", ".", "neg_likelihood", "+=", "loss", "\n", "", "return", "new_beam_state", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._calculate_score": [[489, 512], ["len", "numpy.ndenumerate", "float", "numpy.ones", "uisrnn.UISRNN._update_beam_state", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._update_beam_state"], ["", "def", "_calculate_score", "(", "self", ",", "beam_state", ",", "look_ahead_seq", ")", ":", "\n", "    ", "\"\"\"Calculate negative log likelihoods for all possible state allocations\n       of a look ahead sequence, according to the current beam state.\n\n    Args:\n      beam_state: A BeamState object.\n      look_ahead_seq: Look ahead sequence, size: look_ahead*D.\n        look_ahead: number of step to look ahead in the beam search.\n        D: observation dimension\n\n    Returns:\n      beam_score_set: a set of scores for each possible state allocation.\n    \"\"\"", "\n", "\n", "look_ahead", ",", "_", "=", "look_ahead_seq", ".", "shape", "\n", "beam_num_clusters", "=", "len", "(", "beam_state", ".", "mean_set", ")", "\n", "beam_score_set", "=", "float", "(", "'inf'", ")", "*", "np", ".", "ones", "(", "\n", "beam_num_clusters", "+", "1", "+", "np", ".", "arange", "(", "look_ahead", ")", ")", "\n", "for", "cluster_seq", ",", "_", "in", "np", ".", "ndenumerate", "(", "beam_score_set", ")", ":", "\n", "      ", "updated_beam_state", "=", "self", ".", "_update_beam_state", "(", "beam_state", ",", "\n", "look_ahead_seq", ",", "cluster_seq", ")", "\n", "beam_score_set", "[", "cluster_seq", "]", "=", "updated_beam_state", ".", "neg_likelihood", "\n", "", "return", "beam_score_set", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.predict_single": [[513, 597], ["uisrnn.UISRNN.rnn_model.eval", "numpy.tile", "torch.autograd.Variable().to", "torch.autograd.Variable().to", "numpy.arange", "TypeError", "ValueError", "ValueError", "uisrnn.BeamState", "max", "enumerate", "numpy.sort", "numpy.trim_zeros", "numpy.argsort", "range", "isinstance", "torch.autograd.Variable", "torch.autograd.Variable", "float", "numpy.ones", "uisrnn.UISRNN._calculate_score", "numpy.pad", "numpy.min", "numpy.unravel_index", "uisrnn.UISRNN._update_beam_state", "updated_beam_set.append", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().float", "len", "numpy.append", "numpy.tile", "float", "float", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._calculate_score", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN._update_beam_state", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append"], ["", "def", "predict_single", "(", "self", ",", "test_sequence", ",", "args", ")", ":", "\n", "    ", "\"\"\"Predict labels for a single test sequence using UISRNN model.\n\n    Args:\n      test_sequence: the test observation sequence, which is 2-dim numpy array\n        of real numbers, of size `N * D`.\n\n        - `N`: length of one test utterance.\n        - `D` : observation dimension.\n\n        For example:\n      ```\n      test_sequence =\n      [[2.2 -1.0 3.0 5.6]    --> 1st entry of utterance 'iccc'\n       [0.5 1.8 -3.2 0.4]    --> 2nd entry of utterance 'iccc'\n       [-2.2 5.0 1.8 3.7]    --> 3rd entry of utterance 'iccc'\n       [-3.8 0.1 1.4 3.3]    --> 4th entry of utterance 'iccc'\n       [0.1 2.7 3.5 -1.7]]   --> 5th entry of utterance 'iccc'\n      ```\n        Here `N=5`, `D=4`.\n      args: Inference configurations. See `arguments.py` for details.\n\n    Returns:\n      predicted_cluster_id: predicted speaker id sequence, which is\n        an array of integers, of size `N`.\n        For example, `predicted_cluster_id = [0, 1, 0, 0, 1]`\n\n    Raises:\n      TypeError: If test_sequence is of wrong type.\n      ValueError: If test_sequence has wrong dimension.\n    \"\"\"", "\n", "# check type", "\n", "if", "(", "not", "isinstance", "(", "test_sequence", ",", "np", ".", "ndarray", ")", "or", "\n", "test_sequence", ".", "dtype", "!=", "float", ")", ":", "\n", "      ", "raise", "TypeError", "(", "'test_sequence should be a numpy array of float type.'", ")", "\n", "# check dimension", "\n", "", "if", "test_sequence", ".", "ndim", "!=", "2", ":", "\n", "      ", "raise", "ValueError", "(", "'test_sequence must be 2-dim array.'", ")", "\n", "# check size", "\n", "", "test_sequence_length", ",", "observation_dim", "=", "test_sequence", ".", "shape", "\n", "if", "observation_dim", "!=", "self", ".", "observation_dim", ":", "\n", "      ", "raise", "ValueError", "(", "'test_sequence does not match the dimension specified '", "\n", "'by args.observation_dim.'", ")", "\n", "\n", "", "self", ".", "rnn_model", ".", "eval", "(", ")", "\n", "test_sequence", "=", "np", ".", "tile", "(", "test_sequence", ",", "(", "args", ".", "test_iteration", ",", "1", ")", ")", "\n", "test_sequence", "=", "autograd", ".", "Variable", "(", "\n", "torch", ".", "from_numpy", "(", "test_sequence", ")", ".", "float", "(", ")", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "# bookkeeping for beam search", "\n", "beam_set", "=", "[", "BeamState", "(", ")", "]", "\n", "for", "num_iter", "in", "np", ".", "arange", "(", "0", ",", "args", ".", "test_iteration", "*", "test_sequence_length", ",", "\n", "args", ".", "look_ahead", ")", ":", "\n", "      ", "max_clusters", "=", "max", "(", "[", "len", "(", "beam_state", ".", "mean_set", ")", "for", "beam_state", "in", "beam_set", "]", ")", "\n", "look_ahead_seq", "=", "test_sequence", "[", "num_iter", ":", "num_iter", "+", "args", ".", "look_ahead", ",", ":", "]", "\n", "look_ahead_seq_length", "=", "look_ahead_seq", ".", "shape", "[", "0", "]", "\n", "score_set", "=", "float", "(", "'inf'", ")", "*", "np", ".", "ones", "(", "\n", "np", ".", "append", "(", "\n", "args", ".", "beam_size", ",", "max_clusters", "+", "1", "+", "np", ".", "arange", "(", "\n", "look_ahead_seq_length", ")", ")", ")", "\n", "for", "beam_rank", ",", "beam_state", "in", "enumerate", "(", "beam_set", ")", ":", "\n", "        ", "beam_score_set", "=", "self", ".", "_calculate_score", "(", "beam_state", ",", "look_ahead_seq", ")", "\n", "score_set", "[", "beam_rank", ",", ":", "]", "=", "np", ".", "pad", "(", "\n", "beam_score_set", ",", "\n", "np", ".", "tile", "(", "[", "[", "0", ",", "max_clusters", "-", "len", "(", "beam_state", ".", "mean_set", ")", "]", "]", ",", "\n", "(", "look_ahead_seq_length", ",", "1", ")", ")", ",", "'constant'", ",", "\n", "constant_values", "=", "float", "(", "'inf'", ")", ")", "\n", "# find top scores", "\n", "", "score_ranked", "=", "np", ".", "sort", "(", "score_set", ",", "axis", "=", "None", ")", "\n", "score_ranked", "[", "score_ranked", "==", "float", "(", "'inf'", ")", "]", "=", "0", "\n", "score_ranked", "=", "np", ".", "trim_zeros", "(", "score_ranked", ")", "\n", "idx_ranked", "=", "np", ".", "argsort", "(", "score_set", ",", "axis", "=", "None", ")", "\n", "updated_beam_set", "=", "[", "]", "\n", "for", "new_beam_rank", "in", "range", "(", "\n", "np", ".", "min", "(", "(", "len", "(", "score_ranked", ")", ",", "args", ".", "beam_size", ")", ")", ")", ":", "\n", "        ", "total_idx", "=", "np", ".", "unravel_index", "(", "idx_ranked", "[", "new_beam_rank", "]", ",", "\n", "score_set", ".", "shape", ")", "\n", "prev_beam_rank", "=", "total_idx", "[", "0", "]", "\n", "cluster_seq", "=", "total_idx", "[", "1", ":", "]", "\n", "updated_beam_state", "=", "self", ".", "_update_beam_state", "(", "\n", "beam_set", "[", "prev_beam_rank", "]", ",", "look_ahead_seq", ",", "cluster_seq", ")", "\n", "updated_beam_set", ".", "append", "(", "updated_beam_state", ")", "\n", "", "beam_set", "=", "updated_beam_set", "\n", "", "predicted_cluster_id", "=", "beam_set", "[", "0", "]", ".", "trace", "[", "-", "test_sequence_length", ":", "]", "\n", "return", "predicted_cluster_id", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.predict": [[598, 625], ["isinstance", "isinstance", "TypeError", "uisrnn.UISRNN.predict_single", "uisrnn.UISRNN.predict_single"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.predict_single", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.UISRNN.predict_single"], ["", "def", "predict", "(", "self", ",", "test_sequences", ",", "args", ")", ":", "\n", "    ", "\"\"\"Predict labels for a single or many test sequences using UISRNN model.\n\n    Args:\n      test_sequences: Either a list of test sequences, or a single test\n        sequence. Each test sequence is a 2-dim numpy array\n        of real numbers. See `predict_single()` for details.\n      args: Inference configurations. See `arguments.py` for details.\n\n    Returns:\n      predicted_cluster_ids: Predicted labels for test_sequences.\n\n        1. if test_sequences is a list, predicted_cluster_ids will be a list\n           of the same size, where each element being a 1-dim list of strings.\n        2. if test_sequences is a single sequence, predicted_cluster_ids will\n           be a 1-dim list of strings\n\n    Raises:\n      TypeError: If test_sequences is of wrong type.\n    \"\"\"", "\n", "# check type", "\n", "if", "isinstance", "(", "test_sequences", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "return", "self", ".", "predict_single", "(", "test_sequences", ",", "args", ")", "\n", "", "if", "isinstance", "(", "test_sequences", ",", "list", ")", ":", "\n", "      ", "return", "[", "self", ".", "predict_single", "(", "test_sequence", ",", "args", ")", "\n", "for", "test_sequence", "in", "test_sequences", "]", "\n", "", "raise", "TypeError", "(", "'test_sequences should be either a list or numpy array.'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.__init__": [[27, 29], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "verbosity", ")", ":", "\n", "    ", "self", ".", "_verbosity", "=", "verbosity", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print": [[30, 39], ["utils.Logger.print"], "methods", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.Logger.print"], ["", "def", "print", "(", "self", ",", "level", ",", "message", ")", ":", "\n", "    ", "\"\"\"Print a message if level is not higher than verbosity.\n\n    Args:\n      level: the level of this message, smaller value means more important\n      message: the message to be printed\n    \"\"\"", "\n", "if", "level", "<=", "self", ".", "_verbosity", ":", "\n", "      ", "print", "(", "message", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.generate_random_string": [[41, 53], ["random.choice", "range"], "function", ["None"], ["", "", "", "def", "generate_random_string", "(", "length", "=", "6", ")", ":", "\n", "  ", "\"\"\"Generate a random string of upper case letters and digits.\n\n  Args:\n    length: length of the generated string\n\n  Returns:\n    the generated string\n  \"\"\"", "\n", "return", "''", ".", "join", "(", "[", "\n", "random", ".", "choice", "(", "string", ".", "ascii_uppercase", "+", "string", ".", "digits", ")", "\n", "for", "_", "in", "range", "(", "length", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.enforce_cluster_id_uniqueness": [[55, 79], ["isinstance", "TypeError", "utils.generate_random_string", "isinstance", "new_cluster_ids.append", "cluster_id.tolist.tolist", "isinstance", "TypeError"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.generate_random_string", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append"], ["", "def", "enforce_cluster_id_uniqueness", "(", "cluster_ids", ")", ":", "\n", "  ", "\"\"\"Enforce uniqueness of cluster id across sequences.\n\n  Args:\n    cluster_ids: a list of 1-dim list/numpy.ndarray of strings\n\n  Returns:\n    a new list with same length of cluster_ids\n\n  Raises:\n    TypeError: if cluster_ids or its element has wrong type\n  \"\"\"", "\n", "if", "not", "isinstance", "(", "cluster_ids", ",", "list", ")", ":", "\n", "    ", "raise", "TypeError", "(", "'cluster_ids must be a list'", ")", "\n", "", "new_cluster_ids", "=", "[", "]", "\n", "for", "cluster_id", "in", "cluster_ids", ":", "\n", "    ", "sequence_id", "=", "generate_random_string", "(", ")", "\n", "if", "isinstance", "(", "cluster_id", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "cluster_id", "=", "cluster_id", ".", "tolist", "(", ")", "\n", "", "if", "not", "isinstance", "(", "cluster_id", ",", "list", ")", ":", "\n", "      ", "raise", "TypeError", "(", "'Elements of cluster_ids must be list or numpy.ndarray'", ")", "\n", "", "new_cluster_id", "=", "[", "'_'", ".", "join", "(", "[", "sequence_id", ",", "s", "]", ")", "for", "s", "in", "cluster_id", "]", "\n", "new_cluster_ids", ".", "append", "(", "new_cluster_id", ")", "\n", "", "return", "new_cluster_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.concatenate_training_data": [[81, 141], ["enumerate", "numpy.concatenate", "TypeError", "len", "len", "ValueError", "zip", "utils.enforce_cluster_id_uniqueness", "list", "random.shuffle", "zip", "isinstance", "isinstance", "isinstance", "x.tolist", "isinstance", "TypeError", "len", "ValueError", "zip", "ValueError"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.enforce_cluster_id_uniqueness"], ["", "def", "concatenate_training_data", "(", "train_sequences", ",", "train_cluster_ids", ",", "\n", "enforce_uniqueness", "=", "True", ",", "shuffle", "=", "True", ")", ":", "\n", "  ", "\"\"\"Concatenate training data.\n\n  Args:\n    train_sequences: a list of 2-dim numpy arrays to be concatenated\n    train_cluster_ids: a list of 1-dim list/numpy.ndarray of strings\n    enforce_uniqueness: a boolean indicated whether we should enfore uniqueness\n      to train_cluster_ids\n    shuffle: whether to randomly shuffle input order\n\n  Returns:\n    concatenated_train_sequence: a 2-dim numpy array\n    concatenated_train_cluster_id: a list of strings\n\n  Raises:\n    TypeError: if input has wrong type\n    ValueError: if sizes/dimensions of input or their elements are incorrect\n  \"\"\"", "\n", "# check input", "\n", "if", "not", "isinstance", "(", "train_sequences", ",", "list", ")", "or", "not", "isinstance", "(", "\n", "train_cluster_ids", ",", "list", ")", ":", "\n", "    ", "raise", "TypeError", "(", "'train_sequences and train_cluster_ids must be lists'", ")", "\n", "", "if", "len", "(", "train_sequences", ")", "!=", "len", "(", "train_cluster_ids", ")", ":", "\n", "    ", "raise", "ValueError", "(", "\n", "'train_sequences and train_cluster_ids must have same size'", ")", "\n", "", "train_cluster_ids", "=", "[", "\n", "x", ".", "tolist", "(", ")", "if", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", "else", "x", "\n", "for", "x", "in", "train_cluster_ids", "]", "\n", "global_observation_dim", "=", "None", "\n", "for", "i", ",", "(", "train_sequence", ",", "train_cluster_id", ")", "in", "enumerate", "(", "\n", "zip", "(", "train_sequences", ",", "train_cluster_ids", ")", ")", ":", "\n", "    ", "train_length", ",", "observation_dim", "=", "train_sequence", ".", "shape", "\n", "if", "i", "==", "0", ":", "\n", "      ", "global_observation_dim", "=", "observation_dim", "\n", "", "elif", "global_observation_dim", "!=", "observation_dim", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "'train_sequences must have consistent observation dimension'", ")", "\n", "", "if", "not", "isinstance", "(", "train_cluster_id", ",", "list", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\n", "'Elements of train_cluster_ids must be list or numpy.ndarray'", ")", "\n", "", "if", "len", "(", "train_cluster_id", ")", "!=", "train_length", ":", "\n", "      ", "raise", "ValueError", "(", "\n", "'Each train_sequence and its train_cluster_id must have same length'", ")", "\n", "\n", "# enforce uniqueness", "\n", "", "", "if", "enforce_uniqueness", ":", "\n", "    ", "train_cluster_ids", "=", "enforce_cluster_id_uniqueness", "(", "train_cluster_ids", ")", "\n", "\n", "# random shuffle", "\n", "", "if", "shuffle", ":", "\n", "    ", "zipped_input", "=", "list", "(", "zip", "(", "train_sequences", ",", "train_cluster_ids", ")", ")", "\n", "random", ".", "shuffle", "(", "zipped_input", ")", "\n", "train_sequences", ",", "train_cluster_ids", "=", "zip", "(", "*", "zipped_input", ")", "\n", "\n", "# concatenate", "\n", "", "concatenated_train_sequence", "=", "np", ".", "concatenate", "(", "train_sequences", ",", "axis", "=", "0", ")", "\n", "concatenated_train_cluster_id", "=", "[", "x", "for", "train_cluster_id", "in", "train_cluster_ids", "\n", "for", "x", "in", "train_cluster_id", "]", "\n", "return", "concatenated_train_sequence", ",", "concatenated_train_cluster_id", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.sample_permuted_segments": [[143, 187], ["range", "len", "segments.append", "range", "numpy.random.permutation", "sampled_index_sequences.append", "len", "segments_array.append", "numpy.concatenate", "len", "segments.append", "segments.append", "len"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append"], ["", "def", "sample_permuted_segments", "(", "index_sequence", ",", "number_samples", ")", ":", "\n", "  ", "\"\"\"Sample sequences with permuted blocks.\n\n  Args:\n    index_sequence: (integer array, size: L)\n      - subsequence index\n      For example, index_sequence = [1,2,6,10,11,12].\n    number_samples: (integer)\n      - number of subsampled block-preserving permuted sequences.\n      For example, number_samples = 5\n\n  Returns:\n    sampled_index_sequences: (a list of numpy arrays) - a list of subsampled\n      block-preserving permuted sequences. For example,\n    ```\n    sampled_index_sequences =\n    [[10,11,12,1,2,6],\n     [6,1,2,10,11,12],\n     [1,2,10,11,12,6],\n     [6,1,2,10,11,12],\n     [1,2,6,10,11,12]]\n    ```\n      The length of \"sampled_index_sequences\" is \"number_samples\".\n  \"\"\"", "\n", "segments", "=", "[", "]", "\n", "if", "len", "(", "index_sequence", ")", "==", "1", ":", "\n", "    ", "segments", ".", "append", "(", "index_sequence", ")", "\n", "", "else", ":", "\n", "    ", "prev", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "index_sequence", ")", "-", "1", ")", ":", "\n", "      ", "if", "index_sequence", "[", "i", "+", "1", "]", "!=", "index_sequence", "[", "i", "]", "+", "1", ":", "\n", "        ", "segments", ".", "append", "(", "index_sequence", "[", "prev", ":", "(", "i", "+", "1", ")", "]", ")", "\n", "prev", "=", "i", "+", "1", "\n", "", "if", "i", "+", "1", "==", "len", "(", "index_sequence", ")", "-", "1", ":", "\n", "        ", "segments", ".", "append", "(", "index_sequence", "[", "prev", ":", "]", ")", "\n", "# sample permutations", "\n", "", "", "", "sampled_index_sequences", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "number_samples", ")", ":", "\n", "    ", "segments_array", "=", "[", "]", "\n", "permutation", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "segments", ")", ")", "\n", "for", "permutation_item", "in", "permutation", ":", "\n", "      ", "segments_array", ".", "append", "(", "segments", "[", "permutation_item", "]", ")", "\n", "", "sampled_index_sequences", ".", "append", "(", "np", ".", "concatenate", "(", "segments_array", ")", ")", "\n", "", "return", "sampled_index_sequences", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.resize_sequence": [[189, 219], ["numpy.unique", "utils.sample_permuted_segments", "range", "numpy.where", "sub_sequences.append", "seq_lengths.append", "numpy.where", "sub_sequences.append", "seq_lengths.append", "len", "len"], "function", ["home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.sample_permuted_segments", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append", "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.uisrnn.BeamState.append"], ["", "def", "resize_sequence", "(", "sequence", ",", "cluster_id", ",", "num_permutations", "=", "None", ")", ":", "\n", "  ", "\"\"\"Resize sequences for packing and batching.\n\n  Args:\n    sequence: (real numpy matrix, size: seq_len*obs_size) - observed sequence\n    cluster_id: (numpy vector, size: seq_len) - cluster indicator sequence\n    num_permutations: int - Number of permutations per utterance sampled.\n\n  Returns:\n    sub_sequences: A list of numpy array, with obsevation vector from the same\n      cluster in the same list.\n    seq_lengths: The length of each cluster (+1).\n  \"\"\"", "\n", "# merge sub-sequences that belong to a single cluster to a single sequence", "\n", "unique_id", "=", "np", ".", "unique", "(", "cluster_id", ")", "\n", "sub_sequences", "=", "[", "]", "\n", "seq_lengths", "=", "[", "]", "\n", "if", "num_permutations", "and", "num_permutations", ">", "1", ":", "\n", "    ", "for", "i", "in", "unique_id", ":", "\n", "      ", "idx_set", "=", "np", ".", "where", "(", "cluster_id", "==", "i", ")", "[", "0", "]", "\n", "sampled_idx_sets", "=", "sample_permuted_segments", "(", "idx_set", ",", "num_permutations", ")", "\n", "for", "j", "in", "range", "(", "num_permutations", ")", ":", "\n", "        ", "sub_sequences", ".", "append", "(", "sequence", "[", "sampled_idx_sets", "[", "j", "]", ",", ":", "]", ")", "\n", "seq_lengths", ".", "append", "(", "len", "(", "idx_set", ")", "+", "1", ")", "\n", "", "", "", "else", ":", "\n", "    ", "for", "i", "in", "unique_id", ":", "\n", "      ", "idx_set", "=", "np", ".", "where", "(", "cluster_id", "==", "i", ")", "\n", "sub_sequences", ".", "append", "(", "sequence", "[", "idx_set", ",", ":", "]", "[", "0", "]", ")", "\n", "seq_lengths", ".", "append", "(", "len", "(", "idx_set", "[", "0", "]", ")", "+", "1", ")", "\n", "", "", "return", "sub_sequences", ",", "seq_lengths", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.pack_sequence": [[221, 279], ["len", "torch.from_numpy().float().to", "numpy.sort", "numpy.argsort", "numpy.zeros", "range", "torch.autograd.Variable().to", "torch.nn.utils.rnn.pack_padded_sequence", "numpy.sort", "numpy.zeros", "range", "torch.autograd.Variable().to", "torch.nn.utils.rnn.pack_padded_sequence", "numpy.zeros_like", "range", "numpy.random.choice", "range", "torch.from_numpy().float", "torch.autograd.Variable", "torch.autograd.Variable", "numpy.random.randint", "numpy.mean", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy", "min", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["", "def", "pack_sequence", "(", "sub_sequences", ",", "seq_lengths", ",", "batch_size", ",", "observation_dim", ",", "\n", "device", ",", "loss_samples", ")", ":", "\n", "  ", "\"\"\"Pack sequences for training.\n\n  Args:\n    sub_sequences: A list of numpy array, with obsevation vector from the same\n      cluster in the same list.\n    seq_lengths: The length of each cluster (+1).\n    batch_size: int or None - Run batch learning if batch_size is None. Else,\n      run online learning with specified batch size.\n    observation_dim: int - dimension for observation vectors\n    device: str - Your device. E.g., `cuda:0` or `cpu`.\n\n  Returns:\n    packed_rnn_input: (PackedSequence object) packed rnn input\n    rnn_truth: ground truth\n  \"\"\"", "\n", "num_clusters", "=", "len", "(", "seq_lengths", ")", "\n", "sorted_seq_lengths", "=", "np", ".", "sort", "(", "seq_lengths", ")", "[", ":", ":", "-", "1", "]", "\n", "permute_index", "=", "np", ".", "argsort", "(", "seq_lengths", ")", "[", ":", ":", "-", "1", "]", "\n", "\n", "if", "batch_size", "is", "None", ":", "\n", "    ", "rnn_input", "=", "np", ".", "zeros", "(", "(", "sorted_seq_lengths", "[", "0", "]", ",", "\n", "num_clusters", ",", "\n", "observation_dim", ")", ")", "\n", "for", "i", "in", "range", "(", "num_clusters", ")", ":", "\n", "      ", "rnn_input", "[", "1", ":", "sorted_seq_lengths", "[", "i", "]", ",", "i", ",", "\n", ":", "]", "=", "sub_sequences", "[", "permute_index", "[", "i", "]", "]", "\n", "", "rnn_input_tensor", "=", "autograd", ".", "Variable", "(", "\n", "torch", ".", "from_numpy", "(", "rnn_input", ")", ".", "float", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "packed_rnn_input", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pack_padded_sequence", "(", "\n", "rnn_input_tensor", ",", "sorted_seq_lengths", ",", "batch_first", "=", "False", ")", "\n", "", "else", ":", "\n", "    ", "mini_batch", "=", "np", ".", "sort", "(", "np", ".", "random", ".", "choice", "(", "num_clusters", ",", "batch_size", ")", ")", "\n", "rnn_input", "=", "np", ".", "zeros", "(", "(", "sorted_seq_lengths", "[", "mini_batch", "[", "0", "]", "]", ",", "\n", "batch_size", ",", "\n", "observation_dim", ")", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "      ", "rnn_input", "[", "1", ":", "sorted_seq_lengths", "[", "mini_batch", "[", "i", "]", "]", ",", "\n", "i", ",", ":", "]", "=", "sub_sequences", "[", "permute_index", "[", "mini_batch", "[", "i", "]", "]", "]", "\n", "", "rnn_input_tensor", "=", "autograd", ".", "Variable", "(", "\n", "torch", ".", "from_numpy", "(", "rnn_input", ")", ".", "float", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "packed_rnn_input", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pack_padded_sequence", "(", "\n", "rnn_input_tensor", ",", "sorted_seq_lengths", "[", "mini_batch", "]", ",", "batch_first", "=", "False", ")", "\n", "# build ground truth", "\n", "", "if", "loss_samples", ">", "0", ":", "#", "\n", "    ", "rnn_truth", "=", "np", ".", "zeros_like", "(", "rnn_input", "[", "1", ":", ",", ":", ",", ":", "]", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "      ", "for", "j", "in", "range", "(", "sorted_seq_lengths", "[", "mini_batch", "[", "i", "]", "]", "-", "1", ")", ":", "\n", "        ", "samples_idx", "=", "np", ".", "random", ".", "randint", "(", "\n", "low", "=", "j", "+", "1", ",", "\n", "high", "=", "sorted_seq_lengths", "[", "mini_batch", "[", "i", "]", "]", ",", "\n", "size", "=", "min", "(", "loss_samples", ",", "sorted_seq_lengths", "[", "mini_batch", "[", "i", "]", "]", "-", "j", "-", "1", ")", ")", "\n", "rnn_truth", "[", "j", "]", "=", "np", ".", "mean", "(", "rnn_input", "[", "samples_idx", ",", "i", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "", "", "", "else", ":", "\n", "    ", "rnn_truth", "=", "rnn_input", "[", "1", ":", ",", ":", ",", ":", "]", "\n", "", "rnn_truth", "=", "torch", ".", "from_numpy", "(", "rnn_truth", ")", ".", "float", "(", ")", ".", "to", "(", "device", ")", "\n", "return", "packed_rnn_input", ",", "rnn_truth", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.output_result": [[281, 314], ["zip", "numpy.mean", "open", "file_object.write"], "function", ["None"], ["", "def", "output_result", "(", "model_args", ",", "training_args", ",", "test_record", ")", ":", "\n", "  ", "\"\"\"Produce a string to summarize the experiment.\"\"\"", "\n", "accuracy_array", ",", "_", "=", "zip", "(", "*", "test_record", ")", "\n", "total_accuracy", "=", "np", ".", "mean", "(", "accuracy_array", ")", "\n", "output_string", "=", "\"\"\"\nConfig:\n  sigma_alpha: {}\n  sigma_beta: {}\n  crp_alpha: {}\n  learning rate: {}\n  regularization: {}\n  batch size: {}\n\nPerformance:\n  averaged accuracy: {:.6f}\n  accuracy numbers for all testing sequences:\n  \"\"\"", ".", "strip", "(", ")", ".", "format", "(", "\n", "training_args", ".", "sigma_alpha", ",", "\n", "training_args", ".", "sigma_beta", ",", "\n", "model_args", ".", "crp_alpha", ",", "\n", "training_args", ".", "learning_rate", ",", "\n", "training_args", ".", "regularization_weight", ",", "\n", "training_args", ".", "batch_size", ",", "\n", "total_accuracy", ")", "\n", "for", "accuracy", "in", "accuracy_array", ":", "\n", "    ", "output_string", "+=", "'\\n    {:.6f}'", ".", "format", "(", "accuracy", ")", "\n", "", "output_string", "+=", "'\\n'", "+", "'='", "*", "80", "+", "'\\n'", "\n", "filename", "=", "'layer_{}_{}_{:.1f}_result.txt'", ".", "format", "(", "\n", "model_args", ".", "rnn_hidden_size", ",", "\n", "model_args", ".", "rnn_depth", ",", "model_args", ".", "rnn_dropout", ")", "\n", "with", "open", "(", "filename", ",", "'a'", ")", "as", "file_object", ":", "\n", "    ", "file_object", ".", "write", "(", "output_string", ")", "\n", "", "return", "output_string", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.estimate_transition_bias": [[316, 342], ["range", "len"], "function", ["None"], ["", "def", "estimate_transition_bias", "(", "cluster_ids", ",", "smooth", "=", "1", ")", ":", "\n", "  ", "\"\"\"Estimate the transition bias.\n\n  Args:\n    cluster_id: Either a list of cluster indicator sequences, or a single\n      concatenated sequence. The former is strongly preferred, since the\n      transition_bias estimated from the latter will be inaccurate.\n    smooth: int or float - Smoothing coefficient, avoids -inf value in np.log\n      in the case of a sequence with a single speaker and division by 0 in the\n      case of empty sequences. Using a small value for smooth decreases the\n      bias in the calculation of transition_bias but can also lead to underflow\n      in some remote cases, larger values are safer but less accurate.\n\n  Returns:\n    bias: Flipping coin head probability.\n    bias_denominator: The denominator of the bias, used for multiple calls to\n      fit().\n  \"\"\"", "\n", "transit_num", "=", "smooth", "\n", "bias_denominator", "=", "2", "*", "smooth", "\n", "for", "cluster_id_seq", "in", "cluster_ids", ":", "\n", "    ", "for", "entry", "in", "range", "(", "len", "(", "cluster_id_seq", ")", "-", "1", ")", ":", "\n", "      ", "transit_num", "+=", "(", "cluster_id_seq", "[", "entry", "]", "!=", "cluster_id_seq", "[", "entry", "+", "1", "]", ")", "\n", "bias_denominator", "+=", "1", "\n", "", "", "bias", "=", "transit_num", "/", "bias_denominator", "\n", "return", "bias", ",", "bias_denominator", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.utils.estimate_crp_alpha": [[344, 369], ["sum", "range", "len", "len", "set"], "function", ["None"], ["", "def", "estimate_crp_alpha", "(", "cluster_ids", ",", "smooth", "=", "1", ")", ":", "\n", "  ", "\"\"\"Estimate the transition bias.\n\n  Args:\n    cluster_id: Either a list of cluster indicator sequences, or a single\n      concatenated sequence. The former is strongly preferred, since the\n      transition_bias estimated from the latter will be inaccurate.\n    smooth: int or float - Smoothing coefficient, avoids -inf value in np.log\n      in the case of a sequence with a single speaker and division by 0 in the\n      case of empty sequences. Using a small value for smooth decreases the\n      bias in the calculation of transition_bias but can also lead to underflow\n      in some remote cases, larger values are safer but less accurate.\n\n  Returns:\n    crp_alpha: alpha parameter of the ddCRP that quentifies the probability\n      of a new speaker joining the conversation.\n    crp_alpha_denominator: The denominator of for crp_alpha, used for\n      multiple calls to fit().\n  \"\"\"", "\n", "speaker_joins", "=", "sum", "(", "len", "(", "set", "(", "seq", ")", ")", "-", "1", "for", "seq", "in", "cluster_ids", ")", "+", "smooth", "\n", "speaker_changes", "=", "2", "*", "smooth", "\n", "for", "cluster_id_seq", "in", "cluster_ids", ":", "\n", "    ", "for", "entry", "in", "range", "(", "len", "(", "cluster_id_seq", ")", "-", "1", ")", ":", "\n", "      ", "speaker_changes", "+=", "(", "cluster_id_seq", "[", "entry", "]", "!=", "cluster_id_seq", "[", "entry", "+", "1", "]", ")", "\n", "", "", "return", "speaker_joins", "/", "speaker_changes", ",", "speaker_changes", "\n", "", ""]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.weighted_mse_loss": [[19, 42], ["float", "torch.sum().float", "torch.mm", "input_tensor.size", "torch.diag", "streched_tensor.size", "torch.sum", "weight.float().view", "torch.mean", "weight.nelement", "weight.float"], "function", ["None"], ["def", "weighted_mse_loss", "(", "input_tensor", ",", "target_tensor", ",", "weight", "=", "1", ")", ":", "\n", "  ", "\"\"\"Compute weighted MSE loss.\n\n  Note that we are doing weighted loss that only sum up over non-zero entries.\n\n  Args:\n    input_tensor: input tensor\n    target_tensor: target tensor\n    weight: weight tensor, in this case 1/sigma^2\n\n  Returns:\n    the weighted MSE loss\n  \"\"\"", "\n", "observation_dim", "=", "input_tensor", ".", "size", "(", ")", "[", "-", "1", "]", "\n", "streched_tensor", "=", "(", "(", "input_tensor", "-", "target_tensor", ")", "**", "2", ")", ".", "view", "(", "\n", "-", "1", ",", "observation_dim", ")", "\n", "entry_num", "=", "float", "(", "streched_tensor", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "non_zero_entry_num", "=", "torch", ".", "sum", "(", "streched_tensor", "[", ":", ",", "0", "]", "!=", "0", ")", ".", "float", "(", ")", "\n", "weighted_tensor", "=", "torch", ".", "mm", "(", "\n", "(", "(", "input_tensor", "-", "target_tensor", ")", "**", "2", ")", ".", "view", "(", "-", "1", ",", "observation_dim", ")", ",", "\n", "(", "torch", ".", "diag", "(", "weight", ".", "float", "(", ")", ".", "view", "(", "-", "1", ")", ")", ")", ")", "\n", "return", "torch", ".", "mean", "(", "\n", "weighted_tensor", ")", "*", "weight", ".", "nelement", "(", ")", "*", "entry_num", "/", "non_zero_entry_num", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.sigma2_prior_loss": [[44, 61], ["torch.log"], "function", ["None"], ["", "def", "sigma2_prior_loss", "(", "num_non_zero", ",", "sigma_alpha", ",", "sigma_beta", ",", "sigma2", ")", ":", "\n", "  ", "\"\"\"Compute sigma2 prior loss.\n\n  Args:\n    num_non_zero: since rnn_truth is a collection of different length sequences\n        padded with zeros to fit them into a tensor, we count the sum of\n        'real lengths' of all sequences\n    sigma_alpha: inverse gamma shape\n    sigma_beta: inverse gamma scale\n    sigma2: sigma squared\n\n  Returns:\n    the sigma2 prior loss\n  \"\"\"", "\n", "return", "(", "(", "2", "*", "sigma_alpha", "+", "num_non_zero", "+", "2", ")", "/", "\n", "(", "2", "*", "num_non_zero", ")", "*", "torch", ".", "log", "(", "sigma2", ")", ")", ".", "sum", "(", ")", "+", "(", "\n", "sigma_beta", "/", "(", "sigma2", "*", "num_non_zero", ")", ")", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.DonkeyShot21_uis-rnn-sml.uisrnn.loss_func.regularization_loss": [[63, 77], ["torch.norm"], "function", ["None"], ["", "def", "regularization_loss", "(", "params", ",", "weight", ")", ":", "\n", "  ", "\"\"\"Compute regularization loss.\n\n  Args:\n    params: iterable of all parameters\n    weight: weight for the regularization term\n\n  Returns:\n    the regularization loss\n  \"\"\"", "\n", "l2_reg", "=", "0", "\n", "for", "param", "in", "params", ":", "\n", "    ", "l2_reg", "+=", "torch", ".", "norm", "(", "param", ")", "\n", "", "return", "weight", "*", "l2_reg", "\n", "", ""]]}