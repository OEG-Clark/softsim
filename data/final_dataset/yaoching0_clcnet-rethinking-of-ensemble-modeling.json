{"home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.None.generate_data_for_CLCNet.model_inference": [[40, 61], ["torch.stack", "model1", "torch.nn.Softmax", "torch.nn.Softmax.", "transform1", "img1.type.type", "stack_list1.append", "img1.type.cuda", "img.copy"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["def", "model_inference", "(", "img_list", ",", "model1", ",", "idx_to_class", ",", "transform1", ")", ":", "\n", "\n", "    ", "stack_list1", "=", "[", "]", "\n", "\n", "for", "img", "in", "img_list", ":", "\n", "        ", "img1", "=", "transform1", "(", "img", ".", "copy", "(", ")", ")", "\n", "img1", "=", "img1", ".", "type", "(", "torch", ".", "FloatTensor", ")", "\n", "stack_list1", ".", "append", "(", "img1", ")", "\n", "\n", "", "img1", "=", "torch", ".", "stack", "(", "stack_list1", ",", "dim", "=", "0", ")", "\n", "\n", "# Model gets predictions", "\n", "predict_result1", "=", "model1", "(", "img1", ".", "cuda", "(", ")", ")", "\n", "\n", "\n", "# Define softmax", "\n", "sm", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "predict_result1", "=", "sm", "(", "predict_result1", ")", "\n", "\n", "return", "predict_result1", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.SparsemaxFunction.forward": [[31, 56], ["input.max", "sparsemax.SparsemaxFunction._threshold_and_support", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "ctx.save_for_backward"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15Function._threshold_and_support"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"sparsemax: normalizing sparse transform (a la softmax)\n\n        Parameters\n        ----------\n        ctx : torch.autograd.function._ContextMethodMixin\n        input : torch.Tensor\n            any shape\n        dim : int\n            dimension along which to apply sparsemax\n\n        Returns\n        -------\n        output : torch.Tensor\n            same shape as input\n\n        \"\"\"", "\n", "ctx", ".", "dim", "=", "dim", "\n", "max_val", ",", "_", "=", "input", ".", "max", "(", "dim", "=", "dim", ",", "keepdim", "=", "True", ")", "\n", "input", "-=", "max_val", "# same numerical stability trick as for softmax", "\n", "tau", ",", "supp_size", "=", "SparsemaxFunction", ".", "_threshold_and_support", "(", "input", ",", "dim", "=", "dim", ")", "\n", "output", "=", "torch", ".", "clamp", "(", "input", "-", "tau", ",", "min", "=", "0", ")", "\n", "ctx", ".", "save_for_backward", "(", "supp_size", ",", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.SparsemaxFunction.backward": [[57, 68], ["grad_output.clone", "v_hat.unsqueeze.unsqueeze.unsqueeze", "torch.where", "torch.where", "torch.where", "torch.where", "torch.where.sum", "torch.where.sum", "supp_size.to().squeeze", "supp_size.to"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "supp_size", ",", "output", "=", "ctx", ".", "saved_tensors", "\n", "dim", "=", "ctx", ".", "dim", "\n", "grad_input", "=", "grad_output", ".", "clone", "(", ")", "\n", "grad_input", "[", "output", "==", "0", "]", "=", "0", "\n", "\n", "v_hat", "=", "grad_input", ".", "sum", "(", "dim", "=", "dim", ")", "/", "supp_size", ".", "to", "(", "output", ".", "dtype", ")", ".", "squeeze", "(", ")", "\n", "v_hat", "=", "v_hat", ".", "unsqueeze", "(", "dim", ")", "\n", "grad_input", "=", "torch", ".", "where", "(", "output", "!=", "0", ",", "grad_input", "-", "v_hat", ",", "grad_input", ")", "\n", "return", "grad_input", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.SparsemaxFunction._threshold_and_support": [[69, 97], ["torch.sort", "torch.sort", "torch.sort", "torch.sort", "sparsemax._make_ix_like", "support.sum().unsqueeze", "input_cumsum.gather", "support.sum().unsqueeze.to", "input_srt.cumsum", "support.sum"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax._make_ix_like"], ["", "@", "staticmethod", "\n", "def", "_threshold_and_support", "(", "input", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "\"\"\"Sparsemax building block: compute the threshold\n\n        Parameters\n        ----------\n        input: torch.Tensor\n            any dimension\n        dim : int\n            dimension along which to apply the sparsemax\n\n        Returns\n        -------\n        tau : torch.Tensor\n            the threshold value\n        support_size : torch.Tensor\n\n        \"\"\"", "\n", "\n", "input_srt", ",", "_", "=", "torch", ".", "sort", "(", "input", ",", "descending", "=", "True", ",", "dim", "=", "dim", ")", "\n", "input_cumsum", "=", "input_srt", ".", "cumsum", "(", "dim", ")", "-", "1", "\n", "rhos", "=", "_make_ix_like", "(", "input", ",", "dim", ")", "\n", "support", "=", "rhos", "*", "input_srt", ">", "input_cumsum", "\n", "\n", "support_size", "=", "support", ".", "sum", "(", "dim", "=", "dim", ")", ".", "unsqueeze", "(", "dim", ")", "\n", "tau", "=", "input_cumsum", ".", "gather", "(", "dim", ",", "support_size", "-", "1", ")", "\n", "tau", "/=", "support_size", ".", "to", "(", "input", ".", "dtype", ")", "\n", "return", "tau", ",", "support_size", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Sparsemax.__init__": [[104, 107], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "dim", "=", "dim", "\n", "super", "(", "Sparsemax", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Sparsemax.forward": [[108, 110], ["sparsemax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "sparsemax", "(", "input", ",", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15Function.forward": [[119, 131], ["input.max", "sparsemax.Entmax15Function._threshold_and_support", "ctx.save_for_backward", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15Function._threshold_and_support"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "ctx", ".", "dim", "=", "dim", "\n", "\n", "max_val", ",", "_", "=", "input", ".", "max", "(", "dim", "=", "dim", ",", "keepdim", "=", "True", ")", "\n", "input", "=", "input", "-", "max_val", "# same numerical stability trick as for softmax", "\n", "input", "=", "input", "/", "2", "# divide by 2 to solve actual Entmax", "\n", "\n", "tau_star", ",", "_", "=", "Entmax15Function", ".", "_threshold_and_support", "(", "input", ",", "dim", ")", "\n", "output", "=", "torch", ".", "clamp", "(", "input", "-", "tau_star", ",", "min", "=", "0", ")", "**", "2", "\n", "ctx", ".", "save_for_backward", "(", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15Function.backward": [[132, 141], ["Y.sqrt", "q.unsqueeze.unsqueeze.unsqueeze", "dX.sum", "Y.sqrt.sum"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "Y", ",", "=", "ctx", ".", "saved_tensors", "\n", "gppr", "=", "Y", ".", "sqrt", "(", ")", "# = 1 / g'' (Y)", "\n", "dX", "=", "grad_output", "*", "gppr", "\n", "q", "=", "dX", ".", "sum", "(", "ctx", ".", "dim", ")", "/", "gppr", ".", "sum", "(", "ctx", ".", "dim", ")", "\n", "q", "=", "q", ".", "unsqueeze", "(", "ctx", ".", "dim", ")", "\n", "dX", "-=", "q", "*", "gppr", "\n", "return", "dX", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15Function._threshold_and_support": [[142, 161], ["torch.sort", "torch.sort", "torch.sort", "torch.sort", "sparsemax._make_ix_like", "torch.clamp", "torch.clamp", "torch.clamp", "torch.clamp", "tau.gather", "Xsrt.cumsum", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax._make_ix_like"], ["", "@", "staticmethod", "\n", "def", "_threshold_and_support", "(", "input", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "Xsrt", ",", "_", "=", "torch", ".", "sort", "(", "input", ",", "descending", "=", "True", ",", "dim", "=", "dim", ")", "\n", "\n", "rho", "=", "_make_ix_like", "(", "input", ",", "dim", ")", "\n", "mean", "=", "Xsrt", ".", "cumsum", "(", "dim", ")", "/", "rho", "\n", "mean_sq", "=", "(", "Xsrt", "**", "2", ")", ".", "cumsum", "(", "dim", ")", "/", "rho", "\n", "ss", "=", "rho", "*", "(", "mean_sq", "-", "mean", "**", "2", ")", "\n", "delta", "=", "(", "1", "-", "ss", ")", "/", "rho", "\n", "\n", "# NOTE this is not exactly the same as in reference algo", "\n", "# Fortunately it seems the clamped values never wrongly", "\n", "# get selected by tau <= sorted_z. Prove this!", "\n", "delta_nz", "=", "torch", ".", "clamp", "(", "delta", ",", "0", ")", "\n", "tau", "=", "mean", "-", "torch", ".", "sqrt", "(", "delta_nz", ")", "\n", "\n", "support_size", "=", "(", "tau", "<=", "Xsrt", ")", ".", "sum", "(", "dim", ")", ".", "unsqueeze", "(", "dim", ")", "\n", "tau_star", "=", "tau", ".", "gather", "(", "dim", ",", "support_size", "-", "1", ")", "\n", "return", "tau_star", ",", "support_size", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15.forward": [[166, 171], ["sparsemax.Entmoid15._forward", "ctx.save_for_backward"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15._forward"], ["@", "staticmethod", "\n", "def", "forward", "(", "ctx", ",", "input", ")", ":", "\n", "        ", "output", "=", "Entmoid15", ".", "_forward", "(", "input", ")", "\n", "ctx", ".", "save_for_backward", "(", "output", ")", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15._forward": [[172, 179], ["tau.masked_fill_", "torch.where", "torch.where", "torch.where", "torch.where", "abs", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.relu", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_forward", "(", "input", ")", ":", "\n", "        ", "input", ",", "is_pos", "=", "abs", "(", "input", ")", ",", "input", ">=", "0", "\n", "tau", "=", "(", "input", "+", "torch", ".", "sqrt", "(", "F", ".", "relu", "(", "8", "-", "input", "**", "2", ")", ")", ")", "/", "2", "\n", "tau", ".", "masked_fill_", "(", "tau", "<=", "input", ",", "2.0", ")", "\n", "y_neg", "=", "0.25", "*", "F", ".", "relu", "(", "tau", "-", "input", ",", "inplace", "=", "True", ")", "**", "2", "\n", "return", "torch", ".", "where", "(", "is_pos", ",", "1", "-", "y_neg", ",", "y_neg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15.backward": [[180, 183], ["sparsemax.Entmoid15._backward"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15._backward"], ["", "@", "staticmethod", "\n", "def", "backward", "(", "ctx", ",", "grad_output", ")", ":", "\n", "        ", "return", "Entmoid15", ".", "_backward", "(", "ctx", ".", "saved_tensors", "[", "0", "]", ",", "grad_output", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15._backward": [[184, 191], ["output.sqrt"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "_backward", "(", "output", ",", "grad_output", ")", ":", "\n", "        ", "gppr0", ",", "gppr1", "=", "output", ".", "sqrt", "(", ")", ",", "(", "1", "-", "output", ")", ".", "sqrt", "(", ")", "\n", "grad_input", "=", "grad_output", "*", "gppr0", "\n", "q", "=", "grad_input", "/", "(", "gppr0", "+", "gppr1", ")", "\n", "grad_input", "-=", "q", "*", "gppr0", "\n", "return", "grad_input", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15.__init__": [[199, 202], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "dim", "=", "dim", "\n", "super", "(", "Entmax15", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmax15.forward": [[203, 205], ["entmax15"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "return", "entmax15", "(", "input", ",", "self", ".", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax._make_ix_like": [[16, 22], ["input.size", "torch.arange", "torch.arange", "torch.arange.view().transpose", "input.dim", "torch.arange.view"], "function", ["None"], ["def", "_make_ix_like", "(", "input", ",", "dim", "=", "0", ")", ":", "\n", "    ", "d", "=", "input", ".", "size", "(", "dim", ")", "\n", "rho", "=", "torch", ".", "arange", "(", "1", ",", "d", "+", "1", ",", "device", "=", "input", ".", "device", ",", "dtype", "=", "input", ".", "dtype", ")", "\n", "view", "=", "[", "1", "]", "*", "input", ".", "dim", "(", ")", "\n", "view", "[", "0", "]", "=", "-", "1", "\n", "return", "rho", ".", "view", "(", "view", ")", ".", "transpose", "(", "0", ",", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.restricted_self_attention.Restricted_SelfAttention.__init__": [[19, 34], ["torch.nn.Module.__init__", "int", "torch.nn.Linear().cuda", "torch.nn.Linear().cuda", "gaussian.generate_V_matrix", "ValueError", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.generate_V_matrix"], ["def", "__init__", "(", "self", ",", "num_attention_heads", ",", "input_size", ",", "input_dim", ",", "hidden_size", ",", "qkdim", ")", ":", "\n", "        ", "super", "(", "Restricted_SelfAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "(", "(", "hidden_size", "%", "num_attention_heads", ")", "!=", "0", ")", "or", "(", "(", "qkdim", "%", "num_attention_heads", ")", "!=", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"The hidden/qkdim size (%d) is not a multiple of the number of attention \"", "\n", "\"heads (%d)\"", "%", "(", "hidden_size", ",", "num_attention_heads", ")", ")", "\n", "", "self", ".", "num_attention_heads", "=", "num_attention_heads", "\n", "self", ".", "attention_head_size", "=", "int", "(", "hidden_size", "/", "num_attention_heads", ")", "\n", "self", ".", "all_head_size", "=", "hidden_size", "\n", "#  The dimensions of q and k may not be consistent with the output", "\n", "self", ".", "qkdim", "=", "qkdim", "\n", "self", ".", "query", "=", "nn", ".", "Linear", "(", "input_size", ",", "self", ".", "qkdim", ")", ".", "cuda", "(", ")", "\n", "self", ".", "key", "=", "nn", ".", "Linear", "(", "input_size", ",", "self", ".", "qkdim", ")", ".", "cuda", "(", ")", "\n", "\n", "self", ".", "gaussian_basis", "=", "gaussian", ".", "generate_V_matrix", "(", "in_dim", "=", "input_dim", ",", "out_dim", "=", "hidden_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.restricted_self_attention.Restricted_SelfAttention.transpose_for_scores": [[40, 44], ["x.view.view.view", "x.view.view.permute", "x.view.view.size"], "methods", ["None"], ["", "def", "transpose_for_scores", "(", "self", ",", "x", ")", ":", "\n", "        ", "new_x_shape", "=", "x", ".", "size", "(", ")", "[", ":", "-", "1", "]", "+", "(", "self", ".", "num_attention_heads", ",", "self", ".", "attention_head_size", ")", "\n", "x", "=", "x", ".", "view", "(", "*", "new_x_shape", ")", "\n", "return", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.restricted_self_attention.Restricted_SelfAttention.transpose_for_scores_for_qk": [[45, 49], ["x.view.view.view", "x.view.view.permute", "x.view.view.size", "int"], "methods", ["None"], ["", "def", "transpose_for_scores_for_qk", "(", "self", ",", "x", ")", ":", "\n", "        ", "new_x_shape", "=", "x", ".", "size", "(", ")", "[", ":", "-", "1", "]", "+", "(", "self", ".", "num_attention_heads", ",", "int", "(", "self", ".", "qkdim", "/", "self", ".", "num_attention_heads", ")", ")", "\n", "x", "=", "x", ".", "view", "(", "*", "new_x_shape", ")", "\n", "return", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.restricted_self_attention.Restricted_SelfAttention.forward": [[50, 100], ["restricted_self_attention.Restricted_SelfAttention.Restricted_SelfAttention.query", "restricted_self_attention.Restricted_SelfAttention.Restricted_SelfAttention.key", "gaussian.cal_self_att_V", "restricted_self_attention.Restricted_SelfAttention.Restricted_SelfAttention.transpose_for_scores_for_qk", "restricted_self_attention.Restricted_SelfAttention.Restricted_SelfAttention.transpose_for_scores_for_qk", "restricted_self_attention.Restricted_SelfAttention.Restricted_SelfAttention.transpose_for_scores", "torch.matmul", "attention_probs[].view", "torch.matmul", "context_layer.view.view.permute().contiguous", "context_layer.view.view.view", "torch.sort", "gaussian.generate_V_matrix", "restricted_self_attention.Restricted_SelfAttention.Restricted_SelfAttention.transpose", "math.sqrt", "torch.nn.Softmax", "context_layer.view.view.permute", "context_layer.view.view.size"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.cal_self_att_V", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores_for_qk", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores_for_qk", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.generate_V_matrix"], ["", "def", "forward", "(", "self", ",", "input_tensor", ")", ":", "\n", "\n", "# Check the V matrix and rebuild if it is inconsistent with the input dimension", "\n", "        ", "if", "input_tensor", ".", "shape", "[", "1", "]", "!=", "self", ".", "gaussian_basis", ".", "shape", "[", "0", "]", ":", "\n", "            ", "self", ".", "gaussian_basis", "=", "gaussian", ".", "generate_V_matrix", "(", "in_dim", "=", "input_tensor", ".", "shape", "[", "1", "]", ",", "out_dim", "=", "self", ".", "all_head_size", ")", "\n", "\n", "", "mixed_query_layer", "=", "self", ".", "query", "(", "input_tensor", ")", "\n", "mixed_key_layer", "=", "self", ".", "key", "(", "input_tensor", ")", "\n", "\n", "mixed_value_layer", "=", "gaussian", ".", "cal_self_att_V", "(", "gaussian_matrix", "=", "self", ".", "gaussian_basis", ",", "input", "=", "input_tensor", ")", "\n", "#mixed_value_layer = self.value(input_tensor)", "\n", "\n", "query_layer", "=", "self", ".", "transpose_for_scores_for_qk", "(", "mixed_query_layer", ")", "\n", "key_layer", "=", "self", ".", "transpose_for_scores_for_qk", "(", "mixed_key_layer", ")", "\n", "value_layer", "=", "self", ".", "transpose_for_scores", "(", "mixed_value_layer", ")", "\n", "\n", "# Take the dot product between \"query\" and \"key\" to get the raw attention scores.", "\n", "attention_scores", "=", "torch", ".", "matmul", "(", "query_layer", ",", "key_layer", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "attention_scores", "=", "attention_scores", "/", "math", ".", "sqrt", "(", "self", ".", "attention_head_size", ")", "\n", "\n", "# Apply the attention mask is (precomputed for all layers in BertModel forward() function)", "\n", "# [batch_size heads seq_len seq_len] scores", "\n", "# [batch_size 1 1 seq_len]", "\n", "\n", "# attention_scores = attention_scores + attention_mask", "\n", "\n", "# Normalize the attention scores to probabilities.", "\n", "attention_probs", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "(", "attention_scores", ")", "\n", "\n", "# Only keep the attention value of n=0 and subsequent calculations to save gpu memory", "\n", "attention_probs", "=", "attention_probs", "[", ":", ",", ":", ",", "0", ",", ":", "]", ".", "view", "(", "attention_probs", ".", "shape", "[", "0", "]", ",", "attention_probs", ".", "shape", "[", "1", "]", ",", "-", "1", ",", "attention_probs", ".", "shape", "[", "3", "]", ")", "\n", "# This is actually dropping out entire tokens to attend to, which might", "\n", "# seem a bit unusual, but is taken from the original Transformer paper.", "\n", "# Fixme", "\n", "#attention_probs = self.attn_dropout(attention_probs)", "\n", "context_layer", "=", "torch", ".", "matmul", "(", "attention_probs", ",", "value_layer", ")", "\n", "\n", "context_layer", "=", "context_layer", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "new_context_layer_shape", "=", "context_layer", ".", "size", "(", ")", "[", ":", "-", "2", "]", "+", "(", "self", ".", "all_head_size", ",", ")", "\n", "context_layer", "=", "context_layer", ".", "view", "(", "*", "new_context_layer_shape", ")", "\n", "\n", "# sort the output from largest to smallest", "\n", "context_layer", ",", "_", "=", "torch", ".", "sort", "(", "context_layer", ",", "descending", "=", "True", ",", "dim", "=", "2", ")", "\n", "\n", "#hidden_states = self.dense(context_layer)", "\n", "#hidden_states = self.out_dropout(hidden_states)", "\n", "#hidden_states = self.LayerNorm(hidden_states + input_tensor)", "\n", "\n", "#return hidden_states", "\n", "return", "context_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.__post_init__": [[25, 30], ["super().__post_init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__post_init__"], ["    ", "def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TabNetPretrainer", ",", "self", ")", ".", "__post_init__", "(", ")", "\n", "self", ".", "_task", "=", "'unsupervised'", "\n", "self", ".", "_default_loss", "=", "UnsupervisedLoss", "\n", "self", ".", "_default_metric", "=", "'unsup_loss'", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.prepare_target": [[31, 33], ["None"], "methods", ["None"], ["", "def", "prepare_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.compute_loss": [[34, 36], ["pretraining.TabNetPretrainer.loss_fn"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "output", ",", "embedded_x", ",", "obf_vars", ")", ":", "\n", "        ", "return", "self", ".", "loss_fn", "(", "output", ",", "embedded_x", ",", "obf_vars", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.update_fit_params": [[37, 44], ["utils.filter_weights"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.filter_weights"], ["", "def", "update_fit_params", "(", "\n", "self", ",", "\n", "weights", ",", "\n", ")", ":", "\n", "        ", "self", ".", "updated_weights", "=", "weights", "\n", "filter_weights", "(", "self", ".", "updated_weights", ")", "\n", "self", ".", "preds_mapper", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.fit": [[45, 166], ["sklearn.utils.check_array", "pretraining.TabNetPretrainer.update_fit_params", "pretraining_utils.validate_eval_set", "pretraining.TabNetPretrainer._construct_loaders", "pretraining.TabNetPretrainer._update_network_params", "pretraining.TabNetPretrainer._set_metrics", "pretraining.TabNetPretrainer._set_optimizer", "pretraining.TabNetPretrainer._set_callbacks", "pretraining.TabNetPretrainer._callback_container.on_train_begin", "range", "pretraining.TabNetPretrainer._callback_container.on_train_end", "pretraining.TabNetPretrainer.network.eval", "hasattr", "pretraining.TabNetPretrainer._set_network", "pretraining.TabNetPretrainer._callback_container.on_epoch_begin", "pretraining.TabNetPretrainer._train_epoch", "zip", "pretraining.TabNetPretrainer._callback_container.on_epoch_end", "pretraining.TabNetPretrainer._predict_epoch"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.update_fit_params", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.validate_eval_set", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._construct_loaders", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._update_network_params", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_metrics", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_optimizer", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_callbacks", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_train_begin", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.EarlyStopping.on_train_end", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_network", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_epoch_begin", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._train_epoch", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_epoch_end", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._predict_epoch"], ["", "def", "fit", "(", "\n", "self", ",", "\n", "X_train", ",", "\n", "eval_set", "=", "None", ",", "\n", "eval_name", "=", "None", ",", "\n", "loss_fn", "=", "None", ",", "\n", "pretraining_ratio", "=", "0.5", ",", "\n", "weights", "=", "0", ",", "\n", "max_epochs", "=", "100", ",", "\n", "patience", "=", "10", ",", "\n", "batch_size", "=", "1024", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "num_workers", "=", "0", ",", "\n", "drop_last", "=", "False", ",", "\n", "callbacks", "=", "None", ",", "\n", "pin_memory", "=", "True", ",", "\n", ")", ":", "\n", "        ", "\"\"\"Train a neural network stored in self.network\n        Using train_dataloader for training data and\n        valid_dataloader for validation.\n\n        Parameters\n        ----------\n        X_train : np.ndarray\n            Train set to reconstruct in self supervision\n        eval_set : list of np.array\n            List of evaluation set\n            The last one is used for early stopping\n        eval_name : list of str\n            List of eval set names.\n        eval_metric : list of str\n            List of evaluation metrics.\n            The last metric is used for early stopping.\n        loss_fn : callable or None\n            a PyTorch loss function\n            should be left to None for self supervised and non experts\n        pretraining_ratio : float\n            Between 0 and 1, percentage of feature to mask for reconstruction\n        weights : np.array\n            Sampling weights for each example.\n        max_epochs : int\n            Maximum number of epochs during training\n        patience : int\n            Number of consecutive non improving epoch before early stopping\n        batch_size : int\n            Training batch size\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization (virtual_batch_size < batch_size)\n        num_workers : int\n            Number of workers used in torch.utils.data.DataLoader\n        drop_last : bool\n            Whether to drop last batch during training\n        callbacks : list of callback function\n            List of custom callbacks\n        pin_memory: bool\n            Whether to set pin_memory to True or False during training\n        \"\"\"", "\n", "# update model name", "\n", "\n", "self", ".", "max_epochs", "=", "max_epochs", "\n", "self", ".", "patience", "=", "patience", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "num_workers", "=", "num_workers", "\n", "self", ".", "drop_last", "=", "drop_last", "\n", "self", ".", "input_dim", "=", "X_train", ".", "shape", "[", "1", "]", "\n", "self", ".", "_stop_training", "=", "False", "\n", "self", ".", "pin_memory", "=", "pin_memory", "and", "(", "self", ".", "device", ".", "type", "!=", "\"cpu\"", ")", "\n", "self", ".", "pretraining_ratio", "=", "pretraining_ratio", "\n", "eval_set", "=", "eval_set", "if", "eval_set", "else", "[", "]", "\n", "\n", "if", "loss_fn", "is", "None", ":", "\n", "            ", "self", ".", "loss_fn", "=", "self", ".", "_default_loss", "\n", "", "else", ":", "\n", "            ", "self", ".", "loss_fn", "=", "loss_fn", "\n", "\n", "", "check_array", "(", "X_train", ")", "\n", "\n", "self", ".", "update_fit_params", "(", "\n", "weights", ",", "\n", ")", "\n", "\n", "# Validate and reformat eval set depending on training data", "\n", "eval_names", "=", "validate_eval_set", "(", "eval_set", ",", "eval_name", ",", "X_train", ")", "\n", "train_dataloader", ",", "valid_dataloaders", "=", "self", ".", "_construct_loaders", "(", "\n", "X_train", ",", "eval_set", "\n", ")", "\n", "\n", "if", "not", "hasattr", "(", "self", ",", "'network'", ")", ":", "\n", "            ", "self", ".", "_set_network", "(", ")", "\n", "", "self", ".", "_update_network_params", "(", ")", "\n", "self", ".", "_set_metrics", "(", "eval_names", ")", "\n", "self", ".", "_set_optimizer", "(", ")", "\n", "self", ".", "_set_callbacks", "(", "callbacks", ")", "\n", "\n", "# Call method on_train_begin for all callbacks", "\n", "self", ".", "_callback_container", ".", "on_train_begin", "(", ")", "\n", "\n", "# Training loop over epochs", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "max_epochs", ")", ":", "\n", "\n", "# Call method on_epoch_begin for all callbacks", "\n", "            ", "self", ".", "_callback_container", ".", "on_epoch_begin", "(", "epoch_idx", ")", "\n", "\n", "self", ".", "_train_epoch", "(", "train_dataloader", ")", "\n", "\n", "# Apply predict epoch to all eval sets", "\n", "for", "eval_name", ",", "valid_dataloader", "in", "zip", "(", "eval_names", ",", "valid_dataloaders", ")", ":", "\n", "                ", "self", ".", "_predict_epoch", "(", "eval_name", ",", "valid_dataloader", ")", "\n", "\n", "# Call method on_epoch_end for all callbacks", "\n", "", "self", ".", "_callback_container", ".", "on_epoch_end", "(", "\n", "epoch_idx", ",", "logs", "=", "self", ".", "history", ".", "epoch_metrics", "\n", ")", "\n", "\n", "if", "self", ".", "_stop_training", ":", "\n", "                ", "break", "\n", "\n", "# Call method on_train_end for all callbacks", "\n", "", "", "self", ".", "_callback_container", ".", "on_train_end", "(", ")", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._set_network": [[167, 194], ["tab_network.TabNetPretraining().to", "utils.create_explain_matrix", "hasattr", "tab_network.TabNetPretraining"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_explain_matrix"], ["", "def", "_set_network", "(", "self", ")", ":", "\n", "        ", "\"\"\"Setup the network and explain matrix.\"\"\"", "\n", "if", "not", "hasattr", "(", "self", ",", "'pretraining_ratio'", ")", ":", "\n", "            ", "self", ".", "pretraining_ratio", "=", "0.5", "\n", "", "self", ".", "network", "=", "tab_network", ".", "TabNetPretraining", "(", "\n", "self", ".", "input_dim", ",", "\n", "pretraining_ratio", "=", "self", ".", "pretraining_ratio", ",", "\n", "n_d", "=", "self", ".", "n_d", ",", "\n", "n_a", "=", "self", ".", "n_a", ",", "\n", "n_steps", "=", "self", ".", "n_steps", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "cat_idxs", "=", "self", ".", "cat_idxs", ",", "\n", "cat_dims", "=", "self", ".", "cat_dims", ",", "\n", "cat_emb_dim", "=", "self", ".", "cat_emb_dim", ",", "\n", "n_independent", "=", "self", ".", "n_independent", ",", "\n", "n_shared", "=", "self", ".", "n_shared", ",", "\n", "epsilon", "=", "self", ".", "epsilon", ",", "\n", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", ",", "\n", "momentum", "=", "self", ".", "momentum", ",", "\n", "mask_type", "=", "self", ".", "mask_type", ",", "\n", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "self", ".", "reducing_matrix", "=", "create_explain_matrix", "(", "\n", "self", ".", "network", ".", "input_dim", ",", "\n", "self", ".", "network", ".", "cat_emb_dim", ",", "\n", "self", ".", "network", ".", "cat_idxs", ",", "\n", "self", ".", "network", ".", "post_embed_dim", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._update_network_params": [[196, 199], ["None"], "methods", ["None"], ["", "def", "_update_network_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "network", ".", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", "\n", "self", ".", "network", ".", "pretraining_ratio", "=", "self", ".", "pretraining_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._set_metrics": [[200, 230], ["metrics.check_metrics.check_metrics", "pretraining.TabNetPretrainer._metric_container_dict.items", "pretraining.TabNetPretrainer._metric_container_dict.update", "pretraining.TabNetPretrainer._metrics.extend", "pretraining.TabNetPretrainer._metrics_names.extend", "len", "metrics.check_metrics.UnsupMetricContainer"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.check_metrics"], ["", "def", "_set_metrics", "(", "self", ",", "eval_names", ")", ":", "\n", "        ", "\"\"\"Set attributes relative to the metrics.\n\n        Parameters\n        ----------\n        metrics : list of str\n            List of eval metric names.\n        eval_names : list of str\n            List of eval set names.\n\n        \"\"\"", "\n", "metrics", "=", "[", "self", ".", "_default_metric", "]", "\n", "\n", "metrics", "=", "check_metrics", "(", "metrics", ")", "\n", "# Set metric container for each sets", "\n", "self", ".", "_metric_container_dict", "=", "{", "}", "\n", "for", "name", "in", "eval_names", ":", "\n", "            ", "self", ".", "_metric_container_dict", ".", "update", "(", "\n", "{", "name", ":", "UnsupMetricContainer", "(", "metrics", ",", "prefix", "=", "f\"{name}_\"", ")", "}", "\n", ")", "\n", "\n", "", "self", ".", "_metrics", "=", "[", "]", "\n", "self", ".", "_metrics_names", "=", "[", "]", "\n", "for", "_", ",", "metric_container", "in", "self", ".", "_metric_container_dict", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "_metrics", ".", "extend", "(", "metric_container", ".", "metrics", ")", "\n", "self", ".", "_metrics_names", ".", "extend", "(", "metric_container", ".", "names", ")", "\n", "\n", "# Early stopping metric is the last eval metric", "\n", "", "self", ".", "early_stopping_metric", "=", "(", "\n", "self", ".", "_metrics_names", "[", "-", "1", "]", "if", "len", "(", "self", ".", "_metrics_names", ")", ">", "0", "else", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._construct_loaders": [[232, 260], ["pretraining_utils.create_dataloaders"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_dataloaders"], ["", "def", "_construct_loaders", "(", "self", ",", "X_train", ",", "eval_set", ")", ":", "\n", "        ", "\"\"\"Generate dataloaders for unsupervised train and eval set.\n\n        Parameters\n        ----------\n        X_train : np.array\n            Train set.\n        eval_set : list of tuple\n            List of eval tuple set (X, y).\n\n        Returns\n        -------\n        train_dataloader : `torch.utils.data.Dataloader`\n            Training dataloader.\n        valid_dataloaders : list of `torch.utils.data.Dataloader`\n            List of validation dataloaders.\n\n        \"\"\"", "\n", "train_dataloader", ",", "valid_dataloaders", "=", "create_dataloaders", "(", "\n", "X_train", ",", "\n", "eval_set", ",", "\n", "self", ".", "updated_weights", ",", "\n", "self", ".", "batch_size", ",", "\n", "self", ".", "num_workers", ",", "\n", "self", ".", "drop_last", ",", "\n", "self", ".", "pin_memory", ",", "\n", ")", "\n", "return", "train_dataloader", ",", "valid_dataloaders", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._train_epoch": [[261, 283], ["pretraining.TabNetPretrainer.network.train", "enumerate", "pretraining.TabNetPretrainer.history.epoch_metrics.update", "pretraining.TabNetPretrainer._callback_container.on_batch_begin", "pretraining.TabNetPretrainer._train_batch", "pretraining.TabNetPretrainer._callback_container.on_batch_end"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_batch_begin", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._train_batch", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_batch_end"], ["", "def", "_train_epoch", "(", "self", ",", "train_loader", ")", ":", "\n", "        ", "\"\"\"\n        Trains one epoch of the network in self.network\n\n        Parameters\n        ----------\n        train_loader : a :class: `torch.utils.data.Dataloader`\n            DataLoader with train set\n        \"\"\"", "\n", "self", ".", "network", ".", "train", "(", ")", "\n", "\n", "for", "batch_idx", ",", "X", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "            ", "self", ".", "_callback_container", ".", "on_batch_begin", "(", "batch_idx", ")", "\n", "\n", "batch_logs", "=", "self", ".", "_train_batch", "(", "X", ")", "\n", "\n", "self", ".", "_callback_container", ".", "on_batch_end", "(", "batch_idx", ",", "batch_logs", ")", "\n", "\n", "", "epoch_logs", "=", "{", "\"lr\"", ":", "self", ".", "_optimizer", ".", "param_groups", "[", "-", "1", "]", "[", "\"lr\"", "]", "}", "\n", "self", ".", "history", ".", "epoch_metrics", ".", "update", "(", "epoch_logs", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._train_batch": [[284, 319], ["X.to().float.to().float.to().float", "pretraining.TabNetPretrainer.network.parameters", "pretraining.TabNetPretrainer.network", "pretraining.TabNetPretrainer.compute_loss", "pretraining.TabNetPretrainer.backward", "pretraining.TabNetPretrainer._optimizer.step", "pretraining.TabNetPretrainer.cpu().detach().numpy().item", "torch.nn.utils.clip_grad_norm_", "X.to().float.to().float.to", "pretraining.TabNetPretrainer.network.parameters", "pretraining.TabNetPretrainer.cpu().detach().numpy", "pretraining.TabNetPretrainer.cpu().detach", "pretraining.TabNetPretrainer.cpu"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.compute_loss", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15.backward"], ["", "def", "_train_batch", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Trains one batch of data\n\n        Parameters\n        ----------\n        X : torch.Tensor\n            Train matrix\n\n        Returns\n        -------\n        batch_outs : dict\n            Dictionnary with \"y\": target and \"score\": prediction scores.\n        batch_logs : dict\n            Dictionnary with \"batch_size\" and \"loss\".\n        \"\"\"", "\n", "batch_logs", "=", "{", "\"batch_size\"", ":", "X", ".", "shape", "[", "0", "]", "}", "\n", "\n", "X", "=", "X", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "\n", "for", "param", "in", "self", ".", "network", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "grad", "=", "None", "\n", "\n", "", "output", ",", "embedded_x", ",", "obf_vars", "=", "self", ".", "network", "(", "X", ")", "\n", "loss", "=", "self", ".", "compute_loss", "(", "output", ",", "embedded_x", ",", "obf_vars", ")", "\n", "\n", "# Perform backward pass and optimization", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "self", ".", "clip_value", ":", "\n", "            ", "clip_grad_norm_", "(", "self", ".", "network", ".", "parameters", "(", ")", ",", "self", ".", "clip_value", ")", "\n", "", "self", ".", "_optimizer", ".", "step", "(", ")", "\n", "\n", "batch_logs", "[", "\"loss\"", "]", "=", "loss", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "\n", "\n", "return", "batch_logs", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._predict_epoch": [[320, 352], ["pretraining.TabNetPretrainer.network.eval", "enumerate", "pretraining.TabNetPretrainer.stack_batches", "pretraining.TabNetPretrainer.network.train", "pretraining.TabNetPretrainer.history.epoch_metrics.update", "pretraining.TabNetPretrainer._predict_batch", "list_output.append", "list_embedded_x.append", "list_obfuscation.append"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.stack_batches", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._predict_batch", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "_predict_epoch", "(", "self", ",", "name", ",", "loader", ")", ":", "\n", "        ", "\"\"\"\n        Predict an epoch and update metrics.\n\n        Parameters\n        ----------\n        name : str\n            Name of the validation set\n        loader : torch.utils.data.Dataloader\n                DataLoader with validation set\n        \"\"\"", "\n", "# Setting network on evaluation mode", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n", "list_output", "=", "[", "]", "\n", "list_embedded_x", "=", "[", "]", "\n", "list_obfuscation", "=", "[", "]", "\n", "# Main loop", "\n", "for", "batch_idx", ",", "X", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "output", ",", "embedded_x", ",", "obf_vars", "=", "self", ".", "_predict_batch", "(", "X", ")", "\n", "list_output", ".", "append", "(", "output", ")", "\n", "list_embedded_x", ".", "append", "(", "embedded_x", ")", "\n", "list_obfuscation", ".", "append", "(", "obf_vars", ")", "\n", "\n", "", "output", ",", "embedded_x", ",", "obf_vars", "=", "self", ".", "stack_batches", "(", "list_output", ",", "\n", "list_embedded_x", ",", "\n", "list_obfuscation", ")", "\n", "\n", "metrics_logs", "=", "self", ".", "_metric_container_dict", "[", "name", "]", "(", "output", ",", "embedded_x", ",", "obf_vars", ")", "\n", "self", ".", "network", ".", "train", "(", ")", "\n", "self", ".", "history", ".", "epoch_metrics", ".", "update", "(", "metrics_logs", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer._predict_batch": [[353, 369], ["X.to().float.to().float.to().float", "pretraining.TabNetPretrainer.network", "X.to().float.to().float.to"], "methods", ["None"], ["", "def", "_predict_batch", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Predict one batch of data.\n\n        Parameters\n        ----------\n        X : torch.Tensor\n            Owned products\n\n        Returns\n        -------\n        np.array\n            model scores\n        \"\"\"", "\n", "X", "=", "X", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "return", "self", ".", "network", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.stack_batches": [[370, 375], ["torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "stack_batches", "(", "self", ",", "list_output", ",", "list_embedded_x", ",", "list_obfuscation", ")", ":", "\n", "        ", "output", "=", "torch", ".", "cat", "(", "list_output", ",", "axis", "=", "0", ")", "\n", "embedded_x", "=", "torch", ".", "cat", "(", "list_embedded_x", ",", "axis", "=", "0", ")", "\n", "obf_vars", "=", "torch", ".", "cat", "(", "list_obfuscation", ",", "axis", "=", "0", ")", "\n", "return", "output", ",", "embedded_x", ",", "obf_vars", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining.TabNetPretrainer.predict": [[376, 408], ["pretraining.TabNetPretrainer.network.eval", "torch.utils.data.DataLoader", "enumerate", "numpy.vstack", "numpy.vstack", "utils.PredictDataset", "data.to().float.to().float.to().float", "pretraining.TabNetPretrainer.network", "output.cpu().detach().numpy", "results.append", "embedded_res.append", "embeded_x.cpu().detach().numpy", "data.to().float.to().float.to", "output.cpu().detach", "embeded_x.cpu().detach", "output.cpu", "embeded_x.cpu"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Make predictions on a batch (valid)\n\n        Parameters\n        ----------\n        X : a :tensor: `torch.Tensor`\n            Input data\n\n        Returns\n        -------\n        predictions : np.array\n            Predictions of the regression problem\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "results", "=", "[", "]", "\n", "embedded_res", "=", "[", "]", "\n", "for", "batch_nb", ",", "data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "output", ",", "embeded_x", ",", "_", "=", "self", ".", "network", "(", "data", ")", "\n", "predictions", "=", "output", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "results", ".", "append", "(", "predictions", ")", "\n", "embedded_res", ".", "append", "(", "embeded_x", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "res_output", "=", "np", ".", "vstack", "(", "results", ")", "\n", "embedded_inputs", "=", "np", ".", "vstack", "(", "embedded_res", ")", "\n", "return", "res_output", ",", "embedded_inputs", "\n", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.transforms_noaug_train": [[24, 49], ["torchvision.transforms.Compose", "torchvision.transforms.Resize", "torchvision.transforms.CenterCrop", "timm.data.transforms.ToNumpy", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "timm.data.transforms.str_to_interp_mode", "torch.tensor", "torch.tensor"], "function", ["None"], ["def", "transforms_noaug_train", "(", "\n", "img_size", "=", "224", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "use_prefetcher", "=", "False", ",", "\n", "mean", "=", "IMAGENET_DEFAULT_MEAN", ",", "\n", "std", "=", "IMAGENET_DEFAULT_STD", ",", "\n", ")", ":", "\n", "    ", "if", "interpolation", "==", "'random'", ":", "\n", "# random interpolation not supported with no-aug", "\n", "        ", "interpolation", "=", "'bilinear'", "\n", "", "tfl", "=", "[", "\n", "transforms", ".", "Resize", "(", "img_size", ",", "interpolation", "=", "str_to_interp_mode", "(", "interpolation", ")", ")", ",", "\n", "transforms", ".", "CenterCrop", "(", "img_size", ")", "\n", "]", "\n", "if", "use_prefetcher", ":", "\n", "# prefetcher and collate will handle tensor conversion and norm", "\n", "        ", "tfl", "+=", "[", "ToNumpy", "(", ")", "]", "\n", "", "else", ":", "\n", "        ", "tfl", "+=", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "\n", "mean", "=", "torch", ".", "tensor", "(", "mean", ")", ",", "\n", "std", "=", "torch", ".", "tensor", "(", "std", ")", ")", "\n", "]", "\n", "", "return", "transforms", ".", "Compose", "(", "tfl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.transforms_imagenet_train": [[51, 136], ["tuple", "tuple", "timm.data.transforms.RandomResizedCropAndInterpolation", "isinstance", "isinstance", "dict", "auto_augment.startswith", "torchvision.transforms.Compose", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.RandomVerticalFlip", "min", "timm.data.transforms.str_to_pil_interp", "auto_augment.startswith", "isinstance", "timm.data.transforms.ToNumpy", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "final_tfl.append", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "int", "tuple", "timm.data.auto_augment.rand_augment_transform", "torchvision.transforms.ColorJitter", "timm.data.random_erasing.RandomErasing", "timm.data.auto_augment.augment_and_mix_transform", "timm.data.auto_augment.auto_augment_transform", "len", "torch.tensor", "torch.tensor", "min", "float", "round"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "transforms_imagenet_train", "(", "\n", "img_size", "=", "224", ",", "\n", "scale", "=", "None", ",", "\n", "ratio", "=", "None", ",", "\n", "hflip", "=", "0.5", ",", "\n", "vflip", "=", "0.", ",", "\n", "color_jitter", "=", "0.4", ",", "\n", "auto_augment", "=", "None", ",", "\n", "interpolation", "=", "'random'", ",", "\n", "use_prefetcher", "=", "False", ",", "\n", "mean", "=", "IMAGENET_DEFAULT_MEAN", ",", "\n", "std", "=", "IMAGENET_DEFAULT_STD", ",", "\n", "re_prob", "=", "0.", ",", "\n", "re_mode", "=", "'const'", ",", "\n", "re_count", "=", "1", ",", "\n", "re_num_splits", "=", "0", ",", "\n", "separate", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    If separate==True, the transforms are returned as a tuple of 3 separate transforms\n    for use in a mixing dataset that passes\n     * all data through the first (primary) transform, called the 'clean' data\n     * a portion of the data through the secondary transform\n     * normalizes and converts the branches above with the third, final transform\n    \"\"\"", "\n", "\n", "scale", "=", "tuple", "(", "scale", "or", "(", "0.08", ",", "1.0", ")", ")", "# default imagenet scale range", "\n", "ratio", "=", "tuple", "(", "ratio", "or", "(", "3.", "/", "4.", ",", "4.", "/", "3.", ")", ")", "# default imagenet ratio range", "\n", "primary_tfl", "=", "[", "\n", "RandomResizedCropAndInterpolation", "(", "img_size", ",", "scale", "=", "scale", ",", "ratio", "=", "ratio", ",", "interpolation", "=", "interpolation", ")", "]", "\n", "if", "hflip", ">", "0.", ":", "\n", "        ", "primary_tfl", "+=", "[", "transforms", ".", "RandomHorizontalFlip", "(", "p", "=", "hflip", ")", "]", "\n", "", "if", "vflip", ">", "0.", ":", "\n", "        ", "primary_tfl", "+=", "[", "transforms", ".", "RandomVerticalFlip", "(", "p", "=", "vflip", ")", "]", "\n", "\n", "", "secondary_tfl", "=", "[", "]", "\n", "if", "auto_augment", ":", "\n", "        ", "assert", "isinstance", "(", "auto_augment", ",", "str", ")", "\n", "if", "isinstance", "(", "img_size", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "            ", "img_size_min", "=", "min", "(", "img_size", ")", "\n", "", "else", ":", "\n", "            ", "img_size_min", "=", "img_size", "\n", "", "aa_params", "=", "dict", "(", "\n", "translate_const", "=", "int", "(", "img_size_min", "*", "0.45", ")", ",", "\n", "img_mean", "=", "tuple", "(", "[", "min", "(", "255", ",", "round", "(", "255", "*", "x", ")", ")", "for", "x", "in", "mean", "]", ")", ",", "\n", ")", "\n", "if", "interpolation", "and", "interpolation", "!=", "'random'", ":", "\n", "            ", "aa_params", "[", "'interpolation'", "]", "=", "str_to_pil_interp", "(", "interpolation", ")", "\n", "", "if", "auto_augment", ".", "startswith", "(", "'rand'", ")", ":", "\n", "            ", "secondary_tfl", "+=", "[", "rand_augment_transform", "(", "auto_augment", ",", "aa_params", ")", "]", "\n", "", "elif", "auto_augment", ".", "startswith", "(", "'augmix'", ")", ":", "\n", "            ", "aa_params", "[", "'translate_pct'", "]", "=", "0.3", "\n", "secondary_tfl", "+=", "[", "augment_and_mix_transform", "(", "auto_augment", ",", "aa_params", ")", "]", "\n", "", "else", ":", "\n", "            ", "secondary_tfl", "+=", "[", "auto_augment_transform", "(", "auto_augment", ",", "aa_params", ")", "]", "\n", "", "", "elif", "color_jitter", "is", "not", "None", ":", "\n", "# color jitter is enabled when not using AA", "\n", "        ", "if", "isinstance", "(", "color_jitter", ",", "(", "list", ",", "tuple", ")", ")", ":", "\n", "# color jitter should be a 3-tuple/list if spec brightness/contrast/saturation", "\n", "# or 4 if also augmenting hue", "\n", "            ", "assert", "len", "(", "color_jitter", ")", "in", "(", "3", ",", "4", ")", "\n", "", "else", ":", "\n", "# if it's a scalar, duplicate for brightness, contrast, and saturation, no hue", "\n", "            ", "color_jitter", "=", "(", "float", "(", "color_jitter", ")", ",", ")", "*", "3", "\n", "", "secondary_tfl", "+=", "[", "transforms", ".", "ColorJitter", "(", "*", "color_jitter", ")", "]", "\n", "\n", "", "final_tfl", "=", "[", "]", "\n", "if", "use_prefetcher", ":", "\n", "# prefetcher and collate will handle tensor conversion and norm", "\n", "        ", "final_tfl", "+=", "[", "ToNumpy", "(", ")", "]", "\n", "", "else", ":", "\n", "        ", "final_tfl", "+=", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "\n", "mean", "=", "torch", ".", "tensor", "(", "mean", ")", ",", "\n", "std", "=", "torch", ".", "tensor", "(", "std", ")", ")", "\n", "]", "\n", "if", "re_prob", ">", "0.", ":", "\n", "            ", "final_tfl", ".", "append", "(", "\n", "RandomErasing", "(", "re_prob", ",", "mode", "=", "re_mode", ",", "max_count", "=", "re_count", ",", "num_splits", "=", "re_num_splits", ",", "device", "=", "'cpu'", ")", ")", "\n", "\n", "", "", "if", "separate", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "primary_tfl", ")", ",", "transforms", ".", "Compose", "(", "secondary_tfl", ")", ",", "transforms", ".", "Compose", "(", "final_tfl", ")", "\n", "", "else", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "primary_tfl", "+", "secondary_tfl", "+", "final_tfl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.transforms_imagenet_eval": [[138, 173], ["isinstance", "torchvision.transforms.Compose", "int", "torchvision.transforms.Resize", "torchvision.transforms.CenterCrop", "len", "int", "tuple", "math.floor", "timm.data.transforms.ToNumpy", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "math.floor", "timm.data.transforms.str_to_interp_mode", "int", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "", "def", "transforms_imagenet_eval", "(", "\n", "img_size", "=", "224", ",", "\n", "crop_pct", "=", "None", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "use_prefetcher", "=", "False", ",", "\n", "mean", "=", "IMAGENET_DEFAULT_MEAN", ",", "\n", "std", "=", "IMAGENET_DEFAULT_STD", ")", ":", "\n", "    ", "crop_pct", "=", "crop_pct", "or", "DEFAULT_CROP_PCT", "\n", "\n", "if", "isinstance", "(", "img_size", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "assert", "len", "(", "img_size", ")", "==", "2", "\n", "if", "img_size", "[", "-", "1", "]", "==", "img_size", "[", "-", "2", "]", ":", "\n", "# fall-back to older behaviour so Resize scales to shortest edge if target is square", "\n", "            ", "scale_size", "=", "int", "(", "math", ".", "floor", "(", "img_size", "[", "0", "]", "/", "crop_pct", ")", ")", "\n", "", "else", ":", "\n", "            ", "scale_size", "=", "tuple", "(", "[", "int", "(", "x", "/", "crop_pct", ")", "for", "x", "in", "img_size", "]", ")", "\n", "", "", "else", ":", "\n", "        ", "scale_size", "=", "int", "(", "math", ".", "floor", "(", "img_size", "/", "crop_pct", ")", ")", "\n", "\n", "", "tfl", "=", "[", "\n", "transforms", ".", "Resize", "(", "[", "scale_size", ",", "scale_size", "]", ",", "interpolation", "=", "str_to_interp_mode", "(", "interpolation", ")", ")", ",", "\n", "transforms", ".", "CenterCrop", "(", "img_size", ")", ",", "\n", "]", "\n", "if", "use_prefetcher", ":", "\n", "# prefetcher and collate will handle tensor conversion and norm", "\n", "        ", "tfl", "+=", "[", "ToNumpy", "(", ")", "]", "\n", "", "else", ":", "\n", "        ", "tfl", "+=", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "\n", "mean", "=", "torch", ".", "tensor", "(", "mean", ")", ",", "\n", "std", "=", "torch", ".", "tensor", "(", "std", ")", ")", "\n", "]", "\n", "\n", "", "return", "transforms", ".", "Compose", "(", "tfl", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.create_transform": [[175, 245], ["isinstance", "TfPreprocessTransform", "transforms_factory.transforms_noaug_train", "transforms_factory.transforms_imagenet_train", "transforms_factory.transforms_imagenet_eval"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.transforms_noaug_train", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.transforms_imagenet_train", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.transforms_imagenet_eval"], ["", "def", "create_transform", "(", "\n", "input_size", ",", "\n", "is_training", "=", "False", ",", "\n", "use_prefetcher", "=", "False", ",", "\n", "no_aug", "=", "False", ",", "\n", "scale", "=", "None", ",", "\n", "ratio", "=", "None", ",", "\n", "hflip", "=", "0.5", ",", "\n", "vflip", "=", "0.", ",", "\n", "color_jitter", "=", "0.4", ",", "\n", "auto_augment", "=", "None", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "mean", "=", "IMAGENET_DEFAULT_MEAN", ",", "\n", "std", "=", "IMAGENET_DEFAULT_STD", ",", "\n", "re_prob", "=", "0.", ",", "\n", "re_mode", "=", "'const'", ",", "\n", "re_count", "=", "1", ",", "\n", "re_num_splits", "=", "0", ",", "\n", "crop_pct", "=", "None", ",", "\n", "tf_preprocessing", "=", "False", ",", "\n", "separate", "=", "False", ")", ":", "\n", "\n", "    ", "if", "isinstance", "(", "input_size", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "img_size", "=", "input_size", "[", "-", "2", ":", "]", "\n", "", "else", ":", "\n", "        ", "img_size", "=", "input_size", "\n", "\n", "", "if", "tf_preprocessing", "and", "use_prefetcher", ":", "\n", "        ", "assert", "not", "separate", ",", "\"Separate transforms not supported for TF preprocessing\"", "\n", "from", "timm", ".", "data", ".", "tf_preprocessing", "import", "TfPreprocessTransform", "\n", "transform", "=", "TfPreprocessTransform", "(", "\n", "is_training", "=", "is_training", ",", "size", "=", "img_size", ",", "interpolation", "=", "interpolation", ")", "\n", "", "else", ":", "\n", "        ", "if", "is_training", "and", "no_aug", ":", "\n", "            ", "assert", "not", "separate", ",", "\"Cannot perform split augmentation with no_aug\"", "\n", "transform", "=", "transforms_noaug_train", "(", "\n", "img_size", ",", "\n", "interpolation", "=", "interpolation", ",", "\n", "use_prefetcher", "=", "use_prefetcher", ",", "\n", "mean", "=", "mean", ",", "\n", "std", "=", "std", ")", "\n", "", "elif", "is_training", ":", "\n", "            ", "transform", "=", "transforms_imagenet_train", "(", "\n", "img_size", ",", "\n", "scale", "=", "scale", ",", "\n", "ratio", "=", "ratio", ",", "\n", "hflip", "=", "hflip", ",", "\n", "vflip", "=", "vflip", ",", "\n", "color_jitter", "=", "color_jitter", ",", "\n", "auto_augment", "=", "auto_augment", ",", "\n", "interpolation", "=", "interpolation", ",", "\n", "use_prefetcher", "=", "use_prefetcher", ",", "\n", "mean", "=", "mean", ",", "\n", "std", "=", "std", ",", "\n", "re_prob", "=", "re_prob", ",", "\n", "re_mode", "=", "re_mode", ",", "\n", "re_count", "=", "re_count", ",", "\n", "re_num_splits", "=", "re_num_splits", ",", "\n", "separate", "=", "separate", ")", "\n", "", "else", ":", "\n", "            ", "assert", "not", "separate", ",", "\"Separate transforms not supported for validation preprocessing\"", "\n", "transform", "=", "transforms_imagenet_eval", "(", "\n", "img_size", ",", "\n", "interpolation", "=", "interpolation", ",", "\n", "use_prefetcher", "=", "use_prefetcher", ",", "\n", "mean", "=", "mean", ",", "\n", "std", "=", "std", ",", "\n", "crop_pct", "=", "crop_pct", ")", "\n", "\n", "", "", "return", "transform", "\n", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._assert_all_finite": [[22, 47], ["numpy.asanyarray", "numpy.isfinite", "numpy.sum", "ValueError", "numpy.isnan().any", "numpy.isinf().any", "msg_err.format", "numpy.dtype", "ValueError", "numpy.isfinite().all", "numpy.isnan", "numpy.isinf", "numpy.isfinite"], "function", ["None"], ["def", "_assert_all_finite", "(", "X", ",", "allow_nan", "=", "False", ")", ":", "\n", "    ", "\"\"\"Like assert_all_finite, but only for ndarray.\"\"\"", "\n", "\n", "X", "=", "np", ".", "asanyarray", "(", "X", ")", "\n", "# First try an O(n) time, O(1) space solution for the common case that", "\n", "# everything is finite; fall back to O(n) space np.isfinite to prevent", "\n", "# false positives from overflow in sum method. The sum is also calculated", "\n", "# safely to reduce dtype induced overflows.", "\n", "is_float", "=", "X", ".", "dtype", ".", "kind", "in", "\"fc\"", "\n", "if", "is_float", "and", "(", "np", ".", "isfinite", "(", "np", ".", "sum", "(", "X", ")", ")", ")", ":", "\n", "        ", "pass", "\n", "", "elif", "is_float", ":", "\n", "        ", "msg_err", "=", "\"Input contains {} or a value too large for {!r}.\"", "\n", "if", "(", "\n", "allow_nan", "\n", "and", "np", ".", "isinf", "(", "X", ")", ".", "any", "(", ")", "\n", "or", "not", "allow_nan", "\n", "and", "not", "np", ".", "isfinite", "(", "X", ")", ".", "all", "(", ")", "\n", ")", ":", "\n", "            ", "type_err", "=", "\"infinity\"", "if", "allow_nan", "else", "\"NaN, infinity\"", "\n", "raise", "ValueError", "(", "msg_err", ".", "format", "(", "type_err", ",", "X", ".", "dtype", ")", ")", "\n", "# for object dtype data, we only check for NaNs (GH-13254)", "\n", "", "", "elif", "X", ".", "dtype", "==", "np", ".", "dtype", "(", "\"object\"", ")", "and", "not", "allow_nan", ":", "\n", "        ", "if", "np", ".", "isnan", "(", "X", ")", ".", "any", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Input contains NaN\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.assert_all_finite": [[49, 58], ["multiclass_utils._assert_all_finite", "scipy.issparse"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._assert_all_finite"], ["", "", "", "def", "assert_all_finite", "(", "X", ",", "allow_nan", "=", "False", ")", ":", "\n", "    ", "\"\"\"Throw a ValueError if X contains NaN or infinity.\n\n    Parameters\n    ----------\n    X : array or sparse matrix\n    allow_nan : bool\n    \"\"\"", "\n", "_assert_all_finite", "(", "X", ".", "data", "if", "sp", ".", "issparse", "(", "X", ")", "else", "X", ",", "allow_nan", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._unique_multiclass": [[60, 65], ["hasattr", "numpy.unique", "set", "numpy.asarray"], "function", ["None"], ["", "def", "_unique_multiclass", "(", "y", ")", ":", "\n", "    ", "if", "hasattr", "(", "y", ",", "\"__array__\"", ")", ":", "\n", "        ", "return", "np", ".", "unique", "(", "np", ".", "asarray", "(", "y", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "set", "(", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._unique_indicator": [[67, 75], ["IndexError"], "function", ["None"], ["", "", "def", "_unique_indicator", "(", "y", ")", ":", "\n", "    ", "\"\"\"\n    Not implemented\n    \"\"\"", "\n", "raise", "IndexError", "(", "\n", "f\"\"\"Given labels are of size {y.shape} while they should be (n_samples,) \\n\"\"\"", "\n", "+", "\"\"\"If attempting multilabel classification, try using TabNetMultiTaskClassification \"\"\"", "\n", "+", "\"\"\"or TabNetRegressor\"\"\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.unique_labels": [[85, 141], ["set", "set.pop", "_FN_UNIQUE_LABELS.get", "set", "numpy.array", "ValueError", "len", "ValueError", "ValueError", "itertools.chain.from_iterable", "len", "ValueError", "sorted", "multiclass_utils.type_of_target", "set", "repr", "_FN_UNIQUE_LABELS.get.", "isinstance"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.type_of_target"], ["def", "unique_labels", "(", "*", "ys", ")", ":", "\n", "    ", "\"\"\"Extract an ordered array of unique labels\n\n    We don't allow:\n        - mix of multilabel and multiclass (single label) targets\n        - mix of label indicator matrix and anything else,\n          because there are no explicit labels)\n        - mix of label indicator matrices of different sizes\n        - mix of string and integer labels\n\n    At the moment, we also don't allow \"multiclass-multioutput\" input type.\n\n    Parameters\n    ----------\n    *ys : array-likes\n\n    Returns\n    -------\n    out : numpy array of shape [n_unique_labels]\n        An ordered array of unique labels.\n\n    Examples\n    --------\n    >>> from sklearn.utils.multiclass import unique_labels\n    >>> unique_labels([3, 5, 5, 5, 7, 7])\n    array([3, 5, 7])\n    >>> unique_labels([1, 2, 3, 4], [2, 2, 3, 4])\n    array([1, 2, 3, 4])\n    >>> unique_labels([1, 2, 10], [5, 11])\n    array([ 1,  2,  5, 10, 11])\n    \"\"\"", "\n", "if", "not", "ys", ":", "\n", "        ", "raise", "ValueError", "(", "\"No argument has been passed.\"", ")", "\n", "# Check that we don't mix label format", "\n", "\n", "", "ys_types", "=", "set", "(", "type_of_target", "(", "x", ")", "for", "x", "in", "ys", ")", "\n", "if", "ys_types", "==", "{", "\"binary\"", ",", "\"multiclass\"", "}", ":", "\n", "        ", "ys_types", "=", "{", "\"multiclass\"", "}", "\n", "\n", "", "if", "len", "(", "ys_types", ")", ">", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Mix type of y not allowed, got types %s\"", "%", "ys_types", ")", "\n", "\n", "", "label_type", "=", "ys_types", ".", "pop", "(", ")", "\n", "\n", "# Get the unique set of labels", "\n", "_unique_labels", "=", "_FN_UNIQUE_LABELS", ".", "get", "(", "label_type", ",", "None", ")", "\n", "if", "not", "_unique_labels", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown label type: %s\"", "%", "repr", "(", "ys", ")", ")", "\n", "\n", "", "ys_labels", "=", "set", "(", "chain", ".", "from_iterable", "(", "_unique_labels", "(", "y", ")", "for", "y", "in", "ys", ")", ")", "\n", "\n", "# Check that we don't mix string type with number type", "\n", "if", "len", "(", "set", "(", "isinstance", "(", "label", ",", "str", ")", "for", "label", "in", "ys_labels", ")", ")", ">", "1", ":", "\n", "        ", "raise", "ValueError", "(", "\"Mix of label input types (string and number)\"", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "sorted", "(", "ys_labels", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._is_integral_float": [[143, 145], ["numpy.all", "y.astype"], "function", ["None"], ["", "def", "_is_integral_float", "(", "y", ")", ":", "\n", "    ", "return", "y", ".", "dtype", ".", "kind", "==", "\"f\"", "and", "np", ".", "all", "(", "y", ".", "astype", "(", "int", ")", "==", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.is_multilabel": [[147, 196], ["hasattr", "scipy.sparse.issparse", "numpy.asarray", "isinstance", "numpy.unique", "hasattr", "y.tocsr.tocsr", "len", "len", "multiclass_utils._is_integral_float", "multiclass_utils._is_integral_float", "numpy.unique", "numpy.unique"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._is_integral_float", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._is_integral_float"], ["", "def", "is_multilabel", "(", "y", ")", ":", "\n", "    ", "\"\"\"Check if ``y`` is in a multilabel format.\n\n    Parameters\n    ----------\n    y : numpy array of shape [n_samples]\n        Target values.\n\n    Returns\n    -------\n    out : bool\n        Return ``True``, if ``y`` is in a multilabel format, else ```False``.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from sklearn.utils.multiclass import is_multilabel\n    >>> is_multilabel([0, 1, 0, 1])\n    False\n    >>> is_multilabel([[1], [0, 2], []])\n    False\n    >>> is_multilabel(np.array([[1, 0], [0, 0]]))\n    True\n    >>> is_multilabel(np.array([[1], [0], [0]]))\n    False\n    >>> is_multilabel(np.array([[1, 0, 0]]))\n    True\n    \"\"\"", "\n", "if", "hasattr", "(", "y", ",", "\"__array__\"", ")", ":", "\n", "        ", "y", "=", "np", ".", "asarray", "(", "y", ")", "\n", "", "if", "not", "(", "hasattr", "(", "y", ",", "\"shape\"", ")", "and", "y", ".", "ndim", "==", "2", "and", "y", ".", "shape", "[", "1", "]", ">", "1", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "if", "issparse", "(", "y", ")", ":", "\n", "        ", "if", "isinstance", "(", "y", ",", "(", "dok_matrix", ",", "lil_matrix", ")", ")", ":", "\n", "            ", "y", "=", "y", ".", "tocsr", "(", ")", "\n", "", "return", "(", "\n", "len", "(", "y", ".", "data", ")", "==", "0", "\n", "or", "np", ".", "unique", "(", "y", ".", "data", ")", ".", "size", "==", "1", "\n", "and", "(", "\n", "y", ".", "dtype", ".", "kind", "in", "\"biu\"", "\n", "or", "_is_integral_float", "(", "np", ".", "unique", "(", "y", ".", "data", ")", ")", "# bool, int, uint", "\n", ")", "\n", ")", "\n", "", "else", ":", "\n", "        ", "labels", "=", "np", ".", "unique", "(", "y", ")", "\n", "\n", "return", "len", "(", "labels", ")", "<", "3", "and", "(", "\n", "y", ".", "dtype", ".", "kind", "in", "\"biu\"", "or", "_is_integral_float", "(", "labels", ")", "# bool, int, uint", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_classification_targets": [[199, 219], ["multiclass_utils.type_of_target", "ValueError"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.type_of_target"], ["", "", "def", "check_classification_targets", "(", "y", ")", ":", "\n", "    ", "\"\"\"Ensure that target y is of a non-regression type.\n\n    Only the following target types (as defined in type_of_target) are allowed:\n        'binary', 'multiclass', 'multiclass-multioutput',\n        'multilabel-indicator', 'multilabel-sequences'\n\n    Parameters\n    ----------\n    y : array-like\n    \"\"\"", "\n", "y_type", "=", "type_of_target", "(", "y", ")", "\n", "if", "y_type", "not", "in", "[", "\n", "\"binary\"", ",", "\n", "\"multiclass\"", ",", "\n", "\"multiclass-multioutput\"", ",", "\n", "\"multilabel-indicator\"", ",", "\n", "\"multilabel-sequences\"", ",", "\n", "]", ":", "\n", "        ", "raise", "ValueError", "(", "\"Unknown label type: %r\"", "%", "y_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.type_of_target": [[221, 346], ["multiclass_utils.is_multilabel", "ValueError", "ValueError", "numpy.asarray", "numpy.any", "multiclass_utils._assert_all_finite", "isinstance", "hasattr", "isinstance", "isinstance", "ValueError", "len", "len", "hasattr", "isinstance", "isinstance", "np.asarray.astype", "numpy.unique", "len"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.is_multilabel", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils._assert_all_finite"], ["", "", "def", "type_of_target", "(", "y", ")", ":", "\n", "    ", "\"\"\"Determine the type of data indicated by the target.\n\n    Note that this type is the most specific type that can be inferred.\n    For example:\n\n        * ``binary`` is more specific but compatible with ``multiclass``.\n        * ``multiclass`` of integers is more specific but compatible with\n          ``continuous``.\n        * ``multilabel-indicator`` is more specific but compatible with\n          ``multiclass-multioutput``.\n\n    Parameters\n    ----------\n    y : array-like\n\n    Returns\n    -------\n    target_type : string\n        One of:\n\n        * 'continuous': `y` is an array-like of floats that are not all\n          integers, and is 1d or a column vector.\n        * 'continuous-multioutput': `y` is a 2d array of floats that are\n          not all integers, and both dimensions are of size > 1.\n        * 'binary': `y` contains <= 2 discrete values and is 1d or a column\n          vector.\n        * 'multiclass': `y` contains more than two discrete values, is not a\n          sequence of sequences, and is 1d or a column vector.\n        * 'multiclass-multioutput': `y` is a 2d array that contains more\n          than two discrete values, is not a sequence of sequences, and both\n          dimensions are of size > 1.\n        * 'multilabel-indicator': `y` is a label indicator matrix, an array\n          of two dimensions with at least two columns, and at most 2 unique\n          values.\n        * 'unknown': `y` is array-like but none of the above, such as a 3d\n          array, sequence of sequences, or an array of non-sequence objects.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> type_of_target([0.1, 0.6])\n    'continuous'\n    >>> type_of_target([1, -1, -1, 1])\n    'binary'\n    >>> type_of_target(['a', 'b', 'a'])\n    'binary'\n    >>> type_of_target([1.0, 2.0])\n    'binary'\n    >>> type_of_target([1, 0, 2])\n    'multiclass'\n    >>> type_of_target([1.0, 0.0, 3.0])\n    'multiclass'\n    >>> type_of_target(['a', 'b', 'c'])\n    'multiclass'\n    >>> type_of_target(np.array([[1, 2], [3, 1]]))\n    'multiclass-multioutput'\n    >>> type_of_target([[1, 2]])\n    'multiclass-multioutput'\n    >>> type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]]))\n    'continuous-multioutput'\n    >>> type_of_target(np.array([[0, 1], [1, 1]]))\n    'multilabel-indicator'\n    \"\"\"", "\n", "valid", "=", "(", "\n", "isinstance", "(", "y", ",", "(", "Sequence", ",", "spmatrix", ")", ")", "or", "hasattr", "(", "y", ",", "\"__array__\"", ")", "\n", ")", "and", "not", "isinstance", "(", "y", ",", "str", ")", "\n", "\n", "if", "not", "valid", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"Expected array-like (array or non-string sequence), \"", "\"got %r\"", "%", "y", "\n", ")", "\n", "\n", "", "sparseseries", "=", "y", ".", "__class__", ".", "__name__", "==", "\"SparseSeries\"", "\n", "if", "sparseseries", ":", "\n", "        ", "raise", "ValueError", "(", "\"y cannot be class 'SparseSeries'.\"", ")", "\n", "\n", "", "if", "is_multilabel", "(", "y", ")", ":", "\n", "        ", "return", "\"multilabel-indicator\"", "\n", "\n", "", "try", ":", "\n", "        ", "y", "=", "np", ".", "asarray", "(", "y", ")", "\n", "", "except", "ValueError", ":", "\n", "# Known to fail in numpy 1.3 for array of arrays", "\n", "        ", "return", "\"unknown\"", "\n", "\n", "# The old sequence of sequences format", "\n", "", "try", ":", "\n", "        ", "if", "(", "\n", "not", "hasattr", "(", "y", "[", "0", "]", ",", "\"__array__\"", ")", "\n", "and", "isinstance", "(", "y", "[", "0", "]", ",", "Sequence", ")", "\n", "and", "not", "isinstance", "(", "y", "[", "0", "]", ",", "str", ")", "\n", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"You appear to be using a legacy multi-label data\"", "\n", "\" representation. Sequence of sequences are no\"", "\n", "\" longer supported; use a binary array or sparse\"", "\n", "\" matrix instead - the MultiLabelBinarizer\"", "\n", "\" transformer can convert to this format.\"", "\n", ")", "\n", "", "", "except", "IndexError", ":", "\n", "        ", "pass", "\n", "\n", "# Invalid inputs", "\n", "", "if", "y", ".", "ndim", ">", "2", "or", "(", "y", ".", "dtype", "==", "object", "and", "len", "(", "y", ")", "and", "not", "isinstance", "(", "y", ".", "flat", "[", "0", "]", ",", "str", ")", ")", ":", "\n", "        ", "return", "\"unknown\"", "# [[[1, 2]]] or [obj_1] and not [\"label_1\"]", "\n", "\n", "", "if", "y", ".", "ndim", "==", "2", "and", "y", ".", "shape", "[", "1", "]", "==", "0", ":", "\n", "        ", "return", "\"unknown\"", "# [[]]", "\n", "\n", "", "if", "y", ".", "ndim", "==", "2", "and", "y", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "        ", "suffix", "=", "\"-multioutput\"", "# [[1, 2], [1, 2]]", "\n", "", "else", ":", "\n", "        ", "suffix", "=", "\"\"", "# [1, 2, 3] or [[1], [2], [3]]", "\n", "\n", "# check float and contains non-integer float values", "\n", "", "if", "y", ".", "dtype", ".", "kind", "==", "\"f\"", "and", "np", ".", "any", "(", "y", "!=", "y", ".", "astype", "(", "int", ")", ")", ":", "\n", "# [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]", "\n", "        ", "_assert_all_finite", "(", "y", ")", "\n", "return", "\"continuous\"", "+", "suffix", "\n", "\n", "", "if", "(", "len", "(", "np", ".", "unique", "(", "y", ")", ")", ">", "2", ")", "or", "(", "y", ".", "ndim", ">=", "2", "and", "len", "(", "y", "[", "0", "]", ")", ">", "1", ")", ":", "\n", "        ", "return", "\"multiclass\"", "+", "suffix", "# [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]", "\n", "", "else", ":", "\n", "        ", "return", "\"binary\"", "# [1, 2] or [[\"a\"], [\"b\"]]", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_unique_type": [[348, 353], ["pandas.Series().map().unique", "len", "TypeError", "pandas.Series().map", "pandas.Series"], "function", ["None"], ["", "", "def", "check_unique_type", "(", "y", ")", ":", "\n", "    ", "target_types", "=", "pd", ".", "Series", "(", "y", ")", ".", "map", "(", "type", ")", ".", "unique", "(", ")", "\n", "if", "len", "(", "target_types", ")", "!=", "1", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "f\"Values on the target must have the same type. Target has types {target_types}\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.infer_output_dim": [[356, 377], ["multiclass_utils.check_unique_type", "multiclass_utils.unique_labels", "len"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_unique_type", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.unique_labels"], ["", "", "def", "infer_output_dim", "(", "y_train", ")", ":", "\n", "    ", "\"\"\"\n    Infer output_dim from targets\n\n    Parameters\n    ----------\n    y_train : np.array\n        Training targets\n\n    Returns\n    -------\n    output_dim : int\n        Number of classes for output\n    train_labels : list\n        Sorted list of initial classes\n    \"\"\"", "\n", "check_unique_type", "(", "y_train", ")", "\n", "train_labels", "=", "unique_labels", "(", "y_train", ")", "\n", "output_dim", "=", "len", "(", "train_labels", ")", "\n", "\n", "return", "output_dim", ",", "train_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_output_dim": [[379, 390], ["multiclass_utils.check_unique_type", "multiclass_utils.unique_labels", "set().issubset", "ValueError", "set", "set", "set", "set"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_unique_type", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.unique_labels"], ["", "def", "check_output_dim", "(", "labels", ",", "y", ")", ":", "\n", "    ", "if", "y", "is", "not", "None", ":", "\n", "        ", "check_unique_type", "(", "y", ")", "\n", "valid_labels", "=", "unique_labels", "(", "y", ")", "\n", "if", "not", "set", "(", "valid_labels", ")", ".", "issubset", "(", "set", "(", "labels", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"\"\"Valid set -- {set(valid_labels)} --\n                             contains unkown targets from training --\n                             {set(labels)}\"\"\"", "\n", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.infer_multitask_output": [[392, 426], ["range", "len", "ValueError", "multiclass_utils.infer_output_dim", "tasks_dims.append", "tasks_labels.append", "ValueError"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.infer_output_dim", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "infer_multitask_output", "(", "y_train", ")", ":", "\n", "    ", "\"\"\"\n    Infer output_dim from targets\n    This is for multiple tasks.\n\n    Parameters\n    ----------\n    y_train : np.ndarray\n        Training targets\n\n    Returns\n    -------\n    tasks_dims : list\n        Number of classes for output\n    tasks_labels : list\n        List of sorted list of initial classes\n    \"\"\"", "\n", "\n", "if", "len", "(", "y_train", ".", "shape", ")", "<", "2", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "\"y_train should be of shape (n_examples, n_tasks)\"", "\n", "+", "f\"but got {y_train.shape}\"", "\n", ")", "\n", "", "nb_tasks", "=", "y_train", ".", "shape", "[", "1", "]", "\n", "tasks_dims", "=", "[", "]", "\n", "tasks_labels", "=", "[", "]", "\n", "for", "task_idx", "in", "range", "(", "nb_tasks", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "output_dim", ",", "train_labels", "=", "infer_output_dim", "(", "y_train", "[", ":", ",", "task_idx", "]", ")", "\n", "tasks_dims", ".", "append", "(", "output_dim", ")", "\n", "tasks_labels", ".", "append", "(", "train_labels", ")", "\n", "", "except", "ValueError", "as", "err", ":", "\n", "            ", "raise", "ValueError", "(", "f\"\"\"Error for task {task_idx} : {err}\"\"\"", ")", "\n", "", "", "return", "tasks_dims", ",", "tasks_labels", "\n", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.UnsupMetricContainer.__post_init__": [[72, 75], ["Metric.get_metrics_by_names"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.Metric.get_metrics_by_names"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "metrics", "=", "Metric", ".", "get_metrics_by_names", "(", "self", ".", "metric_names", ")", "\n", "self", ".", "names", "=", "[", "self", ".", "prefix", "+", "name", "for", "name", "in", "self", ".", "metric_names", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.UnsupMetricContainer.__call__": [[76, 97], ["metric"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_pred", ",", "embedded_x", ",", "obf_vars", ")", ":", "\n", "        ", "\"\"\"Compute all metrics and store into a dict.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_pred : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        dict\n            Dict of metrics ({metric_name: metric_value}).\n\n        \"\"\"", "\n", "logs", "=", "{", "}", "\n", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "            ", "res", "=", "metric", "(", "y_pred", ",", "embedded_x", ",", "obf_vars", ")", "\n", "logs", "[", "self", ".", "prefix", "+", "metric", ".", "_name", "]", "=", "res", "\n", "", "return", "logs", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.MetricContainer.__post_init__": [[115, 118], ["Metric.get_metrics_by_names"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.Metric.get_metrics_by_names"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "metrics", "=", "Metric", ".", "get_metrics_by_names", "(", "self", ".", "metric_names", ")", "\n", "self", ".", "names", "=", "[", "self", ".", "prefix", "+", "name", "for", "name", "in", "self", ".", "metric_names", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.MetricContainer.__call__": [[119, 145], ["isinstance", "numpy.mean", "metric", "metric", "range", "len"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "\"\"\"Compute all metrics and store into a dict.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_pred : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        dict\n            Dict of metrics ({metric_name: metric_value}).\n\n        \"\"\"", "\n", "logs", "=", "{", "}", "\n", "for", "metric", "in", "self", ".", "metrics", ":", "\n", "            ", "if", "isinstance", "(", "y_pred", ",", "list", ")", ":", "\n", "                ", "res", "=", "np", ".", "mean", "(", "\n", "[", "metric", "(", "y_true", "[", ":", ",", "i", "]", ",", "y_pred", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "y_pred", ")", ")", "]", "\n", ")", "\n", "", "else", ":", "\n", "                ", "res", "=", "metric", "(", "y_true", ",", "y_pred", ")", "\n", "", "logs", "[", "self", ".", "prefix", "+", "metric", ".", "_name", "]", "=", "res", "\n", "", "return", "logs", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.Metric.__call__": [[148, 150], ["NotImplementedError"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "y_true", ",", "y_pred", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Custom Metrics must implement this function\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.Metric.get_metrics_by_names": [[151, 179], ["cls.__subclasses__", "available_names.index", "metrics.append", "metric"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "@", "classmethod", "\n", "def", "get_metrics_by_names", "(", "cls", ",", "names", ")", ":", "\n", "        ", "\"\"\"Get list of metric classes.\n\n        Parameters\n        ----------\n        cls : Metric\n            Metric class.\n        names : list\n            List of metric names.\n\n        Returns\n        -------\n        metrics : list\n            List of metric classes.\n\n        \"\"\"", "\n", "available_metrics", "=", "cls", ".", "__subclasses__", "(", ")", "\n", "available_names", "=", "[", "metric", "(", ")", ".", "_name", "for", "metric", "in", "available_metrics", "]", "\n", "metrics", "=", "[", "]", "\n", "for", "name", "in", "names", ":", "\n", "            ", "assert", "(", "\n", "name", "in", "available_names", "\n", ")", ",", "f\"{name} is not available, choose in {available_names}\"", "\n", "idx", "=", "available_names", ".", "index", "(", "name", ")", "\n", "metric", "=", "available_metrics", "[", "idx", "]", "(", ")", "\n", "metrics", ".", "append", "(", "metric", ")", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.AUC.__init__": [[186, 189], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"auc\"", "\n", "self", ".", "_maximize", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.AUC.__call__": [[190, 207], ["sklearn.metrics.roc_auc_score"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute AUC of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            AUC of predictions vs targets.\n        \"\"\"", "\n", "return", "roc_auc_score", "(", "y_true", ",", "y_score", "[", ":", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.Accuracy.__init__": [[214, 217], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"accuracy\"", "\n", "self", ".", "_maximize", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.Accuracy.__call__": [[218, 236], ["numpy.argmax", "sklearn.metrics.accuracy_score"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute Accuracy of predictions.\n\n        Parameters\n        ----------\n        y_true: np.ndarray\n            Target matrix or vector\n        y_score: np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            Accuracy of predictions vs targets.\n        \"\"\"", "\n", "y_pred", "=", "np", ".", "argmax", "(", "y_score", ",", "axis", "=", "1", ")", "\n", "return", "accuracy_score", "(", "y_true", ",", "y_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.BalancedAccuracy.__init__": [[243, 246], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"balanced_accuracy\"", "\n", "self", ".", "_maximize", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.BalancedAccuracy.__call__": [[247, 265], ["numpy.argmax", "sklearn.metrics.balanced_accuracy_score"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute Accuracy of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            Accuracy of predictions vs targets.\n        \"\"\"", "\n", "y_pred", "=", "np", ".", "argmax", "(", "y_score", ",", "axis", "=", "1", ")", "\n", "return", "balanced_accuracy_score", "(", "y_true", ",", "y_pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.LogLoss.__init__": [[272, 275], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"logloss\"", "\n", "self", ".", "_maximize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.LogLoss.__call__": [[276, 293], ["sklearn.metrics.log_loss"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute LogLoss of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            LogLoss of predictions vs targets.\n        \"\"\"", "\n", "return", "log_loss", "(", "y_true", ",", "y_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.MAE.__init__": [[300, 303], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"mae\"", "\n", "self", ".", "_maximize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.MAE.__call__": [[304, 321], ["sklearn.metrics.mean_absolute_error"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute MAE (Mean Absolute Error) of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            MAE of predictions vs targets.\n        \"\"\"", "\n", "return", "mean_absolute_error", "(", "y_true", ",", "y_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.MSE.__init__": [[328, 331], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"mse\"", "\n", "self", ".", "_maximize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.MSE.__call__": [[332, 349], ["sklearn.metrics.mean_squared_error"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute MSE (Mean Squared Error) of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            MSE of predictions vs targets.\n        \"\"\"", "\n", "return", "mean_squared_error", "(", "y_true", ",", "y_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.RMSLE.__init__": [[360, 363], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"rmsle\"", "\n", "self", ".", "_maximize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.RMSLE.__call__": [[364, 382], ["numpy.clip", "sklearn.metrics.mean_squared_log_error"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute RMSLE of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            RMSLE of predictions vs targets.\n        \"\"\"", "\n", "y_score", "=", "np", ".", "clip", "(", "y_score", ",", "a_min", "=", "0", ",", "a_max", "=", "None", ")", "\n", "return", "mean_squared_log_error", "(", "y_true", ",", "y_score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.UnsupervisedMetric.__init__": [[389, 392], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"unsup_loss\"", "\n", "self", ".", "_maximize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.UnsupervisedMetric.__call__": [[393, 414], ["metrics.UnsupervisedLoss", "UnsupervisedLoss.item"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.UnsupervisedLoss"], ["", "def", "__call__", "(", "self", ",", "y_pred", ",", "embedded_x", ",", "obf_vars", ")", ":", "\n", "        ", "\"\"\"\n        Compute MSE (Mean Squared Error) of predictions.\n\n        Parameters\n        ----------\n        y_pred : torch.Tensor or np.array\n            Reconstructed prediction (with embeddings)\n        embedded_x : torch.Tensor\n            Original input embedded by network\n        obf_vars : torch.Tensor\n            Binary mask for obfuscated variables.\n            1 means the variables was obfuscated so reconstruction is based on this.\n\n        Returns\n        -------\n        float\n            MSE of predictions vs targets.\n        \"\"\"", "\n", "loss", "=", "UnsupervisedLoss", "(", "y_pred", ",", "embedded_x", ",", "obf_vars", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.RMSE.__init__": [[421, 424], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "_name", "=", "\"rmse\"", "\n", "self", ".", "_maximize", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.RMSE.__call__": [[425, 442], ["numpy.sqrt", "sklearn.metrics.mean_squared_error"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "y_true", ",", "y_score", ")", ":", "\n", "        ", "\"\"\"\n        Compute RMSE (Root Mean Squared Error) of predictions.\n\n        Parameters\n        ----------\n        y_true : np.ndarray\n            Target matrix or vector\n        y_score : np.ndarray\n            Score matrix or vector\n\n        Returns\n        -------\n        float\n            RMSE of predictions vs targets.\n        \"\"\"", "\n", "return", "np", ".", "sqrt", "(", "mean_squared_error", "(", "y_true", ",", "y_score", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.UnsupervisedLoss": [[16, 51], ["torch.matmul", "torch.sum", "torch.mean", "torch.mul", "torch.std"], "function", ["None"], ["def", "UnsupervisedLoss", "(", "y_pred", ",", "embedded_x", ",", "obf_vars", ",", "eps", "=", "1e-9", ")", ":", "\n", "    ", "\"\"\"\n    Implements unsupervised loss function.\n    This differs from orginal paper as it's scaled to be batch size independent\n    and number of features reconstructed independent (by taking the mean)\n\n    Parameters\n    ----------\n    y_pred : torch.Tensor or np.array\n        Reconstructed prediction (with embeddings)\n    embedded_x : torch.Tensor\n        Original input embedded by network\n    obf_vars : torch.Tensor\n        Binary mask for obfuscated variables.\n        1 means the variable was obfuscated so reconstruction is based on this.\n    eps : float\n        A small floating point to avoid ZeroDivisionError\n        This can happen in degenerated case when a feature has only one value\n\n    Returns\n    -------\n    loss : torch float\n        Unsupervised loss, average value over batch samples.\n    \"\"\"", "\n", "errors", "=", "y_pred", "-", "embedded_x", "\n", "reconstruction_errors", "=", "torch", ".", "mul", "(", "errors", ",", "obf_vars", ")", "**", "2", "\n", "batch_stds", "=", "torch", ".", "std", "(", "embedded_x", ",", "dim", "=", "0", ")", "**", "2", "+", "eps", "\n", "features_loss", "=", "torch", ".", "matmul", "(", "reconstruction_errors", ",", "1", "/", "batch_stds", ")", "\n", "# compute the number of obfuscated variables to reconstruct", "\n", "nb_reconstructed_variables", "=", "torch", ".", "sum", "(", "obf_vars", ",", "dim", "=", "1", ")", "\n", "# take the mean of the reconstructed variable errors", "\n", "features_loss", "=", "features_loss", "/", "(", "nb_reconstructed_variables", "+", "eps", ")", "\n", "# here we take the mean per batch, contrary to the paper", "\n", "loss", "=", "torch", ".", "mean", "(", "features_loss", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.check_metrics": [[444, 467], ["isinstance", "val_metrics.append", "issubclass", "val_metrics.append", "TypeError", "metric"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "", "def", "check_metrics", "(", "metrics", ")", ":", "\n", "    ", "\"\"\"Check if custom metrics are provided.\n\n    Parameters\n    ----------\n    metrics : list of str or classes\n        List with built-in metrics (str) or custom metrics (classes).\n\n    Returns\n    -------\n    val_metrics : list of str\n        List of metric names.\n\n    \"\"\"", "\n", "val_metrics", "=", "[", "]", "\n", "for", "metric", "in", "metrics", ":", "\n", "        ", "if", "isinstance", "(", "metric", ",", "str", ")", ":", "\n", "            ", "val_metrics", ".", "append", "(", "metric", ")", "\n", "", "elif", "issubclass", "(", "metric", ",", "Metric", ")", ":", "\n", "            ", "val_metrics", ".", "append", "(", "metric", "(", ")", ".", "_name", ")", "\n", "", "else", ":", "\n", "            ", "raise", "TypeError", "(", "\"You need to provide a valid metric format\"", ")", "\n", "", "", "return", "val_metrics", "\n", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.__post_init__": [[11, 16], ["super().__post_init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__post_init__"], ["    ", "def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TabNetMultiTaskClassifier", ",", "self", ")", ".", "__post_init__", "(", ")", "\n", "self", ".", "_task", "=", "'classification'", "\n", "self", ".", "_default_loss", "=", "torch", ".", "nn", ".", "functional", ".", "cross_entropy", "\n", "self", ".", "_default_metric", "=", "'logloss'", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.prepare_target": [[17, 23], ["y.copy", "range", "numpy.vectorize"], "methods", ["None"], ["", "def", "prepare_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "y_mapped", "=", "y", ".", "copy", "(", ")", "\n", "for", "task_idx", "in", "range", "(", "y", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "task_mapper", "=", "self", ".", "target_mapper", "[", "task_idx", "]", "\n", "y_mapped", "[", ":", ",", "task_idx", "]", "=", "np", ".", "vectorize", "(", "task_mapper", ".", "get", ")", "(", "y", "[", ":", ",", "task_idx", "]", ")", "\n", "", "return", "y_mapped", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.compute_loss": [[24, 56], ["y_true.long.long.long", "isinstance", "len", "zip", "enumerate", "range", "task_loss", "multitask.TabNetMultiTaskClassifier.loss_fn", "len"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "y_pred", ",", "y_true", ")", ":", "\n", "        ", "\"\"\"\n        Computes the loss according to network output and targets\n\n        Parameters\n        ----------\n        y_pred : list of tensors\n            Output of network\n        y_true : LongTensor\n            Targets label encoded\n\n        Returns\n        -------\n        loss : torch.Tensor\n            output of loss function(s)\n\n        \"\"\"", "\n", "loss", "=", "0", "\n", "y_true", "=", "y_true", ".", "long", "(", ")", "\n", "if", "isinstance", "(", "self", ".", "loss_fn", ",", "list", ")", ":", "\n", "# if you specify a different loss for each task", "\n", "            ", "for", "task_loss", ",", "task_output", ",", "task_id", "in", "zip", "(", "\n", "self", ".", "loss_fn", ",", "y_pred", ",", "range", "(", "len", "(", "self", ".", "loss_fn", ")", ")", "\n", ")", ":", "\n", "                ", "loss", "+=", "task_loss", "(", "task_output", ",", "y_true", "[", ":", ",", "task_id", "]", ")", "\n", "", "", "else", ":", "\n", "# same loss function is applied to all tasks", "\n", "            ", "for", "task_id", ",", "task_output", "in", "enumerate", "(", "y_pred", ")", ":", "\n", "                ", "loss", "+=", "self", ".", "loss_fn", "(", "task_output", ",", "y_true", "[", ":", ",", "task_id", "]", ")", "\n", "\n", "", "", "loss", "/=", "len", "(", "y_pred", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.stack_batches": [[57, 65], ["numpy.vstack", "range", "len", "numpy.vstack", "scipy.special.softmax", "y_score.append"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "stack_batches", "(", "self", ",", "list_y_true", ",", "list_y_score", ")", ":", "\n", "        ", "y_true", "=", "np", ".", "vstack", "(", "list_y_true", ")", "\n", "y_score", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "output_dim", ")", ")", ":", "\n", "            ", "score", "=", "np", ".", "vstack", "(", "[", "x", "[", "i", "]", "for", "x", "in", "list_y_score", "]", ")", "\n", "score", "=", "softmax", "(", "score", ",", "axis", "=", "1", ")", "\n", "y_score", ".", "append", "(", "score", ")", "\n", "", "return", "y_true", ",", "y_score", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.update_fit_params": [[66, 83], ["multiclass_utils.infer_multitask_output", "utils.filter_weights", "range", "multiclass_utils.check_output_dim", "str", "str", "enumerate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.infer_multitask_output", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.filter_weights", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_output_dim"], ["", "def", "update_fit_params", "(", "self", ",", "X_train", ",", "y_train", ",", "eval_set", ",", "weights", ")", ":", "\n", "        ", "output_dim", ",", "train_labels", "=", "infer_multitask_output", "(", "y_train", ")", "\n", "for", "_", ",", "y", "in", "eval_set", ":", "\n", "            ", "for", "task_idx", "in", "range", "(", "y", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "check_output_dim", "(", "train_labels", "[", "task_idx", "]", ",", "y", "[", ":", ",", "task_idx", "]", ")", "\n", "", "", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "classes_", "=", "train_labels", "\n", "self", ".", "target_mapper", "=", "[", "\n", "{", "class_label", ":", "index", "for", "index", ",", "class_label", "in", "enumerate", "(", "classes", ")", "}", "\n", "for", "classes", "in", "self", ".", "classes_", "\n", "]", "\n", "self", ".", "preds_mapper", "=", "[", "\n", "{", "str", "(", "index", ")", ":", "str", "(", "class_label", ")", "for", "index", ",", "class_label", "in", "enumerate", "(", "classes", ")", "}", "\n", "for", "classes", "in", "self", ".", "classes_", "\n", "]", "\n", "self", ".", "updated_weights", "=", "weights", "\n", "filter_weights", "(", "self", ".", "updated_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.predict": [[84, 128], ["multitask.TabNetMultiTaskClassifier.network.eval", "torch.utils.data.DataLoader", "utils.PredictDataset", "data.to().float.to().float.to().float", "multitask.TabNetMultiTaskClassifier.network", "range", "numpy.hstack", "torch.argmax().cpu().detach().numpy().reshape", "len", "results.values", "numpy.vectorize", "task_res.astype", "enumerate", "data.to().float.to().float.to", "results.get", "torch.argmax().cpu().detach().numpy", "torch.argmax().cpu().detach", "torch.argmax().cpu", "torch.argmax", "torch.nn.Softmax"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Make predictions on a batch (valid)\n\n        Parameters\n        ----------\n        X : a :tensor: `torch.Tensor`\n            Input data\n\n        Returns\n        -------\n        results : np.array\n            Predictions of the most probable class\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "results", "=", "{", "}", "\n", "for", "data", "in", "dataloader", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "output", ",", "_", "=", "self", ".", "network", "(", "data", ")", "\n", "predictions", "=", "[", "\n", "torch", ".", "argmax", "(", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "task_output", ")", ",", "dim", "=", "1", ")", "\n", ".", "cpu", "(", ")", "\n", ".", "detach", "(", ")", "\n", ".", "numpy", "(", ")", "\n", ".", "reshape", "(", "-", "1", ")", "\n", "for", "task_output", "in", "output", "\n", "]", "\n", "\n", "for", "task_idx", "in", "range", "(", "len", "(", "self", ".", "output_dim", ")", ")", ":", "\n", "                ", "results", "[", "task_idx", "]", "=", "results", ".", "get", "(", "task_idx", ",", "[", "]", ")", "+", "[", "predictions", "[", "task_idx", "]", "]", "\n", "# stack all task individually", "\n", "", "", "results", "=", "[", "np", ".", "hstack", "(", "task_res", ")", "for", "task_res", "in", "results", ".", "values", "(", ")", "]", "\n", "# map all task individually", "\n", "results", "=", "[", "\n", "np", ".", "vectorize", "(", "self", ".", "preds_mapper", "[", "task_idx", "]", ".", "get", ")", "(", "task_res", ".", "astype", "(", "str", ")", ")", "\n", "for", "task_idx", ",", "task_res", "in", "enumerate", "(", "results", ")", "\n", "]", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multitask.TabNetMultiTaskClassifier.predict_proba": [[129, 163], ["multitask.TabNetMultiTaskClassifier.network.eval", "torch.utils.data.DataLoader", "utils.PredictDataset", "data.to().float.to().float.to().float", "multitask.TabNetMultiTaskClassifier.network", "range", "numpy.vstack", "len", "results.values", "data.to().float.to().float.to", "results.get", "torch.nn.Softmax"], "methods", ["None"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Make predictions for classification on a batch (valid)\n\n        Parameters\n        ----------\n        X : a :tensor: `torch.Tensor`\n            Input data\n\n        Returns\n        -------\n        res : list of np.ndarray\n\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "results", "=", "{", "}", "\n", "for", "data", "in", "dataloader", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "output", ",", "_", "=", "self", ".", "network", "(", "data", ")", "\n", "predictions", "=", "[", "\n", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "task_output", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "for", "task_output", "in", "output", "\n", "]", "\n", "for", "task_idx", "in", "range", "(", "len", "(", "self", ".", "output_dim", ")", ")", ":", "\n", "                ", "results", "[", "task_idx", "]", "=", "results", ".", "get", "(", "task_idx", ",", "[", "]", ")", "+", "[", "predictions", "[", "task_idx", "]", "]", "\n", "", "", "res", "=", "[", "np", ".", "vstack", "(", "task_res", ")", "for", "task_res", "in", "results", ".", "values", "(", ")", "]", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.gaussian": [[5, 7], ["numpy.exp", "numpy.power", "numpy.power"], "function", ["None"], ["def", "gaussian", "(", "x", ",", "mu", ",", "sig", ")", ":", "\n", "    ", "return", "np", ".", "exp", "(", "-", "np", ".", "power", "(", "x", "-", "mu", ",", "2.", ")", "/", "(", "2", "*", "np", ".", "power", "(", "sig", ",", "2.", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.generate_V_matrix": [[17, 26], ["numpy.linspace", "range", "numpy.array", "torch.tensor().cuda", "gaussian.gaussian", "np.array.append", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.gaussian", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["def", "generate_V_matrix", "(", "in_dim", ",", "out_dim", ")", ":", "\n", "#out_put:(in_dim,out_dim)", "\n", "    ", "x_values", "=", "np", ".", "linspace", "(", "0", ",", "1", ",", "out_dim", ")", "\n", "out_martix", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "in_dim", ")", ":", "\n", "        ", "y_values", "=", "gaussian", "(", "x_values", ",", "i", "/", "in_dim", ",", "sig", "=", "0.01", ")", "\n", "out_martix", ".", "append", "(", "y_values", ")", "\n", "", "out_martix", "=", "np", ".", "array", "(", "out_martix", ")", "\n", "return", "torch", ".", "tensor", "(", "out_martix", ",", "requires_grad", "=", "False", ",", "dtype", "=", "torch", ".", "float32", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.gaussian.cal_self_att_V": [[27, 32], ["None"], "function", ["None"], ["", "def", "cal_self_att_V", "(", "gaussian_matrix", ",", "input", ")", ":", "\n", "#input:(batch,n,input_size=1)", "\n", "#output:(batch,n,out_dim)", "\n", "    ", "out", "=", "gaussian_matrix", "*", "input", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.__post_init__": [[10, 15], ["super().__post_init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__post_init__"], ["    ", "def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TabNetClassifier", ",", "self", ")", ".", "__post_init__", "(", ")", "\n", "self", ".", "_task", "=", "'classification'", "\n", "self", ".", "_default_loss", "=", "torch", ".", "nn", ".", "functional", ".", "cross_entropy", "\n", "self", ".", "_default_metric", "=", "'accuracy'", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.weight_updater": [[16, 37], ["isinstance", "isinstance", "weights.items"], "methods", ["None"], ["", "def", "weight_updater", "(", "self", ",", "weights", ")", ":", "\n", "        ", "\"\"\"\n        Updates weights dictionary according to target_mapper.\n\n        Parameters\n        ----------\n        weights : bool or dict\n            Given weights for balancing training.\n\n        Returns\n        -------\n        bool or dict\n            Same bool if weights are bool, updated dict otherwise.\n\n        \"\"\"", "\n", "if", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "            ", "return", "weights", "\n", "", "elif", "isinstance", "(", "weights", ",", "dict", ")", ":", "\n", "            ", "return", "{", "self", ".", "target_mapper", "[", "key", "]", ":", "value", "for", "key", ",", "value", "in", "weights", ".", "items", "(", ")", "}", "\n", "", "else", ":", "\n", "            ", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.prepare_target": [[38, 40], ["numpy.vectorize"], "methods", ["None"], ["", "", "def", "prepare_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "return", "np", ".", "vectorize", "(", "self", ".", "target_mapper", ".", "get", ")", "(", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.compute_loss": [[41, 43], ["tab_model.TabNetClassifier.loss_fn", "y_true.long"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "y_pred", ",", "y_true", ")", ":", "\n", "        ", "return", "self", ".", "loss_fn", "(", "y_pred", ",", "y_true", ".", "long", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.update_fit_params": [[44, 64], ["multiclass_utils.infer_output_dim", "tab_model.TabNetClassifier.weight_updater", "multiclass_utils.check_output_dim", "str", "enumerate", "enumerate"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.infer_output_dim", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.weight_updater", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.multiclass_utils.check_output_dim"], ["", "def", "update_fit_params", "(", "\n", "self", ",", "\n", "X_train", ",", "\n", "y_train", ",", "\n", "eval_set", ",", "\n", "weights", ",", "\n", ")", ":", "\n", "        ", "output_dim", ",", "train_labels", "=", "infer_output_dim", "(", "y_train", ")", "\n", "for", "X", ",", "y", "in", "eval_set", ":", "\n", "            ", "check_output_dim", "(", "train_labels", ",", "y", ")", "\n", "", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "_default_metric", "=", "(", "'auc'", "if", "self", ".", "output_dim", "==", "2", "else", "'accuracy'", ")", "\n", "self", ".", "classes_", "=", "train_labels", "\n", "self", ".", "target_mapper", "=", "{", "\n", "class_label", ":", "index", "for", "index", ",", "class_label", "in", "enumerate", "(", "self", ".", "classes_", ")", "\n", "}", "\n", "self", ".", "preds_mapper", "=", "{", "\n", "str", "(", "index", ")", ":", "class_label", "for", "index", ",", "class_label", "in", "enumerate", "(", "self", ".", "classes_", ")", "\n", "}", "\n", "self", ".", "updated_weights", "=", "self", ".", "weight_updater", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.stack_batches": [[65, 70], ["numpy.hstack", "numpy.vstack", "scipy.special.softmax"], "methods", ["None"], ["", "def", "stack_batches", "(", "self", ",", "list_y_true", ",", "list_y_score", ")", ":", "\n", "        ", "y_true", "=", "np", ".", "hstack", "(", "list_y_true", ")", "\n", "y_score", "=", "np", ".", "vstack", "(", "list_y_score", ")", "\n", "y_score", "=", "softmax", "(", "y_score", ",", "axis", "=", "1", ")", "\n", "return", "y_true", ",", "y_score", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.predict_func": [[71, 74], ["numpy.argmax", "numpy.vectorize", "numpy.argmax.astype"], "methods", ["None"], ["", "def", "predict_func", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "outputs", "=", "np", ".", "argmax", "(", "outputs", ",", "axis", "=", "1", ")", "\n", "return", "np", ".", "vectorize", "(", "self", ".", "preds_mapper", ".", "get", ")", "(", "outputs", ".", "astype", "(", "str", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetClassifier.predict_proba": [[75, 106], ["tab_model.TabNetClassifier.network.eval", "torch.utils.data.DataLoader", "enumerate", "numpy.vstack", "utils.PredictDataset", "data.to().float.to().float.to().float", "tab_model.TabNetClassifier.network", "results.append", "data.to().float.to().float.to", "torch.nn.Softmax"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Make predictions for classification on a batch (valid)\n\n        Parameters\n        ----------\n        X : a :tensor: `torch.Tensor`\n            Input data\n\n        Returns\n        -------\n        res : np.ndarray\n\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "results", "=", "[", "]", "\n", "for", "batch_nb", ",", "data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "\n", "output", ",", "M_loss", "=", "self", ".", "network", "(", "data", ")", "\n", "predictions", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "(", "output", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "results", ".", "append", "(", "predictions", ")", "\n", "", "res", "=", "np", ".", "vstack", "(", "results", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetRegressor.__post_init__": [[109, 114], ["super().__post_init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__post_init__"], ["    ", "def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TabNetRegressor", ",", "self", ")", ".", "__post_init__", "(", ")", "\n", "self", ".", "_task", "=", "'regression'", "\n", "self", ".", "_default_loss", "=", "torch", ".", "nn", ".", "functional", ".", "mse_loss", "\n", "self", ".", "_default_metric", "=", "'mse'", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetRegressor.prepare_target": [[115, 117], ["None"], "methods", ["None"], ["", "def", "prepare_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetRegressor.compute_loss": [[118, 120], ["tab_model.TabNetRegressor.loss_fn"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "y_pred", ",", "y_true", ")", ":", "\n", "        ", "return", "self", ".", "loss_fn", "(", "y_pred", ",", "y_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetRegressor.update_fit_params": [[121, 138], ["utils.filter_weights", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.filter_weights"], ["", "def", "update_fit_params", "(", "\n", "self", ",", "\n", "X_train", ",", "\n", "y_train", ",", "\n", "eval_set", ",", "\n", "weights", "\n", ")", ":", "\n", "        ", "if", "len", "(", "y_train", ".", "shape", ")", "!=", "2", ":", "\n", "            ", "msg", "=", "\"Targets should be 2D : (n_samples, n_regression) \"", "+", "f\"but y_train.shape={y_train.shape} given.\\n\"", "+", "\"Use reshape(-1, 1) for single regression.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "self", ".", "output_dim", "=", "y_train", ".", "shape", "[", "1", "]", "\n", "self", ".", "preds_mapper", "=", "None", "\n", "\n", "self", ".", "updated_weights", "=", "weights", "\n", "filter_weights", "(", "self", ".", "updated_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetRegressor.predict_func": [[139, 141], ["None"], "methods", ["None"], ["", "def", "predict_func", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.TabNetRegressor.stack_batches": [[142, 146], ["numpy.vstack", "numpy.vstack"], "methods", ["None"], ["", "def", "stack_batches", "(", "self", ",", "list_y_true", ",", "list_y_score", ")", ":", "\n", "        ", "y_true", "=", "np", ".", "vstack", "(", "list_y_true", ")", "\n", "y_score", "=", "np", ".", "vstack", "(", "list_y_score", ")", "\n", "return", "y_true", ",", "y_score", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.__post_init__": [[149, 154], ["super().__post_init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__post_init__"], ["    ", "def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "CLCNet", ",", "self", ")", ".", "__post_init__", "(", ")", "\n", "self", ".", "_task", "=", "'regression'", "\n", "self", ".", "_default_loss", "=", "torch", ".", "nn", ".", "functional", ".", "mse_loss", "\n", "self", ".", "_default_metric", "=", "'mse'", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.prepare_target": [[155, 157], ["None"], "methods", ["None"], ["", "def", "prepare_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.compute_loss": [[158, 160], ["tab_model.CLCNet.loss_fn"], "methods", ["None"], ["", "def", "compute_loss", "(", "self", ",", "y_pred", ",", "y_true", ")", ":", "\n", "        ", "return", "self", ".", "loss_fn", "(", "y_pred", ",", "y_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.update_fit_params": [[161, 178], ["utils.filter_weights", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.filter_weights"], ["", "def", "update_fit_params", "(", "\n", "self", ",", "\n", "X_train", ",", "\n", "y_train", ",", "\n", "eval_set", ",", "\n", "weights", "\n", ")", ":", "\n", "        ", "if", "len", "(", "y_train", ".", "shape", ")", "!=", "2", ":", "\n", "            ", "msg", "=", "\"Targets should be 2D : (n_samples, n_regression) \"", "+", "f\"but y_train.shape={y_train.shape} given.\\n\"", "+", "\"Use reshape(-1, 1) for single regression.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "self", ".", "output_dim", "=", "y_train", ".", "shape", "[", "1", "]", "\n", "self", ".", "preds_mapper", "=", "None", "\n", "\n", "self", ".", "updated_weights", "=", "weights", "\n", "filter_weights", "(", "self", ".", "updated_weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.predict_func": [[179, 181], ["None"], "methods", ["None"], ["", "def", "predict_func", "(", "self", ",", "outputs", ")", ":", "\n", "        ", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.stack_batches": [[182, 186], ["numpy.vstack", "numpy.vstack"], "methods", ["None"], ["", "def", "stack_batches", "(", "self", ",", "list_y_true", ",", "list_y_score", ")", ":", "\n", "        ", "y_true", "=", "np", ".", "vstack", "(", "list_y_true", ")", "\n", "y_score", "=", "np", ".", "vstack", "(", "list_y_score", ")", "\n", "return", "y_true", ",", "y_score", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.__init__": [[16, 30], ["torch.nn.Module.__init__", "int", "torch.nn.Linear().cuda", "torch.nn.Linear().cuda", "torch.nn.Linear().cuda", "ValueError", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["def", "__init__", "(", "self", ",", "num_attention_heads", ",", "input_size", ",", "hidden_size", ",", "qkdim", ")", ":", "\n", "        ", "super", "(", "Normal_SelfAttention", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "(", "(", "hidden_size", "%", "num_attention_heads", ")", "!=", "0", ")", "or", "(", "(", "qkdim", "%", "num_attention_heads", ")", "!=", "0", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "\"The hidden/qkdim size (%d) is not a multiple of the number of attention \"", "\n", "\"heads (%d)\"", "%", "(", "hidden_size", ",", "num_attention_heads", ")", ")", "\n", "", "self", ".", "num_attention_heads", "=", "num_attention_heads", "\n", "self", ".", "attention_head_size", "=", "int", "(", "hidden_size", "/", "num_attention_heads", ")", "\n", "self", ".", "all_head_size", "=", "hidden_size", "\n", "\n", "self", ".", "qkdim", "=", "qkdim", "\n", "self", ".", "query", "=", "nn", ".", "Linear", "(", "input_size", ",", "self", ".", "qkdim", ")", ".", "cuda", "(", ")", "\n", "self", ".", "key", "=", "nn", ".", "Linear", "(", "input_size", ",", "self", ".", "qkdim", ")", ".", "cuda", "(", ")", "\n", "self", ".", "value", "=", "nn", ".", "Linear", "(", "input_size", ",", "self", ".", "all_head_size", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores": [[32, 36], ["x.view.view.view", "x.view.view.permute", "x.view.view.size"], "methods", ["None"], ["", "def", "transpose_for_scores", "(", "self", ",", "x", ")", ":", "\n", "        ", "new_x_shape", "=", "x", ".", "size", "(", ")", "[", ":", "-", "1", "]", "+", "(", "self", ".", "num_attention_heads", ",", "self", ".", "attention_head_size", ")", "\n", "x", "=", "x", ".", "view", "(", "*", "new_x_shape", ")", "\n", "return", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores_for_qk": [[37, 41], ["x.view.view.view", "x.view.view.permute", "x.view.view.size", "int"], "methods", ["None"], ["", "def", "transpose_for_scores_for_qk", "(", "self", ",", "x", ")", ":", "\n", "        ", "new_x_shape", "=", "x", ".", "size", "(", ")", "[", ":", "-", "1", "]", "+", "(", "self", ".", "num_attention_heads", ",", "int", "(", "self", ".", "qkdim", "/", "self", ".", "num_attention_heads", ")", ")", "\n", "x", "=", "x", ".", "view", "(", "*", "new_x_shape", ")", "\n", "return", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.forward": [[42, 81], ["self_attention.Normal_SelfAttention.Normal_SelfAttention.query", "self_attention.Normal_SelfAttention.Normal_SelfAttention.key", "self_attention.Normal_SelfAttention.Normal_SelfAttention.value", "self_attention.Normal_SelfAttention.Normal_SelfAttention.transpose_for_scores_for_qk", "self_attention.Normal_SelfAttention.Normal_SelfAttention.transpose_for_scores_for_qk", "self_attention.Normal_SelfAttention.Normal_SelfAttention.transpose_for_scores", "torch.matmul", "attention_probs[].view", "torch.matmul", "context_layer.view.view.permute().contiguous", "context_layer.view.view.view", "self_attention.Normal_SelfAttention.Normal_SelfAttention.transpose", "math.sqrt", "torch.nn.Softmax", "context_layer.view.view.permute", "context_layer.view.view.size"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores_for_qk", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores_for_qk", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.self_attention.Normal_SelfAttention.transpose_for_scores"], ["", "def", "forward", "(", "self", ",", "input_tensor", ")", ":", "\n", "        ", "mixed_query_layer", "=", "self", ".", "query", "(", "input_tensor", ")", "\n", "mixed_key_layer", "=", "self", ".", "key", "(", "input_tensor", ")", "\n", "mixed_value_layer", "=", "self", ".", "value", "(", "input_tensor", ")", "\n", "\n", "query_layer", "=", "self", ".", "transpose_for_scores_for_qk", "(", "mixed_query_layer", ")", "\n", "key_layer", "=", "self", ".", "transpose_for_scores_for_qk", "(", "mixed_key_layer", ")", "\n", "value_layer", "=", "self", ".", "transpose_for_scores", "(", "mixed_value_layer", ")", "\n", "\n", "# Take the dot product between \"query\" and \"key\" to get the raw attention scores.", "\n", "attention_scores", "=", "torch", ".", "matmul", "(", "query_layer", ",", "key_layer", ".", "transpose", "(", "-", "1", ",", "-", "2", ")", ")", "\n", "attention_scores", "=", "attention_scores", "/", "math", ".", "sqrt", "(", "self", ".", "attention_head_size", ")", "\n", "# Apply the attention mask is (precomputed for all layers in BertModel forward() function)", "\n", "# [batch_size heads seq_len seq_len] scores", "\n", "# [batch_size 1 1 seq_len]", "\n", "\n", "# attention_scores = attention_scores + attention_mask", "\n", "\n", "# Normalize the attention scores to probabilities.", "\n", "attention_probs", "=", "nn", ".", "Softmax", "(", "dim", "=", "-", "1", ")", "(", "attention_scores", ")", "\n", "\n", "# Only keep the attention value of n=0 and subsequent calculations to save gpu memory", "\n", "attention_probs", "=", "attention_probs", "[", ":", ",", ":", ",", "0", ",", ":", "]", ".", "view", "(", "attention_probs", ".", "shape", "[", "0", "]", ",", "attention_probs", ".", "shape", "[", "1", "]", ",", "-", "1", ",", "attention_probs", ".", "shape", "[", "3", "]", ")", "\n", "\n", "# This is actually dropping out entire tokens to attend to, which might", "\n", "# seem a bit unusual, but is taken from the original Transformer paper.", "\n", "# Fixme", "\n", "#attention_probs = self.attn_dropout(attention_probs)", "\n", "context_layer", "=", "torch", ".", "matmul", "(", "attention_probs", ",", "value_layer", ")", "\n", "\n", "context_layer", "=", "context_layer", ".", "permute", "(", "0", ",", "2", ",", "1", ",", "3", ")", ".", "contiguous", "(", ")", "\n", "new_context_layer_shape", "=", "context_layer", ".", "size", "(", ")", "[", ":", "-", "2", "]", "+", "(", "self", ".", "all_head_size", ",", ")", "\n", "context_layer", "=", "context_layer", ".", "view", "(", "*", "new_context_layer_shape", ")", "\n", "#hidden_states = self.dense(context_layer)", "\n", "#hidden_states = self.out_dropout(hidden_states)", "\n", "#hidden_states = self.LayerNorm(hidden_states + input_tensor)", "\n", "\n", "#return hidden_states", "\n", "return", "context_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.cascade_structure_system.CLCNet_cascade_system": [[5, 43], ["model_s", "torch.softmax", "torch.sort", "torch.sort", "clcnet.predict", "torch.tensor().cuda", "torch.tensor().cuda", "len", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.tensor().cuda.numel", "model_d", "torch.softmax", "torch.sort", "torch.sort", "torch.from_numpy().cuda", "torch.from_numpy().cuda", "torch.tensor", "torch.tensor", "len", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "numpy.nonzero", "clcnet.predict"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.predict", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.predict"], ["def", "CLCNet_cascade_system", "(", "model_s", ",", "model_d", ",", "clcnet", ",", "input_s", ",", "input_d", ",", "threshold", ",", "call_deep", ")", ":", "\n", "\n", "    ", "result_s", "=", "model_s", "(", "input_s", ")", "\n", "result_s", "=", "F", ".", "softmax", "(", "result_s", ",", "dim", "=", "1", ")", "\n", "\n", "#Sort from largest to smallest", "\n", "sorted", ",", "indices", "=", "torch", ".", "sort", "(", "result_s", ",", "descending", "=", "True", ")", "\n", "\n", "result_c", "=", "clcnet", ".", "predict", "(", "sorted", ")", "\n", "\n", "# Find the index of the sample with confidence less than threshold", "\n", "fliter_indices", "=", "torch", ".", "tensor", "(", "np", ".", "nonzero", "(", "(", "result_c", "<", "threshold", ")", "[", ":", ",", "0", "]", ")", "[", "0", "]", ")", ".", "cuda", "(", ")", "\n", "\n", "if", "len", "(", "fliter_indices", ")", "!=", "0", ":", "\n", "\n", "        ", "result_c", "=", "torch", ".", "from_numpy", "(", "result_c", ")", ".", "cuda", "(", ")", "\n", "\n", "# Record how many times the deep model was called", "\n", "call_deep", "[", "0", "]", "+=", "fliter_indices", ".", "numel", "(", ")", "\n", "\n", "# Make further predict on the deep model", "\n", "result_d", "=", "model_d", "(", "input_d", "[", "fliter_indices", "]", ")", "\n", "result_d", "=", "F", ".", "softmax", "(", "result_d", ",", "dim", "=", "1", ")", "\n", "\n", "# Give the result of the deep model to CLCNet again", "\n", "sorted_d", ",", "indices", "=", "torch", ".", "sort", "(", "result_d", ",", "descending", "=", "True", ")", "\n", "result_c_d", "=", "torch", ".", "from_numpy", "(", "clcnet", ".", "predict", "(", "sorted_d", ")", ")", ".", "cuda", "(", ")", "\n", "\n", "result_d", "=", "result_d", "[", "(", "result_c_d", ">", "result_c", "[", "fliter_indices", "]", ")", ".", "view", "(", "-", "1", ")", "]", "\n", "\n", "# Only assign the results of the deep model with high confidence to the final output", "\n", "fliter_indices", "=", "fliter_indices", "[", "(", "result_c", "[", "fliter_indices", "]", "<", "result_c_d", ")", ".", "view", "(", "-", "1", ")", "]", "\n", "\n", "if", "len", "(", "fliter_indices", ")", "!=", "0", ":", "\n", "\n", "            ", "result_s", "[", "fliter_indices", "]", "=", "result_d", "\n", "\n", "", "", "return", "result_s", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining_utils.create_dataloaders": [[9, 71], ["utils.create_sampler", "torch.utils.data.DataLoader", "utils.PredictDataset", "valid_dataloaders.append", "torch.utils.data.DataLoader", "utils.PredictDataset"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_sampler", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["def", "create_dataloaders", "(", "\n", "X_train", ",", "eval_set", ",", "weights", ",", "batch_size", ",", "num_workers", ",", "drop_last", ",", "pin_memory", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Create dataloaders with or without subsampling depending on weights and balanced.\n\n    Parameters\n    ----------\n    X_train : np.ndarray\n        Training data\n    eval_set : list of np.array\n        List of eval sets\n    weights : either 0, 1, dict or iterable\n        if 0 (default) : no weights will be applied\n        if 1 : classification only, will balanced class with inverse frequency\n        if dict : keys are corresponding class values are sample weights\n        if iterable : list or np array must be of length equal to nb elements\n                      in the training set\n    batch_size : int\n        how many samples per batch to load\n    num_workers : int\n        how many subprocesses to use for data loading. 0 means that the data\n        will be loaded in the main process\n    drop_last : bool\n        set to True to drop the last incomplete batch, if the dataset size is not\n        divisible by the batch size. If False and the size of dataset is not\n        divisible by the batch size, then the last batch will be smaller\n    pin_memory : bool\n        Whether to pin GPU memory during training\n\n    Returns\n    -------\n    train_dataloader, valid_dataloader : torch.DataLoader, torch.DataLoader\n        Training and validation dataloaders\n    \"\"\"", "\n", "need_shuffle", ",", "sampler", "=", "create_sampler", "(", "weights", ",", "X_train", ")", "\n", "\n", "train_dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X_train", ")", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "shuffle", "=", "need_shuffle", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "drop_last", "=", "drop_last", ",", "\n", "pin_memory", "=", "pin_memory", ",", "\n", ")", "\n", "\n", "valid_dataloaders", "=", "[", "]", "\n", "for", "X", "in", "eval_set", ":", "\n", "        ", "valid_dataloaders", ".", "append", "(", "\n", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "shuffle", "=", "need_shuffle", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "drop_last", "=", "drop_last", ",", "\n", "pin_memory", "=", "pin_memory", ",", "\n", ")", "\n", ")", "\n", "\n", "", "return", "train_dataloader", ",", "valid_dataloaders", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.pretraining_utils.validate_eval_set": [[73, 103], ["enumerate", "len", "len", "sklearn.utils.check_array", "range", "len"], "function", ["None"], ["", "def", "validate_eval_set", "(", "eval_set", ",", "eval_name", ",", "X_train", ")", ":", "\n", "    ", "\"\"\"Check if the shapes of eval_set are compatible with X_train.\n\n    Parameters\n    ----------\n    eval_set : List of numpy array\n        The list evaluation set.\n        The last one is used for early stopping\n    X_train : np.ndarray\n        Train owned products\n\n    Returns\n    -------\n    eval_names : list of str\n        Validated list of eval_names.\n\n    \"\"\"", "\n", "eval_names", "=", "eval_name", "or", "[", "f\"val_{i}\"", "for", "i", "in", "range", "(", "len", "(", "eval_set", ")", ")", "]", "\n", "assert", "len", "(", "eval_set", ")", "==", "len", "(", "\n", "eval_names", "\n", ")", ",", "\"eval_set and eval_name have not the same length\"", "\n", "\n", "for", "set_nb", ",", "X", "in", "enumerate", "(", "eval_set", ")", ":", "\n", "        ", "check_array", "(", "X", ")", "\n", "msg", "=", "(", "\n", "f\"Number of columns is different between eval set {set_nb}\"", "\n", "+", "f\"({X.shape[1]}) and X_train ({X_train.shape[1]})\"", "\n", ")", "\n", "assert", "X", ".", "shape", "[", "1", "]", "==", "X_train", ".", "shape", "[", "1", "]", ",", "msg", "\n", "", "return", "eval_names", "\n", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.GBN.__init__": [[28, 34], ["super().__init__", "torch.nn.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "virtual_batch_size", "=", "128", ",", "momentum", "=", "0.01", ")", ":", "\n", "        ", "super", "(", "GBN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "bn", "=", "BatchNorm1d", "(", "self", ".", "input_dim", ",", "momentum", "=", "momentum", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.GBN.forward": [[35, 40], ["x.chunk", "torch.cat", "int", "tab_network.GBN.bn", "numpy.ceil"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "chunks", "=", "x", ".", "chunk", "(", "int", "(", "np", ".", "ceil", "(", "x", ".", "shape", "[", "0", "]", "/", "self", ".", "virtual_batch_size", ")", ")", ",", "0", ")", "\n", "res", "=", "[", "self", ".", "bn", "(", "x_", ")", "for", "x_", "in", "chunks", "]", "\n", "\n", "return", "torch", ".", "cat", "(", "res", ",", "dim", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetEncoder.__init__": [[43, 156], ["super().__init__", "isinstance", "torch.nn.BatchNorm1d", "tab_network.TabNetEncoder.Restricted_SelfAttention", "tab_network.TabNetEncoder.Normal_SelfAttention", "tab_network.FeatTransformer", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "torch.nn.ModuleList", "range", "tab_network.FeatTransformer", "tab_network.AttentiveTransformer", "tab_network.TabNetEncoder.feat_transformers.append", "tab_network.TabNetEncoder.att_transformers.append", "torch.nn.ModuleList.append", "torch.nn.ModuleList.append", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "n_d", "=", "8", ",", "\n", "n_a", "=", "8", ",", "\n", "n_steps", "=", "3", ",", "\n", "gamma", "=", "1.3", ",", "\n", "n_independent", "=", "2", ",", "\n", "n_shared", "=", "2", ",", "\n", "epsilon", "=", "1e-15", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", "mask_type", "=", "\"sparsemax\"", ",", "\n", "mapping_dim", "=", "100", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Defines main part of the TabNet network without the embedding layers.\n\n        Parameters\n        ----------\n        input_dim : int\n            Number of features\n        output_dim : int or list of int for multi task classification\n            Dimension of network output\n            examples : one for regression, 2 for binary classification etc...\n        n_d : int\n            Dimension of the prediction  layer (usually between 4 and 64)\n        n_a : int\n            Dimension of the attention  layer (usually between 4 and 64)\n        n_steps : int\n            Number of successive steps in the network (usually between 3 and 10)\n        gamma : float\n            Float above 1, scaling factor for attention updates (usually between 1.0 to 2.0)\n        n_independent : int\n            Number of independent GLU layer in each GLU block (default 2)\n        n_shared : int\n            Number of independent GLU layer in each GLU block (default 2)\n        epsilon : float\n            Avoid log(0), this should be kept very low\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization\n        momentum : float\n            Float value between 0 and 1 which will be used for momentum in all batch norm\n        mask_type : str\n            Either \"sparsemax\" or \"entmax\" : this is the masking function to use\n        \"\"\"", "\n", "super", "(", "TabNetEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Input dimensions of arbitrary length have been mapped to the equivalent mapping_dim(100)-dimensional distribution", "\n", "self", ".", "input_dim", "=", "mapping_dim", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "is_multi_task", "=", "isinstance", "(", "output_dim", ",", "list", ")", "\n", "self", ".", "n_d", "=", "n_d", "\n", "self", ".", "n_a", "=", "n_a", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "n_independent", "=", "n_independent", "\n", "self", ".", "n_shared", "=", "n_shared", "\n", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "mask_type", "=", "mask_type", "\n", "self", ".", "initial_bn", "=", "BatchNorm1d", "(", "input_dim", ",", "momentum", "=", "0.01", ")", "\n", "\n", "# Add a self-attention module for input of various scales, hidden_size represents the dimension of mapping, hyperparameter", "\n", "self", ".", "res_att", "=", "Restricted_SelfAttention", "(", "num_attention_heads", "=", "1", ",", "input_size", "=", "1", ",", "input_dim", "=", "input_dim", ",", "hidden_size", "=", "self", ".", "input_dim", ",", "qkdim", "=", "10", ")", "\n", "\n", "self", ".", "nor_att", "=", "Normal_SelfAttention", "(", "num_attention_heads", "=", "1", ",", "input_size", "=", "1", ",", "hidden_size", "=", "self", ".", "input_dim", ",", "qkdim", "=", "10", ")", "\n", "\n", "if", "self", ".", "n_shared", ">", "0", ":", "\n", "            ", "shared_feat_transform", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_shared", ")", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "shared_feat_transform", ".", "append", "(", "\n", "Linear", "(", "self", ".", "input_dim", ",", "2", "*", "(", "n_d", "+", "n_a", ")", ",", "bias", "=", "False", ")", "\n", ")", "\n", "", "else", ":", "\n", "                    ", "shared_feat_transform", ".", "append", "(", "\n", "Linear", "(", "n_d", "+", "n_a", ",", "2", "*", "(", "n_d", "+", "n_a", ")", ",", "bias", "=", "False", ")", "\n", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "shared_feat_transform", "=", "None", "\n", "\n", "", "self", ".", "initial_splitter", "=", "FeatTransformer", "(", "\n", "self", ".", "input_dim", ",", "\n", "n_d", "+", "n_a", ",", "\n", "shared_feat_transform", ",", "\n", "n_glu_independent", "=", "self", ".", "n_independent", ",", "\n", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", ")", "\n", "\n", "self", ".", "feat_transformers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "att_transformers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "step", "in", "range", "(", "n_steps", ")", ":", "\n", "            ", "transformer", "=", "FeatTransformer", "(", "\n", "self", ".", "input_dim", ",", "\n", "n_d", "+", "n_a", ",", "\n", "shared_feat_transform", ",", "\n", "n_glu_independent", "=", "self", ".", "n_independent", ",", "\n", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", ")", "\n", "attention", "=", "AttentiveTransformer", "(", "\n", "n_a", ",", "\n", "self", ".", "input_dim", ",", "\n", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", "mask_type", "=", "self", ".", "mask_type", ",", "\n", ")", "\n", "self", ".", "feat_transformers", ".", "append", "(", "transformer", ")", "\n", "self", ".", "att_transformers", ".", "append", "(", "attention", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetEncoder.forward": [[157, 197], ["x.view.view.view", "tab_network.TabNetEncoder.res_att", "x.view.view.view", "range", "torch.ones().to", "tab_network.TabNetEncoder.initial_splitter", "torch.mean", "torch.mul", "torch.mul", "x.view.view.view", "tab_network.TabNetEncoder.nor_att", "x.view.view.view", "steps_output.append", "torch.sum", "torch.nn.ReLU", "torch.ones", "torch.mul", "torch.log"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "prior", "=", "None", ")", ":", "\n", "\n", "#x = self.initial_bn(x)", "\n", "\n", "#shape:(b,?) -> (b,100)", "\n", "#First map x to an equivalent distribution of 100 dimensions", "\n", "        ", "x", "=", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "x", "=", "self", ".", "res_att", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "if", "prior", "is", "None", ":", "\n", "            ", "prior", "=", "torch", ".", "ones", "(", "x", ".", "shape", ")", ".", "to", "(", "x", ".", "device", ")", "\n", "\n", "", "M_loss", "=", "0", "\n", "\n", "att", "=", "self", ".", "initial_splitter", "(", "x", ")", "[", ":", ",", "self", ".", "n_d", ":", "]", "\n", "\n", "steps_output", "=", "[", "]", "\n", "for", "step", "in", "range", "(", "self", ".", "n_steps", ")", ":", "\n", "            ", "M", "=", "self", ".", "att_transformers", "[", "step", "]", "(", "prior", ",", "att", ")", "\n", "M_loss", "+=", "torch", ".", "mean", "(", "\n", "torch", ".", "sum", "(", "torch", ".", "mul", "(", "M", ",", "torch", ".", "log", "(", "M", "+", "self", ".", "epsilon", ")", ")", ",", "dim", "=", "1", ")", "\n", ")", "\n", "# update prior", "\n", "prior", "=", "torch", ".", "mul", "(", "self", ".", "gamma", "-", "M", ",", "prior", ")", "\n", "# output", "\n", "masked_x", "=", "torch", ".", "mul", "(", "M", ",", "x", ")", "\n", "\n", "masked_x", "=", "masked_x", ".", "view", "(", "masked_x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "masked_x", "=", "self", ".", "nor_att", "(", "masked_x", ")", "\n", "masked_x", "=", "x", ".", "view", "(", "masked_x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "out", "=", "self", ".", "feat_transformers", "[", "step", "]", "(", "masked_x", ")", "\n", "d", "=", "ReLU", "(", ")", "(", "out", "[", ":", ",", ":", "self", ".", "n_d", "]", ")", "\n", "steps_output", ".", "append", "(", "d", ")", "\n", "# update attention", "\n", "att", "=", "out", "[", ":", ",", "self", ".", "n_d", ":", "]", "\n", "\n", "", "M_loss", "/=", "self", ".", "n_steps", "\n", "return", "steps_output", ",", "M_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetEncoder.forward_masks": [[198, 234], ["x.view.view.view", "tab_network.TabNetEncoder.res_att", "x.view.view.view", "torch.ones().to", "torch.zeros().to", "range", "tab_network.TabNetEncoder.initial_splitter", "torch.mul", "torch.mul", "x.view.view.view", "tab_network.TabNetEncoder.nor_att", "x.view.view.view", "torch.sum", "torch.mul", "torch.ones", "torch.zeros", "torch.nn.ReLU", "torch.sum.unsqueeze"], "methods", ["None"], ["", "def", "forward_masks", "(", "self", ",", "x", ")", ":", "\n", "#x = self.initial_bn(x)", "\n", "\n", "#shape:(b,?) -> (b,1000)", "\n", "#First map x to an equivalent distribution of 100 dimensions", "\n", "        ", "x", "=", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "x", "=", "self", ".", "res_att", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "prior", "=", "torch", ".", "ones", "(", "x", ".", "shape", ")", ".", "to", "(", "x", ".", "device", ")", "\n", "M_explain", "=", "torch", ".", "zeros", "(", "x", ".", "shape", ")", ".", "to", "(", "x", ".", "device", ")", "\n", "att", "=", "self", ".", "initial_splitter", "(", "x", ")", "[", ":", ",", "self", ".", "n_d", ":", "]", "\n", "masks", "=", "{", "}", "\n", "\n", "for", "step", "in", "range", "(", "self", ".", "n_steps", ")", ":", "\n", "            ", "M", "=", "self", ".", "att_transformers", "[", "step", "]", "(", "prior", ",", "att", ")", "\n", "masks", "[", "step", "]", "=", "M", "\n", "# update prior", "\n", "prior", "=", "torch", ".", "mul", "(", "self", ".", "gamma", "-", "M", ",", "prior", ")", "\n", "# output", "\n", "masked_x", "=", "torch", ".", "mul", "(", "M", ",", "x", ")", "\n", "\n", "\n", "masked_x", "=", "masked_x", ".", "view", "(", "masked_x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ",", "1", ")", "\n", "masked_x", "=", "self", ".", "nor_att", "(", "masked_x", ")", "\n", "masked_x", "=", "x", ".", "view", "(", "masked_x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "-", "1", "]", ")", "\n", "\n", "out", "=", "self", ".", "feat_transformers", "[", "step", "]", "(", "masked_x", ")", "\n", "d", "=", "ReLU", "(", ")", "(", "out", "[", ":", ",", ":", "self", ".", "n_d", "]", ")", "\n", "# explain", "\n", "step_importance", "=", "torch", ".", "sum", "(", "d", ",", "dim", "=", "1", ")", "\n", "M_explain", "+=", "torch", ".", "mul", "(", "M", ",", "step_importance", ".", "unsqueeze", "(", "dim", "=", "1", ")", ")", "\n", "# update attention", "\n", "att", "=", "out", "[", ":", ",", "self", ".", "n_d", ":", "]", "\n", "\n", "", "return", "M_explain", ",", "masks", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetDecoder.__init__": [[237, 307], ["super().__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "torch.nn.ModuleList", "range", "tab_network.FeatTransformer", "tab_network.TabNetDecoder.feat_transformers.append", "torch.nn.Linear", "tab_network.initialize_non_glu", "tab_network.TabNetDecoder.reconstruction_layers.append", "torch.nn.ModuleList.append", "torch.nn.ModuleList.append", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_non_glu", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "n_d", "=", "8", ",", "\n", "n_steps", "=", "3", ",", "\n", "n_independent", "=", "2", ",", "\n", "n_shared", "=", "2", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Defines main part of the TabNet network without the embedding layers.\n\n        Parameters\n        ----------\n        input_dim : int\n            Number of features\n        output_dim : int or list of int for multi task classification\n            Dimension of network output\n            examples : one for regression, 2 for binary classification etc...\n        n_d : int\n            Dimension of the prediction  layer (usually between 4 and 64)\n        n_steps : int\n            Number of successive steps in the network (usually between 3 and 10)\n        gamma : float\n            Float above 1, scaling factor for attention updates (usually between 1.0 to 2.0)\n        n_independent : int\n            Number of independent GLU layer in each GLU block (default 2)\n        n_shared : int\n            Number of independent GLU layer in each GLU block (default 2)\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization\n        momentum : float\n            Float value between 0 and 1 which will be used for momentum in all batch norm\n        \"\"\"", "\n", "super", "(", "TabNetDecoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "n_d", "=", "n_d", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "n_independent", "=", "n_independent", "\n", "self", ".", "n_shared", "=", "n_shared", "\n", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "\n", "self", ".", "feat_transformers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "reconstruction_layers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "if", "self", ".", "n_shared", ">", "0", ":", "\n", "            ", "shared_feat_transform", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "n_shared", ")", ":", "\n", "                ", "if", "i", "==", "0", ":", "\n", "                    ", "shared_feat_transform", ".", "append", "(", "Linear", "(", "n_d", ",", "2", "*", "n_d", ",", "bias", "=", "False", ")", ")", "\n", "", "else", ":", "\n", "                    ", "shared_feat_transform", ".", "append", "(", "Linear", "(", "n_d", ",", "2", "*", "n_d", ",", "bias", "=", "False", ")", ")", "\n", "\n", "", "", "", "else", ":", "\n", "            ", "shared_feat_transform", "=", "None", "\n", "\n", "", "for", "step", "in", "range", "(", "n_steps", ")", ":", "\n", "            ", "transformer", "=", "FeatTransformer", "(", "\n", "n_d", ",", "\n", "n_d", ",", "\n", "shared_feat_transform", ",", "\n", "n_glu_independent", "=", "self", ".", "n_independent", ",", "\n", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", ")", "\n", "self", ".", "feat_transformers", ".", "append", "(", "transformer", ")", "\n", "reconstruction_layer", "=", "Linear", "(", "n_d", ",", "self", ".", "input_dim", ",", "bias", "=", "False", ")", "\n", "initialize_non_glu", "(", "reconstruction_layer", ",", "n_d", ",", "self", ".", "input_dim", ")", "\n", "self", ".", "reconstruction_layers", ".", "append", "(", "reconstruction_layer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetDecoder.forward": [[308, 315], ["enumerate", "torch.add"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "steps_output", ")", ":", "\n", "        ", "res", "=", "0", "\n", "for", "step_nb", ",", "step_output", "in", "enumerate", "(", "steps_output", ")", ":", "\n", "            ", "x", "=", "self", ".", "feat_transformers", "[", "step_nb", "]", "(", "step_output", ")", "\n", "x", "=", "self", ".", "reconstruction_layers", "[", "step_nb", "]", "(", "step_output", ")", "\n", "res", "=", "torch", ".", "add", "(", "res", ",", "x", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetPretraining.__init__": [[318, 385], ["super().__init__", "tab_network.EmbeddingGenerator", "tab_network.RandomObfuscator", "tab_network.TabNetEncoder", "tab_network.TabNetDecoder", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "pretraining_ratio", "=", "0.2", ",", "\n", "n_d", "=", "8", ",", "\n", "n_a", "=", "8", ",", "\n", "n_steps", "=", "3", ",", "\n", "gamma", "=", "1.3", ",", "\n", "cat_idxs", "=", "[", "]", ",", "\n", "cat_dims", "=", "[", "]", ",", "\n", "cat_emb_dim", "=", "1", ",", "\n", "n_independent", "=", "2", ",", "\n", "n_shared", "=", "2", ",", "\n", "epsilon", "=", "1e-15", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", "mask_type", "=", "\"sparsemax\"", ",", "\n", ")", ":", "\n", "        ", "super", "(", "TabNetPretraining", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "cat_idxs", "=", "cat_idxs", "or", "[", "]", "\n", "self", ".", "cat_dims", "=", "cat_dims", "or", "[", "]", "\n", "self", ".", "cat_emb_dim", "=", "cat_emb_dim", "\n", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "n_d", "=", "n_d", "\n", "self", ".", "n_a", "=", "n_a", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "n_independent", "=", "n_independent", "\n", "self", ".", "n_shared", "=", "n_shared", "\n", "self", ".", "mask_type", "=", "mask_type", "\n", "self", ".", "pretraining_ratio", "=", "pretraining_ratio", "\n", "\n", "if", "self", ".", "n_steps", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"n_steps should be a positive integer.\"", ")", "\n", "", "if", "self", ".", "n_independent", "==", "0", "and", "self", ".", "n_shared", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"n_shared and n_independent can't be both zero.\"", ")", "\n", "\n", "", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "embedder", "=", "EmbeddingGenerator", "(", "input_dim", ",", "cat_dims", ",", "cat_idxs", ",", "cat_emb_dim", ")", "\n", "self", ".", "post_embed_dim", "=", "self", ".", "embedder", ".", "post_embed_dim", "\n", "\n", "self", ".", "masker", "=", "RandomObfuscator", "(", "self", ".", "pretraining_ratio", ")", "\n", "self", ".", "encoder", "=", "TabNetEncoder", "(", "\n", "input_dim", "=", "self", ".", "post_embed_dim", ",", "\n", "output_dim", "=", "self", ".", "post_embed_dim", ",", "\n", "n_d", "=", "n_d", ",", "\n", "n_a", "=", "n_a", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "gamma", "=", "gamma", ",", "\n", "n_independent", "=", "n_independent", ",", "\n", "n_shared", "=", "n_shared", ",", "\n", "epsilon", "=", "epsilon", ",", "\n", "virtual_batch_size", "=", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", "mask_type", "=", "mask_type", ",", "\n", ")", "\n", "self", ".", "decoder", "=", "TabNetDecoder", "(", "\n", "self", ".", "post_embed_dim", ",", "\n", "n_d", "=", "n_d", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "n_independent", "=", "n_independent", ",", "\n", "n_shared", "=", "n_shared", ",", "\n", "virtual_batch_size", "=", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetPretraining.forward": [[387, 406], ["tab_network.TabNetPretraining.embedder", "tab_network.TabNetPretraining.masker", "tab_network.TabNetPretraining.encoder", "tab_network.TabNetPretraining.decoder", "tab_network.TabNetPretraining.encoder", "tab_network.TabNetPretraining.decoder", "torch.ones().to", "torch.ones"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Returns: res, embedded_x, obf_vars\n            res : output of reconstruction\n            embedded_x : embedded input\n            obf_vars : which variable where obfuscated\n        \"\"\"", "\n", "embedded_x", "=", "self", ".", "embedder", "(", "x", ")", "\n", "if", "self", ".", "training", ":", "\n", "            ", "masked_x", ",", "obf_vars", "=", "self", ".", "masker", "(", "embedded_x", ")", "\n", "# set prior of encoder with obf_mask", "\n", "prior", "=", "1", "-", "obf_vars", "\n", "steps_out", ",", "_", "=", "self", ".", "encoder", "(", "masked_x", ",", "prior", "=", "prior", ")", "\n", "res", "=", "self", ".", "decoder", "(", "steps_out", ")", "\n", "return", "res", ",", "embedded_x", ",", "obf_vars", "\n", "", "else", ":", "\n", "            ", "steps_out", ",", "_", "=", "self", ".", "encoder", "(", "embedded_x", ")", "\n", "res", "=", "self", ".", "decoder", "(", "steps_out", ")", "\n", "return", "res", ",", "embedded_x", ",", "torch", ".", "ones", "(", "embedded_x", ".", "shape", ")", ".", "to", "(", "x", ".", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetPretraining.forward_masks": [[407, 410], ["tab_network.TabNetPretraining.embedder", "tab_network.TabNetPretraining.encoder.forward_masks"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward_masks"], ["", "", "def", "forward_masks", "(", "self", ",", "x", ")", ":", "\n", "        ", "embedded_x", "=", "self", ".", "embedder", "(", "x", ")", "\n", "return", "self", ".", "encoder", ".", "forward_masks", "(", "embedded_x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetNoEmbeddings.__init__": [[413, 501], ["super().__init__", "isinstance", "torch.nn.BatchNorm1d", "tab_network.TabNetEncoder", "torch.nn.ModuleList", "torch.nn.Linear", "tab_network.initialize_non_glu", "torch.nn.Linear", "tab_network.initialize_non_glu", "tab_network.TabNetNoEmbeddings.multi_task_mappings.append"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_non_glu", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_non_glu", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "n_d", "=", "8", ",", "\n", "n_a", "=", "8", ",", "\n", "n_steps", "=", "3", ",", "\n", "gamma", "=", "1.3", ",", "\n", "n_independent", "=", "2", ",", "\n", "n_shared", "=", "2", ",", "\n", "epsilon", "=", "1e-15", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", "mask_type", "=", "\"sparsemax\"", ",", "\n", "mapping_dim", "=", "100", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Defines main part of the TabNet network without the embedding layers.\n\n        Parameters\n        ----------\n        input_dim : int\n            Number of features\n        output_dim : int or list of int for multi task classification\n            Dimension of network output\n            examples : one for regression, 2 for binary classification etc...\n        n_d : int\n            Dimension of the prediction  layer (usually between 4 and 64)\n        n_a : int\n            Dimension of the attention  layer (usually between 4 and 64)\n        n_steps : int\n            Number of successive steps in the network (usually between 3 and 10)\n        gamma : float\n            Float above 1, scaling factor for attention updates (usually between 1.0 to 2.0)\n        n_independent : int\n            Number of independent GLU layer in each GLU block (default 2)\n        n_shared : int\n            Number of independent GLU layer in each GLU block (default 2)\n        epsilon : float\n            Avoid log(0), this should be kept very low\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization\n        momentum : float\n            Float value between 0 and 1 which will be used for momentum in all batch norm\n        mask_type : str\n            Either \"sparsemax\" or \"entmax\" : this is the masking function to use\n        \"\"\"", "\n", "super", "(", "TabNetNoEmbeddings", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "is_multi_task", "=", "isinstance", "(", "output_dim", ",", "list", ")", "\n", "self", ".", "n_d", "=", "n_d", "\n", "self", ".", "n_a", "=", "n_a", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "n_independent", "=", "n_independent", "\n", "self", ".", "n_shared", "=", "n_shared", "\n", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "mask_type", "=", "mask_type", "\n", "self", ".", "initial_bn", "=", "BatchNorm1d", "(", "self", ".", "input_dim", ",", "momentum", "=", "0.01", ")", "\n", "self", ".", "mapping_dim", "=", "mapping_dim", "\n", "\n", "self", ".", "encoder", "=", "TabNetEncoder", "(", "\n", "input_dim", "=", "input_dim", ",", "\n", "output_dim", "=", "output_dim", ",", "\n", "n_d", "=", "n_d", ",", "\n", "n_a", "=", "n_a", ",", "\n", "n_steps", "=", "n_steps", ",", "\n", "gamma", "=", "gamma", ",", "\n", "n_independent", "=", "n_independent", ",", "\n", "n_shared", "=", "n_shared", ",", "\n", "epsilon", "=", "epsilon", ",", "\n", "virtual_batch_size", "=", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", "mask_type", "=", "mask_type", ",", "\n", "mapping_dim", "=", "mapping_dim", "\n", ")", "\n", "\n", "if", "self", ".", "is_multi_task", ":", "\n", "            ", "self", ".", "multi_task_mappings", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "for", "task_dim", "in", "output_dim", ":", "\n", "                ", "task_mapping", "=", "Linear", "(", "n_d", ",", "task_dim", ",", "bias", "=", "False", ")", "\n", "initialize_non_glu", "(", "task_mapping", ",", "n_d", ",", "task_dim", ")", "\n", "self", ".", "multi_task_mappings", ".", "append", "(", "task_mapping", ")", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "final_mapping", "=", "Linear", "(", "n_d", ",", "output_dim", ",", "bias", "=", "False", ")", "\n", "initialize_non_glu", "(", "self", ".", "final_mapping", ",", "n_d", ",", "output_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetNoEmbeddings.forward": [[502, 515], ["tab_network.TabNetNoEmbeddings.encoder", "torch.sum", "torch.stack", "tab_network.TabNetNoEmbeddings.final_mapping", "tab_network.TabNetNoEmbeddings.append", "task_mapping"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "res", "=", "0", "\n", "steps_output", ",", "M_loss", "=", "self", ".", "encoder", "(", "x", ")", "\n", "res", "=", "torch", ".", "sum", "(", "torch", ".", "stack", "(", "steps_output", ",", "dim", "=", "0", ")", ",", "dim", "=", "0", ")", "\n", "\n", "if", "self", ".", "is_multi_task", ":", "\n", "# Result will be in list format", "\n", "            ", "out", "=", "[", "]", "\n", "for", "task_mapping", "in", "self", ".", "multi_task_mappings", ":", "\n", "                ", "out", ".", "append", "(", "task_mapping", "(", "res", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "out", "=", "self", ".", "final_mapping", "(", "res", ")", "\n", "", "return", "out", ",", "M_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNetNoEmbeddings.forward_masks": [[516, 518], ["tab_network.TabNetNoEmbeddings.encoder.forward_masks"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward_masks"], ["", "def", "forward_masks", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "encoder", ".", "forward_masks", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.__init__": [[521, 618], ["super().__init__", "tab_network.EmbeddingGenerator", "tab_network.TabNetNoEmbeddings", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "n_d", "=", "8", ",", "\n", "n_a", "=", "8", ",", "\n", "n_steps", "=", "3", ",", "\n", "gamma", "=", "1.3", ",", "\n", "cat_idxs", "=", "[", "]", ",", "\n", "cat_dims", "=", "[", "]", ",", "\n", "cat_emb_dim", "=", "1", ",", "\n", "n_independent", "=", "2", ",", "\n", "n_shared", "=", "2", ",", "\n", "epsilon", "=", "1e-15", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", "mask_type", "=", "\"sparsemax\"", ",", "\n", "mapping_dim", "=", "100", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Defines TabNet network\n\n        Parameters\n        ----------\n        input_dim : int\n            Initial number of features\n        output_dim : int\n            Dimension of network output\n            examples : one for regression, 2 for binary classification etc...\n        n_d : int\n            Dimension of the prediction  layer (usually between 4 and 64)\n        n_a : int\n            Dimension of the attention  layer (usually between 4 and 64)\n        n_steps : int\n            Number of successive steps in the network (usually between 3 and 10)\n        gamma : float\n            Float above 1, scaling factor for attention updates (usually between 1.0 to 2.0)\n        cat_idxs : list of int\n            Index of each categorical column in the dataset\n        cat_dims : list of int\n            Number of categories in each categorical column\n        cat_emb_dim : int or list of int\n            Size of the embedding of categorical features\n            if int, all categorical features will have same embedding size\n            if list of int, every corresponding feature will have specific size\n        n_independent : int\n            Number of independent GLU layer in each GLU block (default 2)\n        n_shared : int\n            Number of independent GLU layer in each GLU block (default 2)\n        epsilon : float\n            Avoid log(0), this should be kept very low\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization\n        momentum : float\n            Float value between 0 and 1 which will be used for momentum in all batch norm\n        mask_type : str\n            Either \"sparsemax\" or \"entmax\" : this is the masking function to use\n        \"\"\"", "\n", "super", "(", "TabNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cat_idxs", "=", "cat_idxs", "or", "[", "]", "\n", "self", ".", "cat_dims", "=", "cat_dims", "or", "[", "]", "\n", "self", ".", "cat_emb_dim", "=", "cat_emb_dim", "\n", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "self", ".", "n_d", "=", "n_d", "\n", "self", ".", "n_a", "=", "n_a", "\n", "self", ".", "n_steps", "=", "n_steps", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "epsilon", "=", "epsilon", "\n", "self", ".", "n_independent", "=", "n_independent", "\n", "self", ".", "n_shared", "=", "n_shared", "\n", "self", ".", "mask_type", "=", "mask_type", "\n", "self", ".", "mapping_dim", "=", "mapping_dim", "\n", "\n", "if", "self", ".", "n_steps", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"n_steps should be a positive integer.\"", ")", "\n", "", "if", "self", ".", "n_independent", "==", "0", "and", "self", ".", "n_shared", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"n_shared and n_independent can't be both zero.\"", ")", "\n", "\n", "", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "embedder", "=", "EmbeddingGenerator", "(", "input_dim", ",", "cat_dims", ",", "cat_idxs", ",", "cat_emb_dim", ")", "\n", "self", ".", "post_embed_dim", "=", "self", ".", "embedder", ".", "post_embed_dim", "\n", "self", ".", "tabnet", "=", "TabNetNoEmbeddings", "(", "\n", "self", ".", "post_embed_dim", ",", "\n", "output_dim", ",", "\n", "n_d", ",", "\n", "n_a", ",", "\n", "n_steps", ",", "\n", "gamma", ",", "\n", "n_independent", ",", "\n", "n_shared", ",", "\n", "epsilon", ",", "\n", "virtual_batch_size", ",", "\n", "momentum", ",", "\n", "mask_type", ",", "\n", "self", ".", "mapping_dim", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward": [[620, 623], ["tab_network.TabNet.embedder", "tab_network.TabNet.tabnet"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "embedder", "(", "x", ")", "\n", "return", "self", ".", "tabnet", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward_masks": [[624, 627], ["tab_network.TabNet.embedder", "tab_network.TabNet.tabnet.forward_masks"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward_masks"], ["", "def", "forward_masks", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "embedder", "(", "x", ")", "\n", "return", "self", ".", "tabnet", ".", "forward_masks", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.AttentiveTransformer.__init__": [[630, 670], ["super().__init__", "torch.nn.Linear", "tab_network.initialize_non_glu", "tab_network.GBN", "sparsemax.Sparsemax", "sparsemax.Entmax15", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_non_glu"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", "mask_type", "=", "\"sparsemax\"", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize an attention transformer.\n\n        Parameters\n        ----------\n        input_dim : int\n            Input size\n        output_dim : int\n            Output_size\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization\n        momentum : float\n            Float value between 0 and 1 which will be used for momentum in batch norm\n        mask_type : str\n            Either \"sparsemax\" or \"entmax\" : this is the masking function to use\n        \"\"\"", "\n", "super", "(", "AttentiveTransformer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc", "=", "Linear", "(", "input_dim", ",", "output_dim", ",", "bias", "=", "False", ")", "\n", "initialize_non_glu", "(", "self", ".", "fc", ",", "input_dim", ",", "output_dim", ")", "\n", "self", ".", "bn", "=", "GBN", "(", "\n", "output_dim", ",", "virtual_batch_size", "=", "virtual_batch_size", ",", "momentum", "=", "momentum", "\n", ")", "\n", "\n", "if", "mask_type", "==", "\"sparsemax\"", ":", "\n", "# Sparsemax", "\n", "            ", "self", ".", "selector", "=", "sparsemax", ".", "Sparsemax", "(", "dim", "=", "-", "1", ")", "\n", "", "elif", "mask_type", "==", "\"entmax\"", ":", "\n", "# Entmax", "\n", "            ", "self", ".", "selector", "=", "sparsemax", ".", "Entmax15", "(", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\n", "\"Please choose either sparsemax\"", "+", "\"or entmax as masktype\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.AttentiveTransformer.forward": [[672, 678], ["tab_network.AttentiveTransformer.fc", "tab_network.AttentiveTransformer.bn", "torch.mul", "tab_network.AttentiveTransformer.selector"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "priors", ",", "processed_feat", ")", ":", "\n", "        ", "x", "=", "self", ".", "fc", "(", "processed_feat", ")", "\n", "x", "=", "self", ".", "bn", "(", "x", ")", "\n", "x", "=", "torch", ".", "mul", "(", "x", ",", "priors", ")", "\n", "x", "=", "self", ".", "selector", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.FeatTransformer.__init__": [[681, 739], ["super().__init__", "torch.nn.Identity", "tab_network.GLU_Block", "torch.nn.Identity", "tab_network.GLU_Block", "len"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "shared_layers", ",", "\n", "n_glu_independent", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", ")", ":", "\n", "        ", "super", "(", "FeatTransformer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\"\"\"\n        Initialize a feature transformer.\n\n        Parameters\n        ----------\n        input_dim : int\n            Input size\n        output_dim : int\n            Output_size\n        shared_layers : torch.nn.ModuleList\n            The shared block that should be common to every step\n        n_glu_independent : int\n            Number of independent GLU layers\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization within GLU block(s)\n        momentum : float\n            Float value between 0 and 1 which will be used for momentum in batch norm\n        \"\"\"", "\n", "\n", "params", "=", "{", "\n", "\"n_glu\"", ":", "n_glu_independent", ",", "\n", "\"virtual_batch_size\"", ":", "virtual_batch_size", ",", "\n", "\"momentum\"", ":", "momentum", ",", "\n", "}", "\n", "\n", "if", "shared_layers", "is", "None", ":", "\n", "# no shared layers", "\n", "            ", "self", ".", "shared", "=", "torch", ".", "nn", ".", "Identity", "(", ")", "\n", "is_first", "=", "True", "\n", "", "else", ":", "\n", "            ", "self", ".", "shared", "=", "GLU_Block", "(", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "first", "=", "True", ",", "\n", "shared_layers", "=", "shared_layers", ",", "\n", "n_glu", "=", "len", "(", "shared_layers", ")", ",", "\n", "virtual_batch_size", "=", "virtual_batch_size", ",", "\n", "momentum", "=", "momentum", ",", "\n", ")", "\n", "is_first", "=", "False", "\n", "\n", "", "if", "n_glu_independent", "==", "0", ":", "\n", "# no independent layers", "\n", "            ", "self", ".", "specifics", "=", "torch", ".", "nn", ".", "Identity", "(", ")", "\n", "", "else", ":", "\n", "            ", "spec_input_dim", "=", "input_dim", "if", "is_first", "else", "output_dim", "\n", "self", ".", "specifics", "=", "GLU_Block", "(", "\n", "spec_input_dim", ",", "output_dim", ",", "first", "=", "is_first", ",", "**", "params", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.FeatTransformer.forward": [[741, 745], ["tab_network.FeatTransformer.shared", "tab_network.FeatTransformer.specifics"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "shared", "(", "x", ")", "\n", "x", "=", "self", ".", "specifics", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.GLU_Block.__init__": [[752, 775], ["super().__init__", "torch.nn.ModuleList", "tab_network.GLU_Block.glu_layers.append", "range", "tab_network.GLU_Layer", "tab_network.GLU_Block.glu_layers.append", "tab_network.GLU_Layer"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "output_dim", ",", "\n", "n_glu", "=", "2", ",", "\n", "first", "=", "False", ",", "\n", "shared_layers", "=", "None", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "momentum", "=", "0.02", ",", "\n", ")", ":", "\n", "        ", "super", "(", "GLU_Block", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "first", "=", "first", "\n", "self", ".", "shared_layers", "=", "shared_layers", "\n", "self", ".", "n_glu", "=", "n_glu", "\n", "self", ".", "glu_layers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "params", "=", "{", "\"virtual_batch_size\"", ":", "virtual_batch_size", ",", "\"momentum\"", ":", "momentum", "}", "\n", "\n", "fc", "=", "shared_layers", "[", "0", "]", "if", "shared_layers", "else", "None", "\n", "self", ".", "glu_layers", ".", "append", "(", "GLU_Layer", "(", "input_dim", ",", "output_dim", ",", "fc", "=", "fc", ",", "**", "params", ")", ")", "\n", "for", "glu_id", "in", "range", "(", "1", ",", "self", ".", "n_glu", ")", ":", "\n", "            ", "fc", "=", "shared_layers", "[", "glu_id", "]", "if", "shared_layers", "else", "None", "\n", "self", ".", "glu_layers", ".", "append", "(", "GLU_Layer", "(", "output_dim", ",", "output_dim", ",", "fc", "=", "fc", ",", "**", "params", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.GLU_Block.forward": [[776, 788], ["torch.sqrt", "torch.FloatTensor().to", "range", "range", "torch.add", "torch.FloatTensor"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "scale", "=", "torch", ".", "sqrt", "(", "torch", ".", "FloatTensor", "(", "[", "0.5", "]", ")", ".", "to", "(", "x", ".", "device", ")", ")", "\n", "if", "self", ".", "first", ":", "# the first layer of the block has no scale multiplication", "\n", "            ", "x", "=", "self", ".", "glu_layers", "[", "0", "]", "(", "x", ")", "\n", "layers_left", "=", "range", "(", "1", ",", "self", ".", "n_glu", ")", "\n", "", "else", ":", "\n", "            ", "layers_left", "=", "range", "(", "self", ".", "n_glu", ")", "\n", "\n", "", "for", "glu_id", "in", "layers_left", ":", "\n", "            ", "x", "=", "torch", ".", "add", "(", "x", ",", "self", ".", "glu_layers", "[", "glu_id", "]", "(", "x", ")", ")", "\n", "x", "=", "x", "*", "scale", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.GLU_Layer.__init__": [[791, 805], ["super().__init__", "tab_network.initialize_glu", "tab_network.GBN", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_glu"], ["    ", "def", "__init__", "(", "\n", "self", ",", "input_dim", ",", "output_dim", ",", "fc", "=", "None", ",", "virtual_batch_size", "=", "128", ",", "momentum", "=", "0.02", "\n", ")", ":", "\n", "        ", "super", "(", "GLU_Layer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "if", "fc", ":", "\n", "            ", "self", ".", "fc", "=", "fc", "\n", "", "else", ":", "\n", "            ", "self", ".", "fc", "=", "Linear", "(", "input_dim", ",", "2", "*", "output_dim", ",", "bias", "=", "False", ")", "\n", "", "initialize_glu", "(", "self", ".", "fc", ",", "input_dim", ",", "2", "*", "output_dim", ")", "\n", "\n", "self", ".", "bn", "=", "GBN", "(", "\n", "2", "*", "output_dim", ",", "virtual_batch_size", "=", "virtual_batch_size", ",", "momentum", "=", "momentum", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.GLU_Layer.forward": [[807, 812], ["tab_network.GLU_Layer.fc", "tab_network.GLU_Layer.bn", "torch.mul", "torch.sigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "x", "=", "self", ".", "bn", "(", "x", ")", "\n", "out", "=", "torch", ".", "mul", "(", "x", "[", ":", ",", ":", "self", ".", "output_dim", "]", ",", "torch", ".", "sigmoid", "(", "x", "[", ":", ",", "self", ".", "output_dim", ":", "]", ")", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.EmbeddingGenerator.__init__": [[819, 869], ["super().__init__", "isinstance", "int", "torch.nn.ModuleList", "numpy.argsort", "zip", "torch.ones", "len", "len", "ValueError", "tab_network.EmbeddingGenerator.embeddings.append", "len", "len", "torch.nn.Embedding", "len", "len", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "cat_dims", ",", "cat_idxs", ",", "cat_emb_dim", ")", ":", "\n", "        ", "\"\"\"This is an embedding module for an entire set of features\n\n        Parameters\n        ----------\n        input_dim : int\n            Number of features coming as input (number of columns)\n        cat_dims : list of int\n            Number of modalities for each categorial features\n            If the list is empty, no embeddings will be done\n        cat_idxs : list of int\n            Positional index for each categorical features in inputs\n        cat_emb_dim : int or list of int\n            Embedding dimension for each categorical features\n            If int, the same embedding dimension will be used for all categorical features\n        \"\"\"", "\n", "super", "(", "EmbeddingGenerator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "cat_dims", "==", "[", "]", "or", "cat_idxs", "==", "[", "]", ":", "\n", "            ", "self", ".", "skip_embedding", "=", "True", "\n", "self", ".", "post_embed_dim", "=", "input_dim", "\n", "return", "\n", "\n", "", "self", ".", "skip_embedding", "=", "False", "\n", "if", "isinstance", "(", "cat_emb_dim", ",", "int", ")", ":", "\n", "            ", "self", ".", "cat_emb_dims", "=", "[", "cat_emb_dim", "]", "*", "len", "(", "cat_idxs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "cat_emb_dims", "=", "cat_emb_dim", "\n", "\n", "# check that all embeddings are provided", "\n", "", "if", "len", "(", "self", ".", "cat_emb_dims", ")", "!=", "len", "(", "cat_dims", ")", ":", "\n", "            ", "msg", "=", "f\"\"\"cat_emb_dim and cat_dims must be lists of same length, got {len(self.cat_emb_dims)}\n                      and {len(cat_dims)}\"\"\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "self", ".", "post_embed_dim", "=", "int", "(", "\n", "input_dim", "+", "np", ".", "sum", "(", "self", ".", "cat_emb_dims", ")", "-", "len", "(", "self", ".", "cat_emb_dims", ")", "\n", ")", "\n", "\n", "self", ".", "embeddings", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "# Sort dims by cat_idx", "\n", "sorted_idxs", "=", "np", ".", "argsort", "(", "cat_idxs", ")", "\n", "cat_dims", "=", "[", "cat_dims", "[", "i", "]", "for", "i", "in", "sorted_idxs", "]", "\n", "self", ".", "cat_emb_dims", "=", "[", "self", ".", "cat_emb_dims", "[", "i", "]", "for", "i", "in", "sorted_idxs", "]", "\n", "\n", "for", "cat_dim", ",", "emb_dim", "in", "zip", "(", "cat_dims", ",", "self", ".", "cat_emb_dims", ")", ":", "\n", "            ", "self", ".", "embeddings", ".", "append", "(", "torch", ".", "nn", ".", "Embedding", "(", "cat_dim", ",", "emb_dim", ")", ")", "\n", "\n", "# record continuous indices", "\n", "", "self", ".", "continuous_idx", "=", "torch", ".", "ones", "(", "input_dim", ",", "dtype", "=", "torch", ".", "bool", ")", "\n", "self", ".", "continuous_idx", "[", "cat_idxs", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.EmbeddingGenerator.forward": [[870, 894], ["enumerate", "torch.cat", "cols.append", "cols.append", "x[].float().view", "x[].long", "x[].float"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Apply embeddings to inputs\n        Inputs should be (batch_size, input_dim)\n        Outputs will be of size (batch_size, self.post_embed_dim)\n        \"\"\"", "\n", "if", "self", ".", "skip_embedding", ":", "\n", "# no embeddings required", "\n", "            ", "return", "x", "\n", "\n", "", "cols", "=", "[", "]", "\n", "cat_feat_counter", "=", "0", "\n", "for", "feat_init_idx", ",", "is_continuous", "in", "enumerate", "(", "self", ".", "continuous_idx", ")", ":", "\n", "# Enumerate through continuous idx boolean mask to apply embeddings", "\n", "            ", "if", "is_continuous", ":", "\n", "                ", "cols", ".", "append", "(", "x", "[", ":", ",", "feat_init_idx", "]", ".", "float", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "cols", ".", "append", "(", "\n", "self", ".", "embeddings", "[", "cat_feat_counter", "]", "(", "x", "[", ":", ",", "feat_init_idx", "]", ".", "long", "(", ")", ")", "\n", ")", "\n", "cat_feat_counter", "+=", "1", "\n", "# concat", "\n", "", "", "post_embeddings", "=", "torch", ".", "cat", "(", "cols", ",", "dim", "=", "1", ")", "\n", "return", "post_embeddings", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.RandomObfuscator.__init__": [[901, 911], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["def", "__init__", "(", "self", ",", "pretraining_ratio", ")", ":", "\n", "        ", "\"\"\"\n        This create random obfuscation for self suppervised pretraining\n        Parameters\n        ----------\n        pretraining_ratio : float\n            Ratio of feature to randomly discard for reconstruction\n        \"\"\"", "\n", "super", "(", "RandomObfuscator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pretraining_ratio", "=", "pretraining_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.RandomObfuscator.forward": [[912, 925], ["torch.bernoulli().to", "torch.mul", "torch.bernoulli", "torch.ones"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n        Generate random obfuscation mask.\n\n        Returns\n        -------\n        masked input and obfuscated variables.\n        \"\"\"", "\n", "obfuscated_vars", "=", "torch", ".", "bernoulli", "(", "\n", "self", ".", "pretraining_ratio", "*", "torch", ".", "ones", "(", "x", ".", "shape", ")", "\n", ")", ".", "to", "(", "x", ".", "device", ")", "\n", "masked_input", "=", "torch", ".", "mul", "(", "1", "-", "obfuscated_vars", ",", "x", ")", "\n", "return", "masked_input", ",", "obfuscated_vars", "\n", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_non_glu": [[8, 13], ["numpy.sqrt", "torch.nn.init.xavier_normal_", "numpy.sqrt"], "function", ["None"], ["def", "initialize_non_glu", "(", "module", ",", "input_dim", ",", "output_dim", ")", ":", "\n", "    ", "gain_value", "=", "np", ".", "sqrt", "(", "(", "input_dim", "+", "output_dim", ")", "/", "np", ".", "sqrt", "(", "4", "*", "input_dim", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_normal_", "(", "module", ".", "weight", ",", "gain", "=", "gain_value", ")", "\n", "# torch.nn.init.zeros_(module.bias)", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.initialize_glu": [[15, 20], ["numpy.sqrt", "torch.nn.init.xavier_normal_", "numpy.sqrt"], "function", ["None"], ["", "def", "initialize_glu", "(", "module", ",", "input_dim", ",", "output_dim", ")", ":", "\n", "    ", "gain_value", "=", "np", ".", "sqrt", "(", "(", "input_dim", "+", "output_dim", ")", "/", "np", ".", "sqrt", "(", "input_dim", ")", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_normal_", "(", "module", ".", "weight", ",", "gain", "=", "gain_value", ")", "\n", "# torch.nn.init.zeros_(module.bias)", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.__init__": [[14, 16], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.set_params": [[17, 19], ["None"], "methods", ["None"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "self", ".", "params", "=", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.set_trainer": [[20, 22], ["None"], "methods", ["None"], ["", "def", "set_trainer", "(", "self", ",", "model", ")", ":", "\n", "        ", "self", ".", "trainer", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.on_epoch_begin": [[23, 25], ["None"], "methods", ["None"], ["", "def", "on_epoch_begin", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.on_epoch_end": [[26, 28], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.on_batch_begin": [[29, 31], ["None"], "methods", ["None"], ["", "def", "on_batch_begin", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.on_batch_end": [[32, 34], ["None"], "methods", ["None"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.on_train_begin": [[35, 37], ["None"], "methods", ["None"], ["", "def", "on_train_begin", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.Callback.on_train_end": [[38, 40], ["None"], "methods", ["None"], ["", "def", "on_train_end", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append": [[50, 52], ["callbacks.CallbackContainer.callbacks.append"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["def", "append", "(", "self", ",", "callback", ")", ":", "\n", "        ", "self", ".", "callbacks", ".", "append", "(", "callback", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.set_params": [[53, 56], ["callback.set_params"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.set_params"], ["", "def", "set_params", "(", "self", ",", "params", ")", ":", "\n", "        ", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "set_params", "(", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.set_trainer": [[57, 61], ["callback.set_trainer"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.set_trainer"], ["", "", "def", "set_trainer", "(", "self", ",", "trainer", ")", ":", "\n", "        ", "self", ".", "trainer", "=", "trainer", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "set_trainer", "(", "trainer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_epoch_begin": [[62, 66], ["callback.on_epoch_begin"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_epoch_begin"], ["", "", "def", "on_epoch_begin", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "logs", "=", "logs", "or", "{", "}", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "on_epoch_begin", "(", "epoch", ",", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_epoch_end": [[67, 71], ["callback.on_epoch_end"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_epoch_end"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "logs", "=", "logs", "or", "{", "}", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "on_epoch_end", "(", "epoch", ",", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_batch_begin": [[72, 76], ["callback.on_batch_begin"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_batch_begin"], ["", "", "def", "on_batch_begin", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "logs", "=", "logs", "or", "{", "}", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "on_batch_begin", "(", "batch", ",", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_batch_end": [[77, 81], ["callback.on_batch_end"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_batch_end"], ["", "", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "logs", "=", "logs", "or", "{", "}", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "on_batch_end", "(", "batch", ",", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_train_begin": [[82, 87], ["time.time", "callback.on_train_begin"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_train_begin"], ["", "", "def", "on_train_begin", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "logs", "=", "logs", "or", "{", "}", "\n", "logs", "[", "\"start_time\"", "]", "=", "time", ".", "time", "(", ")", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "on_train_begin", "(", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_train_end": [[88, 92], ["callback.on_train_end"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.EarlyStopping.on_train_end"], ["", "", "def", "on_train_end", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "logs", "=", "logs", "or", "{", "}", "\n", "for", "callback", "in", "self", ".", "callbacks", ":", "\n", "            ", "callback", ".", "on_train_end", "(", "logs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.EarlyStopping.__post_init__": [[120, 129], ["callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "best_epoch", "=", "0", "\n", "self", ".", "stopped_epoch", "=", "0", "\n", "self", ".", "wait", "=", "0", "\n", "self", ".", "best_weights", "=", "None", "\n", "self", ".", "best_loss", "=", "np", ".", "inf", "\n", "if", "self", ".", "is_maximize", ":", "\n", "            ", "self", ".", "best_loss", "=", "-", "self", ".", "best_loss", "\n", "", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.EarlyStopping.on_epoch_end": [[130, 148], ["logs.get", "copy.deepcopy", "callbacks.EarlyStopping.trainer.network.state_dict"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "current_loss", "=", "logs", ".", "get", "(", "self", ".", "early_stopping_metric", ")", "\n", "if", "current_loss", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "loss_change", "=", "current_loss", "-", "self", ".", "best_loss", "\n", "max_improved", "=", "self", ".", "is_maximize", "and", "loss_change", ">", "self", ".", "tol", "\n", "min_improved", "=", "(", "not", "self", ".", "is_maximize", ")", "and", "(", "-", "loss_change", ">", "self", ".", "tol", ")", "\n", "if", "max_improved", "or", "min_improved", ":", "\n", "            ", "self", ".", "best_loss", "=", "current_loss", "\n", "self", ".", "best_epoch", "=", "epoch", "\n", "self", ".", "wait", "=", "1", "\n", "self", ".", "best_weights", "=", "copy", ".", "deepcopy", "(", "self", ".", "trainer", ".", "network", ".", "state_dict", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "wait", ">=", "self", ".", "patience", ":", "\n", "                ", "self", ".", "stopped_epoch", "=", "epoch", "\n", "self", ".", "trainer", ".", "_stop_training", "=", "True", "\n", "", "self", ".", "wait", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.EarlyStopping.on_train_end": [[149, 171], ["print", "callbacks.EarlyStopping.trainer.network.load_state_dict", "print", "print", "round", "round"], "methods", ["None"], ["", "", "def", "on_train_end", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "trainer", ".", "best_epoch", "=", "self", ".", "best_epoch", "\n", "self", ".", "trainer", ".", "best_cost", "=", "self", ".", "best_loss", "\n", "\n", "if", "self", ".", "best_weights", "is", "not", "None", ":", "\n", "            ", "self", ".", "trainer", ".", "network", ".", "load_state_dict", "(", "self", ".", "best_weights", ")", "\n", "\n", "", "if", "self", ".", "stopped_epoch", ">", "0", ":", "\n", "            ", "msg", "=", "f\"\\nEarly stopping occurred at epoch {self.stopped_epoch}\"", "\n", "msg", "+=", "(", "\n", "f\" with best_epoch = {self.best_epoch} and \"", "\n", "+", "f\"best_{self.early_stopping_metric} = {round(self.best_loss, 5)}\"", "\n", ")", "\n", "print", "(", "msg", ")", "\n", "", "else", ":", "\n", "            ", "msg", "=", "(", "\n", "f\"Stop training because you reached max_epochs = {self.trainer.max_epochs}\"", "\n", "+", "f\" with best_epoch = {self.best_epoch} and \"", "\n", "+", "f\"best_{self.early_stopping_metric} = {round(self.best_loss, 5)}\"", "\n", ")", "\n", "print", "(", "msg", ")", "\n", "", "print", "(", "\"Best weights from best epoch are automatically used!\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.__post_init__": [[191, 195], ["callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "samples_seen", "=", "0.0", "\n", "self", ".", "total_time", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_train_begin": [[196, 202], ["callbacks.History.history.update", "callbacks.History.history.update"], "methods", ["None"], ["", "def", "on_train_begin", "(", "self", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "history", "=", "{", "\"loss\"", ":", "[", "]", "}", "\n", "self", ".", "history", ".", "update", "(", "{", "\"lr\"", ":", "[", "]", "}", ")", "\n", "self", ".", "history", ".", "update", "(", "{", "name", ":", "[", "]", "for", "name", "in", "self", ".", "trainer", ".", "_metrics_names", "}", ")", "\n", "self", ".", "start_time", "=", "logs", "[", "\"start_time\"", "]", "\n", "self", ".", "epoch_loss", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_epoch_begin": [[203, 206], ["None"], "methods", ["None"], ["", "def", "on_epoch_begin", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "epoch_metrics", "=", "{", "\"loss\"", ":", "0.0", "}", "\n", "self", ".", "samples_seen", "=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_epoch_end": [[207, 222], ["callbacks.History.epoch_metrics.items", "callbacks.History.epoch_metrics.items", "int", "print", "callbacks.History.history[].append", "time.time", "str", "numpy.round", "datetime.timedelta"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "self", ".", "epoch_metrics", "[", "\"loss\"", "]", "=", "self", ".", "epoch_loss", "\n", "for", "metric_name", ",", "metric_value", "in", "self", ".", "epoch_metrics", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "history", "[", "metric_name", "]", ".", "append", "(", "metric_value", ")", "\n", "", "if", "self", ".", "verbose", "==", "0", ":", "\n", "            ", "return", "\n", "", "if", "epoch", "%", "self", ".", "verbose", "!=", "0", ":", "\n", "            ", "return", "\n", "", "msg", "=", "f\"epoch {epoch:<3}\"", "\n", "for", "metric_name", ",", "metric_value", "in", "self", ".", "epoch_metrics", ".", "items", "(", ")", ":", "\n", "            ", "if", "metric_name", "!=", "\"lr\"", ":", "\n", "                ", "msg", "+=", "f\"| {metric_name:<3}: {np.round(metric_value, 5):<8}\"", "\n", "", "", "self", ".", "total_time", "=", "int", "(", "time", ".", "time", "(", ")", "-", "self", ".", "start_time", ")", "\n", "msg", "+=", "f\"|  {str(datetime.timedelta(seconds=self.total_time)) + 's':<6}\"", "\n", "print", "(", "msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_batch_end": [[223, 229], ["None"], "methods", ["None"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "batch_size", "=", "logs", "[", "\"batch_size\"", "]", "\n", "self", ".", "epoch_loss", "=", "(", "\n", "self", ".", "samples_seen", "*", "self", ".", "epoch_loss", "+", "batch_size", "*", "logs", "[", "\"loss\"", "]", "\n", ")", "/", "(", "self", ".", "samples_seen", "+", "batch_size", ")", "\n", "self", ".", "samples_seen", "+=", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.__getitem__": [[230, 232], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "self", ".", "history", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.__repr__": [[233, 235], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "history", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.__str__": [[236, 238], ["str"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "history", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.__post_init__": [[262, 268], ["hasattr", "callbacks.LRSchedulerCallback.scheduler_fn", "callbacks.Callback.__init__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__"], ["def", "__post_init__", "(", "\n", "self", ",", "\n", ")", ":", "\n", "        ", "self", ".", "is_metric_related", "=", "hasattr", "(", "self", ".", "scheduler_fn", ",", "\"is_better\"", ")", "\n", "self", ".", "scheduler", "=", "self", ".", "scheduler_fn", "(", "self", ".", "optimizer", ",", "**", "self", ".", "scheduler_params", ")", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_batch_end": [[269, 274], ["callbacks.LRSchedulerCallback.scheduler.step"], "methods", ["None"], ["", "def", "on_batch_end", "(", "self", ",", "batch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "is_batch_level", ":", "\n", "            ", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "", "else", ":", "\n", "            ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_epoch_end": [[275, 286], ["logs.get", "callbacks.LRSchedulerCallback.scheduler.step", "callbacks.LRSchedulerCallback.scheduler.step"], "methods", ["None"], ["", "", "def", "on_epoch_end", "(", "self", ",", "epoch", ",", "logs", "=", "None", ")", ":", "\n", "        ", "current_loss", "=", "logs", ".", "get", "(", "self", ".", "early_stopping_metric", ")", "\n", "if", "current_loss", "is", "None", ":", "\n", "            ", "return", "\n", "", "if", "self", ".", "is_batch_level", ":", "\n", "            ", "pass", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "is_metric_related", ":", "\n", "                ", "self", ".", "scheduler", ".", "step", "(", "current_loss", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.TorchDataset.__init__": [[22, 25], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "self", ".", "x", "=", "x", "\n", "self", ".", "y", "=", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.TorchDataset.__len__": [[26, 28], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.TorchDataset.__getitem__": [[29, 32], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "x", ",", "y", "=", "self", ".", "x", "[", "index", "]", ",", "self", ".", "y", "[", "index", "]", "\n", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.PredictDataset.__init__": [[44, 46], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "x", "=", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.PredictDataset.__len__": [[47, 49], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.PredictDataset.__getitem__": [[50, 53], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "x", "=", "self", ".", "x", "[", "index", "]", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.ComplexEncoder.default": [[335, 340], ["isinstance", "json.JSONEncoder.default", "int"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.ComplexEncoder.default"], ["    ", "def", "default", "(", "self", ",", "obj", ")", ":", "\n", "        ", "if", "isinstance", "(", "obj", ",", "np", ".", "int64", ")", ":", "\n", "            ", "return", "int", "(", "obj", ")", "\n", "# Let the base class default method raise the TypeError", "\n", "", "return", "json", ".", "JSONEncoder", ".", "default", "(", "self", ",", "obj", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_sampler": [[55, 102], ["isinstance", "isinstance", "numpy.array", "torch.utils.data.WeightedRandomSampler", "numpy.array", "torch.utils.data.WeightedRandomSampler", "numpy.array", "numpy.array", "torch.from_numpy", "samples_weight.double.double", "torch.utils.data.WeightedRandomSampler", "ValueError", "len", "len", "len", "ValueError", "len", "len", "len", "numpy.unique", "numpy.where"], "function", ["None"], ["", "", "def", "create_sampler", "(", "weights", ",", "y_train", ")", ":", "\n", "    ", "\"\"\"\n    This creates a sampler from the given weights\n\n    Parameters\n    ----------\n    weights : either 0, 1, dict or iterable\n        if 0 (default) : no weights will be applied\n        if 1 : classification only, will balanced class with inverse frequency\n        if dict : keys are corresponding class values are sample weights\n        if iterable : list or np array must be of length equal to nb elements\n                      in the training set\n    y_train : np.array\n        Training targets\n    \"\"\"", "\n", "if", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "        ", "if", "weights", "==", "0", ":", "\n", "            ", "need_shuffle", "=", "True", "\n", "sampler", "=", "None", "\n", "", "elif", "weights", "==", "1", ":", "\n", "            ", "need_shuffle", "=", "False", "\n", "class_sample_count", "=", "np", ".", "array", "(", "\n", "[", "len", "(", "np", ".", "where", "(", "y_train", "==", "t", ")", "[", "0", "]", ")", "for", "t", "in", "np", ".", "unique", "(", "y_train", ")", "]", "\n", ")", "\n", "\n", "weights", "=", "1.0", "/", "class_sample_count", "\n", "\n", "samples_weight", "=", "np", ".", "array", "(", "[", "weights", "[", "t", "]", "for", "t", "in", "y_train", "]", ")", "\n", "\n", "samples_weight", "=", "torch", ".", "from_numpy", "(", "samples_weight", ")", "\n", "samples_weight", "=", "samples_weight", ".", "double", "(", ")", "\n", "sampler", "=", "WeightedRandomSampler", "(", "samples_weight", ",", "len", "(", "samples_weight", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Weights should be either 0, 1, dictionnary or list.\"", ")", "\n", "", "", "elif", "isinstance", "(", "weights", ",", "dict", ")", ":", "\n", "# custom weights per class", "\n", "        ", "need_shuffle", "=", "False", "\n", "samples_weight", "=", "np", ".", "array", "(", "[", "weights", "[", "t", "]", "for", "t", "in", "y_train", "]", ")", "\n", "sampler", "=", "WeightedRandomSampler", "(", "samples_weight", ",", "len", "(", "samples_weight", ")", ")", "\n", "", "else", ":", "\n", "# custom weights", "\n", "        ", "if", "len", "(", "weights", ")", "!=", "len", "(", "y_train", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Custom weights should match number of train samples.\"", ")", "\n", "", "need_shuffle", "=", "False", "\n", "samples_weight", "=", "np", ".", "array", "(", "weights", ")", "\n", "sampler", "=", "WeightedRandomSampler", "(", "samples_weight", ",", "len", "(", "samples_weight", ")", ")", "\n", "", "return", "need_shuffle", ",", "sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_dataloaders": [[104, 166], ["utils.create_sampler", "torch.utils.data.DataLoader", "utils.TorchDataset", "valid_dataloaders.append", "X_train.astype", "torch.utils.data.DataLoader", "utils.TorchDataset", "X.astype"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_sampler", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "create_dataloaders", "(", "\n", "X_train", ",", "y_train", ",", "eval_set", ",", "weights", ",", "batch_size", ",", "num_workers", ",", "drop_last", ",", "pin_memory", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Create dataloaders with or without subsampling depending on weights and balanced.\n\n    Parameters\n    ----------\n    X_train : np.ndarray\n        Training data\n    y_train : np.array\n        Mapped Training targets\n    eval_set : list of tuple\n        List of eval tuple set (X, y)\n    weights : either 0, 1, dict or iterable\n        if 0 (default) : no weights will be applied\n        if 1 : classification only, will balanced class with inverse frequency\n        if dict : keys are corresponding class values are sample weights\n        if iterable : list or np array must be of length equal to nb elements\n                      in the training set\n    batch_size : int\n        how many samples per batch to load\n    num_workers : int\n        how many subprocesses to use for data loading. 0 means that the data\n        will be loaded in the main process\n    drop_last : bool\n        set to True to drop the last incomplete batch, if the dataset size is not\n        divisible by the batch size. If False and the size of dataset is not\n        divisible by the batch size, then the last batch will be smaller\n    pin_memory : bool\n        Whether to pin GPU memory during training\n\n    Returns\n    -------\n    train_dataloader, valid_dataloader : torch.DataLoader, torch.DataLoader\n        Training and validation dataloaders\n    \"\"\"", "\n", "need_shuffle", ",", "sampler", "=", "create_sampler", "(", "weights", ",", "y_train", ")", "\n", "\n", "train_dataloader", "=", "DataLoader", "(", "\n", "TorchDataset", "(", "X_train", ".", "astype", "(", "np", ".", "float32", ")", ",", "y_train", ")", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "sampler", "=", "sampler", ",", "\n", "shuffle", "=", "need_shuffle", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "drop_last", "=", "drop_last", ",", "\n", "pin_memory", "=", "pin_memory", ",", "\n", ")", "\n", "\n", "valid_dataloaders", "=", "[", "]", "\n", "for", "X", ",", "y", "in", "eval_set", ":", "\n", "        ", "valid_dataloaders", ".", "append", "(", "\n", "DataLoader", "(", "\n", "TorchDataset", "(", "X", ".", "astype", "(", "np", ".", "float32", ")", ",", "y", ")", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "pin_memory", "=", "pin_memory", ",", "\n", ")", "\n", ")", "\n", "\n", "", "return", "train_dataloader", ",", "valid_dataloaders", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_explain_matrix": [[168, 215], ["isinstance", "range", "numpy.zeros", "enumerate", "scipy.sparse.csc_matrix", "len", "indices_trick.append", "indices_trick.append", "range"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "create_explain_matrix", "(", "input_dim", ",", "cat_emb_dim", ",", "cat_idxs", ",", "post_embed_dim", ")", ":", "\n", "    ", "\"\"\"\n    This is a computational trick.\n    In order to rapidly sum importances from same embeddings\n    to the initial index.\n\n    Parameters\n    ----------\n    input_dim : int\n        Initial input dim\n    cat_emb_dim : int or list of int\n        if int : size of embedding for all categorical feature\n        if list of int : size of embedding for each categorical feature\n    cat_idxs : list of int\n        Initial position of categorical features\n    post_embed_dim : int\n        Post embedding inputs dimension\n\n    Returns\n    -------\n    reducing_matrix : np.array\n        Matrix of dim (post_embed_dim, input_dim)  to performe reduce\n    \"\"\"", "\n", "\n", "if", "isinstance", "(", "cat_emb_dim", ",", "int", ")", ":", "\n", "        ", "all_emb_impact", "=", "[", "cat_emb_dim", "-", "1", "]", "*", "len", "(", "cat_idxs", ")", "\n", "", "else", ":", "\n", "        ", "all_emb_impact", "=", "[", "emb_dim", "-", "1", "for", "emb_dim", "in", "cat_emb_dim", "]", "\n", "\n", "", "acc_emb", "=", "0", "\n", "nb_emb", "=", "0", "\n", "indices_trick", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "input_dim", ")", ":", "\n", "        ", "if", "i", "not", "in", "cat_idxs", ":", "\n", "            ", "indices_trick", ".", "append", "(", "[", "i", "+", "acc_emb", "]", ")", "\n", "", "else", ":", "\n", "            ", "indices_trick", ".", "append", "(", "\n", "range", "(", "i", "+", "acc_emb", ",", "i", "+", "acc_emb", "+", "all_emb_impact", "[", "nb_emb", "]", "+", "1", ")", "\n", ")", "\n", "acc_emb", "+=", "all_emb_impact", "[", "nb_emb", "]", "\n", "nb_emb", "+=", "1", "\n", "\n", "", "", "reducing_matrix", "=", "np", ".", "zeros", "(", "(", "post_embed_dim", ",", "input_dim", ")", ")", "\n", "for", "i", ",", "cols", "in", "enumerate", "(", "indices_trick", ")", ":", "\n", "        ", "reducing_matrix", "[", "cols", ",", "i", "]", "=", "1", "\n", "\n", "", "return", "scipy", ".", "sparse", ".", "csc_matrix", "(", "reducing_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.filter_weights": [[217, 239], ["isinstance", "isinstance", "ValueError", "ValueError"], "function", ["None"], ["", "def", "filter_weights", "(", "weights", ")", ":", "\n", "    ", "\"\"\"\n    This function makes sure that weights are in correct format for\n    regression and multitask TabNet\n\n    Parameters\n    ----------\n    weights : int, dict or list\n        Initial weights parameters given by user\n\n    Returns\n    -------\n    None : This function will only throw an error if format is wrong\n    \"\"\"", "\n", "err_msg", "=", "\"\"\"Please provide a list or np.array of weights for \"\"\"", "\n", "err_msg", "+=", "\"\"\"regression, multitask or pretraining: \"\"\"", "\n", "if", "isinstance", "(", "weights", ",", "int", ")", ":", "\n", "        ", "if", "weights", "==", "1", ":", "\n", "            ", "raise", "ValueError", "(", "err_msg", "+", "\"1 given.\"", ")", "\n", "", "", "if", "isinstance", "(", "weights", ",", "dict", ")", ":", "\n", "        ", "raise", "ValueError", "(", "err_msg", "+", "\"Dict given.\"", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.validate_eval_set": [[241, 306], ["zip", "len", "len", "len", "all", "sklearn.utils.check_array", "len", "len", "len", "len", "len", "range", "len", "len"], "function", ["None"], ["", "def", "validate_eval_set", "(", "eval_set", ",", "eval_name", ",", "X_train", ",", "y_train", ")", ":", "\n", "    ", "\"\"\"Check if the shapes of eval_set are compatible with (X_train, y_train).\n\n    Parameters\n    ----------\n    eval_set : list of tuple\n        List of eval tuple set (X, y).\n        The last one is used for early stopping\n    eval_name : list of str\n        List of eval set names.\n    X_train : np.ndarray\n        Train owned products\n    y_train : np.array\n        Train targeted products\n\n    Returns\n    -------\n    eval_names : list of str\n        Validated list of eval_names.\n    eval_set : list of tuple\n        Validated list of eval_set.\n\n    \"\"\"", "\n", "eval_name", "=", "eval_name", "or", "[", "f\"val_{i}\"", "for", "i", "in", "range", "(", "len", "(", "eval_set", ")", ")", "]", "\n", "\n", "assert", "len", "(", "eval_set", ")", "==", "len", "(", "\n", "eval_name", "\n", ")", ",", "\"eval_set and eval_name have not the same length\"", "\n", "if", "len", "(", "eval_set", ")", ">", "0", ":", "\n", "        ", "assert", "all", "(", "\n", "len", "(", "elem", ")", "==", "2", "for", "elem", "in", "eval_set", "\n", ")", ",", "\"Each tuple of eval_set need to have two elements\"", "\n", "", "for", "name", ",", "(", "X", ",", "y", ")", "in", "zip", "(", "eval_name", ",", "eval_set", ")", ":", "\n", "        ", "check_array", "(", "X", ")", "\n", "msg", "=", "(", "\n", "f\"Dimension mismatch between X_{name} \"", "\n", "+", "f\"{X.shape} and X_train {X_train.shape}\"", "\n", ")", "\n", "assert", "len", "(", "X", ".", "shape", ")", "==", "len", "(", "X_train", ".", "shape", ")", ",", "msg", "\n", "\n", "msg", "=", "(", "\n", "f\"Dimension mismatch between y_{name} \"", "\n", "+", "f\"{y.shape} and y_train {y_train.shape}\"", "\n", ")", "\n", "assert", "len", "(", "y", ".", "shape", ")", "==", "len", "(", "y_train", ".", "shape", ")", ",", "msg", "\n", "\n", "msg", "=", "(", "\n", "f\"Number of columns is different between X_{name} \"", "\n", "+", "f\"({X.shape[1]}) and X_train ({X_train.shape[1]})\"", "\n", ")", "\n", "assert", "X", ".", "shape", "[", "1", "]", "==", "X_train", ".", "shape", "[", "1", "]", ",", "msg", "\n", "\n", "if", "len", "(", "y_train", ".", "shape", ")", "==", "2", ":", "\n", "            ", "msg", "=", "(", "\n", "f\"Number of columns is different between y_{name} \"", "\n", "+", "f\"({y.shape[1]}) and y_train ({y_train.shape[1]})\"", "\n", ")", "\n", "assert", "y", ".", "shape", "[", "1", "]", "==", "y_train", ".", "shape", "[", "1", "]", ",", "msg", "\n", "", "msg", "=", "(", "\n", "f\"You need the same number of rows between X_{name} \"", "\n", "+", "f\"({X.shape[0]}) and y_{name} ({y.shape[0]})\"", "\n", ")", "\n", "assert", "X", ".", "shape", "[", "0", "]", "==", "y", ".", "shape", "[", "0", "]", ",", "msg", "\n", "\n", "", "return", "eval_name", ",", "eval_set", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.define_device": [[308, 332], ["torch.cuda.is_available", "torch.cuda.is_available"], "function", ["None"], ["", "def", "define_device", "(", "device_name", ")", ":", "\n", "    ", "\"\"\"\n    Define the device to use during training and inference.\n    If auto it will detect automatically whether to use cuda or cpu\n\n    Parameters\n    ----------\n    device_name : str\n        Either \"auto\", \"cpu\" or \"cuda\"\n\n    Returns\n    -------\n    str\n        Either \"cpu\" or \"cuda\"\n    \"\"\"", "\n", "if", "device_name", "==", "\"auto\"", ":", "\n", "        ", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "            ", "return", "\"cuda\"", "\n", "", "else", ":", "\n", "            ", "return", "\"cpu\"", "\n", "", "", "elif", "device_name", "==", "\"cuda\"", "and", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "        ", "return", "\"cpu\"", "\n", "", "else", ":", "\n", "        ", "return", "device_name", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__post_init__": [[65, 73], ["torch.manual_seed", "torch.device", "CLCNet.utils.define_device", "print"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.define_device"], ["def", "__post_init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "batch_size", "=", "1024", "\n", "self", ".", "virtual_batch_size", "=", "128", "\n", "torch", ".", "manual_seed", "(", "self", ".", "seed", ")", "\n", "# Defining device", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "define_device", "(", "self", ".", "device_name", ")", ")", "\n", "if", "self", ".", "verbose", "!=", "0", ":", "\n", "            ", "print", "(", "f\"Device used : {self.device}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__update__": [[74, 102], ["kwargs.items", "exec", "warnings.warn", "exec", "exec"], "methods", ["None"], ["", "", "def", "__update__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Updates parameters.\n        If does not already exists, creates it.\n        Otherwise overwrite with warnings.\n        \"\"\"", "\n", "update_list", "=", "[", "\n", "\"cat_dims\"", ",", "\n", "\"cat_emb_dim\"", ",", "\n", "\"cat_idxs\"", ",", "\n", "\"input_dim\"", ",", "\n", "\"mask_type\"", ",", "\n", "\"n_a\"", ",", "\n", "\"n_d\"", ",", "\n", "\"n_independent\"", ",", "\n", "\"n_shared\"", ",", "\n", "\"n_steps\"", ",", "\n", "]", "\n", "for", "var_name", ",", "value", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "var_name", "in", "update_list", ":", "\n", "                ", "try", ":", "\n", "                    ", "exec", "(", "f\"global previous_val; previous_val = self.{var_name}\"", ")", "\n", "if", "previous_val", "!=", "value", ":", "# noqa", "\n", "                        ", "wrn_msg", "=", "f\"Pretraining: {var_name} changed from {previous_val} to {value}\"", "# noqa", "\n", "warnings", ".", "warn", "(", "wrn_msg", ")", "\n", "exec", "(", "f\"self.{var_name} = value\"", ")", "\n", "", "", "except", "AttributeError", ":", "\n", "                    ", "exec", "(", "f\"self.{var_name} = value\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.fit": [[103, 247], ["sklearn.utils.check_array", "abstract_model.TabModel.update_fit_params", "CLCNet.utils.validate_eval_set", "abstract_model.TabModel._construct_loaders", "abstract_model.TabModel._update_network_params", "abstract_model.TabModel._set_metrics", "abstract_model.TabModel._set_optimizer", "abstract_model.TabModel._set_callbacks", "abstract_model.TabModel._callback_container.on_train_begin", "range", "abstract_model.TabModel._callback_container.on_train_end", "abstract_model.TabModel.network.eval", "abstract_model.TabModel._compute_feature_importances", "abstract_model.TabModel.__update__", "hasattr", "abstract_model.TabModel._set_network", "print", "abstract_model.TabModel.load_weights_from_unsupervised", "abstract_model.TabModel._callback_container.on_epoch_begin", "abstract_model.TabModel._train_epoch", "zip", "abstract_model.TabModel._callback_container.on_epoch_end", "abstract_model.TabModel._predict_epoch", "from_unsupervised.get_params"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.update_fit_params", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.validate_eval_set", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._construct_loaders", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._update_network_params", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_metrics", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_optimizer", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_callbacks", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_train_begin", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.EarlyStopping.on_train_end", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._compute_feature_importances", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.__update__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_network", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.load_weights_from_unsupervised", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.History.on_epoch_begin", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._train_epoch", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_epoch_end", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._predict_epoch"], ["", "", "", "", "def", "fit", "(", "\n", "self", ",", "\n", "X_train", ",", "\n", "y_train", ",", "\n", "eval_set", "=", "None", ",", "\n", "eval_name", "=", "None", ",", "\n", "eval_metric", "=", "None", ",", "\n", "loss_fn", "=", "None", ",", "\n", "weights", "=", "0", ",", "\n", "max_epochs", "=", "100", ",", "\n", "patience", "=", "10", ",", "\n", "batch_size", "=", "1024", ",", "\n", "virtual_batch_size", "=", "128", ",", "\n", "num_workers", "=", "0", ",", "\n", "drop_last", "=", "False", ",", "\n", "callbacks", "=", "None", ",", "\n", "pin_memory", "=", "True", ",", "\n", "from_unsupervised", "=", "None", ",", "\n", "mapping_dim", "=", "100", "\n", ")", ":", "\n", "        ", "\"\"\"Train a neural network stored in self.network\n        Using train_dataloader for training data and\n        valid_dataloader for validation.\n\n        Parameters\n        ----------\n        X_train : np.ndarray\n            Train set\n        y_train : np.array\n            Train targets\n        eval_set : list of tuple\n            List of eval tuple set (X, y).\n            The last one is used for early stopping\n        eval_name : list of str\n            List of eval set names.\n        eval_metric : list of str\n            List of evaluation metrics.\n            The last metric is used for early stopping.\n        loss_fn : callable or None\n            a PyTorch loss function\n        weights : bool or dictionnary\n            0 for no balancing\n            1 for automated balancing\n            dict for custom weights per class\n        max_epochs : int\n            Maximum number of epochs during training\n        patience : int\n            Number of consecutive non improving epoch before early stopping\n        batch_size : int\n            Training batch size\n        virtual_batch_size : int\n            Batch size for Ghost Batch Normalization (virtual_batch_size < batch_size)\n        num_workers : int\n            Number of workers used in torch.utils.data.DataLoader\n        drop_last : bool\n            Whether to drop last batch during training\n        callbacks : list of callback function\n            List of custom callbacks\n        pin_memory: bool\n            Whether to set pin_memory to True or False during training\n        from_unsupervised: unsupervised trained model\n            Use a previously self supervised model as starting weights\n        mapping_dim : number of dim for input mapping to\n        \"\"\"", "\n", "# update model name", "\n", "\n", "self", ".", "max_epochs", "=", "max_epochs", "\n", "self", ".", "patience", "=", "patience", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "virtual_batch_size", "=", "virtual_batch_size", "\n", "self", ".", "num_workers", "=", "num_workers", "\n", "self", ".", "drop_last", "=", "drop_last", "\n", "self", ".", "input_dim", "=", "X_train", ".", "shape", "[", "1", "]", "\n", "self", ".", "_stop_training", "=", "False", "\n", "self", ".", "pin_memory", "=", "pin_memory", "and", "(", "self", ".", "device", ".", "type", "!=", "\"cpu\"", ")", "\n", "self", ".", "mapping_dim", "=", "mapping_dim", "\n", "\n", "eval_set", "=", "eval_set", "if", "eval_set", "else", "[", "]", "\n", "\n", "if", "loss_fn", "is", "None", ":", "\n", "            ", "self", ".", "loss_fn", "=", "self", ".", "_default_loss", "\n", "", "else", ":", "\n", "            ", "self", ".", "loss_fn", "=", "loss_fn", "\n", "\n", "", "check_array", "(", "X_train", ")", "\n", "\n", "self", ".", "update_fit_params", "(", "\n", "X_train", ",", "\n", "y_train", ",", "\n", "eval_set", ",", "\n", "weights", ",", "\n", ")", "\n", "\n", "# Validate and reformat eval set depending on training data", "\n", "eval_names", ",", "eval_set", "=", "validate_eval_set", "(", "eval_set", ",", "eval_name", ",", "X_train", ",", "y_train", ")", "\n", "\n", "train_dataloader", ",", "valid_dataloaders", "=", "self", ".", "_construct_loaders", "(", "\n", "X_train", ",", "y_train", ",", "eval_set", "\n", ")", "\n", "\n", "if", "from_unsupervised", "is", "not", "None", ":", "\n", "# Update parameters to match self pretraining", "\n", "            ", "self", ".", "__update__", "(", "**", "from_unsupervised", ".", "get_params", "(", ")", ")", "\n", "\n", "", "if", "not", "hasattr", "(", "self", ",", "\"network\"", ")", ":", "\n", "            ", "self", ".", "_set_network", "(", ")", "\n", "", "self", ".", "_update_network_params", "(", ")", "\n", "self", ".", "_set_metrics", "(", "eval_metric", ",", "eval_names", ")", "\n", "self", ".", "_set_optimizer", "(", ")", "\n", "self", ".", "_set_callbacks", "(", "callbacks", ")", "\n", "\n", "if", "from_unsupervised", "is", "not", "None", ":", "\n", "            ", "print", "(", "\"Loading weights from unsupervised pretraining\"", ")", "\n", "self", ".", "load_weights_from_unsupervised", "(", "from_unsupervised", ")", "\n", "\n", "# Call method on_train_begin for all callbacks", "\n", "", "self", ".", "_callback_container", ".", "on_train_begin", "(", ")", "\n", "\n", "# Training loop over epochs", "\n", "for", "epoch_idx", "in", "range", "(", "self", ".", "max_epochs", ")", ":", "\n", "\n", "# Call method on_epoch_begin for all callbacks", "\n", "            ", "self", ".", "_callback_container", ".", "on_epoch_begin", "(", "epoch_idx", ")", "\n", "\n", "self", ".", "_train_epoch", "(", "train_dataloader", ")", "\n", "\n", "# Apply predict epoch to all eval sets", "\n", "for", "eval_name", ",", "valid_dataloader", "in", "zip", "(", "eval_names", ",", "valid_dataloaders", ")", ":", "\n", "                ", "self", ".", "_predict_epoch", "(", "eval_name", ",", "valid_dataloader", ")", "\n", "\n", "# Call method on_epoch_end for all callbacks", "\n", "", "self", ".", "_callback_container", ".", "on_epoch_end", "(", "\n", "epoch_idx", ",", "logs", "=", "self", ".", "history", ".", "epoch_metrics", "\n", ")", "\n", "\n", "if", "self", ".", "_stop_training", ":", "\n", "                ", "break", "\n", "\n", "# Call method on_train_end for all callbacks", "\n", "", "", "self", ".", "_callback_container", ".", "on_train_end", "(", ")", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n", "# compute feature importance once the best model is defined", "\n", "self", ".", "_compute_feature_importances", "(", "train_dataloader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.predict": [[248, 277], ["abstract_model.TabModel.network.eval", "torch.utils.data.DataLoader", "enumerate", "numpy.vstack", "abstract_model.TabModel.predict_func", "CLCNet.utils.PredictDataset", "data.to().float.to().float.to().float", "abstract_model.TabModel.network", "output.cpu().detach().numpy", "results.append", "data.to().float.to().float.to", "output.cpu().detach", "output.cpu"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.predict_func", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Make predictions on a batch (valid)\n\n        Parameters\n        ----------\n        X : a :tensor: `torch.Tensor`\n            Input data\n\n        Returns\n        -------\n        predictions : np.array\n            Predictions of the regression problem\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "results", "=", "[", "]", "\n", "for", "batch_nb", ",", "data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "output", ",", "M_loss", "=", "self", ".", "network", "(", "data", ")", "\n", "predictions", "=", "output", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "results", ".", "append", "(", "predictions", ")", "\n", "", "res", "=", "np", ".", "vstack", "(", "results", ")", "\n", "return", "self", ".", "predict_func", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.explain": [[278, 326], ["abstract_model.TabModel.network.eval", "torch.utils.data.DataLoader", "enumerate", "numpy.vstack", "CLCNet.utils.PredictDataset", "data.to().float.to().float.to().float", "abstract_model.TabModel.network.forward_masks", "masks.items", "numpy.vstack.append", "scipy.sparse.csc_matrix.dot", "scipy.sparse.csc_matrix.dot", "masks.items", "data.to().float.to().float.to", "value.cpu().detach().numpy", "M_explain.cpu().detach().numpy", "numpy.vstack", "value.cpu().detach", "M_explain.cpu().detach", "value.cpu", "M_explain.cpu"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward_masks", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "explain", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Return local explanation\n\n        Parameters\n        ----------\n        X : tensor: `torch.Tensor`\n            Input data\n\n        Returns\n        -------\n        M_explain : matrix\n            Importance per sample, per columns.\n        masks : matrix\n            Sparse matrix showing attention masks used by network.\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n", "dataloader", "=", "DataLoader", "(", "\n", "PredictDataset", "(", "X", ")", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "\n", "res_explain", "=", "[", "]", "\n", "\n", "for", "batch_nb", ",", "data", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "\n", "M_explain", ",", "masks", "=", "self", ".", "network", ".", "forward_masks", "(", "data", ")", "\n", "for", "key", ",", "value", "in", "masks", ".", "items", "(", ")", ":", "\n", "                ", "masks", "[", "key", "]", "=", "csc_matrix", ".", "dot", "(", "\n", "value", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "reducing_matrix", "\n", ")", "\n", "\n", "", "res_explain", ".", "append", "(", "\n", "csc_matrix", ".", "dot", "(", "M_explain", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "self", ".", "reducing_matrix", ")", "\n", ")", "\n", "\n", "if", "batch_nb", "==", "0", ":", "\n", "                ", "res_masks", "=", "masks", "\n", "", "else", ":", "\n", "                ", "for", "key", ",", "value", "in", "masks", ".", "items", "(", ")", ":", "\n", "                    ", "res_masks", "[", "key", "]", "=", "np", ".", "vstack", "(", "[", "res_masks", "[", "key", "]", ",", "value", "]", ")", "\n", "\n", "", "", "", "res_explain", "=", "np", ".", "vstack", "(", "res_explain", ")", "\n", "\n", "return", "res_explain", ",", "res_masks", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.load_weights_from_unsupervised": [[327, 340], ["copy.deepcopy", "unsupervised_model.network.state_dict().items", "abstract_model.TabModel.network.load_state_dict", "abstract_model.TabModel.network.state_dict", "param.startswith", "unsupervised_model.network.state_dict", "abstract_model.TabModel.network.state_dict().get", "abstract_model.TabModel.network.state_dict"], "methods", ["None"], ["", "def", "load_weights_from_unsupervised", "(", "self", ",", "unsupervised_model", ")", ":", "\n", "        ", "update_state_dict", "=", "copy", ".", "deepcopy", "(", "self", ".", "network", ".", "state_dict", "(", ")", ")", "\n", "for", "param", ",", "weights", "in", "unsupervised_model", ".", "network", ".", "state_dict", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "param", ".", "startswith", "(", "\"encoder\"", ")", ":", "\n", "# Convert encoder's layers name to match", "\n", "                ", "new_param", "=", "\"tabnet.\"", "+", "param", "\n", "", "else", ":", "\n", "                ", "new_param", "=", "param", "\n", "", "if", "self", ".", "network", ".", "state_dict", "(", ")", ".", "get", "(", "new_param", ")", "is", "not", "None", ":", "\n", "# update only common layers", "\n", "                ", "update_state_dict", "[", "new_param", "]", "=", "weights", "\n", "\n", "", "", "self", ".", "network", ".", "load_state_dict", "(", "update_state_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.load_class_attrs": [[341, 344], ["class_attrs.items", "setattr"], "methods", ["None"], ["", "def", "load_class_attrs", "(", "self", ",", "class_attrs", ")", ":", "\n", "        ", "for", "attr_name", ",", "attr_value", "in", "class_attrs", ".", "items", "(", ")", ":", "\n", "            ", "setattr", "(", "self", ",", "attr_name", ",", "attr_value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.save_model": [[345, 387], ["abstract_model.TabModel.get_params().items", "pathlib.Path().mkdir", "torch.save", "shutil.make_archive", "shutil.rmtree", "print", "isinstance", "open", "json.dump", "abstract_model.TabModel.network.state_dict", "pathlib.Path().joinpath", "abstract_model.TabModel.get_params", "pathlib.Path", "pathlib.Path().joinpath", "pathlib.Path", "pathlib.Path"], "methods", ["None"], ["", "", "def", "save_model", "(", "self", ",", "path", ")", ":", "\n", "        ", "\"\"\"Saving TabNet model in two distinct files.\n\n        Parameters\n        ----------\n        path : str\n            Path of the model.\n\n        Returns\n        -------\n        str\n            input filepath with \".zip\" appended\n\n        \"\"\"", "\n", "saved_params", "=", "{", "}", "\n", "init_params", "=", "{", "}", "\n", "for", "key", ",", "val", "in", "self", ".", "get_params", "(", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "val", ",", "type", ")", ":", "\n", "# Don't save torch specific params", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "init_params", "[", "key", "]", "=", "val", "\n", "", "", "saved_params", "[", "\"init_params\"", "]", "=", "init_params", "\n", "\n", "class_attrs", "=", "{", "\n", "\"preds_mapper\"", ":", "self", ".", "preds_mapper", "\n", "}", "\n", "saved_params", "[", "\"class_attrs\"", "]", "=", "class_attrs", "\n", "\n", "# Create folder", "\n", "Path", "(", "path", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "# Save models params", "\n", "with", "open", "(", "Path", "(", "path", ")", ".", "joinpath", "(", "\"model_params.json\"", ")", ",", "\"w\"", ",", "encoding", "=", "\"utf8\"", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "saved_params", ",", "f", ",", "cls", "=", "ComplexEncoder", ")", "\n", "\n", "# Save state_dict", "\n", "", "torch", ".", "save", "(", "self", ".", "network", ".", "state_dict", "(", ")", ",", "Path", "(", "path", ")", ".", "joinpath", "(", "\"network.pt\"", ")", ")", "\n", "shutil", ".", "make_archive", "(", "path", ",", "\"zip\"", ",", "path", ")", "\n", "shutil", ".", "rmtree", "(", "path", ")", "\n", "print", "(", "f\"Successfully saved model at {path}.zip\"", ")", "\n", "return", "f\"{path}.zip\"", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.load_model": [[388, 423], ["abstract_model.TabModel.__init__", "abstract_model.TabModel._set_network", "abstract_model.TabModel.network.load_state_dict", "abstract_model.TabModel.network.eval", "abstract_model.TabModel.load_class_attrs", "zipfile.ZipFile", "KeyError", "z.open", "json.load", "z.open", "torch.load", "torch.load", "io.BytesIO", "f.read"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_network", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.load_class_attrs"], ["", "def", "load_model", "(", "self", ",", "filepath", ")", ":", "\n", "        ", "\"\"\"Load TabNet model.\n\n        Parameters\n        ----------\n        filepath : str\n            Path of the model.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "with", "zipfile", ".", "ZipFile", "(", "filepath", ")", "as", "z", ":", "\n", "                ", "with", "z", ".", "open", "(", "\"model_params.json\"", ")", "as", "f", ":", "\n", "                    ", "loaded_params", "=", "json", ".", "load", "(", "f", ")", "\n", "loaded_params", "[", "\"init_params\"", "]", "[", "\"device_name\"", "]", "=", "self", ".", "device_name", "\n", "", "with", "z", ".", "open", "(", "\"network.pt\"", ")", "as", "f", ":", "\n", "                    ", "try", ":", "\n", "                        ", "saved_state_dict", "=", "torch", ".", "load", "(", "f", ",", "map_location", "=", "self", ".", "device", ")", "\n", "", "except", "io", ".", "UnsupportedOperation", ":", "\n", "# In Python <3.7, the returned file object is not seekable (which at least", "\n", "# some versions of PyTorch require) - so we'll try buffering it in to a", "\n", "# BytesIO instead:", "\n", "                        ", "saved_state_dict", "=", "torch", ".", "load", "(", "\n", "io", ".", "BytesIO", "(", "f", ".", "read", "(", ")", ")", ",", "\n", "map_location", "=", "self", ".", "device", ",", "\n", ")", "\n", "", "", "", "", "except", "KeyError", ":", "\n", "            ", "raise", "KeyError", "(", "\"Your zip file is missing at least one component\"", ")", "\n", "\n", "", "self", ".", "__init__", "(", "**", "loaded_params", "[", "\"init_params\"", "]", ")", "\n", "\n", "self", ".", "_set_network", "(", ")", "\n", "self", ".", "network", ".", "load_state_dict", "(", "saved_state_dict", ")", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "self", ".", "load_class_attrs", "(", "loaded_params", "[", "\"class_attrs\"", "]", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._train_epoch": [[424, 446], ["abstract_model.TabModel.network.train", "enumerate", "abstract_model.TabModel.history.epoch_metrics.update", "abstract_model.TabModel._callback_container.on_batch_begin", "abstract_model.TabModel._train_batch", "abstract_model.TabModel._callback_container.on_batch_end"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.on_batch_begin", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._train_batch", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.LRSchedulerCallback.on_batch_end"], ["", "def", "_train_epoch", "(", "self", ",", "train_loader", ")", ":", "\n", "        ", "\"\"\"\n        Trains one epoch of the network in self.network\n\n        Parameters\n        ----------\n        train_loader : a :class: `torch.utils.data.Dataloader`\n            DataLoader with train set\n        \"\"\"", "\n", "self", ".", "network", ".", "train", "(", ")", "\n", "\n", "for", "batch_idx", ",", "(", "X", ",", "y", ")", "in", "enumerate", "(", "train_loader", ")", ":", "\n", "            ", "self", ".", "_callback_container", ".", "on_batch_begin", "(", "batch_idx", ")", "\n", "\n", "batch_logs", "=", "self", ".", "_train_batch", "(", "X", ",", "y", ")", "\n", "\n", "self", ".", "_callback_container", ".", "on_batch_end", "(", "batch_idx", ",", "batch_logs", ")", "\n", "\n", "", "epoch_logs", "=", "{", "\"lr\"", ":", "self", ".", "_optimizer", ".", "param_groups", "[", "-", "1", "]", "[", "\"lr\"", "]", "}", "\n", "self", ".", "history", ".", "epoch_metrics", ".", "update", "(", "epoch_logs", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._train_batch": [[447, 488], ["X.to().float.to().float.to().float", "y.to().float.to().float.to().float", "abstract_model.TabModel.network.parameters", "abstract_model.TabModel.network", "abstract_model.TabModel.compute_loss", "abstract_model.TabModel.backward", "abstract_model.TabModel._optimizer.step", "abstract_model.TabModel.cpu().detach().numpy().item", "torch.nn.utils.clip_grad_norm_", "X.to().float.to().float.to", "y.to().float.to().float.to", "abstract_model.TabModel.network.parameters", "abstract_model.TabModel.cpu().detach().numpy", "abstract_model.TabModel.cpu().detach", "abstract_model.TabModel.cpu"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.compute_loss", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.sparsemax.Entmoid15.backward"], ["", "def", "_train_batch", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Trains one batch of data\n\n        Parameters\n        ----------\n        X : torch.Tensor\n            Train matrix\n        y : torch.Tensor\n            Target matrix\n\n        Returns\n        -------\n        batch_outs : dict\n            Dictionnary with \"y\": target and \"score\": prediction scores.\n        batch_logs : dict\n            Dictionnary with \"batch_size\" and \"loss\".\n        \"\"\"", "\n", "batch_logs", "=", "{", "\"batch_size\"", ":", "X", ".", "shape", "[", "0", "]", "}", "\n", "\n", "X", "=", "X", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "y", "=", "y", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "\n", "for", "param", "in", "self", ".", "network", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "grad", "=", "None", "\n", "\n", "", "output", ",", "M_loss", "=", "self", ".", "network", "(", "X", ")", "\n", "\n", "loss", "=", "self", ".", "compute_loss", "(", "output", ",", "y", ")", "\n", "# Add the overall sparsity loss", "\n", "loss", "-=", "self", ".", "lambda_sparse", "*", "M_loss", "\n", "\n", "# Perform backward pass and optimization", "\n", "loss", ".", "backward", "(", ")", "\n", "if", "self", ".", "clip_value", ":", "\n", "            ", "clip_grad_norm_", "(", "self", ".", "network", ".", "parameters", "(", ")", ",", "self", ".", "clip_value", ")", "\n", "", "self", ".", "_optimizer", ".", "step", "(", ")", "\n", "\n", "batch_logs", "[", "\"loss\"", "]", "=", "loss", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "\n", "\n", "return", "batch_logs", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._predict_epoch": [[489, 518], ["abstract_model.TabModel.network.eval", "enumerate", "abstract_model.TabModel.stack_batches", "abstract_model.TabModel.network.train", "abstract_model.TabModel.history.epoch_metrics.update", "abstract_model.TabModel._predict_batch", "list_y_true.append", "list_y_score.append"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_model.CLCNet.stack_batches", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._predict_batch", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "_predict_epoch", "(", "self", ",", "name", ",", "loader", ")", ":", "\n", "        ", "\"\"\"\n        Predict an epoch and update metrics.\n\n        Parameters\n        ----------\n        name : str\n            Name of the validation set\n        loader : torch.utils.data.Dataloader\n                DataLoader with validation set\n        \"\"\"", "\n", "# Setting network on evaluation mode", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n", "list_y_true", "=", "[", "]", "\n", "list_y_score", "=", "[", "]", "\n", "\n", "# Main loop", "\n", "for", "batch_idx", ",", "(", "X", ",", "y", ")", "in", "enumerate", "(", "loader", ")", ":", "\n", "            ", "scores", "=", "self", ".", "_predict_batch", "(", "X", ")", "\n", "list_y_true", ".", "append", "(", "y", ")", "\n", "list_y_score", ".", "append", "(", "scores", ")", "\n", "\n", "", "y_true", ",", "scores", "=", "self", ".", "stack_batches", "(", "list_y_true", ",", "list_y_score", ")", "\n", "\n", "metrics_logs", "=", "self", ".", "_metric_container_dict", "[", "name", "]", "(", "y_true", ",", "scores", ")", "\n", "self", ".", "network", ".", "train", "(", ")", "\n", "self", ".", "history", ".", "epoch_metrics", ".", "update", "(", "metrics_logs", ")", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._predict_batch": [[519, 544], ["X.to().float.to().float.to().float", "abstract_model.TabModel.network", "isinstance", "scores.cpu().detach().numpy.cpu().detach().numpy.cpu().detach().numpy", "X.to().float.to().float.to", "x.cpu().detach().numpy", "scores.cpu().detach().numpy.cpu().detach().numpy.cpu().detach", "x.cpu().detach", "scores.cpu().detach().numpy.cpu().detach().numpy.cpu", "x.cpu"], "methods", ["None"], ["", "def", "_predict_batch", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Predict one batch of data.\n\n        Parameters\n        ----------\n        X : torch.Tensor\n            Owned products\n\n        Returns\n        -------\n        np.array\n            model scores\n        \"\"\"", "\n", "X", "=", "X", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "\n", "# compute model output", "\n", "scores", ",", "_", "=", "self", ".", "network", "(", "X", ")", "\n", "\n", "if", "isinstance", "(", "scores", ",", "list", ")", ":", "\n", "            ", "scores", "=", "[", "x", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "for", "x", "in", "scores", "]", "\n", "", "else", ":", "\n", "            ", "scores", "=", "scores", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_network": [[545, 571], ["CLCNet.tab_network.TabNet().to", "CLCNet.utils.create_explain_matrix", "CLCNet.tab_network.TabNet"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_explain_matrix"], ["", "def", "_set_network", "(", "self", ")", ":", "\n", "        ", "\"\"\"Setup the network and explain matrix.\"\"\"", "\n", "self", ".", "network", "=", "tab_network", ".", "TabNet", "(", "\n", "self", ".", "input_dim", ",", "\n", "self", ".", "output_dim", ",", "\n", "n_d", "=", "self", ".", "n_d", ",", "\n", "n_a", "=", "self", ".", "n_a", ",", "\n", "n_steps", "=", "self", ".", "n_steps", ",", "\n", "gamma", "=", "self", ".", "gamma", ",", "\n", "cat_idxs", "=", "self", ".", "cat_idxs", ",", "\n", "cat_dims", "=", "self", ".", "cat_dims", ",", "\n", "cat_emb_dim", "=", "self", ".", "cat_emb_dim", ",", "\n", "n_independent", "=", "self", ".", "n_independent", ",", "\n", "n_shared", "=", "self", ".", "n_shared", ",", "\n", "epsilon", "=", "self", ".", "epsilon", ",", "\n", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", ",", "\n", "momentum", "=", "self", ".", "momentum", ",", "\n", "mask_type", "=", "self", ".", "mask_type", ",", "\n", "mapping_dim", "=", "self", ".", "mapping_dim", ",", "\n", ")", ".", "to", "(", "self", ".", "device", ")", "\n", "\n", "self", ".", "reducing_matrix", "=", "create_explain_matrix", "(", "\n", "self", ".", "mapping_dim", ",", "#self.network.input_dim,", "\n", "self", ".", "network", ".", "cat_emb_dim", ",", "\n", "self", ".", "network", ".", "cat_idxs", ",", "\n", "self", ".", "mapping_dim", ",", "#self.network.post_embed_dim,", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_metrics": [[573, 603], ["CLCNet.metrics.check_metrics", "abstract_model.TabModel._metric_container_dict.items", "abstract_model.TabModel._metric_container_dict.update", "abstract_model.TabModel._metrics.extend", "abstract_model.TabModel._metrics_names.extend", "len", "CLCNet.metrics.MetricContainer"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.metrics.check_metrics"], ["", "def", "_set_metrics", "(", "self", ",", "metrics", ",", "eval_names", ")", ":", "\n", "        ", "\"\"\"Set attributes relative to the metrics.\n\n        Parameters\n        ----------\n        metrics : list of str\n            List of eval metric names.\n        eval_names : list of str\n            List of eval set names.\n\n        \"\"\"", "\n", "metrics", "=", "metrics", "or", "[", "self", ".", "_default_metric", "]", "\n", "\n", "metrics", "=", "check_metrics", "(", "metrics", ")", "\n", "# Set metric container for each sets", "\n", "self", ".", "_metric_container_dict", "=", "{", "}", "\n", "for", "name", "in", "eval_names", ":", "\n", "            ", "self", ".", "_metric_container_dict", ".", "update", "(", "\n", "{", "name", ":", "MetricContainer", "(", "metrics", ",", "prefix", "=", "f\"{name}_\"", ")", "}", "\n", ")", "\n", "\n", "", "self", ".", "_metrics", "=", "[", "]", "\n", "self", ".", "_metrics_names", "=", "[", "]", "\n", "for", "_", ",", "metric_container", "in", "self", ".", "_metric_container_dict", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "_metrics", ".", "extend", "(", "metric_container", ".", "metrics", ")", "\n", "self", ".", "_metrics_names", ".", "extend", "(", "metric_container", ".", "names", ")", "\n", "\n", "# Early stopping metric is the last eval metric", "\n", "", "self", ".", "early_stopping_metric", "=", "(", "\n", "self", ".", "_metrics_names", "[", "-", "1", "]", "if", "len", "(", "self", ".", "_metrics_names", ")", ">", "0", "else", "None", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_callbacks": [[605, 647], ["CLCNet.callbacks.History", "callbacks.append", "CLCNet.callbacks.CallbackContainer", "abstract_model.TabModel._callback_container.set_trainer", "CLCNet.callbacks.EarlyStopping", "callbacks.append", "print", "abstract_model.TabModel.scheduler_params.pop", "CLCNet.callbacks.LRSchedulerCallback", "callbacks.append", "callbacks.extend", "len"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.set_trainer", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.callbacks.CallbackContainer.append"], ["", "def", "_set_callbacks", "(", "self", ",", "custom_callbacks", ")", ":", "\n", "        ", "\"\"\"Setup the callbacks functions.\n\n        Parameters\n        ----------\n        custom_callbacks : list of func\n            List of callback functions.\n\n        \"\"\"", "\n", "# Setup default callbacks history, early stopping and scheduler", "\n", "callbacks", "=", "[", "]", "\n", "self", ".", "history", "=", "History", "(", "self", ",", "verbose", "=", "self", ".", "verbose", ")", "\n", "callbacks", ".", "append", "(", "self", ".", "history", ")", "\n", "if", "(", "self", ".", "early_stopping_metric", "is", "not", "None", ")", "and", "(", "self", ".", "patience", ">", "0", ")", ":", "\n", "            ", "early_stopping", "=", "EarlyStopping", "(", "\n", "early_stopping_metric", "=", "self", ".", "early_stopping_metric", ",", "\n", "is_maximize", "=", "(", "\n", "self", ".", "_metrics", "[", "-", "1", "]", ".", "_maximize", "if", "len", "(", "self", ".", "_metrics", ")", ">", "0", "else", "None", "\n", ")", ",", "\n", "patience", "=", "self", ".", "patience", ",", "\n", ")", "\n", "callbacks", ".", "append", "(", "early_stopping", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\n", "\"No early stopping will be performed, last training weights will be used.\"", "\n", ")", "\n", "", "if", "self", ".", "scheduler_fn", "is", "not", "None", ":", "\n", "# Add LR Scheduler call_back", "\n", "            ", "is_batch_level", "=", "self", ".", "scheduler_params", ".", "pop", "(", "\"is_batch_level\"", ",", "False", ")", "\n", "scheduler", "=", "LRSchedulerCallback", "(", "\n", "scheduler_fn", "=", "self", ".", "scheduler_fn", ",", "\n", "scheduler_params", "=", "self", ".", "scheduler_params", ",", "\n", "optimizer", "=", "self", ".", "_optimizer", ",", "\n", "early_stopping_metric", "=", "self", ".", "early_stopping_metric", ",", "\n", "is_batch_level", "=", "is_batch_level", ",", "\n", ")", "\n", "callbacks", ".", "append", "(", "scheduler", ")", "\n", "\n", "", "if", "custom_callbacks", ":", "\n", "            ", "callbacks", ".", "extend", "(", "custom_callbacks", ")", "\n", "", "self", ".", "_callback_container", "=", "CallbackContainer", "(", "callbacks", ")", "\n", "self", ".", "_callback_container", ".", "set_trainer", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._set_optimizer": [[648, 652], ["abstract_model.TabModel.optimizer_fn", "abstract_model.TabModel.network.parameters"], "methods", ["None"], ["", "def", "_set_optimizer", "(", "self", ")", ":", "\n", "        ", "\"\"\"Setup optimizer.\"\"\"", "\n", "self", ".", "_optimizer", "=", "self", ".", "optimizer_fn", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "**", "self", ".", "optimizer_params", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._construct_loaders": [[654, 691], ["abstract_model.TabModel.prepare_target", "enumerate", "CLCNet.utils.create_dataloaders", "abstract_model.TabModel.prepare_target"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.prepare_target", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.utils.create_dataloaders", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.prepare_target"], ["", "def", "_construct_loaders", "(", "self", ",", "X_train", ",", "y_train", ",", "eval_set", ")", ":", "\n", "        ", "\"\"\"Generate dataloaders for train and eval set.\n\n        Parameters\n        ----------\n        X_train : np.array\n            Train set.\n        y_train : np.array\n            Train targets.\n        eval_set : list of tuple\n            List of eval tuple set (X, y).\n\n        Returns\n        -------\n        train_dataloader : `torch.utils.data.Dataloader`\n            Training dataloader.\n        valid_dataloaders : list of `torch.utils.data.Dataloader`\n            List of validation dataloaders.\n\n        \"\"\"", "\n", "# all weights are not allowed for this type of model", "\n", "y_train_mapped", "=", "self", ".", "prepare_target", "(", "y_train", ")", "\n", "for", "i", ",", "(", "X", ",", "y", ")", "in", "enumerate", "(", "eval_set", ")", ":", "\n", "            ", "y_mapped", "=", "self", ".", "prepare_target", "(", "y", ")", "\n", "eval_set", "[", "i", "]", "=", "(", "X", ",", "y_mapped", ")", "\n", "\n", "", "train_dataloader", ",", "valid_dataloaders", "=", "create_dataloaders", "(", "\n", "X_train", ",", "\n", "y_train_mapped", ",", "\n", "eval_set", ",", "\n", "self", ".", "updated_weights", ",", "\n", "self", ".", "batch_size", ",", "\n", "self", ".", "num_workers", ",", "\n", "self", ".", "drop_last", ",", "\n", "self", ".", "pin_memory", ",", "\n", ")", "\n", "return", "train_dataloader", ",", "valid_dataloaders", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._compute_feature_importances": [[692, 716], ["abstract_model.TabModel.network.eval", "numpy.zeros", "scipy.sparse.csc_matrix.dot", "data.to().float.to().float.to().float", "abstract_model.TabModel.network.forward_masks", "M_explain.sum().cpu().detach().numpy", "numpy.sum", "data.to().float.to().float.to", "M_explain.sum().cpu().detach", "M_explain.sum().cpu", "M_explain.sum"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.tab_network.TabNet.forward_masks"], ["", "def", "_compute_feature_importances", "(", "self", ",", "loader", ")", ":", "\n", "        ", "\"\"\"Compute global feature importance.\n\n        Parameters\n        ----------\n        loader : `torch.utils.data.Dataloader`\n            Pytorch dataloader.\n\n        \"\"\"", "\n", "self", ".", "network", ".", "eval", "(", ")", "\n", "#feature_importances_ = np.zeros((self.network.post_embed_dim))", "\n", "\n", "# any dimension input will be mapped to the mapping_dim dimension", "\n", "feature_importances_", "=", "np", ".", "zeros", "(", "(", "self", ".", "mapping_dim", ")", ")", "\n", "\n", "for", "data", ",", "targets", "in", "loader", ":", "\n", "            ", "data", "=", "data", ".", "to", "(", "self", ".", "device", ")", ".", "float", "(", ")", "\n", "M_explain", ",", "masks", "=", "self", ".", "network", ".", "forward_masks", "(", "data", ")", "\n", "feature_importances_", "+=", "M_explain", ".", "sum", "(", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "feature_importances_", "=", "csc_matrix", ".", "dot", "(", "\n", "feature_importances_", ",", "self", ".", "reducing_matrix", "\n", ")", "\n", "self", ".", "feature_importances_", "=", "feature_importances_", "/", "np", ".", "sum", "(", "feature_importances_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel._update_network_params": [[717, 719], ["None"], "methods", ["None"], ["", "def", "_update_network_params", "(", "self", ")", ":", "\n", "        ", "self", ".", "network", ".", "virtual_batch_size", "=", "self", ".", "virtual_batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.update_fit_params": [[720, 739], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "update_fit_params", "(", "self", ",", "X_train", ",", "y_train", ",", "eval_set", ",", "weights", ")", ":", "\n", "        ", "\"\"\"\n        Set attributes relative to fit function.\n\n        Parameters\n        ----------\n        X_train : np.ndarray\n            Train set\n        y_train : np.array\n            Train targets\n        eval_set : list of tuple\n            List of eval tuple set (X, y).\n        weights : bool or dictionnary\n            0 for no balancing\n            1 for automated balancing\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"users must define update_fit_params to use this base class\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.compute_loss": [[741, 760], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "compute_loss", "(", "self", ",", "y_score", ",", "y_true", ")", ":", "\n", "        ", "\"\"\"\n        Compute the loss.\n\n        Parameters\n        ----------\n        y_score : a :tensor: `torch.Tensor`\n            Score matrix\n        y_true : a :tensor: `torch.Tensor`\n            Target matrix\n\n        Returns\n        -------\n        float\n            Loss value\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"users must define compute_loss to use this base class\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.abstract_model.TabModel.prepare_target": [[762, 779], ["NotImplementedError"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "prepare_target", "(", "self", ",", "y", ")", ":", "\n", "        ", "\"\"\"\n        Prepare target before training.\n\n        Parameters\n        ----------\n        y : a :tensor: `torch.Tensor`\n            Target matrix.\n\n        Returns\n        -------\n        `torch.Tensor`\n            Converted target matrix.\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "\n", "\"users must define prepare_target to use this base class\"", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.PrefetchLoader.__init__": [[70, 98], ["loader.expand_to_chs", "loader.expand_to_chs", "torch.tensor().cuda().view", "torch.tensor().cuda().view", "loader.PrefetchLoader.mean.half", "loader.PrefetchLoader.std.half", "timm.data.random_erasing.RandomErasing", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.expand_to_chs", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.expand_to_chs"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "loader", ",", "\n", "mean", "=", "IMAGENET_DEFAULT_MEAN", ",", "\n", "std", "=", "IMAGENET_DEFAULT_STD", ",", "\n", "channels", "=", "3", ",", "\n", "fp16", "=", "False", ",", "\n", "re_prob", "=", "0.", ",", "\n", "re_mode", "=", "'const'", ",", "\n", "re_count", "=", "1", ",", "\n", "re_num_splits", "=", "0", ")", ":", "\n", "\n", "        ", "mean", "=", "expand_to_chs", "(", "mean", ",", "channels", ")", "\n", "std", "=", "expand_to_chs", "(", "std", ",", "channels", ")", "\n", "normalization_shape", "=", "(", "1", ",", "channels", ",", "1", ",", "1", ")", "\n", "\n", "self", ".", "loader", "=", "loader", "\n", "self", ".", "mean", "=", "torch", ".", "tensor", "(", "[", "x", "*", "255", "for", "x", "in", "mean", "]", ")", ".", "cuda", "(", ")", ".", "view", "(", "normalization_shape", ")", "\n", "self", ".", "std", "=", "torch", ".", "tensor", "(", "[", "x", "*", "255", "for", "x", "in", "std", "]", ")", ".", "cuda", "(", ")", ".", "view", "(", "normalization_shape", ")", "\n", "self", ".", "fp16", "=", "fp16", "\n", "if", "fp16", ":", "\n", "            ", "self", ".", "mean", "=", "self", ".", "mean", ".", "half", "(", ")", "\n", "self", ".", "std", "=", "self", ".", "std", ".", "half", "(", ")", "\n", "", "if", "re_prob", ">", "0.", ":", "\n", "            ", "self", ".", "random_erasing", "=", "RandomErasing", "(", "\n", "probability", "=", "re_prob", ",", "mode", "=", "re_mode", ",", "max_count", "=", "re_count", ",", "num_splits", "=", "re_num_splits", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "random_erasing", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.PrefetchLoader.__iter__": [[99, 124], ["torch.cuda.Stream", "torch.cuda.current_stream().wait_stream", "torch.cuda.stream", "loader.PrefetchLoader.cuda", "next_target.cuda.cuda.cuda", "loader.PrefetchLoader.half().sub_().div_", "loader.PrefetchLoader.float().sub_().div_", "loader.PrefetchLoader.random_erasing", "torch.cuda.current_stream", "loader.PrefetchLoader.half().sub_", "loader.PrefetchLoader.float().sub_", "loader.PrefetchLoader.half", "loader.PrefetchLoader.float"], "methods", ["None"], ["", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "stream", "=", "torch", ".", "cuda", ".", "Stream", "(", ")", "\n", "first", "=", "True", "\n", "\n", "for", "next_input", ",", "next_target", "in", "self", ".", "loader", ":", "\n", "            ", "with", "torch", ".", "cuda", ".", "stream", "(", "stream", ")", ":", "\n", "                ", "next_input", "=", "next_input", ".", "cuda", "(", "non_blocking", "=", "True", ")", "\n", "next_target", "=", "next_target", ".", "cuda", "(", "non_blocking", "=", "True", ")", "\n", "if", "self", ".", "fp16", ":", "\n", "                    ", "next_input", "=", "next_input", ".", "half", "(", ")", ".", "sub_", "(", "self", ".", "mean", ")", ".", "div_", "(", "self", ".", "std", ")", "\n", "", "else", ":", "\n", "                    ", "next_input", "=", "next_input", ".", "float", "(", ")", ".", "sub_", "(", "self", ".", "mean", ")", ".", "div_", "(", "self", ".", "std", ")", "\n", "", "if", "self", ".", "random_erasing", "is", "not", "None", ":", "\n", "                    ", "next_input", "=", "self", ".", "random_erasing", "(", "next_input", ")", "\n", "\n", "", "", "if", "not", "first", ":", "\n", "                ", "yield", "input", ",", "target", "\n", "", "else", ":", "\n", "                ", "first", "=", "False", "\n", "\n", "", "torch", ".", "cuda", ".", "current_stream", "(", ")", ".", "wait_stream", "(", "stream", ")", "\n", "input", "=", "next_input", "\n", "target", "=", "next_target", "\n", "\n", "", "yield", "input", ",", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.PrefetchLoader.__len__": [[125, 127], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "loader", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.PrefetchLoader.sampler": [[128, 131], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "sampler", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loader", ".", "sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.PrefetchLoader.dataset": [[132, 135], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "dataset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "loader", ".", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.PrefetchLoader.mixup_enabled": [[143, 147], ["isinstance"], "methods", ["None"], ["", "", "@", "mixup_enabled", ".", "setter", "\n", "def", "mixup_enabled", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "isinstance", "(", "self", ".", "loader", ".", "collate_fn", ",", "FastCollateMixup", ")", ":", "\n", "            ", "self", ".", "loader", ".", "collate_fn", ".", "mixup_enabled", "=", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.MultiEpochsDataLoader.__init__": [[281, 287], ["super().__init__", "loader._RepeatSampler", "super().__iter__"], "methods", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__", "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__iter__"], ["    ", "def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "self", ".", "_DataLoader__initialized", "=", "False", "\n", "self", ".", "batch_sampler", "=", "_RepeatSampler", "(", "self", ".", "batch_sampler", ")", "\n", "self", ".", "_DataLoader__initialized", "=", "True", "\n", "self", ".", "iterator", "=", "super", "(", ")", ".", "__iter__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.MultiEpochsDataLoader.__len__": [[288, 290], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "batch_sampler", ".", "sampler", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.MultiEpochsDataLoader.__iter__": [[291, 294], ["range", "len", "next"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "yield", "next", "(", "self", ".", "iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__init__": [[303, 305], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sampler", ")", ":", "\n", "        ", "self", ".", "sampler", "=", "sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._RepeatSampler.__iter__": [[306, 309], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "yield", "from", "iter", "(", "self", ".", "sampler", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.fast_collate": [[23, 56], ["isinstance", "len", "isinstance", "len", "torch.zeros", "torch.zeros", "range", "isinstance", "range", "torch.tensor", "torch.zeros", "range", "isinstance", "len", "torch.from_numpy", "len", "torch.from_numpy", "torch.tensor", "torch.zeros", "range", "len", "tensor[].copy_"], "function", ["None"], ["def", "fast_collate", "(", "batch", ")", ":", "\n", "    ", "\"\"\" A fast collation function optimized for uint8 images (np array or torch) and int64 targets (labels)\"\"\"", "\n", "assert", "isinstance", "(", "batch", "[", "0", "]", ",", "tuple", ")", "\n", "batch_size", "=", "len", "(", "batch", ")", "\n", "if", "isinstance", "(", "batch", "[", "0", "]", "[", "0", "]", ",", "tuple", ")", ":", "\n", "# This branch 'deinterleaves' and flattens tuples of input tensors into one tensor ordered by position", "\n", "# such that all tuple of position n will end up in a torch.split(tensor, batch_size) in nth position", "\n", "        ", "inner_tuple_size", "=", "len", "(", "batch", "[", "0", "]", "[", "0", "]", ")", "\n", "flattened_batch_size", "=", "batch_size", "*", "inner_tuple_size", "\n", "targets", "=", "torch", ".", "zeros", "(", "flattened_batch_size", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "tensor", "=", "torch", ".", "zeros", "(", "(", "flattened_batch_size", ",", "*", "batch", "[", "0", "]", "[", "0", "]", "[", "0", "]", ".", "shape", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "assert", "len", "(", "batch", "[", "i", "]", "[", "0", "]", ")", "==", "inner_tuple_size", "# all input tensor tuples must be same length", "\n", "for", "j", "in", "range", "(", "inner_tuple_size", ")", ":", "\n", "                ", "targets", "[", "i", "+", "j", "*", "batch_size", "]", "=", "batch", "[", "i", "]", "[", "1", "]", "\n", "tensor", "[", "i", "+", "j", "*", "batch_size", "]", "+=", "torch", ".", "from_numpy", "(", "batch", "[", "i", "]", "[", "0", "]", "[", "j", "]", ")", "\n", "", "", "return", "tensor", ",", "targets", "\n", "", "elif", "isinstance", "(", "batch", "[", "0", "]", "[", "0", "]", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "targets", "=", "torch", ".", "tensor", "(", "[", "b", "[", "1", "]", "for", "b", "in", "batch", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "assert", "len", "(", "targets", ")", "==", "batch_size", "\n", "tensor", "=", "torch", ".", "zeros", "(", "(", "batch_size", ",", "*", "batch", "[", "0", "]", "[", "0", "]", ".", "shape", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "tensor", "[", "i", "]", "+=", "torch", ".", "from_numpy", "(", "batch", "[", "i", "]", "[", "0", "]", ")", "\n", "", "return", "tensor", ",", "targets", "\n", "", "elif", "isinstance", "(", "batch", "[", "0", "]", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "targets", "=", "torch", ".", "tensor", "(", "[", "b", "[", "1", "]", "for", "b", "in", "batch", "]", ",", "dtype", "=", "torch", ".", "int64", ")", "\n", "assert", "len", "(", "targets", ")", "==", "batch_size", "\n", "tensor", "=", "torch", ".", "zeros", "(", "(", "batch_size", ",", "*", "batch", "[", "0", "]", "[", "0", "]", ".", "shape", ")", ",", "dtype", "=", "torch", ".", "uint8", ")", "\n", "for", "i", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "tensor", "[", "i", "]", ".", "copy_", "(", "batch", "[", "i", "]", "[", "0", "]", ")", "\n", "", "return", "tensor", ",", "targets", "\n", "", "else", ":", "\n", "        ", "assert", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.expand_to_chs": [[58, 66], ["isinstance", "tuple", "itertools.repeat", "len", "len"], "function", ["None"], ["", "", "def", "expand_to_chs", "(", "x", ",", "n", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "x", ",", "(", "tuple", ",", "list", ")", ")", ":", "\n", "        ", "x", "=", "tuple", "(", "repeat", "(", "x", ",", "n", ")", ")", "\n", "", "elif", "len", "(", "x", ")", "==", "1", ":", "\n", "        ", "x", "=", "x", "*", "n", "\n", "", "else", ":", "\n", "        ", "assert", "len", "(", "x", ")", "==", "n", ",", "'normalization stats must match image channels'", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader._worker_init": [[149, 163], ["torch.utils.data.get_worker_info", "isinstance", "worker_seeding", "random.seed", "torch.manual_seed", "numpy.random.seed", "numpy.random.seed"], "function", ["None"], ["", "", "", "def", "_worker_init", "(", "worker_id", ",", "worker_seeding", "=", "'all'", ")", ":", "\n", "    ", "worker_info", "=", "torch", ".", "utils", ".", "data", ".", "get_worker_info", "(", ")", "\n", "assert", "worker_info", ".", "id", "==", "worker_id", "\n", "if", "isinstance", "(", "worker_seeding", ",", "Callable", ")", ":", "\n", "        ", "seed", "=", "worker_seeding", "(", "worker_info", ")", "\n", "random", ".", "seed", "(", "seed", ")", "\n", "torch", ".", "manual_seed", "(", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "seed", "%", "(", "2", "**", "32", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert", "worker_seeding", "in", "(", "'all'", ",", "'part'", ")", "\n", "# random / torch seed already called in dataloader iter class w/ worker_info.seed", "\n", "# to reproduce some old results (same seed + hparam combo), partial seeding is required (skip numpy re-seed)", "\n", "if", "worker_seeding", "==", "'all'", ":", "\n", "            ", "np", ".", "random", ".", "seed", "(", "worker_info", ".", "seed", "%", "(", "2", "**", "32", "-", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.loader.create_loader": [[165, 277], ["transforms_factory.create_transform", "dict", "loader_class", "loader.PrefetchLoader", "isinstance", "timm.data.distributed_sampler.OrderedDistributedSampler", "functools.partial", "dict.pop", "loader_class", "timm.data.distributed_sampler.RepeatAugSampler", "torch.utils.data.distributed.DistributedSampler", "isinstance"], "function", ["home.repos.pwc.inspect_result.yaoching0_clcnet-rethinking-of-ensemble-modeling.CLCNet.transforms_factory.create_transform"], ["", "", "", "def", "create_loader", "(", "\n", "dataset", ",", "\n", "input_size", ",", "\n", "batch_size", ",", "\n", "is_training", "=", "False", ",", "\n", "use_prefetcher", "=", "True", ",", "\n", "no_aug", "=", "False", ",", "\n", "re_prob", "=", "0.", ",", "\n", "re_mode", "=", "'const'", ",", "\n", "re_count", "=", "1", ",", "\n", "re_split", "=", "False", ",", "\n", "scale", "=", "None", ",", "\n", "ratio", "=", "None", ",", "\n", "hflip", "=", "0.5", ",", "\n", "vflip", "=", "0.", ",", "\n", "color_jitter", "=", "0.4", ",", "\n", "auto_augment", "=", "None", ",", "\n", "num_aug_repeats", "=", "0", ",", "\n", "num_aug_splits", "=", "0", ",", "\n", "interpolation", "=", "'bilinear'", ",", "\n", "mean", "=", "IMAGENET_DEFAULT_MEAN", ",", "\n", "std", "=", "IMAGENET_DEFAULT_STD", ",", "\n", "num_workers", "=", "1", ",", "\n", "distributed", "=", "False", ",", "\n", "crop_pct", "=", "None", ",", "\n", "collate_fn", "=", "None", ",", "\n", "pin_memory", "=", "False", ",", "\n", "fp16", "=", "False", ",", "\n", "tf_preprocessing", "=", "False", ",", "\n", "use_multi_epochs_loader", "=", "False", ",", "\n", "persistent_workers", "=", "True", ",", "\n", "worker_seeding", "=", "'all'", ",", "\n", ")", ":", "\n", "    ", "re_num_splits", "=", "0", "\n", "if", "re_split", ":", "\n", "# apply RE to second half of batch if no aug split otherwise line up with aug split", "\n", "        ", "re_num_splits", "=", "num_aug_splits", "or", "2", "\n", "", "dataset", ".", "transform", "=", "create_transform", "(", "\n", "input_size", ",", "\n", "is_training", "=", "is_training", ",", "\n", "use_prefetcher", "=", "use_prefetcher", ",", "\n", "no_aug", "=", "no_aug", ",", "\n", "scale", "=", "scale", ",", "\n", "ratio", "=", "ratio", ",", "\n", "hflip", "=", "hflip", ",", "\n", "vflip", "=", "vflip", ",", "\n", "color_jitter", "=", "color_jitter", ",", "\n", "auto_augment", "=", "auto_augment", ",", "\n", "interpolation", "=", "interpolation", ",", "\n", "mean", "=", "mean", ",", "\n", "std", "=", "std", ",", "\n", "crop_pct", "=", "crop_pct", ",", "\n", "tf_preprocessing", "=", "tf_preprocessing", ",", "\n", "re_prob", "=", "re_prob", ",", "\n", "re_mode", "=", "re_mode", ",", "\n", "re_count", "=", "re_count", ",", "\n", "re_num_splits", "=", "re_num_splits", ",", "\n", "separate", "=", "num_aug_splits", ">", "0", ",", "\n", ")", "\n", "\n", "sampler", "=", "None", "\n", "if", "distributed", "and", "not", "isinstance", "(", "dataset", ",", "torch", ".", "utils", ".", "data", ".", "IterableDataset", ")", ":", "\n", "        ", "if", "is_training", ":", "\n", "            ", "if", "num_aug_repeats", ":", "\n", "                ", "sampler", "=", "RepeatAugSampler", "(", "dataset", ",", "num_repeats", "=", "num_aug_repeats", ")", "\n", "", "else", ":", "\n", "                ", "sampler", "=", "torch", ".", "utils", ".", "data", ".", "distributed", ".", "DistributedSampler", "(", "dataset", ")", "\n", "", "", "else", ":", "\n", "# This will add extra duplicate entries to result in equal num", "\n", "# of samples per-process, will slightly alter validation results", "\n", "            ", "sampler", "=", "OrderedDistributedSampler", "(", "dataset", ")", "\n", "", "", "else", ":", "\n", "        ", "assert", "num_aug_repeats", "==", "0", ",", "\"RepeatAugment not currently supported in non-distributed or IterableDataset use\"", "\n", "\n", "", "if", "collate_fn", "is", "None", ":", "\n", "        ", "collate_fn", "=", "fast_collate", "if", "use_prefetcher", "else", "torch", ".", "utils", ".", "data", ".", "dataloader", ".", "default_collate", "\n", "\n", "", "loader_class", "=", "torch", ".", "utils", ".", "data", ".", "DataLoader", "\n", "if", "use_multi_epochs_loader", ":", "\n", "        ", "loader_class", "=", "MultiEpochsDataLoader", "\n", "\n", "", "loader_args", "=", "dict", "(", "\n", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "not", "isinstance", "(", "dataset", ",", "torch", ".", "utils", ".", "data", ".", "IterableDataset", ")", "and", "sampler", "is", "None", "and", "is_training", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "sampler", "=", "sampler", ",", "\n", "collate_fn", "=", "collate_fn", ",", "\n", "pin_memory", "=", "pin_memory", ",", "\n", "drop_last", "=", "is_training", ",", "\n", "worker_init_fn", "=", "partial", "(", "_worker_init", ",", "worker_seeding", "=", "worker_seeding", ")", ",", "\n", "persistent_workers", "=", "persistent_workers", "\n", ")", "\n", "try", ":", "\n", "        ", "loader", "=", "loader_class", "(", "dataset", ",", "**", "loader_args", ")", "\n", "", "except", "TypeError", "as", "e", ":", "\n", "        ", "loader_args", ".", "pop", "(", "'persistent_workers'", ")", "# only in Pytorch 1.7+", "\n", "loader", "=", "loader_class", "(", "dataset", ",", "**", "loader_args", ")", "\n", "", "if", "use_prefetcher", ":", "\n", "        ", "prefetch_re_prob", "=", "re_prob", "if", "is_training", "and", "not", "no_aug", "else", "0.", "\n", "loader", "=", "PrefetchLoader", "(", "\n", "loader", ",", "\n", "mean", "=", "mean", ",", "\n", "std", "=", "std", ",", "\n", "channels", "=", "input_size", "[", "0", "]", ",", "\n", "fp16", "=", "fp16", ",", "\n", "re_prob", "=", "prefetch_re_prob", ",", "\n", "re_mode", "=", "re_mode", ",", "\n", "re_count", "=", "re_count", ",", "\n", "re_num_splits", "=", "re_num_splits", "\n", ")", "\n", "\n", "", "return", "loader", "\n", "\n"]]}