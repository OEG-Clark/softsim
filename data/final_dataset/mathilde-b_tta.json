{"home.repos.pwc.inspect_result.mathilde-b_tta.None.dice3d.dice3d": [[27, 119], ["torch.unique", "list", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "torch.tensor", "torch.index_select", "torch.index_select.mean", "torch.index_select.std", "dice3d.get_mean_sd", "dice3d.get_mean_sd", "utils.map_", "filter", "u.item", "all_pred.cpu().numpy.cpu().numpy", "all_gt.cpu().numpy.cpu().numpy", "torch.einsum", "torch.einsum", "torch.einsum", "torch.round", "torch.round", "dice_3d.mean.mean", "enumerate", "print", "print", "torch.index_select.item", "dice_3d.std.item", "len", "len", "len", "print", "t.mean", "dice_3d.mean.cpu().numpy", "dice_3d.std.cpu().numpy", "torch.index_select.item", "asd_3d.item", "asd_3d_sd.item", "hd_3d.item", "hd_3d_sd.item", "all_pred.cpu().numpy.cpu", "all_gt.cpu().numpy.cpu", "torch.masked_select().reshape", "torch.masked_select().reshape", "torch.masked_select().reshape", "torch.index_select.cpu", "numpy.argsort", "range", "torch.from_numpy", "torch.from_numpy", "open", "open", "int", "int", "numpy.copy", "numpy.copy", "numpy.copy", "numpy.copy", "numpy.asarray", "numpy.asarray", "dice_3d.mean.cpu", "dice_3d.std.cpu", "torch.masked_select", "torch.masked_select", "torch.masked_select", "re.split", "len", "x.item", "re.split", "re.split", "numpy.unique", "binary.hd95().item", "binary.assd().item", "str", "str", "re.split", "binary.hd95", "binary.assd", "x.item"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.dice3d.get_mean_sd", "home.repos.pwc.inspect_result.mathilde-b_tta.None.dice3d.get_mean_sd", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.hd95", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.assd"], ["def", "dice3d", "(", "all_grp", ",", "all_inter_card", ",", "all_card_gt", ",", "all_card_pred", ",", "all_pred", ",", "all_gt", ",", "all_pnames", ",", "metric_axis", ",", "pprint", "=", "False", ",", "do_hd", "=", "0", ",", "do_asd", "=", "0", ",", "best_epoch_val", "=", "0", ",", "savedir", "=", "0", ")", ":", "\n", "\n", "    ", "unit", "=", "\"mm\"", "\n", "_", ",", "C", "=", "all_card_gt", ".", "shape", "\n", "unique_patients", "=", "torch", ".", "unique", "(", "all_grp", ")", "\n", "list", "(", "filter", "(", "lambda", "a", ":", "a", "!=", "0.0", ",", "unique_patients", ")", ")", "\n", "unique_patients", "=", "[", "u", ".", "item", "(", ")", "for", "u", "in", "unique_patients", "]", "\n", "batch_dice", "=", "torch", ".", "zeros", "(", "(", "len", "(", "unique_patients", ")", ",", "C", ")", ")", "\n", "batch_hd", "=", "torch", ".", "zeros", "(", "(", "len", "(", "unique_patients", ")", ",", "C", ")", ")", "\n", "batch_asd", "=", "torch", ".", "zeros", "(", "(", "len", "(", "unique_patients", ")", ",", "C", ")", ")", "\n", "if", "do_hd", ">", "0", "or", "do_asd", ">", "0", ":", "\n", "        ", "all_pred", "=", "all_pred", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "all_gt", "=", "all_gt", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# do DICE", "\n", "", "for", "i", ",", "p", "in", "enumerate", "(", "unique_patients", ")", ":", "\n", "        ", "inter_card_p", "=", "torch", ".", "einsum", "(", "\"bc->c\"", ",", "[", "torch", ".", "masked_select", "(", "all_inter_card", ",", "all_grp", "==", "p", ")", ".", "reshape", "(", "(", "-", "1", ",", "C", ")", ")", "]", ")", "\n", "card_gt_p", "=", "torch", ".", "einsum", "(", "\"bc->c\"", ",", "[", "torch", ".", "masked_select", "(", "all_card_gt", ",", "all_grp", "==", "p", ")", ".", "reshape", "(", "(", "-", "1", ",", "C", ")", ")", "]", ")", "\n", "card_pred_p", "=", "torch", ".", "einsum", "(", "\"bc->c\"", ",", "[", "torch", ".", "masked_select", "(", "all_card_pred", ",", "all_grp", "==", "p", ")", ".", "reshape", "(", "(", "-", "1", ",", "C", ")", ")", "]", ")", "\n", "dice_3d", "=", "(", "2", "*", "inter_card_p", "+", "1e-8", ")", "/", "(", "(", "card_pred_p", "+", "card_gt_p", ")", "+", "1e-8", ")", "\n", "batch_dice", "[", "i", ",", "...", "]", "=", "dice_3d", "\n", "if", "pprint", ":", "\n", "            ", "print", "(", "p", ",", "dice_3d", ".", "cpu", "(", ")", ",", "file", "=", "open", "(", "savedir", "+", "'/'", "+", "str", "(", "p", ")", "+", "\".txt\"", ",", "\"a\"", ")", ")", "\n", "", "", "indices", "=", "torch", ".", "tensor", "(", "metric_axis", ")", "\n", "dice_3d", "=", "torch", ".", "index_select", "(", "batch_dice", ",", "1", ",", "indices", ")", "\n", "dice_3d_mean", "=", "dice_3d", ".", "mean", "(", "dim", "=", "0", ")", "\n", "dice_3d_mean", "=", "torch", ".", "round", "(", "dice_3d_mean", "*", "10", "**", "4", ")", "/", "(", "10", "**", "4", ")", "\n", "dice_3d_sd", "=", "dice_3d", ".", "std", "(", "dim", "=", "0", ")", "\n", "dice_3d_sd", "=", "torch", ".", "round", "(", "dice_3d_sd", "*", "10", "**", "4", ")", "/", "(", "10", "**", "4", ")", "\n", "\n", "# do HD and / or ASD", "\n", "#if dice_3d_mean.mean()>best_epoch_val:", "\n", "if", "dice_3d_mean", ".", "mean", "(", ")", ">", "0", ":", "\n", "        ", "for", "i", ",", "p", "in", "enumerate", "(", "unique_patients", ")", ":", "\n", "            ", "root_name", "=", "[", "re", ".", "split", "(", "'(\\d+)'", ",", "x", ".", "item", "(", ")", ")", "[", "0", "]", "for", "x", "in", "all_pnames", "]", "[", "0", "]", "\n", "bool_p", "=", "[", "int", "(", "re", ".", "split", "(", "'_'", ",", "re", ".", "split", "(", "root_name", ",", "x", ".", "item", "(", ")", ")", "[", "1", "]", ")", "[", "0", "]", ")", "==", "p", "for", "x", "in", "all_pnames", "]", "\n", "slices_p", "=", "all_pnames", "[", "bool_p", "]", "\n", "#if do_hd >0 or dice_3d_mean.mean()>best_epoch_val:", "\n", "if", "do_hd", ">", "0", "or", "do_asd", ">", "0", ":", "\n", "                ", "all_gt_p", "=", "all_gt", "[", "bool_p", ",", ":", "]", "\n", "all_pred_p", "=", "all_pred", "[", "bool_p", ",", ":", "]", "\n", "sn_p", "=", "[", "int", "(", "re", ".", "split", "(", "'_'", ",", "x", ")", "[", "1", "]", ")", "for", "x", "in", "slices_p", "]", "\n", "ord_p", "=", "np", ".", "argsort", "(", "sn_p", ")", "\n", "label_gt", "=", "all_gt_p", "[", "ord_p", ",", "...", "]", "\n", "label_pred", "=", "all_pred_p", "[", "ord_p", ",", "...", "]", "\n", "asd_3d_var_vec", "=", "[", "None", "]", "*", "C", "\n", "hd_3d_var_vec", "=", "[", "None", "]", "*", "C", "\n", "for", "j", "in", "range", "(", "0", ",", "C", ")", ":", "\n", "                    ", "label_pred_c", "=", "numpy", ".", "copy", "(", "label_pred", ")", "\n", "label_pred_c", "[", "label_pred_c", "!=", "j", "]", "=", "0", "\n", "label_pred_c", "[", "label_pred_c", "==", "j", "]", "=", "1", "\n", "label_gt_c", "=", "numpy", ".", "copy", "(", "label_gt", ")", "\n", "label_gt_c", "[", "label_gt", "!=", "j", "]", "=", "0", "\n", "label_gt_c", "[", "label_gt", "==", "j", "]", "=", "1", "\n", "if", "len", "(", "np", ".", "unique", "(", "label_pred_c", ")", ")", ">", "1", ":", "# len(np.unique(label_gt_c))>1 should always be true...", "\n", "                        ", "if", "root_name", "==", "\"Subj_\"", ":", "\n", "                            ", "res_vec", "=", "[", "2", ",", "1.25", ",", "1.25", "]", "\n", "res_vec", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "", "elif", "root_name", "==", "\"Case\"", ":", "\n", "                            ", "res_vec", "=", "[", "0.6", ",", "0.44", ",", "0.44", "]", "\n", "res_vec", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "", "elif", "root_name", "==", "\"slice\"", "or", "root_name", "==", "\"ctslice\"", ":", "\n", "                            ", "res_vec", "=", "[", "1.6", ",", "0.78", ",", "0.78", "]", "\n", "res_vec", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "", "else", ":", "\n", "                            ", "res_vec", "=", "[", "1", ",", "1", ",", "1", "]", "\n", "unit", "=", "\"voxel\"", "\n", "", "if", "res_vec", "==", "[", "1", ",", "1", ",", "1", "]", ":", "\n", "                            ", "unit", "=", "\"voxel\"", "\n", "", "if", "do_hd", ">", "0", ":", "\n", "                            ", "hd_3d_var_vec", "[", "j", "]", "=", "hd95", "(", "label_pred_c", ",", "label_gt_c", ",", "res_vec", ")", ".", "item", "(", ")", "\n", "", "if", "do_asd", ">", "0", ":", "\n", "                            ", "asd_3d_var_vec", "[", "j", "]", "=", "assd", "(", "label_pred_c", ",", "label_gt_c", ",", "res_vec", ")", ".", "item", "(", ")", "\n", "", "", "else", ":", "\n", "                        ", "hd_3d_var_vec", "[", "j", "]", "=", "np", ".", "NaN", "\n", "asd_3d_var_vec", "[", "j", "]", "=", "np", ".", "NaN", "\n", "", "", "", "if", "do_asd", ">", "0", ":", "\n", "                ", "asd_3d_var", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "asd_3d_var_vec", ")", ")", "# np.nanmean(hd_3d_var_vec)", "\n", "batch_asd", "[", "i", ",", "...", "]", "=", "asd_3d_var", "\n", "\n", "", "if", "do_hd", ">", "0", ":", "\n", "                ", "hd_3d_var", "=", "torch", ".", "from_numpy", "(", "np", ".", "asarray", "(", "hd_3d_var_vec", ")", ")", "# np.nanmean(hd_3d_var_vec)", "\n", "batch_hd", "[", "i", ",", "...", "]", "=", "hd_3d_var", "\n", "\n", "", "", "", "[", "hd_3d", ",", "hd_3d_sd", "]", "=", "get_mean_sd", "(", "batch_hd", ",", "indices", ")", "\n", "[", "asd_3d", ",", "asd_3d_sd", "]", "=", "get_mean_sd", "(", "batch_asd", ",", "indices", ")", "\n", "[", "dice_3d", ",", "dice_3d_sd", "]", "=", "map_", "(", "lambda", "t", ":", "t", ".", "mean", "(", ")", ",", "[", "dice_3d_mean", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "dice_3d_sd", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "]", ")", "\n", "if", "pprint", ":", "\n", "        ", "print", "(", "p", ",", "asd_3d_var_vec", ",", "file", "=", "open", "(", "savedir", "+", "'/'", "+", "str", "(", "p", ")", "+", "\".txt\"", ",", "\"a\"", ")", ")", "\n", "print", "(", "'unit:'", ",", "unit", ",", "'asd_3d_mean'", ",", "asd_3d", ",", "\"asd_3d_sd\"", ",", "asd_3d_sd", ",", "\"hd_3d_mean\"", ",", "hd_3d", ",", "\"hd_3d_sd\"", ",", "hd_3d_sd", ",", "\"dice 3d\"", ",", "dice_3d", ".", "item", "(", ")", ")", "\n", "", "[", "return_asd", ",", "return_asd_sd", "]", "=", "[", "asd_3d", ".", "item", "(", ")", ",", "asd_3d_sd", ".", "item", "(", ")", "]", "if", "do_asd", ">", "0", "else", "[", "0", ",", "0", "]", "\n", "[", "return_hd", ",", "return_hd_sd", "]", "=", "[", "hd_3d", ".", "item", "(", ")", ",", "hd_3d_sd", ".", "item", "(", ")", "]", "if", "do_hd", ">", "0", "else", "[", "0", ",", "0", "]", "\n", "return", "dice_3d", ".", "item", "(", ")", ",", "dice_3d_sd", ".", "item", "(", ")", ",", "return_asd", ",", "return_asd_sd", ",", "return_hd", ",", "return_hd_sd", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dice3d.get_mean_sd": [[121, 129], ["torch.index_select", "torch.index_select.mean", "torch.index_select.std", "utils.map_", "torch.round", "torch.round", "t.mean"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_"], ["", "def", "get_mean_sd", "(", "x", ",", "indices", ")", ":", "\n", "    ", "x_ind", "=", "torch", ".", "index_select", "(", "x", ",", "1", ",", "indices", ")", "\n", "x_mean", "=", "x_ind", ".", "mean", "(", "dim", "=", "0", ")", "\n", "x_mean", "=", "torch", ".", "round", "(", "x_mean", "*", "10", "**", "4", ")", "/", "(", "10", "**", "4", ")", "\n", "x_std", "=", "x_ind", ".", "std", "(", "dim", "=", "0", ")", "\n", "x_std", "=", "torch", ".", "round", "(", "x_std", "*", "10", "**", "4", ")", "/", "(", "10", "**", "4", ")", "\n", "x_mean", ",", "x_std", "=", "map_", "(", "lambda", "t", ":", "t", ".", "mean", "(", ")", ",", "[", "x_mean", ",", "x_std", "]", ")", "\n", "return", "x_mean", ",", "x_std", "\n", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._read_lists": [[7, 22], ["os.path.isfile", "open", "fd.readlines", "my_list.append", "len", "fd.readlines.remove", "_item.split"], "function", ["None"], ["def", "_read_lists", "(", "fid", ")", ":", "\n", "    ", "\"\"\"\n    Read all kinds of lists from text file to python lists\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "fid", ")", ":", "\n", "        ", "return", "None", "\n", "", "with", "open", "(", "fid", ",", "'r'", ")", "as", "fd", ":", "\n", "        ", "_list", "=", "fd", ".", "readlines", "(", ")", "\n", "\n", "", "my_list", "=", "[", "]", "\n", "for", "_item", "in", "_list", ":", "\n", "        ", "if", "len", "(", "_item", ")", "<", "3", ":", "\n", "            ", "_list", ".", "remove", "(", "_item", ")", "\n", "", "my_list", ".", "append", "(", "_item", ".", "split", "(", "'\\n'", ")", "[", "0", "]", ")", "\n", "", "return", "my_list", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._save": [[23, 30], ["tf.train.Saver", "tf.train.Saver.save"], "function", ["None"], ["", "def", "_save", "(", "sess", ",", "model_path", ",", "global_step", ")", ":", "\n", "    ", "\"\"\"\n    Saves the current session to a checkpoint\n    \"\"\"", "\n", "saver", "=", "tf", ".", "train", ".", "Saver", "(", ")", "\n", "save_path", "=", "saver", ".", "save", "(", "sess", ",", "model_path", ",", "global_step", "=", "global_step", ")", "\n", "return", "save_path", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._save_nii_prediction": [[31, 46], ["lib.read_nii_object", "read_nii_object.get_affine", "lib.write_nii", "gth.copy", "lib.write_nii", "out_bname.split"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.lib.read_nii_object", "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib.write_nii", "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib.write_nii"], ["", "def", "_save_nii_prediction", "(", "gth", ",", "comp_pred", ",", "ref_fid", ",", "out_folder", ",", "out_bname", ",", "debug", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    save prediction, sample and gth to nii file given a reference\n    \"\"\"", "\n", "# first write prediction", "\n", "ref_obj", "=", "read_nii_object", "(", "ref_fid", ")", "\n", "ref_affine", "=", "ref_obj", ".", "get_affine", "(", ")", "\n", "out_bname", "=", "out_bname", ".", "split", "(", "\".\"", ")", "[", "0", "]", "+", "\".nii.gz\"", "\n", "write_nii", "(", "comp_pred", ",", "out_bname", ",", "out_folder", ",", "affine", "=", "ref_affine", ")", "\n", "\n", "# then write sample", "\n", "_local_gth", "=", "gth", ".", "copy", "(", ")", "\n", "_local_gth", "[", "_local_gth", ">", "self", ".", "num_cls", "-", "1", "]", "=", "0", "\n", "out_label_bname", "=", "\"gth_\"", "+", "out_bname", "\n", "write_nii", "(", "_local_gth", ",", "out_label_bname", ",", "out_folder", ",", "affine", "=", "ref_affine", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib.write_nii": [[47, 64], ["nibabel.Nifti1Image", "os.path.join", "print", "numpy.diag", "nib.Nifti1Image.to_filename", "print", "Exception"], "function", ["None"], ["", "def", "write_nii", "(", "array_data", ",", "filename", ",", "path", "=", "\"\"", ",", "affine", "=", "None", ")", ":", "\n", "    ", "\"\"\"write np array into nii file\"\"\"", "\n", "#print(array_data.shape)", "\n", "if", "affine", "is", "None", ":", "\n", "        ", "print", "(", "\"No information about the global coordinate system\"", ")", "\n", "affine", "=", "np", ".", "diag", "(", "[", "1", ",", "1", ",", "1", ",", "1", "]", ")", "\n", "#pdb.set_trace()", "\n", "#TODO: to check if it works", "\n", "# array_data = np.int16(array_data)", "\n", "", "array_img", "=", "nib", ".", "Nifti1Image", "(", "array_data", ",", "affine", ")", "\n", "save_fid", "=", "os", ".", "path", ".", "join", "(", "path", ",", "filename", ")", "\n", "try", ":", "\n", "        ", "array_img", ".", "to_filename", "(", "save_fid", ")", "\n", "print", "(", "\"Nii object %s has been saved!\"", "%", "save_fid", ")", "\n", "", "except", ":", "\n", "        ", "raise", "Exception", "(", "\"file %s cannot be saved!\"", "%", "save_fid", ")", "\n", "", "return", "save_fid", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib.read_nii_image": [[65, 69], ["nibabel.load", "nib.load.get_data"], "function", ["None"], ["", "def", "read_nii_image", "(", "input_fid", ")", ":", "\n", "    ", "\"\"\"read the nii image data into numpy array\"\"\"", "\n", "img", "=", "nib", ".", "load", "(", "input_fid", ")", "\n", "return", "img", ".", "get_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib.read_nii_object": [[70, 74], ["nibabel.load"], "function", ["None"], ["", "def", "read_nii_object", "(", "input_fid", ")", ":", "\n", "    ", "\"\"\" directly read the nii object \"\"\"", "\n", "#pdb.set_trace()", "\n", "return", "nib", ".", "load", "(", "input_fid", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._label_decomp": [[76, 94], ["list", "numpy.zeros", "range", "numpy.float32", "numpy.zeros", "numpy.concatenate"], "function", ["None"], ["", "def", "_label_decomp", "(", "num_cls", ",", "label_vol", ")", ":", "\n", "    ", "\"\"\"\n    decompose label for softmax classifier\n    original labels are batchsize * W * H * 1, with label values 0,1,2,3...\n    this function decompse it to one hot, e.g.: 0,0,0,1,0,0 in channel dimension\n    numpy version of tf.one_hot\n    \"\"\"", "\n", "_batch_shape", "=", "list", "(", "label_vol", ".", "shape", ")", "\n", "_vol", "=", "np", ".", "zeros", "(", "_batch_shape", ")", "\n", "_vol", "[", "label_vol", "==", "0", "]", "=", "1", "\n", "_vol", "=", "_vol", "[", "...", ",", "np", ".", "newaxis", "]", "\n", "for", "i", "in", "range", "(", "num_cls", ")", ":", "\n", "        ", "if", "i", "==", "0", ":", "\n", "            ", "continue", "\n", "", "_n_slice", "=", "np", ".", "zeros", "(", "label_vol", ".", "shape", ")", "\n", "_n_slice", "[", "label_vol", "==", "i", "]", "=", "1", "\n", "_vol", "=", "np", ".", "concatenate", "(", "(", "_vol", ",", "_n_slice", "[", "...", ",", "np", ".", "newaxis", "]", ")", ",", "axis", "=", "3", ")", "\n", "", "return", "np", ".", "float32", "(", "_vol", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._dice_eval": [[97, 112], ["tf.one_hot", "range", "tf.reduce_sum", "dice_arr.append", "tf.reduce_sum", "tf.reduce_sum"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot"], ["", "def", "_dice_eval", "(", "compact_pred", ",", "labels", ",", "n_class", ")", ":", "\n", "    ", "\"\"\"\n    calculate standard dice for evaluation, here uses the class prediction, not the probability\n    \"\"\"", "\n", "dice_arr", "=", "[", "]", "\n", "dice", "=", "0", "\n", "eps", "=", "1e-7", "\n", "pred", "=", "tf", ".", "one_hot", "(", "compact_pred", ",", "depth", "=", "n_class", ",", "axis", "=", "-", "1", ")", "\n", "for", "i", "in", "range", "(", "n_class", ")", ":", "\n", "        ", "inse", "=", "tf", ".", "reduce_sum", "(", "pred", "[", ":", ",", ":", ",", ":", ",", "i", "]", "*", "labels", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", "\n", "union", "=", "tf", ".", "reduce_sum", "(", "pred", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", "+", "tf", ".", "reduce_sum", "(", "labels", "[", ":", ",", ":", ",", ":", ",", "i", "]", ")", "\n", "dice", "=", "dice", "+", "2.0", "*", "inse", "/", "(", "union", "+", "eps", ")", "\n", "dice_arr", ".", "append", "(", "2.0", "*", "inse", "/", "(", "union", "+", "eps", ")", ")", "\n", "\n", "", "return", "1.0", "*", "dice", "/", "n_class", ",", "dice_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._inverse_lookup": [[114, 120], ["list", "my_dict.items"], "function", ["None"], ["", "def", "_inverse_lookup", "(", "my_dict", ",", "_value", ")", ":", "\n", "\n", "    ", "for", "key", ",", "dic_value", "in", "list", "(", "my_dict", ".", "items", "(", ")", ")", ":", "\n", "        ", "if", "dic_value", "==", "_value", ":", "\n", "            ", "return", "key", "\n", "", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._jaccard": [[122, 137], ["numpy.zeros", "range", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "_jaccard", "(", "conf_matrix", ")", ":", "\n", "    ", "\"\"\"\n    calculate jaccard similarity from confusion_matrix\n    \"\"\"", "\n", "num_cls", "=", "conf_matrix", ".", "shape", "[", "0", "]", "\n", "jac", "=", "np", ".", "zeros", "(", "num_cls", ")", "\n", "for", "ii", "in", "range", "(", "num_cls", ")", ":", "\n", "        ", "pp", "=", "np", ".", "sum", "(", "conf_matrix", "[", ":", ",", "ii", "]", ")", "\n", "gp", "=", "np", ".", "sum", "(", "conf_matrix", "[", "ii", ",", ":", "]", ")", "\n", "hit", "=", "conf_matrix", "[", "ii", ",", "ii", "]", "\n", "if", "(", "pp", "+", "gp", "-", "hit", ")", "==", "0", ":", "\n", "            ", "jac", "[", "ii", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "jac", "[", "ii", "]", "=", "hit", "*", "1.0", "/", "(", "pp", "+", "gp", "-", "hit", ")", "\n", "", "", "return", "jac", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._dice": [[139, 154], ["numpy.zeros", "range", "numpy.sum", "numpy.sum"], "function", ["None"], ["", "def", "_dice", "(", "conf_matrix", ")", ":", "\n", "    ", "\"\"\"\n    calculate dice coefficient from confusion_matrix\n    \"\"\"", "\n", "num_cls", "=", "conf_matrix", ".", "shape", "[", "0", "]", "\n", "dic", "=", "np", ".", "zeros", "(", "num_cls", ")", "\n", "for", "ii", "in", "range", "(", "num_cls", ")", ":", "\n", "        ", "pp", "=", "np", ".", "sum", "(", "conf_matrix", "[", ":", ",", "ii", "]", ")", "\n", "gp", "=", "np", ".", "sum", "(", "conf_matrix", "[", "ii", ",", ":", "]", ")", "\n", "hit", "=", "conf_matrix", "[", "ii", ",", "ii", "]", "\n", "if", "(", "pp", "+", "gp", ")", "==", "0", ":", "\n", "            ", "dic", "[", "ii", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "dic", "[", "ii", "]", "=", "2.0", "*", "hit", "/", "(", "pp", "+", "gp", ")", "\n", "", "", "return", "dic", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._indicator_eval": [[156, 177], ["lib._dice", "lib._jaccard", "print", "list", "contour_map.items", "print", "print", "print", "int", "int"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._dice", "home.repos.pwc.inspect_result.mathilde-b_tta.None.lib._jaccard"], ["", "def", "_indicator_eval", "(", "cm", ")", ":", "\n", "    ", "\"\"\"\n    Decompose confusion matrix and get statistics\n    \"\"\"", "\n", "contour_map", "=", "{", "# a map used for mapping label value to its name, used for output", "\n", "\"bg\"", ":", "0", ",", "\n", "\"la_myo\"", ":", "1", ",", "\n", "\"la_blood\"", ":", "2", ",", "\n", "\"lv_blood\"", ":", "3", ",", "\n", "\"aa\"", ":", "4", "\n", "}", "\n", "\n", "dice", "=", "_dice", "(", "cm", ")", "\n", "jaccard", "=", "_jaccard", "(", "cm", ")", "\n", "print", "(", "cm", ")", "\n", "for", "organ", ",", "ind", "in", "list", "(", "contour_map", ".", "items", "(", ")", ")", ":", "\n", "        ", "print", "(", "(", "\"organ: %s\"", "%", "organ", ")", ")", "\n", "print", "(", "(", "\"dice: %s\"", "%", "(", "dice", "[", "int", "(", "ind", ")", "]", ")", ")", ")", "\n", "print", "(", "(", "\"jaccard: %s\"", "%", "(", "jaccard", "[", "int", "(", "ind", ")", "]", ")", ")", ")", "\n", "\n", "", "return", "dice", ",", "jaccard", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.FCDiscriminator.__init__": [[37, 53], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "num_classes", ",", "ndf", "=", "64", ")", ":", "\n", "        ", "super", "(", "FCDiscriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# self.conv1 = nn.Conv2d(num_classes, ndf, kernel_size=4, stride=1, padding=1)", "\n", "# self.conv2 = nn.Conv2d(ndf, ndf*2, kernel_size=4, stride=1, padding=1)", "\n", "# self.conv3 = nn.Conv2d(ndf*2, ndf*4, kernel_size=4, stride=2, padding=1)", "\n", "# self.conv4 = nn.Conv2d(ndf*4, ndf*8, kernel_size=4, stride=2, padding=1)", "\n", "# self.classifier = nn.Conv2d(ndf*8, 1, kernel_size=4, stride=2, padding=1)", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "num_classes", ",", "ndf", ",", "kernel_size", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "ndf", ",", "ndf", "*", "2", ",", "kernel_size", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "ndf", "*", "2", ",", "ndf", "*", "4", ",", "kernel_size", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "ndf", "*", "4", ",", "ndf", "*", "8", ",", "kernel_size", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Conv2d", "(", "ndf", "*", "8", ",", "1", ",", "kernel_size", "=", "4", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "\n", "self", ".", "leaky_relu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "#self.up_sample = nn.Upsample(scale_factor=32, mode='bilinear')", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.FCDiscriminator.forward": [[56, 69], ["networks.FCDiscriminator.conv1", "networks.FCDiscriminator.leaky_relu", "networks.FCDiscriminator.conv2", "networks.FCDiscriminator.leaky_relu", "networks.FCDiscriminator.conv3", "networks.FCDiscriminator.leaky_relu", "networks.FCDiscriminator.conv4", "networks.FCDiscriminator.leaky_relu", "networks.FCDiscriminator.classifier"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "leaky_relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "leaky_relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "leaky_relu", "(", "x", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "x", "=", "self", ".", "leaky_relu", "(", "x", ")", "\n", "x", "=", "self", ".", "classifier", "(", "x", ")", "\n", "#x = self.up_sample(x)", "\n", "#x = self.sigmoid(x)", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Dummy.__init__": [[80, 85], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ConvTranspose2d", "torch.nn.ConvTranspose2d"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ":", "int", ",", "out_dim", ":", "int", ")", "->", "None", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "down", "=", "nn", ".", "Conv2d", "(", "in_dim", ",", "10", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "up", "=", "nn", ".", "ConvTranspose2d", "(", "10", ",", "out_dim", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "output_padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Dummy.forward": [[86, 88], ["networks.Dummy.up", "networks.Dummy.down"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "return", "self", ".", "up", "(", "self", ".", "down", "(", "input", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckDownSampling.__init__": [[94, 112], ["torch.nn.Module.__init__", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "layers.conv_block_1", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.PReLU", "torch.nn.PReLU", "int", "int", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "projectionFactor", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# Main branch", "\n", "self", ".", "maxpool0", "=", "nn", ".", "MaxPool2d", "(", "2", ",", "return_indices", "=", "True", ")", "\n", "# Secondary branch", "\n", "self", ".", "conv0", "=", "nn", ".", "Conv2d", "(", "in_dim", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn0", "=", "nn", ".", "BatchNorm2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "PReLU0", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "PReLU1", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "block2", "=", "conv_block_1", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "out_dim", ")", "\n", "\n", "self", ".", "do", "=", "nn", ".", "Dropout", "(", "p", "=", "0.01", ")", "\n", "self", ".", "PReLU3", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckDownSampling.forward": [[113, 144], ["networks.BottleNeckDownSampling.maxpool0", "networks.BottleNeckDownSampling.conv0", "networks.BottleNeckDownSampling.bn0", "networks.BottleNeckDownSampling.PReLU0", "networks.BottleNeckDownSampling.conv1", "networks.BottleNeckDownSampling.bn1", "networks.BottleNeckDownSampling.PReLU1", "networks.BottleNeckDownSampling.block2", "networks.BottleNeckDownSampling.do", "abs", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "networks.BottleNeckDownSampling.PReLU3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# Main branch", "\n", "        ", "maxpool_output", ",", "indices", "=", "self", ".", "maxpool0", "(", "input", ")", "\n", "\n", "# Secondary branch", "\n", "c0", "=", "self", ".", "conv0", "(", "input", ")", "\n", "b0", "=", "self", ".", "bn0", "(", "c0", ")", "\n", "p0", "=", "self", ".", "PReLU0", "(", "b0", ")", "\n", "\n", "c1", "=", "self", ".", "conv1", "(", "p0", ")", "\n", "b1", "=", "self", ".", "bn1", "(", "c1", ")", "\n", "p1", "=", "self", ".", "PReLU1", "(", "b1", ")", "\n", "\n", "p2", "=", "self", ".", "block2", "(", "p1", ")", "\n", "\n", "do", "=", "self", ".", "do", "(", "p2", ")", "\n", "\n", "# Zero padding the feature maps from the main branch", "\n", "depth_to_pad", "=", "abs", "(", "maxpool_output", ".", "shape", "[", "1", "]", "-", "do", ".", "shape", "[", "1", "]", ")", "\n", "padding", "=", "torch", ".", "zeros", "(", "maxpool_output", ".", "shape", "[", "0", "]", ",", "depth_to_pad", ",", "maxpool_output", ".", "shape", "[", "2", "]", ",", "\n", "maxpool_output", ".", "shape", "[", "3", "]", ",", "device", "=", "maxpool_output", ".", "device", ")", "\n", "maxpool_output_pad", "=", "torch", ".", "cat", "(", "(", "maxpool_output", ",", "padding", ")", ",", "1", ")", "\n", "output", "=", "maxpool_output_pad", "+", "do", "\n", "\n", "# _, c, _, _ = maxpool_output.shape", "\n", "# output = do", "\n", "# output[:, :c, :, :] += maxpool_output", "\n", "\n", "final_output", "=", "self", ".", "PReLU3", "(", "output", ")", "\n", "\n", "return", "final_output", ",", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckDownSamplingDilatedConv.__init__": [[147, 163], ["torch.nn.Module.__init__", "layers.conv_block_1", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "layers.conv_block_1", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.PReLU", "torch.nn.PReLU", "int", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "projectionFactor", ",", "out_dim", ",", "dilation", ")", ":", "\n", "        ", "super", "(", "BottleNeckDownSamplingDilatedConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Main branch", "\n", "\n", "# Secondary branch", "\n", "self", ".", "block0", "=", "conv_block_1", "(", "in_dim", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "kernel_size", "=", "3", ",", "\n", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "PReLU1", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "block2", "=", "conv_block_1", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "out_dim", ")", "\n", "\n", "self", ".", "do", "=", "nn", ".", "Dropout", "(", "p", "=", "0.01", ")", "\n", "self", ".", "PReLU3", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckDownSamplingDilatedConv.forward": [[164, 180], ["networks.BottleNeckDownSamplingDilatedConv.block0", "networks.BottleNeckDownSamplingDilatedConv.conv1", "networks.BottleNeckDownSamplingDilatedConv.bn1", "networks.BottleNeckDownSamplingDilatedConv.PReLU1", "networks.BottleNeckDownSamplingDilatedConv.block2", "networks.BottleNeckDownSamplingDilatedConv.do", "networks.BottleNeckDownSamplingDilatedConv.PReLU3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# Secondary branch", "\n", "        ", "b0", "=", "self", ".", "block0", "(", "input", ")", "\n", "\n", "c1", "=", "self", ".", "conv1", "(", "b0", ")", "\n", "b1", "=", "self", ".", "bn1", "(", "c1", ")", "\n", "p1", "=", "self", ".", "PReLU1", "(", "b1", ")", "\n", "\n", "b2", "=", "self", ".", "block2", "(", "p1", ")", "\n", "\n", "do", "=", "self", ".", "do", "(", "b2", ")", "\n", "\n", "output", "=", "input", "+", "do", "\n", "output", "=", "self", ".", "PReLU3", "(", "output", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckDownSamplingDilatedConvLast.__init__": [[183, 200], ["torch.nn.Module.__init__", "layers.conv_block_1", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "layers.conv_block_1", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.PReLU", "int", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "projectionFactor", ",", "out_dim", ",", "dilation", ")", ":", "\n", "        ", "super", "(", "BottleNeckDownSamplingDilatedConvLast", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Main branch", "\n", "\n", "# Secondary branch", "\n", "self", ".", "block0", "=", "conv_block_1", "(", "in_dim", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "kernel_size", "=", "3", ",", "\n", "padding", "=", "dilation", ",", "dilation", "=", "dilation", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "PReLU1", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "block2", "=", "conv_block_1", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "out_dim", ")", "\n", "\n", "self", ".", "do", "=", "nn", ".", "Dropout", "(", "p", "=", "0.01", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "Conv2d", "(", "in_dim", ",", "out_dim", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "PReLU3", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckDownSamplingDilatedConvLast.forward": [[201, 218], ["networks.BottleNeckDownSamplingDilatedConvLast.block0", "networks.BottleNeckDownSamplingDilatedConvLast.conv1", "networks.BottleNeckDownSamplingDilatedConvLast.bn1", "networks.BottleNeckDownSamplingDilatedConvLast.PReLU1", "networks.BottleNeckDownSamplingDilatedConvLast.block2", "networks.BottleNeckDownSamplingDilatedConvLast.do", "networks.BottleNeckDownSamplingDilatedConvLast.PReLU3", "networks.BottleNeckDownSamplingDilatedConvLast.conv_out"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "\n", "# Secondary branch", "\n", "        ", "b0", "=", "self", ".", "block0", "(", "input", ")", "\n", "\n", "c1", "=", "self", ".", "conv1", "(", "b0", ")", "\n", "b1", "=", "self", ".", "bn1", "(", "c1", ")", "\n", "p1", "=", "self", ".", "PReLU1", "(", "b1", ")", "\n", "\n", "b2", "=", "self", ".", "block2", "(", "p1", ")", "\n", "\n", "do", "=", "self", ".", "do", "(", "b2", ")", "\n", "\n", "output", "=", "self", ".", "conv_out", "(", "input", ")", "+", "do", "\n", "output", "=", "self", ".", "PReLU3", "(", "output", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckNormal.__init__": [[221, 237], ["torch.nn.Module.__init__", "layers.conv_block_1", "layers.conv_block_3_3", "layers.conv_block_1", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.PReLU", "torch.nn.PReLU", "int", "int", "int", "int", "layers.conv_block_1"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_3_3", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "projectionFactor", ",", "dropoutRate", ")", ":", "\n", "        ", "super", "(", "BottleNeckNormal", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "# Main branch", "\n", "\n", "# Secondary branch", "\n", "self", ".", "block0", "=", "conv_block_1", "(", "in_dim", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "block1", "=", "conv_block_3_3", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "block2", "=", "conv_block_1", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "out_dim", ")", "\n", "\n", "self", ".", "do", "=", "nn", ".", "Dropout", "(", "p", "=", "dropoutRate", ")", "\n", "self", ".", "PReLU_out", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "if", "in_dim", ">", "out_dim", ":", "\n", "            ", "self", ".", "conv_out", "=", "conv_block_1", "(", "in_dim", ",", "out_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckNormal.forward": [[238, 253], ["networks.BottleNeckNormal.block0", "networks.BottleNeckNormal.block1", "networks.BottleNeckNormal.block2", "networks.BottleNeckNormal.do", "networks.BottleNeckNormal.PReLU_out", "networks.BottleNeckNormal.conv_out"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# Main branch", "\n", "# Secondary branch", "\n", "        ", "b0", "=", "self", ".", "block0", "(", "input", ")", "\n", "b1", "=", "self", ".", "block1", "(", "b0", ")", "\n", "b2", "=", "self", ".", "block2", "(", "b1", ")", "\n", "do", "=", "self", ".", "do", "(", "b2", ")", "\n", "\n", "if", "self", ".", "in_dim", ">", "self", ".", "out_dim", ":", "\n", "            ", "output", "=", "self", ".", "conv_out", "(", "input", ")", "+", "do", "\n", "", "else", ":", "\n", "            ", "output", "=", "input", "+", "do", "\n", "", "output", "=", "self", ".", "PReLU_out", "(", "output", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckNormal_Asym.__init__": [[256, 272], ["torch.nn.Module.__init__", "layers.conv_block_1", "layers.conv_block_Asym", "layers.conv_block_1", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.PReLU", "torch.nn.PReLU", "int", "int", "int", "int", "layers.conv_block_1"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_Asym", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "projectionFactor", ",", "dropoutRate", ")", ":", "\n", "        ", "super", "(", "BottleNeckNormal_Asym", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "# Main branch", "\n", "\n", "# Secondary branch", "\n", "self", ".", "block0", "=", "conv_block_1", "(", "in_dim", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "block1", "=", "conv_block_Asym", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "5", ")", "\n", "self", ".", "block2", "=", "conv_block_1", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "out_dim", ")", "\n", "\n", "self", ".", "do", "=", "nn", ".", "Dropout", "(", "p", "=", "dropoutRate", ")", "\n", "self", ".", "PReLU_out", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "if", "in_dim", ">", "out_dim", ":", "\n", "            ", "self", ".", "conv_out", "=", "conv_block_1", "(", "in_dim", ",", "out_dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckNormal_Asym.forward": [[273, 288], ["networks.BottleNeckNormal_Asym.block0", "networks.BottleNeckNormal_Asym.block1", "networks.BottleNeckNormal_Asym.block2", "networks.BottleNeckNormal_Asym.do", "networks.BottleNeckNormal_Asym.PReLU_out", "networks.BottleNeckNormal_Asym.conv_out"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# Main branch", "\n", "# Secondary branch", "\n", "        ", "b0", "=", "self", ".", "block0", "(", "input", ")", "\n", "b1", "=", "self", ".", "block1", "(", "b0", ")", "\n", "b2", "=", "self", ".", "block2", "(", "b1", ")", "\n", "do", "=", "self", ".", "do", "(", "b2", ")", "\n", "\n", "if", "self", ".", "in_dim", ">", "self", ".", "out_dim", ":", "\n", "            ", "output", "=", "self", ".", "conv_out", "(", "input", ")", "+", "do", "\n", "", "else", ":", "\n", "            ", "output", "=", "input", "+", "do", "\n", "", "output", "=", "self", ".", "PReLU_out", "(", "output", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckUpSampling.__init__": [[291, 306], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.PReLU", "torch.nn.PReLU", "layers.conv_block_1", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.PReLU", "torch.nn.PReLU", "int", "int", "int", "int", "int", "int"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "projectionFactor", ",", "out_dim", ")", ":", "\n", "        ", "super", "(", "BottleNeckUpSampling", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# Main branch", "\n", "self", ".", "conv0", "=", "nn", ".", "Conv2d", "(", "in_dim", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn0", "=", "nn", ".", "BatchNorm2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "PReLU0", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ")", "\n", "self", ".", "PReLU1", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "block2", "=", "conv_block_1", "(", "int", "(", "in_dim", "/", "projectionFactor", ")", ",", "out_dim", ")", "\n", "\n", "self", ".", "do", "=", "nn", ".", "Dropout", "(", "p", "=", "0.01", ")", "\n", "self", ".", "PReLU3", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleNeckUpSampling.forward": [[307, 322], ["networks.BottleNeckUpSampling.conv0", "networks.BottleNeckUpSampling.bn0", "networks.BottleNeckUpSampling.PReLU0", "networks.BottleNeckUpSampling.conv1", "networks.BottleNeckUpSampling.bn1", "networks.BottleNeckUpSampling.PReLU1", "networks.BottleNeckUpSampling.block2", "networks.BottleNeckUpSampling.do"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# Secondary branch", "\n", "        ", "c0", "=", "self", ".", "conv0", "(", "input", ")", "\n", "b0", "=", "self", ".", "bn0", "(", "c0", ")", "\n", "p0", "=", "self", ".", "PReLU0", "(", "b0", ")", "\n", "\n", "c1", "=", "self", ".", "conv1", "(", "p0", ")", "\n", "b1", "=", "self", ".", "bn1", "(", "c1", ")", "\n", "p1", "=", "self", ".", "PReLU1", "(", "b1", ")", "\n", "\n", "p2", "=", "self", ".", "block2", "(", "p1", ")", "\n", "\n", "do", "=", "self", ".", "do", "(", "p2", ")", "\n", "\n", "return", "do", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ENet.__init__": [[325, 398], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "networks.BottleNeckDownSampling", "networks.BottleNeckNormal", "networks.BottleNeckNormal", "networks.BottleNeckNormal", "networks.BottleNeckNormal", "networks.BottleNeckDownSampling", "networks.BottleNeckNormal", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal_Asym", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal_Asym", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal_Asym", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal", "networks.BottleNeckDownSamplingDilatedConv", "networks.BottleNeckNormal_Asym", "networks.BottleNeckDownSamplingDilatedConvLast", "torch.nn.MaxUnpool2d", "torch.nn.MaxUnpool2d", "networks.BottleNeckUpSampling", "torch.nn.PReLU", "torch.nn.PReLU", "networks.BottleNeckNormal", "networks.BottleNeckNormal", "torch.nn.MaxUnpool2d", "torch.nn.MaxUnpool2d", "networks.BottleNeckUpSampling", "networks.BottleNeckNormal", "torch.nn.PReLU", "torch.nn.PReLU", "layers.upSampleConv", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.upSampleConv"], ["    ", "def", "__init__", "(", "self", ",", "nin", ",", "nout", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "projecting_factor", "=", "4", "\n", "self", ".", "n_kernels", "=", "16", "\n", "\n", "# Initial", "\n", "self", ".", "conv0", "=", "nn", ".", "Conv2d", "(", "nin", ",", "15", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "maxpool0", "=", "nn", ".", "MaxPool2d", "(", "2", ",", "return_indices", "=", "True", ")", "\n", "\n", "# First group", "\n", "self", ".", "bottleNeck1_0", "=", "BottleNeckDownSampling", "(", "self", ".", "n_kernels", ",", "self", ".", "projecting_factor", ",", "self", ".", "n_kernels", "*", "4", ")", "\n", "self", ".", "bottleNeck1_1", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "projecting_factor", ",", "0.01", ")", "\n", "self", ".", "bottleNeck1_2", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "projecting_factor", ",", "0.01", ")", "\n", "self", ".", "bottleNeck1_3", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "projecting_factor", ",", "0.01", ")", "\n", "self", ".", "bottleNeck1_4", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "projecting_factor", ",", "0.01", ")", "\n", "\n", "# Second group", "\n", "self", ".", "bottleNeck2_0", "=", "BottleNeckDownSampling", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "projecting_factor", ",", "self", ".", "n_kernels", "*", "8", ")", "\n", "self", ".", "bottleNeck2_1", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "0.1", ")", "\n", "self", ".", "bottleNeck2_2", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "2", ")", "\n", "self", ".", "bottleNeck2_3", "=", "BottleNeckNormal_Asym", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "0.1", ")", "\n", "self", ".", "bottleNeck2_4", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "4", ")", "\n", "self", ".", "bottleNeck2_5", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "0.1", ")", "\n", "self", ".", "bottleNeck2_6", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "8", ")", "\n", "self", ".", "bottleNeck2_7", "=", "BottleNeckNormal_Asym", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "0.1", ")", "\n", "self", ".", "bottleNeck2_8", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "16", ")", "\n", "\n", "# Third group", "\n", "self", ".", "bottleNeck3_1", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "0.1", ")", "\n", "self", ".", "bottleNeck3_2", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "2", ")", "\n", "self", ".", "bottleNeck3_3", "=", "BottleNeckNormal_Asym", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "0.1", ")", "\n", "self", ".", "bottleNeck3_4", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "4", ")", "\n", "self", ".", "bottleNeck3_5", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "0.1", ")", "\n", "self", ".", "bottleNeck3_6", "=", "BottleNeckDownSamplingDilatedConv", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "8", ",", "8", ")", "\n", "self", ".", "bottleNeck3_7", "=", "BottleNeckNormal_Asym", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "0.1", ")", "\n", "self", ".", "bottleNeck3_8", "=", "BottleNeckDownSamplingDilatedConvLast", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "4", ",", "16", ")", "\n", "\n", "# ### Decoding path ####", "\n", "# Unpooling 1", "\n", "self", ".", "unpool_0", "=", "nn", ".", "MaxUnpool2d", "(", "2", ")", "\n", "\n", "self", ".", "bottleNeck_Up_1_0", "=", "BottleNeckUpSampling", "(", "self", ".", "n_kernels", "*", "8", ",", "self", ".", "projecting_factor", ",", "\n", "self", ".", "n_kernels", "*", "4", ")", "\n", "self", ".", "PReLU_Up_1", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "self", ".", "bottleNeck_Up_1_1", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "projecting_factor", ",", "\n", "0.1", ")", "\n", "self", ".", "bottleNeck_Up_1_2", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", "*", "4", ",", "self", ".", "n_kernels", ",", "self", ".", "projecting_factor", ",", "0.1", ")", "\n", "\n", "# Unpooling 2", "\n", "self", ".", "unpool_1", "=", "nn", ".", "MaxUnpool2d", "(", "2", ")", "\n", "self", ".", "bottleNeck_Up_2_1", "=", "BottleNeckUpSampling", "(", "self", ".", "n_kernels", "*", "2", ",", "self", ".", "projecting_factor", ",", "self", ".", "n_kernels", ")", "\n", "self", ".", "bottleNeck_Up_2_2", "=", "BottleNeckNormal", "(", "self", ".", "n_kernels", ",", "self", ".", "n_kernels", ",", "self", ".", "projecting_factor", ",", "0.1", ")", "\n", "self", ".", "PReLU_Up_2", "=", "nn", ".", "PReLU", "(", ")", "\n", "\n", "# Unpooling Last", "\n", "self", ".", "deconv3", "=", "upSampleConv", "(", "self", ".", "n_kernels", ",", "self", ".", "n_kernels", ")", "\n", "\n", "self", ".", "out_025", "=", "nn", ".", "Conv2d", "(", "self", ".", "n_kernels", "*", "8", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "out_05", "=", "nn", ".", "Conv2d", "(", "self", ".", "n_kernels", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "final", "=", "nn", ".", "Conv2d", "(", "self", ".", "n_kernels", ",", "nout", ",", "kernel_size", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ENet.forward": [[399, 457], ["networks.ENet.conv0", "networks.ENet.maxpool0", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "networks.ENet.bottleNeck1_0", "networks.ENet.bottleNeck1_1", "networks.ENet.bottleNeck1_2", "networks.ENet.bottleNeck1_3", "networks.ENet.bottleNeck1_4", "networks.ENet.bottleNeck2_0", "networks.ENet.bottleNeck2_1", "networks.ENet.bottleNeck2_2", "networks.ENet.bottleNeck2_3", "networks.ENet.bottleNeck2_4", "networks.ENet.bottleNeck2_5", "networks.ENet.bottleNeck2_6", "networks.ENet.bottleNeck2_7", "networks.ENet.bottleNeck2_8", "networks.ENet.bottleNeck3_1", "networks.ENet.bottleNeck3_2", "networks.ENet.bottleNeck3_3", "networks.ENet.bottleNeck3_4", "networks.ENet.bottleNeck3_5", "networks.ENet.bottleNeck3_6", "networks.ENet.bottleNeck3_7", "networks.ENet.bottleNeck3_8", "networks.ENet.unpool_0", "networks.ENet.bottleNeck_Up_1_0", "networks.ENet.PReLU_Up_1", "networks.ENet.bottleNeck_Up_1_1", "networks.ENet.bottleNeck_Up_1_2", "networks.ENet.unpool_1", "networks.ENet.bottleNeck_Up_2_1", "networks.ENet.bottleNeck_Up_2_2", "networks.ENet.PReLU_Up_2", "networks.ENet.deconv3", "networks.ENet.final", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "conv_0", "=", "self", ".", "conv0", "(", "input", ")", "# This will go as res in deconv path", "\n", "maxpool_0", ",", "indices_0", "=", "self", ".", "maxpool0", "(", "input", ")", "\n", "outputInitial", "=", "torch", ".", "cat", "(", "(", "conv_0", ",", "maxpool_0", ")", ",", "dim", "=", "1", ")", "\n", "\n", "# First group", "\n", "bn1_0", ",", "indices_1", "=", "self", ".", "bottleNeck1_0", "(", "outputInitial", ")", "\n", "bn1_1", "=", "self", ".", "bottleNeck1_1", "(", "bn1_0", ")", "\n", "bn1_2", "=", "self", ".", "bottleNeck1_2", "(", "bn1_1", ")", "\n", "bn1_3", "=", "self", ".", "bottleNeck1_3", "(", "bn1_2", ")", "\n", "bn1_4", "=", "self", ".", "bottleNeck1_4", "(", "bn1_3", ")", "\n", "\n", "# Second group", "\n", "bn2_0", ",", "indices_2", "=", "self", ".", "bottleNeck2_0", "(", "bn1_4", ")", "\n", "bn2_1", "=", "self", ".", "bottleNeck2_1", "(", "bn2_0", ")", "\n", "bn2_2", "=", "self", ".", "bottleNeck2_2", "(", "bn2_1", ")", "\n", "bn2_3", "=", "self", ".", "bottleNeck2_3", "(", "bn2_2", ")", "\n", "bn2_4", "=", "self", ".", "bottleNeck2_4", "(", "bn2_3", ")", "\n", "bn2_5", "=", "self", ".", "bottleNeck2_5", "(", "bn2_4", ")", "\n", "bn2_6", "=", "self", ".", "bottleNeck2_6", "(", "bn2_5", ")", "\n", "bn2_7", "=", "self", ".", "bottleNeck2_7", "(", "bn2_6", ")", "\n", "bn2_8", "=", "self", ".", "bottleNeck2_8", "(", "bn2_7", ")", "\n", "\n", "# Third group", "\n", "bn3_1", "=", "self", ".", "bottleNeck3_1", "(", "bn2_8", ")", "\n", "bn3_2", "=", "self", ".", "bottleNeck3_2", "(", "bn3_1", ")", "\n", "bn3_3", "=", "self", ".", "bottleNeck3_3", "(", "bn3_2", ")", "\n", "bn3_4", "=", "self", ".", "bottleNeck3_4", "(", "bn3_3", ")", "\n", "bn3_5", "=", "self", ".", "bottleNeck3_5", "(", "bn3_4", ")", "\n", "bn3_6", "=", "self", ".", "bottleNeck3_6", "(", "bn3_5", ")", "\n", "bn3_7", "=", "self", ".", "bottleNeck3_7", "(", "bn3_6", ")", "\n", "bn3_8", "=", "self", ".", "bottleNeck3_8", "(", "bn3_7", ")", "\n", "\n", "# #### Deconvolution Path ####", "\n", "#  First block #", "\n", "unpool_0", "=", "self", ".", "unpool_0", "(", "bn3_8", ",", "indices_2", ")", "\n", "\n", "# bn_up_1_0 = self.bottleNeck_Up_1_0(unpool_0) # Not concatenate", "\n", "bn_up_1_0", "=", "self", ".", "bottleNeck_Up_1_0", "(", "torch", ".", "cat", "(", "(", "unpool_0", ",", "bn1_4", ")", ",", "dim", "=", "1", ")", ")", "# concatenate", "\n", "\n", "up_block_1", "=", "self", ".", "PReLU_Up_1", "(", "unpool_0", "+", "bn_up_1_0", ")", "\n", "\n", "bn_up_1_1", "=", "self", ".", "bottleNeck_Up_1_1", "(", "up_block_1", ")", "\n", "bn_up_1_2", "=", "self", ".", "bottleNeck_Up_1_2", "(", "bn_up_1_1", ")", "\n", "\n", "#  Second block #", "\n", "unpool_1", "=", "self", ".", "unpool_1", "(", "bn_up_1_2", ",", "indices_1", ")", "\n", "\n", "# bn_up_2_1 = self.bottleNeck_Up_2_1(unpool_1) # Not concatenate", "\n", "bn_up_2_1", "=", "self", ".", "bottleNeck_Up_2_1", "(", "torch", ".", "cat", "(", "(", "unpool_1", ",", "outputInitial", ")", ",", "dim", "=", "1", ")", ")", "# concatenate", "\n", "\n", "bn_up_2_2", "=", "self", ".", "bottleNeck_Up_2_2", "(", "bn_up_2_1", ")", "\n", "\n", "up_block_1", "=", "self", ".", "PReLU_Up_2", "(", "unpool_1", "+", "bn_up_2_2", ")", "\n", "\n", "unpool_12", "=", "self", ".", "deconv3", "(", "up_block_1", ")", "\n", "\n", "return", "self", ".", "final", "(", "unpool_12", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Conv_residual_conv.__init__": [[460, 469], ["torch.nn.Module.__init__", "layers.conv_block", "layers.conv_block_3", "layers.conv_block"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_3", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block"], ["    ", "def", "__init__", "(", "self", ",", "in_dim", ",", "out_dim", ",", "act_fn", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_dim", "=", "in_dim", "\n", "self", ".", "out_dim", "=", "out_dim", "\n", "act_fn", "=", "act_fn", "\n", "\n", "self", ".", "conv_1", "=", "conv_block", "(", "self", ".", "in_dim", ",", "self", ".", "out_dim", ",", "act_fn", ")", "\n", "self", ".", "conv_2", "=", "conv_block_3", "(", "self", ".", "out_dim", ",", "self", ".", "out_dim", ",", "act_fn", ")", "\n", "self", ".", "conv_3", "=", "conv_block", "(", "self", ".", "out_dim", ",", "self", ".", "out_dim", ",", "act_fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Conv_residual_conv.forward": [[470, 476], ["networks.Conv_residual_conv.conv_1", "networks.Conv_residual_conv.conv_2", "networks.Conv_residual_conv.conv_3"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "conv_1", "=", "self", ".", "conv_1", "(", "input", ")", "\n", "conv_2", "=", "self", ".", "conv_2", "(", "conv_1", ")", "\n", "res", "=", "conv_1", "+", "conv_2", "\n", "conv_3", "=", "self", ".", "conv_3", "(", "res", ")", "\n", "return", "conv_3", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResidualUNet.__init__": [[479, 522], ["torch.nn.Module.__init__", "torch.nn.LeakyReLU", "torch.nn.LeakyReLU", "torch.nn.ReLU", "torch.nn.ReLU", "networks.Conv_residual_conv", "layers.maxpool", "networks.Conv_residual_conv", "layers.maxpool", "networks.Conv_residual_conv", "layers.maxpool", "networks.Conv_residual_conv", "layers.maxpool", "networks.Conv_residual_conv", "layers.conv_decod_block", "networks.Conv_residual_conv", "layers.conv_decod_block", "networks.Conv_residual_conv", "layers.conv_decod_block", "networks.Conv_residual_conv", "layers.conv_decod_block", "networks.Conv_residual_conv", "torch.nn.Conv2d", "torch.nn.Conv2d", "networks.ResidualUNet.modules", "print", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.maxpool", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.maxpool", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.maxpool", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.maxpool", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_decod_block", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_decod_block", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_decod_block", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_decod_block"], ["    ", "def", "__init__", "(", "self", ",", "input_nc", ",", "output_nc", ",", "ngf", "=", "32", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_dim", "=", "input_nc", "\n", "self", ".", "out_dim", "=", "ngf", "\n", "self", ".", "final_out_dim", "=", "output_nc", "\n", "act_fn", "=", "nn", ".", "LeakyReLU", "(", "0.2", ",", "inplace", "=", "True", ")", "\n", "act_fn_2", "=", "nn", ".", "ReLU", "(", ")", "\n", "\n", "# Encoder", "\n", "self", ".", "down_1", "=", "Conv_residual_conv", "(", "self", ".", "in_dim", ",", "self", ".", "out_dim", ",", "act_fn", ")", "\n", "self", ".", "pool_1", "=", "maxpool", "(", ")", "\n", "self", ".", "down_2", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", ",", "self", ".", "out_dim", "*", "2", ",", "act_fn", ")", "\n", "self", ".", "pool_2", "=", "maxpool", "(", ")", "\n", "self", ".", "down_3", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", "*", "2", ",", "self", ".", "out_dim", "*", "4", ",", "act_fn", ")", "\n", "self", ".", "pool_3", "=", "maxpool", "(", ")", "\n", "self", ".", "down_4", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", "*", "4", ",", "self", ".", "out_dim", "*", "8", ",", "act_fn", ")", "\n", "self", ".", "pool_4", "=", "maxpool", "(", ")", "\n", "\n", "# Bridge between Encoder-Decoder", "\n", "self", ".", "bridge", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", "*", "8", ",", "self", ".", "out_dim", "*", "16", ",", "act_fn", ")", "\n", "\n", "# Decoder", "\n", "self", ".", "deconv_1", "=", "conv_decod_block", "(", "self", ".", "out_dim", "*", "16", ",", "self", ".", "out_dim", "*", "8", ",", "act_fn_2", ")", "\n", "self", ".", "up_1", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", "*", "8", ",", "self", ".", "out_dim", "*", "8", ",", "act_fn_2", ")", "\n", "self", ".", "deconv_2", "=", "conv_decod_block", "(", "self", ".", "out_dim", "*", "8", ",", "self", ".", "out_dim", "*", "4", ",", "act_fn_2", ")", "\n", "self", ".", "up_2", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", "*", "4", ",", "self", ".", "out_dim", "*", "4", ",", "act_fn_2", ")", "\n", "self", ".", "deconv_3", "=", "conv_decod_block", "(", "self", ".", "out_dim", "*", "4", ",", "self", ".", "out_dim", "*", "2", ",", "act_fn_2", ")", "\n", "self", ".", "up_3", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", "*", "2", ",", "self", ".", "out_dim", "*", "2", ",", "act_fn_2", ")", "\n", "self", ".", "deconv_4", "=", "conv_decod_block", "(", "self", ".", "out_dim", "*", "2", ",", "self", ".", "out_dim", ",", "act_fn_2", ")", "\n", "self", ".", "up_4", "=", "Conv_residual_conv", "(", "self", ".", "out_dim", ",", "self", ".", "out_dim", ",", "act_fn_2", ")", "\n", "\n", "self", ".", "out", "=", "nn", ".", "Conv2d", "(", "self", ".", "out_dim", ",", "self", ".", "final_out_dim", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", "\n", "\n", "# Params initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n", "", "", "print", "(", "f\"Initialized {self.__class__.__name__} succesfully\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResidualUNet.forward": [[523, 551], ["networks.ResidualUNet.down_1", "networks.ResidualUNet.down_2", "networks.ResidualUNet.down_3", "networks.ResidualUNet.down_4", "networks.ResidualUNet.bridge", "networks.ResidualUNet.deconv_1", "networks.ResidualUNet.up_1", "networks.ResidualUNet.deconv_2", "networks.ResidualUNet.up_2", "networks.ResidualUNet.deconv_3", "networks.ResidualUNet.up_3", "networks.ResidualUNet.deconv_4", "networks.ResidualUNet.up_4", "networks.ResidualUNet.out", "networks.ResidualUNet.pool_1", "networks.ResidualUNet.pool_2", "networks.ResidualUNet.pool_3", "networks.ResidualUNet.pool_4"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# Encoding path", "\n", "\n", "        ", "down_1", "=", "self", ".", "down_1", "(", "input", ")", "# This will go as res in deconv path", "\n", "down_2", "=", "self", ".", "down_2", "(", "self", ".", "pool_1", "(", "down_1", ")", ")", "\n", "down_3", "=", "self", ".", "down_3", "(", "self", ".", "pool_2", "(", "down_2", ")", ")", "\n", "down_4", "=", "self", ".", "down_4", "(", "self", ".", "pool_3", "(", "down_3", ")", ")", "\n", "\n", "bridge", "=", "self", ".", "bridge", "(", "self", ".", "pool_4", "(", "down_4", ")", ")", "\n", "\n", "# Decoding path", "\n", "deconv_1", "=", "self", ".", "deconv_1", "(", "bridge", ")", "\n", "skip_1", "=", "(", "deconv_1", "+", "down_4", ")", "/", "2", "# Residual connection", "\n", "up_1", "=", "self", ".", "up_1", "(", "skip_1", ")", "\n", "\n", "deconv_2", "=", "self", ".", "deconv_2", "(", "up_1", ")", "\n", "skip_2", "=", "(", "deconv_2", "+", "down_3", ")", "/", "2", "# Residual connection", "\n", "up_2", "=", "self", ".", "up_2", "(", "skip_2", ")", "\n", "\n", "deconv_3", "=", "self", ".", "deconv_3", "(", "up_2", ")", "\n", "skip_3", "=", "(", "deconv_3", "+", "down_2", ")", "/", "2", "# Residual connection", "\n", "up_3", "=", "self", ".", "up_3", "(", "skip_3", ")", "\n", "\n", "deconv_4", "=", "self", ".", "deconv_4", "(", "up_3", ")", "\n", "skip_4", "=", "(", "deconv_4", "+", "down_1", ")", "/", "2", "# Residual connection", "\n", "up_4", "=", "self", ".", "up_4", "(", "skip_4", ")", "\n", "\n", "return", "self", ".", "out", "(", "up_4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.UNet.__init__": [[555, 579], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "layers.upSampleConv", "torch.nn.Sequential", "torch.nn.Sequential", "layers.upSampleConv", "torch.nn.Sequential", "torch.nn.Sequential", "layers.upSampleConv", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.residualConv", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch", "layers.convBatch"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.upSampleConv", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.upSampleConv", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.upSampleConv", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch"], ["    ", "def", "__init__", "(", "self", ",", "nin", ",", "nout", ",", "nG", "=", "32", ")", ":", "# m changed the default from 64 to 32", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv0", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nin", ",", "nG", ")", ",", "\n", "convBatch", "(", "nG", ",", "nG", ")", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nG", "*", "1", ",", "nG", "*", "2", ",", "stride", "=", "2", ")", ",", "\n", "convBatch", "(", "nG", "*", "2", ",", "nG", "*", "2", ")", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nG", "*", "2", ",", "nG", "*", "4", ",", "stride", "=", "2", ")", ",", "\n", "convBatch", "(", "nG", "*", "4", ",", "nG", "*", "4", ")", ")", "\n", "\n", "self", ".", "bridge", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nG", "*", "4", ",", "nG", "*", "8", ",", "stride", "=", "2", ")", ",", "\n", "residualConv", "(", "nG", "*", "8", ",", "nG", "*", "8", ")", ",", "\n", "convBatch", "(", "nG", "*", "8", ",", "nG", "*", "8", ")", ")", "\n", "\n", "self", ".", "deconv1", "=", "upSampleConv", "(", "nG", "*", "8", ",", "nG", "*", "8", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nG", "*", "12", ",", "nG", "*", "4", ")", ",", "\n", "convBatch", "(", "nG", "*", "4", ",", "nG", "*", "4", ")", ")", "\n", "self", ".", "deconv2", "=", "upSampleConv", "(", "nG", "*", "4", ",", "nG", "*", "4", ")", "\n", "self", ".", "conv6", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nG", "*", "6", ",", "nG", "*", "2", ")", ",", "\n", "convBatch", "(", "nG", "*", "2", ",", "nG", "*", "2", ")", ")", "\n", "self", ".", "deconv3", "=", "upSampleConv", "(", "nG", "*", "2", ",", "nG", "*", "2", ")", "\n", "self", ".", "conv7", "=", "nn", ".", "Sequential", "(", "convBatch", "(", "nG", "*", "3", ",", "nG", "*", "1", ")", ",", "\n", "convBatch", "(", "nG", "*", "1", ",", "nG", "*", "1", ")", ")", "\n", "self", ".", "final", "=", "nn", ".", "Conv2d", "(", "nG", ",", "nout", ",", "kernel_size", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.UNet.forward": [[580, 594], ["input.float.float.float", "networks.UNet.conv0", "networks.UNet.conv1", "networks.UNet.conv2", "networks.UNet.bridge", "networks.UNet.deconv1", "networks.UNet.deconv2", "networks.UNet.deconv3", "networks.UNet.conv7", "networks.UNet.final", "networks.UNet.conv5", "networks.UNet.conv6", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "input", "=", "input", ".", "float", "(", ")", "\n", "x0", "=", "self", ".", "conv0", "(", "input", ")", "\n", "x1", "=", "self", ".", "conv1", "(", "x0", ")", "\n", "x2", "=", "self", ".", "conv2", "(", "x1", ")", "\n", "\n", "bridge", "=", "self", ".", "bridge", "(", "x2", ")", "\n", "\n", "y0", "=", "self", ".", "deconv1", "(", "bridge", ")", "\n", "y1", "=", "self", ".", "deconv2", "(", "self", ".", "conv5", "(", "torch", ".", "cat", "(", "(", "y0", ",", "x2", ")", ",", "dim", "=", "1", ")", ")", ")", "\n", "y2", "=", "self", ".", "deconv3", "(", "self", ".", "conv6", "(", "torch", ".", "cat", "(", "(", "y1", ",", "x1", ")", ",", "dim", "=", "1", ")", ")", ")", "\n", "y3", "=", "self", ".", "conv7", "(", "torch", ".", "cat", "(", "(", "y2", ",", "x0", ")", ",", "dim", "=", "1", ")", ")", "\n", "\n", "return", "self", ".", "final", "(", "y3", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.fcn8s.__init__": [[597, 656], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Dropout2d", "torch.nn.Dropout2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.Dropout2d", "torch.nn.Dropout2d", "torch.nn.Conv2d", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "nin", ",", "nout", ",", "learned_billinear", "=", "False", ")", ":", "\n", "        ", "super", "(", "fcn8s", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "learned_billinear", "=", "learned_billinear", "\n", "self", ".", "n_classes", "=", "nout", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "nin", ",", "64", ",", "3", ",", "padding", "=", "100", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", ")", "\n", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", ")", "\n", "\n", "self", ".", "conv3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "128", ",", "256", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "256", ",", "256", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "256", ",", "256", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", ")", "\n", "\n", "self", ".", "conv4", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "256", ",", "512", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", ")", "\n", "\n", "self", ".", "conv5", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "MaxPool2d", "(", "2", ",", "stride", "=", "2", ",", "ceil_mode", "=", "True", ")", ")", "\n", "\n", "self", ".", "classifier", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "512", ",", "4096", ",", "7", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Dropout2d", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "4096", ",", "4096", ",", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Dropout2d", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "4096", ",", "self", ".", "n_classes", ",", "1", ")", ",", ")", "\n", "\n", "self", ".", "forward_path", ":", "Iterable", "[", "Any", "]", "=", "[", "self", ".", "conv1", ",", "self", ".", "conv2", ",", "self", ".", "conv3", ",", "self", ".", "conv4", ",", "self", ".", "conv5", ",", "self", ".", "classifier", "]", "\n", "\n", "self", ".", "score_pool4", "=", "nn", ".", "Conv2d", "(", "512", ",", "self", ".", "n_classes", ",", "1", ")", "\n", "self", ".", "score_pool3", "=", "nn", ".", "Conv2d", "(", "256", ",", "self", ".", "n_classes", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.fcn8s.apply": [[657, 661], ["print", "torchvision.vgg16", "networks.fcn8s.init_vgg16_params"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.fcn8s.init_vgg16_params"], ["", "def", "apply", "(", "self", ",", "_", ")", "->", "None", ":", "\n", "        ", "print", "(", "\"Override default apply fn, call its own weight init instead\"", ")", "\n", "vgg16", "=", "models", ".", "vgg16", "(", "pretrained", "=", "True", ")", "\n", "self", ".", "init_vgg16_params", "(", "vgg16", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.fcn8s.forward": [[662, 675], ["utils.compose_acc", "networks.fcn8s.score_pool4", "networks.fcn8s.score_pool3", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "torch.interpolate", "networks.fcn8s.size", "networks.fcn8s.size", "x.size"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.compose_acc"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "_", ",", "_", ",", "_", ",", "conv3", ",", "conv4", ",", "_", ",", "score", "=", "compose_acc", "(", "self", ".", "forward_path", ",", "x", ")", "\n", "\n", "score_pool4", "=", "self", ".", "score_pool4", "(", "conv4", ")", "\n", "score_pool3", "=", "self", ".", "score_pool3", "(", "conv3", ")", "\n", "\n", "score", "=", "F", ".", "interpolate", "(", "score", ",", "size", "=", "score_pool4", ".", "size", "(", ")", "[", "2", ":", "]", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "True", ")", "\n", "score", "+=", "score_pool4", "\n", "score", "=", "F", ".", "interpolate", "(", "score", ",", "size", "=", "score_pool3", ".", "size", "(", ")", "[", "2", ":", "]", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "True", ")", "\n", "score", "+=", "score_pool3", "\n", "out", "=", "F", ".", "interpolate", "(", "score", ",", "size", "=", "x", ".", "size", "(", ")", "[", "2", ":", "]", ",", "mode", "=", "\"bilinear\"", ",", "align_corners", "=", "True", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.fcn8s.init_vgg16_params": [[676, 704], ["list", "enumerate", "zip", "vgg16.features.children", "zip", "l1.weight.data.view", "l1.bias.data.view", "networks.fcn8s.classifier[].weight.size", "l1.weight.data[].view", "l2.weight.size", "l2.bias.size", "l2.weight.size", "isinstance", "isinstance", "l1.weight.size", "l2.weight.size", "l1.bias.size", "l2.bias.size"], "methods", ["None"], ["", "def", "init_vgg16_params", "(", "self", ",", "vgg16", ",", "copy_fc8", "=", "True", ")", ":", "\n", "        ", "blocks", "=", "[", "self", ".", "conv1", ",", "\n", "self", ".", "conv2", ",", "\n", "self", ".", "conv3", ",", "\n", "self", ".", "conv4", ",", "\n", "self", ".", "conv5", "]", "\n", "\n", "ranges", "=", "[", "[", "0", ",", "4", "]", ",", "[", "5", ",", "9", "]", ",", "[", "10", ",", "16", "]", ",", "[", "17", ",", "23", "]", ",", "[", "24", ",", "29", "]", "]", "\n", "features", "=", "list", "(", "vgg16", ".", "features", ".", "children", "(", ")", ")", "\n", "\n", "for", "idx", ",", "conv", "in", "enumerate", "(", "blocks", ")", ":", "\n", "            ", "for", "l1", ",", "l2", "in", "zip", "(", "features", "[", "ranges", "[", "idx", "]", "[", "0", "]", ":", "ranges", "[", "idx", "]", "[", "1", "]", "]", ",", "conv", ")", ":", "\n", "                ", "if", "isinstance", "(", "l1", ",", "nn", ".", "Conv2d", ")", "and", "isinstance", "(", "l2", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                    ", "assert", "l1", ".", "weight", ".", "size", "(", ")", "==", "l2", ".", "weight", ".", "size", "(", ")", "\n", "assert", "l1", ".", "bias", ".", "size", "(", ")", "==", "l2", ".", "bias", ".", "size", "(", ")", "\n", "l2", ".", "weight", ".", "data", "=", "l1", ".", "weight", ".", "data", "\n", "l2", ".", "bias", ".", "data", "=", "l1", ".", "bias", ".", "data", "\n", "", "", "", "for", "i1", ",", "i2", "in", "zip", "(", "[", "0", ",", "3", "]", ",", "[", "0", ",", "3", "]", ")", ":", "\n", "            ", "l1", "=", "vgg16", ".", "classifier", "[", "i1", "]", "\n", "l2", "=", "self", ".", "classifier", "[", "i2", "]", "\n", "l2", ".", "weight", ".", "data", "=", "l1", ".", "weight", ".", "data", ".", "view", "(", "l2", ".", "weight", ".", "size", "(", ")", ")", "\n", "l2", ".", "bias", ".", "data", "=", "l1", ".", "bias", ".", "data", ".", "view", "(", "l2", ".", "bias", ".", "size", "(", ")", ")", "\n", "", "n_class", "=", "self", ".", "classifier", "[", "6", "]", ".", "weight", ".", "size", "(", ")", "[", "0", "]", "\n", "if", "copy_fc8", ":", "\n", "            ", "l1", "=", "vgg16", ".", "classifier", "[", "6", "]", "\n", "l2", "=", "self", ".", "classifier", "[", "6", "]", "\n", "l2", ".", "weight", ".", "data", "=", "l1", ".", "weight", ".", "data", "[", ":", "n_class", ",", ":", "]", ".", "view", "(", "l2", ".", "weight", ".", "size", "(", ")", ")", "\n", "l2", ".", "bias", ".", "data", "=", "l1", ".", "bias", ".", "data", "[", ":", "n_class", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Bottleneck.__init__": [[708, 718], ["torch.nn.Module.__init__", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "expansion", "=", "4", ",", "growthRate", "=", "12", ",", "dropRate", "=", "0", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "planes", "=", "expansion", "*", "growthRate", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "inplanes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "growthRate", ",", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "dropRate", "=", "dropRate", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Bottleneck.forward": [[719, 732], ["networks.Bottleneck.bn1", "networks.Bottleneck.relu", "networks.Bottleneck.conv1", "networks.Bottleneck.bn2", "networks.Bottleneck.relu", "networks.Bottleneck.conv2", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.dropout", "torch.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "bn1", "(", "x", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "if", "self", ".", "dropRate", ">", "0", ":", "\n", "            ", "out", "=", "F", ".", "dropout", "(", "out", ",", "p", "=", "self", ".", "dropRate", ",", "training", "=", "self", ".", "training", ")", "\n", "\n", "", "out", "=", "torch", ".", "cat", "(", "(", "x", ",", "out", ")", ",", "1", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet.__init__": [[735, 768], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "networks.DenseNet._make_denseblock", "networks.DenseNet._make_transition", "networks.DenseNet._make_denseblock", "networks.DenseNet._make_transition", "networks.DenseNet._make_denseblock", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "torch.nn.Linear", "torch.nn.Linear", "networks.DenseNet.modules", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_denseblock", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_transition", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_denseblock", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_transition", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_denseblock"], ["    ", "def", "__init__", "(", "self", ",", "depth", "=", "22", ",", "block", "=", "Bottleneck", ",", "\n", "dropRate", "=", "0", ",", "num_classes", "=", "10", ",", "growthRate", "=", "12", ",", "compressionRate", "=", "2", ")", ":", "\n", "        ", "super", "(", "DenseNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "(", "depth", "-", "4", ")", "%", "3", "==", "0", ",", "'depth should be 3n+4'", "\n", "n", "=", "(", "depth", "-", "4", ")", "/", "3", "if", "block", "==", "BasicBlock", "else", "(", "depth", "-", "4", ")", "//", "6", "\n", "\n", "self", ".", "growthRate", "=", "growthRate", "\n", "self", ".", "dropRate", "=", "dropRate", "\n", "\n", "# self.inplanes is a global variable used across multiple", "\n", "# helper functions", "\n", "self", ".", "inplanes", "=", "growthRate", "*", "2", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "self", ".", "inplanes", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "dense1", "=", "self", ".", "_make_denseblock", "(", "block", ",", "n", ")", "\n", "self", ".", "trans1", "=", "self", ".", "_make_transition", "(", "compressionRate", ")", "\n", "self", ".", "dense2", "=", "self", ".", "_make_denseblock", "(", "block", ",", "n", ")", "\n", "self", ".", "trans2", "=", "self", ".", "_make_transition", "(", "compressionRate", ")", "\n", "self", ".", "dense3", "=", "self", ".", "_make_denseblock", "(", "block", ",", "n", ")", "\n", "self", ".", "bn", "=", "nn", ".", "BatchNorm2d", "(", "self", ".", "inplanes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "8", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "self", ".", "inplanes", ",", "num_classes", ")", "\n", "\n", "# Weight initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_denseblock": [[769, 777], ["range", "torch.nn.Sequential", "torch.nn.Sequential", "layers.append", "block"], "methods", ["None"], ["", "", "", "def", "_make_denseblock", "(", "self", ",", "block", ",", "blocks", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "blocks", ")", ":", "\n", "# Currently we fix the expansion ratio as the default value", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "growthRate", "=", "self", ".", "growthRate", ",", "dropRate", "=", "self", ".", "dropRate", ")", ")", "\n", "self", ".", "inplanes", "+=", "self", ".", "growthRate", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet._make_transition": [[778, 783], ["int", "networks.Transition", "math.floor"], "methods", ["None"], ["", "def", "_make_transition", "(", "self", ",", "compressionRate", ")", ":", "\n", "        ", "inplanes", "=", "self", ".", "inplanes", "\n", "outplanes", "=", "int", "(", "math", ".", "floor", "(", "self", ".", "inplanes", "//", "compressionRate", ")", ")", "\n", "self", ".", "inplanes", "=", "outplanes", "\n", "return", "Transition", "(", "inplanes", ",", "outplanes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.DenseNet.forward": [[784, 798], ["networks.DenseNet.conv1", "networks.DenseNet.trans1", "networks.DenseNet.trans2", "networks.DenseNet.dense3", "networks.DenseNet.bn", "networks.DenseNet.relu", "networks.DenseNet.avgpool", "networks.DenseNet.view", "networks.DenseNet.fc", "networks.DenseNet.dense1", "networks.DenseNet.dense2", "networks.DenseNet.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "trans1", "(", "self", ".", "dense1", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "trans2", "(", "self", ".", "dense2", "(", "x", ")", ")", "\n", "x", "=", "self", ".", "dense3", "(", "x", ")", "\n", "x", "=", "self", ".", "bn", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BasicBlock.__init__": [[801, 809], ["torch.nn.Module.__init__", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "expansion", "=", "1", ",", "growthRate", "=", "12", ",", "dropRate", "=", "0", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# planes = expansion * growthRate", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "inplanes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "growthRate", ",", "kernel_size", "=", "3", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "dropRate", "=", "dropRate", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BasicBlock.forward": [[810, 820], ["networks.BasicBlock.bn1", "networks.BasicBlock.relu", "networks.BasicBlock.conv1", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.dropout", "torch.dropout"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "bn1", "(", "x", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "if", "self", ".", "dropRate", ">", "0", ":", "\n", "            ", "out", "=", "F", ".", "dropout", "(", "out", ",", "p", "=", "self", ".", "dropRate", ",", "training", "=", "self", ".", "training", ")", "\n", "\n", "", "out", "=", "torch", ".", "cat", "(", "(", "x", ",", "out", ")", ",", "1", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Transition.__init__": [[823, 829], ["torch.nn.Module.__init__", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.ReLU", "torch.nn.ReLU"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "outplanes", ")", ":", "\n", "        ", "super", "(", "Transition", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "inplanes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "outplanes", ",", "kernel_size", "=", "1", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.Transition.forward": [[830, 836], ["networks.Transition.bn1", "networks.Transition.relu", "networks.Transition.conv1", "torch.avg_pool2d", "torch.avg_pool2d"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "bn1", "(", "x", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "2", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleneckC.__init__": [[845, 868], ["torch.nn.Module.__init__", "int", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.ReLU", "math.floor"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "baseWidth", ",", "cardinality", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "\"\"\" Constructor\n        Args:\n            inplanes: input channel dimensionality\n            planes: output channel dimensionality\n            baseWidth: base width.\n            cardinality: num of convolution groups.\n            stride: conv stride. Replaces pooling layer.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "D", "=", "int", "(", "math", ".", "floor", "(", "planes", "*", "(", "baseWidth", "/", "64", ")", ")", ")", "\n", "C", "=", "cardinality", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "D", "*", "C", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "D", "*", "C", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "D", "*", "C", ",", "D", "*", "C", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "groups", "=", "C", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "D", "*", "C", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "D", "*", "C", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "\n", "self", ".", "downsample", "=", "downsample", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.BottleneckC.forward": [[869, 891], ["networks.BottleneckC.conv1", "networks.BottleneckC.bn1", "networks.BottleneckC.relu", "networks.BottleneckC.conv2", "networks.BottleneckC.bn2", "networks.BottleneckC.relu", "networks.BottleneckC.conv3", "networks.BottleneckC.bn3", "torch.dropout", "torch.dropout", "networks.BottleneckC.relu", "networks.BottleneckC.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "=", "F", ".", "dropout", "(", "out", ",", "p", "=", "0.5", ",", "training", "=", "self", ".", "training", ")", "\n", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt.__init__": [[898, 934], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "torch.nn.ReLU", "torch.nn.ReLU", "torch.nn.MaxPool2d", "torch.nn.MaxPool2d", "networks.ResNeXt._make_layer", "networks.ResNeXt._make_layer", "networks.ResNeXt._make_layer", "networks.ResNeXt._make_layer", "torch.nn.AvgPool2d", "torch.nn.AvgPool2d", "torch.nn.Linear", "torch.nn.Linear", "networks.ResNeXt.modules", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt._make_layer", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt._make_layer", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt._make_layer", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt._make_layer"], ["def", "__init__", "(", "self", ",", "baseWidth", ",", "cardinality", ",", "layers", ",", "num_classes", ")", ":", "\n", "        ", "\"\"\" Constructor\n        Args:\n            baseWidth: baseWidth for ResNeXt.\n            cardinality: number of convolution groups.\n            layers: config of layers, e.g., [3, 4, 6, 3]\n            num_classes: number of classes\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "block", "=", "BottleneckC", "\n", "\n", "self", ".", "cardinality", "=", "cardinality", "\n", "self", ".", "baseWidth", "=", "baseWidth", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "self", ".", "inplanes", "=", "64", "\n", "self", ".", "output_size", "=", "64", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "1", ",", "64", ",", "7", ",", "2", ",", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool1", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "2", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "7", ")", "\n", "# self.fc = nn.Linear(512 * block.expansion, 1)", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "self", ".", "num_classes", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt._make_layer": [[935, 959], ["layers.append", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "block", "layers.append", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.BatchNorm2d", "block"], "methods", ["None"], ["", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "\"\"\" Stack n bottleneck modules where n is inferred from the depth of the network.\n        Args:\n            block: block type used to construct ResNext\n            planes: number of output channels (need to multiply by block.expansion)\n            blocks: number of blocks to be built\n            stride: factor to reduce the spatial dimensionality in the first bottleneck of the block.\n        Returns: a Module consisting of n sequential bottlenecks.\n        \"\"\"", "\n", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "self", ".", "baseWidth", ",", "self", ".", "cardinality", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "self", ".", "baseWidth", ",", "self", ".", "cardinality", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.ResNeXt.forward": [[960, 974], ["networks.ResNeXt.conv1", "networks.ResNeXt.bn1", "networks.ResNeXt.relu", "networks.ResNeXt.maxpool1", "networks.ResNeXt.layer1", "networks.ResNeXt.layer2", "networks.ResNeXt.layer3", "networks.ResNeXt.layer4", "networks.ResNeXt.avgpool", "networks.ResNeXt.view", "networks.ResNeXt.fc", "networks.ResNeXt.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.configure_model": [[19, 34], ["model.train", "model.requires_grad_", "model.modules", "isinstance", "isinstance", "m.requires_grad_"], "function", ["None"], ["def", "configure_model", "(", "model", ")", ":", "\n", "    ", "\"\"\"Configure model for use with tent.\"\"\"", "\n", "# train mode, because tent optimizes the model to minimize entropy", "\n", "model", ".", "train", "(", ")", "\n", "# disable grad, to (re-)enable only what tent updates", "\n", "model", ".", "requires_grad_", "(", "False", ")", "\n", "# configure norm for tent updates: enable grad + force batch statisics", "\n", "for", "m", "in", "model", ".", "modules", "(", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm3d", ")", ":", "\n", "            ", "m", ".", "requires_grad_", "(", "True", ")", "\n", "# force use of batch stats in train and eval modes", "\n", "m", ".", "track_running_stats", "=", "False", "\n", "m", ".", "running_mean", "=", "None", "\n", "m", ".", "running_var", "=", "None", "\n", "", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.weights_init": [[71, 77], ["torch.nn.init.xavier_normal_", "type", "type", "type", "m.weight.data.normal_", "m.bias.data.fill_"], "function", ["None"], ["", "", "def", "weights_init", "(", "m", ")", ":", "\n", "    ", "if", "type", "(", "m", ")", "==", "nn", ".", "Conv2d", "or", "type", "(", "m", ")", "==", "nn", ".", "ConvTranspose2d", ":", "\n", "        ", "nn", ".", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ".", "data", ")", "\n", "", "elif", "type", "(", "m", ")", "==", "nn", ".", "BatchNorm2d", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "1.0", ",", "0.02", ")", "\n", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.resnext101": [[976, 982], ["networks.ResNeXt"], "function", ["None"], ["", "", "def", "resnext101", "(", "baseWidth", ",", "cardinality", ",", "n_class", "=", "2", ")", ":", "\n", "    ", "\"\"\"\n    Construct ResNeXt-101.\n    \"\"\"", "\n", "model", "=", "ResNeXt", "(", "baseWidth", ",", "cardinality", ",", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "num_classes", "=", "n_class", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.setup": [[40, 91], ["print", "torch.load.to", "print", "torch.optim.Adam", "torch.optim.Adam", "print", "eval", "getattr", "utils.map_", "print", "torch.device", "torch.device", "torch.device", "torch.device", "getattr", "getattr.type().to", "torch.load.apply", "print", "networks.configure_model", "print", "print", "torch.load.parameters", "torch.optim.AdamW", "torch.optim.AdamW", "getattr", "loss_fns.append", "print", "__import__", "operator.itemgetter", "torch.cuda.is_available", "torch.cuda.is_available", "torch.load", "torch.load", "torch.load", "torch.load", "__import__", "torch.load.parameters", "__import__", "getattr.", "bounds.CheckBounds", "print", "getattr", "getattr.type", "__import__", "eval", "getattr."], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.fcn8s.apply", "home.repos.pwc.inspect_result.mathilde-b_tta.None.networks.configure_model", "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.CheckBounds"], ["def", "setup", "(", "args", ",", "n_class", ",", "dtype", ")", "->", "Tuple", "[", "\n", "Any", ",", "Any", ",", "Any", ",", "List", "[", "Callable", "]", ",", "List", "[", "float", "]", ",", "List", "[", "Callable", "]", ",", "List", "[", "float", "]", ",", "Callable", "]", ":", "\n", "    ", "print", "(", "\">>> Setting up, loading, \"", ",", "args", ".", "model_weights", ")", "\n", "cpu", ":", "bool", "=", "args", ".", "cpu", "or", "not", "torch", ".", "cuda", ".", "is_available", "(", ")", "\n", "if", "cpu", ":", "\n", "        ", "print", "(", "\"WARNING CUDA NOT AVAILABLE\"", ")", "\n", "", "device", "=", "torch", ".", "device", "(", "\"cpu\"", ")", "if", "cpu", "else", "torch", ".", "device", "(", "\"cuda\"", ")", "\n", "n_epoch", "=", "args", ".", "n_epoch", "\n", "if", "args", ".", "model_weights", ":", "\n", "        ", "if", "cpu", ":", "\n", "            ", "net", "=", "torch", ".", "load", "(", "args", ".", "model_weights", ",", "map_location", "=", "'cpu'", ")", "\n", "", "else", ":", "\n", "            ", "net", "=", "torch", ".", "load", "(", "args", ".", "model_weights", ")", "\n", "", "", "else", ":", "\n", "        ", "net_class", "=", "getattr", "(", "__import__", "(", "'networks'", ")", ",", "args", ".", "network", ")", "\n", "net", "=", "net_class", "(", "1", ",", "n_class", ")", ".", "type", "(", "dtype", ")", ".", "to", "(", "device", ")", "\n", "net", ".", "apply", "(", "weights_init", ")", "\n", "", "net", ".", "to", "(", "device", ")", "\n", "print", "(", "args", ".", "do_not_config_mod", ",", "\"args.config_mod\"", ")", "\n", "if", "args", ".", "do_not_config_mod", ":", "\n", "        ", "print", "(", "'WARNING all var updated'", ")", "\n", "", "else", ":", "\n", "        ", "net", "=", "networks", ".", "configure_model", "(", "net", ")", "\n", "print", "(", "'normalization statistics updated'", ")", "\n", "", "if", "args", ".", "saveim", ":", "\n", "        ", "print", "(", "\"WARNING: Saving masks at each epc\"", ")", "\n", "\n", "", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "net", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "l_rate", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ",", "weight_decay", "=", "args", ".", "weight_decay", ")", "\n", "if", "args", ".", "adamw", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "AdamW", "(", "net", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "l_rate", ",", "betas", "=", "(", "0.9", ",", "0.999", ")", ")", "\n", "", "print", "(", "args", ".", "target_losses", ")", "\n", "losses", "=", "eval", "(", "args", ".", "target_losses", ")", "\n", "loss_fns", ":", "List", "[", "Callable", "]", "=", "[", "]", "\n", "for", "loss_name", ",", "loss_params", ",", "type_bounds", ",", "bounds_params", ",", "fn", ",", "_", "in", "losses", ":", "\n", "        ", "loss_class", "=", "getattr", "(", "__import__", "(", "'losses'", ")", ",", "loss_name", ")", "\n", "loss_fns", ".", "append", "(", "loss_class", "(", "**", "loss_params", ",", "dtype", "=", "dtype", ",", "fn", "=", "fn", ")", ")", "\n", "print", "(", "\"bounds_params\"", ",", "bounds_params", ")", "\n", "if", "bounds_params", "!=", "None", "and", "type_bounds", "!=", "'PreciseBounds'", ":", "\n", "            ", "bool_predexist", "=", "CheckBounds", "(", "**", "bounds_params", ")", "\n", "print", "(", "\"size prior file properly read : \"", ",", "bool_predexist", ")", "\n", "if", "not", "bool_predexist", ":", "\n", "                ", "n_epoch", "=", "0", "\n", "", "", "", "momfn", "=", "getattr", "(", "__import__", "(", "'utils'", ")", ",", "loss_params", "[", "'moment_fn'", "]", ")", "\n", "loss_weights", "=", "map_", "(", "itemgetter", "(", "5", ")", ",", "losses", ")", "\n", "\n", "if", "args", ".", "scheduler", ":", "\n", "        ", "scheduler", "=", "getattr", "(", "__import__", "(", "'scheduler'", ")", ",", "args", ".", "scheduler", ")", "(", "**", "eval", "(", "args", ".", "scheduler_params", ")", ")", "\n", "", "else", ":", "\n", "        ", "scheduler", "=", "''", "\n", "\n", "", "return", "net", ",", "optimizer", ",", "device", ",", "loss_fns", ",", "loss_weights", ",", "scheduler", ",", "n_epoch", ",", "momfn", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.do_epoch": [[93, 324], ["len", "torch.tensor", "torch.tensor", "eval", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "numpy.zeros().astype", "utils.tqdm_", "torch.index_select().mean().cpu().numpy().item", "torch.index_select().mean().cpu().numpy().item", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu().numpy", "len", "len", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "len", "warnings.catch_warnings", "warnings.simplefilter", "dice3d.dice3d", "utils.get_mom_posmed", "utils.get_mom_posmed", "utils.get_mom_posav", "utils.get_mom_posav", "utils.get_linreg_coef", "utils.get_linreg_coef", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select().sum().cpu().numpy", "torch.index_select().sum().cpu().numpy", "mask_pos.sum().cpu().numpy", "torch.index_select().sum().cpu().numpy", "torch.index_select().sum().cpu().numpy", "gt_pos.sum().cpu().numpy", "loss_se.mean().item", "loss_cons.mean().item", "loss_tot.mean().item", "torch.index_select().mean().cpu().numpy.mean", "size_mean_pos.mean", "torch.index_select().mean().cpu().numpy.mean", "gt_size_mean_pos.mean", "pandas.DataFrame", "pd.DataFrame.to_csv", "pandas.DataFrame", "pd.DataFrame.to_csv", "numpy.zeros", "zip", "len", "len", "net", "torch.softmax", "utils.probs2one_hot", "torch.zeros().to", "torch.zeros().to", "enumerate", "utils.dice_coef", "slice", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.FloatTensor().unsqueeze().repeat", "torch.FloatTensor().unsqueeze().repeat", "slice", "utils.tqdm_.set_postfix", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu().numpy", "torch.index_select().mean().cpu", "torch.index_select().mean().cpu", "torch.index_select().mean().cpu", "torch.index_select().mean().cpu", "torch.index_select().mean().cpu", "torch.index_select().mean().cpu", "pathlib.Path", "pathlib.Path", "e.to", "len", "len", "optimizer.zero_grad", "utils.resize", "utils.resize", "len", "len", "len", "zip", "loss_fn.backward", "optimizer.step", "predicted_mask.detach", "target_gt.detach", "torch.round", "torch.round", "momfn", "momfn", "momfn", "momfn", "momfn", "utils.probs2class().cpu().detach", "utils.probs2class().detach", "len", "torch.stack().sum", "torch.stack().sum", "torch.index_select().sum().cpu", "torch.index_select().sum().cpu", "mask_pos.sum().cpu", "torch.index_select().sum().cpu", "torch.index_select().sum().cpu", "gt_pos.sum().cpu", "loss_se.mean", "loss_cons.mean", "loss_tot.mean", "all_sizes2.cpu", "all_moments_gt.cpu", "numpy.repeat().transpose", "numpy.repeat", "all_moments.cpu", "all_moments_pred.cpu", "f.split", "utils.resize", "torch.zeros", "torch.zeros", "loss_fn", "loss_kw.append", "loss_fn", "loss_kw.append", "utils.resize.detach", "predicted_mask.type", "predicted_mask.type", "target_gt.type", "target_gt.type", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "warnings.catch_warnings", "warnings.filterwarnings", "warnings.simplefilter", "utils.probs2class", "utils.save_images", "all_dices[].mean", "all_sizes[].mean", "all_sizes[].mean", "stat_dict.items", "torch.index_select().mean().cpu", "torch.index_select().mean().cpu", "torch.index_select().mean", "torch.index_select().mean", "torch.index_select().mean", "torch.index_select().mean", "torch.index_select().mean", "torch.index_select().mean", "str", "len", "loss_cons_prior.detach", "loss_1.detach", "loss_kw.append", "loss_1.detach", "eval", "utils.probs2class().cpu", "utils.probs2class", "torch.stack", "torch.stack", "torch.einsum", "torch.einsum", "utils.save_images_ent", "torch.index_select().sum", "torch.index_select().sum", "mask_pos.sum", "torch.index_select().sum", "torch.index_select().sum", "gt_pos.sum", "str", "numpy.repeat", "str", "eval", "est_prop.detach", "torch.FloatTensor", "torch.FloatTensor", "torch.einsum.detach", "torch.index_select().mean", "torch.index_select().mean", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "str", "len", "loss_cons_prior.detach", "utils.get_subj_nb", "utils.probs2class", "torch.index_select", "torch.index_select", "torch.index_select", "torch.index_select", "str", "torch.index_select", "torch.index_select"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.dice3d.dice3d", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_mom_posmed", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_mom_posmed", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_mom_posav", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_mom_posav", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_linreg_coef", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_linreg_coef", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2class", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_images", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2class", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_images_ent", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_subj_nb", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2class"], ["", "def", "do_epoch", "(", "args", ",", "mode", ":", "str", ",", "net", ":", "Any", ",", "device", ":", "Any", ",", "epc", ":", "int", ",", "\n", "loss_fns", ":", "List", "[", "Callable", "]", ",", "loss_weights", ":", "List", "[", "float", "]", ",", "\n", "new_w", ":", "int", ",", "C", ":", "int", ",", "metric_axis", ":", "List", "[", "int", "]", ",", "savedir", ":", "str", "=", "\"\"", ",", "\n", "optimizer", ":", "Any", "=", "None", ",", "target_loader", ":", "Any", "=", "None", ",", "best_dice3d_val", ":", "Any", "=", "None", ",", "momfn", ":", "Any", "=", "None", ",", "mom_est", ":", "Any", "=", "None", ",", "mom_coef_vec", ":", "Any", "=", "None", ",", "keep_lambda", ":", "Any", "=", "None", ")", ":", "\n", "    ", "assert", "mode", "in", "[", "\"train\"", ",", "\"val\"", "]", "\n", "L", ":", "int", "=", "len", "(", "loss_fns", ")", "\n", "indices", "=", "torch", ".", "tensor", "(", "metric_axis", ",", "device", "=", "device", ")", "\n", "desc", "=", "f\">> TTA ({epc})\"", "\n", "\n", "total_it_t", ",", "total_images_t", "=", "len", "(", "target_loader", ")", ",", "len", "(", "target_loader", ".", "dataset", ")", "\n", "total_iteration", "=", "total_it_t", "\n", "total_images", "=", "total_images_t", "\n", "\n", "if", "args", ".", "debug", ":", "\n", "        ", "total_iteration", "=", "10", "\n", "", "pho", "=", "1", "\n", "dtype", "=", "eval", "(", "args", ".", "dtype", ")", "\n", "\n", "all_dices", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_sizes", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_gt_sizes", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_sizes2", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_moments", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_moments_pred", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_moments_pred0", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_moments_gt", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_moments_gt0", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_inter_card", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_card_gt", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_card_pred", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_gt", "=", "[", "]", "\n", "all_pred", "=", "[", "]", "\n", "if", "args", ".", "do_hd", "or", "args", ".", "do_asd", ":", "\n", "        ", "all_gt", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "args", ".", "wh", ",", "args", ".", "wh", ")", ",", "dtype", "=", "dtype", ")", "\n", "all_pred", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "args", ".", "wh", ",", "args", ".", "wh", ")", ",", "dtype", "=", "dtype", ")", "\n", "", "loss_log", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "loss_cons", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "loss_se", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "loss_tot", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "posim_log", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "haussdorf_log", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_grp", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "total_images", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "device", ")", "\n", "all_pnames", "=", "np", ".", "zeros", "(", "[", "total_images", "]", ")", ".", "astype", "(", "'U256'", ")", "\n", "dice_3d_log", ",", "dice_3d_sd_log", "=", "0", ",", "0", "\n", "hd_3d_log", ",", "asd_3d_log", ",", "hd_3d_sd_log", ",", "asd_3d_sd_log", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "tq_iter", "=", "tqdm_", "(", "enumerate", "(", "target_loader", ")", ",", "total", "=", "total_iteration", ",", "desc", "=", "desc", ")", "\n", "done", ":", "int", "=", "0", "\n", "n_warmup", "=", "args", ".", "n_warmup", "\n", "mult_lw", "=", "[", "pho", "**", "(", "epc", "-", "n_warmup", "+", "1", ")", "]", "*", "len", "(", "loss_weights", ")", "\n", "mult_lw", "[", "0", "]", "=", "1", "\n", "loss_weights", "=", "[", "a", "*", "b", "for", "a", ",", "b", "in", "zip", "(", "loss_weights", ",", "mult_lw", ")", "]", "\n", "losses_vec", ",", "target_vec", ",", "baseline_target_vec", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "pen_count", "=", "0", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "count_losses", "=", "0", "\n", "for", "j", ",", "target_data", "in", "tq_iter", ":", "\n", "            ", "target_data", "[", "1", ":", "]", "=", "[", "e", ".", "to", "(", "device", ")", "for", "e", "in", "target_data", "[", "1", ":", "]", "]", "# Move all tensors to device", "\n", "filenames_target", ",", "target_image", ",", "target_gt", "=", "target_data", "[", ":", "3", "]", "\n", "# print(torch.unique(target_gt))", "\n", "# print(\"target\", filenames_target)", "\n", "labels", "=", "target_data", "[", "3", ":", "3", "+", "L", "]", "\n", "bounds", "=", "target_data", "[", "3", "+", "L", ":", "]", "\n", "filenames_target", "=", "[", "f", ".", "split", "(", "'.nii'", ")", "[", "0", "]", "for", "f", "in", "filenames_target", "]", "\n", "assert", "len", "(", "labels", ")", "==", "len", "(", "bounds", ")", ",", "len", "(", "bounds", ")", "\n", "B", "=", "len", "(", "target_image", ")", "\n", "# Reset gradients", "\n", "if", "optimizer", ":", "\n", "                ", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "# Forward", "\n", "", "pred_logits", "=", "net", "(", "target_image", ")", "\n", "pred_probs", ":", "Tensor", "=", "F", ".", "softmax", "(", "pred_logits", "/", "args", ".", "softmax_temp", ",", "dim", "=", "1", ")", "\n", "if", "new_w", ">", "0", ":", "\n", "                ", "pred_probs", "=", "resize", "(", "pred_probs", ",", "new_w", ")", "\n", "labels", "=", "[", "resize", "(", "label", ",", "new_w", ")", "for", "label", "in", "labels", "]", "\n", "target", "=", "resize", "(", "target", ",", "new_w", ")", "\n", "", "predicted_mask", ":", "Tensor", "=", "probs2one_hot", "(", "pred_probs", ")", "# Used only for dice computation", "\n", "#print(filenames_target,\"inertia_gt\", inertia_gt,\"inertia_pred\", inertia_pred,\"inertia_probs\",", "\n", "#      inertia_probs,\"gt size\",size_gt,\"pred size\",size_pred)", "\n", "# print(torch.unique(predicted_mask))", "\n", "assert", "len", "(", "bounds", ")", "==", "len", "(", "loss_fns", ")", "==", "len", "(", "loss_weights", ")", "\n", "#if epc < n_warmup:", "\n", "#    loss_weights = [0] * len(loss_weights)", "\n", "loss", ":", "Tensor", "=", "torch", ".", "zeros", "(", "1", ",", "requires_grad", "=", "True", ")", ".", "to", "(", "device", ")", "\n", "loss_vec", "=", "[", "]", "\n", "loss_kw", "=", "[", "]", "\n", "#print(len(loss_fns), len(labels), len(loss_weights), len(bounds))", "\n", "for", "i", ",", "(", "loss_fn", ",", "label", ",", "w", ",", "bound", ")", "in", "enumerate", "(", "zip", "(", "loss_fns", ",", "labels", ",", "loss_weights", ",", "bounds", ")", ")", ":", "\n", "                ", "if", "\"EntKLProp\"", "in", "eval", "(", "args", ".", "target_losses", ")", "[", "i", "]", "[", "0", "]", ":", "\n", "                    ", "if", "epc", ">", "0", "and", "args", ".", "update_mom_est", "and", "i", "==", "0", ":", "#i=0 to prevent wrong update if two constraints, only update firsst", "\n", "                        ", "loss_fn", ".", "mom_est", "=", "mom_est", "\n", "", "if", "epc", ">", "0", "and", "args", ".", "update_lin_reg", ":", "\n", "                        ", "if", "args", ".", "ind_mom", "==", "1", ":", "\n", "                            ", "loss_fn", ".", "reg", ",", "loss_fn", ".", "reg2", "=", "mom_coef_vec", "\n", "", "else", ":", "\n", "                            ", "loss_fn", ".", "reg", "=", "mom_coef_vec", "\n", "", "", "loss_1", ",", "loss_cons_prior", ",", "est_prop", "=", "loss_fn", "(", "pred_probs", ",", "label", ",", "bound", ",", "epc", ")", "\n", "if", "epc", "==", "0", "and", "args", ".", "adw", ":", "\n", "                        ", "first_loss", "=", "loss_cons_prior", ".", "detach", "(", ")", "\n", "keep_lambda", "=", "1", "/", "first_loss", "\n", "", "loss_kw", ".", "append", "(", "loss_1", ".", "detach", "(", ")", ")", "\n", "if", "args", ".", "n_warmup", ">", "0", "and", "epc", "<", "n_warmup", ":", "\n", "                        ", "loss", "=", "loss_1", "\n", "", "else", ":", "\n", "                        ", "loss", "=", "loss_1", "+", "keep_lambda", "*", "loss_cons_prior", "\n", "loss_kw", ".", "append", "(", "keep_lambda", "*", "loss_cons_prior", ".", "detach", "(", ")", ")", "\n", "", "", "else", ":", "\n", "                    ", "loss", "=", "loss_fn", "(", "pred_probs", ",", "label", ",", "bound", ")", "\n", "loss", "=", "w", "*", "loss", "\n", "loss_1", "=", "loss", "\n", "loss_kw", ".", "append", "(", "loss_1", ".", "detach", "(", ")", ")", "\n", "", "", "if", "optimizer", ":", "\n", "                ", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "", "dices", ",", "inter_card", ",", "card_gt", ",", "card_pred", "=", "dice_coef", "(", "predicted_mask", ".", "detach", "(", ")", ",", "target_gt", ".", "detach", "(", ")", ")", "\n", "assert", "dices", ".", "shape", "==", "(", "B", ",", "C", ")", ",", "(", "dices", ".", "shape", ",", "B", ",", "C", ")", "\n", "sm_slice", "=", "slice", "(", "done", ",", "done", "+", "B", ")", "# Values only for current batch", "\n", "all_dices", "[", "sm_slice", ",", "...", "]", "=", "dices", "\n", "if", "eval", "(", "args", ".", "target_losses", ")", "[", "0", "]", "[", "0", "]", "in", "[", "\"EntKLProp\"", "]", ":", "\n", "                ", "all_sizes", "[", "sm_slice", ",", "...", "]", "=", "torch", ".", "round", "(", "\n", "est_prop", ".", "detach", "(", ")", "*", "target_image", ".", "shape", "[", "2", "]", "*", "target_image", ".", "shape", "[", "3", "]", ")", "\n", "", "all_sizes2", "[", "sm_slice", ",", "...", "]", "=", "torch", ".", "sum", "(", "predicted_mask", ",", "dim", "=", "(", "2", ",", "3", ")", ")", "\n", "all_moments", "[", "sm_slice", ",", "...", "]", "=", "momfn", "(", "pred_probs", ".", "detach", "(", ")", ")", "[", ":", ",", ":", ",", "args", ".", "ind_mom", "]", "\n", "all_moments_pred0", "[", "sm_slice", ",", "...", "]", "=", "momfn", "(", "predicted_mask", ".", "type", "(", "torch", ".", "float32", ")", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "all_moments_pred", "[", "sm_slice", ",", "...", "]", "=", "momfn", "(", "predicted_mask", ".", "type", "(", "torch", ".", "float32", ")", ")", "[", ":", ",", ":", ",", "args", ".", "ind_mom", "]", "\n", "all_moments_gt", "[", "sm_slice", ",", "...", "]", "=", "momfn", "(", "target_gt", ".", "type", "(", "torch", ".", "float32", ")", ")", "[", ":", ",", ":", ",", "args", ".", "ind_mom", "]", "\n", "all_moments_gt0", "[", "sm_slice", ",", "...", "]", "=", "momfn", "(", "target_gt", ".", "type", "(", "torch", ".", "float32", ")", ")", "[", ":", ",", ":", ",", "0", "]", "\n", "all_gt_sizes", "[", "sm_slice", ",", "...", "]", "=", "torch", ".", "sum", "(", "target_gt", ",", "dim", "=", "(", "2", ",", "3", ")", ")", "\n", "all_grp", "[", "sm_slice", ",", "...", "]", "=", "torch", ".", "FloatTensor", "(", "get_subj_nb", "(", "filenames_target", ")", ")", ".", "unsqueeze", "(", "1", ")", ".", "repeat", "(", "1", ",", "C", ")", "\n", "all_pnames", "[", "sm_slice", "]", "=", "filenames_target", "\n", "all_inter_card", "[", "sm_slice", ",", "...", "]", "=", "inter_card", "\n", "all_card_gt", "[", "sm_slice", ",", "...", "]", "=", "card_gt", "\n", "all_card_pred", "[", "sm_slice", ",", "...", "]", "=", "card_pred", "\n", "if", "args", ".", "do_hd", "or", "args", ".", "do_asd", ":", "\n", "                ", "all_pred", "[", "sm_slice", ",", "...", "]", "=", "probs2class", "(", "predicted_mask", "[", ":", ",", ":", ",", ":", ",", ":", "]", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", "\n", "all_gt", "[", "sm_slice", ",", "...", "]", "=", "probs2class", "(", "target_gt", ")", ".", "detach", "(", ")", "\n", "", "loss_se", "[", "sm_slice", "]", "=", "loss_kw", "[", "0", "]", "\n", "if", "len", "(", "loss_kw", ")", ">", "1", ":", "\n", "                ", "loss_cons", "[", "sm_slice", "]", "=", "loss_kw", "[", "1", "]", "\n", "#loss_tot[sm_slice] = np.sum(loss_kw)", "\n", "loss_tot", "[", "sm_slice", "]", "=", "torch", ".", "stack", "(", "loss_kw", ",", "dim", "=", "0", ")", ".", "sum", "(", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "                ", "loss_cons", "[", "sm_slice", "]", "=", "0", "\n", "loss_tot", "[", "sm_slice", "]", "=", "loss_kw", "[", "0", "]", "\n", "# # Save images", "\n", "", "if", "savedir", "and", "args", ".", "saveim", "and", "mode", "==", "\"val\"", ":", "\n", "                ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "                    ", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ",", "category", "=", "UserWarning", ")", "\n", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "predicted_class", ":", "Tensor", "=", "probs2class", "(", "pred_probs", ")", "\n", "save_images", "(", "predicted_class", ",", "filenames_target", ",", "savedir", ",", "mode", ",", "epc", ",", "False", ")", "\n", "if", "args", ".", "entmap", ":", "\n", "                        ", "ent_map", "=", "torch", ".", "einsum", "(", "\"bcwh,bcwh->bwh\"", ",", "[", "-", "pred_probs", ",", "(", "pred_probs", "+", "1e-10", ")", ".", "log", "(", ")", "]", ")", "\n", "save_images_ent", "(", "ent_map", ".", "detach", "(", ")", ",", "filenames_target", ",", "savedir", ",", "'ent_map'", ",", "epc", ")", "\n", "\n", "# Logging", "\n", "", "", "", "big_slice", "=", "slice", "(", "0", ",", "done", "+", "B", ")", "# Value for current and previous batches", "\n", "stat_dict", "=", "{", "**", "{", "f\"DSC{n}\"", ":", "all_dices", "[", "big_slice", ",", "n", "]", ".", "mean", "(", ")", "for", "n", "in", "metric_axis", "}", ",", "\n", "**", "{", "f\"SZ{n}\"", ":", "all_sizes", "[", "big_slice", ",", "n", "]", ".", "mean", "(", ")", "for", "n", "in", "metric_axis", "}", "}", "\n", "\n", "size_dict", "=", "{", "**", "{", "f\"SZ{n}\"", ":", "all_sizes", "[", "big_slice", ",", "n", "]", ".", "mean", "(", ")", "for", "n", "in", "metric_axis", "}", "}", "\n", "nice_dict", "=", "{", "k", ":", "f\"{v:.4f}\"", "for", "(", "k", ",", "v", ")", "in", "stat_dict", ".", "items", "(", ")", "}", "\n", "done", "+=", "B", "\n", "tq_iter", ".", "set_postfix", "(", "nice_dict", ")", "\n", "", "", "if", "args", ".", "dice_3d", "and", "(", "mode", "==", "'val'", ")", ":", "\n", "        ", "dice_3d_log", ",", "dice_3d_sd_log", ",", "asd_3d_log", ",", "asd_3d_sd_log", ",", "hd_3d_log", ",", "hd_3d_sd_log", "=", "dice3d", "(", "all_grp", ",", "\n", "all_inter_card", ",", "\n", "all_card_gt", ",", "\n", "all_card_pred", ",", "\n", "all_pred", ",", "all_gt", ",", "\n", "all_pnames", ",", "\n", "metric_axis", ",", "\n", "args", ".", "pprint", ",", "\n", "args", ".", "do_hd", ",", "\n", "args", ".", "do_asd", ",", "\n", "best_dice3d_val", ",", "savedir", ")", "\n", "", "dice_2d", "=", "torch", ".", "index_select", "(", "all_dices", ",", "1", ",", "indices", ")", ".", "mean", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "item", "(", ")", "\n", "target_vec", "=", "[", "dice_3d_log", ",", "dice_3d_sd_log", ",", "asd_3d_log", ",", "asd_3d_sd_log", ",", "hd_3d_log", ",", "hd_3d_sd_log", ",", "dice_2d", "]", "\n", "size_mean", "=", "torch", ".", "index_select", "(", "all_sizes2", ",", "1", ",", "indices", ")", ".", "mean", "(", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "#mom_med = all_moments_pred.mean(dim=0).cpu().numpy().tolist()", "\n", "#mom_med0 = all_moments_pred0.mean(dim=0).cpu().numpy().tolist()", "\n", "if", "args", ".", "med", ":", "\n", "        ", "mom_est", "=", "get_mom_posmed", "(", "C", ",", "all_moments_pred", ",", "all_sizes2", ",", "args", ".", "th", ")", "\n", "mom_est0", "=", "get_mom_posmed", "(", "C", ",", "all_moments_pred0", ",", "all_sizes2", ",", "args", ".", "th", ")", "\n", "", "else", ":", "\n", "        ", "mom_est", "=", "get_mom_posav", "(", "C", ",", "all_moments_pred", ",", "all_sizes2", ",", "args", ".", "th", ")", "\n", "#mom_med_gt = get_mom_posav(C, all_moments_gt, all_sizes2, args.th)", "\n", "#mom_med_gt0 = get_mom_posav(C, all_moments_gt0, all_sizes2, args.th)", "\n", "#print(mom_med_gt0,mom_med_gt)", "\n", "mom_est0", "=", "get_mom_posav", "(", "C", ",", "all_moments_pred0", ",", "all_sizes2", ",", "args", ".", "th", ")", "\n", "", "if", "args", ".", "update_lin_reg", ":", "\n", "        ", "mom_coef", "=", "get_linreg_coef", "(", "C", ",", "all_moments_pred", ",", "all_sizes2", ",", "args", ".", "th", ")", "\n", "mom_coef0", "=", "get_linreg_coef", "(", "C", ",", "all_moments_pred0", ",", "all_sizes2", ",", "args", ".", "th", ")", "\n", "#print(mom_coef)", "\n", "", "size_gt_mean", "=", "torch", ".", "index_select", "(", "all_gt_sizes", ",", "1", ",", "indices", ")", ".", "mean", "(", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "mask_pos", "=", "torch", ".", "index_select", "(", "all_sizes2", ",", "1", ",", "indices", ")", "!=", "0", "\n", "gt_pos", "=", "torch", ".", "index_select", "(", "all_gt_sizes", ",", "1", ",", "indices", ")", "!=", "0", "\n", "size_mean_pos", "=", "torch", ".", "index_select", "(", "all_sizes2", ",", "1", ",", "indices", ")", ".", "sum", "(", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "/", "mask_pos", ".", "sum", "(", "\n", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_size_mean_pos", "=", "torch", ".", "index_select", "(", "all_gt_sizes", ",", "1", ",", "indices", ")", ".", "sum", "(", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "/", "gt_pos", ".", "sum", "(", "\n", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "size_mean2", "=", "torch", ".", "index_select", "(", "all_sizes2", ",", "1", ",", "indices", ")", ".", "mean", "(", "dim", "=", "0", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "losses_vec", "=", "[", "loss_se", ".", "mean", "(", ")", ".", "item", "(", ")", ",", "loss_cons", ".", "mean", "(", ")", ".", "item", "(", ")", ",", "loss_tot", ".", "mean", "(", ")", ".", "item", "(", ")", ",", "size_mean", ".", "mean", "(", ")", ",", "\n", "size_mean_pos", ".", "mean", "(", ")", ",", "size_gt_mean", ".", "mean", "(", ")", ",", "gt_size_mean_pos", ".", "mean", "(", ")", "]", "\n", "if", "args", ".", "ind_mom", "==", "1", ":", "\n", "        ", "mom_vec", "=", "[", "mom_est0", ",", "mom_est", "]", "\n", "", "else", ":", "\n", "        ", "mom_vec", "=", "mom_est0", "\n", "", "if", "not", "args", ".", "update_lin_reg", ":", "\n", "        ", "mom_coef_vec", "=", "[", "]", "\n", "", "else", ":", "\n", "        ", "if", "args", ".", "ind_mom", "==", "1", ":", "\n", "            ", "mom_coef_vec", "=", "[", "mom_coef0", ",", "mom_coef", "]", "\n", "", "else", ":", "\n", "            ", "mom_coef_vec", "=", "mom_coef0", "\n", "", "", "if", "not", "epc", "%", "50", ":", "\n", "#print(all_pnames.shape,mom_est0,np.repeat(str(mom_est0),len(all_pnames)).transpose().shape)", "\n", "        ", "df_t", "=", "pd", ".", "DataFrame", "(", "{", "\n", "\"val_ids\"", ":", "all_pnames", ",", "\n", "\"pred_size\"", ":", "all_sizes2", ".", "cpu", "(", ")", "}", ")", "\n", "df_t", ".", "to_csv", "(", "Path", "(", "savedir", ",", "args", ".", "train_grp_regex", "+", "mode", "+", "str", "(", "epc", ")", "+", "\"sizes.csv\"", ")", ",", "mode", "=", "'a'", ",", "float_format", "=", "\"%.4f\"", ",", "index_label", "=", "\"epoch\"", ")", "\n", "df_t", "=", "pd", ".", "DataFrame", "(", "{", "\n", "\"val_ids\"", ":", "all_pnames", ",", "\n", "\"gt_moment\"", ":", "all_moments_gt", ".", "cpu", "(", ")", ",", "\n", "\"est_moment_0\"", ":", "np", ".", "repeat", "(", "str", "(", "mom_est0", ")", ",", "len", "(", "all_pnames", ")", ")", ".", "transpose", "(", ")", ",", "\n", "\"est_moment_1\"", ":", "np", ".", "repeat", "(", "str", "(", "mom_est", ")", ",", "len", "(", "all_pnames", ")", ")", ",", "\n", "\"proposal_moment\"", ":", "all_moments", ".", "cpu", "(", ")", ",", "\n", "\"pred_moment\"", ":", "all_moments_pred", ".", "cpu", "(", ")", "}", ")", "\n", "df_t", ".", "to_csv", "(", "Path", "(", "savedir", ",", "args", ".", "train_grp_regex", "+", "mode", "+", "str", "(", "epc", ")", "+", "\"ind_mom\"", "+", "str", "(", "args", ".", "ind_mom", ")", "+", "\"moment.csv\"", ")", ",", "mode", "=", "'a'", ",", "float_format", "=", "\"%.4f\"", ",", "index_label", "=", "\"epoch\"", ")", "\n", "", "return", "losses_vec", ",", "target_vec", ",", "mom_vec", ",", "mom_coef_vec", ",", "keep_lambda", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.run_subj": [[326, 486], ["eval", "dataloader.get_loaders", "print", "numpy.zeros", "numpy.zeros", "numpy.zeros", "print", "print", "open", "range", "open.close", "print", "print", "main.do_epoch", "print", "pathlib.Path", "pathlib.Path.exists", "torch.save", "torch.save", "shutil.rmtree", "pandas.DataFrame", "df_t.append.to_csv", "utils.exp_lr_scheduler", "torch.no_grad", "torch.no_grad", "main.do_epoch", "pathlib.Path", "pathlib.Path.exists", "torch.save", "torch.save", "pathlib.Path", "pathlib.Path.exists", "str", "print", "open", "f.write", "shutil.rmtree", "pathlib.Path", "pathlib.Path", "df_t.append.append", "pathlib.Path", "open", "f.write", "shutil.rmtree", "pathlib.Path", "open", "f.write", "shutil.rmtree", "str", "pathlib.Path", "shutil.copytree", "pathlib.Path", "shutil.copytree", "pathlib.Path", "shutil.copytree", "str", "pathlib.Path", "pathlib.Path", "errors.extend", "numpy.int", "numpy.int", "numpy.int", "str", "pathlib.Path", "pathlib.Path", "errors.extend", "str", "pathlib.Path", "pathlib.Path", "errors.extend", "str", "str", "str", "args.target_folders.split", "str"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.get_loaders", "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.do_epoch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.exp_lr_scheduler", "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.do_epoch"], ["", "def", "run_subj", "(", "args", ",", "net", ",", "optimizer", ",", "device", ",", "loss_fns", ",", "loss_weights", ",", "scheduler", ",", "n_epoch", ",", "momfn", ")", ":", "\n", "    ", "dtype", "=", "eval", "(", "args", ".", "dtype", ")", "\n", "shuffle", "=", "True", "\n", "metric_axis", ":", "List", "=", "args", ".", "metric_axis", "\n", "lr", ":", "float", "=", "args", ".", "l_rate", "\n", "savedir", ":", "str", "=", "args", ".", "workdir", "\n", "if", "args", ".", "oneslice", ":", "\n", "        ", "n_epoch", "=", "100", "\n", "", "else", ":", "\n", "        ", "n_epoch", ":", "int", "=", "args", ".", "n_epoch", "\n", "", "n_class", "=", "args", ".", "n_class", "\n", "subj", "=", "args", ".", "train_grp_regex", "\n", "if", "\"prostate\"", "in", "savedir", ":", "\n", "        ", "if", "args", ".", "thl", "==", "\"low\"", ":", "\n", "#args.th = [[0, 100], [384 * 384, 12000]]", "\n", "            ", "args", ".", "th", "=", "[", "[", "0", ",", "100", "]", ",", "[", "384", "*", "384", ",", "384", "*", "384", "]", "]", "\n", "", "else", ":", "\n", "            ", "args", ".", "th", "=", "[", "[", "0", ",", "4000", "]", ",", "[", "384", "*", "384", ",", "12000", "]", "]", "\n", "", "", "else", ":", "\n", "        ", "if", "args", ".", "thl", "==", "\"low\"", ":", "\n", "            ", "args", ".", "th", "=", "[", "[", "0", ",", "100", ",", "100", ",", "100", ",", "100", "]", ",", "[", "256", "*", "256", ",", "256", "*", "256", ",", "256", "*", "256.0", ",", "256", "*", "256", ",", "256", "*", "256", "]", "]", "\n", "", "else", ":", "\n", "# args.th = [[0,2214.0, 2498.0, 2243.5, 1853.0],[256*256,6642.0, 7494.0, 6730.5, 5559.0]]", "\n", "            ", "args", ".", "th", "=", "[", "[", "0", ",", "2214.0", ",", "1498.0", ",", "1243.5", ",", "853.0", "]", ",", "[", "256", "*", "256", ",", "7642.0", ",", "8494.0", ",", "7730.5", ",", "6559.0", "]", "]", "\n", "\n", "", "", "target_loader", ",", "target_loader_val", "=", "get_loaders", "(", "args", ",", "args", ".", "target_dataset", ",", "args", ".", "target_folders", ",", "\n", "args", ".", "batch_size", ",", "args", ".", "n_class", ",", "\n", "args", ".", "debug", ",", "args", ".", "in_memory", ",", "dtype", ",", "shuffle", ",", "\"target\"", ",", "\n", "args", ".", "val_target_folders", ")", "\n", "\n", "print", "(", "\"metric axis\"", ",", "metric_axis", ")", "\n", "best_dice_pos", ":", "Tensor", "=", "np", ".", "zeros", "(", "1", ")", "\n", "best_dice", ":", "Tensor", "=", "np", ".", "zeros", "(", "1", ")", "\n", "best_hd3d_dice", ":", "Tensor", "=", "np", ".", "zeros", "(", "1", ")", "\n", "best_3d_dice", ":", "Tensor", "=", "0", "\n", "last_3d_dice", ":", "Tensor", "=", "0", "\n", "best_3d_asd", ":", "Tensor", "=", "10000", "\n", "last_3d_asd", ":", "Tensor", "=", "10000", "\n", "print", "(", "\"Results saved in \"", ",", "savedir", ")", "\n", "print", "(", "\">>> Starting the training\"", ")", "\n", "df", "=", "open", "(", "subj", ",", "'w'", ")", "\n", "mom_est", "=", "[", "]", "\n", "mom_coef_vec", "=", "[", "]", "\n", "keep_lambda", "=", "1", "\n", "errors", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "n_epoch", ")", ":", "\n", "\n", "        ", "if", "args", ".", "mode", "==", "\"makeim\"", ":", "\n", "            ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "\n", "                ", "val_losses_vec", ",", "val_target_vec", ",", "mom_est", ",", "mom_coef_vec", ",", "keep_lambda", "=", "do_epoch", "(", "args", ",", "\"val\"", ",", "net", ",", "device", ",", "\n", "i", ",", "loss_fns", ",", "\n", "loss_weights", ",", "\n", "args", ".", "resize", ",", "\n", "n_class", ",", "metric_axis", ",", "\n", "savedir", "=", "savedir", ",", "\n", "target_loader", "=", "target_loader", ",", "\n", "best_dice3d_val", "=", "best_3d_dice", ",", "momfn", "=", "momfn", ",", "mom_est", "=", "mom_est", ",", "mom_coef_vec", "=", "mom_coef_vec", ",", "keep_lambda", "=", "keep_lambda", ")", "\n", "#tra_losses_vec = val_losses_vec", "\n", "#tra_target_vec = val_target_vec", "\n", "", "", "else", ":", "\n", "            ", "val_losses_vec", ",", "val_target_vec", ",", "mom_est", ",", "mom_coef_vec", ",", "keep_lambda", "=", "do_epoch", "(", "args", ",", "\"val\"", ",", "net", ",", "device", ",", "\n", "i", ",", "loss_fns", ",", "\n", "loss_weights", ",", "\n", "args", ".", "resize", ",", "\n", "n_class", ",", "metric_axis", ",", "\n", "savedir", "=", "savedir", ",", "\n", "optimizer", "=", "optimizer", ",", "\n", "target_loader", "=", "target_loader", ",", "\n", "best_dice3d_val", "=", "best_3d_dice", ",", "momfn", "=", "momfn", ",", "mom_est", "=", "mom_est", ",", "mom_coef_vec", "=", "mom_coef_vec", ",", "keep_lambda", "=", "keep_lambda", ")", "\n", "\n", "#tra_losses_vec = val_losses_vec", "\n", "#tra_target_vec = val_target_vec", "\n", "", "current_val_target_3d_dice", "=", "val_target_vec", "[", "0", "]", "\n", "current_val_target_3d_asd", "=", "val_target_vec", "[", "2", "]", "\n", "if", "args", ".", "dice_3d", ":", "\n", "            ", "if", "current_val_target_3d_dice", ">", "best_3d_dice", ":", "\n", "                ", "best_3d_dice", "=", "current_val_target_3d_dice", "\n", "with", "open", "(", "Path", "(", "savedir", ",", "subj", "+", "\"3dbestepoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "str", "(", "i", ")", "+", "','", "+", "str", "(", "best_3d_dice", ")", ")", "\n", "", "best_folder_3d", "=", "Path", "(", "savedir", ",", "subj", "+", "\"best_epoch_3d\"", ")", "\n", "if", "best_folder_3d", ".", "exists", "(", ")", ":", "\n", "                    ", "rmtree", "(", "best_folder_3d", ")", "\n", "", "if", "args", ".", "saveim", ":", "\n", "                    ", "try", ":", "\n", "                        ", "copytree", "(", "Path", "(", "savedir", ",", "f\"iter{i:03d}\"", ")", ",", "Path", "(", "best_folder_3d", ")", ")", "\n", "", "except", "shutil", ".", "Error", "as", "err", ":", "\n", "                        ", "errors", ".", "extend", "(", "err", ".", "args", "[", "0", "]", ")", "\n", "\n", "", "", "", "if", "not", "args", ".", "oneslice", ":", "\n", "                ", "torch", ".", "save", "(", "net", ",", "Path", "(", "savedir", ",", "subj", "+", "\"best_3d.pkl\"", ")", ")", "\n", "\n", "", "if", "current_val_target_3d_asd", "<", "best_3d_asd", ":", "\n", "                ", "best_3d_asd", "=", "current_val_target_3d_asd", "\n", "with", "open", "(", "Path", "(", "savedir", ",", "subj", "+", "\"asd3dbestepoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                    ", "f", ".", "write", "(", "str", "(", "i", ")", "+", "','", "+", "str", "(", "best_3d_asd", ")", ")", "\n", "", "best_folder_asd_3d", "=", "Path", "(", "savedir", ",", "subj", "+", "\"best_epoch_asd\"", ")", "\n", "if", "best_folder_asd_3d", ".", "exists", "(", ")", ":", "\n", "                    ", "rmtree", "(", "best_folder_asd_3d", ")", "\n", "", "if", "args", ".", "saveim", ":", "\n", "                    ", "try", ":", "\n", "                        ", "copytree", "(", "Path", "(", "savedir", ",", "f\"iter{i:03d}\"", ")", ",", "Path", "(", "best_folder_asd_3d", ")", ")", "\n", "", "except", "shutil", ".", "Error", "as", "err", ":", "\n", "                        ", "errors", ".", "extend", "(", "err", ".", "args", "[", "0", "]", ")", "\n", "\n", "\n", "", "", "", "", "if", "not", "(", "i", "%", "10", ")", "and", "not", "args", ".", "oneslice", ":", "\n", "            ", "print", "(", "subj", ",", "\"epoch\"", ",", "str", "(", "i", ")", ",", "savedir", ",", "'best 3d dice'", ",", "best_3d_dice", ",", "\"mom_est\"", ",", "mom_est", ")", "\n", "if", "args", ".", "update_lin_reg", ":", "\n", "                ", "print", "(", "subj", ",", "\"epoch\"", ",", "str", "(", "i", ")", ",", "savedir", ",", "'best 3d dice'", ",", "best_3d_dice", ",", "\"first mom_coef\"", ",", "mom_coef_vec", "[", "0", "]", ")", "\n", "\n", "", "", "if", "i", "==", "n_epoch", "-", "1", "and", "not", "args", ".", "oneslice", ":", "\n", "            ", "last_3d_dice", "=", "val_target_vec", "[", "0", "]", "\n", "last_3d_asd", "=", "val_target_vec", "[", "2", "]", "\n", "with", "open", "(", "Path", "(", "savedir", ",", "subj", "+", "\"last_epoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "f", ".", "write", "(", "str", "(", "i", ")", "+", "','", "+", "str", "(", "last_3d_dice", ")", "+", "','", "+", "str", "(", "last_3d_asd", ")", ")", "\n", "", "last_folder", "=", "Path", "(", "savedir", ",", "subj", "+", "\"last_epoch\"", ")", "\n", "if", "last_folder", ".", "exists", "(", ")", ":", "\n", "                ", "rmtree", "(", "last_folder", ")", "\n", "", "if", "args", ".", "saveim", ":", "\n", "                ", "try", ":", "\n", "                    ", "copytree", "(", "Path", "(", "savedir", ",", "f\"iter{i:03d}\"", ")", ",", "Path", "(", "last_folder", ")", ")", "\n", "", "except", "shutil", ".", "Error", "as", "err", ":", "\n", "                    ", "errors", ".", "extend", "(", "err", ".", "args", "[", "0", "]", ")", "\n", "", "", "torch", ".", "save", "(", "net", ",", "Path", "(", "savedir", ",", "subj", "+", "\"last.pkl\"", ")", ")", "\n", "\n", "# remove images from iteration", "\n", "", "if", "args", ".", "saveim", ":", "\n", "            ", "rmtree", "(", "Path", "(", "savedir", ",", "f\"iter{i:03d}\"", ")", ")", "\n", "", "if", "not", "args", ".", "oneslice", ":", "\n", "            ", "df_t_tmp", "=", "pd", ".", "DataFrame", "(", "{", "\n", "\"epoch\"", ":", "i", ",", "\n", "\"val_loss_s\"", ":", "[", "val_losses_vec", "[", "0", "]", "]", ",", "\n", "\"val_loss_cons\"", ":", "[", "val_losses_vec", "[", "1", "]", "]", ",", "\n", "\"val_loss_tot\"", ":", "[", "val_losses_vec", "[", "2", "]", "]", ",", "\n", "\"val_dice_3d_sd\"", ":", "[", "val_target_vec", "[", "1", "]", "]", ",", "\n", "\"val_size_mean\"", ":", "[", "np", ".", "int", "(", "val_losses_vec", "[", "3", "]", ")", "]", ",", "\n", "\"val_gt_size_mean\"", ":", "[", "np", ".", "int", "(", "val_losses_vec", "[", "5", "]", ")", "]", ",", "\n", "#\"val_size_mean_pos\": [np.int(val_losses_vec[4])],", "\n", "\"val_gt_size_mean_pos\"", ":", "[", "np", ".", "int", "(", "val_losses_vec", "[", "6", "]", ")", "]", ",", "\n", "'val_asd_sd'", ":", "[", "val_target_vec", "[", "3", "]", "]", ",", "\n", "'val_hd'", ":", "[", "val_target_vec", "[", "4", "]", "]", ",", "\n", "'val_hd_sd'", ":", "[", "val_target_vec", "[", "5", "]", "]", ",", "\n", "'val_dice'", ":", "[", "val_target_vec", "[", "6", "]", "]", ",", "\n", "'val_asd'", ":", "[", "val_target_vec", "[", "2", "]", "]", ",", "\n", "\"val_dice_3d\"", ":", "[", "val_target_vec", "[", "0", "]", "]", "}", ")", "\n", "\n", "if", "i", "==", "0", ":", "\n", "                ", "df_t", "=", "df_t_tmp", "\n", "", "else", ":", "\n", "                ", "df_t", "=", "df_t", ".", "append", "(", "df_t_tmp", ")", "\n", "\n", "", "df_t", ".", "to_csv", "(", "Path", "(", "savedir", ",", "\"_\"", ".", "join", "(", "(", "args", ".", "target_folders", ".", "split", "(", "\"'\"", ")", "[", "1", "]", ",", "subj", ",", "args", ".", "csv", ")", ")", ")", ",", "\n", "float_format", "=", "\"%.4f\"", ",", "index", "=", "False", ")", "\n", "\n", "", "if", "args", ".", "flr", "==", "False", ":", "\n", "            ", "exp_lr_scheduler", "(", "optimizer", ",", "i", ",", "args", ".", "lr_decay", ",", "args", ".", "lr_decay_epoch", ")", "\n", "", "", "df", ".", "close", "(", ")", "\n", "print", "(", "subj", ",", "\" Results saved in \"", ",", "savedir", ",", "\"best 3d dice\"", ",", "best_3d_dice", ",", "\"best asd 3d\"", ",", "best_3d_asd", ")", "\n", "print", "(", "subj", ",", "\"last 3d dice\"", ",", "last_3d_dice", ",", "\"last asd 3d\"", ",", "last_3d_asd", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.run": [[488, 569], ["vars", "str", "platform.node", "utils.save_dict_to_file", "eval", "print", "eval", "print", "print", "print", "print", "print", "open().read", "ast.literal_eval", "ast.literal_eval.keys", "datetime.datetime.now", "main.setup", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "open", "f.write", "open", "f.write", "open", "f.write", "open", "f.write", "setattr", "str", "list", "random.shuffle", "main.run_subj", "utils.map_", "numpy.mean", "numpy.mean", "pathlib.Path", "str", "pathlib.Path", "str", "pathlib.Path", "str", "pathlib.Path", "str", "open", "pathlib.Path", "range", "main.run_subj", "pathlib.Path().glob", "open", "f.readlines", "dsc.append", "open", "f.readlines", "asd.append", "open", "f.readlines", "last_dsc.append", "last_asd.append", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "numpy.round", "str", "open", "f.readlines", "pathlib.Path", "pathlib.Path", "pathlib.Path", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.mean", "str", "str", "pathlib.Path", "pathlib.Path", "eval", "dsc.append", "eval", "eval", "eval", "eval", "numpy.round", "numpy.round", "numpy.mean", "numpy.mean", "eval"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_dict_to_file", "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.setup", "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.run_subj", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.run_subj"], ["", "def", "run", "(", "args", ":", "argparse", ".", "Namespace", ")", "->", "None", ":", "\n", "    ", "savedir", ":", "str", "=", "args", ".", "workdir", "\n", "if", "args", ".", "dic_params", "!=", "\"\"", ":", "\n", "        ", "c", "=", "open", "(", "args", ".", "dic_params", ",", "'r'", ")", ".", "read", "(", ")", "\n", "dic_params", "=", "ast", ".", "literal_eval", "(", "c", ")", "\n", "for", "e", "in", "dic_params", ".", "keys", "(", ")", ":", "\n", "            ", "setattr", "(", "args", ",", "e", ",", "dic_params", "[", "e", "]", ")", "\n", "", "args", ".", "workdir", "=", "savedir", "\n", "# save args to dict", "\n", "", "d", "=", "vars", "(", "args", ")", "\n", "\n", "d", "[", "'time'", "]", "=", "str", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ")", "\n", "d", "[", "'server'", "]", "=", "platform", ".", "node", "(", ")", "\n", "\n", "save_dict_to_file", "(", "d", ",", "args", ".", "workdir", ",", "args", ".", "mode", ")", "\n", "\n", "n_class", ":", "int", "=", "args", ".", "n_class", "\n", "dtype", "=", "eval", "(", "args", ".", "dtype", ")", "\n", "\n", "# Proper params", "\n", "\n", "print", "(", "args", ".", "target_folders", ")", "\n", "subj_list", "=", "eval", "(", "args", ".", "regex_list", ")", "\n", "model_weights_dir", "=", "args", ".", "model_weights", "\n", "for", "subj", "in", "subj_list", ":", "\n", "        ", "if", "not", "args", ".", "global_model", ":", "\n", "            ", "subj_model_weights", "=", "str", "(", "Path", "(", "model_weights_dir", ",", "subj", "+", "\"last.pkl\"", ")", ")", "\n", "args", ".", "model_weights", "=", "subj_model_weights", "\n", "", "net", ",", "optimizer", ",", "device", ",", "loss_fns", ",", "loss_weights", ",", "scheduler", ",", "n_epoch", ",", "momfn", "=", "setup", "(", "args", ",", "n_class", ",", "dtype", ")", "\n", "if", "args", ".", "oneslice", ":", "\n", "            ", "a", "=", "list", "(", "range", "(", "0", ",", "256", ")", ")", "\n", "random", ".", "shuffle", "(", "a", ")", "\n", "for", "i", "in", "a", ":", "\n", "                ", "args", ".", "train_grp_regex", "=", "subj", "+", "\"_\"", "+", "str", "(", "i", ")", "+", "\".nii\"", "\n", "args", ".", "grp_regex", "=", "subj", "+", "\"_\"", "+", "str", "(", "i", ")", "+", "\".nii\"", "\n", "run_subj", "(", "args", ",", "net", ",", "optimizer", ",", "device", ",", "loss_fns", ",", "loss_weights", ",", "scheduler", ",", "n_epoch", ",", "momfn", ")", "\n", "", "", "else", ":", "\n", "            ", "args", ".", "train_grp_regex", "=", "subj", "\n", "args", ".", "grp_regex", "=", "subj", "\n", "run_subj", "(", "args", ",", "net", ",", "optimizer", ",", "device", ",", "loss_fns", ",", "loss_weights", ",", "scheduler", ",", "n_epoch", ",", "momfn", ")", "\n", "\n", "", "", "dsc", ",", "asd", ",", "last_dsc", ",", "last_asd", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "subj", "in", "subj_list", ":", "\n", "        ", "if", "args", ".", "oneslice", ":", "\n", "            ", "list_", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "Path", "(", "savedir", ")", ".", "glob", "(", "\"*.nii3dbestepoch.txt\"", ")", ")", "\n", "for", "l", "in", "list_", ":", "\n", "                ", "with", "open", "(", "Path", "(", "savedir", ",", "l", ")", ")", "as", "f", ":", "\n", "                    ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "tmp_dsc", "=", "eval", "(", "lines", "[", "0", "]", ")", "[", "1", "]", "\n", "if", "tmp_dsc", "!=", "1", ":", "\n", "                        ", "dsc", ".", "append", "(", "eval", "(", "lines", "[", "0", "]", ")", "[", "1", "]", ")", "\n", "", "", "", "", "else", ":", "\n", "            ", "with", "open", "(", "Path", "(", "savedir", ",", "subj", "+", "\"3dbestepoch.txt\"", ")", ")", "as", "f", ":", "\n", "                ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "dsc", ".", "append", "(", "eval", "(", "lines", "[", "0", "]", ")", "[", "1", "]", ")", "\n", "", "with", "open", "(", "Path", "(", "savedir", ",", "subj", "+", "\"asd3dbestepoch.txt\"", ")", ")", "as", "f", ":", "\n", "                ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "asd", ".", "append", "(", "eval", "(", "lines", "[", "0", "]", ")", "[", "1", "]", ")", "\n", "", "with", "open", "(", "Path", "(", "savedir", ",", "subj", "+", "\"last_epoch.txt\"", ")", ")", "as", "f", ":", "\n", "                ", "lines", "=", "f", ".", "readlines", "(", ")", "\n", "last_dsc", ".", "append", "(", "eval", "(", "lines", "[", "0", "]", ")", "[", "1", "]", ")", "\n", "last_asd", ".", "append", "(", "eval", "(", "lines", "[", "0", "]", ")", "[", "2", "]", ")", "\n", "\n", "", "", "", "print", "(", "\"last_dsc\"", ",", "last_dsc", ")", "\n", "# print(x, dsc)", "\n", "print", "(", "\"Mean best 3d dice all subj\"", ",", "np", ".", "round", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "dsc", "*", "100", ")", ",", "3", ")", "*", "100", ",", "3", ")", ")", "\n", "print", "(", "\"Mean last 3d dice all subj\"", ",", "np", ".", "round", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "last_dsc", "*", "100", ")", ",", "3", ")", "*", "100", ",", "3", ")", ")", "\n", "print", "(", "\"Mean best 3d asd all subj\"", ",", "np", ".", "round", "(", "np", ".", "mean", "(", "asd", ")", ",", "3", ")", ")", "\n", "print", "(", "\"Mean last 3d asd all subj\"", ",", "np", ".", "round", "(", "np", ".", "mean", "(", "last_asd", ")", ",", "3", ")", ")", "\n", "\n", "with", "open", "(", "Path", "(", "savedir", ",", "\"3dbestepoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "np", ".", "round", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "dsc", "*", "100", ")", ",", "3", ")", "*", "100", ",", "3", ")", ")", ")", "\n", "\n", "", "with", "open", "(", "Path", "(", "savedir", ",", "\"3dlast_epoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "np", ".", "round", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "last_dsc", "*", "100", ")", ",", "3", ")", "*", "100", ",", "3", ")", ")", ")", "\n", "\n", "", "with", "open", "(", "Path", "(", "savedir", ",", "\"asdlast_epoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "last_asd", ")", ",", "3", ")", ")", ")", "\n", "\n", "", "with", "open", "(", "Path", "(", "savedir", ",", "\"asd3dbestepoch.txt\"", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "str", "(", "np", ".", "round", "(", "np", ".", "mean", "(", "asd", ")", ",", "3", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.main.get_args": [[571, 647], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "print", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["", "", "def", "get_args", "(", ")", "->", "argparse", ".", "Namespace", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Hyperparams'", ")", "\n", "parser", ".", "add_argument", "(", "'--target_dataset'", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"--workdir\"", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"--target_losses\"", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"List of (loss_name, loss_params, bounds_name, bounds_params, fn, weight)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--target_folders\"", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"List of (subfolder, transform, is_hot)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--val_target_folders\"", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "\"List of (subfolder, transform, is_hot)\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--network\"", ",", "type", "=", "str", ",", "required", "=", "True", ",", "help", "=", "\"The network to use\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--grp_regex\"", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"--regex_list\"", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"--train_grp_regex\"", ",", "type", "=", "str", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_class\"", ",", "type", "=", "int", ",", "required", "=", "True", ")", "\n", "parser", ".", "add_argument", "(", "\"--dic_params\"", ",", "type", "=", "str", ",", "default", "=", "\"\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--mode\"", ",", "type", "=", "str", ",", "default", "=", "\"learn\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--lin_aug_w\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--both\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--trainval\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--valonly\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--flr\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--augment\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--do_hd\"", ",", "type", "=", "bool", ",", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "\"--global_model\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--do_asd\"", ",", "type", "=", "bool", ",", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "\"--saveim\"", ",", "type", "=", "bool", ",", "default", "=", "False", ")", "\n", "parser", ".", "add_argument", "(", "\"--thl\"", ",", "type", "=", "str", ",", "default", "=", "'med'", ")", "\n", "parser", ".", "add_argument", "(", "\"--do_not_config_mod\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--debug\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--med\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--csv\"", ",", "type", "=", "str", ",", "default", "=", "'metrics.csv'", ")", "\n", "parser", ".", "add_argument", "(", "\"--adamw\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--dice_3d\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--ontest\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--adw\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--oneslice\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--testonly\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--trainonly\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--ontrain\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--pprint\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--entmap\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--update_mom_est\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--update_lin_reg\"", ",", "action", "=", "\"store_true\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--model_weights\"", ",", "type", "=", "str", ",", "default", "=", "''", ")", "\n", "parser", ".", "add_argument", "(", "\"--cpu\"", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\"--in_memory\"", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\"--tta\"", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "\"--resize\"", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\"--pho\"", ",", "nargs", "=", "'?'", ",", "type", "=", "float", ",", "default", "=", "1", ",", "\n", "help", "=", "'augment'", ")", "\n", "parser", ".", "add_argument", "(", "\"--n_warmup\"", ",", "type", "=", "int", ",", "default", "=", "0", ")", "\n", "parser", ".", "add_argument", "(", "\"--wh\"", ",", "type", "=", "int", ",", "default", "=", "256", ")", "\n", "parser", ".", "add_argument", "(", "'--n_epoch'", ",", "nargs", "=", "'?'", ",", "type", "=", "int", ",", "default", "=", "200", ",", "\n", "help", "=", "'# of the epochs'", ")", "\n", "parser", ".", "add_argument", "(", "'--ind_mom'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "\n", "help", "=", "'index of the moment'", ")", "\n", "parser", ".", "add_argument", "(", "'--l_rate'", ",", "nargs", "=", "'?'", ",", "type", "=", "float", ",", "default", "=", "5e-4", ",", "\n", "help", "=", "'Learning Rate'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_decay'", ",", "nargs", "=", "'?'", ",", "type", "=", "float", ",", "default", "=", "0.7", ")", ",", "\n", "parser", ".", "add_argument", "(", "'--lr_decay_epoch'", ",", "nargs", "=", "'?'", ",", "type", "=", "float", ",", "default", "=", "20", ")", ",", "\n", "parser", ".", "add_argument", "(", "'--weight_decay'", ",", "nargs", "=", "'?'", ",", "type", "=", "float", ",", "default", "=", "1e-5", ",", "\n", "help", "=", "'L2 regularisation of network weights'", ")", "\n", "parser", ".", "add_argument", "(", "'--batch_size'", ",", "type", "=", "int", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "\"--dtype\"", ",", "type", "=", "str", ",", "default", "=", "\"torch.float32\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--scheduler\"", ",", "type", "=", "str", ",", "default", "=", "\"DummyScheduler\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--scheduler_params\"", ",", "type", "=", "str", ",", "default", "=", "\"{}\"", ")", "\n", "parser", ".", "add_argument", "(", "\"--power\"", ",", "type", "=", "float", ",", "default", "=", "0.9", ")", "\n", "parser", ".", "add_argument", "(", "\"--softmax_temp\"", ",", "type", "=", "float", ",", "default", "=", "1", ")", "\n", "parser", ".", "add_argument", "(", "\"--train_case_nb\"", ",", "type", "=", "int", ",", "default", "=", "-", "1", ")", "\n", "parser", ".", "add_argument", "(", "\"--metric_axis\"", ",", "type", "=", "int", ",", "nargs", "=", "'*'", ",", "required", "=", "True", ",", "help", "=", "\"Classes to display metrics. \\\n        Display only the average of everything if empty\"", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "print", "(", "args", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.ConstantBounds.__init__": [[12, 21], ["torch.zeros", "kwargs[].items", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "C", ":", "int", "=", "kwargs", "[", "'C'", "]", "\n", "self", ".", "const", ":", "Tensor", "=", "torch", ".", "zeros", "(", "(", "self", ".", "C", ",", "1", ",", "2", ")", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "for", "i", ",", "(", "low", ",", "high", ")", "in", "kwargs", "[", "'values'", "]", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "const", "[", "i", ",", "0", ",", "0", "]", "=", "low", "\n", "self", ".", "const", "[", "i", ",", "0", ",", "1", "]", "=", "high", "\n", "\n", "", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.ConstantBounds.__call__": [[22, 24], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ":", "Tensor", ",", "target", ":", "Tensor", ",", "weak_target", ":", "Tensor", ",", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "        ", "return", "self", ".", "const", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.PredictionBounds.__init__": [[26, 36], ["pandas.read_csv", "print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "margin", ":", "float", "=", "kwargs", "[", "'margin'", "]", "\n", "self", ".", "dir", ":", "str", "=", "kwargs", "[", "'dir'", "]", "\n", "self", ".", "mode", "=", "\"percentage\"", "\n", "self", ".", "sizefile", ":", "float", "=", "kwargs", "[", "'sizefile'", "]", "\n", "self", ".", "sep", "=", "kwargs", "[", "'sep'", "]", "\n", "self", ".", "sizes", "=", "pd", ".", "read_csv", "(", "self", ".", "sizefile", ",", "sep", "=", "self", ".", "sep", ")", "\n", "self", ".", "predcol", ":", "bool", "=", "kwargs", "[", "'predcol'", "]", "\n", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.PredictionBounds.__call__": [[37, 75], ["torch.tensor().squeeze", "torch.max().type", "eval", "ValueError", "torch.stack", "print", "eval", "torch.tensor", "torch.stack", "torch.max", "torch.stack", "torch.zeros().type", "torch.zeros"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ":", "Tensor", ",", "target", ":", "Tensor", ",", "weak_target", ":", "Tensor", ",", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "        ", "c", ",", "w", ",", "h", "=", "target", ".", "shape", "\n", "pred_size_col", "=", "self", ".", "predcol", "\n", "#print(self.sizes.loc[:,pred_size_col])", "\n", "#print(self.sizes.val_ids)", "\n", "#print(self.sizes.loc[self.sizes.val_ids == filename])", "\n", "try", ":", "\n", "            ", "value", "=", "eval", "(", "self", ".", "sizes", ".", "loc", "[", "self", ".", "sizes", ".", "val_ids", "==", "filename", ",", "pred_size_col", "]", ".", "values", "[", "0", "]", ")", "\n", "", "except", ":", "\n", "            ", "print", "(", "filename", ",", "filename", "[", "1", ":", "]", ")", "\n", "value", "=", "eval", "(", "self", ".", "sizes", ".", "loc", "[", "self", ".", "sizes", ".", "val_ids", "==", "filename", "[", "1", ":", "]", ",", "pred_size_col", "]", ".", "values", "[", "0", "]", ")", "\n", "#print('not eval')", "\n", "#print(self.sizes[pred_size_col])", "\n", "#print(self.sizes.columns)", "\n", "#print(filename)", "\n", "#value = self.sizes.loc[self.sizes.val_ids == filename, pred_size_col].values[0]", "\n", "", "value", "=", "torch", ".", "tensor", "(", "[", "value", "]", ")", ".", "squeeze", "(", "0", ")", "\n", "#with_margin: Tensor = torch.stack([value, value], dim=-1)", "\n", "#assert with_margin.shape == (*value.shape, 2), with_margin.shape", "\n", "\n", "margin", ":", "Tensor", "\n", "if", "self", ".", "mode", "==", "\"percentage\"", ":", "\n", "            ", "margin", "=", "value", "*", "self", ".", "margin", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"mode\"", ")", "\n", "\n", "", "if", "self", ".", "dir", "==", "\"both\"", ":", "\n", "            ", "with_margin", ":", "Tensor", "=", "torch", ".", "stack", "(", "[", "value", "-", "margin", ",", "value", "+", "margin", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "elif", "self", ".", "dir", "==", "\"high\"", ":", "\n", "            ", "with_margin", ":", "Tensor", "=", "torch", ".", "stack", "(", "[", "value", ",", "value", "+", "margin", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "elif", "self", ".", "dir", "==", "\"low\"", ":", "\n", "            ", "with_margin", ":", "Tensor", "=", "torch", ".", "stack", "(", "[", "value", "-", "margin", ",", "value", "]", ",", "dim", "=", "-", "1", ")", "\n", "", "assert", "with_margin", ".", "shape", "==", "(", "*", "value", ".", "shape", ",", "2", ")", ",", "with_margin", ".", "shape", "\n", "\n", "#res = torch.max(with_margin, torch.zeros(*value.shape, 2)).type(torch.float32)", "\n", "res", "=", "torch", ".", "max", "(", "with_margin", ",", "torch", ".", "zeros", "(", "*", "value", ".", "shape", ",", "2", ")", ".", "type", "(", "torch", ".", "long", ")", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "#print(res.shape,'res.shape')", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.PreciseBounds.__init__": [[78, 87], ["getattr", "print", "__import__"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "margin", ":", "float", "=", "kwargs", "[", "'margin'", "]", "\n", "self", ".", "mode", ":", "str", "=", "kwargs", "[", "'mode'", "]", "\n", "self", ".", "namefun", ":", "str", "=", "kwargs", "[", "'fn'", "]", "\n", "#self.power: int = kwargs['power']", "\n", "self", ".", "power", ":", "int", "=", "1", "\n", "self", ".", "__fn__", "=", "getattr", "(", "__import__", "(", "'utils'", ")", ",", "kwargs", "[", "'fn'", "]", ")", "\n", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.PreciseBounds.__call__": [[88, 108], ["torch.stack", "torch.max().type", "[].type", "[].type", "ValueError", "torch.max", "torch.ones_like", "torch.zeros", "bounds.PreciseBounds.__fn__", "bounds.PreciseBounds.__fn__", "target[].type", "target[].type"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ":", "Tensor", ",", "target", ":", "Tensor", ",", "weak_target", ":", "Tensor", ",", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "        ", "if", "self", ".", "namefun", "==", "\"norm_soft_size\"", ":", "\n", "            ", "value", ":", "Tensor", "=", "self", ".", "__fn__", "(", "target", "[", "None", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", ",", "self", ".", "power", ")", "[", "0", "]", ".", "type", "(", "torch", ".", "float32", ")", "# cwh and not bcwh", "\n", "", "else", ":", "\n", "#value: Tensor = self.__fn__(target[None, ...])[0].type(torch.float32)  # cwh and not bcwh", "\n", "            ", "value", ":", "Tensor", "=", "self", ".", "__fn__", "(", "target", "[", "None", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", ")", "[", "0", "]", ".", "type", "(", "torch", ".", "float32", ")", "# cwh and not bcwh", "\n", "", "margin", ":", "Tensor", "\n", "if", "self", ".", "mode", "==", "\"percentage\"", ":", "\n", "            ", "margin", "=", "value", "*", "self", ".", "margin", "\n", "", "elif", "self", ".", "mode", "==", "\"abs\"", ":", "\n", "            ", "margin", "=", "torch", ".", "ones_like", "(", "value", ")", "*", "self", ".", "margin", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"mode\"", ")", "\n", "\n", "", "with_margin", ":", "Tensor", "=", "torch", ".", "stack", "(", "[", "value", "-", "margin", ",", "value", "+", "margin", "]", ",", "dim", "=", "-", "1", ")", "\n", "assert", "with_margin", ".", "shape", "==", "(", "*", "value", ".", "shape", ",", "2", ")", ",", "with_margin", ".", "shape", "\n", "\n", "res", "=", "torch", ".", "max", "(", "with_margin", ",", "torch", ".", "zeros", "(", "*", "value", ".", "shape", ",", "2", ")", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "#print(res.shape,\"in bounds\")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.PreciseTags.__init__": [[111, 115], ["bounds.PreciseBounds.__init__"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "\n", "self", ".", "neg_value", ":", "List", "=", "kwargs", "[", "'neg_value'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.PreciseTags.__call__": [[116, 125], ["bounds.PreciseBounds.__call__", "torch.Tensor", "torch.einsum"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__call__"], ["", "def", "__call__", "(", "self", ",", "image", ":", "Tensor", ",", "target", ":", "Tensor", ",", "weak_target", ":", "Tensor", ",", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "        ", "positive_class", ":", "Tensor", "=", "torch", ".", "einsum", "(", "\"cwh->c\"", ",", "[", "target", "]", ")", ">", "0", "\n", "\n", "res", "=", "super", "(", ")", ".", "__call__", "(", "image", ",", "target", ",", "weak_target", ",", "filename", ")", "\n", "\n", "masked", "=", "res", "[", "...", "]", "\n", "masked", "[", "positive_class", "==", "0", "]", "=", "torch", ".", "Tensor", "(", "self", ".", "neg_value", ")", "\n", "\n", "return", "masked", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.BoxBounds.__init__": [[128, 132], ["torch.Tensor", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "margins", ":", "Tensor", "=", "torch", ".", "Tensor", "(", "kwargs", "[", "'margins'", "]", ")", "\n", "assert", "len", "(", "self", ".", "margins", ")", "==", "2", "\n", "assert", "self", ".", "margins", "[", "0", "]", "<=", "self", ".", "margins", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.BoxBounds.__call__": [[133, 143], ["len", "[].type", "torch.einsum"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "image", ":", "Tensor", ",", "target", ":", "Tensor", ",", "weak_target", ":", "Tensor", ",", "filename", ":", "str", ")", "->", "Tensor", ":", "\n", "        ", "c", "=", "len", "(", "weak_target", ")", "\n", "box_sizes", ":", "Tensor", "=", "torch", ".", "einsum", "(", "\"cwh->c\"", ",", "[", "weak_target", "]", ")", "[", "...", ",", "None", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "bounds", ":", "Tensor", "=", "box_sizes", "*", "self", ".", "margins", "\n", "\n", "res", "=", "bounds", "[", ":", ",", "None", ",", ":", "]", "\n", "assert", "res", ".", "shape", "==", "(", "c", ",", "1", ",", "2", ")", "\n", "assert", "(", "res", "[", "...", ",", "0", "]", "<=", "res", "[", "...", ",", "1", "]", ")", ".", "all", "(", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.bounds.CheckBounds": [[145, 158], ["pandas.read_csv", "print", "print", "print"], "function", ["None"], ["", "", "def", "CheckBounds", "(", "**", "kwargs", ")", ":", "\n", "        ", "sizefile", ":", "float", "=", "kwargs", "[", "'sizefile'", "]", "\n", "sizes", "=", "pd", ".", "read_csv", "(", "sizefile", ",", "sep", "=", "kwargs", "[", "'sep'", "]", ")", "\n", "predcol", ":", "str", "=", "kwargs", "[", "'predcol'", "]", "\n", "#print(predcol, 'pred_size_col')", "\n", "#print(sizes.columns, 'self.sizes.columns')", "\n", "if", "predcol", "in", "sizes", ".", "columns", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "print", "(", "'size pred not in file'", ")", "\n", "print", "(", "sizes", ".", "columns", ",", "'self.sizes.columns'", ")", "\n", "print", "(", "sizes", ".", "shape", ",", "\"size file shape\"", ")", "\n", "return", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.MySampler.Sampler.__init__": [[11, 13], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data_source", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.MySampler.Sampler.__iter__": [[14, 16], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.MySampler.Sampler.__len__": [[17, 19], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.interpolate.__init__": [[22, 27], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__"], ["    ", "def", "__init__", "(", "self", ",", "scale_factor", ",", "mode", "=", "'nearest'", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "scale_factor", "=", "scale_factor", "\n", "self", ".", "mode", "=", "mode", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.interpolate.forward": [[28, 30], ["torch.interpolate", "torch.interpolate"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "cin", ")", ":", "\n", "        ", "return", "F", ".", "interpolate", "(", "cin", ",", "mode", "=", "self", ".", "mode", ",", "scale_factor", "=", "self", ".", "scale_factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.residualConv.__init__": [[122, 134], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.convBatch", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch"], ["    ", "def", "__init__", "(", "self", ",", "nin", ",", "nout", ")", ":", "\n", "        ", "super", "(", "residualConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "convs", "=", "nn", ".", "Sequential", "(", "\n", "convBatch", "(", "nin", ",", "nout", ")", ",", "\n", "nn", ".", "Conv2d", "(", "nout", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "nout", ")", "\n", ")", "\n", "self", ".", "res", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "nin", "!=", "nout", ":", "\n", "            ", "self", ".", "res", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "nin", ",", "nout", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "nout", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.residualConv.forward": [[136, 139], ["layers.residualConv.convs", "torch.leaky_relu", "torch.leaky_relu", "layers.residualConv.res"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "out", "=", "self", ".", "convs", "(", "input", ")", "\n", "return", "F", ".", "leaky_relu", "(", "out", "+", "self", ".", "res", "(", "input", ")", ",", "0.2", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch": [[7, 12], ["torch.Sequential", "layer", "torch.BatchNorm2d", "torch.PReLU"], "function", ["None"], ["def", "convBatch", "(", "nin", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ",", "layer", "=", "nn", ".", "Conv2d", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "layer", "(", "nin", ",", "nout", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "bias", "=", "bias", ",", "dilation", "=", "dilation", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "nout", ")", ",", "\n", "nn", ".", "PReLU", "(", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.downSampleConv": [[15, 18], ["torch.Sequential", "layers.convBatch"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch"], ["", "def", "downSampleConv", "(", "nin", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "convBatch", "(", "nin", ",", "nout", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "bias", "=", "bias", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.upSampleConv": [[32, 38], ["torch.Sequential", "layers.interpolate", "layers.convBatch", "layers.convBatch"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.convBatch"], ["", "", "def", "upSampleConv", "(", "nin", ",", "nout", ",", "kernel_size", "=", "3", ",", "upscale", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "# nn.Upsample(scale_factor=upscale),", "\n", "interpolate", "(", "mode", "=", "'nearest'", ",", "scale_factor", "=", "upscale", ")", ",", "\n", "convBatch", "(", "nin", ",", "nout", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "1", ",", "padding", "=", "padding", ",", "bias", "=", "bias", ")", ",", "\n", "convBatch", "(", "nout", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "bias", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block": [[41, 48], ["torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d"], "function", ["None"], ["", "def", "conv_block", "(", "in_dim", ",", "out_dim", ",", "act_fn", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_dim", ",", "out_dim", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "dilation", "=", "dilation", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_dim", ")", ",", "\n", "act_fn", ",", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_1": [[50, 57], ["torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.PReLU"], "function", ["None"], ["", "def", "conv_block_1", "(", "in_dim", ",", "out_dim", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_dim", ",", "out_dim", ",", "kernel_size", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_dim", ")", ",", "\n", "nn", ".", "PReLU", "(", ")", ",", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_Asym": [[59, 67], ["torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.PReLU", "tuple", "tuple"], "function", ["None"], ["", "def", "conv_block_Asym", "(", "in_dim", ",", "out_dim", ",", "kernelSize", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_dim", ",", "out_dim", ",", "kernel_size", "=", "[", "kernelSize", ",", "1", "]", ",", "padding", "=", "tuple", "(", "[", "2", ",", "0", "]", ")", ")", ",", "\n", "nn", ".", "Conv2d", "(", "out_dim", ",", "out_dim", ",", "kernel_size", "=", "[", "1", ",", "kernelSize", "]", ",", "padding", "=", "tuple", "(", "[", "0", ",", "2", "]", ")", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_dim", ")", ",", "\n", "nn", ".", "PReLU", "(", ")", ",", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_3_3": [[69, 76], ["torch.Sequential", "torch.Conv2d", "torch.BatchNorm2d", "torch.PReLU"], "function", ["None"], ["", "def", "conv_block_3_3", "(", "in_dim", ",", "out_dim", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_dim", ",", "out_dim", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_dim", ")", ",", "\n", "nn", ".", "PReLU", "(", ")", ",", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block_3": [[78, 86], ["torch.Sequential", "layers.conv_block", "layers.conv_block", "torch.Conv2d", "torch.BatchNorm2d"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block", "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_block"], ["", "def", "conv_block_3", "(", "in_dim", ",", "out_dim", ",", "act_fn", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "conv_block", "(", "in_dim", ",", "out_dim", ",", "act_fn", ")", ",", "\n", "conv_block", "(", "out_dim", ",", "out_dim", ",", "act_fn", ")", ",", "\n", "nn", ".", "Conv2d", "(", "out_dim", ",", "out_dim", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_dim", ")", ",", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv": [[88, 103], ["torch.LeakyReLU", "layer", "layers.insert", "torch.Sequential", "layers.append", "torch.BatchNorm2d", "layers.append", "layers.append", "activ"], "function", ["None"], ["", "def", "conv", "(", "nin", ",", "nout", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ",", "layer", "=", "nn", ".", "Conv2d", ",", "\n", "BN", "=", "False", ",", "ws", "=", "False", ",", "activ", "=", "nn", ".", "LeakyReLU", "(", "0.2", ")", ",", "gainWS", "=", "2", ")", ":", "\n", "    ", "convlayer", "=", "layer", "(", "nin", ",", "nout", ",", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "bias", "=", "bias", ")", "\n", "layers", "=", "[", "]", "\n", "if", "BN", ":", "\n", "        ", "layers", ".", "append", "(", "nn", ".", "BatchNorm2d", "(", "nout", ")", ")", "\n", "", "if", "activ", "is", "not", "None", ":", "\n", "        ", "if", "activ", "==", "nn", ".", "PReLU", ":", "\n", "# to avoid sharing the same parameter, activ must be set to nn.PReLU (without '()')", "\n", "            ", "layers", ".", "append", "(", "activ", "(", "num_parameters", "=", "1", ")", ")", "\n", "", "else", ":", "\n", "# if activ == nn.PReLU(), the parameter will be shared for the whole network !", "\n", "            ", "layers", ".", "append", "(", "activ", ")", "\n", "", "", "layers", ".", "insert", "(", "ws", ",", "convlayer", ")", "\n", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.conv_decod_block": [[106, 113], ["torch.Sequential", "torch.ConvTranspose2d", "torch.BatchNorm2d"], "function", ["None"], ["", "def", "conv_decod_block", "(", "in_dim", ",", "out_dim", ",", "act_fn", ")", ":", "\n", "    ", "model", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "ConvTranspose2d", "(", "in_dim", ",", "out_dim", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "output_padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_dim", ")", ",", "\n", "act_fn", ",", "\n", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.layers.maxpool": [[115, 118], ["torch.MaxPool2d"], "function", ["None"], ["", "def", "maxpool", "(", ")", ":", "\n", "    ", "pool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "0", ")", "\n", "return", "pool", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.scheduler.DummyScheduler.__call__": [[8, 11], ["None"], "methods", ["None"], ["    ", "def", "__call__", "(", "self", ",", "epoch", ":", "int", ",", "optimizer", ":", "Any", ",", "loss_fns", ":", "List", "[", "Callable", "]", ",", "loss_weights", ":", "List", "[", "float", "]", ")", "->", "Tuple", "[", "float", ",", "List", "[", "Callable", "]", ",", "List", "[", "float", "]", "]", ":", "\n", "        ", "return", "optimizer", ",", "loss_fns", ",", "loss_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.scheduler.AddWeightLoss.__init__": [[14, 16], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "to_add", ":", "List", "[", "float", "]", ")", ":", "\n", "        ", "self", ".", "to_add", ":", "List", "[", "float", "]", "=", "to_add", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.scheduler.AddWeightLoss.__call__": [[17, 25], ["utils.map_", "print", "len", "len", "utils.uc_", "zip"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.uc_"], ["", "def", "__call__", "(", "self", ",", "epoch", ":", "int", ",", "optimizer", ":", "Any", ",", "loss_fns", ":", "List", "[", "Callable", "]", ",", "loss_weights", ":", "List", "[", "float", "]", ")", "->", "Tuple", "[", "float", ",", "List", "[", "Callable", "]", ",", "List", "[", "float", "]", "]", ":", "\n", "        ", "assert", "len", "(", "self", ".", "to_add", ")", "==", "len", "(", "loss_weights", ")", "\n", "new_weights", ":", "List", "[", "float", "]", "=", "map_", "(", "uc_", "(", "add", ")", ",", "zip", "(", "loss_weights", ",", "self", ".", "to_add", ")", ")", "\n", "\n", "print", "(", "f\"Loss weights went from {loss_weights} to {new_weights}\"", ")", "\n", "\n", "return", "optimizer", ",", "loss_fns", ",", "new_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.scheduler.StealWeight.__init__": [[28, 30], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "to_steal", ":", "float", ")", ":", "\n", "        ", "self", ".", "to_steal", ":", "float", "=", "to_steal", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.scheduler.StealWeight.__call__": [[31, 39], ["print", "max"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "epoch", ":", "int", ",", "optimizer", ":", "Any", ",", "loss_fns", ":", "List", "[", "Callable", "]", ",", "loss_weights", ":", "List", "[", "float", "]", ")", "->", "Tuple", "[", "float", ",", "List", "[", "Callable", "]", ",", "List", "[", "float", "]", "]", ":", "\n", "        ", "a", ",", "b", "=", "loss_weights", "\n", "new_weights", ":", "List", "[", "float", "]", "=", "[", "max", "(", "0.1", ",", "a", "-", "self", ".", "to_steal", ")", ",", "b", "+", "self", ".", "to_steal", "]", "\n", "\n", "print", "(", "f\"Loss weights went from {loss_weights} to {new_weights}\"", ")", "\n", "\n", "return", "optimizer", ",", "loss_fns", ",", "new_weights", "", "", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.dc": [[35, 83], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "float"], "function", ["None"], ["def", "dc", "(", "result", ",", "reference", ")", ":", "\n", "    ", "r\"\"\"\n    Dice coefficient\n\n    Computes the Dice coefficient (also known as Sorensen index) between the binary\n    objects in two images.\n\n    The metric is defined as\n\n    .. math::\n\n        DC=\\frac{2|A\\cap B|}{|A|+|B|}\n\n    , where :math:`A` is the first and :math:`B` the second set of samples (here: binary objects).\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n\n    Returns\n    -------\n    dc : float\n        The Dice coefficient between the object(s) in ```result``` and the\n        object(s) in ```reference```. It ranges from 0 (no overlap) to 1 (perfect overlap).\n\n    Notes\n    -----\n    This is a real metric. The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "intersection", "=", "numpy", ".", "count_nonzero", "(", "result", "&", "reference", ")", "\n", "\n", "size_i1", "=", "numpy", ".", "count_nonzero", "(", "result", ")", "\n", "size_i2", "=", "numpy", ".", "count_nonzero", "(", "reference", ")", "\n", "\n", "try", ":", "\n", "        ", "dc", "=", "2.", "*", "intersection", "/", "float", "(", "size_i1", "+", "size_i2", ")", "\n", "", "except", "ZeroDivisionError", ":", "\n", "        ", "dc", "=", "0.0", "\n", "\n", "", "return", "dc", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.jc": [[85, 119], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "float", "float"], "function", ["None"], ["", "def", "jc", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Jaccard coefficient\n\n    Computes the Jaccard coefficient between the binary objects in two images.\n\n    Parameters\n    ----------\n    result: array_like\n            Input data containing objects. Can be any type but will be converted\n            into binary: background where 0, object everywhere else.\n    reference: array_like\n            Input data containing objects. Can be any type but will be converted\n            into binary: background where 0, object everywhere else.\n\n    Returns\n    -------\n    jc: float\n        The Jaccard coefficient between the object(s) in `result` and the\n        object(s) in `reference`. It ranges from 0 (no overlap) to 1 (perfect overlap).\n\n    Notes\n    -----\n    This is a real metric. The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "intersection", "=", "numpy", ".", "count_nonzero", "(", "result", "&", "reference", ")", "\n", "union", "=", "numpy", ".", "count_nonzero", "(", "result", "|", "reference", ")", "\n", "\n", "jc", "=", "float", "(", "intersection", ")", "/", "float", "(", "union", ")", "\n", "\n", "return", "jc", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.precision": [[121, 167], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "float"], "function", ["None"], ["", "def", "precision", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Precison.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n\n    Returns\n    -------\n    precision : float\n        The precision between two binary datasets, here mostly binary objects in images,\n        which is defined as the fraction of retrieved instances that are relevant. The\n        precision is not symmetric.\n\n    See also\n    --------\n    :func:`recall`\n\n    Notes\n    -----\n    Not symmetric. The inverse of the precision is :func:`recall`.\n    High precision means that an algorithm returned substantially more relevant results than irrelevant.\n\n    References\n    ----------\n    .. [1] http://en.wikipedia.org/wiki/Precision_and_recall\n    .. [2] http://en.wikipedia.org/wiki/Confusion_matrix#Table_of_confusion\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "tp", "=", "numpy", ".", "count_nonzero", "(", "result", "&", "reference", ")", "\n", "fp", "=", "numpy", ".", "count_nonzero", "(", "result", "&", "~", "reference", ")", "\n", "\n", "try", ":", "\n", "        ", "precision", "=", "tp", "/", "float", "(", "tp", "+", "fp", ")", "\n", "", "except", "ZeroDivisionError", ":", "\n", "        ", "precision", "=", "0.0", "\n", "\n", "", "return", "precision", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.recall": [[169, 215], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "float"], "function", ["None"], ["", "def", "recall", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Recall.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n\n    Returns\n    -------\n    recall : float\n        The recall between two binary datasets, here mostly binary objects in images,\n        which is defined as the fraction of relevant instances that are retrieved. The\n        recall is not symmetric.\n\n    See also\n    --------\n    :func:`precision`\n\n    Notes\n    -----\n    Not symmetric. The inverse of the recall is :func:`precision`.\n    High recall means that an algorithm returned most of the relevant results.\n\n    References\n    ----------\n    .. [1] http://en.wikipedia.org/wiki/Precision_and_recall\n    .. [2] http://en.wikipedia.org/wiki/Confusion_matrix#Table_of_confusion\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "tp", "=", "numpy", ".", "count_nonzero", "(", "result", "&", "reference", ")", "\n", "fn", "=", "numpy", ".", "count_nonzero", "(", "~", "result", "&", "reference", ")", "\n", "\n", "try", ":", "\n", "        ", "recall", "=", "tp", "/", "float", "(", "tp", "+", "fn", ")", "\n", "", "except", "ZeroDivisionError", ":", "\n", "        ", "recall", "=", "0.0", "\n", "\n", "", "return", "recall", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.sensitivity": [[217, 227], ["binary.recall"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.recall"], ["", "def", "sensitivity", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Sensitivity.\n    Same as :func:`recall`, see there for a detailed description.\n\n    See also\n    --------\n    :func:`specificity`\n    \"\"\"", "\n", "return", "recall", "(", "result", ",", "reference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.specificity": [[229, 275], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "float"], "function", ["None"], ["", "def", "specificity", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Specificity.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n\n    Returns\n    -------\n    specificity : float\n        The specificity between two binary datasets, here mostly binary objects in images,\n        which denotes the fraction of correctly returned negatives. The\n        specificity is not symmetric.\n\n    See also\n    --------\n    :func:`sensitivity`\n\n    Notes\n    -----\n    Not symmetric. The completment of the specificity is :func:`sensitivity`.\n    High recall means that an algorithm returned most of the irrelevant results.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Sensitivity_and_specificity\n    .. [2] http://en.wikipedia.org/wiki/Confusion_matrix#Table_of_confusion\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "tn", "=", "numpy", ".", "count_nonzero", "(", "~", "result", "&", "~", "reference", ")", "\n", "fp", "=", "numpy", ".", "count_nonzero", "(", "result", "&", "~", "reference", ")", "\n", "\n", "try", ":", "\n", "        ", "specificity", "=", "tn", "/", "float", "(", "tn", "+", "fp", ")", "\n", "", "except", "ZeroDivisionError", ":", "\n", "        ", "specificity", "=", "0.0", "\n", "\n", "", "return", "specificity", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.true_negative_rate": [[277, 288], ["binary.specificity"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.specificity"], ["", "def", "true_negative_rate", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    True negative rate.\n    Same as :func:`specificity`, see there for a detailed description.\n\n    See also\n    --------\n    :func:`true_positive_rate`\n    :func:`positive_predictive_value`\n    \"\"\"", "\n", "return", "specificity", "(", "result", ",", "reference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.true_positive_rate": [[290, 301], ["binary.recall"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.recall"], ["", "def", "true_positive_rate", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    True positive rate.\n    Same as :func:`recall` and :func:`sensitivity`, see there for a detailed description.\n\n    See also\n    --------\n    :func:`positive_predictive_value`\n    :func:`true_negative_rate`\n    \"\"\"", "\n", "return", "recall", "(", "result", ",", "reference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.positive_predictive_value": [[303, 314], ["binary.precision"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.precision"], ["", "def", "positive_predictive_value", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Positive predictive value.\n    Same as :func:`precision`, see there for a detailed description.\n\n    See also\n    --------\n    :func:`true_positive_rate`\n    :func:`true_negative_rate`\n    \"\"\"", "\n", "return", "precision", "(", "result", ",", "reference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.hd": [[316, 362], ["__surface_distances().max", "__surface_distances().max", "max", "binary.__surface_distances", "binary.__surface_distances"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances"], ["", "def", "hd", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Hausdorff Distance.\n\n    Computes the (symmetric) Hausdorff Distance (HD) between the binary objects in two\n    images. It is defined as the maximum surface distance between the objects.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        Note that the connectivity influences the result in the case of the Hausdorff distance.\n\n    Returns\n    -------\n    hd : float\n        The symmetric Hausdorff Distance between the object(s) in ```result``` and the\n        object(s) in ```reference```. The distance unit is the same as for the spacing of\n        elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`assd`\n    :func:`asd`\n\n    Notes\n    -----\n    This is a real metric. The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "hd1", "=", "__surface_distances", "(", "result", ",", "reference", ",", "voxelspacing", ",", "connectivity", ")", ".", "max", "(", ")", "\n", "hd2", "=", "__surface_distances", "(", "reference", ",", "result", ",", "voxelspacing", ",", "connectivity", ")", ".", "max", "(", ")", "\n", "hd", "=", "max", "(", "hd1", ",", "hd2", ")", "\n", "return", "hd", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.hd_var": [[364, 410], ["binary.__surface_distances", "binary.__surface_distances", "numpy.percentile", "numpy.hstack"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances"], ["", "def", "hd_var", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ",", "percentile", "=", "95", ")", ":", "\n", "    ", "\"\"\"\n    95th percentile of the Hausdorff Distance.\n\n    Computes the 95th percentile of the (symmetric) Hausdorff Distance (HD) between the binary objects in two\n    images. Compared to the Hausdorff Distance, this metric is slightly more stable to small outliers and is\n    commonly used in Biomedical Segmentation challenges.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        Note that the connectivity influences the result in the case of the Hausdorff distance.\n\n    Returns\n    -------\n    hd : float\n        The symmetric Hausdorff Distance between the object(s) in ```result``` and the\n        object(s) in ```reference```. The distance unit is the same as for the spacing of\n        elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`hd`\n\n    Notes\n    -----\n    This is a real metric. The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "hd1", "=", "__surface_distances", "(", "result", ",", "reference", ",", "voxelspacing", ",", "connectivity", ")", "\n", "hd2", "=", "__surface_distances", "(", "reference", ",", "result", ",", "voxelspacing", ",", "connectivity", ")", "\n", "hd_per", "=", "numpy", ".", "percentile", "(", "numpy", ".", "hstack", "(", "(", "hd1", ",", "hd2", ")", ")", ",", "percentile", ")", "\n", "return", "hd_per", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.hd95": [[413, 459], ["binary.__surface_distances", "binary.__surface_distances", "numpy.percentile", "numpy.hstack"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances"], ["", "def", "hd95", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    95th percentile of the Hausdorff Distance.\n\n    Computes the 95th percentile of the (symmetric) Hausdorff Distance (HD) between the binary objects in two\n    images. Compared to the Hausdorff Distance, this metric is slightly more stable to small outliers and is\n    commonly used in Biomedical Segmentation challenges.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        Note that the connectivity influences the result in the case of the Hausdorff distance.\n\n    Returns\n    -------\n    hd : float\n        The symmetric Hausdorff Distance between the object(s) in ```result``` and the\n        object(s) in ```reference```. The distance unit is the same as for the spacing of\n        elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`hd`\n\n    Notes\n    -----\n    This is a real metric. The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "hd1", "=", "__surface_distances", "(", "result", ",", "reference", ",", "voxelspacing", ",", "connectivity", ")", "\n", "hd2", "=", "__surface_distances", "(", "reference", ",", "result", ",", "voxelspacing", ",", "connectivity", ")", "\n", "hd95", "=", "numpy", ".", "percentile", "(", "numpy", ".", "hstack", "(", "(", "hd1", ",", "hd2", ")", ")", ",", "95", ")", "\n", "return", "hd95", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.assd": [[461, 515], ["numpy.mean", "binary.asd", "binary.asd"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.asd", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.asd"], ["", "def", "assd", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Average symmetric surface distance.\n\n    Computes the average symmetric surface distance (ASD) between the binary objects in\n    two images.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        The decision on the connectivity is important, as it can influence the results\n        strongly. If in doubt, leave it as it is.\n\n    Returns\n    -------\n    assd : float\n        The average symmetric surface distance between the object(s) in ``result`` and the\n        object(s) in ``reference``. The distance unit is the same as for the spacing of\n        elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`asd`\n    :func:`hd`\n\n    Notes\n    -----\n    This is a real metric, obtained by calling and averaging\n\n    >>> asd(result, reference)\n\n    and\n\n    >>> asd(reference, result)\n\n    The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "assd", "=", "numpy", ".", "mean", "(", "\n", "(", "asd", "(", "result", ",", "reference", ",", "voxelspacing", ",", "connectivity", ")", ",", "asd", "(", "reference", ",", "result", ",", "voxelspacing", ",", "connectivity", ")", ")", ")", "\n", "return", "assd", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.asd": [[517, 625], ["binary.__surface_distances", "__surface_distances.mean"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances"], ["", "def", "asd", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Average surface distance metric.\n\n    Computes the average surface distance (ASD) between the binary objects in two images.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        The decision on the connectivity is important, as it can influence the results\n        strongly. If in doubt, leave it as it is.\n\n    Returns\n    -------\n    asd : float\n        The average surface distance between the object(s) in ``result`` and the\n        object(s) in ``reference``. The distance unit is the same as for the spacing\n        of elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`assd`\n    :func:`hd`\n\n\n    Notes\n    -----\n    This is not a real metric, as it is directed. See `assd` for a real metric of this.\n\n    The method is implemented making use of distance images and simple binary morphology\n    to achieve high computational speed.\n\n    Examples\n    --------\n    The `connectivity` determines what pixels/voxels are considered the surface of a\n    binary object. Take the following binary image showing a cross\n\n    >>> from scipy.ndimage.morphology import generate_binary_structure\n    >>> cross = generate_binary_structure(2, 1)\n    array([[0, 1, 0],\n           [1, 1, 1],\n           [0, 1, 0]])\n\n    With `connectivity` set to `1` a 4-neighbourhood is considered when determining the\n    object surface, resulting in the surface\n\n    .. code-block:: python\n\n        array([[0, 1, 0],\n               [1, 0, 1],\n               [0, 1, 0]])\n\n    Changing `connectivity` to `2`, a 8-neighbourhood is considered and we get:\n\n    .. code-block:: python\n\n        array([[0, 1, 0],\n               [1, 1, 1],\n               [0, 1, 0]])\n\n    , as a diagonal connection does no longer qualifies as valid object surface.\n\n    This influences the  results `asd` returns. Imagine we want to compute the surface\n    distance of our cross to a cube-like object:\n\n    >>> cube = generate_binary_structure(2, 1)\n    array([[1, 1, 1],\n           [1, 1, 1],\n           [1, 1, 1]])\n\n    , which surface is, independent of the `connectivity` value set, always\n\n    .. code-block:: python\n\n        array([[1, 1, 1],\n               [1, 0, 1],\n               [1, 1, 1]])\n\n    Using a `connectivity` of `1` we get\n\n    >>> asd(cross, cube, connectivity=1)\n    0.0\n\n    while a value of `2` returns us\n\n    >>> asd(cross, cube, connectivity=2)\n    0.20000000000000001\n\n    due to the center of the cross being considered surface as well.\n\n    \"\"\"", "\n", "sds", "=", "__surface_distances", "(", "result", ",", "reference", ",", "voxelspacing", ",", "connectivity", ")", "\n", "asd", "=", "sds", ".", "mean", "(", ")", "\n", "return", "asd", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.ravd": [[627, 713], ["numpy.atleast_1d", "numpy.atleast_1d", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "RuntimeError", "float"], "function", ["None"], ["", "def", "ravd", "(", "result", ",", "reference", ")", ":", "\n", "    ", "\"\"\"\n    Relative absolute volume difference.\n\n    Compute the relative absolute volume difference between the (joined) binary objects\n    in the two images.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n\n    Returns\n    -------\n    ravd : float\n        The relative absolute volume difference between the object(s) in ``result``\n        and the object(s) in ``reference``. This is a percentage value in the range\n        :math:`[-1.0, +inf]` for which a :math:`0` denotes an ideal score.\n\n    Raises\n    ------\n    RuntimeError\n        If the reference object is empty.\n\n    See also\n    --------\n    :func:`dc`\n    :func:`precision`\n    :func:`recall`\n\n    Notes\n    -----\n    This is not a real metric, as it is directed. Negative values denote a smaller\n    and positive values a larger volume than the reference.\n    This implementation does not check, whether the two supplied arrays are of the same\n    size.\n\n    Examples\n    --------\n    Considering the following inputs\n\n    >>> import numpy\n    >>> arr1 = numpy.asarray([[0,1,0],[1,1,1],[0,1,0]])\n    >>> arr1\n    array([[0, 1, 0],\n           [1, 1, 1],\n           [0, 1, 0]])\n    >>> arr2 = numpy.asarray([[0,1,0],[1,0,1],[0,1,0]])\n    >>> arr2\n    array([[0, 1, 0],\n           [1, 0, 1],\n           [0, 1, 0]])\n\n    comparing `arr1` to `arr2` we get\n\n    >>> ravd(arr1, arr2)\n    -0.2\n\n    and reversing the inputs the directivness of the metric becomes evident\n\n    >>> ravd(arr2, arr1)\n    0.25\n\n    It is important to keep in mind that a perfect score of `0` does not mean that the\n    binary objects fit exactely, as only the volumes are compared:\n\n    >>> arr1 = numpy.asarray([1,0,0])\n    >>> arr2 = numpy.asarray([0,0,1])\n    >>> ravd(arr1, arr2)\n    0.0\n\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "vol1", "=", "numpy", ".", "count_nonzero", "(", "result", ")", "\n", "vol2", "=", "numpy", ".", "count_nonzero", "(", "reference", ")", "\n", "\n", "if", "0", "==", "vol2", ":", "\n", "        ", "raise", "RuntimeError", "(", "'The second supplied array does not contain any binary object.'", ")", "\n", "\n", "", "return", "(", "vol1", "-", "vol2", ")", "/", "float", "(", "vol2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.volume_correlation": [[715, 748], ["numpy.atleast_2d", "numpy.atleast_2d", "scipy.stats.pearsonr", "numpy.array().astype", "numpy.array().astype", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "volume_correlation", "(", "results", ",", "references", ")", ":", "\n", "    ", "r\"\"\"\n    Volume correlation.\n\n    Computes the linear correlation in binary object volume between the\n    contents of the successive binary images supplied. Measured through\n    the Pearson product-moment correlation coefficient.\n\n    Parameters\n    ----------\n    results : sequence of array_like\n        Ordered list of input data containing objects. Each array_like will be\n        converted into binary: background where 0, object everywhere else.\n    references : sequence of array_like\n        Ordered list of input data containing objects. Each array_like will be\n        converted into binary: background where 0, object everywhere else.\n        The order must be the same as for ``results``.\n\n    Returns\n    -------\n    r : float\n        The correlation coefficient between -1 and 1.\n    p : float\n        The two-side p value.\n\n    \"\"\"", "\n", "results", "=", "numpy", ".", "atleast_2d", "(", "numpy", ".", "array", "(", "results", ")", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "references", "=", "numpy", ".", "atleast_2d", "(", "numpy", ".", "array", "(", "references", ")", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "results_volumes", "=", "[", "numpy", ".", "count_nonzero", "(", "r", ")", "for", "r", "in", "results", "]", "\n", "references_volumes", "=", "[", "numpy", ".", "count_nonzero", "(", "r", ")", "for", "r", "in", "references", "]", "\n", "\n", "return", "pearsonr", "(", "results_volumes", ",", "references_volumes", ")", "# returns (Pearson'", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.volume_change_correlation": [[750, 787], ["numpy.atleast_2d", "numpy.atleast_2d", "numpy.asarray", "numpy.asarray", "scipy.stats.pearsonr", "numpy.array().astype", "numpy.array().astype", "numpy.count_nonzero", "numpy.count_nonzero", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "volume_change_correlation", "(", "results", ",", "references", ")", ":", "\n", "    ", "r\"\"\"\n    Volume change correlation.\n\n    Computes the linear correlation of change in binary object volume between\n    the contents of the successive binary images supplied. Measured through\n    the Pearson product-moment correlation coefficient.\n\n    Parameters\n    ----------\n    results : sequence of array_like\n        Ordered list of input data containing objects. Each array_like will be\n        converted into binary: background where 0, object everywhere else.\n    references : sequence of array_like\n        Ordered list of input data containing objects. Each array_like will be\n        converted into binary: background where 0, object everywhere else.\n        The order must be the same as for ``results``.\n\n    Returns\n    -------\n    r : float\n        The correlation coefficient between -1 and 1.\n    p : float\n        The two-side p value.\n\n    \"\"\"", "\n", "results", "=", "numpy", ".", "atleast_2d", "(", "numpy", ".", "array", "(", "results", ")", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "references", "=", "numpy", ".", "atleast_2d", "(", "numpy", ".", "array", "(", "references", ")", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "results_volumes", "=", "numpy", ".", "asarray", "(", "[", "numpy", ".", "count_nonzero", "(", "r", ")", "for", "r", "in", "results", "]", ")", "\n", "references_volumes", "=", "numpy", ".", "asarray", "(", "[", "numpy", ".", "count_nonzero", "(", "r", ")", "for", "r", "in", "references", "]", ")", "\n", "\n", "results_volumes_changes", "=", "results_volumes", "[", "1", ":", "]", "-", "results_volumes", "[", ":", "-", "1", "]", "\n", "references_volumes_changes", "=", "references_volumes", "[", "1", ":", "]", "-", "references_volumes", "[", ":", "-", "1", "]", "\n", "\n", "return", "pearsonr", "(", "results_volumes_changes", ",", "\n", "references_volumes_changes", ")", "# returns (Pearson's correlation coefficient, 2-tailed p-value)", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.obj_assd": [[789, 843], ["numpy.mean", "binary.obj_asd", "binary.obj_asd"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.obj_asd", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.obj_asd"], ["", "def", "obj_assd", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Average symmetric surface distance.\n\n    Computes the average symmetric surface distance (ASSD) between the binary objects in\n    two images.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining what accounts\n        for a distinct binary object as well as when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        The decision on the connectivity is important, as it can influence the results\n        strongly. If in doubt, leave it as it is.\n\n    Returns\n    -------\n    assd : float\n        The average symmetric surface distance between all mutually existing distinct\n        binary object(s) in ``result`` and ``reference``. The distance unit is the same as for\n        the spacing of elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`obj_asd`\n\n    Notes\n    -----\n    This is a real metric, obtained by calling and averaging\n\n    >>> obj_asd(result, reference)\n\n    and\n\n    >>> obj_asd(reference, result)\n\n    The binary images can therefore be supplied in any order.\n    \"\"\"", "\n", "assd", "=", "numpy", ".", "mean", "(", "(", "obj_asd", "(", "result", ",", "reference", ",", "voxelspacing", ",", "connectivity", ")", ",", "\n", "obj_asd", "(", "reference", ",", "result", ",", "voxelspacing", ",", "connectivity", ")", ")", ")", "\n", "return", "assd", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.obj_asd": [[845, 986], ["list", "binary.__distinct_binary_object_correspondences", "scipy.ndimage.measurements.find_objects", "scipy.ndimage.measurements.find_objects", "list", "numpy.mean", "mapping.items", "binary.__combine_windows", "list.extend", "binary.__surface_distances"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__distinct_binary_object_correspondences", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__combine_windows", "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances"], ["", "def", "obj_asd", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Average surface distance between objects.\n\n    First correspondences between distinct binary objects in reference and result are\n    established. Then the average surface distance is only computed between corresponding\n    objects. Correspondence is defined as unique and at least one voxel overlap.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    voxelspacing : float or sequence of floats, optional\n        The voxelspacing in a distance unit i.e. spacing of elements\n        along each dimension. If a sequence, must be of length equal to\n        the input rank; if a single number, this is used for all axes. If\n        not specified, a grid spacing of unity is implied.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining what accounts\n        for a distinct binary object as well as when determining the surface\n        of the binary objects. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        The decision on the connectivity is important, as it can influence the results\n        strongly. If in doubt, leave it as it is.\n\n    Returns\n    -------\n    asd : float\n        The average surface distance between all mutually existing distinct binary\n        object(s) in ``result`` and ``reference``. The distance unit is the same as for the\n        spacing of elements along each dimension, which is usually given in mm.\n\n    See also\n    --------\n    :func:`obj_assd`\n    :func:`obj_tpr`\n    :func:`obj_fpr`\n\n    Notes\n    -----\n    This is not a real metric, as it is directed. See `obj_assd` for a real metric of this.\n\n    For the understanding of this metric, both the notions of connectedness and surface\n    distance are essential. Please see :func:`obj_tpr` and :func:`obj_fpr` for more\n    information on the first and :func:`asd` on the second.\n\n    Examples\n    --------\n    >>> arr1 = numpy.asarray([[1,1,1],[1,1,1],[1,1,1]])\n    >>> arr2 = numpy.asarray([[0,1,0],[0,1,0],[0,1,0]])\n    >>> arr1\n    array([[1, 1, 1],\n           [1, 1, 1],\n           [1, 1, 1]])\n    >>> arr2\n    array([[0, 1, 0],\n           [0, 1, 0],\n           [0, 1, 0]])\n    >>> obj_asd(arr1, arr2)\n    1.5\n    >>> obj_asd(arr2, arr1)\n    0.333333333333\n\n    With the `voxelspacing` parameter, the distances between the voxels can be set for\n    each dimension separately:\n\n    >>> obj_asd(arr1, arr2, voxelspacing=(1,2))\n    1.5\n    >>> obj_asd(arr2, arr1, voxelspacing=(1,2))\n    0.333333333333\n\n    More examples depicting the notion of object connectedness:\n\n    >>> arr1 = numpy.asarray([[1,0,1],[1,0,0],[0,0,0]])\n    >>> arr2 = numpy.asarray([[1,0,1],[1,0,0],[0,0,1]])\n    >>> arr1\n    array([[1, 0, 1],\n           [1, 0, 0],\n           [0, 0, 0]])\n    >>> arr2\n    array([[1, 0, 1],\n           [1, 0, 0],\n           [0, 0, 1]])\n    >>> obj_asd(arr1, arr2)\n    0.0\n    >>> obj_asd(arr2, arr1)\n    0.0\n\n    >>> arr1 = numpy.asarray([[1,0,1],[1,0,1],[0,0,1]])\n    >>> arr2 = numpy.asarray([[1,0,1],[1,0,0],[0,0,1]])\n    >>> arr1\n    array([[1, 0, 1],\n           [1, 0, 1],\n           [0, 0, 1]])\n    >>> arr2\n    array([[1, 0, 1],\n           [1, 0, 0],\n           [0, 0, 1]])\n    >>> obj_asd(arr1, arr2)\n    0.6\n    >>> obj_asd(arr2, arr1)\n    0.0\n\n    Influence of `connectivity` parameter can be seen in the following example, where\n    with the (default) connectivity of `1` the first array is considered to contain two\n    objects, while with an increase connectivity of `2`, just one large object is\n    detected.\n\n    >>> arr1 = numpy.asarray([[1,0,0],[0,1,1],[0,1,1]])\n    >>> arr2 = numpy.asarray([[1,0,0],[0,0,0],[0,0,0]])\n    >>> arr1\n    array([[1, 0, 0],\n           [0, 1, 1],\n           [0, 1, 1]])\n    >>> arr2\n    array([[1, 0, 0],\n           [0, 0, 0],\n           [0, 0, 0]])\n    >>> obj_asd(arr1, arr2)\n    0.0\n    >>> obj_asd(arr1, arr2, connectivity=2)\n    1.742955328\n\n    Note that the connectivity also influence the notion of what is considered an object\n    surface voxels.\n    \"\"\"", "\n", "sds", "=", "list", "(", ")", "\n", "labelmap1", ",", "labelmap2", ",", "_a", ",", "_b", ",", "mapping", "=", "__distinct_binary_object_correspondences", "(", "result", ",", "reference", ",", "connectivity", ")", "\n", "slicers1", "=", "find_objects", "(", "labelmap1", ")", "\n", "slicers2", "=", "find_objects", "(", "labelmap2", ")", "\n", "for", "lid2", ",", "lid1", "in", "list", "(", "mapping", ".", "items", "(", ")", ")", ":", "\n", "        ", "window", "=", "__combine_windows", "(", "slicers1", "[", "lid1", "-", "1", "]", ",", "slicers2", "[", "lid2", "-", "1", "]", ")", "\n", "object1", "=", "labelmap1", "[", "window", "]", "==", "lid1", "\n", "object2", "=", "labelmap2", "[", "window", "]", "==", "lid2", "\n", "sds", ".", "extend", "(", "__surface_distances", "(", "object1", ",", "object2", ",", "voxelspacing", ",", "connectivity", ")", ")", "\n", "", "asd", "=", "numpy", ".", "mean", "(", "sds", ")", "\n", "return", "asd", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.obj_fpr": [[988, 1098], ["binary.__distinct_binary_object_correspondences", "float", "len"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__distinct_binary_object_correspondences"], ["", "def", "obj_fpr", "(", "result", ",", "reference", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    The false positive rate of distinct binary object detection.\n\n    The false positive rates gives a percentage measure of how many distinct binary\n    objects in the second array do not exists in the first array. A partial overlap\n    (of minimum one voxel) is here considered sufficient.\n\n    In cases where two distinct binary object in the second array overlap with a single\n    distinct object in the first array, only one is considered to have been detected\n    successfully and the other is added to the count of false positives.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining what accounts\n        for a distinct binary object. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        The decision on the connectivity is important, as it can influence the results\n        strongly. If in doubt, leave it as it is.\n\n    Returns\n    -------\n    tpr : float\n        A percentage measure of how many distinct binary objects in ``results`` have no\n        corresponding binary object in ``reference``. It has the range :math:`[0, 1]`, where a :math:`0`\n        denotes an ideal score.\n\n    Raises\n    ------\n    RuntimeError\n        If the second array is empty.\n\n    See also\n    --------\n    :func:`obj_tpr`\n\n    Notes\n    -----\n    This is not a real metric, as it is directed. Whatever array is considered as\n    reference should be passed second. A perfect score of :math:`0` tells that there are no\n    distinct binary objects in the second array that do not exists also in the reference\n    array, but does not reveal anything about objects in the reference array also\n    existing in the second array (use :func:`obj_tpr` for this).\n\n    Examples\n    --------\n    >>> arr2 = numpy.asarray([[1,0,0],[1,0,1],[0,0,1]])\n    >>> arr1 = numpy.asarray([[0,0,1],[1,0,1],[0,0,1]])\n    >>> arr2\n    array([[1, 0, 0],\n           [1, 0, 1],\n           [0, 0, 1]])\n    >>> arr1\n    array([[0, 0, 1],\n           [1, 0, 1],\n           [0, 0, 1]])\n    >>> obj_fpr(arr1, arr2)\n    0.0\n    >>> obj_fpr(arr2, arr1)\n    0.0\n\n    Example of directedness:\n\n    >>> arr2 = numpy.asarray([1,0,1,0,1])\n    >>> arr1 = numpy.asarray([1,0,1,0,0])\n    >>> obj_fpr(arr1, arr2)\n    0.0\n    >>> obj_fpr(arr2, arr1)\n    0.3333333333333333\n\n    Examples of multiple overlap treatment:\n\n    >>> arr2 = numpy.asarray([1,0,1,0,1,1,1])\n    >>> arr1 = numpy.asarray([1,1,1,0,1,0,1])\n    >>> obj_fpr(arr1, arr2)\n    0.3333333333333333\n    >>> obj_fpr(arr2, arr1)\n    0.3333333333333333\n\n    >>> arr2 = numpy.asarray([1,0,1,1,1,0,1])\n    >>> arr1 = numpy.asarray([1,1,1,0,1,1,1])\n    >>> obj_fpr(arr1, arr2)\n    0.0\n    >>> obj_fpr(arr2, arr1)\n    0.3333333333333333\n\n    >>> arr2 = numpy.asarray([[1,0,1,0,0],\n                              [1,0,0,0,0],\n                              [1,0,1,1,1],\n                              [0,0,0,0,0],\n                              [1,0,1,0,0]])\n    >>> arr1 = numpy.asarray([[1,1,1,0,0],\n                              [0,0,0,0,0],\n                              [1,1,1,0,1],\n                              [0,0,0,0,0],\n                              [1,1,1,0,0]])\n    >>> obj_fpr(arr1, arr2)\n    0.0\n    >>> obj_fpr(arr2, arr1)\n    0.2\n    \"\"\"", "\n", "_", ",", "_", ",", "_", ",", "n_obj_reference", ",", "mapping", "=", "__distinct_binary_object_correspondences", "(", "reference", ",", "result", ",", "connectivity", ")", "\n", "return", "(", "n_obj_reference", "-", "len", "(", "mapping", ")", ")", "/", "float", "(", "n_obj_reference", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.obj_tpr": [[1100, 1209], ["binary.__distinct_binary_object_correspondences", "len", "float"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__distinct_binary_object_correspondences"], ["", "def", "obj_tpr", "(", "result", ",", "reference", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    The true positive rate of distinct binary object detection.\n\n    The true positive rates gives a percentage measure of how many distinct binary\n    objects in the first array also exists in the second array. A partial overlap\n    (of minimum one voxel) is here considered sufficient.\n\n    In cases where two distinct binary object in the first array overlaps with a single\n    distinct object in the second array, only one is considered to have been detected\n    successfully.\n\n    Parameters\n    ----------\n    result : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    reference : array_like\n        Input data containing objects. Can be any type but will be converted\n        into binary: background where 0, object everywhere else.\n    connectivity : int\n        The neighbourhood/connectivity considered when determining what accounts\n        for a distinct binary object. This value is passed to\n        `scipy.ndimage.morphology.generate_binary_structure` and should usually be :math:`> 1`.\n        The decision on the connectivity is important, as it can influence the results\n        strongly. If in doubt, leave it as it is.\n\n    Returns\n    -------\n    tpr : float\n        A percentage measure of how many distinct binary objects in ``result`` also exists\n        in ``reference``. It has the range :math:`[0, 1]`, where a :math:`1` denotes an ideal score.\n\n    Raises\n    ------\n    RuntimeError\n        If the reference object is empty.\n\n    See also\n    --------\n    :func:`obj_fpr`\n\n    Notes\n    -----\n    This is not a real metric, as it is directed. Whatever array is considered as\n    reference should be passed second. A perfect score of :math:`1` tells that all distinct\n    binary objects in the reference array also exist in the result array, but does not\n    reveal anything about additional binary objects in the result array\n    (use :func:`obj_fpr` for this).\n\n    Examples\n    --------\n    >>> arr2 = numpy.asarray([[1,0,0],[1,0,1],[0,0,1]])\n    >>> arr1 = numpy.asarray([[0,0,1],[1,0,1],[0,0,1]])\n    >>> arr2\n    array([[1, 0, 0],\n           [1, 0, 1],\n           [0, 0, 1]])\n    >>> arr1\n    array([[0, 0, 1],\n           [1, 0, 1],\n           [0, 0, 1]])\n    >>> obj_tpr(arr1, arr2)\n    1.0\n    >>> obj_tpr(arr2, arr1)\n    1.0\n\n    Example of directedness:\n\n    >>> arr2 = numpy.asarray([1,0,1,0,1])\n    >>> arr1 = numpy.asarray([1,0,1,0,0])\n    >>> obj_tpr(arr1, arr2)\n    0.6666666666666666\n    >>> obj_tpr(arr2, arr1)\n    1.0\n\n    Examples of multiple overlap treatment:\n\n    >>> arr2 = numpy.asarray([1,0,1,0,1,1,1])\n    >>> arr1 = numpy.asarray([1,1,1,0,1,0,1])\n    >>> obj_tpr(arr1, arr2)\n    0.6666666666666666\n    >>> obj_tpr(arr2, arr1)\n    0.6666666666666666\n\n    >>> arr2 = numpy.asarray([1,0,1,1,1,0,1])\n    >>> arr1 = numpy.asarray([1,1,1,0,1,1,1])\n    >>> obj_tpr(arr1, arr2)\n    0.6666666666666666\n    >>> obj_tpr(arr2, arr1)\n    1.0\n\n    >>> arr2 = numpy.asarray([[1,0,1,0,0],\n                              [1,0,0,0,0],\n                              [1,0,1,1,1],\n                              [0,0,0,0,0],\n                              [1,0,1,0,0]])\n    >>> arr1 = numpy.asarray([[1,1,1,0,0],\n                              [0,0,0,0,0],\n                              [1,1,1,0,1],\n                              [0,0,0,0,0],\n                              [1,1,1,0,0]])\n    >>> obj_tpr(arr1, arr2)\n    0.8\n    >>> obj_tpr(arr2, arr1)\n    1.0\n    \"\"\"", "\n", "_", ",", "_", ",", "n_obj_result", ",", "_", ",", "mapping", "=", "__distinct_binary_object_correspondences", "(", "reference", ",", "result", ",", "connectivity", ")", "\n", "return", "len", "(", "mapping", ")", "/", "float", "(", "n_obj_result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__distinct_binary_object_correspondences": [[1211, 1267], ["numpy.atleast_1d", "numpy.atleast_1d", "scipy.ndimage.morphology.generate_binary_structure", "scipy.ndimage.measurements.label", "scipy.ndimage.measurements.label", "scipy.ndimage.measurements.find_objects", "dict", "set", "list", "enumerate", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "numpy.unique", "sorted", "[].pop", "set.add", "len", "len", "set.add", "len", "sorted.append", "len", "set"], "function", ["None"], ["", "def", "__distinct_binary_object_correspondences", "(", "reference", ",", "result", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    Determines all distinct (where connectivity is defined by the connectivity parameter\n    passed to scipy's `generate_binary_structure`) binary objects in both of the input\n    parameters and returns a 1to1 mapping from the labelled objects in reference to the\n    corresponding (whereas a one-voxel overlap suffices for correspondence) objects in\n    result.\n\n    All stems from the problem, that the relationship is non-surjective many-to-many.\n\n    @return (labelmap1, labelmap2, n_lables1, n_labels2, labelmapping2to1)\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "\n", "# binary structure", "\n", "footprint", "=", "generate_binary_structure", "(", "result", ".", "ndim", ",", "connectivity", ")", "\n", "\n", "# label distinct binary objects", "\n", "labelmap1", ",", "n_obj_result", "=", "label", "(", "result", ",", "footprint", ")", "\n", "labelmap2", ",", "n_obj_reference", "=", "label", "(", "reference", ",", "footprint", ")", "\n", "\n", "# find all overlaps from labelmap2 to labelmap1; collect one-to-one relationships and store all one-two-many for later processing", "\n", "slicers", "=", "find_objects", "(", "labelmap2", ")", "# get windows of labelled objects", "\n", "mapping", "=", "dict", "(", ")", "# mappings from labels in labelmap2 to corresponding object labels in labelmap1", "\n", "used_labels", "=", "set", "(", ")", "# set to collect all already used labels from labelmap2", "\n", "one_to_many", "=", "list", "(", ")", "# list to collect all one-to-many mappings", "\n", "for", "l1id", ",", "slicer", "in", "enumerate", "(", "slicers", ")", ":", "# iterate over object in labelmap2 and their windows", "\n", "        ", "l1id", "+=", "1", "# labelled objects have ids sarting from 1", "\n", "bobj", "=", "(", "l1id", ")", "==", "labelmap2", "[", "slicer", "]", "# find binary object corresponding to the label1 id in the segmentation", "\n", "l2ids", "=", "numpy", ".", "unique", "(", "labelmap1", "[", "slicer", "]", "[", "\n", "bobj", "]", ")", "# extract all unique object identifiers at the corresponding positions in the reference (i.e. the mapping)", "\n", "l2ids", "=", "l2ids", "[", "0", "!=", "l2ids", "]", "# remove background identifiers (=0)", "\n", "if", "1", "==", "len", "(", "\n", "l2ids", ")", ":", "# one-to-one mapping: if target label not already used, add to final list of object-to-object mappings and mark target label as used", "\n", "            ", "l2id", "=", "l2ids", "[", "0", "]", "\n", "if", "not", "l2id", "in", "used_labels", ":", "\n", "                ", "mapping", "[", "l1id", "]", "=", "l2id", "\n", "used_labels", ".", "add", "(", "l2id", ")", "\n", "", "", "elif", "1", "<", "len", "(", "l2ids", ")", ":", "# one-to-many mapping: store relationship for later processing", "\n", "            ", "one_to_many", ".", "append", "(", "(", "l1id", ",", "set", "(", "l2ids", ")", ")", ")", "\n", "\n", "# process one-to-many mappings, always choosing the one with the least labelmap2 correspondences first", "\n", "", "", "while", "True", ":", "\n", "        ", "one_to_many", "=", "[", "(", "l1id", ",", "l2ids", "-", "used_labels", ")", "for", "l1id", ",", "l2ids", "in", "\n", "one_to_many", "]", "# remove already used ids from all sets", "\n", "one_to_many", "=", "[", "x", "for", "x", "in", "one_to_many", "if", "x", "[", "1", "]", "]", "# remove empty sets", "\n", "one_to_many", "=", "sorted", "(", "one_to_many", ",", "key", "=", "lambda", "x", ":", "len", "(", "x", "[", "1", "]", ")", ")", "# sort by set length", "\n", "if", "0", "==", "len", "(", "one_to_many", ")", ":", "\n", "            ", "break", "\n", "", "l2id", "=", "one_to_many", "[", "0", "]", "[", "1", "]", ".", "pop", "(", ")", "# select an arbitrary target label id from the shortest set", "\n", "mapping", "[", "one_to_many", "[", "0", "]", "[", "0", "]", "]", "=", "l2id", "# add to one-to-one mappings", "\n", "used_labels", ".", "add", "(", "l2id", ")", "# mark target label as used", "\n", "one_to_many", "=", "one_to_many", "[", "1", ":", "]", "# delete the processed set from all sets", "\n", "\n", "", "return", "labelmap1", ",", "labelmap2", ",", "n_obj_result", ",", "n_obj_reference", ",", "mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__surface_distances": [[1269, 1302], ["numpy.atleast_1d", "numpy.atleast_1d", "scipy.ndimage.morphology.generate_binary_structure", "scipy.ndimage.morphology.distance_transform_edt", "numpy.atleast_1d.astype", "numpy.atleast_1d.astype", "scipy.ndimage._ni_support._normalize_sequence", "numpy.asarray", "numpy.count_nonzero", "RuntimeError", "numpy.count_nonzero", "RuntimeError", "scipy.ndimage.morphology.binary_erosion", "scipy.ndimage.morphology.binary_erosion", "voxelspacing.copy.copy"], "function", ["None"], ["", "def", "__surface_distances", "(", "result", ",", "reference", ",", "voxelspacing", "=", "None", ",", "connectivity", "=", "1", ")", ":", "\n", "    ", "\"\"\"\n    The distances between the surface voxel of binary objects in result and their\n    nearest partner surface voxel of a binary object in reference.\n    \"\"\"", "\n", "result", "=", "numpy", ".", "atleast_1d", "(", "result", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "reference", "=", "numpy", ".", "atleast_1d", "(", "reference", ".", "astype", "(", "numpy", ".", "bool", ")", ")", "\n", "if", "voxelspacing", "is", "not", "None", ":", "\n", "        ", "voxelspacing", "=", "_ni_support", ".", "_normalize_sequence", "(", "voxelspacing", ",", "result", ".", "ndim", ")", "\n", "voxelspacing", "=", "numpy", ".", "asarray", "(", "voxelspacing", ",", "dtype", "=", "numpy", ".", "float64", ")", "\n", "if", "not", "voxelspacing", ".", "flags", ".", "contiguous", ":", "\n", "            ", "voxelspacing", "=", "voxelspacing", ".", "copy", "(", ")", "\n", "\n", "# binary structure", "\n", "", "", "footprint", "=", "generate_binary_structure", "(", "result", ".", "ndim", ",", "connectivity", ")", "\n", "\n", "# test for emptiness", "\n", "if", "0", "==", "numpy", ".", "count_nonzero", "(", "result", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "'The first supplied array does not contain any binary object.'", ")", "\n", "", "if", "0", "==", "numpy", ".", "count_nonzero", "(", "reference", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "'The second supplied array does not contain any binary object.'", ")", "\n", "\n", "# extract only 1-pixel border line of objects", "\n", "", "result_border", "=", "result", "^", "binary_erosion", "(", "result", ",", "structure", "=", "footprint", ",", "iterations", "=", "1", ")", "\n", "reference_border", "=", "reference", "^", "binary_erosion", "(", "reference", ",", "structure", "=", "footprint", ",", "iterations", "=", "1", ")", "\n", "\n", "# compute average surface distance", "\n", "# Note: scipys distance transform is calculated only inside the borders of the", "\n", "#       foreground objects, therefore the input has to be reversed", "\n", "dt", "=", "distance_transform_edt", "(", "~", "reference_border", ",", "sampling", "=", "voxelspacing", ")", "\n", "sds", "=", "dt", "[", "result_border", "]", "\n", "\n", "return", "sds", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.binary.__combine_windows": [[1304, 1313], ["zip", "tuple", "res.append", "slice", "min", "max"], "function", ["None"], ["", "def", "__combine_windows", "(", "w1", ",", "w2", ")", ":", "\n", "    ", "\"\"\"\n    Joins two windows (defined by tuple of slices) such that their maximum\n    combined extend is covered by the new returned window.\n    \"\"\"", "\n", "res", "=", "[", "]", "\n", "for", "s1", ",", "s2", "in", "zip", "(", "w1", ",", "w2", ")", ":", "\n", "        ", "res", ".", "append", "(", "slice", "(", "min", "(", "s1", ".", "start", ",", "s2", ".", "start", ")", ",", "max", "(", "s1", ".", "stop", ",", "s2", ".", "stop", ")", ")", ")", "\n", "", "return", "tuple", "(", "res", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.__init__": [[321, 350], ["dataloader.SliceDataset.check_files", "dataloader.SliceDataset.load_images", "print", "len", "len", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.check_files", "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.load_images"], ["    ", "def", "__init__", "(", "self", ",", "filenames", ":", "List", "[", "str", "]", ",", "folders", ":", "List", "[", "Path", "]", ",", "are_hots", ":", "List", "[", "bool", "]", ",", "\n", "bounds_generators", ":", "List", "[", "Callable", "]", ",", "transforms", ":", "List", "[", "Callable", "]", ",", "debug", "=", "False", ",", "augment", ":", "bool", "=", "False", ",", "\n", "C", "=", "2", ",", "in_memory", ":", "bool", "=", "False", ")", "->", "None", ":", "\n", "        ", "self", ".", "folders", ":", "List", "[", "Path", "]", "=", "folders", "\n", "self", ".", "transforms", ":", "List", "[", "Callable", "[", "[", "D", "]", ",", "Tensor", "]", "]", "=", "transforms", "\n", "assert", "len", "(", "self", ".", "transforms", ")", "==", "len", "(", "self", ".", "folders", ")", "\n", "\n", "self", ".", "are_hots", ":", "List", "[", "bool", "]", "=", "are_hots", "\n", "self", ".", "filenames", ":", "List", "[", "str", "]", "=", "filenames", "\n", "self", ".", "debug", "=", "debug", "\n", "self", ".", "C", ":", "int", "=", "C", "# Number of classes", "\n", "self", ".", "in_memory", ":", "bool", "=", "in_memory", "\n", "self", ".", "bounds_generators", ":", "List", "[", "Callable", "]", "=", "bounds_generators", "\n", "self", ".", "augment", ":", "bool", "=", "augment", "\n", "\n", "#print(\"self.folders\",self.folders)", "\n", "#print(\"self.filenames[:10]\",self.filenames[:10])", "\n", "if", "self", ".", "debug", ":", "\n", "            ", "self", ".", "filenames", "=", "self", ".", "filenames", "[", ":", "10", "]", "\n", "\n", "", "assert", "self", ".", "check_files", "(", ")", "# Make sure all file exists", "\n", "\n", "# Load things in memory if needed", "\n", "self", ".", "files", ":", "List", "[", "List", "[", "F", "]", "]", "=", "SliceDataset", ".", "load_images", "(", "self", ".", "folders", ",", "self", ".", "filenames", ",", "self", ".", "in_memory", ")", "\n", "assert", "len", "(", "self", ".", "files", ")", "==", "len", "(", "self", ".", "folders", ")", "\n", "for", "files", "in", "self", ".", "files", ":", "\n", "            ", "assert", "len", "(", "files", ")", "==", "len", "(", "self", ".", "filenames", ")", "\n", "\n", "", "print", "(", "f\"Initialized {self.__class__.__name__} with {len(self.filenames)} images\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.check_files": [[351, 365], ["pathlib.Path().exists", "print", "pathlib.Path().exists", "print", "pathlib.Path", "pathlib.Path"], "methods", ["None"], ["", "def", "check_files", "(", "self", ")", "->", "bool", ":", "\n", "        ", "for", "folder", "in", "self", ".", "folders", ":", "\n", "#print(folder)", "\n", "            ", "if", "not", "Path", "(", "folder", ")", ".", "exists", "(", ")", ":", "\n", "                ", "print", "(", "folder", ",", "\"does not exist\"", ")", "\n", "return", "False", "\n", "\n", "", "for", "f_n", "in", "self", ".", "filenames", ":", "\n", "#print(f_n)", "\n", "                ", "if", "not", "Path", "(", "folder", ",", "f_n", ")", ".", "exists", "(", ")", ":", "\n", "                    ", "print", "(", "folder", ",", "f_n", ",", "\"does not exist\"", ")", "\n", "return", "False", "\n", "\n", "", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.load_images": [[366, 381], ["pathlib.Path", "print", "dataloader.SliceDataset.load_images.load"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "load_images", "(", "folders", ":", "List", "[", "Path", "]", ",", "filenames", ":", "List", "[", "str", "]", ",", "in_memory", ":", "bool", ")", "->", "List", "[", "List", "[", "F", "]", "]", ":", "\n", "        ", "def", "load", "(", "folder", ":", "Path", ",", "filename", ":", "str", ")", "->", "F", ":", "\n", "            ", "p", ":", "Path", "=", "Path", "(", "folder", ",", "filename", ")", "\n", "if", "in_memory", ":", "\n", "                ", "with", "open", "(", "p", ",", "'rb'", ")", "as", "data", ":", "\n", "                    ", "res", "=", "io", ".", "BytesIO", "(", "data", ".", "read", "(", ")", ")", "\n", "", "return", "res", "\n", "", "return", "p", "\n", "", "if", "in_memory", ":", "\n", "            ", "print", "(", "\"Loading the data in memory...\"", ")", "\n", "\n", "", "files", ":", "List", "[", "List", "[", "F", "]", "]", "=", "[", "[", "load", "(", "f", ",", "im", ")", "for", "im", "in", "filenames", "]", "for", "f", "in", "folders", "]", "\n", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.__len__": [[382, 384], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "filenames", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.__getitem__": [[385, 438], ["pathlib.Path", "dataloader.SliceDataset.check_files", "t_tensors[].max", "zip", "dataloader.SliceDataset.load_images", "utils.augment", "tr", "f", "dataloader.SliceDataset.load_images", "PIL.Image.open().convert", "zip", "t_tensors[].min", "t_tensors[].max", "utils.one_hot", "zip", "f", "print", "ValueError", "zip", "PIL.Image.open", "utils.read_nii_image", "numpy.load", "utils.read_unknownformat_image"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.check_files", "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.load_images", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.augment", "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.SliceDataset.load_images", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_nii_image", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_unknownformat_image"], ["", "def", "__getitem__", "(", "self", ",", "index", ":", "int", ")", "->", "List", "[", "Any", "]", ":", "\n", "        ", "filename", ":", "str", "=", "self", ".", "filenames", "[", "index", "]", "\n", "path_name", ":", "Path", "=", "Path", "(", "filename", ")", "\n", "images", ":", "List", "[", "D", "]", "\n", "#print('get',self.folders, filename)", "\n", "try", ":", "\n", "            ", "files", "=", "SliceDataset", ".", "load_images", "(", "self", ".", "folders", "[", "0", ":", "3", "]", ",", "[", "filename", "]", ",", "self", ".", "in_memory", ")", "\n", "", "except", ":", "\n", "            ", "files", "=", "SliceDataset", ".", "load_images", "(", "self", ".", "folders", "[", "3", ":", "]", ",", "[", "filename", "]", ",", "self", ".", "in_memory", ")", "\n", "#print('files', files, self.bounds_generators)", "\n", "#print('old files', self.files[0][index])", "\n", "#print(self.files, filename)", "\n", "#print(path_name)", "\n", "", "if", "path_name", ".", "suffix", "==", "\".png\"", ":", "\n", "            ", "images", "=", "[", "Image", ".", "open", "(", "files", "[", "index", "]", ")", ".", "convert", "(", "'L'", ")", "for", "files", "in", "self", ".", "files", "]", "\n", "", "elif", "path_name", ".", "suffix", "==", "\".nii\"", ":", "\n", "#print(files)", "\n", "            ", "try", ":", "\n", "                ", "images", "=", "[", "read_nii_image", "(", "f", "[", "0", "]", ")", "for", "f", "in", "files", "]", "\n", "#print(\"nm\",[i.shape for i in images])", "\n", "", "except", ":", "\n", "                ", "images", "=", "[", "read_unknownformat_image", "(", "f", "[", "0", "]", ")", "for", "f", "in", "files", "]", "\n", "#print(\"em\",[i.shape for i in images])", "\n", "", "", "elif", "path_name", ".", "suffix", "==", "\".npy\"", ":", "\n", "            ", "images", "=", "[", "np", ".", "load", "(", "files", "[", "index", "]", ")", "for", "files", "in", "self", ".", "files", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "filename", ")", "\n", "", "if", "self", ".", "augment", ":", "\n", "            ", "images", "=", "augment", "(", "*", "images", ")", "\n", "#print(np.unique(images[1], \"after reading\"))", "\n", "", "assert", "self", ".", "check_files", "(", ")", "# Make sure all file exists", "\n", "# Final transforms and assertions", "\n", "t_tensors", ":", "List", "[", "Tensor", "]", "=", "[", "tr", "(", "e", ")", "for", "(", "tr", ",", "e", ")", "in", "zip", "(", "self", ".", "transforms", ",", "images", ")", "]", "\n", "\n", "assert", "0", "<=", "t_tensors", "[", "0", "]", ".", "min", "(", ")", "and", "t_tensors", "[", "0", "]", ".", "max", "(", ")", "<=", "1.00001", ",", "t_tensors", "[", "0", "]", ".", "max", "(", ")", "# main image is between 0 and 1", "\n", "#print(t_tensors[0].max()) ", "\n", "_", ",", "w", ",", "h", "=", "t_tensors", "[", "0", "]", ".", "shape", "\n", "\n", "for", "ttensor", ",", "is_hot", "in", "zip", "(", "t_tensors", "[", "1", ":", "]", ",", "self", ".", "are_hots", ")", ":", "# All masks (ground truths) are class encoded", "\n", "            ", "if", "is_hot", ":", "\n", "                ", "assert", "one_hot", "(", "ttensor", ",", "axis", "=", "0", ")", "\n", "#assert ttensor.shape == (self.C, w, h)", "\n", "\n", "", "", "img", ",", "gt", "=", "t_tensors", "[", ":", "2", "]", "\n", "#print(np.unique(gt),\"np unqie gt in dataloader\")", "\n", "#print(gt.shape)", "\n", "bounds", "=", "[", "f", "(", "img", ",", "gt", ",", "t", ",", "filename", ")", "for", "f", ",", "t", "in", "zip", "(", "self", ".", "bounds_generators", ",", "t_tensors", "[", "2", ":", "]", ")", "]", "\n", "try", ":", "\n", "            ", "bounds", "=", "[", "f", "(", "img", ",", "gt", ",", "t", ",", "filename", ")", "for", "f", ",", "t", "in", "zip", "(", "self", ".", "bounds_generators", ",", "t_tensors", "[", "2", ":", "]", ")", "]", "\n", "", "except", ":", "\n", "            ", "print", "(", "self", ".", "folders", ",", "filename", ",", "self", ".", "bounds_generator", ")", "\n", "# return t_tensors + [filename] + bounds", "\n", "", "return", "[", "filename", "]", "+", "t_tensors", "+", "bounds", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.PatientSampler.__init__": [[441, 474], ["print", "re.compile", "utils.map_", "list", "print", "dict", "enumerate", "print", "match.group", "set", "len", "len", "zip", "sum", "len", "random.sample", "pathlib.Path", "itertools.repeat", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ":", "SliceDataset", ",", "grp_regex", ",", "shuffle", "=", "False", ")", "->", "None", ":", "\n", "        ", "filenames", ":", "List", "[", "str", "]", "=", "dataset", ".", "filenames", "\n", "# Might be needed in case of escape sequence fuckups", "\n", "# self.grp_regex = bytes(grp_regex, \"utf-8\").decode('unicode_escape')", "\n", "self", ".", "grp_regex", "=", "grp_regex", "\n", "\n", "# Configure the shuffling function", "\n", "self", ".", "shuffle", ":", "bool", "=", "shuffle", "\n", "self", ".", "shuffle_fn", ":", "Callable", "=", "(", "lambda", "x", ":", "random", ".", "sample", "(", "x", ",", "len", "(", "x", ")", ")", ")", "if", "self", ".", "shuffle", "else", "id_", "\n", "\n", "print", "(", "f\"Grouping using {self.grp_regex} regex\"", ")", "\n", "# assert grp_regex == \"(patient\\d+_\\d+)_\\d+\"", "\n", "# grouping_regex: Pattern = re.compile(\"grp_regex\")", "\n", "grouping_regex", ":", "Pattern", "=", "re", ".", "compile", "(", "self", ".", "grp_regex", ")", "\n", "\n", "stems", ":", "List", "[", "str", "]", "=", "[", "Path", "(", "filename", ")", ".", "stem", "for", "filename", "in", "filenames", "]", "# avoid matching the extension", "\n", "matches", ":", "List", "[", "Match", "]", "=", "map_", "(", "grouping_regex", ".", "match", ",", "stems", ")", "\n", "patients", ":", "List", "[", "str", "]", "=", "[", "match", ".", "group", "(", "0", ")", "for", "match", "in", "matches", "]", "\n", "\n", "unique_patients", ":", "List", "[", "str", "]", "=", "list", "(", "set", "(", "patients", ")", ")", "\n", "assert", "len", "(", "unique_patients", ")", "<=", "len", "(", "filenames", ")", "\n", "print", "(", "f\"Found {len(unique_patients)} unique patients out of {len(filenames)} images\"", ")", "\n", "\n", "self", ".", "idx_map", ":", "Dict", "[", "str", ",", "List", "[", "int", "]", "]", "=", "dict", "(", "zip", "(", "unique_patients", ",", "repeat", "(", "None", ")", ")", ")", "\n", "for", "i", ",", "patient", "in", "enumerate", "(", "patients", ")", ":", "\n", "            ", "if", "not", "self", ".", "idx_map", "[", "patient", "]", ":", "\n", "                ", "self", ".", "idx_map", "[", "patient", "]", "=", "[", "]", "\n", "\n", "", "self", ".", "idx_map", "[", "patient", "]", "+=", "[", "i", "]", "\n", "# print(self.idx_map)", "\n", "", "assert", "sum", "(", "len", "(", "self", ".", "idx_map", "[", "k", "]", ")", "for", "k", "in", "unique_patients", ")", "==", "len", "(", "filenames", ")", "\n", "\n", "print", "(", "\"Patient to slices mapping done\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.PatientSampler.__len__": [[475, 477], ["len", "dataloader.PatientSampler.idx_map.keys"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "idx_map", ".", "keys", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.PatientSampler.__iter__": [[478, 482], ["list", "dataloader.PatientSampler.shuffle_fn", "iter", "dataloader.PatientSampler.idx_map.values"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "values", "=", "list", "(", "self", ".", "idx_map", ".", "values", "(", ")", ")", "\n", "shuffled", "=", "self", ".", "shuffle_fn", "(", "values", ")", "\n", "return", "iter", "(", "shuffled", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.RandomSampler.__init__": [[495, 511], ["isinstance", "ValueError", "ValueError", "ValueError", "isinstance"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "data_source", ",", "replacement", "=", "False", ",", "num_samples", "=", "None", ")", ":", "\n", "        ", "self", ".", "data_source", "=", "data_source", "\n", "self", ".", "replacement", "=", "replacement", "\n", "self", ".", "_num_samples", "=", "num_samples", "\n", "\n", "if", "not", "isinstance", "(", "self", ".", "replacement", ",", "bool", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"replacement should be a boolean value, but got \"", "\n", "\"replacement={}\"", ".", "format", "(", "self", ".", "replacement", ")", ")", "\n", "\n", "", "if", "self", ".", "_num_samples", "is", "not", "None", "and", "not", "replacement", ":", "\n", "            ", "raise", "ValueError", "(", "\"With replacement=False, num_samples should not be specified, \"", "\n", "\"since a random permute will be performed.\"", ")", "\n", "\n", "", "if", "not", "isinstance", "(", "self", ".", "num_samples", ",", "int", ")", "or", "self", ".", "num_samples", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"num_samples should be a positive integer \"", "\n", "\"value, but got num_samples={}\"", ".", "format", "(", "self", ".", "num_samples", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.RandomSampler.num_samples": [[512, 518], ["len"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "num_samples", "(", "self", ")", ":", "\n", "# dataset size might change at runtime", "\n", "        ", "if", "self", ".", "_num_samples", "is", "None", ":", "\n", "            ", "return", "len", "(", "self", ".", "data_source", ")", "\n", "", "return", "self", ".", "_num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.RandomSampler.__iter__": [[519, 524], ["len", "iter", "iter", "torch.randperm().tolist", "torch.randint().tolist", "torch.randperm", "torch.randint"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "n", "=", "len", "(", "self", ".", "data_source", ")", "\n", "if", "self", ".", "replacement", ":", "\n", "            ", "return", "iter", "(", "torch", ".", "randint", "(", "high", "=", "n", ",", "size", "=", "(", "self", ".", "num_samples", ",", ")", ",", "dtype", "=", "torch", ".", "int64", ")", ".", "tolist", "(", ")", ")", "\n", "", "return", "iter", "(", "torch", ".", "randperm", "(", "n", ")", ".", "tolist", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.RandomSampler.__len__": [[525, 527], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.cumsum": [[541, 549], ["len", "r.append"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "cumsum", "(", "sequence", ")", ":", "\n", "        ", "r", ",", "s", "=", "[", "]", ",", "0", "\n", "for", "e", "in", "sequence", ":", "\n", "            ", "l", "=", "len", "(", "e", ")", "\n", "r", ".", "append", "(", "l", "+", "s", ")", "\n", "s", "+=", "l", "\n", "", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.__init__": [[550, 555], ["torch.utils.data.Dataset.__init__", "list", "dataloader.ConcatDataset.cumsum", "len"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__", "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.cumsum"], ["", "def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "super", "(", "ConcatDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "assert", "len", "(", "datasets", ")", ">", "0", ",", "'datasets should not be an empty iterable'", "\n", "self", ".", "datasets", "=", "list", "(", "datasets", ")", "\n", "self", ".", "cumulative_sizes", "=", "self", ".", "cumsum", "(", "self", ".", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.__len__": [[556, 558], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "cumulative_sizes", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.__getitem__": [[559, 570], ["bisect.bisect_right", "len", "ValueError", "len"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "idx", "<", "0", ":", "\n", "            ", "if", "-", "idx", ">", "len", "(", "self", ")", ":", "\n", "                ", "raise", "ValueError", "(", "\"absolute value of index should not exceed dataset length\"", ")", "\n", "", "idx", "=", "len", "(", "self", ")", "+", "idx", "\n", "", "dataset_idx", "=", "bisect", ".", "bisect_right", "(", "self", ".", "cumulative_sizes", ",", "idx", ")", "\n", "if", "dataset_idx", "==", "0", ":", "\n", "            ", "sample_idx", "=", "idx", "\n", "", "else", ":", "\n", "            ", "sample_idx", "=", "idx", "-", "self", ".", "cumulative_sizes", "[", "dataset_idx", "-", "1", "]", "\n", "", "return", "self", ".", "datasets", "[", "dataset_idx", "]", "[", "sample_idx", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.cummulative_sizes": [[571, 576], ["warnings.warn"], "methods", ["None"], ["", "@", "property", "\n", "def", "cummulative_sizes", "(", "self", ")", ":", "\n", "        ", "warnings", ".", "warn", "(", "\"cummulative_sizes attribute is renamed to \"", "\n", "\"cumulative_sizes\"", ",", "DeprecationWarning", ",", "stacklevel", "=", "2", ")", "\n", "return", "self", ".", "cumulative_sizes", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.Concat.__init__": [[580, 585], ["numpy.cumsum", "numpy.sum", "len"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.ConcatDataset.cumsum"], ["    ", "def", "__init__", "(", "self", ",", "datasets", ")", ":", "\n", "        ", "self", ".", "datasets", "=", "datasets", "\n", "self", ".", "lengths", "=", "[", "len", "(", "d", ")", "for", "d", "in", "datasets", "]", "\n", "self", ".", "offsets", "=", "np", ".", "cumsum", "(", "self", ".", "lengths", ")", "\n", "self", ".", "length", "=", "np", ".", "sum", "(", "self", ".", "lengths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.Concat.__getitem__": [[586, 593], ["enumerate", "IndexError"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "for", "i", ",", "offset", "in", "enumerate", "(", "self", ".", "offsets", ")", ":", "\n", "            ", "if", "index", "<", "offset", ":", "\n", "                ", "if", "i", ">", "0", ":", "\n", "                    ", "index", "-=", "self", ".", "offsets", "[", "i", "-", "1", "]", "\n", "", "return", "self", ".", "datasets", "[", "i", "]", "[", "index", "]", "\n", "", "", "raise", "IndexError", "(", "f'{index} exceeds {self.length}'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.Concat.__len__": [[594, 596], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "length", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.nii_transform": [[28, 32], ["torchvision.transforms.Compose", "torch.tensor"], "function", ["None"], ["def", "nii_transform", "(", "resolution", ":", "Tuple", "[", "float", ",", "...", "]", ",", "K", ":", "int", ")", "->", "Callable", "[", "[", "D", "]", ",", "Tensor", "]", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "nd", ":", "(", "(", "nd", "+", "4", ")", "/", "8", ")", ",", "# max <= 1 ", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.nii_gt_transform": [[34, 39], ["torchvision.transforms.Compose", "functools.partial", "operator.itemgetter", "torch.tensor"], "function", ["None"], ["", "def", "nii_gt_transform", "(", "resolution", ":", "Tuple", "[", "float", ",", "...", "]", ",", "K", ":", "int", ")", "->", "Callable", "[", "[", "D", "]", ",", "Tensor", "]", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "# need to Add one dimension to simulate batch ", "\n", "partial", "(", "class2one_hot", ",", "K", "=", "K", ")", ",", "\n", "itemgetter", "(", "0", ")", ",", "# Then pop the element to go back to img shape ", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.dummy_transform": [[41, 47], ["torchvision.transforms.Compose", "functools.partial", "operator.itemgetter", "torch.tensor", "torch.zeros_like"], "function", ["None"], ["", "def", "dummy_transform", "(", "resolution", ":", "Tuple", "[", "float", ",", "...", "]", ",", "K", ":", "int", ")", "->", "Callable", "[", "[", "D", "]", ",", "Tensor", "]", ":", "\n", "        ", "return", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "lambda", "t", ":", "torch", ".", "zeros_like", "(", "t", ")", ",", "\n", "partial", "(", "class2one_hot", ",", "K", "=", "K", ")", ",", "\n", "itemgetter", "(", "0", ")", "# Then pop the element to go back to img shape", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.dataloader.get_loaders": [[49, 317], ["torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "eval", "eval", "zip", "zip", "functools.partial", "functools.partial", "functools.partial", "functools.partial", "utils.map_", "functools.partial.", "functools.partial.", "utils.map_", "functools.partial.", "functools.partial.", "eval", "eval", "getattr", "bounds_generators.append", "eval", "pathlib.Path", "train_folders[].glob", "len", "utils.map_", "len", "utils.map_", "print", "random.shuffle", "range", "functools.partial.", "dataloader.Concat", "print", "val_folders[].glob", "len", "len", "utils.map_", "utils.map_", "functools.partial", "operator.itemgetter", "functools.partial", "operator.itemgetter", "functools.partial", "operator.itemgetter", "functools.partial", "operator.itemgetter", "functools.partial", "operator.itemgetter", "functools.partial", "operator.itemgetter", "bounds_generators.append", "__import__", "getattr.", "str", "utils.map_", "utils.map_", "train_folders[].glob", "train_folders[].glob", "random.shuffle", "re.split", "pathlib.Path", "print", "utils.map_", "pathlib.Path", "print", "str", "utils.map_", "utils.map_", "val_folders[].glob", "val_folders[].glob", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "utils.remap", "torch.tensor", "torch.tensor", "pathlib.Path", "pathlib.Path", "pathlib.Path", "train_folders[].glob", "train_folders[].glob", "str", "str", "str", "itertools.chain", "train_folders[].glob", "pathlib.Path", "print", "val_folders[].glob", "val_folders[].glob", "str", "str", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "torch.zeros", "pathlib.Path", "str", "str", "range", "range", "str", "itertools.chain", "str", "pathlib.Path", "pathlib.Path", "str", "str", "nd.min", "nd.max", "nd.min", "pathlib.Path", "range", "range", "range", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.remap"], ["", "def", "get_loaders", "(", "args", ",", "data_folder", ":", "str", ",", "subfolders", ":", "str", ",", "\n", "batch_size", ":", "int", ",", "n_class", ":", "int", ",", "\n", "debug", ":", "bool", ",", "in_memory", ":", "bool", ",", "dtype", ",", "shuffle", ":", "bool", ",", "mode", ":", "str", ",", "val_subfolders", ":", "\"\"", ")", "->", "Tuple", "[", "DataLoader", ",", "DataLoader", "]", ":", "\n", "\n", "    ", "nii_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "lambda", "nd", ":", "nd", "[", ":", ",", "0", ":", "384", ",", "0", ":", "384", "]", ",", "\n", "#lambda nd: print(nd.shape),", "\n", "]", ")", "\n", "\n", "nii_gt_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "partial", "(", "class2one_hot", ",", "C", "=", "n_class", ")", ",", "\n", "lambda", "nd", ":", "nd", "[", ":", ",", ":", ",", "0", ":", "384", ",", "0", ":", "384", "]", ",", "\n", "itemgetter", "(", "0", ")", ",", "\n", "#lambda nd: print(nd.shape,\"nii gt rtans\")", "\n", "]", ")", "\n", "\n", "\n", "nii_transform_normalize", "=", "transforms", ".", "Compose", "(", "[", "\n", "#lambda img: np.array(img)[np.newaxis, ...],", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "float32", ")", ",", "\n", "lambda", "nd", ":", "nd", "[", ":", ",", "0", ":", "384", ",", "0", ":", "384", "]", ",", "\n", "#lambda nd: nd[:,0:384,0:384],", "\n", "lambda", "nd", ":", "(", "nd", "-", "nd", ".", "min", "(", ")", ")", "/", "(", "nd", ".", "max", "(", ")", "-", "nd", ".", "min", "(", ")", ")", ",", "# max <= 1", "\n", "#lambda nd: print(nd.shape),", "\n", "]", ")", "\n", "\n", "nii_gt_transform_expand", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "img", ":", "np", ".", "array", "(", "img", ")", "[", "np", ".", "newaxis", ",", "...", "]", ",", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "#lambda nd: nd[:,0:384,0:384],", "\n", "partial", "(", "class2one_hot", ",", "C", "=", "n_class", ")", ",", "\n", "itemgetter", "(", "0", ")", ",", "\n", "#lambda nd: print(nd.shape,\"nii gt rtans\")", "\n", "]", ")", "\n", "\n", "png_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "img", ":", "np", ".", "array", "(", "img", ")", "[", "np", ".", "newaxis", ",", "...", "]", ",", "\n", "lambda", "nd", ":", "nd", "/", "255", ",", "# max <= 1", "\n", "# lambda nd: np.pad(nd, [(0,0), (0,0), (110,110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256,256),", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "dtype", ")", "\n", "]", ")", "\n", "imnpy_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "nd", ":", "nd", "/", "255", ",", "# max <= 1", "\n", "# lambda nd: np.pad(nd, [(0,0), (0,0), (110,110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256,256),", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "dtype", ")", "\n", "]", ")", "\n", "npy_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "img", ":", "np", ".", "array", "(", "img", ")", "[", "np", ".", "newaxis", ",", "...", "]", ",", "\n", "lambda", "nd", ":", "nd", "/", "255", ",", "# max <= 1", "\n", "#lambda nd: np.pad(nd, [(0,0), (0,0), (110,110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256, 256),", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "dtype", ")", "\n", "]", ")", "\n", "gtnpy_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "img", ":", "np", ".", "array", "(", "img", ")", "[", "np", ".", "newaxis", ",", "...", "]", ",", "\n", "#lambda nd: np.pad(nd, [(0, 0), (0, 0), (110, 110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256, 256),", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "#lambda nd: remap({0:0, 36:4, 72:0, 109:1, 145:0, 182:2, 218:3, 255:0},nd),", "\n", "partial", "(", "class2one_hot", ",", "C", "=", "n_class", ")", ",", "\n", "itemgetter", "(", "0", ")", "\n", "]", ")", "\n", "gt_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "#lambda img: np.array(img)[np.newaxis, ...],", "\n", "#lambda nd: np.pad(nd, [(0, 0), (0, 0), (110, 110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256, 256),", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "#lambda nd: print(nd.shape,\"nd in gt transform\"),", "\n", "partial", "(", "class2one_hot", ",", "C", "=", "n_class", ")", ",", "\n", "itemgetter", "(", "0", ")", ",", "\n", "]", ")", "\n", "gtpng_transform_remap", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "img", ":", "np", ".", "array", "(", "img", ")", "[", "np", ".", "newaxis", ",", "...", "]", ",", "\n", "#lambda nd: np.pad(nd, [(0, 0), (0, 0), (110, 110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256, 256),", "\n", "lambda", "nd", ":", "remap", "(", "{", "0", ":", "0", ",", "1", ":", "1", ",", "255", ":", "1", "}", ",", "nd", ")", ",", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "#lambda nd: print(nd.shape,\"nd in gt transform\"),", "\n", "partial", "(", "class2one_hot", ",", "C", "=", "n_class", ")", ",", "\n", "itemgetter", "(", "0", ")", ",", "\n", "]", ")", "\n", "gtpng_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "lambda", "img", ":", "np", ".", "array", "(", "img", ")", "[", "np", ".", "newaxis", ",", "...", "]", ",", "\n", "#lambda nd: np.pad(nd, [(0, 0), (0, 0), (110, 110)], 'constant'),", "\n", "#lambda nd: pad_to(nd, 256, 256),", "\n", "lambda", "nd", ":", "torch", ".", "tensor", "(", "nd", ",", "dtype", "=", "torch", ".", "int64", ")", ",", "\n", "#lambda nd: print(nd.shape,\"nd in gt transform\"),", "\n", "partial", "(", "class2one_hot", ",", "C", "=", "n_class", ")", ",", "\n", "itemgetter", "(", "0", ")", ",", "\n", "]", ")", "\n", "\n", "\n", "\n", "if", "mode", "==", "\"target\"", ":", "\n", "        ", "losses", "=", "eval", "(", "args", ".", "target_losses", ")", "\n", "", "else", ":", "\n", "        ", "losses", "=", "eval", "(", "args", ".", "source_losses", ")", "\n", "\n", "", "bounds_generators", ":", "List", "[", "Callable", "]", "=", "[", "]", "\n", "for", "_", ",", "_", ",", "bounds_name", ",", "bounds_params", ",", "fn", ",", "_", "in", "losses", ":", "\n", "        ", "if", "bounds_name", "is", "None", ":", "\n", "            ", "bounds_generators", ".", "append", "(", "lambda", "*", "a", ":", "torch", ".", "zeros", "(", "n_class", ",", "1", ",", "2", ")", ")", "\n", "continue", "\n", "", "bounds_class", "=", "getattr", "(", "__import__", "(", "'bounds'", ")", ",", "bounds_name", ")", "\n", "bounds_generators", ".", "append", "(", "bounds_class", "(", "C", "=", "args", ".", "n_class", ",", "fn", "=", "fn", ",", "**", "bounds_params", ")", ")", "\n", "", "folders_list", "=", "eval", "(", "subfolders", ")", "\n", "val_folders_list", "=", "eval", "(", "subfolders", ")", "\n", "if", "val_subfolders", "!=", "\"\"", ":", "\n", "        ", "val_folders_list", "=", "eval", "(", "val_subfolders", ")", "\n", "\n", "# print(folders_list)", "\n", "", "folders", ",", "trans", ",", "are_hots", "=", "zip", "(", "*", "folders_list", ")", "\n", "valfolders", ",", "val_trans", ",", "val_are_hots", "=", "zip", "(", "*", "val_folders_list", ")", "\n", "# Create partial functions: Easier for readability later (see the difference between train and validation)", "\n", "gen_dataset", "=", "partial", "(", "SliceDataset", ",", "\n", "transforms", "=", "trans", ",", "\n", "are_hots", "=", "are_hots", ",", "\n", "debug", "=", "debug", ",", "\n", "C", "=", "n_class", ",", "\n", "in_memory", "=", "in_memory", ",", "augment", "=", "args", ".", "augment", ",", "\n", "bounds_generators", "=", "bounds_generators", ")", "\n", "gen_dataset_noaug", "=", "partial", "(", "SliceDataset", ",", "\n", "transforms", "=", "trans", ",", "\n", "are_hots", "=", "are_hots", ",", "\n", "debug", "=", "debug", ",", "\n", "C", "=", "n_class", ",", "\n", "in_memory", "=", "in_memory", ",", "augment", "=", "False", ",", "\n", "bounds_generators", "=", "bounds_generators", ")", "\n", "valgen_dataset", "=", "partial", "(", "SliceDataset", ",", "\n", "transforms", "=", "val_trans", ",", "\n", "are_hots", "=", "val_are_hots", ",", "\n", "debug", "=", "debug", ",", "\n", "C", "=", "n_class", ",", "\n", "in_memory", "=", "in_memory", ",", "augment", "=", "False", ",", "\n", "bounds_generators", "=", "bounds_generators", ")", "\n", "\n", "data_loader", "=", "partial", "(", "DataLoader", ",", "\n", "num_workers", "=", "4", ",", "\n", "#num_workers=min(cpu_count(), batch_size + 4),", "\n", "#num_workers=1,", "\n", "pin_memory", "=", "True", ")", "\n", "\n", "# Prepare the datasets and dataloaders", "\n", "train_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"train\"", ",", "f", ")", "for", "f", "in", "folders", "]", "\n", "if", "args", ".", "trainval", ":", "\n", "#train_folders: List[Path] = [Path(data_folder, \"trainval\", f) for f in folders]", "\n", "        ", "train_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"train\"", ",", "f", ")", "for", "f", "in", "folders", "]", "+", "[", "Path", "(", "data_folder", ",", "\"val\"", ",", "f", ")", "for", "f", "in", "folders", "]", "\n", "", "elif", "args", ".", "trainonly", ":", "\n", "        ", "train_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"train\"", ",", "f", ")", "for", "f", "in", "folders", "]", "\n", "", "elif", "args", ".", "valonly", ":", "\n", "        ", "train_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"val\"", ",", "f", ")", "for", "f", "in", "folders", "]", "\n", "", "elif", "args", ".", "testonly", ":", "\n", "        ", "train_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"test\"", ",", "f", ")", "for", "f", "in", "folders", "]", "\n", "", "elif", "args", ".", "direct", ":", "\n", "        ", "train_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "f", ")", "for", "f", "in", "folders", "]", "\n", "#if args.ontrain1:", "\n", "#    train_folders: List[Path] = [Path(data_folder, \"train1\", f) for f in folders]", "\n", "# I assume all files have the same name inside their folder: makes things much easier", "\n", "#print(list(train_folders[0].glob(\"*nii\")))", "\n", "#print(train_folders,\"train_folders\",args.train_grp_regex)", "\n", "", "train_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "train_folders", "[", "0", "]", ".", "glob", "(", "args", ".", "train_grp_regex", "+", "\"*nii\"", ")", ")", "\n", "if", "args", ".", "trainval", ":", "\n", "        ", "train_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "train_folders", "[", "0", "]", ".", "glob", "(", "args", ".", "train_grp_regex", "+", "\"*nii\"", ")", ")", "+", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "train_folders", "[", "4", "]", ".", "glob", "(", "args", ".", "train_grp_regex", "+", "\"*nii\"", ")", ")", "\n", "#print(\"train_names\",train_names)", "\n", "\n", "", "if", "len", "(", "train_names", ")", "==", "0", ":", "\n", "        ", "train_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "train_folders", "[", "0", "]", ".", "glob", "(", "args", ".", "train_grp_regex", "+", "\"*.png\"", ")", ")", "\n", "", "if", "len", "(", "train_names", ")", "==", "0", ":", "\n", "        ", "train_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "train_folders", "[", "0", "]", ".", "glob", "(", "\"*.npy\"", ")", ")", "\n", "#train_names.sort()", "\n", "", "if", "args", ".", "train_case_nb", ">", "0", ":", "\n", "# print('hello')", "\n", "        ", "vec_prostate", "=", "[", "\"Case00\"", ",", "\"Case01\"", ",", "\"Case03\"", ",", "\"Case04\"", ",", "\"Case06\"", ",", "\"Case09\"", ",", "\"Case10\"", ",", "\"Case11\"", ",", "\"Case13\"", ",", "\"Case14\"", ",", "\n", "\"Case16\"", ",", "\"Case18\"", ",", "\"Case19\"", ",", "\"Case21\"", ",", "\"Case23\"", ",", "\"Case24\"", ",", "\"Case25\"", ",", "\"Case27\"", ",", "\"Case28\"", ",", "\"Case29\"", "]", "\n", "vec_ivd", "=", "[", "\"Subj_\"", "+", "str", "(", "i", ")", "for", "i", "in", "chain", "(", "range", "(", "1", ",", "5", ")", ",", "range", "(", "6", ",", "15", ")", ")", "]", "\n", "#aug_vec_ivd = ['a'+ v for v in vec_ivd] +['b'+v for v in vec_ivd] +['c'+v for v in vec_ivd] + ['d'+v for v in vec_ivd] + ['w'+v for v in vec_ivd]", "\n", "if", "args", ".", "valonly", ":", "\n", "            ", "vec_ivd", "=", "[", "\"Subj_\"", "+", "str", "(", "i", ")", "for", "i", "in", "chain", "(", "range", "(", "0", ",", "1", ")", ",", "range", "(", "5", ",", "6", ")", ",", "range", "(", "15", ",", "16", ")", ")", "]", "\n", "random", ".", "shuffle", "(", "vec_ivd", ")", "\n", "aug_vec_ivd", "=", "[", "'a'", "+", "v", "for", "v", "in", "vec_ivd", "]", "+", "[", "'b'", "+", "v", "for", "v", "in", "vec_ivd", "]", "+", "[", "'w'", "+", "v", "for", "v", "in", "vec_ivd", "]", "\n", "#vec_ivd +=aug_vec_ivd", "\n", "", "print", "(", "train_names", "[", "0", "]", ")", "\n", "\n", "root_name", "=", "re", ".", "split", "(", "'(\\d+)'", ",", "train_names", "[", "0", "]", ")", "[", "0", "]", "\n", "extension", "=", "Path", "(", "train_names", "[", "0", "]", ")", ".", "suffix", "\n", "if", "root_name", "==", "\"Case\"", ":", "\n", "            ", "vec", "=", "vec_prostate", "\n", "", "else", ":", "\n", "            ", "vec", "=", "vec_ivd", "\n", "", "if", "args", ".", "specific_subj", ":", "\n", "            ", "vec", "=", "[", "args", ".", "specific_subj", "]", "\n", "", "random", ".", "shuffle", "(", "vec", ")", "\n", "train_names", "=", "[", "]", "\n", "#print(vec,'vec')", "\n", "for", "i", "in", "range", "(", "0", ",", "args", ".", "train_case_nb", ")", ":", "\n", "            ", "tmp_reg", "=", "\"*\"", "+", "vec", "[", "i", "]", "+", "\"_*\"", "+", "extension", "\n", "print", "(", "tmp_reg", ",", "'tmp reg'", ")", "\n", "tmp_train_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "train_folders", "[", "0", "]", ".", "glob", "(", "tmp_reg", ")", ")", "\n", "train_names", "=", "train_names", "+", "tmp_train_names", "\n", "#print(train_names)", "\n", "\n", "", "", "train_set", "=", "gen_dataset", "(", "train_names", ",", "\n", "train_folders", ")", "\n", "if", "args", ".", "augment", ":", "\n", "        ", "train_set_noaug", "=", "gen_dataset_noaug", "(", "train_names", ",", "\n", "train_folders", ")", "\n", "train_set", "=", "Concat", "(", "[", "train_set", ",", "train_set_noaug", "]", ")", "\n", "#if fix_size!=[0,0] and len(train_set)<fix_size[0]:", "\n", "#nb_to_add= fix_size[0] - len(train_set)", "\n", "#print(\"nb_to_add\", nb_to_add)", "\n", "#train_set_2 = RandomSampler(train_set, replacement=True, num_samples=nb_to_add)", "\n", "#   train_set =  Concat([train_set, train_set])", "\n", "\n", "", "train_loader", "=", "data_loader", "(", "train_set", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "drop_last", "=", "False", ")", "\n", "\n", "#train_loader= torch.utils.data.RandomSampler(data_source, replacement=False, num_samples=None)", "\n", "if", "args", ".", "ontest", ":", "\n", "        ", "print", "(", "'on test'", ")", "\n", "val_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"test\"", ",", "f", ")", "for", "f", "in", "valfolders", "]", "\n", "\n", "", "elif", "args", ".", "ontrain", ":", "\n", "        ", "print", "(", "'on train'", ")", "\n", "val_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"train\"", ",", "f", ")", "for", "f", "in", "valfolders", "]", "\n", "", "elif", "args", ".", "direct", ":", "\n", "        ", "val_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "f", ")", "for", "f", "in", "valfolders", "]", "\n", "", "else", ":", "#/", "\n", "        ", "print", "(", "'on val'", ")", "\n", "val_folders", ":", "List", "[", "Path", "]", "=", "[", "Path", "(", "data_folder", ",", "\"val\"", ",", "f", ")", "for", "f", "in", "valfolders", "]", "\n", "#print(val_folders,\"(val_folders\" )", "\n", "", "val_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "val_folders", "[", "0", "]", ".", "glob", "(", "\"*.npy\"", ")", ")", "\n", "if", "len", "(", "val_names", ")", "==", "0", ":", "\n", "        ", "if", "\"slice\"", "in", "args", ".", "grp_regex", ":", "\n", "            ", "val_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "val_folders", "[", "0", "]", ".", "glob", "(", "args", ".", "train_grp_regex", "+", "\"*\"", ")", ")", "\n", "#val_names: List[str] = map_(lambda p: str(p.name), val_folders[0].glob(\"*.nii\"))", "\n", "", "else", ":", "\n", "            ", "val_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "val_folders", "[", "0", "]", ".", "glob", "(", "\"*.nii\"", ")", ")", "\n", "", "", "if", "len", "(", "val_names", ")", "==", "0", ":", "\n", "        ", "val_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "val_folders", "[", "0", "]", ".", "glob", "(", "\"*.png\"", ")", ")", "\n", "", "if", "args", ".", "tta", ":", "\n", "        ", "val_names", ":", "List", "[", "str", "]", "=", "map_", "(", "lambda", "p", ":", "str", "(", "p", ".", "name", ")", ",", "val_folders", "[", "0", "]", ".", "glob", "(", "tmp_reg", ")", ")", "\n", "\n", "", "val_set", "=", "valgen_dataset", "(", "val_names", ",", "\n", "val_folders", ")", "\n", "\n", "#if fix_size!=[0,0] and len(val_set)<fix_size[1]:", "\n", "#nb_to_add= fix_size[1] - len(val_set)", "\n", "#val_set_2 = RandomSampler(val_set, replacement=True, num_samples=nb_to_add)", "\n", "#val_set =  Concat([val_set, val_set, val_set, val_set , val_set])", "\n", "\n", "#val_sampler = PatientSampler(val_set, args.grp_regex, shuffle=shuffle)", "\n", "# val_sampler = None", "\n", "# val_loader = data_loader(val_set,", "\n", "#                          batch_sampler=val_sampler)", "\n", "\n", "val_loader", "=", "data_loader", "(", "val_set", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "False", ",", "\n", "drop_last", "=", "False", ")", "\n", "\n", "return", "train_loader", ",", "val_loader", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.BCELoss.__init__": [[1109, 1113], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "self", ".", "dtype", "=", "kwargs", "[", "\"dtype\"", "]", "\n", "#print(f\"Initialized {self.__class__.__name__} with {kwargs}\")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.BCELoss.__call__": [[1115, 1119], ["torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss.", "torch.nn.BCEWithLogitsLoss.", "torch.Tensor().fill_().to", "torch.Tensor().fill_().to", "torch.Tensor().fill_", "torch.Tensor().fill_", "torch.Tensor", "torch.Tensor", "d_out.data.size"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "d_out", ":", "Tensor", ",", "label", ":", "float", ")", ":", "\n", "        ", "bce_loss", "=", "torch", ".", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "loss", "=", "bce_loss", "(", "d_out", ",", "Tensor", "(", "d_out", ".", "data", ".", "size", "(", ")", ")", ".", "fill_", "(", "label", ")", ".", "to", "(", "d_out", ".", "device", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_dic_diff": [[47, 50], ["set", "set"], "function", ["None"], ["def", "get_dic_diff", "(", "a", ",", "b", ")", ":", "\n", "    ", "value", "=", "set", "(", "a", ")", "-", "set", "(", "b", ")", "\n", "return", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_mom_posmed": [[51, 56], ["numpy.round", "numpy.median", "range", "[].cpu().numpy", "range", "[].cpu", "len"], "function", ["None"], ["", "def", "get_mom_posmed", "(", "nclass", ",", "mom", ",", "sizes", ",", "th", ")", ":", "\n", "    ", "med", "=", "[", "np", ".", "round", "(", "\n", "np", ".", "median", "(", "[", "mom", "[", "i", "]", "[", "j", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "mom", ")", ")", "if", "sizes", "[", "i", "]", "[", "j", "]", ">", "th", "[", "0", "]", "[", "j", "]", "and", "sizes", "[", "i", "]", "[", "j", "]", "<", "th", "[", "1", "]", "[", "j", "]", "]", ")", ",", "2", ")", "for", "\n", "j", "in", "range", "(", "0", ",", "nclass", ")", "]", "\n", "return", "med", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_mom_posav": [[57, 62], ["numpy.round", "numpy.mean", "range", "[].cpu().numpy", "range", "[].cpu", "len"], "function", ["None"], ["", "def", "get_mom_posav", "(", "nclass", ",", "mom", ",", "sizes", ",", "th", ")", ":", "\n", "    ", "med", "=", "[", "np", ".", "round", "(", "\n", "np", ".", "mean", "(", "[", "mom", "[", "i", "]", "[", "j", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "mom", ")", ")", "if", "sizes", "[", "i", "]", "[", "j", "]", ">", "th", "[", "0", "]", "[", "j", "]", "and", "sizes", "[", "i", "]", "[", "j", "]", "<", "th", "[", "1", "]", "[", "j", "]", "]", ")", ",", "2", ")", "for", "\n", "j", "in", "range", "(", "0", ",", "nclass", ")", "]", "\n", "return", "med", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_linreg_coef": [[63, 76], ["range", "numpy.array().astype().squeeze", "numpy.array().astype().squeeze", "statsmodels.formula.api.ols().fit", "slopes.append", "ints.append", "[].squeeze().cpu().numpy", "numpy.array().astype", "[].squeeze().cpu().numpy", "numpy.array().astype", "statsmodels.formula.api.ols", "range", "range", "[].squeeze().cpu", "len", "numpy.array", "[].squeeze().cpu", "len", "numpy.array", "dict", "[].squeeze", "[].squeeze"], "function", ["None"], ["", "def", "get_linreg_coef", "(", "nclass", ",", "mom", ",", "sizes", ",", "thresholdsize", ")", ":", "\n", "    ", "slopes", "=", "[", "]", "\n", "ints", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "0", ",", "nclass", ")", ":", "\n", "        ", "x", "=", "[", "[", "sizes", "[", "i", "]", "[", "j", "]", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "mom", ")", ")", "if", "sizes", "[", "i", "]", "[", "j", "]", ">", "thresholdsize", "]", "]", "\n", "x", "=", "np", ".", "array", "(", "x", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "squeeze", "(", "0", ")", "\n", "y", "=", "[", "[", "mom", "[", "i", "]", "[", "j", "]", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "for", "i", "in", "range", "(", "0", ",", "len", "(", "mom", ")", ")", "if", "sizes", "[", "i", "]", "[", "j", "]", ">", "thresholdsize", "]", "]", "\n", "y", "=", "np", ".", "array", "(", "y", ")", ".", "astype", "(", "np", ".", "float32", ")", ".", "squeeze", "(", "0", ")", "\n", "regression", "=", "ols", "(", "\"data ~ x\"", ",", "data", "=", "dict", "(", "data", "=", "y", ",", "x", "=", "x", ")", ")", ".", "fit", "(", ")", "\n", "params", "=", "regression", ".", "params", "\n", "slopes", ".", "append", "(", "params", "[", "1", "]", ")", "\n", "ints", ".", "append", "(", "params", "[", "0", "]", ")", "\n", "", "return", "[", "slopes", ",", "ints", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_subj_nb": [[79, 82], ["int", "re.split"], "function", ["None"], ["", "def", "get_subj_nb", "(", "filenames_vec", ")", ":", "\n", "    ", "subj_nb", "=", "[", "int", "(", "re", ".", "split", "(", "'(\\d+)'", ",", "x", ")", "[", "1", "]", ")", "for", "x", "in", "filenames_vec", "]", "\n", "return", "subj_nb", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_weights": [[85, 101], ["numpy.sum", "print", "numpy.round", "len", "numpy.sum", "len", "len"], "function", ["None"], ["", "def", "get_weights", "(", "list1", ")", ":", "\n", "    ", "if", "len", "(", "list1", ")", "==", "5", ":", "\n", "        ", "m0", ",", "m1", ",", "m2", ",", "m3", ",", "m4", "=", "list1", "\n", "", "elif", "len", "(", "list1", ")", "==", "4", ":", "\n", "        ", "m1", ",", "m2", ",", "m3", ",", "m4", "=", "list1", "\n", "m0", "=", "256", "*", "256", "-", "m1", "-", "m2", "-", "m3", "-", "m4", "\n", "list1", "=", "[", "m0", "]", "+", "list1", "\n", "", "elif", "len", "(", "list1", ")", "==", "1", ":", "\n", "        ", "m1", "=", "list1", "[", "0", "]", "\n", "m0", "=", "256", "*", "36", "-", "m1", "\n", "list1", "=", "[", "m0", "]", "+", "list1", "\n", "", "inv", "=", "[", "1", "/", "m", "for", "m", "in", "list1", "]", "\n", "N", "=", "np", ".", "sum", "(", "inv", ")", "\n", "w_vec", "=", "[", "i", "/", "N", "for", "i", "in", "inv", "]", "\n", "print", "(", "np", ".", "sum", "(", "w_vec", ")", ")", "\n", "return", "np", ".", "round", "(", "w_vec", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.Nmaxelements": [[103, 117], ["range", "range", "list1.remove", "final_list.append", "len"], "function", ["None"], ["", "def", "Nmaxelements", "(", "list1", ",", "N", ")", ":", "\n", "    ", "final_list", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "N", ")", ":", "\n", "        ", "max1", "=", "0", "\n", "\n", "for", "j", "in", "range", "(", "len", "(", "list1", ")", ")", ":", "\n", "            ", "if", "list1", "[", "j", "]", ">", "max1", ":", "\n", "                ", "max1", "=", "list1", "[", "j", "]", ";", "\n", "\n", "", "", "list1", ".", "remove", "(", "max1", ")", ";", "\n", "final_list", ".", "append", "(", "max1", ")", "\n", "\n", "", "return", "(", "final_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_optimal_crop": [[118, 124], ["numpy.sqrt", "numpy.round"], "function", ["None"], ["", "def", "get_optimal_crop", "(", "size_in_mr", ",", "size_in_ct", ")", ":", "\n", "    ", "a", "=", "256", "*", "256", "\n", "area", "=", "(", "size_in_mr", "*", "a", ")", "/", "size_in_ct", "\n", "length", "=", "np", ".", "sqrt", "(", "area", ")", "\n", "crop", "=", "np", ".", "round", "(", "(", "256", "-", "length", ")", "/", "2", ",", "0", ")", "\n", "return", "crop", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_anyformat_image": [[126, 140], ["warnings.catch_warnings", "warnings.filterwarnings", "skimage.io.imread", "pathlib.Path", "numpy.load", "pathlib.Path", "utils.read_nii_image", "numpy.squeeze", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_nii_image"], ["", "def", "read_anyformat_image", "(", "filename", ")", ":", "\n", "    ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ",", "category", "=", "UserWarning", ")", "\n", "#print(filename)", "\n", "#acc = imread(filename)", "\n", "\n", "if", "Path", "(", "filename", ")", ".", "suffix", "==", "\".png\"", ":", "\n", "            ", "acc", ":", "np", ".", "ndarray", "=", "imread", "(", "filename", ")", "\n", "", "elif", "Path", "(", "filename", ")", ".", "suffix", "==", "\".npy\"", ":", "\n", "            ", "acc", ":", "np", ".", "ndarray", "=", "np", ".", "load", "(", "filename", ")", "\n", "", "elif", "Path", "(", "filename", ")", ".", "suffix", "==", "\".nii\"", ":", "\n", "            ", "acc", ":", "np", ".", "ndarray", "=", "read_nii_image", "(", "filename", ")", "\n", "acc", "=", "np", ".", "squeeze", "(", "acc", ")", "\n", "", "", "return", "(", "acc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_unknownformat_image": [[142, 161], ["warnings.catch_warnings", "warnings.filterwarnings", "print", "skimage.io.imread", "skimage.io.imread", "numpy.expand_dims", "pathlib.Path", "numpy.load", "pathlib.Path", "utils.read_nii_image", "os.path.splitext", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_nii_image"], ["", "def", "read_unknownformat_image", "(", "filename", ")", ":", "\n", "    ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ",", "category", "=", "UserWarning", ")", "\n", "#acc = imread(filename)", "\n", "print", "(", "filename", ")", "\n", "try", ":", "\n", "            ", "if", "Path", "(", "filename", ")", ".", "suffix", "==", "\".png\"", ":", "\n", "                ", "acc", ":", "np", ".", "ndarray", "=", "imread", "(", "filename", ")", "\n", "", "elif", "Path", "(", "filename", ")", ".", "suffix", "==", "\".npy\"", ":", "\n", "                ", "acc", ":", "np", ".", "ndarray", "=", "np", ".", "load", "(", "filename", ")", "\n", "", "elif", "Path", "(", "filename", ")", ".", "suffix", "==", "\".nii\"", ":", "\n", "                ", "acc", ":", "np", ".", "ndarray", "=", "read_nii_image", "(", "filename", ")", "\n", "#acc = np.squeeze(acc)", "\n", "", "", "except", ":", "\n", "#print('changing extension')", "\n", "            ", "filename", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "0", "]", "+", "\".png\"", "\n", "acc", ":", "np", ".", "ndarray", "=", "imread", "(", "filename", ")", "\n", "acc", "=", "np", ".", "expand_dims", "(", "acc", ",", "0", ")", "\n", "", "return", "(", "acc", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.read_nii_image": [[165, 169], ["nibabel.load", "nib.load.get_data", "str"], "function", ["None"], ["", "", "def", "read_nii_image", "(", "input_fid", ")", ":", "\n", "    ", "\"\"\"read the nii image data into numpy array\"\"\"", "\n", "img", "=", "nib", ".", "load", "(", "str", "(", "input_fid", ")", ")", "\n", "return", "img", ".", "get_data", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.exp_lr_scheduler": [[170, 178], ["None"], "function", ["None"], ["", "def", "exp_lr_scheduler", "(", "optimizer", ",", "epoch", ",", "lr_decay", "=", "0.1", ",", "lr_decay_epoch", "=", "20", ")", ":", "\n", "    ", "\"\"\"Decay learning rate by a factor of lr_decay every lr_decay_epoch epochs\"\"\"", "\n", "if", "(", "epoch", "%", "lr_decay_epoch", ")", "or", "epoch", "==", "0", ":", "\n", "        ", "return", "optimizer", "\n", "\n", "", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "        ", "param_group", "[", "'lr'", "]", "*=", "lr_decay", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.depth": [[180, 188], ["type", "utils.depth"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.depth"], ["", "", "def", "depth", "(", "e", ":", "List", ")", "->", "int", ":", "\n", "    ", "\"\"\"\n    Compute the depth of nested lists\n    \"\"\"", "\n", "if", "type", "(", "e", ")", "==", "list", "and", "e", ":", "\n", "        ", "return", "1", "+", "depth", "(", "e", "[", "0", "]", ")", "\n", "\n", "", "return", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.iIoU": [[189, 194], ["utils.inter_sum", "utils.union_sum"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.inter_sum", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.union_sum"], ["", "def", "iIoU", "(", "pred", ":", "Tensor", ",", "target", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "IoUs", "=", "inter_sum", "(", "pred", ",", "target", ")", "/", "(", "union_sum", "(", "pred", ",", "target", ")", "+", "1e-10", ")", "\n", "assert", "IoUs", ".", "shape", "==", "pred", ".", "shape", "[", ":", "2", "]", "\n", "\n", "return", "IoUs", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.inter_sum": [[195, 197], ["torch.einsum", "intersection().type", "utils.intersection"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.intersection"], ["", "def", "inter_sum", "(", "a", ":", "Tensor", ",", "b", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "return", "einsum", "(", "\"bcwh->bc\"", ",", "intersection", "(", "a", ",", "b", ")", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.union_sum": [[199, 201], ["torch.einsum", "union().type", "utils.union"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.union"], ["", "def", "union_sum", "(", "a", ":", "Tensor", ",", "b", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "return", "einsum", "(", "\"bcwh->bc\"", ",", "union", "(", "a", ",", "b", ")", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.compose": [[202, 204], ["functools.reduce", "f"], "function", ["None"], ["", "def", "compose", "(", "fns", ",", "init", ")", ":", "\n", "    ", "return", "reduce", "(", "lambda", "acc", ",", "f", ":", "f", "(", "acc", ")", ",", "fns", ",", "init", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.compose_acc": [[206, 208], ["functools.reduce", "f"], "function", ["None"], ["", "def", "compose_acc", "(", "fns", ",", "init", ")", ":", "\n", "    ", "return", "reduce", "(", "lambda", "acc", ",", "f", ":", "acc", "+", "[", "f", "(", "acc", "[", "-", "1", "]", ")", "]", ",", "fns", ",", "[", "init", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_": [[210, 212], ["list", "map", "PIL.Image.fromarray", "PIL.Image.fromarray", "PIL.ImageOps.flip", "PIL.ImageOps.flip", "PIL.ImageOps.mirror", "PIL.ImageOps.mirror", "numpy.np.flip", "numpy.np.fliplr"], "function", ["None"], ["", "def", "map_", "(", "fn", ":", "Callable", "[", "[", "A", "]", ",", "B", "]", ",", "iter", ":", "Iterable", "[", "A", "]", ")", "->", "List", "[", "B", "]", ":", "\n", "    ", "return", "list", "(", "map", "(", "fn", ",", "iter", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.mmap_": [[214, 216], ["multiprocessing.pool.Pool().map", "multiprocessing.pool.Pool"], "function", ["None"], ["", "def", "mmap_", "(", "fn", ":", "Callable", "[", "[", "A", "]", ",", "B", "]", ",", "iter", ":", "Iterable", "[", "A", "]", ")", "->", "List", "[", "B", "]", ":", "\n", "    ", "return", "Pool", "(", ")", ".", "map", "(", "fn", ",", "iter", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.uc_": [[218, 220], ["functools.partial"], "function", ["None"], ["", "def", "uc_", "(", "fn", ":", "Callable", ")", "->", "Callable", ":", "\n", "    ", "return", "partial", "(", "uncurry", ",", "fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.uncurry": [[222, 224], ["fn"], "function", ["None"], ["", "def", "uncurry", "(", "fn", ":", "Callable", ",", "args", ":", "List", "[", "Any", "]", ")", "->", "Any", ":", "\n", "    ", "return", "fn", "(", "*", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.id_": [[226, 228], ["None"], "function", ["None"], ["", "def", "id_", "(", "x", ")", ":", "\n", "    ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size": [[231, 233], ["torch.einsum", "torch.einsum"], "function", ["None"], ["", "def", "soft_size", "(", "a", ":", "Tensor", ",", "power", "=", "1", ")", "->", "Tensor", ":", "\n", "    ", "return", "torch", ".", "einsum", "(", "\"bcwh->bc\"", ",", "[", "a", "]", ")", "[", "...", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.norm_soft_size": [[235, 245], ["torch.einsum().type", "ress_norm.unsqueeze", "torch.div", "torch.div", "a.max", "torch.einsum", "torch.sum", "torch.sum"], "function", ["None"], ["", "def", "norm_soft_size", "(", "a", ":", "Tensor", ",", "power", ":", "int", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "c", ",", "w", ",", "h", "=", "a", ".", "shape", "\n", "sl_sz", "=", "w", "*", "h", "\n", "amax", "=", "a", ".", "max", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "[", "0", "]", "+", "1e-10", "\n", "#amax = torch.cat(c*[amax], dim=1)", "\n", "resp", "=", "(", "torch", ".", "div", "(", "a", ",", "amax", ")", ")", "**", "power", "\n", "ress", "=", "einsum", "(", "\"bcwh->bc\"", ",", "[", "resp", "]", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "ress_norm", "=", "ress", "/", "(", "torch", ".", "sum", "(", "ress", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "+", "1e-10", ")", "\n", "#print(torch.sum(ress,dim=1))", "\n", "return", "ress_norm", ".", "unsqueeze", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.cls_ratio_power": [[247, 254], ["torch.einsum().type", "torch.einsum().type", "ress_norm.unsqueeze", "torch.einsum", "torch.einsum"], "function", ["None"], ["", "def", "cls_ratio_power", "(", "a", ":", "Tensor", ",", "power", ":", "int", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "c", ",", "w", ",", "h", "=", "a", ".", "shape", "\n", "sizes", "=", "einsum", "(", "\"bcwh->bc\"", ",", "[", "resp", "]", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "resp", "=", "a", "**", "power", "\n", "ress", "=", "einsum", "(", "\"bcwh->bc\"", ",", "[", "resp", "]", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "ress_norm", "=", "ress", "/", "(", "w", "*", "h", ")", "\n", "return", "ress_norm", ".", "unsqueeze", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.batch_soft_size": [[256, 258], ["torch.einsum", "torch.einsum"], "function", ["None"], ["", "def", "batch_soft_size", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "return", "torch", ".", "einsum", "(", "\"bcwh->c\"", ",", "[", "a", "]", ")", "[", "...", ",", "None", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.class_dist_centroid": [[260, 273], ["utils.soft_centroid", "res.unsqueeze.unsqueeze", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "res.unsqueeze.unsqueeze", "utils.soft_size"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_centroid", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size"], ["", "def", "class_dist_centroid", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "centroid", "=", "soft_centroid", "(", "a", ")", "\n", "bool_size", "=", "(", "soft_size", "(", "a", ")", ">", "10", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "res", "=", "(", "centroid", "[", ":", ",", "1", ",", ":", "]", "-", "centroid", "[", ":", ",", "3", ",", ":", "]", ")", "**", "2", "\n", "res", "=", "res", ".", "unsqueeze", "(", "2", ")", "\n", "res", "=", "torch", ".", "einsum", "(", "\"bdo->bo\"", ",", "res", ")", "\n", "#print(res.shape,bool_size[:,1,:].shape)", "\n", "res", "=", "torch", ".", "einsum", "(", "\"bc,bc->bc\"", ",", "res", ",", "bool_size", "[", ":", ",", "1", ",", ":", "]", ")", "\n", "res", "=", "torch", ".", "einsum", "(", "\"bc,bc->bc\"", ",", "res", ",", "bool_size", "[", ":", ",", "3", ",", ":", "]", ")", "\n", "#res = res*bool_size[:,1]*bool_size[:,3].unsqueeze(2)", "\n", "res", "=", "res", ".", "unsqueeze", "(", "2", ")", "\n", "#print(res.shape)", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_centroid": [[275, 291], ["utils.map_", "a.type", "torch.stack", "torch.stack", "torch.einsum().type", "torch.einsum", "torch.einsum", "torch.Tensor().to().type", "torch.einsum", "torch.Tensor().to", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_"], ["", "def", "soft_centroid", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "c", ",", "w", ",", "h", "=", "a", ".", "shape", "\n", "\n", "ws", ",", "hs", "=", "map_", "(", "lambda", "e", ":", "Tensor", "(", "e", ")", ".", "to", "(", "a", ".", "device", ")", ".", "type", "(", "torch", ".", "float32", ")", ",", "np", ".", "mgrid", "[", "0", ":", "w", ",", "0", ":", "h", "]", ")", "\n", "assert", "ws", ".", "shape", "==", "hs", ".", "shape", "==", "(", "w", ",", "h", ")", "\n", "\n", "flotted", "=", "a", ".", "type", "(", "torch", ".", "float32", ")", "\n", "tot", "=", "einsum", "(", "\"bcwh->bc\"", ",", "[", "a", "]", ")", ".", "type", "(", "torch", ".", "float32", ")", "+", "1e-10", "\n", "\n", "cw", "=", "einsum", "(", "\"bcwh,wh->bc\"", ",", "[", "flotted", ",", "ws", "]", ")", "/", "tot", "\n", "ch", "=", "einsum", "(", "\"bcwh,wh->bc\"", ",", "[", "flotted", ",", "hs", "]", ")", "/", "tot", "\n", "\n", "res", "=", "torch", ".", "stack", "(", "[", "cw", ",", "ch", "]", ",", "dim", "=", "2", ")", "\n", "assert", "res", ".", "shape", "==", "(", "b", ",", "c", ",", "2", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_length": [[293, 313], ["utils.static_laplacian", "torch.ones", "torch.ones", "range", "range", "[].type", "flat_slice.t().mm", "laplacian.mm", "flat_slice.t", "a[].flatten"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.static_laplacian"], ["", "def", "soft_length", "(", "a", ":", "Tensor", ",", "kernel", ":", "Tuple", "=", "None", ")", "->", "Tensor", ":", "\n", "        ", "B", ",", "K", ",", "*", "img_shape", "=", "a", ".", "shape", "\n", "\n", "laplacian", ":", "Tensor", "=", "static_laplacian", "(", "*", "img_shape", ",", "device", "=", "a", ".", "device", ",", "kernel", "=", "kernel", ")", "\n", "assert", "laplacian", ".", "dtype", "==", "torch", ".", "float64", "\n", "N", ",", "M", "=", "laplacian", ".", "shape", "\n", "assert", "N", "==", "M", "\n", "\n", "results", ":", "Tensor", "=", "torch", ".", "ones", "(", "(", "B", ",", "K", ",", "1", ")", ",", "dtype", "=", "torch", ".", "float32", ",", "device", "=", "a", ".", "device", ")", "\n", "for", "b", "in", "range", "(", "B", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "K", ")", ":", "\n", "                ", "flat_slice", ":", "Tensor", "=", "a", "[", "b", ",", "k", "]", ".", "flatten", "(", ")", "[", ":", ",", "None", "]", ".", "type", "(", "torch", ".", "float64", ")", "\n", "\n", "assert", "flat_slice", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "slice_length", ":", "Tensor", "=", "flat_slice", ".", "t", "(", ")", ".", "mm", "(", "laplacian", ".", "mm", "(", "flat_slice", ")", ")", "\n", "\n", "assert", "slice_length", ".", "shape", "==", "(", "1", ",", "1", ")", "\n", "results", "[", "b", ",", "k", ",", ":", "]", "=", "slice_length", "[", "...", "]", "\n", "\n", "", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_dist_centroid": [[315, 357], ["utils.map_", "all", "a.type", "torch.einsum", "all", "all", "all", "all", "all", "torch.stack", "torch.stack", "len", "NotImplementedError", "len", "len", "len", "len", "torch.tensor().to().type", "torch.tensor().to().type", "torch.einsum", "g.repeat", "c[].repeat", "zip", "torch.einsum", "dc.sqrt", "len", "slice", "tuple", "tuple", "torch.tensor().to", "torch.tensor().to", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_"], ["", "def", "soft_dist_centroid", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "k", ",", "*", "img_shape", "=", "a", ".", "shape", "\n", "if", "len", "(", "img_shape", ")", ">", "2", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Only handle 2D for now, require to update the einsums\"", ")", "\n", "# nd: str = \"whd\" if len(img_shape) == 3 else \"wh\"", "\n", "\n", "", "grids", ":", "list", "[", "np", ".", "ndarray", "]", "=", "np", ".", "mgrid", "[", "[", "slice", "(", "0", ",", "l", ")", "for", "l", "in", "img_shape", "]", "]", "\n", "tensor_grids", ":", "list", "[", "Tensor", "]", "=", "map_", "(", "lambda", "e", ":", "torch", ".", "tensor", "(", "e", ")", ".", "to", "(", "a", ".", "device", ")", ".", "type", "(", "torch", ".", "float32", ")", ",", "grids", ")", "\n", "\n", "# Make sure all grids have the same shape as img_shape", "\n", "assert", "all", "(", "g", ".", "shape", "==", "tuple", "(", "img_shape", ")", "for", "g", "in", "tensor_grids", ")", "\n", "\n", "# Useful when `a` is a label tensor (int64)", "\n", "flotted", ":", "Tensor", "=", "a", ".", "type", "(", "torch", ".", "float32", ")", "\n", "sizes", ":", "Tensor", "=", "einsum", "(", "\"bk...->bk\"", ",", "flotted", ")", "\n", "assert", "sizes", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "centroids", ":", "list", "[", "Tensor", "]", "=", "[", "einsum", "(", "\"bkhw,hw->bk\"", ",", "flotted", ",", "grid", ")", "/", "(", "sizes", "+", "1e-10", ")", "\n", "for", "grid", "in", "tensor_grids", "]", "\n", "assert", "all", "(", "c", ".", "dtype", "==", "torch", ".", "float32", "for", "c", "in", "centroids", ")", ",", "[", "c", ".", "dtype", "for", "c", "in", "centroids", "]", "\n", "\n", "assert", "all", "(", "c", ".", "shape", "==", "(", "b", ",", "k", ")", "for", "c", "in", "centroids", ")", "\n", "assert", "all", "(", "g", ".", "shape", "==", "tuple", "(", "img_shape", ")", "for", "g", "in", "tensor_grids", ")", "\n", "assert", "len", "(", "tensor_grids", ")", "==", "len", "(", "centroids", ")", "\n", "# Now the tricky part: different centroid for each batch and class:", "\n", "# g.shape: (hw), c.shape: (bk) -> d.shape: (bkhw)", "\n", "diffs", ":", "list", "[", "Tensor", "]", "=", "[", "(", "g", ".", "repeat", "(", "b", ",", "k", ",", "1", ",", "1", ")", "-", "c", "[", ":", ",", ":", ",", "None", ",", "None", "]", ".", "repeat", "(", "1", ",", "1", ",", "*", "img_shape", ")", ")", "\n", "for", "(", "g", ",", "c", ")", "in", "zip", "(", "tensor_grids", ",", "centroids", ")", "]", "\n", "assert", "len", "(", "diffs", ")", "==", "len", "(", "img_shape", ")", "\n", "assert", "all", "(", "d", ".", "shape", "==", "(", "a", ".", "shape", ")", "==", "(", "b", ",", "k", ",", "*", "img_shape", ")", "for", "d", "in", "diffs", ")", "\n", "assert", "all", "(", "d", ".", "dtype", "==", "torch", ".", "float32", "for", "d", "in", "diffs", ")", ",", "[", "d", ".", "dtype", "for", "d", "in", "diffs", "]", "\n", "\n", "dist_centroid", ":", "list", "[", "Tensor", "]", "=", "[", "einsum", "(", "\"bkhw,bkhw->bk\"", ",", "flotted", ",", "d", "**", "2", ")", "/", "(", "sizes", "+", "1e-10", ")", "\n", "for", "d", "in", "diffs", "]", "\n", "\n", "# pprint(dist_centroid)", "\n", "\n", "res", "=", "torch", ".", "stack", "(", "[", "dc", ".", "sqrt", "(", ")", "for", "dc", "in", "dist_centroid", "]", ",", "dim", "=", "2", ")", "\n", "assert", "res", ".", "shape", "==", "(", "b", ",", "k", ",", "len", "(", "img_shape", ")", ")", "\n", "assert", "res", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_nu": [[359, 401], ["utils.map_", "all", "a.type", "torch.einsum", "all", "all", "all", "all", "all", "torch.stack", "torch.stack", "len", "NotImplementedError", "len", "len", "len", "len", "torch.tensor().to().type", "torch.tensor().to().type", "torch.einsum", "g.repeat", "c[].repeat", "zip", "torch.einsum", "dc.sqrt", "len", "slice", "tuple", "tuple", "torch.tensor().to", "torch.tensor().to", "torch.tensor", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_"], ["", "def", "soft_nu", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "k", ",", "*", "img_shape", "=", "a", ".", "shape", "\n", "if", "len", "(", "img_shape", ")", ">", "2", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Only handle 2D for now, require to update the einsums\"", ")", "\n", "# nd: str = \"whd\" if len(img_shape) == 3 else \"wh\"", "\n", "\n", "", "grids", ":", "list", "[", "np", ".", "ndarray", "]", "=", "np", ".", "mgrid", "[", "[", "slice", "(", "0", ",", "l", ")", "for", "l", "in", "img_shape", "]", "]", "\n", "tensor_grids", ":", "list", "[", "Tensor", "]", "=", "map_", "(", "lambda", "e", ":", "torch", ".", "tensor", "(", "e", ")", ".", "to", "(", "a", ".", "device", ")", ".", "type", "(", "torch", ".", "float32", ")", ",", "grids", ")", "\n", "\n", "# Make sure all grids have the same shape as img_shape", "\n", "assert", "all", "(", "g", ".", "shape", "==", "tuple", "(", "img_shape", ")", "for", "g", "in", "tensor_grids", ")", "\n", "\n", "# Useful when `a` is a label tensor (int64)", "\n", "flotted", ":", "Tensor", "=", "a", ".", "type", "(", "torch", ".", "float32", ")", "\n", "sizes", ":", "Tensor", "=", "einsum", "(", "\"bk...->bk\"", ",", "flotted", ")", "\n", "assert", "sizes", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "centroids", ":", "list", "[", "Tensor", "]", "=", "[", "einsum", "(", "\"bkhw,hw->bk\"", ",", "flotted", ",", "grid", ")", "/", "(", "sizes", "+", "1e-10", ")", "\n", "for", "grid", "in", "tensor_grids", "]", "\n", "assert", "all", "(", "c", ".", "dtype", "==", "torch", ".", "float32", "for", "c", "in", "centroids", ")", ",", "[", "c", ".", "dtype", "for", "c", "in", "centroids", "]", "\n", "\n", "assert", "all", "(", "c", ".", "shape", "==", "(", "b", ",", "k", ")", "for", "c", "in", "centroids", ")", "\n", "assert", "all", "(", "g", ".", "shape", "==", "tuple", "(", "img_shape", ")", "for", "g", "in", "tensor_grids", ")", "\n", "assert", "len", "(", "tensor_grids", ")", "==", "len", "(", "centroids", ")", "\n", "# Now the tricky part: different centroid for each batch and class:", "\n", "# g.shape: (hw), c.shape: (bk) -> d.shape: (bkhw)", "\n", "diffs", ":", "list", "[", "Tensor", "]", "=", "[", "(", "g", ".", "repeat", "(", "b", ",", "k", ",", "1", ",", "1", ")", "-", "c", "[", ":", ",", ":", ",", "None", ",", "None", "]", ".", "repeat", "(", "1", ",", "1", ",", "*", "img_shape", ")", ")", "\n", "for", "(", "g", ",", "c", ")", "in", "zip", "(", "tensor_grids", ",", "centroids", ")", "]", "\n", "assert", "len", "(", "diffs", ")", "==", "len", "(", "img_shape", ")", "\n", "assert", "all", "(", "d", ".", "shape", "==", "(", "a", ".", "shape", ")", "==", "(", "b", ",", "k", ",", "*", "img_shape", ")", "for", "d", "in", "diffs", ")", "\n", "assert", "all", "(", "d", ".", "dtype", "==", "torch", ".", "float32", "for", "d", "in", "diffs", ")", ",", "[", "d", ".", "dtype", "for", "d", "in", "diffs", "]", "\n", "\n", "nu", ":", "list", "[", "Tensor", "]", "=", "[", "einsum", "(", "\"bkhw,bkhw->bk\"", ",", "flotted", ",", "d", "**", "2", ")", "/", "(", "sizes", "**", "2", "+", "1e-10", ")", "\n", "for", "d", "in", "diffs", "]", "\n", "\n", "# pprint(dist_centroid)", "\n", "\n", "res", "=", "torch", ".", "stack", "(", "[", "dc", ".", "sqrt", "(", ")", "for", "dc", "in", "nu", "]", ",", "dim", "=", "2", ")", "\n", "assert", "res", ".", "shape", "==", "(", "b", ",", "k", ",", "len", "(", "img_shape", ")", ")", "\n", "assert", "res", ".", "dtype", "==", "torch", ".", "float32", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_compactness": [[402, 410], ["utils.soft_length", "soft_size().type", "utils.soft_size"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_length", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size"], ["", "def", "soft_compactness", "(", "a", ":", "Tensor", ",", "kernel", ":", "Tuple", "=", "None", ")", "->", "Tensor", ":", "\n", "    ", "L", ":", "Tensor", "=", "soft_length", "(", "a", ",", "kernel", ")", "\n", "# S: Tensor = cast(Tensor, soft_size(a).type(torch.float32))", "\n", "S", ":", "Tensor", "=", "soft_size", "(", "a", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "assert", "L", ".", "shape", "==", "S", ".", "shape", "# Don't want any weird broadcasting issues", "\n", "\n", "return", "L", "**", "2", "/", "(", "4", "*", "math", ".", "pi", "*", "S", "+", "1e-10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.saml_compactness": [[413, 436], ["torch.abs", "torch.abs", "torch.einsum", "torch.einsum", "length.unsqueeze.unsqueeze", "utils.soft_size", "torch.div", "torch.div", "torch.sqrt", "torch.sqrt"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size"], ["", "def", "saml_compactness", "(", "y_pred", ")", ":", "\n", "\n", "    ", "\"\"\"\n    y_pred: BxCxHxW\n    length term\n    \"\"\"", "\n", "\n", "x", "=", "y_pred", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "y_pred", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", "# horizontal and vertical directions", "\n", "y", "=", "y_pred", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", "-", "y_pred", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", "]", "\n", "\n", "delta_x", "=", "x", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", "**", "2", "\n", "delta_y", "=", "y", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", "**", "2", "\n", "\n", "delta_u", "=", "torch", ".", "abs", "(", "delta_x", "+", "delta_y", ")", "\n", "\n", "epsilon", "=", "0.00000001", "# where is a parameter to avoid square root is zero in practice.", "\n", "length", "=", "torch", ".", "einsum", "(", "\"bcwh->bc\"", ",", "torch", ".", "sqrt", "(", "delta_u", "+", "epsilon", ")", ")", "\n", "length", "=", "length", ".", "unsqueeze", "(", "2", ")", "\n", "area", "=", "soft_size", "(", "y_pred", ")", "\n", "#print(area.shape,length.shape)", "\n", "compactness_loss", "=", "torch", ".", "div", "(", "length", "**", "2", ",", "(", "area", "*", "4", "*", "math", ".", "pi", "+", "1e-10", ")", ")", "\n", "\n", "return", "compactness_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_moment": [[438, 457], ["diffmoments.scaleinv_moments", "soft_inertia_moment.unsqueeze.unsqueeze", "soft_size().type", "utils.soft_size"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size"], ["", "def", "soft_moment", "(", "a", ":", "Tensor", ",", "ind_moment", ")", "->", "Tensor", ":", "\n", "    ", "soft_central_moments", ",", "soft_scaleinv_moments", "=", "diffmoments", ".", "scaleinv_moments", "(", "a", ")", "\n", "u", ",", "i", ",", "j", "=", "ind_moment", "\n", "if", "u", "==", "0", ":", "\n", "        ", "soft_inertia_moment", "=", "soft_central_moments", "[", "i", "]", "[", "j", "]", "\n", "", "else", ":", "\n", "        ", "soft_inertia_moment", "=", "soft_scaleinv_moments", "[", "i", "]", "[", "j", "]", "\n", "\n", "#print(soft_inertia_moment,type(soft_inertia_moment))", "\n", "#if torch.max(soft_inertia_moment)>1:", "\n", "#    print(\"soft size: \", soft_size(a),\"soft_inertia_moment: \", soft_inertia_moment,\"pb\")", "\n", "#    pb = soft_inertia_moment", "\n", "", "soft_inertia_moment", "=", "soft_inertia_moment", ".", "unsqueeze", "(", "2", ")", "\n", "# S: Tensor = cast(Tensor, soft_size(a).type(torch.float32))", "\n", "S", ":", "Tensor", "=", "soft_size", "(", "a", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "assert", "soft_inertia_moment", ".", "shape", "==", "S", ".", "shape", "# Don't want any weird broadcasting issues", "\n", "#print(soft_inertia_moment.shape,S.shape)", "\n", "return", "soft_inertia_moment", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_eccentricity": [[459, 465], ["diffmoments.eccentricity().unsqueeze", "soft_size().type", "diffmoments.eccentricity", "utils.soft_size"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size"], ["", "def", "soft_eccentricity", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "\n", "    ", "soft_ec", "=", "diffmoments", ".", "eccentricity", "(", "a", ")", ".", "unsqueeze", "(", "2", ")", "\n", "S", ":", "Tensor", "=", "soft_size", "(", "a", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "assert", "soft_ec", ".", "shape", "==", "S", ".", "shape", "# Don't want any weird broadcasting issues", "\n", "return", "soft_ec", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_inertia": [[467, 474], ["diffmoments.inertia().unsqueeze", "soft_size().type", "diffmoments.inertia", "utils.soft_size"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size"], ["", "def", "soft_inertia", "(", "a", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "\n", "    ", "soft_in", "=", "diffmoments", ".", "inertia", "(", "a", ")", ".", "unsqueeze", "(", "2", ")", "\n", "S", ":", "Tensor", "=", "soft_size", "(", "a", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "assert", "soft_in", ".", "shape", "==", "S", ".", "shape", "# Don't want any weird broadcasting issues", "\n", "#print(soft_in.shape,S.shape)", "\n", "return", "soft_in", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.static_laplacian": [[477, 541], ["int", "numpy.pad", "numpy.zeros", "range", "numpy.tile", "np.zeros.flatten", "numpy.ones", "scipy.sparse.csc_matrix", "laplacian.tocoo", "torch.stack", "torch.stack", "torch.sparse.FloatTensor().to", "torch.sparse.FloatTensor().to", "numpy.ones", "numpy.asarray", "numpy.sum", "numpy.arange().reshape", "range", "numpy.arange", "len", "scipy.sparse.spdiags", "T.ravel", "adj.sum", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.sparse.FloatTensor", "torch.sparse.FloatTensor", "numpy.arange", "indices.type", "torch.from_numpy", "torch.from_numpy", "torch.Size", "torch.Size"], "function", ["None"], ["", "def", "static_laplacian", "(", "width", ":", "int", ",", "height", ":", "int", ",", "\n", "kernel", ":", "Tuple", "=", "None", ",", "\n", "device", "=", "None", ")", "->", "Tensor", ":", "\n", "    ", "\"\"\"\n    This function compute the weights of the graph representing img.\n    The weights 0 <= w_i <= 1 will be determined from the difference between the nodes: 1 for identical value,\n    0 for completely different.\n    :param img: The image, as a (n,n) matrix.\n    :param kernel: A binary mask of (k,k) shape.\n    :param sigma: Parameter for the weird exponential at the end.\n    :param eps: Other parameter for the weird exponential at the end.\n    :return: A float valued (n^2,n^2) symmetric matrix. Diagonal is empty\n    \"\"\"", "\n", "kernel_", ":", "np", ".", "ndarray", "\n", "if", "kernel", "is", "None", ":", "\n", "        ", "kernelSize", "=", "3", "\n", "\n", "kernel_", "=", "np", ".", "ones", "(", "(", "kernelSize", ",", ")", "*", "2", ")", "\n", "kernel_", "[", "(", "kernelSize", "//", "2", ",", ")", "*", "2", "]", "=", "0", "\n", "\n", "", "else", ":", "\n", "        ", "kernel_", "=", "np", ".", "asarray", "(", "kernel", ")", "\n", "# print(kernel_)", "\n", "\n", "", "img_shape", "=", "(", "width", ",", "height", ")", "\n", "N", "=", "width", "*", "height", "\n", "\n", "KW", ",", "KH", "=", "kernel_", ".", "shape", "\n", "K", "=", "int", "(", "np", ".", "sum", "(", "kernel_", ")", ")", "# 0 or 1", "\n", "\n", "A", "=", "np", ".", "pad", "(", "np", ".", "arange", "(", "N", ")", ".", "reshape", "(", "img_shape", ")", ",", "\n", "(", "(", "KW", "//", "2", ",", "KW", "//", "2", ")", ",", "(", "KH", "//", "2", ",", "KH", "//", "2", ")", ")", ",", "\n", "'constant'", ",", "\n", "constant_values", "=", "-", "1", ")", "\n", "neighs", "=", "np", ".", "zeros", "(", "(", "K", ",", "N", ")", ",", "np", ".", "int64", ")", "\n", "\n", "k", "=", "0", "\n", "for", "i", "in", "range", "(", "KW", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "KH", ")", ":", "\n", "            ", "if", "kernel_", "[", "i", ",", "j", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "T", "=", "A", "[", "i", ":", "i", "+", "width", ",", "j", ":", "j", "+", "height", "]", "\n", "neighs", "[", "k", ",", ":", "]", "=", "T", ".", "ravel", "(", ")", "\n", "k", "+=", "1", "\n", "\n", "", "", "T1", "=", "np", ".", "tile", "(", "np", ".", "arange", "(", "N", ")", ",", "K", ")", "\n", "T2", "=", "neighs", ".", "flatten", "(", ")", "\n", "Z", "=", "T1", "<=", "T2", "\n", "T1", ",", "T2", "=", "T1", "[", "Z", "]", ",", "T2", "[", "Z", "]", "\n", "\n", "diff", "=", "np", ".", "ones", "(", "len", "(", "T1", ")", ")", "\n", "M", "=", "sp", ".", "sparse", ".", "csc_matrix", "(", "(", "diff", ",", "(", "T1", ",", "T2", ")", ")", ",", "shape", "=", "(", "N", ",", "N", ")", ")", "\n", "adj", "=", "M", "+", "M", ".", "T", "\n", "laplacian", "=", "sp", ".", "sparse", ".", "spdiags", "(", "adj", ".", "sum", "(", "0", ")", ",", "0", ",", "N", ",", "N", ")", "-", "adj", "\n", "coo_laplacian", "=", "laplacian", ".", "tocoo", "(", ")", "\n", "\n", "indices", ":", "Tensor", "=", "torch", ".", "stack", "(", "[", "torch", ".", "from_numpy", "(", "coo_laplacian", ".", "row", ")", ",", "torch", ".", "from_numpy", "(", "coo_laplacian", ".", "col", ")", "]", ")", "\n", "torch_laplacian", "=", "torch", ".", "sparse", ".", "FloatTensor", "(", "indices", ".", "type", "(", "torch", ".", "int64", ")", ",", "\n", "torch", ".", "from_numpy", "(", "coo_laplacian", ".", "data", ")", ",", "\n", "torch", ".", "Size", "(", "[", "N", ",", "N", "]", ")", ")", ".", "to", "(", "device", ")", "\n", "assert", "torch_laplacian", ".", "device", "==", "device", "\n", "\n", "return", "torch_laplacian", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.index2cartesian": [[542, 549], ["numpy.indices", "torch.Tensor().to().type", "torch.Tensor().to().type", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.Tensor().to", "torch.Tensor().to", "numpy.floor", "numpy.floor", "torch.Tensor", "torch.Tensor"], "function", ["None"], ["", "def", "index2cartesian", "(", "t", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "c", ",", "h", ",", "w", "=", "t", ".", "shape", "\n", "grid", "=", "np", ".", "indices", "(", "(", "h", ",", "w", ")", ")", "\n", "cart", "=", "torch", ".", "Tensor", "(", "2", ",", "h", ",", "w", ")", ".", "to", "(", "t", ".", "device", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "cart", "[", "0", ",", ":", "]", "=", "torch", ".", "from_numpy", "(", "grid", "[", "1", "]", "-", "np", ".", "floor", "(", "w", "/", "2", ")", ")", "# x coord", "\n", "cart", "[", "1", ",", ":", "]", "=", "torch", ".", "from_numpy", "(", "-", "grid", "[", "0", "]", "+", "np", ".", "floor", "(", "h", "/", "2", ")", ")", "# y coord", "\n", "return", "cart", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_intensity": [[551, 560], ["a.type", "torch.einsum().type", "torch.einsum", "torch.einsum"], "function", ["None"], ["", "def", "soft_intensity", "(", "a", ":", "Tensor", ",", "im", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "#b, c, w, h = a.shape", "\n", "\n", "    ", "flotted", "=", "a", ".", "type", "(", "torch", ".", "float32", ")", "\n", "tot", "=", "einsum", "(", "\"bcwh->bc\"", ",", "[", "a", "]", ")", ".", "type", "(", "torch", ".", "float32", ")", "+", "1e-10", "\n", "\n", "si", "=", "einsum", "(", "\"bcwh,wh->bc\"", ",", "[", "flotted", ",", "im", "]", ")", "/", "tot", "\n", "\n", "return", "si", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.uniq": [[563, 565], ["set", "torch.unique().numpy", "torch.unique().numpy", "torch.unique", "torch.unique", "a.cpu"], "function", ["None"], ["", "def", "uniq", "(", "a", ":", "Tensor", ")", "->", "Set", ":", "\n", "    ", "return", "set", "(", "torch", ".", "unique", "(", "a", ".", "cpu", "(", ")", ")", ".", "numpy", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset": [[567, 569], ["uniq().issubset", "utils.uniq"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.uniq"], ["", "def", "sset", "(", "a", ":", "Tensor", ",", "sub", ":", "Iterable", ")", "->", "bool", ":", "\n", "    ", "return", "uniq", "(", "a", ")", ".", "issubset", "(", "sub", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.eq": [[571, 573], ["torch.eq().all", "torch.eq().all", "torch.eq", "torch.eq"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.eq", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.eq"], ["", "def", "eq", "(", "a", ":", "Tensor", ",", "b", ")", "->", "bool", ":", "\n", "    ", "return", "torch", ".", "eq", "(", "a", ",", "b", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex": [[575, 579], ["t.sum().type", "torch.ones_like", "torch.ones_like", "torch.allclose", "torch.allclose", "t.sum"], "function", ["None"], ["", "def", "simplex", "(", "t", ":", "Tensor", ",", "axis", "=", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "->", "bool", ":", "\n", "    ", "_sum", "=", "t", ".", "sum", "(", "axis", ")", ".", "type", "(", "dtype", ")", "\n", "_ones", "=", "torch", ".", "ones_like", "(", "_sum", ",", "dtype", "=", "_sum", ".", "dtype", ")", "\n", "return", "torch", ".", "allclose", "(", "_sum", ",", "_ones", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot": [[581, 583], ["utils.simplex", "utils.sset"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset"], ["", "def", "one_hot", "(", "t", ":", "Tensor", ",", "axis", "=", "1", ",", "dtype", "=", "torch", ".", "float32", ")", "->", "bool", ":", "\n", "    ", "return", "simplex", "(", "t", ",", "axis", ",", "dtype", ")", "and", "sset", "(", "t", ",", "[", "0", ",", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.meta_dice": [[586, 598], ["print", "utils.one_hot", "utils.one_hot", "torch.einsum().type", "torch.einsum().type", "torch.einsum().type", "torch.einsum", "torch.einsum", "torch.einsum", "utils.intersection"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.intersection"], ["", "def", "meta_dice", "(", "sum_str", ":", "str", ",", "label", ":", "Tensor", ",", "pred", ":", "Tensor", ",", "smooth", ":", "float", "=", "1e-8", ",", "dtype", "=", "torch", ".", "float32", ")", ":", "\n", "    ", "assert", "label", ".", "shape", "==", "pred", ".", "shape", ",", "print", "(", "label", ".", "shape", ",", "pred", ".", "shape", ")", "\n", "assert", "one_hot", "(", "label", ")", "\n", "assert", "one_hot", "(", "pred", ")", "\n", "\n", "inter_size", ":", "Tensor", "=", "einsum", "(", "sum_str", ",", "[", "intersection", "(", "label", ",", "pred", ")", "]", ")", ".", "type", "(", "dtype", ")", "\n", "sum_sizes_label", ":", "Tensor", "=", "einsum", "(", "sum_str", ",", "[", "label", "]", ")", ".", "type", "(", "dtype", ")", "\n", "sum_sizes_pred", ":", "Tensor", "=", "einsum", "(", "sum_str", ",", "[", "pred", "]", ")", ".", "type", "(", "dtype", ")", "\n", "\n", "dices", ":", "Tensor", "=", "(", "2", "*", "inter_size", "+", "smooth", ")", "/", "(", "(", "sum_sizes_label", "+", "sum_sizes_pred", ")", ".", "type", "(", "dtype", ")", "+", "smooth", ")", "\n", "\n", "return", "dices", ",", "inter_size", ",", "sum_sizes_label", ",", "sum_sizes_pred", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.intersection": [[604, 609], ["utils.sset", "utils.sset"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset"], ["def", "intersection", "(", "a", ":", "Tensor", ",", "b", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "assert", "a", ".", "shape", "==", "b", ".", "shape", "\n", "assert", "sset", "(", "a", ",", "[", "0", ",", "1", "]", ")", "\n", "assert", "sset", "(", "b", ",", "[", "0", ",", "1", "]", ")", "\n", "return", "a", "&", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.union": [[611, 616], ["utils.sset", "utils.sset"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset"], ["", "def", "union", "(", "a", ":", "Tensor", ",", "b", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "assert", "a", ".", "shape", "==", "b", ".", "shape", "\n", "assert", "sset", "(", "a", ",", "[", "0", ",", "1", "]", ")", "\n", "assert", "sset", "(", "b", ",", "[", "0", ",", "1", "]", ")", "\n", "return", "a", "|", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2class": [[619, 627], ["utils.simplex", "probs.argmax"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex"], ["", "def", "probs2class", "(", "probs", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "b", ",", "_", ",", "w", ",", "h", "=", "probs", ".", "shape", "# type: Tuple[int, int, int, int]", "\n", "assert", "simplex", "(", "probs", ")", "\n", "\n", "res", "=", "probs", ".", "argmax", "(", "dim", "=", "1", ")", "\n", "assert", "res", ".", "shape", "==", "(", "b", ",", "w", ",", "h", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.class2one_hot": [[629, 645], ["utils.sset", "torch.stack().type", "torch.stack().type", "utils.one_hot", "len", "seg.unsqueeze.unsqueeze", "list", "range", "torch.stack", "torch.stack", "range"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot"], ["", "def", "class2one_hot", "(", "seg", ":", "Tensor", ",", "C", ":", "int", ")", "->", "Tensor", ":", "\n", "    ", "if", "len", "(", "seg", ".", "shape", ")", "==", "2", ":", "# Only w, h, used by the dataloader", "\n", "        ", "seg", "=", "seg", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "#print('range classes:',list(range(C)))", "\n", "\n", "#print('unique seg:',torch.unique(seg))", "\n", "#print(\"setdiff:\",set(torch.unique(seg)).difference(list(range(C))))", "\n", "", "assert", "sset", "(", "seg", ",", "list", "(", "range", "(", "C", ")", ")", ")", "\n", "\n", "b", ",", "w", ",", "h", "=", "seg", ".", "shape", "# type: Tuple[int, int, int]", "\n", "\n", "res", "=", "torch", ".", "stack", "(", "[", "seg", "==", "c", "for", "c", "in", "range", "(", "C", ")", "]", ",", "dim", "=", "1", ")", ".", "type", "(", "torch", ".", "int32", ")", "\n", "assert", "res", ".", "shape", "==", "(", "b", ",", "C", ",", "w", ",", "h", ")", "\n", "assert", "one_hot", "(", "res", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2one_hot": [[647, 656], ["utils.simplex", "utils.class2one_hot", "utils.one_hot", "utils.probs2class"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.class2one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2class"], ["", "def", "probs2one_hot", "(", "probs", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "    ", "_", ",", "C", ",", "_", ",", "_", "=", "probs", ".", "shape", "\n", "assert", "simplex", "(", "probs", ")", "\n", "\n", "res", "=", "class2one_hot", "(", "probs2class", "(", "probs", ")", ",", "C", ")", "\n", "assert", "res", ".", "shape", "==", "probs", ".", "shape", "\n", "assert", "one_hot", "(", "res", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_images_p": [[659, 671], ["zip", "seg.cpu().numpy.cpu().numpy", "pathlib.Path().with_suffix", "Path().with_suffix.parent.mkdir", "skimage.io.imsave", "str", "seg.cpu().numpy.astype", "seg.cpu().numpy.cpu", "pathlib.Path"], "function", ["None"], ["", "def", "save_images_p", "(", "segs", ":", "Tensor", ",", "names", ":", "Iterable", "[", "str", "]", ",", "root", ":", "str", ",", "mode", ":", "str", ",", "iter", ":", "int", ",", "remap", ":", "True", ")", "->", "None", ":", "\n", "    ", "b", ",", "w", ",", "h", "=", "segs", ".", "shape", "# Since we have the class numbers, we do not need a C axis", "\n", "\n", "for", "seg", ",", "name", "in", "zip", "(", "segs", ",", "names", ")", ":", "\n", "        ", "seg", "=", "seg", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "remap", ":", "\n", "#assert sset(seg, list(range(2)))", "\n", "            ", "seg", "[", "seg", "==", "1", "]", "=", "255", "\n", "#save_path = Path(root, f\"iter{iter:03d}\", mode, name).with_suffix(\".png\")", "\n", "", "save_path", "=", "Path", "(", "root", ",", "mode", ",", "\"WatonInn_pjce\"", ",", "name", ")", ".", "with_suffix", "(", "\".png\"", ")", "\n", "save_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "imsave", "(", "str", "(", "save_path", ")", ",", "seg", ".", "astype", "(", "'uint8'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_be_images": [[673, 684], ["zip", "seg.cpu().numpy.cpu().numpy", "pathlib.Path().with_suffix", "Path().with_suffix.parent.mkdir", "skimage.io.imsave", "str", "seg.cpu().numpy.astype", "seg.cpu().numpy.cpu", "pathlib.Path"], "function", ["None"], ["", "", "def", "save_be_images", "(", "segs", ":", "Tensor", ",", "names", ":", "Iterable", "[", "str", "]", ",", "root", ":", "str", ",", "mode", ":", "str", ",", "iter", ":", "int", ",", "remap", ":", "True", ")", "->", "None", ":", "\n", "    ", "b", ",", "w", ",", "h", "=", "segs", ".", "shape", "# Since we have the class numbers, we do not need a C axis", "\n", "\n", "for", "seg", ",", "name", "in", "zip", "(", "segs", ",", "names", ")", ":", "\n", "        ", "seg", "=", "seg", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "remap", ":", "\n", "#assert sset(seg, list(range(2)))", "\n", "            ", "seg", "[", "seg", "==", "1", "]", "=", "255", "\n", "", "save_path", "=", "Path", "(", "root", ",", "\"best\"", ",", "name", ")", ".", "with_suffix", "(", "\".png\"", ")", "\n", "save_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "imsave", "(", "str", "(", "save_path", ")", ",", "seg", ".", "astype", "(", "'uint8'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_images": [[687, 699], ["zip", "seg.cpu().numpy.cpu().numpy", "pathlib.Path().with_suffix", "Path().with_suffix.parent.mkdir", "skimage.io.imsave", "str", "seg.cpu().numpy.astype", "seg.cpu().numpy.cpu", "pathlib.Path"], "function", ["None"], ["", "", "def", "save_images", "(", "segs", ":", "Tensor", ",", "names", ":", "Iterable", "[", "str", "]", ",", "root", ":", "str", ",", "mode", ":", "str", ",", "iter", ":", "int", ",", "remap", ":", "True", ")", "->", "None", ":", "\n", "    ", "b", ",", "w", ",", "h", "=", "segs", ".", "shape", "# Since we have the class numbers, we do not need a C axis", "\n", "for", "seg", ",", "name", "in", "zip", "(", "segs", ",", "names", ")", ":", "\n", "#print(root,iter,mode,name)", "\n", "        ", "seg", "=", "seg", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "remap", ":", "\n", "#assert sset(seg, list(range(2)))", "\n", "            ", "seg", "[", "seg", "==", "1", "]", "=", "255", "\n", "", "save_path", "=", "Path", "(", "root", ",", "f\"iter{iter:03d}\"", ",", "mode", ",", "name", ")", ".", "with_suffix", "(", "\".png\"", ")", "\n", "save_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "imsave", "(", "str", "(", "save_path", ")", ",", "seg", ".", "astype", "(", "'uint8'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_images_ent": [[701, 709], ["zip", "pathlib.Path().with_suffix", "Path().with_suffix.parent.mkdir", "skimage.io.imsave", "seg.cpu().numpy", "str", "seg.astype", "pathlib.Path", "seg.cpu"], "function", ["None"], ["", "", "def", "save_images_ent", "(", "segs", ":", "Tensor", ",", "names", ":", "Iterable", "[", "str", "]", ",", "root", ":", "str", ",", "mode", ":", "str", ",", "iter", ":", "int", ")", "->", "None", ":", "\n", "    ", "b", ",", "w", ",", "h", "=", "segs", ".", "shape", "# Since we have the class numbers, we do not need a C axis", "\n", "for", "seg", ",", "name", "in", "zip", "(", "segs", ",", "names", ")", ":", "\n", "#print(root,iter,mode,name)", "\n", "        ", "seg", "=", "seg", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "255", "#entropy is smaller than 1", "\n", "save_path", "=", "Path", "(", "root", ",", "f\"iter{iter:03d}\"", ",", "mode", ",", "name", ")", ".", "with_suffix", "(", "\".png\"", ")", "\n", "save_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "imsave", "(", "str", "(", "save_path", ")", ",", "seg", ".", "astype", "(", "'uint8'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_images_inf": [[712, 727], ["zip", "np.round.cpu().numpy", "numpy.round", "pathlib.Path().with_suffix", "Path().with_suffix.parent.mkdir", "skimage.io.imsave", "str", "np.round.astype", "np.round.cpu", "pathlib.Path"], "function", ["None"], ["", "", "def", "save_images_inf", "(", "segs", ":", "Tensor", ",", "names", ":", "Iterable", "[", "str", "]", ",", "root", ":", "str", ",", "mode", ":", "str", ",", "remap", ":", "True", ")", "->", "None", ":", "\n", "    ", "b", ",", "w", ",", "h", "=", "segs", ".", "shape", "# Since we have the class numbers, we do not need a C axis", "\n", "\n", "for", "seg", ",", "name", "in", "zip", "(", "segs", ",", "names", ")", ":", "\n", "        ", "seg", "=", "seg", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "seg", "=", "np", ".", "round", "(", "seg", ",", "1", ")", "\n", "#print(np.unique(seg))", "\n", "if", "remap", ":", "\n", "#assert sset(seg, list(range(2)))", "\n", "            ", "seg", "[", "seg", "==", "1", "]", "=", "255", "\n", "", "save_path", "=", "Path", "(", "root", ",", "mode", ",", "name", ")", ".", "with_suffix", "(", "\".png\"", ")", "\n", "#save_path = Path(root, mode, name).with_suffix(\".npy\")", "\n", "save_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "\n", "imsave", "(", "str", "(", "save_path", ")", ",", "seg", ".", "astype", "(", "'uint8'", ")", ")", "\n", "#np.save(str(save_path), seg)", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.augment": [[730, 757], ["isinstance", "utils.map_", "list", "utils.map_", "utils.map_", "random.uniform", "utils.map_", "random.uniform", "utils.map_", "utils.map_", "all", "random.random", "random.random", "random.random", "random.random", "int", "int", "random.randint", "random.randint", "e.rotate", "i.resize", "i.crop"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize"], ["", "", "def", "augment", "(", "*", "arrs", ":", "Union", "[", "np", ".", "ndarray", ",", "Image", ".", "Image", "]", ",", "rotate_angle", ":", "float", "=", "45", ",", "\n", "flip", ":", "bool", "=", "True", ",", "mirror", ":", "bool", "=", "True", ",", "\n", "rotate", ":", "bool", "=", "True", ",", "scale", ":", "bool", "=", "False", ")", "->", "List", "[", "Image", ".", "Image", "]", ":", "\n", "    ", "imgs", ":", "List", "[", "Image", ".", "Image", "]", "=", "map_", "(", "Image", ".", "fromarray", ",", "arrs", ")", "if", "isinstance", "(", "arrs", "[", "0", "]", ",", "np", ".", "ndarray", ")", "else", "list", "(", "arrs", ")", "\n", "\n", "if", "flip", "and", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "imgs", "=", "map_", "(", "ImageOps", ".", "flip", ",", "imgs", ")", "\n", "", "if", "mirror", "and", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "imgs", "=", "map_", "(", "ImageOps", ".", "mirror", ",", "imgs", ")", "\n", "", "if", "rotate", "and", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "angle", ":", "float", "=", "uniform", "(", "-", "rotate_angle", ",", "rotate_angle", ")", "\n", "imgs", "=", "map_", "(", "lambda", "e", ":", "e", ".", "rotate", "(", "angle", ")", ",", "imgs", ")", "\n", "", "if", "scale", "and", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "scale_factor", ":", "float", "=", "uniform", "(", "1", ",", "1.2", ")", "\n", "w", ",", "h", "=", "imgs", "[", "0", "]", ".", "size", "# Tuple[int, int]", "\n", "nw", ",", "nh", "=", "int", "(", "w", "*", "scale_factor", ")", ",", "int", "(", "h", "*", "scale_factor", ")", "# Tuple[int, int]", "\n", "\n", "# Resize", "\n", "imgs", "=", "map_", "(", "lambda", "i", ":", "i", ".", "resize", "(", "(", "nw", ",", "nh", ")", ")", ",", "imgs", ")", "\n", "\n", "# Now need to crop to original size", "\n", "bw", ",", "bh", "=", "randint", "(", "0", ",", "nw", "-", "w", ")", ",", "randint", "(", "0", ",", "nh", "-", "h", ")", "# Tuple[int, int]", "\n", "\n", "imgs", "=", "map_", "(", "lambda", "i", ":", "i", ".", "crop", "(", "(", "bw", ",", "bh", ",", "bw", "+", "w", ",", "bh", "+", "h", ")", ")", ",", "imgs", ")", "\n", "assert", "all", "(", "i", ".", "size", "==", "(", "w", ",", "h", ")", "for", "i", "in", "imgs", ")", "\n", "\n", "", "return", "imgs", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.augment_arr": [[759, 775], ["list", "random.random", "utils.map_", "random.random", "utils.map_"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.map_"], ["", "def", "augment_arr", "(", "*", "arrs_a", ":", "np", ".", "ndarray", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "    ", "arrs", "=", "list", "(", "arrs_a", ")", "# manoucherie type check", "\n", "\n", "if", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "arrs", "=", "map_", "(", "np", ".", "flip", ",", "arrs", ")", "\n", "", "if", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "arrs", "=", "map_", "(", "np", ".", "fliplr", ",", "arrs", ")", "\n", "# if random() > 0.5:", "\n", "#     orig_shape = arrs[0].shape", "\n", "\n", "#     angle = random() * 90 - 45", "\n", "#     arrs = map_(lambda e: sp.ndimage.rotate(e, angle, order=1), arrs)", "\n", "\n", "#     arrs = get_center(orig_shape, *arrs)", "\n", "\n", "", "return", "arrs", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_center": [[778, 795], ["utils.get_center.g_center"], "function", ["None"], ["", "def", "get_center", "(", "shape", ":", "Tuple", ",", "*", "arrs", ":", "np", ".", "ndarray", ")", "->", "List", "[", "np", ".", "ndarray", "]", ":", "\n", "    ", "def", "g_center", "(", "arr", ")", ":", "\n", "        ", "if", "arr", ".", "shape", "==", "shape", ":", "\n", "            ", "return", "arr", "\n", "\n", "", "dx", "=", "(", "arr", ".", "shape", "[", "0", "]", "-", "shape", "[", "0", "]", ")", "//", "2", "\n", "dy", "=", "(", "arr", ".", "shape", "[", "1", "]", "-", "shape", "[", "1", "]", ")", "//", "2", "\n", "\n", "if", "dx", "==", "0", "or", "dy", "==", "0", ":", "\n", "            ", "return", "arr", "[", ":", "shape", "[", "0", "]", ",", ":", "shape", "[", "1", "]", "]", "\n", "\n", "", "res", "=", "arr", "[", "dx", ":", "-", "dx", ",", "dy", ":", "-", "dy", "]", "[", ":", "shape", "[", "0", "]", ",", ":", "shape", "[", "1", "]", "]", "# Deal with off-by-one errors", "\n", "assert", "res", ".", "shape", "==", "shape", ",", "(", "res", ".", "shape", ",", "shape", ",", "dx", ",", "dy", ")", "\n", "\n", "return", "res", "\n", "\n", "", "return", "[", "g_center", "(", "arr", ")", "for", "arr", "in", "arrs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.pad_to": [[797, 824], ["int", "int", "len", "len", "numpy.pad", "numpy.pad"], "function", ["None"], ["", "def", "pad_to", "(", "img", ":", "np", ".", "ndarray", ",", "new_h", ",", "new_w", ")", "->", "np", ".", "ndarray", ":", "\n", "    ", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "\n", "        ", "h", ",", "w", "=", "img", ".", "shape", "\n", "", "else", ":", "\n", "        ", "b", ",", "h", ",", "w", "=", "img", ".", "shape", "\n", "", "padd_lr", "=", "int", "(", "(", "new_w", "-", "w", ")", "/", "2", ")", "\n", "if", "(", "new_w", "-", "w", ")", "/", "2", "==", "padd_lr", ":", "\n", "        ", "padd_l", "=", "padd_lr", "\n", "padd_r", "=", "padd_lr", "\n", "", "else", ":", "#no divisible by 2", "\n", "        ", "padd_l", "=", "padd_lr", "\n", "padd_r", "=", "padd_lr", "+", "1", "\n", "", "padd_ud", "=", "int", "(", "(", "new_h", "-", "h", ")", "/", "2", ")", "\n", "if", "(", "new_h", "-", "h", ")", "/", "2", "==", "padd_ud", ":", "\n", "        ", "padd_u", "=", "padd_ud", "\n", "padd_d", "=", "padd_ud", "\n", "", "else", ":", "#no divisible by 2", "\n", "        ", "padd_u", "=", "padd_ud", "\n", "padd_d", "=", "padd_ud", "+", "1", "\n", "\n", "", "if", "len", "(", "img", ".", "shape", ")", "==", "2", ":", "\n", "        ", "new_im", "=", "np", ".", "pad", "(", "img", ",", "[", "(", "padd_u", ",", "padd_d", ")", ",", "(", "padd_l", ",", "padd_r", ")", "]", ",", "'constant'", ")", "\n", "", "else", ":", "\n", "        ", "new_im", "=", "np", ".", "pad", "(", "img", ",", "[", "(", "0", ",", "0", ")", ",", "(", "padd_u", ",", "padd_d", ")", ",", "(", "padd_l", ",", "padd_r", ")", "]", ",", "'constant'", ")", "\n", "\n", "#print(img.shape, '-->', new_im.shape)", "\n", "", "return", "new_im", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.mask_resize": [[826, 839], ["t.device", "t.dtype", "int", "torch.nn.ZeroPad2d", "torch.nn.ZeroPad2d", "torch.ones", "torch.ones", "torch.nn.ZeroPad2d.", "torch.einsum().to", "torch.einsum().to", "torch.einsum", "torch.einsum", "int"], "function", ["None"], ["", "def", "mask_resize", "(", "t", ",", "new_w", ")", ":", "\n", "    ", "b", ",", "c", ",", "h", ",", "w", "=", "t", ".", "shape", "\n", "new_t", "=", "t", "\n", "if", "w", "!=", "new_w", ":", "\n", "        ", "device", "=", "t", ".", "device", "(", ")", "\n", "dtype", "=", "t", ".", "dtype", "(", ")", "\n", "padd_lr", "=", "int", "(", "(", "w", "-", "int", "(", "new_w", ")", ")", "/", "2", ")", "\n", "m", "=", "torch", ".", "nn", ".", "ZeroPad2d", "(", "(", "0", ",", "0", ",", "padd_lr", ",", "padd_lr", ")", ")", "\n", "mask_resize", "=", "torch", ".", "ones", "(", "[", "new_w", ",", "h", "]", ",", "dtype", "=", "dtype", ")", "\n", "mask_resize_fg", "=", "m", "(", "mask_resize", ")", "\n", "mask_resize_bg", "=", "1", "-", "mask_resize_fg", "\n", "new_t", "=", "torch", ".", "einsum", "(", "'wh,bcwh->bcwh'", ",", "[", "mask_resize", ",", "t", "]", ")", ".", "to", "(", "device", ")", "\n", "", "return", "new_t", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize": [[840, 847], ["int", "int"], "function", ["None"], ["", "def", "resize", "(", "t", ",", "new_w", ")", ":", "\n", "    ", "b", ",", "c", ",", "h", ",", "w", "=", "t", ".", "shape", "\n", "new_t", "=", "t", "\n", "if", "w", "!=", "new_w", ":", "\n", "        ", "padd_lr", "=", "int", "(", "(", "w", "-", "int", "(", "new_w", ")", ")", "/", "2", ")", "\n", "new_t", "=", "t", "[", ":", ",", ":", ",", ":", ",", "padd_lr", "-", "1", ":", "padd_lr", "+", "new_w", "-", "1", "]", "\n", "", "return", "new_t", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize_im": [[849, 854], ["int", "int"], "function", ["None"], ["", "def", "resize_im", "(", "t", ",", "new_w", ")", ":", "\n", "    ", "w", ",", "h", "=", "t", ".", "shape", "\n", "padd_lr", "=", "int", "(", "(", "w", "-", "int", "(", "new_w", ")", ")", "/", "2", ")", "\n", "new_t", "=", "t", "[", ":", ",", "padd_lr", "-", "1", ":", "padd_lr", "+", "new_w", "-", "1", "]", "\n", "return", "new_t", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.haus_p": [[855, 863], ["torch.unique", "torch.unique", "torch.masked_select().reshape", "torch.masked_select().reshape", "haus_all_p.append", "numpy.mean", "numpy.std", "torch.masked_select().reshape.mean().cpu().numpy", "torch.masked_select", "torch.masked_select", "torch.masked_select().reshape.mean().cpu", "torch.masked_select().reshape.mean"], "function", ["None"], ["", "def", "haus_p", "(", "haus_s", ",", "all_p", ")", ":", "\n", "    ", "_", ",", "C", "=", "haus_s", ".", "shape", "\n", "unique_p", "=", "torch", ".", "unique", "(", "all_p", ")", "\n", "haus_all_p", "=", "[", "]", "\n", "for", "p", "in", "unique_p", ":", "\n", "        ", "haus_p", "=", "torch", ".", "masked_select", "(", "haus_s", ",", "all_p", "==", "p", ")", ".", "reshape", "(", "(", "-", "1", ",", "C", ")", ")", "\n", "haus_all_p", ".", "append", "(", "haus_p", ".", "mean", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "", "return", "(", "np", ".", "mean", "(", "haus_all_p", ")", ",", "np", ".", "std", "(", "haus_all_p", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.haussdorf": [[865, 881], ["utils.one_hot", "utils.one_hot", "torch.zeros", "torch.zeros", "preds.cpu().numpy", "target.cpu().numpy", "range", "range", "preds.cpu", "target.cpu", "utils.numpy_haussdorf"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.numpy_haussdorf"], ["", "def", "haussdorf", "(", "preds", ":", "Tensor", ",", "target", ":", "Tensor", ",", "dtype", "=", "torch", ".", "float32", ")", "->", "Tensor", ":", "\n", "    ", "assert", "preds", ".", "shape", "==", "target", ".", "shape", "\n", "assert", "one_hot", "(", "preds", ")", "\n", "assert", "one_hot", "(", "target", ")", "\n", "\n", "B", ",", "C", ",", "_", ",", "_", "=", "preds", ".", "shape", "\n", "\n", "res", "=", "torch", ".", "zeros", "(", "(", "B", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "preds", ".", "device", ")", "\n", "n_pred", "=", "preds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "n_target", "=", "target", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "b", "in", "range", "(", "B", ")", ":", "\n", "        ", "for", "c", "in", "range", "(", "C", ")", ":", "\n", "            ", "res", "[", "b", ",", "c", "]", "=", "numpy_haussdorf", "(", "n_pred", "[", "b", ",", "c", "]", ",", "n_target", "[", "b", ",", "c", "]", ")", "\n", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.haussdorf_asd": [[882, 900], ["utils.one_hot", "utils.one_hot", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "preds.cpu().numpy", "target.cpu().numpy", "range", "range", "preds.cpu", "target.cpu", "utils.numpy_haussdorf", "utils.numpy_asd"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.one_hot", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.numpy_haussdorf", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.numpy_asd"], ["", "def", "haussdorf_asd", "(", "preds", ":", "Tensor", ",", "target", ":", "Tensor", ",", "dtype", "=", "torch", ".", "float32", ")", "->", "Tensor", ":", "\n", "    ", "assert", "preds", ".", "shape", "==", "target", ".", "shape", "\n", "assert", "one_hot", "(", "preds", ")", "\n", "assert", "one_hot", "(", "target", ")", "\n", "\n", "B", ",", "C", ",", "_", ",", "_", "=", "preds", ".", "shape", "\n", "\n", "res", "=", "torch", ".", "zeros", "(", "(", "B", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "preds", ".", "device", ")", "\n", "res2", "=", "torch", ".", "zeros", "(", "(", "B", ",", "C", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "preds", ".", "device", ")", "\n", "n_pred", "=", "preds", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "n_target", "=", "target", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "for", "b", "in", "range", "(", "B", ")", ":", "\n", "        ", "for", "c", "in", "range", "(", "C", ")", ":", "\n", "            ", "res", "[", "b", ",", "c", "]", "=", "numpy_haussdorf", "(", "n_pred", "[", "b", ",", "c", "]", ",", "n_target", "[", "b", ",", "c", "]", ")", "\n", "res2", "[", "b", ",", "c", "]", "=", "numpy_asd", "(", "n_pred", "[", "b", ",", "c", "]", ",", "n_target", "[", "b", ",", "c", "]", ")", "\n", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.numpy_haussdorf": [[901, 906], ["max", "len", "scipy.spatial.distance.directed_hausdorff", "scipy.spatial.distance.directed_hausdorff"], "function", ["None"], ["", "def", "numpy_haussdorf", "(", "pred", ":", "np", ".", "ndarray", ",", "target", ":", "np", ".", "ndarray", ")", "->", "float", ":", "\n", "    ", "assert", "len", "(", "pred", ".", "shape", ")", "==", "2", "\n", "assert", "pred", ".", "shape", "==", "target", ".", "shape", "\n", "\n", "return", "max", "(", "directed_hausdorff", "(", "pred", ",", "target", ")", "[", "0", "]", ",", "directed_hausdorff", "(", "target", ",", "pred", ")", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.numpy_asd": [[908, 914], ["scipy.spatial.distance.directed_hausdorff", "len"], "function", ["None"], ["", "def", "numpy_asd", "(", "pred", ":", "np", ".", "ndarray", ",", "target", ":", "np", ".", "ndarray", ")", ":", "\n", "    ", "assert", "len", "(", "pred", ".", "shape", ")", "==", "2", "\n", "assert", "pred", ".", "shape", "==", "target", ".", "shape", "\n", "res", "=", "directed_hausdorff", "(", "pred", ",", "target", ")", "\n", "res", "=", "res", "[", "0", "]", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.run_CRF": [[916, 946], ["torch.zeros", "torch.zeros", "range", "utils.sset", "dcrf.DenseCRF2D", "print", "dcrf.DenseCRF2D.setUnaryEnergy", "dcrf.DenseCRF2D.addPairwiseGaussian", "dcrf.DenseCRF2D.inference", "numpy.array", "np.argmax().reshape.from_numpy", "class2one_hot.cpu().numpy", "unary_from_labels", "class2one_hot.cpu().numpy", "unary_from_softmax", "numpy.argmax().reshape", "utils.class2one_hot", "class2one_hot.cpu", "class2one_hot.cpu", "numpy.argmax"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.sset", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.class2one_hot"], ["", "def", "run_CRF", "(", "preds", ":", "Tensor", ",", "nit", ":", "int", ")", ":", "\n", "# preds is either probability or hard labeling", "\n", "#here done in two classes case only", "\n", "    ", "b", ",", "c", ",", "w", ",", "h", "=", "preds", ".", "shape", "\n", "dtype", "=", "torch", ".", "float32", "\n", "output", "=", "torch", ".", "zeros", "(", "(", "b", ",", "c", ",", "w", ",", "h", ")", ",", "dtype", "=", "dtype", ",", "device", "=", "preds", ".", "device", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "b", ")", ":", "\n", "        ", "im", "=", "preds", "[", "i", ",", ":", ",", ":", ",", ":", "]", "\n", "if", "sset", "(", "im", ",", "[", "0", ",", "1", "]", ")", ":", "# hard labels in one hot form or class form", "\n", "            ", "hard", "=", "True", "\n", "if", "c", ">", "1", ":", "\n", "                ", "im", "=", "class2one_hot", "(", "im", ",", "c", ")", "\n", "", "im", "=", "im", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "u", "=", "unary_from_labels", "(", "im", ",", "c", ",", "0.5", ",", "zero_unsure", "=", "False", ")", "\n", "", "else", ":", "# labels in a softmax", "\n", "            ", "im", "=", "im", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "u", "=", "unary_from_softmax", "(", "im", ")", "\n", "", "d", "=", "dcrf", ".", "DenseCRF2D", "(", "w", ",", "h", ",", "c", ")", "# width, height, nlabels", "\n", "print", "(", "u", ".", "shape", ")", "# -> (5, 480, 640)", "\n", "d", ".", "setUnaryEnergy", "(", "u", ")", "\n", "# This adds the color-independent term, features are the locations only.", "\n", "d", ".", "addPairwiseGaussian", "(", "sxy", "=", "(", "3", ",", "3", ")", ",", "compat", "=", "3", ",", "kernel", "=", "dcrf", ".", "DIAG_KERNEL", ",", "normalization", "=", "dcrf", ".", "NORMALIZE_SYMMETRIC", ")", "\n", "Q", "=", "d", ".", "inference", "(", "nit", ")", "\n", "new_im", "=", "np", ".", "array", "(", "Q", ")", "\n", "if", "hard", "==", "True", ":", "\n", "            ", "new_im", "=", "np", ".", "argmax", "(", "Q", ",", "axis", "=", "0", ")", ".", "reshape", "(", "(", "w", ",", "h", ")", ")", "\n", "", "new_im", "=", "new_im", ".", "from_numpy", "(", "new_im", ")", "\n", "output", "[", "i", ",", ":", ",", ":", ",", ":", "]", "=", "new_im", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.run_CRF_im": [[948, 973], ["set", "dcrf.DenseCRF2D", "dcrf.DenseCRF2D.setUnaryEnergy", "dcrf.DenseCRF2D.addPairwiseGaussian", "dcrf.DenseCRF2D.inference", "numpy.array", "numpy.unique", "unary_from_labels", "unary_from_softmax", "numpy.argmax().reshape", "set", "set", "numpy.unique", "numpy.unique", "numpy.argmax"], "function", ["None"], ["", "def", "run_CRF_im", "(", "im", ":", "np", ".", "ndarray", ",", "nit", ":", "int", ",", "conf", ":", "0.5", ")", ":", "\n", "# preds is either probability or hard labeling", "\n", "#here done in two classes case only", "\n", "    ", "w", ",", "h", "=", "im", ".", "shape", "\n", "output", "=", "im", "\n", "if", "set", "(", "np", ".", "unique", "(", "im", ")", ")", ">", "{", "0", "}", ":", "\n", "        ", "if", "set", "(", "np", ".", "unique", "(", "im", ")", ")", "<=", "{", "0", ",", "255", "}", "or", "set", "(", "np", ".", "unique", "(", "im", ")", ")", "<=", "{", "0", ",", "1", "}", ":", "# hard labels in one hot form or class form", "\n", "            ", "hard", "=", "True", "\n", "im", "[", "im", "==", "255", "]", "=", "1", "\n", "u", "=", "unary_from_labels", "(", "im", ",", "2", ",", "conf", ",", "zero_unsure", "=", "False", ")", "\n", "", "else", ":", "# labels in a softmax", "\n", "            ", "u", "=", "unary_from_softmax", "(", "im", ")", "\n", "", "d", "=", "dcrf", ".", "DenseCRF2D", "(", "w", ",", "h", ",", "2", ")", "# width, height, nlabels", "\n", "#print(u.shape)  # -> (5, 480, 640)", "\n", "d", ".", "setUnaryEnergy", "(", "u", ")", "\n", "# This adds the color-independent term, features are the locations only.", "\n", "d", ".", "addPairwiseGaussian", "(", "sxy", "=", "(", "3", ",", "3", ")", ",", "compat", "=", "3", ",", "kernel", "=", "dcrf", ".", "DIAG_KERNEL", ",", "normalization", "=", "dcrf", ".", "NORMALIZE_SYMMETRIC", ")", "\n", "Q", "=", "d", ".", "inference", "(", "nit", ")", "\n", "new_im", "=", "np", ".", "array", "(", "Q", ")", "\n", "if", "hard", "==", "True", ":", "\n", "            ", "new_im", "=", "np", ".", "argmax", "(", "Q", ",", "axis", "=", "0", ")", ".", "reshape", "(", "(", "w", ",", "h", ")", ")", "\n", "new_im", "[", "new_im", "==", "1", "]", "=", "255", "\n", "", "output", "=", "new_im", "\n", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.interp": [[975, 978], ["torch.Upsample"], "function", ["None"], ["", "def", "interp", "(", "input", ")", ":", "\n", "    ", "_", ",", "_", ",", "w", ",", "h", "=", "input", ".", "shape", "\n", "return", "nn", ".", "Upsample", "(", "input", ",", "size", "=", "(", "h", ",", "w", ")", ",", "mode", "=", "'bilinear'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.interp_target": [[980, 983], ["torch.Upsample"], "function", ["None"], ["", "def", "interp_target", "(", "input", ")", ":", "\n", "    ", "_", ",", "_", ",", "w", ",", "h", "=", "input", ".", "shape", "\n", "return", "nn", ".", "Upsample", "(", "size", "=", "(", "h", ",", "w", ")", ",", "mode", "=", "'bilinear'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.plot_t": [[985, 998], ["matplotlib.close", "matplotlib.imshow", "matplotlib.title", "matplotlib.colorbar", "input[].detach().cpu().numpy", "input[].cpu().numpy", "str", "input[].detach().cpu", "input[].cpu", "input[].detach"], "function", ["None"], ["", "def", "plot_t", "(", "input", ")", ":", "\n", "    ", "_", ",", "c", ",", "w", ",", "h", "=", "input", ".", "shape", "\n", "axis_to_plot", "=", "1", "\n", "if", "c", "==", "1", ":", "\n", "        ", "axis_to_plot", "=", "0", "\n", "", "if", "input", ".", "requires_grad", ":", "\n", "        ", "im", "=", "input", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "im", "=", "input", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "plt", ".", "close", "(", "\"all\"", ")", "\n", "plt", ".", "imshow", "(", "im", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "title", "(", "'plotting on channel:'", "+", "str", "(", "axis_to_plot", ")", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.plot_all": [[1000, 1020], ["s_seg[].detach().cpu().numpy", "t_seg[].detach().cpu().numpy", "gt_seg[].cpu().numpy", "disc_t[].detach().cpu().numpy", "matplotlib.close", "matplotlib.subplot", "matplotlib.imshow", "matplotlib.subplot", "matplotlib.imshow", "matplotlib.subplot", "matplotlib.imshow", "matplotlib.subplot", "matplotlib.imshow", "matplotlib.suptitle", "matplotlib.colorbar", "s_seg[].detach().cpu", "t_seg[].detach().cpu", "gt_seg[].cpu", "disc_t[].detach().cpu", "s_seg[].detach", "t_seg[].detach", "disc_t[].detach"], "function", ["None"], ["", "def", "plot_all", "(", "gt_seg", ",", "s_seg", ",", "t_seg", ",", "disc_t", ")", ":", "\n", "    ", "_", ",", "c", ",", "w", ",", "h", "=", "s_seg", ".", "shape", "\n", "axis_to_plot", "=", "1", "\n", "if", "c", "==", "1", ":", "\n", "        ", "axis_to_plot", "=", "0", "\n", "", "s_seg", "=", "s_seg", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "t_seg", "=", "t_seg", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "gt_seg", "=", "gt_seg", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "disc_t", "=", "disc_t", "[", "0", ",", "0", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "plt", ".", "close", "(", "\"all\"", ")", "\n", "plt", ".", "subplot", "(", "141", ")", "\n", "plt", ".", "imshow", "(", "gt_seg", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "subplot", "(", "142", ")", "\n", "plt", ".", "imshow", "(", "s_seg", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "subplot", "(", "143", ")", "\n", "plt", ".", "imshow", "(", "t_seg", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "subplot", "(", "144", ")", "\n", "plt", ".", "imshow", "(", "disc_t", ",", "cmap", "=", "'gray'", ")", "\n", "plt", ".", "suptitle", "(", "'gt, source seg, target seg, disc_t'", ",", "fontsize", "=", "12", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.plot_as_viewer": [[1022, 1049], ["s_seg[].detach().cpu().numpy", "t_seg[].detach().cpu().numpy", "s_im[].detach().cpu().numpy", "utils.resize_im", "t_im[].detach().cpu().numpy", "utils.resize_im", "gt_seg[].cpu().numpy", "matplotlib.close", "matplotlib.figure", "matplotlib.GridSpec", "plt.figure.add_subplot", "fig.add_subplot.imshow", "plt.figure.add_subplot", "display_item", "plt.figure.add_subplot", "display_item", "plt.figure.suptitle", "s_seg[].detach().cpu", "t_seg[].detach().cpu", "s_im[].detach().cpu", "t_im[].detach().cpu", "gt_seg[].cpu", "s_seg[].detach", "t_seg[].detach", "s_im[].detach", "t_im[].detach"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize_im", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.resize_im"], ["", "def", "plot_as_viewer", "(", "gt_seg", ",", "s_seg", ",", "t_seg", ",", "s_im", ",", "t_im", ")", ":", "\n", "    ", "_", ",", "c", ",", "w", ",", "h", "=", "s_seg", ".", "shape", "\n", "axis_to_plot", "=", "1", "\n", "if", "c", "==", "1", ":", "\n", "        ", "axis_to_plot", "=", "0", "\n", "\n", "", "s_seg", "=", "s_seg", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "t_seg", "=", "t_seg", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "s_im", "=", "s_im", "[", "0", ",", "0", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "s_im", "=", "resize_im", "(", "s_im", ",", "s_seg", ".", "shape", "[", "1", "]", ")", "\n", "t_im", "=", "t_im", "[", "0", ",", "0", ",", ":", ",", ":", "]", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "t_im", "=", "resize_im", "(", "t_im", ",", "t_seg", ".", "shape", "[", "1", "]", ")", "\n", "gt_seg", "=", "gt_seg", "[", "0", ",", "axis_to_plot", ",", ":", ",", ":", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "plt", ".", "close", "(", "\"all\"", ")", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "gs", "=", "gridspec", ".", "GridSpec", "(", "1", ",", "3", ")", "\n", "\n", "axe", "=", "fig", ".", "add_subplot", "(", "gs", "[", "0", ",", "0", "]", ")", "\n", "axe", ".", "imshow", "(", "gt_seg", ",", "cmap", "=", "'gray'", ")", "\n", "axe", "=", "fig", ".", "add_subplot", "(", "gs", "[", "0", ",", "1", "]", ")", "\n", "display_item", "(", "axe", ",", "s_im", ",", "s_seg", ",", "True", ")", "\n", "axe", "=", "fig", ".", "add_subplot", "(", "gs", "[", "0", ",", "2", "]", ")", "\n", "display_item", "(", "axe", ",", "t_im", ",", "t_seg", ",", "True", ")", "\n", "#fig.show()", "\n", "\n", "fig", ".", "suptitle", "(", "'gt, source seg, target seg'", ",", "fontsize", "=", "12", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.save_dict_to_file": [[1051, 1057], ["pathlib.Path", "pathlib.Path.parent.mkdir", "open", "open.write", "open.close", "str"], "function", ["None"], ["", "def", "save_dict_to_file", "(", "dic", ",", "workdir", ",", "mode", ")", ":", "\n", "    ", "save_path", "=", "Path", "(", "workdir", ",", "mode", "+", "'params.txt'", ")", "\n", "save_path", ".", "parent", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "f", "=", "open", "(", "save_path", ",", "'w'", ")", "\n", "f", ".", "write", "(", "str", "(", "dic", ")", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.load_dict_from_file": [[1059, 1064], ["open", "open.read", "open.close", "eval"], "function", ["None"], ["", "def", "load_dict_from_file", "(", "workdir", ")", ":", "\n", "    ", "f", "=", "open", "(", "workdir", "+", "'/params.txt'", ",", "'r'", ")", "\n", "data", "=", "f", ".", "read", "(", ")", "\n", "f", ".", "close", "(", ")", "\n", "return", "eval", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.remap": [[1066, 1071], ["set().issubset", "changes.items", "set", "numpy.unique", "set", "numpy.unique"], "function", ["None"], ["", "def", "remap", "(", "changes", ":", "Dict", "[", "int", ",", "int", "]", ",", "im", ")", ":", "\n", "    ", "assert", "set", "(", "np", ".", "unique", "(", "im", ")", ")", ".", "issubset", "(", "changes", ")", ",", "(", "set", "(", "changes", ")", ",", "np", ".", "unique", "(", "im", ")", ")", "\n", "for", "a", ",", "b", "in", "changes", ".", "items", "(", ")", ":", "\n", "        ", "im", "[", "im", "==", "a", "]", "=", "b", "\n", "", "return", "im", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.get_remaining_time": [[1073, 1077], ["round"], "function", ["None"], ["", "def", "get_remaining_time", "(", "done", ",", "total", ",", "its", ")", ":", "\n", "    ", "time_s", "=", "(", "total", "-", "done", ")", "/", "its", "\n", "time_m", "=", "round", "(", "time_s", "/", "60", ",", "0", ")", "\n", "return", "time_m", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.lr_poly": [[1078, 1080], ["float"], "function", ["None"], ["", "def", "lr_poly", "(", "base_lr", ",", "iter", ",", "max_iter", ",", "power", ")", ":", "\n", "    ", "return", "base_lr", "*", "(", "(", "1", "-", "float", "(", "iter", ")", "/", "max_iter", ")", "**", "(", "power", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.adjust_learning_rate": [[1081, 1086], ["utils.lr_poly", "len"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.lr_poly"], ["", "def", "adjust_learning_rate", "(", "optimizer", ",", "i_iter", ",", "learning_rate", ",", "num_steps", ",", "power", ")", ":", "\n", "    ", "lr", "=", "lr_poly", "(", "learning_rate", ",", "i_iter", ",", "num_steps", ",", "power", ")", "\n", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "=", "lr", "\n", "if", "len", "(", "optimizer", ".", "param_groups", ")", ">", "1", ":", "\n", "        ", "optimizer", ".", "param_groups", "[", "1", "]", "[", "'lr'", "]", "=", "lr", "*", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.loss_calc": [[1088, 1100], ["Variable().to", "torch.randn", "torch.randn", "CrossEntropy", "CrossEntropy.", "Variable", "Variable().to.long"], "function", ["None"], ["", "", "def", "loss_calc", "(", "pred", ",", "label", ",", "device", ")", ":", "\n", "    ", "\"\"\"\n    This function returns cross entropy loss for semantic segmentation\n    \"\"\"", "\n", "# out shape batch_size x channels x h x w -> batch_size x channels x h x w", "\n", "# label shape h x w x 1 x batch_size  -> batch_size x 1 x h x w", "\n", "label", "=", "Variable", "(", "label", ".", "long", "(", ")", ")", ".", "to", "(", "device", "=", "device", ")", "\n", "#criterion = CrossEntropy2d().to(device=device)", "\n", "loss_params", "=", "{", "'idc'", ":", "[", "0", ",", "1", "]", ",", "'weights'", ":", "[", "9216", "/", "9099", ",", "9216", "/", "117", "]", "}", "\n", "bounds", "=", "torch", ".", "randn", "(", "1", ")", "\n", "criterion", "=", "CrossEntropy", "(", "**", "loss_params", ",", "dtype", "=", "\"torch.float32\"", ")", "\n", "return", "criterion", "(", "pred", ",", "label", ",", "bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.d_loss_calc": [[1101, 1106], ["utils.BCELoss", "BCELoss."], "function", ["None"], ["", "def", "d_loss_calc", "(", "pred", ",", "label", ")", ":", "\n", "#label = Variable(label.long()).to(device=device)", "\n", "    ", "loss_params", "=", "{", "'idc'", ":", "[", "0", ",", "1", "]", "}", "\n", "criterion", "=", "BCELoss", "(", "**", "loss_params", ",", "dtype", "=", "\"torch.float32\"", ")", "\n", "return", "criterion", "(", "pred", ",", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.adjust_learning_rate_D": [[1122, 1128], ["utils.lr_poly", "print", "len"], "function", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.lr_poly"], ["", "", "def", "adjust_learning_rate_D", "(", "optimizer", ",", "i_iter", ",", "learning_rate_D", ",", "num_steps", ",", "power", ")", ":", "\n", "    ", "lr", "=", "lr_poly", "(", "learning_rate_D", ",", "i_iter", ",", "num_steps", ",", "power", ")", "\n", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "=", "lr", "\n", "print", "(", "f'> New learning Rate: {lr}'", ")", "\n", "if", "len", "(", "optimizer", ".", "param_groups", ")", ">", "1", ":", "\n", "        ", "optimizer", ".", "param_groups", "[", "1", "]", "[", "'lr'", "]", "=", "lr", "*", "10", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils._read_lists": [[1131, 1146], ["os.path.isfile", "open", "fd.readlines", "my_list.append", "len", "fd.readlines.remove", "_item.split"], "function", ["None"], ["", "", "def", "_read_lists", "(", "fid", ")", ":", "\n", "    ", "\"\"\"\n    Read all kinds of lists from text file to python lists\n    \"\"\"", "\n", "if", "not", "os", ".", "path", ".", "isfile", "(", "fid", ")", ":", "\n", "        ", "return", "None", "\n", "", "with", "open", "(", "fid", ",", "'r'", ")", "as", "fd", ":", "\n", "        ", "_list", "=", "fd", ".", "readlines", "(", ")", "\n", "\n", "", "my_list", "=", "[", "]", "\n", "for", "_item", "in", "_list", ":", "\n", "        ", "if", "len", "(", "_item", ")", "<", "3", ":", "\n", "            ", "_list", ".", "remove", "(", "_item", ")", "\n", "", "my_list", ".", "append", "(", "_item", ".", "split", "(", "'\\n'", ")", "[", "0", "]", ")", "\n", "", "return", "my_list", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.str2bool": [[1147, 1154], ["v.lower", "v.lower", "argparse.ArgumentTypeError"], "function", ["None"], ["", "def", "str2bool", "(", "v", ")", ":", "\n", "    ", "if", "v", ".", "lower", "(", ")", "in", "(", "'yes'", ",", "'true'", ",", "'t'", ",", "'y'", ",", "'1'", ")", ":", "\n", "        ", "return", "True", "\n", "", "elif", "v", ".", "lower", "(", ")", "in", "(", "'no'", ",", "'false'", ",", "'f'", ",", "'n'", ",", "'0'", ")", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "raise", "argparse", ".", "ArgumentTypeError", "(", "'Boolean value expected.'", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.AbstractConstraints.__init__": [[21, 26], ["len", "getattr", "__import__"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "#self.nd: str = kwargs[\"nd\"]", "\n", "self", ".", "C", "=", "len", "(", "self", ".", "idc", ")", "\n", "self", ".", "__fn__", "=", "getattr", "(", "__import__", "(", "'utils'", ")", ",", "kwargs", "[", "'fn'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.AbstractConstraints.penalty": [[30, 36], ["None"], "methods", ["None"], ["", "def", "penalty", "(", "self", ",", "z", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "\"\"\"\n        id: int - Is used to tell if is it the upper or the lower bound\n                  0 for lower, 1 for upper\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.AbstractConstraints.__call__": [[37, 77], ["utils.simplex", "utils.probs2one_hot().detach", "typing.cast", "typing.cast().reshape", "typing.cast().reshape", "losses.AbstractConstraints.penalty", "losses.AbstractConstraints.penalty", "losses.AbstractConstraints.__fn__", "upper_penalty.numel", "lower_penalty.numel", "upper_z.numel", "lower_z.numel", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "res.sum", "functools.reduce", "utils.probs2one_hot", "typing.cast", "typing.cast"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.NaivePenalty.penalty", "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.NaivePenalty.penalty", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2one_hot"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "bounds", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "# and simplex(target)  # Actually, does not care about second part", "\n", "assert", "probs", ".", "shape", "==", "target", ".", "shape", "\n", "predicted_mask", "=", "probs2one_hot", "(", "probs", ")", ".", "detach", "(", ")", "\n", "# b, _, w, h = probs.shape  # type: Tuple[int, int, int, int]", "\n", "b", ":", "int", "\n", "b", ",", "_", ",", "*", "im_shape", "=", "probs", ".", "shape", "\n", "_", ",", "_", ",", "k", ",", "two", "=", "bounds", ".", "shape", "# scalar or vector", "\n", "assert", "two", "==", "2", "\n", "\n", "value", ":", "Tensor", "=", "cast", "(", "Tensor", ",", "self", ".", "__fn__", "(", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ")", ")", "\n", "#size_pred = soft_size(predicted_mask[:, self.idc, ...].type(torch.float32))", "\n", "#bool_size = (size_pred > 10).type(torch.float32)", "\n", "#print(\"before\",value)", "\n", "#print(value.shape,bool_size.shape)", "\n", "#value = torch.einsum(\"bco,bco->bco\", [value, bool_size])", "\n", "#print(\"after\", value)", "\n", "lower_b", "=", "bounds", "[", ":", ",", "self", ".", "idc", ",", ":", ",", "0", "]", "\n", "#print(\"lower_b\",lower_b)", "\n", "upper_b", "=", "bounds", "[", ":", ",", "self", ".", "idc", ",", ":", ",", "1", "]", "\n", "\n", "assert", "value", ".", "shape", "==", "(", "b", ",", "self", ".", "C", ",", "k", ")", ",", "value", ".", "shape", "\n", "assert", "lower_b", ".", "shape", "==", "upper_b", ".", "shape", "==", "(", "b", ",", "self", ".", "C", ",", "k", ")", ",", "lower_b", ".", "shape", "\n", "#print(\" estimation from probs: \",value,\"gt: \", lower_b, \"gt size\", soft_size(target[:, self.idc, ...]))", "\n", "upper_z", ":", "Tensor", "=", "cast", "(", "Tensor", ",", "(", "value", "-", "upper_b", ")", ".", "type", "(", "torch", ".", "float32", ")", ")", ".", "reshape", "(", "b", ",", "self", ".", "C", "*", "k", ")", "\n", "lower_z", ":", "Tensor", "=", "cast", "(", "Tensor", ",", "(", "lower_b", "-", "value", ")", ".", "type", "(", "torch", ".", "float32", ")", ")", ".", "reshape", "(", "b", ",", "self", ".", "C", "*", "k", ")", "\n", "#assert len(upper_z) == len(lower_b) == len(filenames)", "\n", "\n", "\n", "upper_penalty", ":", "Tensor", "=", "self", ".", "penalty", "(", "upper_z", ")", "\n", "lower_penalty", ":", "Tensor", "=", "self", ".", "penalty", "(", "lower_z", ")", "\n", "assert", "upper_penalty", ".", "numel", "(", ")", "==", "lower_penalty", ".", "numel", "(", ")", "==", "upper_z", ".", "numel", "(", ")", "==", "lower_z", ".", "numel", "(", ")", "\n", "\n", "# f for flattened axis", "\n", "res", ":", "Tensor", "=", "einsum", "(", "\"f->\"", ",", "upper_penalty", ")", "+", "einsum", "(", "\"f->\"", ",", "lower_penalty", ")", "\n", "\n", "loss", ":", "Tensor", "=", "res", ".", "sum", "(", ")", "/", "reduce", "(", "mul", ",", "im_shape", ")", "\n", "assert", "loss", ".", "requires_grad", "==", "probs", ".", "requires_grad", "# Handle the case for validation", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.NaivePenalty.penalty": [[80, 84], ["z.flatten", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["    ", "def", "penalty", "(", "self", ",", "z", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "# assert z.shape == ()", "\n", "        ", "z_", ":", "Tensor", "=", "z", ".", "flatten", "(", ")", "\n", "return", "F", ".", "relu", "(", "z_", ")", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.DiceLoss.__init__": [[86, 91], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "#self.nd: str = kwargs[\"nd\"]", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.DiceLoss.__call__": [[92, 106], ["probs[].type", "target[].type", "torch.einsum", "torch.einsum", "torch.einsum", "divided.mean", "utils.simplex", "utils.simplex", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "_", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "and", "simplex", "(", "target", ")", "\n", "\n", "pc", "=", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "tc", "=", "target", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "intersection", ":", "Tensor", "=", "einsum", "(", "f\"bcwh,bcwh->bc\"", ",", "pc", ",", "tc", ")", "\n", "union", ":", "Tensor", "=", "(", "einsum", "(", "f\"bkwh->bk\"", ",", "pc", ")", "+", "einsum", "(", "f\"bkwh->bk\"", ",", "tc", ")", ")", "\n", "\n", "divided", ":", "Tensor", "=", "torch", ".", "ones_like", "(", "intersection", ")", "-", "(", "2", "*", "intersection", "+", "1e-10", ")", "/", "(", "union", "+", "1e-10", ")", "\n", "\n", "loss", "=", "divided", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.EntKLPropWMoment.__init__": [[111, 125], ["getattr", "getattr", "__import__", "__import__"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "power", ":", "int", "=", "kwargs", "[", "\"power\"", "]", "\n", "self", ".", "__fn__", "=", "getattr", "(", "__import__", "(", "'utils'", ")", ",", "kwargs", "[", "'fn'", "]", ")", "\n", "self", ".", "__momfn__", "=", "getattr", "(", "__import__", "(", "'utils'", ")", ",", "kwargs", "[", "'moment_fn'", "]", ")", "\n", "self", ".", "curi", ":", "bool", "=", "kwargs", "[", "\"curi\"", "]", "\n", "self", ".", "idc", ":", "bool", "=", "kwargs", "[", "\"idc_c\"", "]", "\n", "self", ".", "ivd", ":", "bool", "=", "kwargs", "[", "\"ivd\"", "]", "\n", "self", ".", "weights", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"weights_se\"", "]", "\n", "self", ".", "mom_est", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"mom_est\"", "]", "\n", "self", ".", "lamb_se", ":", "float", "=", "kwargs", "[", "\"lamb_se\"", "]", "\n", "self", ".", "lamb_consprior", ":", "float", "=", "kwargs", "[", "\"lamb_consprior\"", "]", "\n", "self", ".", "lamb_moment", ":", "float", "=", "kwargs", "[", "\"lamb_moment\"", "]", "\n", "self", ".", "margin", ":", "float", "=", "kwargs", "[", "\"margin\"", "]", "\n", "self", ".", "temp", ":", "float", "=", "kwargs", "[", "\"temp\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.EntKLPropWMoment.__call__": [[126, 197], ["utils.simplex", "utils.probs2one_hot().detach", "losses.EntKLPropWMoment.__fn__", "est_prop.squeeze.squeeze.squeeze", "utils.soft_size", "utils.soft_size", "probs.type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "losses.EntKLPropWMoment.__fn__", "gt_prop.squeeze.squeeze.squeeze", "predicted_mask[].type", "target[].type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "losses.EntKLPropWMoment.__momfn__", "torch.einsum", "torch.einsum", "torch.einsum", "losses.EntKLPropWMoment.__momfn__", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "mask.sum", "utils.probs2one_hot", "bounds.unsqueeze.unsqueeze.unsqueeze", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "probs.type", "probs[].type", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.FloatTensor().expand().unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "binary_est_gt_moment[].to", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "torch.FloatTensor().unsqueeze().unsqueeze", "est_gt_moment[].to", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().expand", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.FloatTensor().unsqueeze", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.soft_size", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2one_hot"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "bounds", ",", "epc", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "# and simplex(target)  # Actually, does not care about second part", "\n", "b", ",", "c", ",", "w", ",", "h", "=", "probs", ".", "shape", "# type: Tuple[int, int, int, int]", "\n", "predicted_mask", "=", "probs2one_hot", "(", "probs", ")", ".", "detach", "(", ")", "\n", "est_prop", ":", "Tensor", "=", "self", ".", "__fn__", "(", "probs", ",", "self", ".", "power", ")", "\n", "if", "self", ".", "curi", ":", "\n", "            ", "if", "self", ".", "ivd", ":", "\n", "                ", "bounds", "=", "bounds", "[", ":", ",", ":", ",", "0", "]", "\n", "bounds", "=", "bounds", ".", "unsqueeze", "(", "2", ")", "\n", "", "gt_prop", "=", "torch", ".", "ones_like", "(", "est_prop", ")", "*", "bounds", "/", "(", "w", "*", "h", ")", "\n", "gt_prop", "=", "gt_prop", "[", ":", ",", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "gt_prop", ":", "Tensor", "=", "self", ".", "__fn__", "(", "target", ",", "self", ".", "power", ")", "\n", "", "if", "not", "self", ".", "curi", ":", "\n", "            ", "gt_prop", "=", "gt_prop", ".", "squeeze", "(", "2", ")", "\n", "", "est_prop", "=", "est_prop", ".", "squeeze", "(", "2", ")", "\n", "log_est_prop", ":", "Tensor", "=", "(", "est_prop", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "\n", "log_gt_prop", ":", "Tensor", "=", "(", "gt_prop", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "\n", "size_pred", "=", "soft_size", "(", "predicted_mask", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "size_gt", "=", "soft_size", "(", "target", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "bool_size", "=", "(", "size_pred", ">", "10", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "bool_gt_size", "=", "(", "size_gt", ">", "1", ")", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "loss_cons_prior", "=", "-", "torch", ".", "einsum", "(", "\"bc,bc->\"", ",", "[", "est_prop", ",", "log_gt_prop", "]", ")", "+", "torch", ".", "einsum", "(", "\"bc,bc->\"", ",", "[", "est_prop", ",", "log_est_prop", "]", ")", "\n", "loss_cons_prior", "/=", "b", "\n", "loss_cons_prior", "*=", "self", ".", "temp", "\n", "\n", "if", "self", ".", "__momfn__", ".", "__name__", "==", "\"class_dist_centroid\"", ":", "\n", "            ", "loss_moment", "=", "self", ".", "__momfn__", "(", "probs", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "loss_moment", "=", "einsum", "(", "\"bou->\"", ",", "loss_moment", ")", "\n", "", "else", ":", "\n", "            ", "probs_moment", "=", "self", ".", "__momfn__", "(", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", ")", "\n", "# for numerical stability, only keep probs_moment if there is a predicted structure", "\n", "probs_moment", "=", "torch", ".", "einsum", "(", "\"bct,bco->bct\"", ",", "[", "probs_moment", ",", "bool_size", "]", ")", "\n", "# add the tag", "\n", "probs_moment", "=", "torch", ".", "einsum", "(", "\"bct,bco->bct\"", ",", "[", "probs_moment", ",", "bool_gt_size", "]", ")", "\n", "\n", "if", "probs_moment", ".", "shape", "[", "2", "]", "==", "2", ":", "# centroid and dist2centroid", "\n", "\n", "                ", "binary_est_gt_moment_w", "=", "torch", ".", "FloatTensor", "(", "self", ".", "mom_est", "[", "0", "]", ")", ".", "expand", "(", "b", ",", "c", ")", ".", "unsqueeze", "(", "2", ")", "\n", "binary_est_gt_moment_h", "=", "torch", ".", "FloatTensor", "(", "self", ".", "mom_est", "[", "1", "]", ")", ".", "expand", "(", "b", ",", "c", ")", ".", "unsqueeze", "(", "2", ")", "\n", "binary_est_gt_moment", "=", "torch", ".", "cat", "(", "(", "binary_est_gt_moment_w", ",", "binary_est_gt_moment_h", ")", ",", "2", ")", "\n", "binary_est_gt_moment", "=", "binary_est_gt_moment", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "to", "(", "loss_cons_prior", ".", "device", ")", "\n", "est_gt_moment", "=", "binary_est_gt_moment", "\n", "\n", "", "else", ":", "\n", "                ", "est_gt_moment", "=", "torch", ".", "FloatTensor", "(", "self", ".", "mom_est", ")", ".", "unsqueeze", "(", "0", ")", ".", "unsqueeze", "(", "2", ")", "\n", "est_gt_moment", "=", "est_gt_moment", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "to", "(", "loss_cons_prior", ".", "device", ")", "\n", "", "est_gt_moment", "=", "torch", ".", "einsum", "(", "\"bct,bco->bct\"", ",", "[", "est_gt_moment", ",", "bool_gt_size", "]", ")", "\n", "\n", "upper_z", "=", "(", "est_gt_moment", "*", "(", "1", "+", "self", ".", "margin", ")", "-", "probs_moment", ")", ".", "flatten", "(", ")", "\n", "lower_z", "=", "(", "probs_moment", "-", "est_gt_moment", "*", "(", "1", "-", "self", ".", "margin", ")", ")", ".", "flatten", "(", ")", "\n", "upper_z", "=", "F", ".", "relu", "(", "upper_z", ")", "**", "2", "\n", "lower_z", "=", "F", ".", "relu", "(", "lower_z", ")", "**", "2", "\n", "loss_moment", "=", "upper_z", "+", "lower_z", "\n", "loss_moment", "=", "einsum", "(", "\"f->\"", ",", "loss_moment", ")", "\n", "\n", "# Adding division by batch_size to normalise", "\n", "", "loss_moment", "/=", "b", "\n", "log_p", ":", "Tensor", "=", "(", "probs", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "mask", ":", "Tensor", "=", "probs", ".", "type", "(", "(", "torch", ".", "float32", ")", ")", "\n", "mask_weighted", "=", "torch", ".", "einsum", "(", "\"bcwh,c->bcwh\"", ",", "[", "mask", ",", "Tensor", "(", "self", ".", "weights", ")", ".", "to", "(", "mask", ".", "device", ")", "]", ")", "\n", "loss_se", "=", "-", "torch", ".", "einsum", "(", "\"bcwh,bcwh->\"", ",", "[", "mask_weighted", ",", "log_p", "]", ")", "\n", "loss_se", "/=", "mask", ".", "sum", "(", ")", "+", "1e-10", "\n", "\n", "assert", "loss_se", ".", "requires_grad", "==", "probs", ".", "requires_grad", "# Handle the case for validation", "\n", "\n", "return", "self", ".", "lamb_se", "*", "loss_se", "+", "self", ".", "lamb_consprior", "*", "loss_cons_prior", ",", "self", ".", "lamb_moment", "*", "loss_moment", ",", "est_prop", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.EntKLProp.__init__": [[203, 212], ["getattr", "__import__"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "power", ":", "int", "=", "kwargs", "[", "\"power\"", "]", "\n", "self", ".", "__fn__", "=", "getattr", "(", "__import__", "(", "'utils'", ")", ",", "kwargs", "[", "'fn'", "]", ")", "\n", "self", ".", "curi", ":", "bool", "=", "kwargs", "[", "\"curi\"", "]", "\n", "self", ".", "idc", ":", "bool", "=", "kwargs", "[", "\"idc_c\"", "]", "\n", "self", ".", "ivd", ":", "bool", "=", "kwargs", "[", "\"ivd\"", "]", "\n", "self", ".", "weights", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"weights_se\"", "]", "\n", "self", ".", "lamb_se", ":", "float", "=", "kwargs", "[", "\"lamb_se\"", "]", "\n", "self", ".", "lamb_consprior", ":", "float", "=", "kwargs", "[", "\"lamb_consprior\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.EntKLProp.__call__": [[213, 244], ["utils.simplex", "utils.probs2one_hot().detach", "losses.EntKLProp.__fn__", "est_prop.squeeze.squeeze.squeeze", "probs.type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "losses.EntKLProp.__fn__", "gt_prop.squeeze.squeeze.squeeze", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "mask.sum", "utils.probs2one_hot", "bounds.unsqueeze.unsqueeze.unsqueeze", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.ones_like", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2one_hot"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "bounds", ",", "epc", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "# and simplex(target)  # Actually, does not care about second part", "\n", "b", ",", "_", ",", "w", ",", "h", "=", "probs", ".", "shape", "# type: Tuple[int, int, int, int]", "\n", "predicted_mask", "=", "probs2one_hot", "(", "probs", ")", ".", "detach", "(", ")", "\n", "est_prop", ":", "Tensor", "=", "self", ".", "__fn__", "(", "probs", ",", "self", ".", "power", ")", "\n", "if", "self", ".", "curi", ":", "\n", "            ", "if", "self", ".", "ivd", ":", "\n", "                ", "bounds", "=", "bounds", "[", ":", ",", ":", ",", "0", "]", "\n", "bounds", "=", "bounds", ".", "unsqueeze", "(", "2", ")", "\n", "", "gt_prop", "=", "torch", ".", "ones_like", "(", "est_prop", ")", "*", "bounds", "/", "(", "w", "*", "h", ")", "\n", "gt_prop", "=", "gt_prop", "[", ":", ",", ":", ",", "0", "]", "\n", "", "else", ":", "\n", "            ", "gt_prop", ":", "Tensor", "=", "self", ".", "__fn__", "(", "target", ",", "self", ".", "power", ")", "# the power here is actually useless if we have 0/1 gt labels", "\n", "", "if", "not", "self", ".", "curi", ":", "\n", "            ", "gt_prop", "=", "gt_prop", ".", "squeeze", "(", "2", ")", "\n", "", "est_prop", "=", "est_prop", ".", "squeeze", "(", "2", ")", "\n", "log_est_prop", ":", "Tensor", "=", "(", "est_prop", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "\n", "log_gt_prop", ":", "Tensor", "=", "(", "gt_prop", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "loss_cons_prior", "=", "-", "torch", ".", "einsum", "(", "\"bc,bc->\"", ",", "[", "est_prop", ",", "log_gt_prop", "]", ")", "+", "torch", ".", "einsum", "(", "\"bc,bc->\"", ",", "[", "est_prop", ",", "log_est_prop", "]", ")", "\n", "# Adding division by batch_size to normalise ", "\n", "loss_cons_prior", "/=", "b", "\n", "log_p", ":", "Tensor", "=", "(", "probs", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "mask", ":", "Tensor", "=", "probs", ".", "type", "(", "(", "torch", ".", "float32", ")", ")", "\n", "mask_weighted", "=", "torch", ".", "einsum", "(", "\"bcwh,c->bcwh\"", ",", "[", "mask", ",", "Tensor", "(", "self", ".", "weights", ")", ".", "to", "(", "mask", ".", "device", ")", "]", ")", "\n", "loss_se", "=", "-", "torch", ".", "einsum", "(", "\"bcwh,bcwh->\"", ",", "[", "mask_weighted", ",", "log_p", "]", ")", "\n", "loss_se", "/=", "mask", ".", "sum", "(", ")", "+", "1e-10", "\n", "\n", "assert", "loss_se", ".", "requires_grad", "==", "probs", ".", "requires_grad", "# Handle the case for validation", "\n", "\n", "return", "self", ".", "lamb_se", "*", "loss_se", ",", "self", ".", "lamb_consprior", "*", "loss_cons_prior", ",", "est_prop", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.ProposalLoss.__init__": [[247, 253], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "self", ".", "weights", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"weights\"", "]", "\n", "self", ".", "dtype", "=", "kwargs", "[", "\"dtype\"", "]", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.ProposalLoss.__call__": [[254, 264], ["utils.probs2one_hot().detach", "predicted_mask[].type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "utils.simplex", "utils.simplex", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "mask.sum", "utils.probs2one_hot", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.probs2one_hot"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "bounds", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "and", "simplex", "(", "target", ")", "\n", "predicted_mask", "=", "probs2one_hot", "(", "probs", ")", ".", "detach", "(", ")", "\n", "log_p", ":", "Tensor", "=", "(", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "mask", ":", "Tensor", "=", "predicted_mask", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "(", "torch", ".", "float32", ")", ")", "\n", "mask_weighted", "=", "torch", ".", "einsum", "(", "\"bcwh,c->bcwh\"", ",", "[", "mask", ",", "Tensor", "(", "self", ".", "weights", ")", ".", "to", "(", "mask", ".", "device", ")", "]", ")", "\n", "loss", "=", "-", "torch", ".", "einsum", "(", "\"bcwh,bcwh->\"", ",", "[", "mask_weighted", ",", "log_p", "]", ")", "\n", "loss", "/=", "mask", ".", "sum", "(", ")", "+", "1e-10", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.SelfEntropy.__init__": [[267, 273], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "self", ".", "weights", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"weights\"", "]", "\n", "self", ".", "dtype", "=", "kwargs", "[", "\"dtype\"", "]", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.SelfEntropy.__call__": [[274, 284], ["probs[].type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "utils.simplex", "utils.simplex", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "mask.sum", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "bounds", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "and", "simplex", "(", "target", ")", "\n", "\n", "log_p", ":", "Tensor", "=", "(", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "mask", ":", "Tensor", "=", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "(", "torch", ".", "float32", ")", ")", "\n", "mask_weighted", "=", "torch", ".", "einsum", "(", "\"bcwh,c->bcwh\"", ",", "[", "mask", ",", "Tensor", "(", "self", ".", "weights", ")", ".", "to", "(", "mask", ".", "device", ")", "]", ")", "\n", "loss", "=", "-", "torch", ".", "einsum", "(", "\"bcwh,bcwh->\"", ",", "[", "mask_weighted", ",", "log_p", "]", ")", "\n", "loss", "/=", "mask", ".", "sum", "(", ")", "+", "1e-10", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.CrossEntropy.__init__": [[288, 294], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "self", ".", "weights", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"weights\"", "]", "\n", "self", ".", "dtype", "=", "kwargs", "[", "\"dtype\"", "]", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.CrossEntropy.__call__": [[295, 304], ["target[].type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "utils.simplex", "utils.simplex", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "mask.sum", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "bounds", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "and", "simplex", "(", "target", ")", "\n", "\n", "log_p", ":", "Tensor", "=", "(", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "mask", ":", "Tensor", "=", "target", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "(", "torch", ".", "float32", ")", ")", "\n", "mask_weighted", "=", "torch", ".", "einsum", "(", "\"bcwh,c->bcwh\"", ",", "[", "mask", ",", "Tensor", "(", "self", ".", "weights", ")", ".", "to", "(", "mask", ".", "device", ")", "]", ")", "\n", "loss", "=", "-", "torch", ".", "einsum", "(", "\"bcwh,bcwh->\"", ",", "[", "mask_weighted", ",", "log_p", "]", ")", "\n", "loss", "/=", "mask", ".", "sum", "(", ")", "+", "1e-10", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.BCELoss.__init__": [[307, 311], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "self", ".", "dtype", "=", "kwargs", "[", "\"dtype\"", "]", "\n", "#print(f\"Initialized {self.__class__.__name__} with {kwargs}\")", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.BCELoss.__call__": [[313, 317], ["torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss", "torch.nn.BCEWithLogitsLoss.", "torch.nn.BCEWithLogitsLoss.", "torch.nn.BCEWithLogitsLoss.", "torch.Tensor().fill_().to", "torch.Tensor().fill_().to", "torch.Tensor().fill_().to", "torch.Tensor().fill_", "torch.Tensor().fill_", "torch.Tensor().fill_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "d_out.data.size"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "d_out", ":", "Tensor", ",", "label", ":", "float", ")", ":", "\n", "        ", "bce_loss", "=", "torch", ".", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "loss", "=", "bce_loss", "(", "d_out", ",", "Tensor", "(", "d_out", ".", "data", ".", "size", "(", ")", ")", ".", "fill_", "(", "label", ")", ".", "to", "(", "d_out", ".", "device", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.BCEGDice.__init__": [[320, 325], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "self", ".", "lamb", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"lamb\"", "]", "\n", "self", ".", "weights", ":", "List", "[", "float", "]", "=", "kwargs", "[", "\"weights\"", "]", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "_", ":", "Tensor", ")", "->", "Tensor", ":", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.BCEGDice.__call__": [[325, 346], ["probs[].type", "target[].type", "divided.mean", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "utils.simplex", "utils.simplex", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "target[].type.sum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.Tensor().to", "torch.Tensor().to", "torch.Tensor().to", "torch.einsum().type", "torch.einsum().type", "torch.einsum().type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.einsum", "torch.einsum", "torch.einsum"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "_", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "and", "simplex", "(", "target", ")", "\n", "\n", "pc", "=", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "tc", "=", "target", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "w", ":", "Tensor", "=", "1", "/", "(", "(", "einsum", "(", "\"bcwh->bc\"", ",", "tc", ")", ".", "type", "(", "torch", ".", "float32", ")", "+", "1e-10", ")", "**", "2", ")", "\n", "intersection", ":", "Tensor", "=", "w", "*", "einsum", "(", "\"bcwh,bcwh->bc\"", ",", "pc", ",", "tc", ")", "\n", "union", ":", "Tensor", "=", "w", "*", "(", "einsum", "(", "\"bcwh->bc\"", ",", "pc", ")", "+", "einsum", "(", "\"bcwh->bc\"", ",", "tc", ")", ")", "\n", "\n", "divided", ":", "Tensor", "=", "1", "-", "2", "*", "(", "einsum", "(", "\"bc->b\"", ",", "intersection", ")", "+", "1e-10", ")", "/", "(", "einsum", "(", "\"bc->b\"", ",", "union", ")", "+", "1e-10", ")", "\n", "\n", "loss_gde", "=", "divided", ".", "mean", "(", ")", "\n", "\n", "log_p", ":", "Tensor", "=", "(", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", "+", "1e-10", ")", ".", "log", "(", ")", "\n", "mask_weighted", "=", "torch", ".", "einsum", "(", "\"bcwh,c->bcwh\"", ",", "[", "tc", ",", "Tensor", "(", "self", ".", "weights", ")", ".", "to", "(", "tc", ".", "device", ")", "]", ")", "\n", "loss_ce", "=", "-", "torch", ".", "einsum", "(", "\"bcwh,bcwh->\"", ",", "[", "mask_weighted", ",", "log_p", "]", ")", "\n", "loss_ce", "/=", "tc", ".", "sum", "(", ")", "+", "1e-10", "\n", "loss", "=", "loss_ce", "+", "self", ".", "lamb", "*", "loss_gde", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__init__": [[350, 354], ["print"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "# Self.idc is used to filter out some classes of the target mask. Use fancy indexing", "\n", "        ", "self", ".", "idc", ":", "List", "[", "int", "]", "=", "kwargs", "[", "\"idc\"", "]", "\n", "print", "(", "f\"Initialized {self.__class__.__name__} with {kwargs}\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mathilde-b_tta.None.losses.GeneralizedDice.__call__": [[355, 370], ["probs[].type", "target[].type", "divided.mean", "utils.simplex", "utils.simplex", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum().type", "torch.einsum().type", "torch.einsum().type", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum", "torch.einsum"], "methods", ["home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex", "home.repos.pwc.inspect_result.mathilde-b_tta.None.utils.simplex"], ["", "def", "__call__", "(", "self", ",", "probs", ":", "Tensor", ",", "target", ":", "Tensor", ",", "_", ":", "Tensor", ")", "->", "Tensor", ":", "\n", "        ", "assert", "simplex", "(", "probs", ")", "and", "simplex", "(", "target", ")", "\n", "\n", "pc", "=", "probs", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "tc", "=", "target", "[", ":", ",", "self", ".", "idc", ",", "...", "]", ".", "type", "(", "torch", ".", "float32", ")", "\n", "\n", "w", ":", "Tensor", "=", "1", "/", "(", "(", "einsum", "(", "\"bcwh->bc\"", ",", "tc", ")", ".", "type", "(", "torch", ".", "float32", ")", "+", "1e-10", ")", "**", "2", ")", "\n", "intersection", ":", "Tensor", "=", "w", "*", "einsum", "(", "\"bcwh,bcwh->bc\"", ",", "pc", ",", "tc", ")", "\n", "union", ":", "Tensor", "=", "w", "*", "(", "einsum", "(", "\"bcwh->bc\"", ",", "pc", ")", "+", "einsum", "(", "\"bcwh->bc\"", ",", "tc", ")", ")", "\n", "\n", "divided", ":", "Tensor", "=", "1", "-", "2", "*", "(", "einsum", "(", "\"bc->b\"", ",", "intersection", ")", "+", "1e-10", ")", "/", "(", "einsum", "(", "\"bc->b\"", ",", "union", ")", "+", "1e-10", ")", "\n", "\n", "loss", "=", "divided", ".", "mean", "(", ")", "\n", "\n", "return", "loss", "\n", "", "", ""]]}