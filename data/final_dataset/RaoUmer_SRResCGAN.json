{"home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.timer.__init__": [[6, 9], ["utils.timer.tic"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.tic"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "=", "0", "\n", "self", ".", "tic", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.timer.tic": [[10, 12], ["time.time"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "        ", "self", ".", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.timer.toc": [[13, 17], ["time.time", "time.time"], "methods", ["None"], ["", "def", "toc", "(", "self", ",", "restart", "=", "False", ")", ":", "\n", "        ", "diff", "=", "time", ".", "time", "(", ")", "-", "self", ".", "t0", "\n", "if", "restart", ":", "self", ".", "t0", "=", "time", ".", "time", "(", ")", "\n", "return", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.timer.hold": [[18, 20], ["utils.timer.toc"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.toc"], ["", "def", "hold", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "+=", "self", ".", "toc", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.timer.release": [[21, 26], ["None"], "methods", ["None"], ["", "def", "release", "(", "self", ")", ":", "\n", "        ", "ret", "=", "self", ".", "acc", "\n", "self", ".", "acc", "=", "0", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.timer.reset": [[27, 29], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.augment_img": [[30, 47], ["numpy.flipud", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.rot90", "numpy.rot90", "numpy.flipud", "numpy.rot90"], "function", ["None"], ["", "", "def", "augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ")", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "img", ")", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.inv_augment_img": [[48, 65], ["numpy.fliplr", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.fliplr", "numpy.rot90", "numpy.rot90", "numpy.fliplr", "numpy.rot90"], "function", ["None"], ["", "", "def", "inv_augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "img", ")", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "img", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "np", ".", "rot90", "(", "img", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.augment_img_np3": [[67, 93], ["img.transpose.transpose", "img.transpose.transpose", "img.transpose.transpose", "img.transpose.transpose"], "function", ["None"], ["", "", "def", "augment_img_np3", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "return", "img", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.augment_img_tensor": [[95, 110], ["img.size", "img.data.cpu().numpy", "utils.augment_img", "torch.from_numpy", "img_tensor.permute.type_as", "len", "numpy.transpose", "numpy.ascontiguousarray", "len", "img_tensor.permute.permute", "img.data.cpu", "len", "numpy.transpose", "len", "img_tensor.permute.permute"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.augment_img"], ["", "", "def", "augment_img_tensor", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "img_size", "=", "img", ".", "size", "(", ")", "\n", "img_np", "=", "img", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "img_np", "=", "augment_img", "(", "img_np", ",", "mode", "=", "mode", ")", "\n", "img_tensor", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img_np", ")", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "return", "img_tensor", ".", "type_as", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.srrescgan_code_demo.utils.inv_augment_img_tensor": [[111, 126], ["img.size", "img.data.cpu().numpy", "utils.inv_augment_img", "torch.from_numpy", "img_tensor.permute.type_as", "len", "numpy.transpose", "numpy.ascontiguousarray", "len", "img_tensor.permute.permute", "img.data.cpu", "len", "numpy.transpose", "len", "img_tensor.permute.permute"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.inv_augment_img"], ["", "def", "inv_augment_img_tensor", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "img_size", "=", "img", ".", "size", "(", ")", "\n", "img_np", "=", "img", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "img_np", "=", "inv_augment_img", "(", "img_np", ",", "mode", "=", "mode", ")", "\n", "img_tensor", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img_np", ")", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "return", "img_tensor", ".", "type_as", "(", "img", ")", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.BasicBlock.__init__": [[15, 26], ["torch.Module.__init__", "SRResCGAN.conv3x3", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.PReLU", "SRResCGAN.conv3x3", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.conv3x3", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "weightnorm", "=", "None", ",", "shortcut", "=", "True", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shortcut", "=", "shortcut", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "\n", "self", ".", "relu1", "=", "nn", ".", "PReLU", "(", "num_parameters", "=", "planes", ",", "init", "=", "0.1", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "PReLU", "(", "num_parameters", "=", "planes", ",", "init", "=", "0.1", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "if", "weightnorm", ":", "\n", "            ", "self", ".", "conv1", "=", "weight_norm", "(", "self", ".", "conv1", ")", "\n", "self", ".", "conv2", "=", "weight_norm", "(", "self", ".", "conv2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.BasicBlock.forward": [[27, 39], ["SRResCGAN.BasicBlock.relu1", "torch.pad", "torch.pad", "torch.pad", "SRResCGAN.BasicBlock.conv1", "SRResCGAN.BasicBlock.relu2", "torch.pad", "torch.pad", "torch.pad", "SRResCGAN.BasicBlock.conv2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "relu1", "(", "x", ")", "\n", "out", "=", "F", ".", "pad", "(", "out", ",", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "'reflect'", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "out", "[", ":", ",", ":", ",", ":", "x", ".", "shape", "[", "2", "]", ",", ":", "x", ".", "shape", "[", "3", "]", "]", "\n", "out", "=", "self", ".", "relu2", "(", "out", ")", "\n", "out", "=", "F", ".", "pad", "(", "out", ",", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "'reflect'", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "out", "[", ":", ",", ":", ",", ":", "x", ".", "shape", "[", "2", "]", ",", ":", "x", ".", "shape", "[", "3", "]", "]", "\n", "if", "self", ".", "shortcut", ":", "\n", "            ", "out", "=", "x", "+", "out", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.L2Proj.__init__": [[45, 47], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "L2Proj", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.L2Proj.forward": [[48, 64], ["torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "x.view", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "x.size", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "x.size", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "stdn", ",", "alpha", ")", ":", "\n", "        ", "if", "x", ".", "is_cuda", ":", "\n", "            ", "x_size", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "x", ".", "shape", "[", "1", "]", "*", "x", ".", "shape", "[", "2", "]", "*", "x", ".", "shape", "[", "3", "]", ")", "\n", "", "else", ":", "\n", "            ", "x_size", "=", "torch", ".", "Tensor", "(", "[", "x", ".", "shape", "[", "1", "]", "*", "x", ".", "shape", "[", "2", "]", "*", "x", ".", "shape", "[", "3", "]", "]", ")", "\n", "", "numX", "=", "torch", ".", "sqrt", "(", "x_size", "-", "1", ")", "\n", "if", "x", ".", "is_cuda", ":", "\n", "            ", "epsilon", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "1", ")", ".", "fill_", "(", "1", ")", "*", "(", "torch", ".", "exp", "(", "alpha", ")", "*", "stdn", "*", "numX", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "", "else", ":", "\n", "            ", "epsilon", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", ".", "fill_", "(", "1", ")", "*", "(", "torch", ".", "exp", "(", "alpha", ")", "*", "stdn", "*", "numX", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "", "x_resized", "=", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "x_norm", "=", "torch", ".", "norm", "(", "x_resized", ",", "2", ",", "dim", "=", "1", ")", ".", "reshape", "(", "x", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", "\n", "max_norm", "=", "torch", ".", "max", "(", "x_norm", ",", "epsilon", ")", "\n", "result", "=", "x", "*", "(", "epsilon", "/", "max_norm", ")", "\n", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.Wmad_estimator.__init__": [[70, 80], ["torch.Module.__init__", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Wmad_estimator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# DB7 high pass decomposition filter", "\n", "self", ".", "db7_decomp_high", "=", "torch", ".", "Tensor", "(", "[", "-", "0.07785205408506236", ",", "0.39653931948230575", ",", "-", "0.7291320908465551", ",", "\n", "0.4697822874053586", ",", "0.14390600392910627", ",", "-", "0.22403618499416572", ",", "\n", "-", "0.07130921926705004", ",", "0.0806126091510659", ",", "0.03802993693503463", ",", "\n", "-", "0.01657454163101562", ",", "-", "0.012550998556013784", ",", "0.00042957797300470274", ",", "\n", "0.0018016407039998328", ",", "0.0003537138000010399", "]", ")", "[", ":", ",", "None", "]", "\n", "self", ".", "db7_decomp_high", "=", "self", ".", "db7_decomp_high", "[", "None", ",", "None", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.Wmad_estimator.forward": [[82, 107], ["torch.pad", "torch.pad", "torch.pad", "torch.conv2d", "torch.conv2d", "torch.conv2d", "torch.pad", "torch.pad", "torch.pad", "torch.conv2d", "torch.conv2d", "torch.conv2d", "diagonal.view.view.view", "range", "sigma.detach.detach.detach", "x.max", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "db7_decomp_high.cuda.cuda.cuda", "diagonal.view.view.transpose", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.median", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "max", "(", ")", ">", "1", ":", "\n", "            ", "x", "=", "x", "/", "255", "\n", "", "db7_decomp_high", "=", "self", ".", "db7_decomp_high", "\n", "if", "x", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "            ", "db7_decomp_high", "=", "torch", ".", "cat", "(", "[", "self", ".", "db7_decomp_high", "]", "*", "x", ".", "shape", "[", "1", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "x", ".", "is_cuda", ":", "\n", "            ", "db7_decomp_high", "=", "db7_decomp_high", ".", "cuda", "(", ")", "\n", "\n", "", "diagonal", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "0", ",", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ",", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ")", ",", "mode", "=", "'reflect'", ")", "\n", "diagonal", "=", "F", ".", "conv2d", "(", "diagonal", ",", "db7_decomp_high", ",", "stride", "=", "(", "2", ",", "1", ")", ",", "groups", "=", "x", ".", "shape", "[", "1", "]", ")", "\n", "diagonal", "=", "F", ".", "pad", "(", "diagonal", ",", "(", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ",", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ",", "0", ",", "0", ")", ",", "mode", "=", "'reflect'", ")", "\n", "diagonal", "=", "F", ".", "conv2d", "(", "diagonal", ".", "transpose", "(", "2", ",", "3", ")", ",", "db7_decomp_high", ",", "stride", "=", "(", "2", ",", "1", ")", ",", "groups", "=", "x", ".", "shape", "[", "1", "]", ")", "\n", "\n", "sigma", "=", "0", "\n", "diagonal", "=", "diagonal", ".", "view", "(", "diagonal", ".", "shape", "[", "0", "]", ",", "diagonal", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "for", "c", "in", "range", "(", "diagonal", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "d", "=", "diagonal", "[", ":", ",", "c", "]", "\n", "sigma", "+=", "torch", ".", "median", "(", "torch", ".", "abs", "(", "d", ")", ",", "dim", "=", "1", ")", "[", "0", "]", "/", "0.6745", "\n", "", "sigma", "=", "sigma", "/", "diagonal", ".", "shape", "[", "1", "]", "\n", "sigma", "=", "sigma", ".", "detach", "(", ")", "\n", "del", "db7_decomp_high", "\n", "\n", "return", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.ResCNet.__init__": [[112, 133], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "SRResCGAN.ResCNet._make_layer", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "SRResCGAN.L2Proj", "SRResCGAN.ResCNet.zeromean", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet._make_layer", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.zeromean"], ["def", "__init__", "(", "self", ",", "depth", "=", "5", ",", "color", "=", "True", ",", "weightnorm", "=", "True", ")", ":", "\n", "        ", "self", ".", "inplanes", "=", "64", "\n", "super", "(", "ResCNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "color", ":", "\n", "            ", "in_channels", "=", "3", "\n", "", "else", ":", "\n", "            ", "in_channels", "=", "1", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "64", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "True", ")", "\n", "if", "weightnorm", ":", "\n", "            ", "self", ".", "conv1", "=", "weight_norm", "(", "self", ".", "conv1", ")", "\n", "\n", "# Resnet blocks layer", "\n", "", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "BasicBlock", ",", "64", ",", "depth", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "ConvTranspose2d", "(", "64", ",", "in_channels", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "bias", "=", "True", ")", "\n", "if", "weightnorm", ":", "\n", "            ", "self", ".", "conv_out", "=", "weight_norm", "(", "self", ".", "conv_out", ")", "\n", "\n", "", "self", ".", "l2proj", "=", "L2Proj", "(", ")", "\n", "self", ".", "zeromean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.ResCNet._make_layer": [[134, 140], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "weightnorm", "=", "True", ",", "shortcut", "=", "False", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "weightnorm", "=", "True", ",", "shortcut", "=", "True", ")", ")", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.ResCNet.zeromean": [[141, 147], ["SRResCGAN.ResCNet.modules", "isinstance", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["None"], ["", "def", "zeromean", "(", "self", ")", ":", "\n", "# Function zeromean subtracts the mean E(f) from filters f", "\n", "# in order to create zero mean filters", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", "=", "m", ".", "weight", ".", "data", "-", "torch", ".", "mean", "(", "m", ".", "weight", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.ResCNet.forward": [[148, 156], ["SRResCGAN.ResCNet.zeromean", "torch.pad", "torch.pad", "torch.pad", "SRResCGAN.ResCNet.conv1", "SRResCGAN.ResCNet.layer1", "SRResCGAN.ResCNet.conv_out", "SRResCGAN.ResCNet.l2proj"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.zeromean"], ["", "", "", "def", "forward", "(", "self", ",", "x", ",", "stdn", ",", "alpha", ")", ":", "\n", "        ", "self", ".", "zeromean", "(", ")", "\n", "out", "=", "F", ".", "pad", "(", "x", ",", "(", "2", ",", "2", ",", "2", ",", "2", ")", ",", "'reflect'", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv_out", "(", "out", ")", "\n", "out", "=", "self", ".", "l2proj", "(", "out", ",", "stdn", ",", "alpha", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.Generator.__init__": [[161, 168], ["torch.Module.__init__", "SRResCGAN.ResCNet", "SRResCGAN.Wmad_estimator", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Hardtanh", "torch.Hardtanh", "torch.Hardtanh", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.linspace", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log"], ["def", "__init__", "(", "self", ",", "scale", ")", ":", "\n", "        ", "super", "(", "Generator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "model", "=", "ResCNet", "(", ")", "\n", "self", ".", "upscale_factor", "=", "scale", "\n", "self", ".", "noise_estimator", "=", "Wmad_estimator", "(", ")", "\n", "self", ".", "alpha", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "np", ".", "linspace", "(", "np", ".", "log", "(", "2", ")", ",", "np", ".", "log", "(", "1", ")", ",", "1", ")", ")", ")", "\n", "self", ".", "bbproj", "=", "nn", ".", "Hardtanh", "(", "min_val", "=", "0.", ",", "max_val", "=", "255.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.Generator.forward": [[169, 187], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "SRResCGAN.Generator.noise_estimator", "SRResCGAN.Generator.model", "SRResCGAN.Generator.bbproj"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# upsampling", "\n", "        ", "input", "=", "F", ".", "interpolate", "(", "input", ",", "scale_factor", "=", "self", ".", "upscale_factor", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "\n", "# estimate sigma ", "\n", "sigma", "=", "self", ".", "noise_estimator", "(", "input", ")", "\n", "sigma", "*=", "255.", "\n", "\n", "# Rescnet model  ", "\n", "output", "=", "self", ".", "model", "(", "input", ",", "sigma", ",", "self", ".", "alpha", ")", "\n", "\n", "# residual ouput", "\n", "output", "=", "input", "-", "output", "\n", "\n", "# clipping layer", "\n", "output", "=", "self", ".", "bbproj", "(", "output", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResCGAN.conv3x3": [[7, 10], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "0", ",", "bias", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.discriminator_vgg_arch.Discriminator_VGG_128.__init__": [[7, 39], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_nc", ",", "nf", ")", ":", "\n", "        ", "super", "(", "Discriminator_VGG_128", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# [64, 128, 128]", "\n", "self", ".", "conv0_0", "=", "nn", ".", "Conv2d", "(", "in_nc", ",", "nf", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv0_1", "=", "nn", ".", "Conv2d", "(", "nf", ",", "nf", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn0_1", "=", "nn", ".", "BatchNorm2d", "(", "nf", ",", "affine", "=", "True", ")", "\n", "# [64, 64, 64]", "\n", "self", ".", "conv1_0", "=", "nn", ".", "Conv2d", "(", "nf", ",", "nf", "*", "2", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_0", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "2", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv1_1", "=", "nn", ".", "Conv2d", "(", "nf", "*", "2", ",", "nf", "*", "2", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1_1", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "2", ",", "affine", "=", "True", ")", "\n", "# [128, 32, 32]", "\n", "self", ".", "conv2_0", "=", "nn", ".", "Conv2d", "(", "nf", "*", "2", ",", "nf", "*", "4", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_0", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "4", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv2_1", "=", "nn", ".", "Conv2d", "(", "nf", "*", "4", ",", "nf", "*", "4", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2_1", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "4", ",", "affine", "=", "True", ")", "\n", "# [256, 16, 16]", "\n", "self", ".", "conv3_0", "=", "nn", ".", "Conv2d", "(", "nf", "*", "4", ",", "nf", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_0", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv3_1", "=", "nn", ".", "Conv2d", "(", "nf", "*", "8", ",", "nf", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3_1", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "8", ",", "affine", "=", "True", ")", "\n", "# [512, 8, 8]", "\n", "self", ".", "conv4_0", "=", "nn", ".", "Conv2d", "(", "nf", "*", "8", ",", "nf", "*", "8", ",", "3", ",", "1", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_0", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "8", ",", "affine", "=", "True", ")", "\n", "self", ".", "conv4_1", "=", "nn", ".", "Conv2d", "(", "nf", "*", "8", ",", "nf", "*", "8", ",", "4", ",", "2", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn4_1", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "8", ",", "affine", "=", "True", ")", "\n", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "512", "*", "4", "*", "4", ",", "100", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "100", ",", "1", ")", "\n", "\n", "# activation function", "\n", "self", ".", "lrelu", "=", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ",", "inplace", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.discriminator_vgg_arch.Discriminator_VGG_128.forward": [[40, 60], ["discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.view", "discriminator_vgg_arch.Discriminator_VGG_128.lrelu", "discriminator_vgg_arch.Discriminator_VGG_128.linear2", "discriminator_vgg_arch.Discriminator_VGG_128.conv0_0", "discriminator_vgg_arch.Discriminator_VGG_128.bn0_1", "discriminator_vgg_arch.Discriminator_VGG_128.bn1_0", "discriminator_vgg_arch.Discriminator_VGG_128.bn1_1", "discriminator_vgg_arch.Discriminator_VGG_128.bn2_0", "discriminator_vgg_arch.Discriminator_VGG_128.bn2_1", "discriminator_vgg_arch.Discriminator_VGG_128.bn3_0", "discriminator_vgg_arch.Discriminator_VGG_128.bn3_1", "discriminator_vgg_arch.Discriminator_VGG_128.bn4_0", "discriminator_vgg_arch.Discriminator_VGG_128.bn4_1", "discriminator_vgg_arch.Discriminator_VGG_128.size", "discriminator_vgg_arch.Discriminator_VGG_128.linear1", "discriminator_vgg_arch.Discriminator_VGG_128.conv0_1", "discriminator_vgg_arch.Discriminator_VGG_128.conv1_0", "discriminator_vgg_arch.Discriminator_VGG_128.conv1_1", "discriminator_vgg_arch.Discriminator_VGG_128.conv2_0", "discriminator_vgg_arch.Discriminator_VGG_128.conv2_1", "discriminator_vgg_arch.Discriminator_VGG_128.conv3_0", "discriminator_vgg_arch.Discriminator_VGG_128.conv3_1", "discriminator_vgg_arch.Discriminator_VGG_128.conv4_0", "discriminator_vgg_arch.Discriminator_VGG_128.conv4_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "conv0_0", "(", "x", ")", ")", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn0_1", "(", "self", ".", "conv0_1", "(", "fea", ")", ")", ")", "\n", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_0", "(", "self", ".", "conv1_0", "(", "fea", ")", ")", ")", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn1_1", "(", "self", ".", "conv1_1", "(", "fea", ")", ")", ")", "\n", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_0", "(", "self", ".", "conv2_0", "(", "fea", ")", ")", ")", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn2_1", "(", "self", ".", "conv2_1", "(", "fea", ")", ")", ")", "\n", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_0", "(", "self", ".", "conv3_0", "(", "fea", ")", ")", ")", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn3_1", "(", "self", ".", "conv3_1", "(", "fea", ")", ")", ")", "\n", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_0", "(", "self", ".", "conv4_0", "(", "fea", ")", ")", ")", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "bn4_1", "(", "self", ".", "conv4_1", "(", "fea", ")", ")", ")", "\n", "\n", "fea", "=", "fea", ".", "view", "(", "fea", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "fea", "=", "self", ".", "lrelu", "(", "self", ".", "linear1", "(", "fea", ")", ")", "\n", "out", "=", "self", ".", "linear2", "(", "fea", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.discriminator_vgg_arch.VGGFeatureExtractor.__init__": [[63, 82], ["torch.device", "torch.device", "torch.device", "torch.device", "torch.Module.__init__", "torch.Sequential", "torch.Sequential", "discriminator_vgg_arch.VGGFeatureExtractor.features.named_parameters", "torchvision.models.vgg19_bn", "torchvision.models.vgg19", "torch.Tensor().view().to", "torch.Tensor().view().to", "torch.Tensor().view().to", "torch.Tensor().view().to", "torch.Tensor().view().to", "torch.Tensor().view().to", "torch.Tensor().view().to", "torch.Tensor().view().to", "discriminator_vgg_arch.VGGFeatureExtractor.register_buffer", "discriminator_vgg_arch.VGGFeatureExtractor.register_buffer", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "list", "torchvision.models.vgg19.features.children", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "feature_layer", "=", "34", ",", "use_bn", "=", "False", ",", "use_input_norm", "=", "True", ",", "\n", "device", "=", "torch", ".", "device", "(", "'cuda'", ")", ")", ":", "\n", "        ", "super", "(", "VGGFeatureExtractor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_input_norm", "=", "use_input_norm", "\n", "if", "use_bn", ":", "\n", "            ", "model", "=", "torchvision", ".", "models", ".", "vgg19_bn", "(", "pretrained", "=", "True", ")", "\n", "", "else", ":", "\n", "            ", "model", "=", "torchvision", ".", "models", ".", "vgg19", "(", "pretrained", "=", "True", ")", "\n", "", "if", "self", ".", "use_input_norm", ":", "\n", "            ", "mean", "=", "torch", ".", "Tensor", "(", "[", "0.485", ",", "0.456", ",", "0.406", "]", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", ".", "to", "(", "device", ")", "\n", "# [0.485 - 1, 0.456 - 1, 0.406 - 1] if input in range [-1, 1]", "\n", "std", "=", "torch", ".", "Tensor", "(", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ".", "view", "(", "1", ",", "3", ",", "1", ",", "1", ")", ".", "to", "(", "device", ")", "\n", "# [0.229 * 2, 0.224 * 2, 0.225 * 2] if input in range [-1, 1]", "\n", "self", ".", "register_buffer", "(", "'mean'", ",", "mean", ")", "\n", "self", ".", "register_buffer", "(", "'std'", ",", "std", ")", "\n", "", "self", ".", "features", "=", "nn", ".", "Sequential", "(", "*", "list", "(", "model", ".", "features", ".", "children", "(", ")", ")", "[", ":", "(", "feature_layer", "+", "1", ")", "]", ")", "\n", "# No need to BP to variable", "\n", "for", "k", ",", "v", "in", "self", ".", "features", ".", "named_parameters", "(", ")", ":", "\n", "            ", "v", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.discriminator_vgg_arch.VGGFeatureExtractor.forward": [[83, 89], ["discriminator_vgg_arch.VGGFeatureExtractor.features"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "# Assume input range is [0, 1]", "\n", "        ", "if", "self", ".", "use_input_norm", ":", "\n", "            ", "x", "=", "(", "x", "-", "self", ".", "mean", ")", "/", "self", ".", "std", "\n", "", "output", "=", "self", ".", "features", "(", "x", ")", "\n", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResDNet.SRResDNet.__init__": [[8, 16], ["torch.Module.__init__", "modules.wmad_estimator.Wmad_estimator", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Hardtanh", "torch.Hardtanh", "torch.Hardtanh", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.linspace", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "scale", ")", ":", "\n", "        ", "super", "(", "SRResDNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "upscale_factor", "=", "scale", "\n", "self", ".", "noise_estimator", "=", "Wmad_estimator", "(", ")", "\n", "self", ".", "alpha", "=", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "np", ".", "linspace", "(", "np", ".", "log", "(", "2", ")", ",", "np", ".", "log", "(", "1", ")", ",", "1", ")", ")", ")", "\n", "self", ".", "bbproj", "=", "nn", ".", "Hardtanh", "(", "min_val", "=", "0.", ",", "max_val", "=", "255.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.SRResDNet.SRResDNet.forward": [[17, 40], ["torch.interpolate", "torch.interpolate", "torch.interpolate", "SRResDNet.SRResDNet.noise_estimator", "SRResDNet.SRResDNet.model", "SRResDNet.SRResDNet.bbproj"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "# reconstruction block", "\n", "        ", "input", "=", "F", ".", "interpolate", "(", "input", ",", "scale_factor", "=", "self", ".", "upscale_factor", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "\n", "#print('input:', input.shape, input.min(), input.max())", "\n", "\n", "# estimate sigma ", "\n", "sigma", "=", "self", ".", "noise_estimator", "(", "input", ")", "\n", "sigma", "*=", "255.", "\n", "#print('estimated sigma:', sigma.shape, sigma)", "\n", "\n", "# model  ", "\n", "output", "=", "self", ".", "model", "(", "input", ",", "sigma", ",", "self", ".", "alpha", ")", "\n", "#print('output:', output.shape, output.min(), output.max())", "\n", "\n", "# residual ouput", "\n", "output", "=", "input", "-", "output", "\n", "#print('residual output:', output.shape, output.min(), output.max())", "\n", "\n", "# clipping layer", "\n", "output", "=", "self", ".", "bbproj", "(", "output", ")", "\n", "#print('clipping output:', output.shape, output.min(), output.max())", "\n", "\n", "return", "output", "", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.Generator.__init__": [[6, 14], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.ModuleList", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.PReLU", "DSGAN.ResidualBlock", "range"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_res_blocks", "=", "8", ")", ":", "\n", "        ", "super", "(", "Generator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "block_input", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "PReLU", "(", ")", "\n", ")", "\n", "self", ".", "res_blocks", "=", "nn", ".", "ModuleList", "(", "[", "ResidualBlock", "(", "64", ")", "for", "_", "in", "range", "(", "n_res_blocks", ")", "]", ")", "\n", "self", ".", "block_output", "=", "nn", ".", "Conv2d", "(", "64", ",", "3", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.Generator.forward": [[15, 21], ["DSGAN.Generator.block_input", "DSGAN.Generator.block_output", "torch.sigmoid", "res_block"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "block", "=", "self", ".", "block_input", "(", "x", ")", "\n", "for", "res_block", "in", "self", ".", "res_blocks", ":", "\n", "            ", "block", "=", "res_block", "(", "block", ")", "\n", "", "block", "=", "self", ".", "block_output", "(", "block", ")", "\n", "return", "torch", ".", "sigmoid", "(", "block", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.Discriminator.__init__": [[24, 33], ["torch.nn.Module.__init__", "DSGAN.DiscriminatorBasic", "DSGAN.FilterHigh"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recursions", "=", "1", ",", "stride", "=", "1", ",", "kernel_size", "=", "5", ",", "gaussian", "=", "False", ",", "wgan", "=", "False", ",", "highpass", "=", "True", ")", ":", "\n", "        ", "super", "(", "Discriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "highpass", ":", "\n", "            ", "self", ".", "filter", "=", "FilterHigh", "(", "recursions", "=", "recursions", ",", "stride", "=", "stride", ",", "kernel_size", "=", "kernel_size", ",", "include_pad", "=", "False", ",", "\n", "gaussian", "=", "gaussian", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "filter", "=", "None", "\n", "", "self", ".", "net", "=", "DiscriminatorBasic", "(", "n_input_channels", "=", "3", ")", "\n", "self", ".", "wgan", "=", "wgan", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.Discriminator.forward": [[34, 43], ["DSGAN.Discriminator.net", "DSGAN.Discriminator.filter", "DSGAN.Discriminator.net().mean", "torch.sigmoid", "DSGAN.Discriminator.net", "DSGAN.Discriminator.filter"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", "=", "None", ")", ":", "\n", "        ", "if", "self", ".", "filter", "is", "not", "None", ":", "\n", "            ", "x", "=", "self", ".", "filter", "(", "x", ")", "\n", "", "x", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "y", "is", "not", "None", ":", "\n", "            ", "x", "-=", "self", ".", "net", "(", "self", ".", "filter", "(", "y", ")", ")", ".", "mean", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "", "if", "not", "self", ".", "wgan", ":", "\n", "            ", "x", "=", "torch", ".", "sigmoid", "(", "x", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.DiscriminatorBasic.__init__": [[46, 61], ["torch.nn.Module.__init__", "torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.LeakyReLU", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_input_channels", "=", "3", ")", ":", "\n", "        ", "super", "(", "DiscriminatorBasic", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "n_input_channels", ",", "64", ",", "kernel_size", "=", "5", ",", "padding", "=", "2", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ")", ",", "\n", "\n", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "kernel_size", "=", "5", ",", "padding", "=", "2", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "128", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ")", ",", "\n", "\n", "nn", ".", "Conv2d", "(", "128", ",", "256", ",", "kernel_size", "=", "5", ",", "padding", "=", "2", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "256", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ")", ",", "\n", "\n", "nn", ".", "Conv2d", "(", "256", ",", "1", ",", "kernel_size", "=", "1", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.DiscriminatorBasic.forward": [[63, 65], ["DSGAN.DiscriminatorBasic.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "net", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.ResidualBlock.__init__": [[68, 73], ["torch.nn.Module.__init__", "torch.nn.Conv2d", "torch.nn.PReLU", "torch.nn.Conv2d"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "channels", ")", ":", "\n", "        ", "super", "(", "ResidualBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "channels", ",", "channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "self", ".", "prelu", "=", "nn", ".", "PReLU", "(", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "channels", ",", "channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.ResidualBlock.forward": [[74, 79], ["DSGAN.ResidualBlock.conv1", "DSGAN.ResidualBlock.prelu", "DSGAN.ResidualBlock.conv2"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "self", ".", "conv1", "(", "x", ")", "\n", "residual", "=", "self", ".", "prelu", "(", "residual", ")", "\n", "residual", "=", "self", ".", "conv2", "(", "residual", ")", "\n", "return", "x", "+", "residual", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.GaussianFilter.__init__": [[82, 107], ["torch.nn.Module.__init__", "torch.arange", "torch.arange.repeat().view", "torch.arange.repeat().view.t", "torch.stack().float", "torch.exp", "gaussian_kernel.repeat.repeat.view", "gaussian_kernel.repeat.repeat.repeat", "torch.nn.Conv2d", "torch.sum", "torch.arange.repeat", "torch.stack", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "4", ")", ":", "\n", "        ", "super", "(", "GaussianFilter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# initialize guassian kernel", "\n", "mean", "=", "(", "kernel_size", "-", "1", ")", "/", "2.0", "\n", "variance", "=", "(", "kernel_size", "/", "6.0", ")", "**", "2.0", "\n", "# Create a x, y coordinate grid of shape (kernel_size, kernel_size, 2)", "\n", "x_coord", "=", "torch", ".", "arange", "(", "kernel_size", ")", "\n", "x_grid", "=", "x_coord", ".", "repeat", "(", "kernel_size", ")", ".", "view", "(", "kernel_size", ",", "kernel_size", ")", "\n", "y_grid", "=", "x_grid", ".", "t", "(", ")", "\n", "xy_grid", "=", "torch", ".", "stack", "(", "[", "x_grid", ",", "y_grid", "]", ",", "dim", "=", "-", "1", ")", ".", "float", "(", ")", "\n", "\n", "# Calculate the 2-dimensional gaussian kernel", "\n", "gaussian_kernel", "=", "torch", ".", "exp", "(", "-", "torch", ".", "sum", "(", "(", "xy_grid", "-", "mean", ")", "**", "2.", ",", "dim", "=", "-", "1", ")", "/", "(", "2", "*", "variance", ")", ")", "\n", "\n", "# Make sure sum of values in gaussian kernel equals 1.", "\n", "gaussian_kernel", "=", "gaussian_kernel", "/", "torch", ".", "sum", "(", "gaussian_kernel", ")", "\n", "\n", "# Reshape to 2d depthwise convolutional weight", "\n", "gaussian_kernel", "=", "gaussian_kernel", ".", "view", "(", "1", ",", "1", ",", "kernel_size", ",", "kernel_size", ")", "\n", "gaussian_kernel", "=", "gaussian_kernel", ".", "repeat", "(", "3", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "# create gaussian filter as convolutional layer", "\n", "self", ".", "gaussian_filter", "=", "nn", ".", "Conv2d", "(", "3", ",", "3", ",", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "groups", "=", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "gaussian_filter", ".", "weight", ".", "data", "=", "gaussian_kernel", "\n", "self", ".", "gaussian_filter", ".", "weight", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.GaussianFilter.forward": [[108, 110], ["DSGAN.GaussianFilter.gaussian_filter"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gaussian_filter"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "gaussian_filter", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.FilterLow.__init__": [[113, 124], ["torch.nn.Module.__init__", "int", "DSGAN.GaussianFilter", "torch.nn.AvgPool2d"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recursions", "=", "1", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "True", ",", "include_pad", "=", "True", ",", "gaussian", "=", "False", ")", ":", "\n", "        ", "super", "(", "FilterLow", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "padding", ":", "\n", "            ", "pad", "=", "int", "(", "(", "kernel_size", "-", "1", ")", "/", "2", ")", "\n", "", "else", ":", "\n", "            ", "pad", "=", "0", "\n", "", "if", "gaussian", ":", "\n", "            ", "self", ".", "filter", "=", "GaussianFilter", "(", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "pad", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "filter", "=", "nn", ".", "AvgPool2d", "(", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "pad", ",", "count_include_pad", "=", "include_pad", ")", "\n", "", "self", ".", "recursions", "=", "recursions", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.FilterLow.forward": [[125, 129], ["range", "DSGAN.FilterLow.filter"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "recursions", ")", ":", "\n", "            ", "img", "=", "self", ".", "filter", "(", "img", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.FilterHigh.__init__": [[132, 138], ["torch.nn.Module.__init__", "DSGAN.FilterLow"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recursions", "=", "1", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "include_pad", "=", "True", ",", "normalize", "=", "True", ",", "gaussian", "=", "False", ")", ":", "\n", "        ", "super", "(", "FilterHigh", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "filter_low", "=", "FilterLow", "(", "recursions", "=", "1", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "include_pad", "=", "include_pad", ",", "\n", "gaussian", "=", "gaussian", ")", "\n", "self", ".", "recursions", "=", "recursions", "\n", "self", ".", "normalize", "=", "normalize", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.DSGAN.FilterHigh.forward": [[139, 148], ["range", "DSGAN.FilterHigh.filter_low", "DSGAN.FilterHigh.filter_low"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "self", ".", "recursions", ">", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "recursions", "-", "1", ")", ":", "\n", "                ", "img", "=", "self", ".", "filter_low", "(", "img", ")", "\n", "", "", "img", "=", "img", "-", "self", ".", "filter_low", "(", "img", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "            ", "return", "0.5", "+", "img", "*", "0.5", "\n", "", "else", ":", "\n", "            ", "return", "img", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.BasicBlock.__init__": [[14, 25], ["torch.Module.__init__", "ResDNet.conv3x3", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.PReLU", "torch.PReLU", "ResDNet.conv3x3", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.conv3x3", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.conv3x3"], ["    ", "def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "weightnorm", "=", "None", ",", "shortcut", "=", "True", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "shortcut", "=", "shortcut", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "\n", "self", ".", "relu1", "=", "nn", ".", "PReLU", "(", "num_parameters", "=", "planes", ",", "init", "=", "0.1", ")", "\n", "self", ".", "relu2", "=", "nn", ".", "PReLU", "(", "num_parameters", "=", "planes", ",", "init", "=", "0.1", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "if", "weightnorm", ":", "\n", "            ", "self", ".", "conv1", "=", "weight_norm", "(", "self", ".", "conv1", ")", "\n", "self", ".", "conv2", "=", "weight_norm", "(", "self", ".", "conv2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.BasicBlock.forward": [[27, 39], ["ResDNet.BasicBlock.relu1", "torch.pad", "torch.pad", "torch.pad", "ResDNet.BasicBlock.conv1", "ResDNet.BasicBlock.relu2", "torch.pad", "torch.pad", "torch.pad", "ResDNet.BasicBlock.conv2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "relu1", "(", "x", ")", "\n", "out", "=", "F", ".", "pad", "(", "out", ",", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "'reflect'", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "out", "[", ":", ",", ":", ",", ":", "x", ".", "shape", "[", "2", "]", ",", ":", "x", ".", "shape", "[", "3", "]", "]", "\n", "out", "=", "self", ".", "relu2", "(", "out", ")", "\n", "out", "=", "F", ".", "pad", "(", "out", ",", "(", "1", ",", "1", ",", "1", ",", "1", ")", ",", "'reflect'", ")", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "out", "[", ":", ",", ":", ",", ":", "x", ".", "shape", "[", "2", "]", ",", ":", "x", ".", "shape", "[", "3", "]", "]", "\n", "if", "self", ".", "shortcut", ":", "\n", "            ", "out", "=", "x", "+", "out", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.__init__": [[43, 74], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "ResDNet.ResDNet._make_layer", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "modules.l2proj.L2Proj", "ResDNet.ResDNet.modules", "ResDNet.ResDNet.zeromean", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "torch.nn.utils.weight_norm", "isinstance", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "numpy.sqrt", "numpy.random.standard_normal", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet._make_layer", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.zeromean"], ["    ", "def", "__init__", "(", "self", ",", "depth", ",", "color", "=", "True", ",", "weightnorm", "=", "True", ")", ":", "\n", "        ", "self", ".", "inplanes", "=", "64", "\n", "super", "(", "ResDNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "color", ":", "\n", "            ", "in_channels", "=", "3", "\n", "", "else", ":", "\n", "            ", "in_channels", "=", "1", "\n", "\n", "", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "64", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "\n", "bias", "=", "True", ")", "\n", "if", "weightnorm", ":", "\n", "            ", "self", ".", "conv1", "=", "weight_norm", "(", "self", ".", "conv1", ")", "\n", "\n", "# inntermediate layer has D-2 depth", "\n", "", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "BasicBlock", ",", "64", ",", "depth", ")", "\n", "self", ".", "conv_out", "=", "nn", ".", "ConvTranspose2d", "(", "64", ",", "in_channels", ",", "kernel_size", "=", "5", ",", "stride", "=", "1", ",", "padding", "=", "2", ",", "\n", "bias", "=", "True", ")", "\n", "if", "weightnorm", ":", "\n", "            ", "self", ".", "conv_out", "=", "weight_norm", "(", "self", ".", "conv_out", ")", "\n", "\n", "", "self", ".", "l2proj", "=", "l2proj", ".", "L2Proj", "(", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "weights", "=", "np", ".", "sqrt", "(", "2", "/", "(", "9.", "*", "64", ")", ")", "*", "np", ".", "random", ".", "standard_normal", "(", "m", ".", "weight", ".", "data", ".", "shape", ")", "\n", "#weights = np.random.normal(size=m.weight.data.shape,", "\n", "#                           scale=np.sqrt(1. / m.weight.data.shape[1]))", "\n", "m", ".", "weight", ".", "data", "=", "torch", ".", "Tensor", "(", "weights", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "", "self", ".", "zeromean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet._make_layer": [[75, 82], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "weightnorm", "=", "True", ",", "shortcut", "=", "False", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "weightnorm", "=", "True", ",", "shortcut", "=", "True", ")", ")", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.zeromean": [[83, 89], ["ResDNet.ResDNet.modules", "isinstance", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["None"], ["", "def", "zeromean", "(", "self", ")", ":", "\n", "# Function zeromean subtracts the mean E(f) from filters f", "\n", "# in order to create zero mean filters", "\n", "        ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", "=", "m", ".", "weight", ".", "data", "-", "torch", ".", "mean", "(", "m", ".", "weight", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.forward": [[90, 98], ["ResDNet.ResDNet.zeromean", "torch.pad", "torch.pad", "torch.pad", "ResDNet.ResDNet.conv1", "ResDNet.ResDNet.layer1", "ResDNet.ResDNet.conv_out", "ResDNet.ResDNet.l2proj"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.ResDNet.zeromean"], ["", "", "", "def", "forward", "(", "self", ",", "x", ",", "stdn", ",", "alpha", ")", ":", "\n", "        ", "self", ".", "zeromean", "(", ")", "\n", "out", "=", "F", ".", "pad", "(", "x", ",", "(", "2", ",", "2", ",", "2", ",", "2", ")", ",", "'reflect'", ")", "\n", "out", "=", "self", ".", "conv1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "conv_out", "(", "out", ")", "\n", "out", "=", "self", ".", "l2proj", "(", "out", ",", "stdn", ",", "alpha", ")", "\n", "return", "out", "", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.models.ResDNet.conv3x3": [[8, 12], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"3x3 convolution with padding\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "0", ",", "bias", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.training_codes.main_sr_color.main": [[36, 1050], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "torch.manual_seed", "torch.manual_seed", "torch.cuda.manual_seed", "torch.cuda.manual_seed", "utils.utils_logger.logger_info", "logging.getLogger", "torch.save", "torch.save", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "data_loader.LRHR_dataset.LRHRDataset", "torch.utils.data.DataLoader", "int", "logging.getLogger.info", "logging.getLogger.info", "data_loader.LRHR_dataset.LRHRDataset", "torch.utils.data.DataLoader", "logging.getLogger.info", "logging.getLogger.info", "logging.getLogger.info", "models.ResDNet.ResDNet", "models.SRResDNet.SRResDNet", "models.Discriminator_VGG_128", "modules.filters.FilterLow", "modules.filters.FilterHigh", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "modules.MultiStepLR_Restart", "modules.MultiStepLR_Restart", "modules.loss.GANLoss", "modules.PerceptualLoss", "modules.PerceptualLoss", "main_sr_color.main.print_network"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_info", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.print_network"], ["def", "main", "(", ")", ":", "\n", "################################", "\n", "##  Network parameters", "\n", "################################", "\n", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Image Super-resolution with SRResCGAN'", ")", "\n", "# SRResdnet Parameters", "\n", "parser", ".", "add_argument", "(", "\"--in_nc\"", ",", "type", "=", "int", ",", "default", "=", "3", ",", "help", "=", "'no. of in_chs for D'", ")", "\n", "parser", ".", "add_argument", "(", "\"--nf\"", ",", "type", "=", "int", ",", "default", "=", "64", ",", "help", "=", "'no. of feat. maps for D'", ")", "\n", "parser", ".", "add_argument", "(", "\"--resdnet_depth\"", ",", "type", "=", "int", ",", "default", "=", "5", ",", "help", "=", "'no. of resblocks for resdnet'", ")", "\n", "# Training Parameters", "\n", "parser", ".", "add_argument", "(", "'--train_stdn'", ",", "type", "=", "list", ",", "default", "=", "[", "0.0", "]", ",", "help", "=", "\" Number of noise levels (standard deviation) for which the network will be trained.\"", ")", "# [1.0,2.0,2.55,3.0,4.,5.0,5.10,6.0,7.,7.65,8.0,9.0,10.,11.0,12.0,12.75,13.0,14.0,15.0]", "\n", "parser", ".", "add_argument", "(", "'--test_stdn'", ",", "type", "=", "list", ",", "default", "=", "[", "0.0", "]", ",", "help", "=", "\" Number of noise levels (standard deviation) for testing.\"", ")", "# [2.55, 5.10, 7.65, 12.75] ", "\n", "parser", ".", "add_argument", "(", "'--upscale_factor'", ",", "type", "=", "int", ",", "default", "=", "4", ",", "help", "=", "'scaling factor.'", ")", "# [2, 3, 4]", "\n", "parser", ".", "add_argument", "(", "'--trainBatchSize'", ",", "type", "=", "int", ",", "default", "=", "16", ",", "help", "=", "'training batch size.'", ")", "\n", "parser", ".", "add_argument", "(", "'--testBatchSize'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'testing batch size.'", ")", "\n", "parser", ".", "add_argument", "(", "'--niter'", ",", "type", "=", "int", ",", "default", "=", "51000", ",", "help", "=", "'number of iters to train for.'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_bn'", ",", "type", "=", "bool", ",", "default", "=", "False", ",", "help", "=", "'use Batch-Norm?'", ")", "\n", "parser", ".", "add_argument", "(", "'--cuda'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'use cuda?'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "type", "=", "int", ",", "default", "=", "123", ",", "help", "=", "'random seed to use. Default=123.'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_filters'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'use Filters: LP, HP?'", ")", "\n", "parser", ".", "add_argument", "(", "'--resume'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'resume training?'", ")", "\n", "parser", ".", "add_argument", "(", "'--resume_start_epoch'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'Where to resume training?.'", ")", "\n", "parser", ".", "add_argument", "(", "'--pretrainedModelPath'", ",", "type", "=", "str", ",", "default", "=", "'pretrained_nets/SRResDNet/G_perceptual.pth'", ",", "help", "=", "'location of pretrained model.'", ")", "\n", "parser", ".", "add_argument", "(", "'--pretrain'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'Initialize the model paramaters from a pretrained net.'", ")", "\n", "# DataSet Parameters", "\n", "parser", ".", "add_argument", "(", "'--imdbTrainPath'", ",", "type", "=", "str", ",", "default", "=", "'datasets/'", ",", "help", "=", "'location of the training dataset.'", ")", "\n", "parser", ".", "add_argument", "(", "'--imdbTestPath'", ",", "type", "=", "str", ",", "default", "=", "'datasets/'", ",", "help", "=", "'location of the testing dataset.'", ")", "\n", "parser", ".", "add_argument", "(", "'--patch_size'", ",", "type", "=", "int", ",", "default", "=", "32", ",", "help", "=", "'patch size for training. [x2-->64,x3-->42,x4-->32]'", ")", "\n", "parser", ".", "add_argument", "(", "'--rgb_range'", ",", "type", "=", "int", ",", "default", "=", "255", ",", "help", "=", "'data range of the training images.'", ")", "\n", "parser", ".", "add_argument", "(", "'--is_train'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "' True for training phase'", ")", "\n", "parser", ".", "add_argument", "(", "'--is_mixup'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "' mixup_data augmentation for training data'", ")", "\n", "parser", ".", "add_argument", "(", "'--use_chop'", ",", "type", "=", "bool", ",", "default", "=", "False", ",", "help", "=", "' chop for less memory consumption during test.'", ")", "\n", "parser", ".", "add_argument", "(", "'--alpha'", ",", "type", "=", "float", ",", "default", "=", "1.2", ",", "help", "=", "'alpha for data mixup (uniform=1., ERM=0.)'", ")", "\n", "parser", ".", "add_argument", "(", "'--numWorkers'", ",", "type", "=", "int", ",", "default", "=", "4", ",", "help", "=", "'number of threads for data loader to use.'", ")", "\n", "# Optimizer Parameters", "\n", "parser", ".", "add_argument", "(", "'--lr_G'", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "'learning rate for G.'", ")", "\n", "parser", ".", "add_argument", "(", "'--beta1_G'", ",", "type", "=", "float", ",", "default", "=", "0.9", ",", "help", "=", "'learning rate. Default=0.9.'", ")", "\n", "parser", ".", "add_argument", "(", "'--beta2_G'", ",", "type", "=", "float", ",", "default", "=", "0.999", ",", "help", "=", "'learning rate. Default=0.999.'", ")", "\n", "parser", ".", "add_argument", "(", "'--eps_G'", ",", "type", "=", "float", ",", "default", "=", "1e-8", ",", "help", "=", "'learning rate. Default=1e-8.'", ")", "\n", "parser", ".", "add_argument", "(", "'--weightdecay_G'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "help", "=", "'learning rate. Default=0.'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_D'", ",", "type", "=", "float", ",", "default", "=", "1e-4", ",", "help", "=", "'learning rate for D.'", ")", "\n", "parser", ".", "add_argument", "(", "'--beta1_D'", ",", "type", "=", "float", ",", "default", "=", "0.9", ",", "help", "=", "'learning rate. Default=0.9.'", ")", "\n", "parser", ".", "add_argument", "(", "'--beta2_D'", ",", "type", "=", "float", ",", "default", "=", "0.999", ",", "help", "=", "'learning rate. Default=0.999.'", ")", "\n", "parser", ".", "add_argument", "(", "'--eps_D'", ",", "type", "=", "float", ",", "default", "=", "1e-8", ",", "help", "=", "'learning rate. Default=1e-8.'", ")", "\n", "parser", ".", "add_argument", "(", "'--weightdecay_D'", ",", "type", "=", "float", ",", "default", "=", "0", ",", "help", "=", "'learning rate. Default=0.'", ")", "\n", "parser", ".", "add_argument", "(", "'--amsgrad'", ",", "type", "=", "bool", ",", "default", "=", "False", ",", "help", "=", "'Use the fix for Adam?'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_milestones'", ",", "type", "=", "list", ",", "default", "=", "[", "5000", ",", "10000", ",", "20000", ",", "30000", "]", ",", "help", "=", "\"Scheduler's learning rate milestones.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_gamma'", ",", "type", "=", "float", ",", "default", "=", "0.5", ",", "help", "=", "\"multiplicative factor of learning rate decay.\"", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_restart'", ",", "default", "=", "None", ",", "help", "=", "'lr restart.'", ")", "\n", "parser", ".", "add_argument", "(", "'--lr_restart_weights'", ",", "default", "=", "None", ",", "help", "=", "'lr restart weights.'", ")", "\n", "parser", ".", "add_argument", "(", "'--warmup_iter'", ",", "type", "=", "int", ",", "default", "=", "-", "1", ",", "help", "=", "'warmup iter.'", ")", "\n", "parser", ".", "add_argument", "(", "'--D_update_ratio'", ",", "type", "=", "int", ",", "default", "=", "1", ",", "help", "=", "'D_update_ratio.'", ")", "\n", "parser", ".", "add_argument", "(", "'--D_init_iters'", ",", "type", "=", "int", ",", "default", "=", "0", ",", "help", "=", "'D_init_iters.'", ")", "\n", "# losses Parameters", "\n", "parser", ".", "add_argument", "(", "'--pixel_criterion'", ",", "type", "=", "str", ",", "default", "=", "'l1'", ",", "help", "=", "'pixel-wise criteria.'", ")", "\n", "parser", ".", "add_argument", "(", "'--feature_criterion'", ",", "type", "=", "str", ",", "default", "=", "'l1'", ",", "help", "=", "'feature criteria.'", ")", "\n", "parser", ".", "add_argument", "(", "'--tv_criterion'", ",", "type", "=", "str", ",", "default", "=", "'l1'", ",", "help", "=", "'TV criteria.'", ")", "\n", "parser", ".", "add_argument", "(", "'--gan_type'", ",", "type", "=", "str", ",", "default", "=", "'ragan'", ",", "help", "=", "'gan type. default: gan | ragan'", ")", "\n", "parser", ".", "add_argument", "(", "'--pixel_weight'", ",", "type", "=", "float", ",", "default", "=", "10.", ",", "help", "=", "'weight for pixel-wise criteria. default: 1e-2'", ")", "\n", "parser", ".", "add_argument", "(", "'--feature_weight'", ",", "type", "=", "float", ",", "default", "=", "1.", ",", "help", "=", "'weight for feature criteria.'", ")", "\n", "parser", ".", "add_argument", "(", "'--tv_weight'", ",", "type", "=", "float", ",", "default", "=", "1.", ",", "help", "=", "'weight for TV criteria.'", ")", "\n", "parser", ".", "add_argument", "(", "'--gan_weight'", ",", "type", "=", "float", ",", "default", "=", "1.", ",", "help", "=", "'weight for gan | ragan criteria. default: 5e-3'", ")", "\n", "# Results Output Parameters", "\n", "parser", ".", "add_argument", "(", "'--saveTrainedModelsPath'", ",", "type", "=", "str", ",", "default", "=", "'trained_nets'", ",", "help", "=", "'location of trained models.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path_training_states'", ",", "type", "=", "str", ",", "default", "=", "'/training_states/'", ",", "help", "=", "'location of training states.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path_netG'", ",", "type", "=", "str", ",", "default", "=", "'/netG/'", ",", "help", "=", "'location of trained netG.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path_netD'", ",", "type", "=", "str", ",", "default", "=", "'/netD/'", ",", "help", "=", "'location of trained netD.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path_best_psnr'", ",", "type", "=", "str", ",", "default", "=", "'/best_psnr/'", ",", "help", "=", "'location of trained model best PSNR.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_path_best_lpips'", ",", "type", "=", "str", ",", "default", "=", "'/best_lpips/'", ",", "help", "=", "'location of trained model best LPIPS.'", ")", "\n", "parser", ".", "add_argument", "(", "'--saveImgsPath'", ",", "type", "=", "str", ",", "default", "=", "'results'", ",", "help", "=", "'location of saved images on training\\validation.'", ")", "\n", "parser", ".", "add_argument", "(", "'--saveLogsPath'", ",", "type", "=", "str", ",", "default", "=", "'logs'", ",", "help", "=", "'location of training logs.'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_checkpoint_freq'", ",", "type", "=", "float", ",", "default", "=", "20", ",", "help", "=", "'Every how many iters we save the model parameters, default:5e3.'", ")", "\n", "parser", ".", "add_argument", "(", "'--saveBest'", ",", "type", "=", "bool", ",", "default", "=", "True", ",", "help", "=", "'save the best model parameters?'", ")", "\n", "\n", "opt", "=", "parser", ".", "parse_args", "(", ")", "\n", "torch", ".", "manual_seed", "(", "opt", ".", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "opt", ".", "seed", ")", "\n", "# shave boader to calculate PSNR and SSIM", "\n", "#border = opt.upscale_factor", "\n", "border", "=", "0", "\n", "\n", "# store trained models path", "\n", "models_save_path", "=", "opt", ".", "saveTrainedModelsPath", "+", "'_x'", "+", "str", "(", "opt", ".", "upscale_factor", ")", "+", "'/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "models_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "models_save_path", ")", "\n", "\n", "# store training states path", "\n", "", "training_states_save_path", "=", "models_save_path", "+", "opt", ".", "save_path_training_states", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "training_states_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "training_states_save_path", ")", "\n", "\n", "# store trained netG path", "\n", "", "netG_save_path", "=", "models_save_path", "+", "opt", ".", "save_path_netG", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "netG_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "netG_save_path", ")", "\n", "\n", "# store trained netD path", "\n", "", "netD_save_path", "=", "models_save_path", "+", "opt", ".", "save_path_netD", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "netD_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "netD_save_path", ")", "\n", "\n", "# store trained model best PSNR path", "\n", "", "best_psnr_save_path", "=", "models_save_path", "+", "opt", ".", "save_path_best_psnr", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "best_psnr_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "best_psnr_save_path", ")", "\n", "\n", "# store trained model best LPIPS path", "\n", "", "best_lpips_save_path", "=", "models_save_path", "+", "opt", ".", "save_path_best_lpips", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "best_lpips_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "best_lpips_save_path", ")", "\n", "\n", "# save train images path", "\n", "", "save_train_imgs_path", "=", "opt", ".", "saveImgsPath", "+", "'_x'", "+", "str", "(", "opt", ".", "upscale_factor", ")", "+", "'/train_imgs/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "save_train_imgs_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_train_imgs_path", ")", "\n", "\n", "# save test images path", "\n", "", "save_test_imgs_path", "=", "opt", ".", "saveImgsPath", "+", "'_x'", "+", "str", "(", "opt", ".", "upscale_factor", ")", "+", "'/test_imgs/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "save_test_imgs_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "save_test_imgs_path", ")", "\n", "\n", "# logs path", "\n", "", "logs_save_path", "=", "opt", ".", "saveLogsPath", "+", "'_x'", "+", "str", "(", "opt", ".", "upscale_factor", ")", "+", "'/'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "logs_save_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "logs_save_path", ")", "\n", "\n", "# setup logging ", "\n", "", "utils_logger", ".", "logger_info", "(", "'train_SRResCGAN'", ",", "log_path", "=", "os", ".", "path", ".", "join", "(", "logs_save_path", ",", "'train_SRResCGAN.log'", ")", ")", "\n", "logger", "=", "logging", ".", "getLogger", "(", "'train_SRResCGAN'", ")", "\n", "\n", "# save the training arguments", "\n", "torch", ".", "save", "(", "opt", ",", "os", ".", "path", ".", "join", "(", "logs_save_path", ",", "\"args.pth\"", ")", ")", "\n", "\n", "logger", ".", "info", "(", "'===================== Selected training parameters ====================='", ")", "\n", "logger", ".", "info", "(", "'{:s}.'", ".", "format", "(", "str", "(", "opt", ")", ")", ")", "\n", "\n", "################################", "\n", "## datasets preparation ", "\n", "################################", "\n", "#print('===> Loading dataset')", "\n", "logger", ".", "info", "(", "'===================== Loading dataset ====================='", ")", "\n", "# training dataset", "\n", "train_dataset", "=", "LRHRDataset", "(", "dataroot", "=", "opt", ".", "imdbTrainPath", ",", "\n", "is_train", "=", "opt", ".", "is_train", ",", "\n", "scale", "=", "opt", ".", "upscale_factor", ",", "\n", "patch_size", "=", "opt", ".", "patch_size", ",", "\n", "rgb_range", "=", "opt", ".", "rgb_range", ",", "\n", "noise_std", "=", "opt", ".", "train_stdn", ")", "\n", "\n", "trainset_loader", "=", "DataLoader", "(", "train_dataset", ",", "\n", "shuffle", "=", "True", ",", "\n", "batch_size", "=", "opt", ".", "trainBatchSize", ",", "\n", "pin_memory", "=", "True", ",", "\n", "num_workers", "=", "opt", ".", "numWorkers", ",", "\n", "drop_last", "=", "True", "\n", ")", "\n", "train_size", "=", "int", "(", "math", ".", "ceil", "(", "len", "(", "train_dataset", ")", "/", "opt", ".", "trainBatchSize", ")", ")", "\n", "logger", ".", "info", "(", "'training dataset:{:6d}'", ".", "format", "(", "len", "(", "train_dataset", ")", ")", ")", "\n", "logger", ".", "info", "(", "'training loaders:{:6d}'", ".", "format", "(", "len", "(", "trainset_loader", ")", ")", ")", "\n", "\n", "# testing dataset", "\n", "test_dataset", "=", "LRHRDataset", "(", "dataroot", "=", "opt", ".", "imdbTestPath", ",", "\n", "is_train", "=", "False", ",", "\n", "scale", "=", "opt", ".", "upscale_factor", ",", "\n", "patch_size", "=", "opt", ".", "patch_size", ",", "\n", "rgb_range", "=", "opt", ".", "rgb_range", ",", "\n", "noise_std", "=", "opt", ".", "test_stdn", ")", "\n", "\n", "testset_loader", "=", "DataLoader", "(", "test_dataset", ",", "\n", "shuffle", "=", "False", ",", "\n", "batch_size", "=", "opt", ".", "testBatchSize", ",", "\n", "pin_memory", "=", "True", ",", "\n", "num_workers", "=", "1", "\n", ")", "\n", "\n", "logger", ".", "info", "(", "'testing dataset:{:6d}'", ".", "format", "(", "len", "(", "test_dataset", ")", ")", ")", "\n", "logger", ".", "info", "(", "'testing loaders:{:6d}'", ".", "format", "(", "len", "(", "testset_loader", ")", ")", ")", "\n", "\n", "################################", "\n", "## Functions", "\n", "################################", "\n", "def", "weights_init_normal", "(", "m", ",", "std", "=", "0.02", ")", ":", "\n", "        ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Conv2d", ",", "nn", ".", "ConvTranspose2d", ")", ")", ":", "\n", "            ", "print", "(", "'initializing [%s] ...'", "%", "classname", ")", "\n", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "0.0", ",", "std", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "Linear", ")", ")", ":", "\n", "            ", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "0.0", ",", "std", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "BatchNorm2d", ")", ")", ":", "\n", "            ", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "1.0", ",", "std", ")", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n", "", "", "def", "weights_init_kaiming", "(", "m", ",", "scale", "=", "1", ")", ":", "\n", "        ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Conv2d", ",", "nn", ".", "ConvTranspose2d", ")", ")", ":", "\n", "            ", "print", "(", "'initializing [%s] ...'", "%", "classname", ")", "\n", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "0", ",", "mode", "=", "'fan_in'", ")", "\n", "m", ".", "weight", ".", "data", "*=", "scale", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "Linear", ")", ")", ":", "\n", "            ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "0", ",", "mode", "=", "'fan_in'", ")", "\n", "m", ".", "weight", ".", "data", "*=", "scale", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "BatchNorm2d", ")", ")", ":", "\n", "            ", "init", ".", "constant_", "(", "m", ".", "weight", ".", "data", ",", "1.0", ")", "\n", "m", ".", "weight", ".", "data", "*=", "scale", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n", "", "", "def", "weights_init_orthogonal", "(", "m", ")", ":", "\n", "        ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Conv2d", ",", "nn", ".", "ConvTranspose2d", ")", ")", ":", "\n", "            ", "print", "(", "'initializing [%s] ...'", "%", "classname", ")", "\n", "init", ".", "orthogonal_", "(", "m", ".", "weight", ".", "data", ",", "gain", "=", "1", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "Linear", ")", ")", ":", "\n", "            ", "init", ".", "orthogonal_", "(", "m", ".", "weight", ".", "data", ",", "gain", "=", "1", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", "elif", "isinstance", "(", "m", ",", "(", "nn", ".", "BatchNorm2d", ")", ")", ":", "\n", "            ", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "1.0", ",", "0.02", ")", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n", "", "", "def", "zeromean", "(", "m", ")", ":", "\n", "# Function zeromean subtracts the mean E(f) from filters f", "\n", "# in order to create zero mean filters", "\n", "        ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Conv2d", ",", "nn", ".", "ConvTranspose2d", ")", ")", ":", "\n", "            ", "print", "(", "'zeromeans initializing [%s] ...'", "%", "classname", ")", "\n", "m", ".", "weight", ".", "data", "=", "m", ".", "weight", ".", "data", "-", "torch", ".", "mean", "(", "m", ".", "weight", ".", "data", ")", "\n", "#print('init zeromean weights:', m.weight.data.shape,  m.weight.data.min(),  m.weight.data.max())", "\n", "\n", "", "", "def", "init_weights", "(", "net", ",", "init_type", "=", "'kaiming'", ",", "zeromeans", "=", "False", ",", "scale", "=", "1", ",", "std", "=", "0.02", ")", ":", "\n", "# scale for 'kaiming', std for 'normal'.", "\n", "        ", "print", "(", "'initialization method [%s]'", "%", "init_type", ")", "\n", "if", "init_type", "==", "'normal'", ":", "\n", "            ", "weights_init_normal_", "=", "functools", ".", "partial", "(", "weights_init_normal", ",", "std", "=", "std", ")", "\n", "net", ".", "apply", "(", "weights_init_normal_", ")", "\n", "", "elif", "init_type", "==", "'kaiming'", ":", "\n", "            ", "weights_init_kaiming_", "=", "functools", ".", "partial", "(", "weights_init_kaiming", ",", "scale", "=", "scale", ")", "\n", "net", ".", "apply", "(", "weights_init_kaiming_", ")", "\n", "", "elif", "init_type", "==", "'orthogonal'", ":", "\n", "            ", "net", ".", "apply", "(", "weights_init_orthogonal", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'initialization method [%s] is not implemented'", "%", "init_type", ")", "\n", "\n", "", "if", "zeromeans", ":", "\n", "            ", "weights_zeromean", "=", "functools", ".", "partial", "(", "zeromean", ")", "\n", "net", ".", "apply", "(", "weights_zeromean", ")", "\n", "\n", "", "", "def", "crop_forward", "(", "model", ",", "x", ",", "stdn", ",", "sf", ",", "shave", "=", "10", ",", "min_size", "=", "100000", ",", "bic", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n\u00a0 \u00a0 \u00a0 \u00a0 chop for less memory consumption during test\n\u00a0 \u00a0 \u00a0 \u00a0 \"\"\"", "\n", "n_GPUs", "=", "1", "\n", "scale", "=", "sf", "\n", "b", ",", "c", ",", "h", ",", "w", "=", "x", ".", "size", "(", ")", "\n", "h_half", ",", "w_half", "=", "h", "//", "2", ",", "w", "//", "2", "\n", "h_size", ",", "w_size", "=", "h_half", "+", "shave", ",", "w_half", "+", "shave", "\n", "lr_list", "=", "[", "\n", "x", "[", ":", ",", ":", ",", "0", ":", "h_size", ",", "0", ":", "w_size", "]", ",", "\n", "x", "[", ":", ",", ":", ",", "0", ":", "h_size", ",", "(", "w", "-", "w_size", ")", ":", "w", "]", ",", "\n", "x", "[", ":", ",", ":", ",", "(", "h", "-", "h_size", ")", ":", "h", ",", "0", ":", "w_size", "]", ",", "\n", "x", "[", ":", ",", ":", ",", "(", "h", "-", "h_size", ")", ":", "h", ",", "(", "w", "-", "w_size", ")", ":", "w", "]", "]", "\n", "\n", "if", "bic", "is", "not", "None", ":", "\n", "            ", "bic_h_size", "=", "h_size", "*", "scale", "\n", "bic_w_size", "=", "w_size", "*", "scale", "\n", "bic_h", "=", "h", "*", "scale", "\n", "bic_w", "=", "w", "*", "scale", "\n", "\n", "bic_list", "=", "[", "\n", "bic", "[", ":", ",", ":", ",", "0", ":", "bic_h_size", ",", "0", ":", "bic_w_size", "]", ",", "\n", "bic", "[", ":", ",", ":", ",", "0", ":", "bic_h_size", ",", "(", "bic_w", "-", "bic_w_size", ")", ":", "bic_w", "]", ",", "\n", "bic", "[", ":", ",", ":", ",", "(", "bic_h", "-", "bic_h_size", ")", ":", "bic_h", ",", "0", ":", "bic_w_size", "]", ",", "\n", "bic", "[", ":", ",", ":", ",", "(", "bic_h", "-", "bic_h_size", ")", ":", "bic_h", ",", "(", "bic_w", "-", "bic_w_size", ")", ":", "bic_w", "]", "]", "\n", "\n", "", "if", "w_size", "*", "h_size", "<", "min_size", ":", "\n", "            ", "sr_list", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "4", ",", "n_GPUs", ")", ":", "\n", "                ", "lr_batch", "=", "torch", ".", "cat", "(", "lr_list", "[", "i", ":", "(", "i", "+", "n_GPUs", ")", "]", ",", "dim", "=", "0", ")", "\n", "if", "bic", "is", "not", "None", ":", "\n", "                    ", "bic_batch", "=", "torch", ".", "cat", "(", "bic_list", "[", "i", ":", "(", "i", "+", "n_GPUs", ")", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "sr_batch_temp", "=", "model", "(", "lr_batch", ",", "stdn", ")", "\n", "\n", "if", "isinstance", "(", "sr_batch_temp", ",", "list", ")", ":", "\n", "                    ", "sr_batch", "=", "sr_batch_temp", "[", "-", "1", "]", "\n", "", "else", ":", "\n", "                    ", "sr_batch", "=", "sr_batch_temp", "\n", "\n", "", "sr_list", ".", "extend", "(", "sr_batch", ".", "chunk", "(", "n_GPUs", ",", "dim", "=", "0", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "sr_list", "=", "[", "\n", "crop_forward", "(", "model", ",", "x", "=", "patch", ",", "stdn", "=", "stdn", ",", "shave", "=", "shave", ",", "min_size", "=", "min_size", ")", "for", "patch", "in", "lr_list", "\n", "]", "\n", "\n", "", "h", ",", "w", "=", "scale", "*", "h", ",", "scale", "*", "w", "\n", "h_half", ",", "w_half", "=", "scale", "*", "h_half", ",", "scale", "*", "w_half", "\n", "h_size", ",", "w_size", "=", "scale", "*", "h_size", ",", "scale", "*", "w_size", "\n", "shave", "*=", "scale", "\n", "\n", "output", "=", "x", ".", "new", "(", "b", ",", "c", ",", "h", ",", "w", ")", "\n", "output", "[", ":", ",", ":", ",", "0", ":", "h_half", ",", "0", ":", "w_half", "]", "=", "sr_list", "[", "0", "]", "[", ":", ",", ":", ",", "0", ":", "h_half", ",", "0", ":", "w_half", "]", "\n", "output", "[", ":", ",", ":", ",", "0", ":", "h_half", ",", "w_half", ":", "w", "]", "=", "sr_list", "[", "1", "]", "[", ":", ",", ":", ",", "0", ":", "h_half", ",", "(", "w_size", "-", "w", "+", "w_half", ")", ":", "w_size", "]", "\n", "output", "[", ":", ",", ":", ",", "h_half", ":", "h", ",", "0", ":", "w_half", "]", "=", "sr_list", "[", "2", "]", "[", ":", ",", ":", ",", "(", "h_size", "-", "h", "+", "h_half", ")", ":", "h_size", ",", "0", ":", "w_half", "]", "\n", "output", "[", ":", ",", ":", ",", "h_half", ":", "h", ",", "w_half", ":", "w", "]", "=", "sr_list", "[", "3", "]", "[", ":", ",", ":", ",", "(", "h_size", "-", "h", "+", "h_half", ")", ":", "h_size", ",", "(", "w_size", "-", "w", "+", "w_half", ")", ":", "w_size", "]", "\n", "\n", "return", "output", "\n", "\n", "", "def", "_net_init", "(", "model", ",", "init_type", ")", ":", "\n", "        ", "print", "(", "'==> Initializing the network using [%s]'", "%", "init_type", ")", "\n", "init_weights", "(", "model", ",", "init_type", ")", "\n", "\n", "", "def", "train", "(", "x", ",", "y", ",", "y_ref", ",", "sigma", ",", "\n", "netG", ",", "netD", ",", "netF", ",", "\n", "optimizers", ",", "\n", "cri_pix", ",", "l_pix_w", ",", "\n", "cri_fea", ",", "l_fea_w", ",", "\n", "cri_tv", ",", "l_tv_w", ",", "\n", "cri_gan", ",", "l_gan_w", ",", "\n", "filter_low", ",", "filter_high", ",", "\n", "step", ")", ":", "\n", "\n", "        ", "netG", ".", "train", "(", ")", "\n", "netD", ".", "train", "(", ")", "\n", "\n", "# feed data ", "\n", "var_L", "=", "y", "# LR", "\n", "var_H", "=", "x", "# GT", "\n", "input_ref", "=", "y_ref", "if", "y_ref", "else", "x", "\n", "var_ref", "=", "input_ref", "\n", "#sigma_noise = sigma", "\n", "optimizer_G", ",", "optimizer_D", "=", "optimizers", "[", "0", "]", ",", "optimizers", "[", "1", "]", "\n", "\n", "# G", "\n", "for", "p", "in", "netD", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "False", "\n", "\n", "", "optimizer_G", ".", "zero_grad", "(", ")", "\n", "fake_H", "=", "netG", "(", "var_L", ")", ".", "clamp", "(", "0.", ",", "255.", ")", "\n", "#print('train:: output fake_H:', fake_H.shape, fake_H.min(), fake_H.max())  ", "\n", "\n", "l_g_total", "=", "0", "\n", "if", "step", "%", "opt", ".", "D_update_ratio", "==", "0", "and", "step", ">", "opt", ".", "D_init_iters", ":", "\n", "            ", "if", "cri_pix", ":", "# pixel loss", "\n", "#l_g_pix_f = l_pix_w * cri_pix(filter_low(fake_H), filter_low(var_H))", "\n", "                ", "l_g_pix_f", "=", "l_pix_w", "*", "cri_pix", "(", "fake_H", ",", "var_H", ")", "\n", "l_g_pix_nf", "=", "l_pix_w", "*", "cri_pix", "(", "fake_H", ",", "var_H", ")", "\n", "\n", "if", "opt", ".", "use_filters", ":", "\n", "                    ", "l_g_pix", "=", "l_g_pix_f", "\n", "", "else", ":", "\n", "                    ", "l_g_pix", "=", "l_g_pix_nf", "\n", "\n", "", "l_g_total", "+=", "l_g_pix", "\n", "\n", "", "if", "cri_fea", ":", "# feature loss", "\n", "                ", "real_fea", "=", "netF", "(", "var_H", ")", ".", "detach", "(", ")", "\n", "fake_fea", "=", "netF", "(", "fake_H", ")", "\n", "l_g_fea", "=", "l_fea_w", "*", "cri_fea", "(", "fake_fea", ",", "real_fea", ")", "\n", "l_g_total", "+=", "l_g_fea", "\n", "\n", "", "if", "cri_tv", ":", "# TV loss", "\n", "                ", "l_g_tv", "=", "l_tv_w", "*", "cri_tv", "(", "fake_H", ",", "var_H", ")", "\n", "l_g_total", "+=", "l_g_tv", "\n", "\n", "", "if", "opt", ".", "use_filters", ":", "\n", "                ", "pred_g_fake", "=", "netD", "(", "filter_high", "(", "fake_H", ")", ")", "\n", "", "else", ":", "\n", "                ", "pred_g_fake", "=", "netD", "(", "fake_H", ")", "\n", "\n", "", "if", "opt", ".", "gan_type", "==", "'gan'", ":", "\n", "                ", "l_g_gan", "=", "l_gan_w", "*", "cri_gan", "(", "pred_g_fake", ",", "True", ")", "\n", "", "elif", "opt", ".", "gan_type", "==", "'ragan'", ":", "\n", "                ", "if", "opt", ".", "use_filters", ":", "\n", "                    ", "pred_d_real", "=", "netD", "(", "filter_high", "(", "var_ref", ")", ")", ".", "detach", "(", ")", "\n", "", "else", ":", "\n", "                    ", "pred_d_real", "=", "netD", "(", "var_ref", ")", ".", "detach", "(", ")", "\n", "", "l_g_gan", "=", "l_gan_w", "*", "(", "\n", "cri_gan", "(", "pred_d_real", "-", "torch", ".", "mean", "(", "pred_g_fake", ")", ",", "False", ")", "+", "\n", "cri_gan", "(", "pred_g_fake", "-", "torch", ".", "mean", "(", "pred_d_real", ")", ",", "True", ")", ")", "/", "2", "\n", "", "l_g_total", "+=", "l_g_gan", "\n", "\n", "l_g_total", ".", "backward", "(", ")", "\n", "optimizer_G", ".", "step", "(", ")", "\n", "\n", "# D", "\n", "", "for", "p", "in", "netD", ".", "parameters", "(", ")", ":", "\n", "            ", "p", ".", "requires_grad", "=", "True", "\n", "\n", "", "optimizer_D", ".", "zero_grad", "(", ")", "\n", "l_d_total", "=", "0", "\n", "\n", "if", "opt", ".", "use_filters", ":", "\n", "            ", "pred_d_real", "=", "netD", "(", "filter_high", "(", "var_ref", ")", ")", "\n", "pred_d_fake", "=", "netD", "(", "filter_high", "(", "fake_H", ".", "detach", "(", ")", ")", ")", "# detach to avoid BP to G", "\n", "", "else", ":", "\n", "            ", "pred_d_real", "=", "netD", "(", "var_ref", ")", "\n", "pred_d_fake", "=", "netD", "(", "fake_H", ".", "detach", "(", ")", ")", "# detach to avoid BP to G", "\n", "\n", "", "if", "opt", ".", "gan_type", "==", "'gan'", ":", "\n", "            ", "l_d_real", "=", "cri_gan", "(", "pred_d_real", ",", "True", ")", "\n", "l_d_fake", "=", "cri_gan", "(", "pred_d_fake", ",", "False", ")", "\n", "l_d_total", "=", "l_d_real", "+", "l_d_fake", "\n", "", "elif", "opt", ".", "gan_type", "==", "'ragan'", ":", "\n", "            ", "l_d_real", "=", "cri_gan", "(", "pred_d_real", "-", "torch", ".", "mean", "(", "pred_d_fake", ")", ",", "True", ")", "\n", "l_d_fake", "=", "cri_gan", "(", "pred_d_fake", "-", "torch", ".", "mean", "(", "pred_d_real", ")", ",", "False", ")", "\n", "l_d_total", "=", "(", "l_d_real", "+", "l_d_fake", ")", "/", "2", "\n", "\n", "", "l_d_total", ".", "backward", "(", ")", "\n", "optimizer_D", ".", "step", "(", ")", "\n", "\n", "# set log", "\n", "if", "step", "%", "opt", ".", "D_update_ratio", "==", "0", "and", "step", ">", "opt", ".", "D_init_iters", ":", "\n", "            ", "if", "cri_pix", ":", "\n", "                ", "l_g_pix_batch", "=", "l_g_pix", ".", "item", "(", ")", "\n", "", "if", "cri_fea", ":", "\n", "                ", "l_g_fea_batch", "=", "l_g_fea", ".", "item", "(", ")", "\n", "", "if", "cri_tv", ":", "\n", "                ", "l_g_tv_batch", "=", "l_g_tv", ".", "item", "(", ")", "\n", "", "l_g_gan_batch", "=", "l_g_gan", ".", "item", "(", ")", "\n", "\n", "", "l_d_real_batch", "=", "l_d_real", ".", "item", "(", ")", "\n", "l_d_fake_batch", "=", "l_d_fake", ".", "item", "(", ")", "\n", "D_real_batch", "=", "torch", ".", "mean", "(", "pred_d_real", ".", "detach", "(", ")", ")", "\n", "D_fake_batch", "=", "torch", ".", "mean", "(", "pred_d_fake", ".", "detach", "(", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"===> train:: l_g_pix Loss:{:.6f}\"", ".", "format", "(", "l_g_pix_batch", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: l_g_fea Loss:{:.6f}\"", ".", "format", "(", "l_g_fea_batch", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: l_g_tv Loss:{:.6f}\"", ".", "format", "(", "l_g_tv_batch", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: l_g_gan Loss:{:.6f}\"", ".", "format", "(", "l_g_gan_batch", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"===> train:: l_d_real Loss:{:.6f}\"", ".", "format", "(", "l_d_real_batch", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: l_d_fake Loss:{:.6f}\"", ".", "format", "(", "l_d_fake_batch", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: l_d_total Loss:{:.6f}\"", ".", "format", "(", "l_d_total", ".", "item", "(", ")", ")", ")", "\n", "\n", "logger", ".", "info", "(", "\"===> train:: D_real output:{:.6f}\"", ".", "format", "(", "D_real_batch", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: D_fake output:{:.6f}\"", ".", "format", "(", "D_fake_batch", ")", ")", "\n", "\n", "output", "=", "fake_H", "\n", "total_loss_g", "=", "l_g_total", ".", "item", "(", ")", "\n", "psnr_batch", "=", "psnr", "(", "fake_H", ",", "var_H", ",", "border", "=", "border", ")", ".", "item", "(", ")", "\n", "logger", ".", "info", "(", "\"===> train:: batch: Total Gen. Loss:{:.6f}\"", ".", "format", "(", "total_loss_g", ")", ")", "\n", "logger", ".", "info", "(", "\"===> train:: batch: Gen. output PSNR:{:.4f}\"", ".", "format", "(", "psnr_batch", ")", ")", "\n", "\n", "return", "output", ",", "total_loss_g", ",", "psnr_batch", ",", "netG", ",", "netD", "\n", "\n", "", "def", "test", "(", "model", ",", "lpips", ",", "epoch", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "test_results", "=", "OrderedDict", "(", ")", "\n", "test_results", "[", "'psnr'", "]", "=", "[", "]", "\n", "test_results", "[", "'ssim'", "]", "=", "[", "]", "\n", "test_results", "[", "'lpips_dist'", "]", "=", "[", "]", "\n", "img_idx", "=", "1", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "for", "i", ",", "data", "in", "enumerate", "(", "testset_loader", ")", ":", "\n", "                ", "y", ",", "x", ",", "sigma", "=", "data", "[", "'LR'", "]", ",", "data", "[", "'HR'", "]", ",", "data", "[", "'sigma'", "]", "\n", "\n", "if", "opt", ".", "cuda", ":", "\n", "                    ", "y", "=", "y", ".", "cuda", "(", ")", "\n", "x", "=", "x", ".", "cuda", "(", ")", "\n", "sigma", "=", "sigma", ".", "cuda", "(", ")", "\n", "\n", "", "y", "=", "y", ".", "float", "(", ")", "\n", "x", "=", "x", ".", "float", "(", ")", "\n", "sigma", "=", "sigma", ".", "float", "(", ")", "\n", "\n", "#print(\"test x:\", x.shape, x.min(), x.max())", "\n", "#print(\"test y:\", y.shape, y.min(), y.max())", "\n", "#print(\"test sigma:\", sigma.shape, sigma.min(), sigma.max())", "\n", "\n", "if", "opt", ".", "use_chop", ":", "\n", "                    ", "xhat", "=", "crop_forward", "(", "model", ",", "y", ",", "opt", ".", "upscale_factor", ")", "\n", "", "else", ":", "\n", "                    ", "outputs", "=", "model", "(", "y", ")", "\n", "\n", "", "xhat", "=", "outputs", ".", "clamp", "(", "0.", ",", "255.", ")", "\n", "#print(\"test xhat:\", xhat.shape, xhat.min(), xhat.max())   ", "\n", "\n", "# save test images", "\n", "gt", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "LR", "=", "y", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "output", "=", "xhat", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "gt_img_path", "=", "save_test_imgs_path", "+", "'img'", "+", "repr", "(", "img_idx", ")", "+", "'_GT'", "+", "'.png'", "\n", "LR_img_path", "=", "save_test_imgs_path", "+", "'img'", "+", "repr", "(", "img_idx", ")", "+", "'_LR'", "+", "'.png'", "\n", "output_img_path", "=", "save_test_imgs_path", "+", "'img'", "+", "repr", "(", "img_idx", ")", "+", "'_SR'", "+", "'.png'", "\n", "\n", "# psnr, ssim, and lpips", "\n", "psnr", "=", "utils_common", ".", "calculate_psnr", "(", "output", "[", "0", "]", ",", "gt", "[", "0", "]", ",", "border", "=", "border", ")", "\n", "ssim", "=", "utils_common", ".", "calculate_ssim", "(", "output", "[", "0", "]", ",", "gt", "[", "0", "]", ",", "border", "=", "border", ")", "\n", "\n", "# normalized tensors", "\n", "img_x", "=", "util", ".", "normalized_tensor", "(", "x", ")", "\n", "pred_xhat", "=", "util", ".", "normalized_tensor", "(", "xhat", ")", "\n", "lpips_dist", "=", "lpips", ".", "forward", "(", "img_x", ",", "pred_xhat", ")", ".", "item", "(", ")", "\n", "\n", "test_results", "[", "'psnr'", "]", ".", "append", "(", "psnr", ")", "\n", "test_results", "[", "'ssim'", "]", ".", "append", "(", "ssim", ")", "\n", "test_results", "[", "'lpips_dist'", "]", ".", "append", "(", "lpips_dist", ")", "\n", "\n", "logger", ".", "info", "(", "'{:->4d}--> {:>10s}, psnr:{:.2f}dB'", ".", "format", "(", "img_idx", ",", "output_img_path", ",", "psnr", ")", ")", "\n", "logger", ".", "info", "(", "'{:->4d}--> {:>10s}, ssim:{:.4f}'", ".", "format", "(", "img_idx", ",", "output_img_path", ",", "ssim", ")", ")", "\n", "logger", ".", "info", "(", "'{:->4d}--> {:>10s}, lpips dist:{:.4f}'", ".", "format", "(", "img_idx", ",", "output_img_path", ",", "lpips_dist", ")", ")", "\n", "img_idx", "+=", "1", "\n", "\n", "if", "epoch", "%", "1", "==", "0", ":", "\n", "                    ", "save", "(", "gt_img_path", ",", "gt", "[", "0", "]", ")", "\n", "save", "(", "LR_img_path", ",", "LR", "[", "0", "]", ")", "\n", "save", "(", "output_img_path", ",", "output", "[", "0", "]", ")", "\n", "\n", "", "del", "x", "\n", "del", "y", "\n", "del", "sigma", "\n", "del", "xhat", "\n", "del", "gt", "\n", "del", "LR", "\n", "del", "output", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "\n", "", "", "avg_psnr", "=", "sum", "(", "test_results", "[", "'psnr'", "]", ")", "/", "len", "(", "test_results", "[", "'psnr'", "]", ")", "\n", "avg_ssim", "=", "sum", "(", "test_results", "[", "'ssim'", "]", ")", "/", "len", "(", "test_results", "[", "'ssim'", "]", ")", "\n", "avg_lpips", "=", "sum", "(", "test_results", "[", "'lpips_dist'", "]", ")", "/", "len", "(", "test_results", "[", "'lpips_dist'", "]", ")", "\n", "\n", "#print(\"===>test:: Avg. PSNR:{:.2f}\".format(avg_psnr))", "\n", "#print(\"===>test:: Avg. SSIM:{:.4f}\".format(avg_ssim))", "\n", "logger", ".", "info", "(", "\"test:: Epoch[{}]: Avg. PSNR: {:.2f} dB\"", ".", "format", "(", "epoch", ",", "avg_psnr", ")", ")", "\n", "logger", ".", "info", "(", "\"test:: Epoch[{}]: Avg. SSIM: {:.4f}\"", ".", "format", "(", "epoch", ",", "avg_ssim", ")", ")", "\n", "logger", ".", "info", "(", "\"test:: Epoch[{}]: Avg. Lpips: {:.6f}\"", ".", "format", "(", "epoch", ",", "avg_lpips", ")", ")", "\n", "\n", "return", "avg_psnr", ",", "avg_lpips", "\n", "\n", "", "def", "count_parameters", "(", "model", ")", ":", "\n", "        ", "return", "sum", "(", "p", ".", "numel", "(", ")", "for", "p", "in", "model", ".", "parameters", "(", ")", "if", "p", ".", "requires_grad", ")", "\n", "\n", "", "def", "get_current_learning_rate", "(", "optimizer", ")", ":", "\n", "        ", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "            ", "return", "param_group", "[", "'lr'", "]", "\n", "\n", "", "", "def", "_set_lr", "(", "optimizers", ",", "lr_groups_l", ")", ":", "\n", "        ", "\"\"\"Set learning rate for warmup\n        lr_groups_l: list for lr_groups. each for a optimizer\"\"\"", "\n", "for", "optimizer", ",", "lr_groups", "in", "zip", "(", "optimizers", ",", "lr_groups_l", ")", ":", "\n", "            ", "for", "param_group", ",", "lr", "in", "zip", "(", "optimizer", ".", "param_groups", ",", "lr_groups", ")", ":", "\n", "                ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n", "", "", "", "def", "_get_init_lr", "(", "optimizers", ")", ":", "\n", "        ", "\"\"\"Get the initial lr, which is set by the scheduler\"\"\"", "\n", "init_lr_groups_l", "=", "[", "]", "\n", "for", "optimizer", "in", "optimizers", ":", "\n", "            ", "init_lr_groups_l", ".", "append", "(", "[", "v", "[", "'initial_lr'", "]", "for", "v", "in", "optimizer", ".", "param_groups", "]", ")", "\n", "", "return", "init_lr_groups_l", "\n", "\n", "", "def", "update_learning_rate", "(", "optimizers", ",", "schedulers", ",", "cur_iter", ",", "warmup_iter", "=", "-", "1", ")", ":", "\n", "        ", "for", "scheduler", "in", "schedulers", ":", "\n", "            ", "scheduler", ".", "step", "(", ")", "\n", "# set up warm-up learning rate", "\n", "", "if", "cur_iter", "<", "warmup_iter", ":", "\n", "# get initial lr for each group", "\n", "            ", "init_lr_g_l", "=", "_get_init_lr", "(", ")", "\n", "# modify warming-up learning rates", "\n", "warm_up_lr_l", "=", "[", "]", "\n", "for", "init_lr_g", "in", "init_lr_g_l", ":", "\n", "                ", "warm_up_lr_l", ".", "append", "(", "[", "v", "/", "warmup_iter", "*", "cur_iter", "for", "v", "in", "init_lr_g", "]", ")", "\n", "# set learning rate", "\n", "", "_set_lr", "(", "optimizers", ",", "warm_up_lr_l", ")", "\n", "\n", "", "", "def", "save_network", "(", "path_model", ",", "network", ",", "network_label", ",", "iter_label", ")", ":", "\n", "        ", "save_filename", "=", "'{}_{}.pth'", ".", "format", "(", "iter_label", ",", "network_label", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "path_model", ",", "save_filename", ")", "\n", "if", "isinstance", "(", "network", ",", "nn", ".", "DataParallel", ")", "or", "isinstance", "(", "network", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "network", "=", "network", ".", "module", "\n", "", "state_dict", "=", "network", ".", "state_dict", "(", ")", "\n", "for", "key", ",", "param", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "            ", "state_dict", "[", "key", "]", "=", "param", ".", "cpu", "(", ")", "\n", "", "torch", ".", "save", "(", "state_dict", ",", "save_path", ")", "\n", "\n", "", "def", "load_network", "(", "load_path", ",", "network", ",", "strict", "=", "True", ")", ":", "\n", "        ", "if", "isinstance", "(", "network", ",", "nn", ".", "DataParallel", ")", "or", "isinstance", "(", "network", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "network", "=", "network", ".", "module", "\n", "", "load_net", "=", "torch", ".", "load", "(", "load_path", ")", "\n", "#        load_net_clean = OrderedDict()  # remove unnecessary 'module.'", "\n", "#        for k, v in load_net.items():", "\n", "#            if k.startswith('module.'):", "\n", "#                load_net_clean[k[7:]] = v", "\n", "#            else:", "\n", "#                load_net_clean[k] = v", "\n", "network", ".", "load_state_dict", "(", "load_net", ",", "strict", "=", "strict", ")", "\n", "return", "network", "\n", "\n", "", "def", "custom_load", "(", "netG", ",", "netD", ",", "load_path_G", ",", "load_path_D", ")", ":", "\n", "        ", "if", "load_path_G", "is", "not", "None", ":", "\n", "            ", "logger", ".", "info", "(", "'Loading model for G [{:s}] ...'", ".", "format", "(", "load_path_G", ")", ")", "\n", "netG", "=", "load_network", "(", "load_path_G", ",", "netG", ")", "\n", "\n", "", "if", "load_path_D", "is", "not", "None", ":", "\n", "            ", "logger", ".", "info", "(", "'Loading model for D [{:s}] ...'", ".", "format", "(", "load_path_D", ")", ")", "\n", "netD", "=", "load_network", "(", "load_path_D", ",", "netD", ")", "\n", "", "return", "netG", ",", "netD", "\n", "\n", "", "def", "save_checkpoint_best", "(", "model_path", ",", "epoch", ",", "iter_step", ",", "optimizers", ",", "schedulers", ",", "metrics", ",", "label", ")", ":", "\n", "        ", "state", "=", "{", "'epoch'", ":", "epoch", ",", "'iter'", ":", "iter_step", ",", "'schedulers'", ":", "[", "]", ",", "'optimizers'", ":", "[", "]", "}", "\n", "state", "=", "{", "**", "state", ",", "**", "metrics", "}", "\n", "for", "s", "in", "schedulers", ":", "\n", "            ", "state", "[", "'schedulers'", "]", ".", "append", "(", "s", ".", "state_dict", "(", ")", ")", "\n", "", "for", "o", "in", "optimizers", ":", "\n", "            ", "state", "[", "'optimizers'", "]", ".", "append", "(", "o", ".", "state_dict", "(", ")", ")", "\n", "", "save_filename", "=", "'{}_tr_states_best_'", ".", "format", "(", "epoch", ")", "+", "label", "+", "'.pth'", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "model_path", ",", "save_filename", ")", "\n", "torch", ".", "save", "(", "state", ",", "save_path", ")", "\n", "logger", ".", "info", "(", "\"===> Checkpoint saved to {:s}\"", ".", "format", "(", "save_path", ")", ")", "\n", "\n", "", "def", "save_training_state", "(", "epoch", ",", "iter_step", ",", "optimizers", ",", "schedulers", ",", "metrics", ")", ":", "\n", "        ", "\"\"\"Save training state during training, which will be used for resuming\"\"\"", "\n", "state", "=", "{", "'epoch'", ":", "epoch", ",", "'iter'", ":", "iter_step", ",", "'schedulers'", ":", "[", "]", ",", "'optimizers'", ":", "[", "]", "}", "\n", "state", "=", "{", "**", "state", ",", "**", "metrics", "}", "\n", "for", "s", "in", "schedulers", ":", "\n", "            ", "state", "[", "'schedulers'", "]", ".", "append", "(", "s", ".", "state_dict", "(", ")", ")", "\n", "", "for", "o", "in", "optimizers", ":", "\n", "            ", "state", "[", "'optimizers'", "]", ".", "append", "(", "o", ".", "state_dict", "(", ")", ")", "\n", "", "save_filename", "=", "'{}_tr_states.pth'", ".", "format", "(", "epoch", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "training_states_save_path", ",", "save_filename", ")", "\n", "torch", ".", "save", "(", "state", ",", "save_path", ")", "\n", "\n", "", "def", "resume_training", "(", "resume_path", ",", "optimizers", ",", "schedulers", ")", ":", "\n", "        ", "\"\"\"Resume the optimizers and schedulers for training\"\"\"", "\n", "if", "opt", ".", "cuda", ":", "\n", "            ", "resume_state", "=", "torch", ".", "load", "(", "resume_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ".", "cuda", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "resume_state", "=", "torch", ".", "load", "(", "resume_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "\n", "", "start_epoch", "=", "resume_state", "[", "'epoch'", "]", "\n", "iter_step", "=", "resume_state", "[", "'iter'", "]", "\n", "epoch_psnr_old", "=", "resume_state", "[", "'epoch_psnr_old'", "]", "\n", "epoch_lpips_old", "=", "resume_state", "[", "'epoch_lpips_old'", "]", "\n", "resume_optimizers", "=", "resume_state", "[", "'optimizers'", "]", "\n", "resume_schedulers", "=", "resume_state", "[", "'schedulers'", "]", "\n", "assert", "len", "(", "resume_optimizers", ")", "==", "len", "(", "optimizers", ")", ",", "'Wrong lengths of optimizers'", "\n", "assert", "len", "(", "resume_schedulers", ")", "==", "len", "(", "schedulers", ")", ",", "'Wrong lengths of schedulers'", "\n", "for", "i", ",", "o", "in", "enumerate", "(", "resume_optimizers", ")", ":", "\n", "            ", "optimizers", "[", "i", "]", ".", "load_state_dict", "(", "o", ")", "\n", "", "for", "i", ",", "s", "in", "enumerate", "(", "resume_schedulers", ")", ":", "\n", "            ", "schedulers", "[", "i", "]", ".", "load_state_dict", "(", "s", ")", "\n", "\n", "", "return", "start_epoch", ",", "iter_step", ",", "epoch_psnr_old", ",", "epoch_lpips_old", ",", "optimizers", ",", "schedulers", "\n", "\n", "", "def", "get_network_description", "(", "network", ")", ":", "\n", "        ", "\"\"\"Get the string and total parameters of the network\"\"\"", "\n", "if", "isinstance", "(", "network", ",", "nn", ".", "DataParallel", ")", "or", "isinstance", "(", "network", ",", "DistributedDataParallel", ")", ":", "\n", "            ", "network", "=", "network", ".", "module", "\n", "", "return", "str", "(", "network", ")", ",", "sum", "(", "map", "(", "lambda", "x", ":", "x", ".", "numel", "(", ")", ",", "network", ".", "parameters", "(", ")", ")", ")", "\n", "\n", "", "def", "print_network", "(", "netG", ",", "netD", ",", "netF", ")", ":", "\n", "# Generator", "\n", "        ", "if", "netG", "is", "not", "None", ":", "\n", "            ", "s", ",", "n", "=", "get_network_description", "(", "netG", ")", "\n", "if", "isinstance", "(", "netG", ",", "nn", ".", "DataParallel", ")", "or", "isinstance", "(", "netG", ",", "DistributedDataParallel", ")", ":", "\n", "                ", "net_struc_str", "=", "'{} - {}'", ".", "format", "(", "netG", ".", "__class__", ".", "__name__", ",", "\n", "netG", ".", "module", ".", "__class__", ".", "__name__", ")", "\n", "", "else", ":", "\n", "                ", "net_struc_str", "=", "'{}'", ".", "format", "(", "netG", ".", "__class__", ".", "__name__", ")", "\n", "", "logger", ".", "info", "(", "'Network G structure: {}, with parameters: {:,d}'", ".", "format", "(", "net_struc_str", ",", "n", ")", ")", "\n", "logger", ".", "info", "(", "s", ")", "\n", "\n", "# Discriminator", "\n", "", "if", "netD", "is", "not", "None", ":", "\n", "            ", "s", ",", "n", "=", "get_network_description", "(", "netD", ")", "\n", "if", "isinstance", "(", "netD", ",", "nn", ".", "DataParallel", ")", "or", "isinstance", "(", "netD", ",", "DistributedDataParallel", ")", ":", "\n", "                ", "net_struc_str", "=", "'{} - {}'", ".", "format", "(", "netD", ".", "__class__", ".", "__name__", ",", "\n", "netD", ".", "module", ".", "__class__", ".", "__name__", ")", "\n", "", "else", ":", "\n", "                ", "net_struc_str", "=", "'{}'", ".", "format", "(", "netD", ".", "__class__", ".", "__name__", ")", "\n", "", "logger", ".", "info", "(", "'Network D structure: {}, with parameters: {:,d}'", ".", "format", "(", "net_struc_str", ",", "n", ")", ")", "\n", "logger", ".", "info", "(", "s", ")", "\n", "\n", "# F, Perceptual Network", "\n", "", "if", "netF", "is", "not", "None", ":", "\n", "            ", "s", ",", "n", "=", "get_network_description", "(", "netF", ")", "\n", "if", "isinstance", "(", "netF", ",", "nn", ".", "DataParallel", ")", "or", "isinstance", "(", "netF", ",", "DistributedDataParallel", ")", ":", "\n", "                ", "net_struc_str", "=", "'{} - {}'", ".", "format", "(", "netF", ".", "__class__", ".", "__name__", ",", "\n", "netF", ".", "module", ".", "__class__", ".", "__name__", ")", "\n", "", "else", ":", "\n", "                ", "net_struc_str", "=", "'{}'", ".", "format", "(", "netF", ".", "__class__", ".", "__name__", ")", "\n", "", "logger", ".", "info", "(", "'Network F structure: {}, with parameters: {:,d}'", ".", "format", "(", "net_struc_str", ",", "n", ")", ")", "\n", "logger", ".", "info", "(", "s", ")", "\n", "\n", "### Utils for managing network parameters ###", "\n", "", "", "def", "get_module_name_dict", "(", "root", ",", "rootname", "=", "\"/\"", ")", ":", "\n", "        ", "def", "_rec", "(", "module", ",", "d", ",", "name", ")", ":", "\n", "            ", "for", "key", ",", "child", "in", "module", ".", "__dict__", "[", "\"_modules\"", "]", ".", "items", "(", ")", ":", "\n", "                ", "d", "[", "child", "]", "=", "name", "+", "key", "+", "\"/\"", "\n", "_rec", "(", "child", ",", "d", ",", "d", "[", "child", "]", ")", "\n", "\n", "", "", "d", "=", "{", "root", ":", "rootname", "}", "\n", "_rec", "(", "root", ",", "d", ",", "d", "[", "root", "]", ")", "\n", "return", "d", "\n", "\n", "", "def", "parameters_by_module", "(", "net", ",", "name", "=", "\"\"", ")", ":", "\n", "        ", "modulenames", "=", "get_module_name_dict", "(", "net", ",", "name", "+", "\"/\"", ")", "\n", "params", "=", "[", "{", "\"params\"", ":", "p", ",", "\"name\"", ":", "n", ",", "\"module\"", ":", "modulenames", "[", "m", "]", "}", "for", "m", "in", "net", ".", "modules", "(", ")", "for", "n", ",", "p", "in", "m", ".", "_parameters", ".", "items", "(", ")", "if", "p", "is", "not", "None", "]", "\n", "return", "params", "\n", "\n", "", "def", "parameter_count", "(", "net", ")", ":", "\n", "        ", "parameters", "=", "parameters_by_module", "(", "net", ")", "\n", "\n", "nparams", "=", "0", "\n", "for", "pg", "in", "parameters", ":", "\n", "            ", "for", "p", "in", "pg", "[", "\"params\"", "]", ":", "\n", "                ", "nparams", "+=", "p", ".", "data", ".", "numel", "(", ")", "\n", "\n", "", "", "return", "nparams", "\n", "\n", "################################", "\n", "## NN Architecture", "\n", "################################", "\n", "", "logger", ".", "info", "(", "'===================== Building model ====================='", ")", "\n", "\n", "# denoiser net", "\n", "resdnet", "=", "ResDNet", "(", "depth", "=", "opt", ".", "resdnet_depth", ")", "\n", "# Generator net", "\n", "netG", "=", "SRResDNet", "(", "resdnet", ",", "scale", "=", "opt", ".", "upscale_factor", ")", "\n", "\n", "# Discriminator net", "\n", "netD", "=", "SRGAN_arch", ".", "Discriminator_VGG_128", "(", "in_nc", "=", "opt", ".", "in_nc", ",", "nf", "=", "opt", ".", "nf", ")", "\n", "\n", "# initialize model with pertrained network", "\n", "if", "opt", ".", "pretrain", ":", "\n", "        ", "logger", ".", "info", "(", "'Initialized model with pretrained net from {:s}.'", ".", "format", "(", "opt", ".", "pretrainedModelPath", ")", ")", "\n", "netG", "=", "load_network", "(", "opt", ".", "pretrainedModelPath", ",", "netG", ")", "\n", "", "else", ":", "\n", "        ", "netG", "=", "_net_init", "(", "netG", ",", "init_type", "=", "'kaiming'", ")", "\n", "netD", "=", "_net_init", "(", "netD", ",", "init_type", "=", "'kaiming'", ")", "\n", "\n", "# Filters: low-pass: W_L, high-pass: W_H", "\n", "", "filter_low", "=", "filters", ".", "FilterLow", "(", ")", "\n", "filter_high", "=", "filters", ".", "FilterHigh", "(", ")", "\n", "\n", "if", "opt", ".", "cuda", ":", "\n", "        ", "netG", "=", "netG", ".", "cuda", "(", ")", "\n", "netD", "=", "netD", ".", "cuda", "(", ")", "\n", "filter_low", "=", "filter_low", ".", "cuda", "(", ")", "\n", "filter_high", "=", "filter_high", ".", "cuda", "(", ")", "\n", "\n", "# optimizers", "\n", "# Adam    ", "\n", "", "optimizer_G", "=", "torch", ".", "optim", ".", "Adam", "(", "netG", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "opt", ".", "lr_G", ",", "\n", "betas", "=", "(", "opt", ".", "beta1_G", ",", "opt", ".", "beta2_G", ")", ",", "\n", "eps", "=", "opt", ".", "eps_G", ",", "\n", "weight_decay", "=", "opt", ".", "weightdecay_G", ",", "\n", "amsgrad", "=", "opt", ".", "amsgrad", ")", "\n", "\n", "optimizer_D", "=", "torch", ".", "optim", ".", "Adam", "(", "netD", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "opt", ".", "lr_D", ",", "\n", "betas", "=", "(", "opt", ".", "beta1_D", ",", "opt", ".", "beta2_D", ")", ",", "\n", "eps", "=", "opt", ".", "eps_D", ",", "\n", "weight_decay", "=", "opt", ".", "weightdecay_D", ",", "\n", "amsgrad", "=", "opt", ".", "amsgrad", ")", "\n", "optimizers", "=", "[", "optimizer_G", ",", "optimizer_D", "]", "\n", "\n", "# schedulers", "\n", "scheduler_G", "=", "lr_scheduler", ".", "MultiStepLR_Restart", "(", "optimizer_G", ",", "\n", "milestones", "=", "opt", ".", "lr_milestones", ",", "\n", "restarts", "=", "opt", ".", "lr_restart", ",", "\n", "weights", "=", "opt", ".", "lr_restart_weights", ",", "\n", "gamma", "=", "opt", ".", "lr_gamma", ")", "\n", "scheduler_D", "=", "lr_scheduler", ".", "MultiStepLR_Restart", "(", "optimizer_D", ",", "\n", "milestones", "=", "opt", ".", "lr_milestones", ",", "\n", "restarts", "=", "opt", ".", "lr_restart", ",", "\n", "weights", "=", "opt", ".", "lr_restart_weights", ",", "\n", "gamma", "=", "opt", ".", "lr_gamma", ")", "\n", "schedulers", "=", "[", "scheduler_G", ",", "scheduler_D", "]", "\n", "\n", "# losses criteria  ", "\n", "# G pixel loss", "\n", "l_pix_type", "=", "opt", ".", "pixel_criterion", "\n", "if", "l_pix_type", "==", "'l1'", ":", "\n", "        ", "cri_pix", "=", "nn", ".", "L1Loss", "(", ")", "\n", "", "elif", "l_pix_type", "==", "'l2'", ":", "\n", "        ", "cri_pix", "=", "nn", ".", "MSELoss", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Loss type [{:s}] not recognized.'", ".", "format", "(", "l_pix_type", ")", ")", "\n", "", "l_pix_w", "=", "opt", ".", "pixel_weight", "\n", "\n", "# G TV loss", "\n", "l_tv_type", "=", "opt", ".", "tv_criterion", "\n", "if", "l_tv_type", "==", "'l1'", ":", "\n", "        ", "cri_tv", "=", "TV_L1LOSS", "(", ")", "\n", "", "elif", "l_tv_type", "==", "'l2'", ":", "\n", "        ", "cri_tv", "=", "TV_L2Loss", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Loss type [{:s}] not recognized.'", ".", "format", "(", "l_tv_type", ")", ")", "\n", "", "l_tv_w", "=", "opt", ".", "tv_weight", "\n", "\n", "# G feature loss", "\n", "l_fea_type", "=", "opt", ".", "feature_criterion", "\n", "if", "l_fea_type", "==", "'l1'", ":", "\n", "        ", "cri_fea", "=", "nn", ".", "L1Loss", "(", ")", "\n", "", "elif", "l_fea_type", "==", "'l2'", ":", "\n", "        ", "cri_fea", "=", "nn", ".", "MSELoss", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Loss type [{:s}] not recognized.'", ".", "format", "(", "l_fea_type", ")", ")", "\n", "", "l_fea_w", "=", "opt", ".", "feature_weight", "\n", "\n", "if", "cri_fea", ":", "# load VGG perceptual loss", "\n", "# PyTorch pretrained VGG19-54, before ReLU.", "\n", "        ", "if", "opt", ".", "use_bn", ":", "\n", "            ", "feature_layer", "=", "49", "\n", "", "else", ":", "\n", "            ", "feature_layer", "=", "34", "\n", "", "netF", "=", "SRGAN_arch", ".", "VGGFeatureExtractor", "(", "feature_layer", "=", "feature_layer", ",", "\n", "use_bn", "=", "opt", ".", "use_bn", ",", "\n", "use_input_norm", "=", "True", ",", "\n", "device", "=", "'cuda'", ")", "\n", "netF", ".", "eval", "(", ")", "# No need to train", "\n", "netF", "=", "netF", ".", "cuda", "(", ")", "\n", "\n", "# GD gan loss", "\n", "", "cri_gan", "=", "GANLoss", "(", "opt", ".", "gan_type", ",", "1.0", ",", "0.0", ")", "\n", "l_gan_w", "=", "opt", ".", "gan_weight", "\n", "\n", "if", "opt", ".", "cuda", ":", "\n", "        ", "cri_pix", "=", "cri_pix", ".", "cuda", "(", ")", "\n", "cri_fea", "=", "cri_fea", ".", "cuda", "(", ")", "\n", "cri_gan", "=", "cri_gan", ".", "cuda", "(", ")", "\n", "\n", "# lpips distance metric for test", "\n", "", "lpips", "=", "modules", ".", "PerceptualLoss", "(", "model", "=", "'net-lin'", ",", "net", "=", "'alex'", ",", "use_gpu", "=", "opt", ".", "cuda", ")", "# alex, squeeze, vgg", "\n", "\n", "# print networks", "\n", "print_network", "(", "netG", ",", "netD", ",", "netF", ")", "\n", "\n", "################################", "\n", "## Main", "\n", "################################", "\n", "# start training", "\n", "logger", ".", "info", "(", "'===================== start training ====================='", ")", "\n", "#resume training", "\n", "if", "opt", ".", "resume", ":", "\n", "        ", "logger", ".", "info", "(", "'===================== resume training ====================='", ")", "\n", "resume_path", "=", "training_states_save_path", "\n", "if", "not", "os", ".", "listdir", "(", "resume_path", ")", ":", "\n", "            ", "logger", ".", "info", "(", "'===> No saved training states to resume.'", ")", "\n", "current_step", "=", "0", "\n", "start_epoch", "=", "0", "\n", "epoch_psnr_old", "=", "-", "float", "(", "'inf'", ")", "\n", "epoch_lpips_old", "=", "float", "(", "'inf'", ")", "\n", "logger", ".", "info", "(", "'===> start training from epoch: {}, iter: {}.'", ".", "format", "(", "start_epoch", ",", "current_step", ")", ")", "\n", "", "else", ":", "\n", "            ", "resume_start_epoch", "=", "opt", ".", "resume_start_epoch", "\n", "resume_path", "=", "training_states_save_path", "+", "str", "(", "resume_start_epoch", ")", "+", "'_tr_states.pth'", "\n", "start_epoch", ",", "current_step", ",", "epoch_psnr_old", ",", "epoch_lpips_old", ",", "optimizers", ",", "schedulers", "=", "resume_training", "(", "resume_path", ",", "\n", "optimizers", ",", "\n", "schedulers", ")", "\n", "logger", ".", "info", "(", "'===> loading pretrained models: G, D.'", ")", "\n", "load_path_G", "=", "netG_save_path", "+", "str", "(", "start_epoch", ")", "+", "'_G.pth'", "\n", "load_path_D", "=", "netD_save_path", "+", "str", "(", "start_epoch", ")", "+", "'_D.pth'", "\n", "netG", ",", "netD", "=", "custom_load", "(", "netG", ",", "netD", ",", "load_path_G", ",", "load_path_D", ")", "\n", "logger", ".", "info", "(", "'===> Resuming training from epoch: {}, iter: {}.'", ".", "format", "(", "start_epoch", ",", "current_step", ")", ")", "\n", "\n", "#training loop", "\n", "", "", "t", "=", "timer", "(", ")", "\n", "t", ".", "tic", "(", ")", "\n", "total_iters", "=", "int", "(", "opt", ".", "niter", ")", "\n", "total_epochs", "=", "int", "(", "math", ".", "ceil", "(", "total_iters", "/", "train_size", ")", ")", "\n", "logger", ".", "info", "(", "'Total # of epochs for training: {}.'", ".", "format", "(", "total_epochs", ")", ")", "\n", "\n", "for", "epoch", "in", "range", "(", "start_epoch", "+", "1", ",", "total_epochs", "+", "1", ")", ":", "\n", "#print('===> Epoch %d' % epoch)", "\n", "        ", "logger", ".", "info", "(", "\"===> train:: Epoch[{}]\"", ".", "format", "(", "epoch", ")", ")", "\n", "epoch_loss", "=", "0", "\n", "epoch_psnr", "=", "0", "\n", "\n", "for", "_", ",", "data", "in", "enumerate", "(", "trainset_loader", ")", ":", "\n", "            ", "current_step", "+=", "1", "\n", "if", "current_step", ">", "total_iters", ":", "\n", "                ", "break", "\n", "\n", "#### update learning rate", "\n", "", "update_learning_rate", "(", "optimizers", ",", "\n", "schedulers", ",", "\n", "cur_iter", "=", "current_step", ",", "\n", "warmup_iter", "=", "opt", ".", "warmup_iter", ")", "\n", "\n", "logger", ".", "info", "(", "\"===> train:: Epoch[{}] \\t Iter-step[{}]\"", ".", "format", "(", "epoch", ",", "current_step", ")", ")", "\n", "y", ",", "x", ",", "sigma", "=", "data", "[", "'LR'", "]", ",", "data", "[", "'HR'", "]", ",", "data", "[", "'sigma'", "]", "\n", "y_ref", "=", "None", "\n", "\n", "if", "opt", ".", "cuda", ":", "\n", "                    ", "y", "=", "y", ".", "cuda", "(", ")", "\n", "x", "=", "x", ".", "cuda", "(", ")", "\n", "#y_ref = y_ref.cuda()", "\n", "sigma", "=", "sigma", ".", "cuda", "(", ")", "\n", "\n", "# generate mixed inputs, targets and mixing coefficient", "\n", "", "if", "(", "opt", ".", "is_mixup", "and", "random", ".", "random", "(", ")", "<", "0.5", ")", ":", "\n", "                ", "x", ",", "y", ",", "sigma", ",", "lam", "=", "utils_common", ".", "mixup_data", "(", "x", ",", "y", ",", "sigma", ",", "alpha", "=", "opt", ".", "alpha", ",", "use_cuda", "=", "opt", ".", "cuda", ")", "\n", "\n", "", "x", "=", "x", ".", "float", "(", ")", "\n", "y", "=", "y", ".", "float", "(", ")", "\n", "sigma", "=", "sigma", ".", "float", "(", ")", "\n", "#print('train x:', x.shape, x.min(), x.max())", "\n", "#print('train y:', y.shape, y.min(), y.max())", "\n", "#print('train sigma:', sigma.shape, sigma.min(), sigma.max())", "\n", "\n", "xhat", ",", "loss", ",", "psnr_batch", ",", "netG", ",", "netD", "=", "train", "(", "x", ",", "y", ",", "y_ref", ",", "sigma", ",", "\n", "netG", ",", "netD", ",", "netF", ",", "\n", "optimizers", ",", "\n", "cri_pix", ",", "l_pix_w", ",", "\n", "cri_fea", ",", "l_fea_w", ",", "\n", "cri_tv", ",", "l_tv_w", ",", "\n", "cri_gan", ",", "l_gan_w", ",", "\n", "filter_low", ",", "filter_high", ",", "\n", "current_step", ")", "\n", "epoch_loss", "+=", "loss", "\n", "epoch_psnr", "+=", "psnr_batch", "\n", "\n", "# save train images", "\n", "gt", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "LR", "=", "y", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "output", "=", "xhat", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "idx", "=", "1", "\n", "for", "j", "in", "range", "(", "gt", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "if", "current_step", "%", "100", "==", "0", ":", "\n", "                    ", "save", "(", "save_train_imgs_path", "+", "'img'", "+", "repr", "(", "idx", ")", "+", "'_GT'", "+", "'.png'", ",", "gt", "[", "j", "]", ")", "\n", "save", "(", "save_train_imgs_path", "+", "'img'", "+", "repr", "(", "idx", ")", "+", "'_LR'", "+", "'.png'", ",", "LR", "[", "j", "]", ")", "\n", "save", "(", "save_train_imgs_path", "+", "'img'", "+", "repr", "(", "idx", ")", "+", "'_SR'", "+", "'.png'", ",", "output", "[", "j", "]", ")", "\n", "\n", "# psnr and ssim", "\n", "", "psnr_SR", "=", "utils_common", ".", "calculate_psnr", "(", "output", "[", "j", "]", ",", "gt", "[", "j", "]", ",", "border", "=", "border", ")", "\n", "ssim_SR", "=", "utils_common", ".", "calculate_ssim", "(", "output", "[", "j", "]", ",", "gt", "[", "j", "]", ",", "border", "=", "border", ")", "\n", "\n", "logger", ".", "info", "(", "'===> train:: {:->4d}--> {:>10s}, SR psnr:{:.2f}dB'", ".", "format", "(", "idx", ",", "save_train_imgs_path", "+", "'img'", "+", "repr", "(", "idx", ")", "+", "'_sr'", "+", "'.png'", ",", "psnr_SR", ")", ")", "\n", "logger", ".", "info", "(", "'===> train:: {:->4d}--> {:>10s}, SR ssim:{:.4f}'", ".", "format", "(", "idx", ",", "save_train_imgs_path", "+", "'img'", "+", "repr", "(", "idx", ")", "+", "'_sr'", "+", "'.png'", ",", "ssim_SR", ")", ")", "\n", "idx", "+=", "1", "\n", "\n", "", "del", "x", "\n", "del", "y", "\n", "del", "y_ref", "\n", "del", "sigma", "\n", "del", "xhat", "\n", "del", "gt", "\n", "del", "LR", "\n", "del", "output", "\n", "torch", ".", "cuda", ".", "empty_cache", "(", ")", "\n", "#break", "\n", "\n", "", "logger", ".", "info", "(", "\"train:: Epoch[{}] Complete: Avg. Loss: {:.6f}\"", ".", "format", "(", "epoch", ",", "epoch_loss", "/", "len", "(", "trainset_loader", ")", ")", ")", "\n", "logger", ".", "info", "(", "\"train:: Epoch[{}] Complete: Avg. PSNR: {:.2f} dB\"", ".", "format", "(", "epoch", ",", "epoch_psnr", "/", "len", "(", "trainset_loader", ")", ")", ")", "\n", "\n", "# testing", "\n", "logger", ".", "info", "(", "'===================== start testing ====================='", ")", "\n", "epoch_psnr_new", ",", "epoch_lpips_new", "=", "test", "(", "netG", ",", "lpips", ",", "epoch", ")", "\n", "logger", ".", "info", "(", "'===================== end testing ====================='", ")", "\n", "\n", "# current learning rate (lr)", "\n", "logger", ".", "info", "(", "\"train:: current lr[{:.8f}]\"", ".", "format", "(", "get_current_learning_rate", "(", "optimizer_G", ")", ")", ")", "\n", "\n", "# saving the best model w.r.t. psnr", "\n", "if", "opt", ".", "saveBest", ":", "\n", "            ", "if", "epoch_psnr_new", ">", "epoch_psnr_old", ":", "\n", "                ", "epoch_psnr_old", "=", "epoch_psnr_new", "\n", "save_checkpoint_best", "(", "best_psnr_save_path", ",", "\n", "epoch", ",", "current_step", ",", "\n", "optimizers", ",", "schedulers", ",", "\n", "{", "'epoch_psnr_old'", ":", "epoch_psnr_old", ",", "\n", "'epoch_lpips_old'", ":", "epoch_lpips_old", "}", ",", "\n", "\"psnr\"", ")", "\n", "save_network", "(", "best_psnr_save_path", ",", "netG", ",", "'G_best_psnr'", ",", "epoch", ")", "\n", "save_network", "(", "best_psnr_save_path", ",", "netD", ",", "'D_best_psnr'", ",", "epoch", ")", "\n", "\n", "# saving the best model w.r.t. lpips", "\n", "", "", "if", "opt", ".", "saveBest", ":", "\n", "            ", "if", "epoch_lpips_new", "<", "epoch_lpips_old", ":", "\n", "                ", "epoch_lpips_old", "=", "epoch_lpips_new", "\n", "save_checkpoint_best", "(", "best_lpips_save_path", ",", "\n", "epoch", ",", "current_step", ",", "\n", "optimizers", ",", "schedulers", ",", "\n", "{", "'epoch_psnr_old'", ":", "epoch_psnr_old", ",", "\n", "'epoch_lpips_old'", ":", "epoch_lpips_old", "}", ",", "\n", "\"lpips\"", ")", "\n", "save_network", "(", "best_lpips_save_path", ",", "netG", ",", "'G_best_lpips'", ",", "epoch", ")", "\n", "save_network", "(", "best_lpips_save_path", ",", "netD", ",", "'D_best_lpips'", ",", "epoch", ")", "\n", "\n", "# save models and training states", "\n", "", "", "if", "epoch", "%", "opt", ".", "save_checkpoint_freq", "==", "0", ":", "\n", "            ", "logger", ".", "info", "(", "'Saving models and training states.'", ")", "\n", "save_network", "(", "netG_save_path", ",", "netG", ",", "'G'", ",", "epoch", ")", "\n", "save_network", "(", "netD_save_path", ",", "netD", ",", "'D'", ",", "epoch", ")", "\n", "save_training_state", "(", "epoch", ",", "current_step", ",", "optimizers", ",", "schedulers", ",", "\n", "{", "'epoch_psnr_old'", ":", "epoch_psnr_old", ",", "\n", "'epoch_lpips_old'", ":", "epoch_lpips_old", "}", ")", "\n", "#break", "\n", "\n", "", "", "logger", ".", "info", "(", "'===================== Saving the final model ====================='", ")", "\n", "# save final network states", "\n", "save_network", "(", "netG_save_path", ",", "netG", ",", "'final_G'", ",", "epoch", ")", "\n", "save_network", "(", "netD_save_path", ",", "netD", ",", "'final_D'", ",", "epoch", ")", "\n", "\n", "logger", ".", "info", "(", "'===================== Training completed in {:.4f} seconds ====================='", ".", "format", "(", "t", ".", "toc", "(", ")", ")", ")", "\n", "logger", ".", "info", "(", "'===================== end training ====================='", ")", "\n", "###############################", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.is_image_file": [[22, 24], ["any", "filename.endswith"], "function", ["None"], ["def", "is_image_file", "(", "filename", ")", ":", "\n", "    ", "return", "any", "(", "filename", ".", "endswith", "(", "extension", ")", "for", "extension", "in", "IMG_EXTENSIONS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.get_timestamp": [[26, 28], ["datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["None"], ["", "def", "get_timestamp", "(", ")", ":", "\n", "    ", "return", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "'%y%m%d-%H%M%S'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.imshow": [[30, 38], ["matplotlib.figure", "matplotlib.imshow", "matplotlib.show", "matplotlib.title", "matplotlib.colorbar"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.imshow"], ["", "def", "imshow", "(", "x", ",", "title", "=", "None", ",", "cbar", "=", "False", ",", "figsize", "=", "None", ")", ":", "\n", "    ", "plt", ".", "figure", "(", "figsize", "=", "figsize", ")", "\n", "plt", ".", "imshow", "(", "x", ",", "interpolation", "=", "'nearest'", ",", "cmap", "=", "'gray'", ")", "\n", "if", "title", ":", "\n", "        ", "plt", ".", "title", "(", "title", ")", "\n", "", "if", "cbar", ":", "\n", "        ", "plt", ".", "colorbar", "(", ")", "\n", "", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.get_image_paths": [[47, 52], ["sorted", "utils_image._get_paths_from_images"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common._get_paths_from_images"], ["def", "get_image_paths", "(", "dataroot", ")", ":", "\n", "    ", "paths", "=", "None", "# return None if dataroot is None", "\n", "if", "dataroot", "is", "not", "None", ":", "\n", "        ", "paths", "=", "sorted", "(", "_get_paths_from_images", "(", "dataroot", ")", ")", "\n", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image._get_paths_from_images": [[54, 64], ["os.path.isdir", "sorted", "os.walk", "sorted", "utils_image.is_image_file", "os.path.join", "images.append"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file"], ["", "def", "_get_paths_from_images", "(", "path", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "isdir", "(", "path", ")", ",", "'{:s} is not a valid directory'", ".", "format", "(", "path", ")", "\n", "images", "=", "[", "]", "\n", "for", "dirpath", ",", "_", ",", "fnames", "in", "sorted", "(", "os", ".", "walk", "(", "path", ")", ")", ":", "\n", "        ", "for", "fname", "in", "sorted", "(", "fnames", ")", ":", "\n", "            ", "if", "is_image_file", "(", "fname", ")", ":", "\n", "                ", "img_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "fname", ")", "\n", "images", ".", "append", "(", "img_path", ")", "\n", "", "", "", "assert", "images", ",", "'{:s} has no valid image file'", ".", "format", "(", "path", ")", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.mkdir": [[73, 76], ["os.path.exists", "os.makedirs"], "function", ["None"], ["def", "mkdir", "(", "path", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.mkdirs": [[78, 84], ["isinstance", "utils_image.mkdir", "utils_image.mkdir"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.mkdir", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.mkdir"], ["", "", "def", "mkdirs", "(", "paths", ")", ":", "\n", "    ", "if", "isinstance", "(", "paths", ",", "str", ")", ":", "\n", "        ", "mkdir", "(", "paths", ")", "\n", "", "else", ":", "\n", "        ", "for", "path", "in", "paths", ":", "\n", "            ", "mkdir", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.mkdir_and_rename": [[86, 92], ["os.path.exists", "os.makedirs", "print", "os.rename", "utils_image.get_timestamp"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.get_timestamp"], ["", "", "", "def", "mkdir_and_rename", "(", "path", ")", ":", "\n", "    ", "if", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "        ", "new_name", "=", "path", "+", "'_archived_'", "+", "get_timestamp", "(", ")", "\n", "print", "(", "'Path already exists. Rename it to [{:s}]'", ".", "format", "(", "new_name", ")", ")", "\n", "os", ".", "rename", "(", "path", ",", "new_name", ")", "\n", "", "os", ".", "makedirs", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.read_img": [[106, 117], ["cv2.imread", "np.expand_dims.astype", "numpy.expand_dims"], "function", ["None"], ["def", "read_img", "(", "path", ")", ":", "\n", "# read image by cv2", "\n", "# return: Numpy float32, HWC, BGR, [0,1]", "\n", "    ", "img", "=", "cv2", ".", "imread", "(", "path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", "# cv2.IMREAD_GRAYSCALE", "\n", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "\n", "# some images have 4 channels", "\n", "", "if", "img", ".", "shape", "[", "2", "]", ">", "3", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ",", ":", "3", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.imread_uint": [[122, 135], ["cv2.imread", "numpy.expand_dims", "cv2.imread", "cv2.cvtColor", "cv2.cvtColor"], "function", ["None"], ["", "def", "imread_uint", "(", "path", ",", "n_channels", "=", "3", ")", ":", "\n", "#  input: path", "\n", "# output: HxWx3(RGB or GGG), or HxWx1 (G)", "\n", "    ", "if", "n_channels", "==", "1", ":", "\n", "        ", "img", "=", "cv2", ".", "imread", "(", "path", ",", "0", ")", "# cv2.IMREAD_GRAYSCALE", "\n", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "# HxWx1", "\n", "", "elif", "n_channels", "==", "3", ":", "\n", "        ", "img", "=", "cv2", ".", "imread", "(", "path", ",", "cv2", ".", "IMREAD_UNCHANGED", ")", "# BGR or G", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "# GGG", "\n", "", "else", ":", "\n", "            ", "img", "=", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2RGB", ")", "# RGB", "\n", "", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.imsave": [[137, 141], ["cv2.imwrite"], "function", ["None"], ["", "def", "imsave", "(", "img", ",", "img_path", ")", ":", "\n", "    ", "if", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ",", "[", "2", ",", "1", ",", "0", "]", "]", "\n", "", "cv2", ".", "imwrite", "(", "img_path", ",", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.unit2single": [[157, 160], ["numpy.float32"], "function", ["None"], ["def", "unit2single", "(", "img", ")", ":", "\n", "\n", "    ", "return", "np", ".", "float32", "(", "img", "/", "255.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.single2uint": [[162, 165], ["numpy.uint8"], "function", ["None"], ["", "def", "single2uint", "(", "img", ")", ":", "\n", "\n", "    ", "return", "np", ".", "uint8", "(", "(", "img", "*", "255.", ")", ".", "round", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.unit162single": [[167, 170], ["numpy.float32"], "function", ["None"], ["", "def", "unit162single", "(", "img", ")", ":", "\n", "\n", "    ", "return", "np", ".", "float32", "(", "img", "/", "65535.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.single2uint16": [[172, 175], ["numpy.uint8"], "function", ["None"], ["", "def", "single2uint16", "(", "img", ")", ":", "\n", "\n", "    ", "return", "np", ".", "uint8", "(", "(", "img", "*", "65535.", ")", ".", "round", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.uint2tensor4": [[184, 188], ["torch.from_numpy().permute().float().div().unsqueeze", "numpy.expand_dims", "torch.from_numpy().permute().float().div", "torch.from_numpy().permute().float", "torch.from_numpy().permute", "torch.from_numpy", "numpy.ascontiguousarray"], "function", ["None"], ["", "def", "uint2tensor4", "(", "img", ")", ":", "\n", "    ", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "\n", "", "return", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "float", "(", ")", ".", "div", "(", "255.", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.uint2tensor3": [[191, 195], ["torch.from_numpy().permute().float().div", "numpy.expand_dims", "torch.from_numpy().permute().float", "torch.from_numpy().permute", "torch.from_numpy", "numpy.ascontiguousarray"], "function", ["None"], ["", "def", "uint2tensor3", "(", "img", ")", ":", "\n", "    ", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "\n", "", "return", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "float", "(", ")", ".", "div", "(", "255.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.tensor2uint": [[198, 203], ["np.transpose.data.squeeze().float().clamp_().cpu().numpy", "numpy.uint8", "numpy.transpose", "np.transpose.data.squeeze().float().clamp_().cpu", "np.transpose.data.squeeze().float().clamp_", "np.transpose.data.squeeze().float", "np.transpose.data.squeeze"], "function", ["None"], ["", "def", "tensor2uint", "(", "img", ")", ":", "\n", "    ", "img", "=", "img", ".", "data", ".", "squeeze", "(", ")", ".", "float", "(", ")", ".", "clamp_", "(", "0", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "img", "=", "np", ".", "transpose", "(", "img", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "return", "np", ".", "uint8", "(", "(", "img", "*", "255.0", ")", ".", "round", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.single2tensor4": [[212, 214], ["torch.from_numpy().permute().float().unsqueeze", "torch.from_numpy().permute().float", "torch.from_numpy().permute", "torch.from_numpy", "numpy.ascontiguousarray"], "function", ["None"], ["", "def", "single2tensor4", "(", "img", ")", ":", "\n", "    ", "return", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "float", "(", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.single2tensor3": [[217, 219], ["torch.from_numpy().permute().float", "torch.from_numpy().permute", "torch.from_numpy", "numpy.ascontiguousarray"], "function", ["None"], ["", "def", "single2tensor3", "(", "img", ")", ":", "\n", "    ", "return", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img", ")", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.tensor2single": [[222, 228], ["np.transpose.data.squeeze().float().clamp_().cpu().numpy", "numpy.transpose", "np.transpose.data.squeeze().float().clamp_().cpu", "np.transpose.data.squeeze().float().clamp_", "np.transpose.data.squeeze().float", "np.transpose.data.squeeze"], "function", ["None"], ["", "def", "tensor2single", "(", "img", ")", ":", "\n", "    ", "img", "=", "img", ".", "data", ".", "squeeze", "(", ")", ".", "float", "(", ")", ".", "clamp_", "(", "0", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "img", "=", "np", ".", "transpose", "(", "img", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.tensor2single3": [[229, 236], ["np.expand_dims.data.squeeze().float().clamp_().cpu().numpy", "numpy.transpose", "np.expand_dims.data.squeeze().float().clamp_().cpu", "numpy.expand_dims", "np.expand_dims.data.squeeze().float().clamp_", "np.expand_dims.data.squeeze().float", "np.expand_dims.data.squeeze"], "function", ["None"], ["", "def", "tensor2single3", "(", "img", ")", ":", "\n", "    ", "img", "=", "img", ".", "data", ".", "squeeze", "(", ")", ".", "float", "(", ")", ".", "clamp_", "(", "0", ",", "1", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "img", "=", "np", ".", "transpose", "(", "img", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "elif", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.tensor2img": [[239, 264], ["tensor.squeeze().float().cpu().clamp_.squeeze().float().cpu().clamp_", "tensor.squeeze().float().cpu().clamp_.dim", "tensor.numpy.astype", "len", "torchvision.utils.make_grid().numpy", "numpy.transpose", "tensor.squeeze().float().cpu().clamp_.squeeze().float().cpu", "tensor.squeeze().float().cpu().clamp_.numpy", "numpy.transpose", "torchvision.utils.make_grid", "tensor.squeeze().float().cpu().clamp_.numpy", "TypeError", "tensor.squeeze().float().cpu().clamp_.squeeze().float", "int", "tensor.squeeze().float().cpu().clamp_.squeeze", "math.sqrt"], "function", ["None"], ["", "def", "tensor2img", "(", "tensor", ",", "out_type", "=", "np", ".", "uint8", ",", "min_max", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "'''\n    Converts a torch Tensor into an image Numpy array of BGR channel order\n    Input: 4D(B,(3/1),H,W), 3D(C,H,W), or 2D(H,W), any range, RGB channel order\n    Output: 3D(H,W,C) or 2D(H,W), [0,255], np.uint8 (default)\n    '''", "\n", "tensor", "=", "tensor", ".", "squeeze", "(", ")", ".", "float", "(", ")", ".", "cpu", "(", ")", ".", "clamp_", "(", "*", "min_max", ")", "# squeeze first, then clamp", "\n", "tensor", "=", "(", "tensor", "-", "min_max", "[", "0", "]", ")", "/", "(", "min_max", "[", "1", "]", "-", "min_max", "[", "0", "]", ")", "# to range [0,1]", "\n", "n_dim", "=", "tensor", ".", "dim", "(", ")", "\n", "if", "n_dim", "==", "4", ":", "\n", "        ", "n_img", "=", "len", "(", "tensor", ")", "\n", "img_np", "=", "make_grid", "(", "tensor", ",", "nrow", "=", "int", "(", "math", ".", "sqrt", "(", "n_img", ")", ")", ",", "normalize", "=", "False", ")", ".", "numpy", "(", ")", "\n", "img_np", "=", "np", ".", "transpose", "(", "img_np", "[", "[", "2", ",", "1", ",", "0", "]", ",", ":", ",", ":", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "# HWC, BGR", "\n", "", "elif", "n_dim", "==", "3", ":", "\n", "        ", "img_np", "=", "tensor", ".", "numpy", "(", ")", "\n", "img_np", "=", "np", ".", "transpose", "(", "img_np", "[", "[", "2", ",", "1", ",", "0", "]", ",", ":", ",", ":", "]", ",", "(", "1", ",", "2", ",", "0", ")", ")", "# HWC, BGR", "\n", "", "elif", "n_dim", "==", "2", ":", "\n", "        ", "img_np", "=", "tensor", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "'Only support 4D, 3D and 2D tensor. But received with dimension: {:d}'", ".", "format", "(", "n_dim", ")", ")", "\n", "", "if", "out_type", "==", "np", ".", "uint8", ":", "\n", "        ", "img_np", "=", "(", "img_np", "*", "255.0", ")", ".", "round", "(", ")", "\n", "# Important. Unlike matlab, numpy.unit8() WILL NOT round by default.", "\n", "", "return", "img_np", ".", "astype", "(", "out_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.augment_img": [[274, 291], ["numpy.flipud", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.rot90", "numpy.rot90", "numpy.flipud", "numpy.rot90"], "function", ["None"], ["def", "augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ")", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "img", ")", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.inv_augment_img": [[292, 309], ["numpy.fliplr", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.fliplr", "numpy.rot90", "numpy.rot90", "numpy.fliplr", "numpy.rot90"], "function", ["None"], ["", "", "def", "inv_augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "img", ")", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "img", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "np", ".", "rot90", "(", "img", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.augment_img_np3": [[311, 337], ["img.transpose.transpose", "img.transpose.transpose", "img.transpose.transpose", "img.transpose.transpose"], "function", ["None"], ["", "", "def", "augment_img_np3", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "return", "img", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.augment_img_tensor": [[339, 354], ["img.size", "img.data.cpu().numpy", "utils_image.augment_img", "torch.from_numpy", "img_tensor.permute.type_as", "len", "numpy.transpose", "numpy.ascontiguousarray", "len", "img_tensor.permute.permute", "img.data.cpu", "len", "numpy.transpose", "len", "img_tensor.permute.permute"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.augment_img"], ["", "", "def", "augment_img_tensor", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "img_size", "=", "img", ".", "size", "(", ")", "\n", "img_np", "=", "img", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "img_np", "=", "augment_img", "(", "img_np", ",", "mode", "=", "mode", ")", "\n", "img_tensor", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img_np", ")", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "return", "img_tensor", ".", "type_as", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.inv_augment_img_tensor": [[355, 370], ["img.size", "img.data.cpu().numpy", "utils_image.inv_augment_img", "torch.from_numpy", "img_tensor.permute.type_as", "len", "numpy.transpose", "numpy.ascontiguousarray", "len", "img_tensor.permute.permute", "img.data.cpu", "len", "numpy.transpose", "len", "img_tensor.permute.permute"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.inv_augment_img"], ["", "def", "inv_augment_img_tensor", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "img_size", "=", "img", ".", "size", "(", ")", "\n", "img_np", "=", "img", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "img_np", "=", "inv_augment_img", "(", "img_np", ",", "mode", "=", "mode", ")", "\n", "img_tensor", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img_np", ")", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "return", "img_tensor", ".", "type_as", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.augment_imgs": [[372, 388], ["utils_image.augment_imgs._augment"], "function", ["None"], ["", "def", "augment_imgs", "(", "img_list", ",", "hflip", "=", "True", ",", "rot", "=", "True", ")", ":", "\n", "# horizontal flip OR rotate", "\n", "    ", "hflip", "=", "hflip", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "vflip", "=", "rot", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "rot90", "=", "rot", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "\n", "def", "_augment", "(", "img", ")", ":", "\n", "        ", "if", "hflip", ":", "\n", "            ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "if", "vflip", ":", "\n", "            ", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "if", "rot90", ":", "\n", "            ", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "", "return", "img", "\n", "\n", "", "return", "[", "_augment", "(", "img", ")", "for", "img", "in", "img_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.rgb2ycbcr": [[402, 424], ["img.astype", "rlt.round.astype", "rlt.round.round", "numpy.dot", "numpy.matmul"], "function", ["None"], ["def", "rgb2ycbcr", "(", "img", ",", "only_y", "=", "True", ")", ":", "\n", "    ", "'''same as matlab rgb2ycbcr\n    only_y: only return Y channel\n    Input:\n        uint8, [0, 255]\n        float, [0, 1]\n    '''", "\n", "in_img_type", "=", "img", ".", "dtype", "\n", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "in_img_type", "!=", "np", ".", "uint8", ":", "\n", "        ", "img", "*=", "255.", "\n", "# convert", "\n", "", "if", "only_y", ":", "\n", "        ", "rlt", "=", "np", ".", "dot", "(", "img", ",", "[", "65.481", ",", "128.553", ",", "24.966", "]", ")", "/", "255.0", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "rlt", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "\n", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", "]", ")", "/", "255.0", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "if", "in_img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "rlt", "=", "rlt", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "rlt", "/=", "255.", "\n", "", "return", "rlt", ".", "astype", "(", "in_img_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.ycbcr2rgb": [[426, 444], ["img.astype", "rlt.round.astype", "rlt.round.round", "numpy.matmul"], "function", ["None"], ["", "def", "ycbcr2rgb", "(", "img", ")", ":", "\n", "    ", "'''same as matlab ycbcr2rgb\n    Input:\n        uint8, [0, 255]\n        float, [0, 1]\n    '''", "\n", "in_img_type", "=", "img", ".", "dtype", "\n", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "in_img_type", "!=", "np", ".", "uint8", ":", "\n", "        ", "img", "*=", "255.", "\n", "# convert", "\n", "", "rlt", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "0.00456621", ",", "0.00456621", ",", "0.00456621", "]", ",", "[", "0", ",", "-", "0.00153632", ",", "0.00791071", "]", ",", "\n", "[", "0.00625893", ",", "-", "0.00318811", ",", "0", "]", "]", ")", "*", "255.0", "+", "[", "-", "222.921", ",", "135.576", ",", "-", "276.836", "]", "\n", "if", "in_img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "rlt", "=", "rlt", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "rlt", "/=", "255.", "\n", "", "return", "rlt", ".", "astype", "(", "in_img_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.bgr2ycbcr": [[446, 468], ["img.astype", "rlt.round.astype", "rlt.round.round", "numpy.dot", "numpy.matmul"], "function", ["None"], ["", "def", "bgr2ycbcr", "(", "img", ",", "only_y", "=", "True", ")", ":", "\n", "    ", "'''bgr version of rgb2ycbcr\n    only_y: only return Y channel\n    Input:\n        uint8, [0, 255]\n        float, [0, 1]\n    '''", "\n", "in_img_type", "=", "img", ".", "dtype", "\n", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "in_img_type", "!=", "np", ".", "uint8", ":", "\n", "        ", "img", "*=", "255.", "\n", "# convert", "\n", "", "if", "only_y", ":", "\n", "        ", "rlt", "=", "np", ".", "dot", "(", "img", ",", "[", "24.966", ",", "128.553", ",", "65.481", "]", ")", "/", "255.0", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "rlt", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "\n", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", "]", ")", "/", "255.0", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "if", "in_img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "rlt", "=", "rlt", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "rlt", "/=", "255.", "\n", "", "return", "rlt", ".", "astype", "(", "in_img_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.modcrop_np": [[470, 484], ["numpy.copy", "ValueError"], "function", ["None"], ["", "def", "modcrop_np", "(", "img_in", ",", "scale", ")", ":", "\n", "# img_in: Numpy, HWC or HW", "\n", "    ", "img", "=", "np", ".", "copy", "(", "img_in", ")", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "H", ",", "W", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", "]", "\n", "", "elif", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "H", ",", "W", ",", "C", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wrong img ndim: [{:d}].'", ".", "format", "(", "img", ".", "ndim", ")", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.modcrop": [[485, 491], ["None"], "function", ["None"], ["", "def", "modcrop", "(", "img", ",", "scale", ")", ":", "\n", "# img: Pytorch, C*H*W ", "\n", "    ", "C", ",", "H", ",", "W", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", ",", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", "]", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.shave": [[492, 498], ["numpy.copy"], "function", ["None"], ["", "def", "shave", "(", "img_in", ",", "border", "=", "0", ")", ":", "\n", "# img_in: Numpy, HWC or HW", "\n", "    ", "img", "=", "np", ".", "copy", "(", "img_in", ")", "\n", "h", ",", "w", "=", "img", ".", "shape", "[", ":", "2", "]", "\n", "img", "=", "img", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.channel_convert": [[500, 512], ["cv2.cvtColor", "numpy.expand_dims", "utils_image.bgr2ycbcr", "numpy.expand_dims", "cv2.cvtColor"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.bgr2ycbcr"], ["", "def", "channel_convert", "(", "in_c", ",", "tar_type", ",", "img_list", ")", ":", "\n", "# conversion among BGR, gray and y", "\n", "    ", "if", "in_c", "==", "3", "and", "tar_type", "==", "'gray'", ":", "# BGR to gray", "\n", "        ", "gray_list", "=", "[", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_BGR2GRAY", ")", "for", "img", "in", "img_list", "]", "\n", "return", "[", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "for", "img", "in", "gray_list", "]", "\n", "", "elif", "in_c", "==", "3", "and", "tar_type", "==", "'y'", ":", "# BGR to y", "\n", "        ", "y_list", "=", "[", "bgr2ycbcr", "(", "img", ",", "only_y", "=", "True", ")", "for", "img", "in", "img_list", "]", "\n", "return", "[", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "for", "img", "in", "y_list", "]", "\n", "", "elif", "in_c", "==", "1", "and", "tar_type", "==", "'RGB'", ":", "# gray/y to BGR", "\n", "        ", "return", "[", "cv2", ".", "cvtColor", "(", "img", ",", "cv2", ".", "COLOR_GRAY2BGR", ")", "for", "img", "in", "img_list", "]", "\n", "", "else", ":", "\n", "        ", "return", "img_list", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.calculate_psnr": [[524, 538], ["img1.astype.astype", "img2.astype.astype", "numpy.mean", "ValueError", "float", "math.log10", "math.sqrt"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.log10"], ["def", "calculate_psnr", "(", "img1", ",", "img2", ",", "border", "=", "0", ")", ":", "\n", "# img1 and img2 have range [0, 255]", "\n", "    ", "if", "not", "img1", ".", "shape", "==", "img2", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "'Input images must have the same dimensions.'", ")", "\n", "", "h", ",", "w", "=", "img1", ".", "shape", "[", ":", "2", "]", "\n", "img1", "=", "img1", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "img2", "=", "img2", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "mse", "=", "np", ".", "mean", "(", "(", "img1", "-", "img2", ")", "**", "2", ")", "\n", "if", "mse", "==", "0", ":", "\n", "        ", "return", "float", "(", "'inf'", ")", "\n", "", "return", "20", "*", "math", ".", "log10", "(", "255.0", "/", "math", ".", "sqrt", "(", "mse", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.calculate_ssim": [[543, 566], ["ValueError", "utils_image.ssim", "ValueError", "range", "numpy.array().mean", "ssims.append", "utils_image.ssim", "utils_image.ssim", "numpy.array", "numpy.squeeze", "numpy.squeeze"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim"], ["", "def", "calculate_ssim", "(", "img1", ",", "img2", ",", "border", "=", "0", ")", ":", "\n", "    ", "'''calculate SSIM\n    the same outputs as MATLAB's\n    img1, img2: [0, 255]\n    '''", "\n", "if", "not", "img1", ".", "shape", "==", "img2", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "'Input images must have the same dimensions.'", ")", "\n", "", "h", ",", "w", "=", "img1", ".", "shape", "[", ":", "2", "]", "\n", "img1", "=", "img1", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "img2", "=", "img2", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "\n", "if", "img1", ".", "ndim", "==", "2", ":", "\n", "        ", "return", "ssim", "(", "img1", ",", "img2", ")", "\n", "", "elif", "img1", ".", "ndim", "==", "3", ":", "\n", "        ", "if", "img1", ".", "shape", "[", "2", "]", "==", "3", ":", "\n", "            ", "ssims", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "                ", "ssims", ".", "append", "(", "ssim", "(", "img1", ",", "img2", ")", ")", "\n", "", "return", "np", ".", "array", "(", "ssims", ")", ".", "mean", "(", ")", "\n", "", "elif", "img1", ".", "shape", "[", "2", "]", "==", "1", ":", "\n", "            ", "return", "ssim", "(", "np", ".", "squeeze", "(", "img1", ")", ",", "np", ".", "squeeze", "(", "img2", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wrong input image dimensions.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.ssim": [[568, 589], ["img1.astype.astype", "img2.astype.astype", "cv2.getGaussianKernel", "numpy.outer", "ssim_map.mean", "cv2.getGaussianKernel.transpose", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D"], "function", ["None"], ["", "", "def", "ssim", "(", "img1", ",", "img2", ")", ":", "\n", "    ", "C1", "=", "(", "0.01", "*", "255", ")", "**", "2", "\n", "C2", "=", "(", "0.03", "*", "255", ")", "**", "2", "\n", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "kernel", "=", "cv2", ".", "getGaussianKernel", "(", "11", ",", "1.5", ")", "\n", "window", "=", "np", ".", "outer", "(", "kernel", ",", "kernel", ".", "transpose", "(", ")", ")", "\n", "\n", "mu1", "=", "cv2", ".", "filter2D", "(", "img1", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "# valid", "\n", "mu2", "=", "cv2", ".", "filter2D", "(", "img2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "\n", "mu1_sq", "=", "mu1", "**", "2", "\n", "mu2_sq", "=", "mu2", "**", "2", "\n", "mu1_mu2", "=", "mu1", "*", "mu2", "\n", "sigma1_sq", "=", "cv2", ".", "filter2D", "(", "img1", "**", "2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu1_sq", "\n", "sigma2_sq", "=", "cv2", ".", "filter2D", "(", "img2", "**", "2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu2_sq", "\n", "sigma12", "=", "cv2", ".", "filter2D", "(", "img1", "*", "img2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu1_mu2", "\n", "\n", "ssim_map", "=", "(", "(", "2", "*", "mu1_mu2", "+", "C1", ")", "*", "(", "2", "*", "sigma12", "+", "C2", ")", ")", "/", "(", "(", "mu1_sq", "+", "mu2_sq", "+", "C1", ")", "*", "\n", "(", "sigma1_sq", "+", "sigma2_sq", "+", "C2", ")", ")", "\n", "return", "ssim_map", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.cubic": [[599, 605], ["torch.abs"], "function", ["None"], ["def", "cubic", "(", "x", ")", ":", "\n", "    ", "absx", "=", "torch", ".", "abs", "(", "x", ")", "\n", "absx2", "=", "absx", "**", "2", "\n", "absx3", "=", "absx", "**", "3", "\n", "return", "(", "1.5", "*", "absx3", "-", "2.5", "*", "absx2", "+", "1", ")", "*", "(", "(", "absx", "<=", "1", ")", ".", "type_as", "(", "absx", ")", ")", "+", "(", "-", "0.5", "*", "absx3", "+", "2.5", "*", "absx2", "-", "4", "*", "absx", "+", "2", ")", "*", "(", "(", "(", "absx", ">", "1", ")", "*", "(", "absx", "<=", "2", ")", ")", ".", "type_as", "(", "absx", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.calculate_weights_indices": [[607, 660], ["torch.linspace", "torch.floor", "torch.sum().view", "torch.sum", "weights.narrow.contiguous", "indices.narrow.contiguous", "math.ceil", "torch.floor.view().expand", "torch.linspace().view().expand", "u.view().expand", "utils_image.cubic", "torch.sum().view.expand", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "indices.narrow.max", "int", "int", "utils_image.cubic", "torch.sum", "indices.narrow.min", "torch.floor.view", "torch.linspace().view", "u.view", "torch.linspace"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic"], ["", "def", "calculate_weights_indices", "(", "in_length", ",", "out_length", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", ":", "\n", "    ", "if", "(", "scale", "<", "1", ")", "and", "(", "antialiasing", ")", ":", "\n", "# Use a modified kernel to simultaneously interpolate and antialias- larger kernel width", "\n", "        ", "kernel_width", "=", "kernel_width", "/", "scale", "\n", "\n", "# Output-space coordinates", "\n", "", "x", "=", "torch", ".", "linspace", "(", "1", ",", "out_length", ",", "out_length", ")", "\n", "\n", "# Input-space coordinates. Calculate the inverse mapping such that 0.5", "\n", "# in output space maps to 0.5 in input space, and 0.5+scale in output", "\n", "# space maps to 1.5 in input space.", "\n", "u", "=", "x", "/", "scale", "+", "0.5", "*", "(", "1", "-", "1", "/", "scale", ")", "\n", "\n", "# What is the left-most pixel that can be involved in the computation?", "\n", "left", "=", "torch", ".", "floor", "(", "u", "-", "kernel_width", "/", "2", ")", "\n", "\n", "# What is the maximum number of pixels that can be involved in the", "\n", "# computation?  Note: it's OK to use an extra pixel here; if the", "\n", "# corresponding weights are all zero, it will be eliminated at the end", "\n", "# of this function.", "\n", "P", "=", "math", ".", "ceil", "(", "kernel_width", ")", "+", "2", "\n", "\n", "# The indices of the input pixels involved in computing the k-th output", "\n", "# pixel are in row k of the indices matrix.", "\n", "indices", "=", "left", ".", "view", "(", "out_length", ",", "1", ")", ".", "expand", "(", "out_length", ",", "P", ")", "+", "torch", ".", "linspace", "(", "0", ",", "P", "-", "1", ",", "P", ")", ".", "view", "(", "\n", "1", ",", "P", ")", ".", "expand", "(", "out_length", ",", "P", ")", "\n", "\n", "# The weights used to compute the k-th output pixel are in row k of the", "\n", "# weights matrix.", "\n", "distance_to_center", "=", "u", ".", "view", "(", "out_length", ",", "1", ")", ".", "expand", "(", "out_length", ",", "P", ")", "-", "indices", "\n", "# apply cubic kernel", "\n", "if", "(", "scale", "<", "1", ")", "and", "(", "antialiasing", ")", ":", "\n", "        ", "weights", "=", "scale", "*", "cubic", "(", "distance_to_center", "*", "scale", ")", "\n", "", "else", ":", "\n", "        ", "weights", "=", "cubic", "(", "distance_to_center", ")", "\n", "# Normalize the weights matrix so that each row sums to 1.", "\n", "", "weights_sum", "=", "torch", ".", "sum", "(", "weights", ",", "1", ")", ".", "view", "(", "out_length", ",", "1", ")", "\n", "weights", "=", "weights", "/", "weights_sum", ".", "expand", "(", "out_length", ",", "P", ")", "\n", "\n", "# If a column in weights is all zero, get rid of it. only consider the first and last column.", "\n", "weights_zero_tmp", "=", "torch", ".", "sum", "(", "(", "weights", "==", "0", ")", ",", "0", ")", "\n", "if", "not", "math", ".", "isclose", "(", "weights_zero_tmp", "[", "0", "]", ",", "0", ",", "rel_tol", "=", "1e-6", ")", ":", "\n", "        ", "indices", "=", "indices", ".", "narrow", "(", "1", ",", "1", ",", "P", "-", "2", ")", "\n", "weights", "=", "weights", ".", "narrow", "(", "1", ",", "1", ",", "P", "-", "2", ")", "\n", "", "if", "not", "math", ".", "isclose", "(", "weights_zero_tmp", "[", "-", "1", "]", ",", "0", ",", "rel_tol", "=", "1e-6", ")", ":", "\n", "        ", "indices", "=", "indices", ".", "narrow", "(", "1", ",", "0", ",", "P", "-", "2", ")", "\n", "weights", "=", "weights", ".", "narrow", "(", "1", ",", "0", ",", "P", "-", "2", ")", "\n", "", "weights", "=", "weights", ".", "contiguous", "(", ")", "\n", "indices", "=", "indices", ".", "contiguous", "(", ")", "\n", "sym_len_s", "=", "-", "indices", ".", "min", "(", ")", "+", "1", "\n", "sym_len_e", "=", "indices", ".", "max", "(", ")", "-", "in_length", "\n", "indices", "=", "indices", "+", "sym_len_s", "-", "1", "\n", "return", "weights", ",", "indices", ",", "int", "(", "sym_len_s", ")", ",", "int", "(", "sym_len_e", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.imresize": [[665, 733], ["img.size", "utils_image.calculate_weights_indices", "utils_image.calculate_weights_indices", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_H.size", "range", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_W.size", "range", "img.unsqueeze_", "math.ceil", "math.ceil", "int", "range", "int", "range", "torch.FloatTensor.squeeze_", "img.dim", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "img_aug[].transpose().mv", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "out_1_aug[].mv", "sym_patch.size", "sym_patch.size", "img_aug[].transpose", "sym_patch.size", "sym_patch.size"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices"], ["", "def", "imresize", "(", "img", ",", "scale", ",", "antialiasing", "=", "True", ")", ":", "\n", "# Now the scale should be the same for H and W", "\n", "# input: img: pytorch tensor, CHW or HW [0,1]", "\n", "# output: CHW or HW [0,1] w/o round", "\n", "    ", "need_squeeze", "=", "True", "if", "img", ".", "dim", "(", ")", "==", "2", "else", "False", "\n", "if", "need_squeeze", ":", "\n", "        ", "img", ".", "unsqueeze_", "(", "0", ")", "\n", "", "in_C", ",", "in_H", ",", "in_W", "=", "img", ".", "size", "(", ")", "\n", "out_C", ",", "out_H", ",", "out_W", "=", "in_C", ",", "math", ".", "ceil", "(", "in_H", "*", "scale", ")", ",", "math", ".", "ceil", "(", "in_W", "*", "scale", ")", "\n", "kernel_width", "=", "4", "\n", "kernel", "=", "'cubic'", "\n", "\n", "# Return the desired dimension order for performing the resize.  The", "\n", "# strategy is to perform the resize first along the dimension with the", "\n", "# smallest scale factor.", "\n", "# Now we do not support this.", "\n", "\n", "# get weights and indices", "\n", "weights_H", ",", "indices_H", ",", "sym_len_Hs", ",", "sym_len_He", "=", "calculate_weights_indices", "(", "\n", "in_H", ",", "out_H", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", "\n", "weights_W", ",", "indices_W", ",", "sym_len_Ws", ",", "sym_len_We", "=", "calculate_weights_indices", "(", "\n", "in_W", ",", "out_W", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", "\n", "# process H dimension", "\n", "# symmetric copying", "\n", "img_aug", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "in_H", "+", "sym_len_Hs", "+", "sym_len_He", ",", "in_W", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "sym_len_Hs", ",", "in_H", ")", ".", "copy_", "(", "img", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", ",", ":", "sym_len_Hs", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "0", ",", "sym_len_Hs", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", ",", "-", "sym_len_He", ":", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "sym_len_Hs", "+", "in_H", ",", "sym_len_He", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_1", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "out_H", ",", "in_W", ")", "\n", "kernel_width", "=", "weights_H", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_H", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_H", "[", "i", "]", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "out_C", ")", ":", "\n", "            ", "out_1", "[", "j", ",", "i", ",", ":", "]", "=", "img_aug", "[", "j", ",", "idx", ":", "idx", "+", "kernel_width", ",", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "mv", "(", "weights_H", "[", "i", "]", ")", "\n", "\n", "# process W dimension", "\n", "# symmetric copying", "\n", "", "", "out_1_aug", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "out_H", ",", "in_W", "+", "sym_len_Ws", "+", "sym_len_We", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "sym_len_Ws", ",", "in_W", ")", ".", "copy_", "(", "out_1", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", ",", ":", "sym_len_Ws", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "2", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "2", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "0", ",", "sym_len_Ws", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", ",", "-", "sym_len_We", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "2", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "2", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "sym_len_Ws", "+", "in_W", ",", "sym_len_We", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_2", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "out_H", ",", "out_W", ")", "\n", "kernel_width", "=", "weights_W", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_W", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_W", "[", "i", "]", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "out_C", ")", ":", "\n", "            ", "out_2", "[", "j", ",", ":", ",", "i", "]", "=", "out_1_aug", "[", "j", ",", ":", ",", "idx", ":", "idx", "+", "kernel_width", "]", ".", "mv", "(", "weights_W", "[", "i", "]", ")", "\n", "", "", "if", "need_squeeze", ":", "\n", "        ", "out_2", ".", "squeeze_", "(", ")", "\n", "", "return", "out_2", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.imresize_np": [[738, 809], ["torch.from_numpy", "torch.from_numpy.size", "utils_image.calculate_weights_indices", "utils_image.calculate_weights_indices", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_H.size", "range", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_W.size", "range", "torch.FloatTensor.numpy", "torch.from_numpy.unsqueeze_", "math.ceil", "math.ceil", "int", "range", "int", "range", "torch.FloatTensor.squeeze_", "torch.from_numpy.dim", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "img_aug[].transpose().mv", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "out_1_aug[].mv", "sym_patch.size", "sym_patch.size", "img_aug[].transpose", "sym_patch.size", "sym_patch.size"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices"], ["", "def", "imresize_np", "(", "img", ",", "scale", ",", "antialiasing", "=", "True", ")", ":", "\n", "# Now the scale should be the same for H and W", "\n", "# input: img: Numpy, HWC or HW [0,1]", "\n", "# output: HWC or HW [0,1] w/o round", "\n", "    ", "img", "=", "torch", ".", "from_numpy", "(", "img", ")", "\n", "need_squeeze", "=", "True", "if", "img", ".", "dim", "(", ")", "==", "2", "else", "False", "\n", "if", "need_squeeze", ":", "\n", "        ", "img", ".", "unsqueeze_", "(", "2", ")", "\n", "\n", "", "in_H", ",", "in_W", ",", "in_C", "=", "img", ".", "size", "(", ")", "\n", "out_C", ",", "out_H", ",", "out_W", "=", "in_C", ",", "math", ".", "ceil", "(", "in_H", "*", "scale", ")", ",", "math", ".", "ceil", "(", "in_W", "*", "scale", ")", "\n", "kernel_width", "=", "4", "\n", "kernel", "=", "'cubic'", "\n", "\n", "# Return the desired dimension order for performing the resize.  The", "\n", "# strategy is to perform the resize first along the dimension with the", "\n", "# smallest scale factor.", "\n", "# Now we do not support this.", "\n", "\n", "# get weights and indices", "\n", "weights_H", ",", "indices_H", ",", "sym_len_Hs", ",", "sym_len_He", "=", "calculate_weights_indices", "(", "\n", "in_H", ",", "out_H", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", "\n", "weights_W", ",", "indices_W", ",", "sym_len_Ws", ",", "sym_len_We", "=", "calculate_weights_indices", "(", "\n", "in_W", ",", "out_W", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", "\n", "# process H dimension", "\n", "# symmetric copying", "\n", "img_aug", "=", "torch", ".", "FloatTensor", "(", "in_H", "+", "sym_len_Hs", "+", "sym_len_He", ",", "in_W", ",", "in_C", ")", "\n", "img_aug", ".", "narrow", "(", "0", ",", "sym_len_Hs", ",", "in_H", ")", ".", "copy_", "(", "img", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", "sym_len_Hs", ",", ":", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "0", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "0", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "0", ",", "0", ",", "sym_len_Hs", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "img", "[", "-", "sym_len_He", ":", ",", ":", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "0", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "0", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "0", ",", "sym_len_Hs", "+", "in_H", ",", "sym_len_He", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_1", "=", "torch", ".", "FloatTensor", "(", "out_H", ",", "in_W", ",", "in_C", ")", "\n", "kernel_width", "=", "weights_H", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_H", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_H", "[", "i", "]", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "out_C", ")", ":", "\n", "            ", "out_1", "[", "i", ",", ":", ",", "j", "]", "=", "img_aug", "[", "idx", ":", "idx", "+", "kernel_width", ",", ":", ",", "j", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "mv", "(", "weights_H", "[", "i", "]", ")", "\n", "\n", "# process W dimension", "\n", "# symmetric copying", "\n", "", "", "out_1_aug", "=", "torch", ".", "FloatTensor", "(", "out_H", ",", "in_W", "+", "sym_len_Ws", "+", "sym_len_We", ",", "in_C", ")", "\n", "out_1_aug", ".", "narrow", "(", "1", ",", "sym_len_Ws", ",", "in_W", ")", ".", "copy_", "(", "out_1", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", "sym_len_Ws", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "1", ",", "0", ",", "sym_len_Ws", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", "-", "sym_len_We", ":", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "1", ",", "sym_len_Ws", "+", "in_W", ",", "sym_len_We", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_2", "=", "torch", ".", "FloatTensor", "(", "out_H", ",", "out_W", ",", "in_C", ")", "\n", "kernel_width", "=", "weights_W", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_W", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_W", "[", "i", "]", "[", "0", "]", ")", "\n", "for", "j", "in", "range", "(", "out_C", ")", ":", "\n", "            ", "out_2", "[", ":", ",", "i", ",", "j", "]", "=", "out_1_aug", "[", ":", ",", "idx", ":", "idx", "+", "kernel_width", ",", "j", "]", ".", "mv", "(", "weights_W", "[", "i", "]", ")", "\n", "", "", "if", "need_squeeze", ":", "\n", "        ", "out_2", ".", "squeeze_", "(", ")", "\n", "\n", "", "return", "out_2", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.is_image_file": [[12, 14], ["any", "filename.endswith"], "function", ["None"], ["def", "is_image_file", "(", "filename", ")", ":", "\n", "    ", "return", "any", "(", "filename", ".", "endswith", "(", "extension", ")", "for", "extension", "in", "[", "'.png'", ",", "'.jpg'", ",", "'.jpeg'", ",", "'.PNG'", ",", "'.JPG'", ",", "'.JPEG'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.calculate_valid_crop_size": [[16, 18], ["None"], "function", ["None"], ["", "def", "calculate_valid_crop_size", "(", "crop_size", ",", "upscale_factor", ")", ":", "\n", "    ", "return", "crop_size", "-", "(", "crop_size", "%", "upscale_factor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.gaussian_noise": [[20, 23], ["numpy.rint", "PIL.Image.fromarray", "numpy.random.normal", "numpy.clip().astype", "numpy.shape", "numpy.clip"], "function", ["None"], ["", "def", "gaussian_noise", "(", "image", ",", "std_dev", ")", ":", "\n", "    ", "noise", "=", "np", ".", "rint", "(", "np", ".", "random", ".", "normal", "(", "loc", "=", "0.0", ",", "scale", "=", "std_dev", ",", "size", "=", "np", ".", "shape", "(", "image", ")", ")", ")", "\n", "return", "Image", ".", "fromarray", "(", "np", ".", "clip", "(", "image", "+", "noise", ",", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.display_transform": [[25, 31], ["torchvision.transforms.Compose", "torchvision.transforms.ToPILImage", "torchvision.transforms.Resize", "torchvision.transforms.CenterCrop", "torchvision.transforms.ToTensor"], "function", ["None"], ["", "def", "display_transform", "(", ")", ":", "\n", "    ", "return", "Compose", "(", "[", "\n", "ToPILImage", "(", ")", ",", "\n", "Resize", "(", "400", ")", ",", "\n", "CenterCrop", "(", "400", ")", ",", "\n", "ToTensor", "(", ")", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.cubic": [[37, 44], ["torch.abs"], "function", ["None"], ["", "def", "cubic", "(", "x", ")", ":", "\n", "    ", "absx", "=", "torch", ".", "abs", "(", "x", ")", "\n", "absx2", "=", "absx", "**", "2", "\n", "absx3", "=", "absx", "**", "3", "\n", "return", "(", "1.5", "*", "absx3", "-", "2.5", "*", "absx2", "+", "1", ")", "*", "(", "\n", "(", "absx", "<=", "1", ")", ".", "type_as", "(", "absx", ")", ")", "+", "(", "-", "0.5", "*", "absx3", "+", "2.5", "*", "absx2", "-", "4", "*", "absx", "+", "2", ")", "*", "(", "(", "\n", "(", "absx", ">", "1", ")", "*", "(", "absx", "<=", "2", ")", ")", ".", "type_as", "(", "absx", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.calculate_weights_indices": [[46, 99], ["torch.linspace", "torch.floor", "torch.sum().view", "torch.sum", "weights.narrow.contiguous", "indices.narrow.contiguous", "math.ceil", "torch.floor.view().expand", "torch.linspace().view().expand", "u.view().expand", "utils_dsgan.cubic", "torch.sum().view.expand", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "indices.narrow.max", "int", "int", "utils_dsgan.cubic", "torch.sum", "indices.narrow.min", "torch.floor.view", "torch.linspace().view", "u.view", "torch.linspace"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic"], ["", "def", "calculate_weights_indices", "(", "in_length", ",", "out_length", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", ":", "\n", "    ", "if", "(", "scale", "<", "1", ")", "and", "(", "antialiasing", ")", ":", "\n", "# Use a modified kernel to simultaneously interpolate and antialias- larger kernel width", "\n", "        ", "kernel_width", "=", "kernel_width", "/", "scale", "\n", "\n", "# Output-space coordinates", "\n", "", "x", "=", "torch", ".", "linspace", "(", "1", ",", "out_length", ",", "out_length", ")", "\n", "\n", "# Input-space coordinates. Calculate the inverse mapping such that 0.5", "\n", "# in output space maps to 0.5 in input space, and 0.5+scale in output", "\n", "# space maps to 1.5 in input space.", "\n", "u", "=", "x", "/", "scale", "+", "0.5", "*", "(", "1", "-", "1", "/", "scale", ")", "\n", "\n", "# What is the left-most pixel that can be involved in the computation?", "\n", "left", "=", "torch", ".", "floor", "(", "u", "-", "kernel_width", "/", "2", ")", "\n", "\n", "# What is the maximum number of pixels that can be involved in the", "\n", "# computation?  Note: it's OK to use an extra pixel here; if the", "\n", "# corresponding weights are all zero, it will be eliminated at the end", "\n", "# of this function.", "\n", "P", "=", "math", ".", "ceil", "(", "kernel_width", ")", "+", "2", "\n", "\n", "# The indices of the input pixels involved in computing the k-th output", "\n", "# pixel are in row k of the indices matrix.", "\n", "indices", "=", "left", ".", "view", "(", "out_length", ",", "1", ")", ".", "expand", "(", "out_length", ",", "P", ")", "+", "torch", ".", "linspace", "(", "0", ",", "P", "-", "1", ",", "P", ")", ".", "view", "(", "\n", "1", ",", "P", ")", ".", "expand", "(", "out_length", ",", "P", ")", "\n", "\n", "# The weights used to compute the k-th output pixel are in row k of the", "\n", "# weights matrix.", "\n", "distance_to_center", "=", "u", ".", "view", "(", "out_length", ",", "1", ")", ".", "expand", "(", "out_length", ",", "P", ")", "-", "indices", "\n", "# apply cubic kernel", "\n", "if", "(", "scale", "<", "1", ")", "and", "(", "antialiasing", ")", ":", "\n", "        ", "weights", "=", "scale", "*", "cubic", "(", "distance_to_center", "*", "scale", ")", "\n", "", "else", ":", "\n", "        ", "weights", "=", "cubic", "(", "distance_to_center", ")", "\n", "# Normalize the weights matrix so that each row sums to 1.", "\n", "", "weights_sum", "=", "torch", ".", "sum", "(", "weights", ",", "1", ")", ".", "view", "(", "out_length", ",", "1", ")", "\n", "weights", "=", "weights", "/", "weights_sum", ".", "expand", "(", "out_length", ",", "P", ")", "\n", "\n", "# If a column in weights is all zero, get rid of it. only consider the first and last column.", "\n", "weights_zero_tmp", "=", "torch", ".", "sum", "(", "(", "weights", "==", "0", ")", ",", "0", ")", "\n", "if", "not", "math", ".", "isclose", "(", "weights_zero_tmp", "[", "0", "]", ",", "0", ",", "rel_tol", "=", "1e-6", ")", ":", "\n", "        ", "indices", "=", "indices", ".", "narrow", "(", "1", ",", "1", ",", "P", "-", "2", ")", "\n", "weights", "=", "weights", ".", "narrow", "(", "1", ",", "1", ",", "P", "-", "2", ")", "\n", "", "if", "not", "math", ".", "isclose", "(", "weights_zero_tmp", "[", "-", "1", "]", ",", "0", ",", "rel_tol", "=", "1e-6", ")", ":", "\n", "        ", "indices", "=", "indices", ".", "narrow", "(", "1", ",", "0", ",", "P", "-", "2", ")", "\n", "weights", "=", "weights", ".", "narrow", "(", "1", ",", "0", ",", "P", "-", "2", ")", "\n", "", "weights", "=", "weights", ".", "contiguous", "(", ")", "\n", "indices", "=", "indices", ".", "contiguous", "(", ")", "\n", "sym_len_s", "=", "-", "indices", ".", "min", "(", ")", "+", "1", "\n", "sym_len_e", "=", "indices", ".", "max", "(", ")", "-", "in_length", "\n", "indices", "=", "indices", "+", "sym_len_s", "-", "1", "\n", "return", "weights", ",", "indices", ",", "int", "(", "sym_len_s", ")", ",", "int", "(", "sym_len_e", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_dsgan.imresize": [[101, 168], ["img.size", "utils_dsgan.calculate_weights_indices", "utils_dsgan.calculate_weights_indices", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_H.size", "range", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_W.size", "range", "torch.clamp", "math.ceil", "math.ceil", "int", "img_aug[].transpose().mv", "img_aug[].transpose().mv", "img_aug[].transpose().mv", "int", "out_1_aug[].mv", "out_1_aug[].mv", "out_1_aug[].mv", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "img_aug[].transpose", "img_aug[].transpose", "img_aug[].transpose", "sym_patch.size", "sym_patch.size", "sym_patch.size", "sym_patch.size"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices"], ["", "def", "imresize", "(", "img", ",", "scale", ",", "antialiasing", "=", "True", ")", ":", "\n", "# Now the scale should be the same for H and W", "\n", "# input: img: CHW RGB [0,1]", "\n", "# output: CHW RGB [0,1] w/o round", "\n", "\n", "    ", "in_C", ",", "in_H", ",", "in_W", "=", "img", ".", "size", "(", ")", "\n", "_", ",", "out_H", ",", "out_W", "=", "in_C", ",", "math", ".", "ceil", "(", "in_H", "*", "scale", ")", ",", "math", ".", "ceil", "(", "in_W", "*", "scale", ")", "\n", "kernel_width", "=", "4", "\n", "kernel", "=", "'cubic'", "\n", "\n", "# Return the desired dimension order for performing the resize.  The", "\n", "# strategy is to perform the resize first along the dimension with the", "\n", "# smallest scale factor.", "\n", "# Now we do not support this.", "\n", "\n", "# get weights and indices", "\n", "weights_H", ",", "indices_H", ",", "sym_len_Hs", ",", "sym_len_He", "=", "calculate_weights_indices", "(", "\n", "in_H", ",", "out_H", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", "\n", "weights_W", ",", "indices_W", ",", "sym_len_Ws", ",", "sym_len_We", "=", "calculate_weights_indices", "(", "\n", "in_W", ",", "out_W", ",", "scale", ",", "kernel", ",", "kernel_width", ",", "antialiasing", ")", "\n", "# process H dimension", "\n", "# symmetric copying", "\n", "img_aug", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "in_H", "+", "sym_len_Hs", "+", "sym_len_He", ",", "in_W", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "sym_len_Hs", ",", "in_H", ")", ".", "copy_", "(", "img", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", ",", ":", "sym_len_Hs", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "0", ",", "sym_len_Hs", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "img", "[", ":", ",", "-", "sym_len_He", ":", ",", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "1", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "1", ",", "inv_idx", ")", "\n", "img_aug", ".", "narrow", "(", "1", ",", "sym_len_Hs", "+", "in_H", ",", "sym_len_He", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_1", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "out_H", ",", "in_W", ")", "\n", "kernel_width", "=", "weights_H", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_H", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_H", "[", "i", "]", "[", "0", "]", ")", "\n", "out_1", "[", "0", ",", "i", ",", ":", "]", "=", "img_aug", "[", "0", ",", "idx", ":", "idx", "+", "kernel_width", ",", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "mv", "(", "weights_H", "[", "i", "]", ")", "\n", "out_1", "[", "1", ",", "i", ",", ":", "]", "=", "img_aug", "[", "1", ",", "idx", ":", "idx", "+", "kernel_width", ",", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "mv", "(", "weights_H", "[", "i", "]", ")", "\n", "out_1", "[", "2", ",", "i", ",", ":", "]", "=", "img_aug", "[", "2", ",", "idx", ":", "idx", "+", "kernel_width", ",", ":", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "mv", "(", "weights_H", "[", "i", "]", ")", "\n", "\n", "# process W dimension", "\n", "# symmetric copying", "\n", "", "out_1_aug", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "out_H", ",", "in_W", "+", "sym_len_Ws", "+", "sym_len_We", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "sym_len_Ws", ",", "in_W", ")", ".", "copy_", "(", "out_1", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", ",", ":", "sym_len_Ws", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "2", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "2", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "0", ",", "sym_len_Ws", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "sym_patch", "=", "out_1", "[", ":", ",", ":", ",", "-", "sym_len_We", ":", "]", "\n", "inv_idx", "=", "torch", ".", "arange", "(", "sym_patch", ".", "size", "(", "2", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "long", "(", ")", "\n", "sym_patch_inv", "=", "sym_patch", ".", "index_select", "(", "2", ",", "inv_idx", ")", "\n", "out_1_aug", ".", "narrow", "(", "2", ",", "sym_len_Ws", "+", "in_W", ",", "sym_len_We", ")", ".", "copy_", "(", "sym_patch_inv", ")", "\n", "\n", "out_2", "=", "torch", ".", "FloatTensor", "(", "in_C", ",", "out_H", ",", "out_W", ")", "\n", "kernel_width", "=", "weights_W", ".", "size", "(", "1", ")", "\n", "for", "i", "in", "range", "(", "out_W", ")", ":", "\n", "        ", "idx", "=", "int", "(", "indices_W", "[", "i", "]", "[", "0", "]", ")", "\n", "out_2", "[", "0", ",", ":", ",", "i", "]", "=", "out_1_aug", "[", "0", ",", ":", ",", "idx", ":", "idx", "+", "kernel_width", "]", ".", "mv", "(", "weights_W", "[", "i", "]", ")", "\n", "out_2", "[", "1", ",", ":", ",", "i", "]", "=", "out_1_aug", "[", "1", ",", ":", ",", "idx", ":", "idx", "+", "kernel_width", "]", ".", "mv", "(", "weights_W", "[", "i", "]", ")", "\n", "out_2", "[", "2", ",", ":", ",", "i", "]", "=", "out_1_aug", "[", "2", ",", ":", ",", "idx", ":", "idx", "+", "kernel_width", "]", ".", "mv", "(", "weights_W", "[", "i", "]", ")", "\n", "\n", "", "return", "torch", ".", "clamp", "(", "out_2", ",", "0", ",", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_print.__init__": [[48, 51], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "log_path", "=", "\"default.log\"", ")", ":", "\n", "        ", "self", ".", "terminal", "=", "sys", ".", "stdout", "\n", "self", ".", "log", "=", "open", "(", "log_path", ",", "'a'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_print.write": [[52, 55], ["utils_logger.logger_print.terminal.write", "utils_logger.logger_print.log.write"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_print.write", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_print.write"], ["", "def", "write", "(", "self", ",", "message", ")", ":", "\n", "        ", "self", ".", "terminal", ".", "write", "(", "message", ")", "\n", "self", ".", "log", ".", "write", "(", "message", ")", "# write the message", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_print.flush": [[56, 58], ["None"], "methods", ["None"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.timer.__init__": [[66, 69], ["utils_logger.timer.tic"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.tic"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "=", "0", "\n", "self", ".", "tic", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.timer.tic": [[70, 72], ["time.time"], "methods", ["None"], ["", "def", "tic", "(", "self", ")", ":", "\n", "        ", "self", ".", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.timer.toc": [[73, 77], ["time.time", "time.time"], "methods", ["None"], ["", "def", "toc", "(", "self", ",", "restart", "=", "False", ")", ":", "\n", "        ", "diff", "=", "time", ".", "time", "(", ")", "-", "self", ".", "t0", "\n", "if", "restart", ":", "self", ".", "t0", "=", "time", ".", "time", "(", ")", "\n", "return", "diff", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.timer.hold": [[78, 80], ["utils_logger.timer.toc"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.toc"], ["", "def", "hold", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "+=", "self", ".", "toc", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.timer.release": [[81, 86], ["None"], "methods", ["None"], ["", "def", "release", "(", "self", ")", ":", "\n", "        ", "ret", "=", "self", ".", "acc", "\n", "self", ".", "acc", "=", "0", "\n", "\n", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.timer.reset": [[87, 89], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log": [[7, 9], ["print", "datetime.datetime.now().strftime", "datetime.datetime.now"], "function", ["None"], ["def", "log", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "print", "(", "datetime", ".", "datetime", ".", "now", "(", ")", ".", "strftime", "(", "\"%Y-%m-%d %H:%M:%S:\"", ")", ",", "*", "args", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.logger_info": [[19, 38], ["logging.getLogger", "logging.getLogger.hasHandlers", "print", "print", "logging.Formatter", "logging.FileHandler", "logging.FileHandler.setFormatter", "logging.getLogger.setLevel", "logging.getLogger.addHandler", "logging.StreamHandler", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler"], "function", ["None"], ["def", "logger_info", "(", "logger_name", ",", "log_path", "=", "'default_logger.log'", ")", ":", "\n", "    ", "''' set up logger\n    '''", "\n", "log", "=", "logging", ".", "getLogger", "(", "logger_name", ")", "\n", "if", "log", ".", "hasHandlers", "(", ")", ":", "\n", "        ", "print", "(", "'LogHandlers exists!'", ")", "\n", "", "else", ":", "\n", "        ", "print", "(", "'LogHandlers setup!'", ")", "\n", "level", "=", "logging", ".", "INFO", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "'%(asctime)s.%(msecs)03d : %(message)s'", ",", "datefmt", "=", "'%y-%m-%d %H:%M:%S'", ")", "\n", "fh", "=", "logging", ".", "FileHandler", "(", "log_path", ",", "mode", "=", "'a'", ")", "\n", "fh", ".", "setFormatter", "(", "formatter", ")", "\n", "log", ".", "setLevel", "(", "level", ")", "\n", "log", ".", "addHandler", "(", "fh", ")", "\n", "# print(len(log.handlers))", "\n", "\n", "sh", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "sh", ".", "setFormatter", "(", "formatter", ")", "\n", "log", ".", "addHandler", "(", "sh", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.MSEGradLoss.__init__": [[241, 246], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "grad", "=", "False", ")", ":", "\n", "\n", "        ", "super", "(", "MSEGradLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "grad", "=", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.MSEGradLoss.forward": [[247, 254], ["err.norm().pow().div", "err.numel", "utils.utils_model.utils_model.imGrad().norm().pow().div", "err.norm().pow", "err.numel", "utils.utils_model.utils_model.imGrad().norm().pow", "err.norm", "utils.utils_model.utils_model.imGrad().norm", "utils.utils_model.utils_model.imGrad"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imGrad"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "err", "=", "input", "-", "target", "\n", "loss", "=", "err", ".", "norm", "(", "p", "=", "2", ")", ".", "pow", "(", "2", ")", ".", "div", "(", "err", ".", "numel", "(", ")", ")", "\n", "if", "self", ".", "grad", ":", "\n", "            ", "loss", "+=", "utils", ".", "imGrad", "(", "err", ",", "bc", "=", "'reflexive'", ")", ".", "norm", "(", "p", "=", "2", ")", ".", "pow", "(", "2", ")", ".", "div", "(", "err", ".", "numel", "(", ")", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.MSEGradLoss.__repr__": [[255, 258], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "'('", "+", "'gradMSE = '", "+", "str", "(", "self", ".", "grad", ")", "+", "')'", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.L1GradLoss.__init__": [[260, 265], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "grad", "=", "False", ")", ":", "\n", "\n", "        ", "super", "(", "L1GradLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "grad", "=", "grad", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.L1GradLoss.forward": [[266, 274], ["err.norm().div", "err.numel", "utils.utils_model.utils_model.imGrad().norm().div", "err.norm", "err.numel", "utils.utils_model.utils_model.imGrad().norm", "utils.utils_model.utils_model.imGrad"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imGrad"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "err", "=", "input", "-", "target", "\n", "#loss = err.view(-1,1).abs().sum().div(err.numel())", "\n", "loss", "=", "err", ".", "norm", "(", "p", "=", "1", ")", ".", "div", "(", "err", ".", "numel", "(", ")", ")", "\n", "if", "self", ".", "grad", ":", "\n", "            ", "loss", "+=", "utils", ".", "imGrad", "(", "err", ",", "bc", "=", "'reflexive'", ")", ".", "norm", "(", "p", "=", "1", ")", ".", "div", "(", "err", ".", "numel", "(", ")", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.L1GradLoss.__repr__": [[275, 278], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "'('", "+", "'gradL1 = '", "+", "str", "(", "self", ".", "grad", ")", "+", "')'", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.PSNRLoss.__init__": [[281, 287], ["torch.Module.__init__", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log"], ["    ", "def", "__init__", "(", "self", ",", "peakval", "=", "255.0", ")", ":", "\n", "\n", "        ", "super", "(", "PSNRLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "peakval", "=", "peakval", "\n", "self", ".", "log10", "=", "1", "/", "torch", ".", "log", "(", "torch", ".", "FloatTensor", "(", "[", "10", "]", ")", ")", ".", "numpy", "(", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.PSNRLoss.forward": [[288, 305], ["target.size", "range", "torch.mse_loss", "torch.mse_loss", "torch.mse_loss", "target.view().max", "torch.mse_loss.data.cpu().numpy", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "target.view", "torch.mse_loss.data.cpu", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.mse_loss", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.mse_loss", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.mse_loss", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log"], ["", "def", "forward", "(", "self", ",", "input", ",", "target", ")", ":", "\n", "        ", "N", ",", "C", ",", "H", ",", "W", "=", "target", ".", "size", "(", ")", "\n", "\n", "if", "self", ".", "peakVal", "is", "None", ":", "\n", "            ", "self", ".", "peakVal", "=", "target", ".", "view", "(", "N", ",", "-", "1", ")", ".", "max", "(", "dim", "=", "1", ")", "[", "0", "]", "\n", "\n", "", "loss", "=", "0", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "mse", "=", "F", ".", "mse_loss", "(", "input", "[", "i", "]", ",", "target", "[", "i", "]", ")", "\n", "\n", "if", "mse", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "==", "0", ":", "\n", "                ", "loss", "+=", "100", "\n", "continue", "\n", "", "loss", "+=", "20", "*", "torch", ".", "log", "(", "self", ".", "peakval", "/", "torch", ".", "sqrt", "(", "mse", ")", ")", "*", "self", ".", "log10", "\n", "", "loss", "/=", "N", "\n", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.PSNRLoss.__repr__": [[306, 309], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__class__", ".", "__name__", "+", "'('", "+", "'peakVal = '", "+", "str", "(", "self", ".", "peakval", ")", "+", "')'", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.generate_noisy": [[14, 32], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "x_noise.clamp", "torch.randn", "torch.randn", "torch.randn"], "function", ["None"], ["def", "generate_noisy", "(", "x", ",", "nstd", ",", "random_seed", "=", "20180102", ")", ":", "\n", "    ", "\"\"\"\n    This function generates noisy images from clear ones.\n    Input:\n        x: (N, C, H, W) \n        nstd: noise sigma added to clean image\n    \"\"\"", "\n", "shape", "=", "x", ".", "shape", "\n", "dtype", "=", "x", ".", "dtype", "\n", "sigma", "=", "nstd", "\n", "\n", "torch", ".", "manual_seed", "(", "random_seed", ")", "\n", "\n", "noise", "=", "sigma", "*", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "\n", "x_noise", "=", "x", "+", "noise", "\n", "\n", "return", "x_noise", ".", "clamp", "(", "0.", ",", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.generate_blur_noisy": [[33, 58], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "blur_noisy.clamp", "utils.utils_model.imfilter2D_SpatialDomain", "utils.utils_model.imfilter2D_SpatialDomain", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter2D_SpatialDomain", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter2D_SpatialDomain"], ["", "def", "generate_blur_noisy", "(", "x", ",", "kernel", ",", "nstd", ",", "same", "=", "True", ",", "random_seed", "=", "20180102", ")", ":", "\n", "    ", "\"\"\"\n    This function generates blurry noisy images from clear ones and corresponding kernels.\n    Input:\n        x: (N, C, H, W) \n        kernel: (N, 1, Hk, Wk) kernels\n        nstd: noise sigma added to blur image\n        same: whether convolution keeps result same size as x. If False, result will be with size of (N, C, H-Hk+1, W-Wk+1). \n    \"\"\"", "\n", "sigma", "=", "nstd", "\n", "dtype", "=", "x", ".", "dtype", "\n", "torch", ".", "manual_seed", "(", "random_seed", ")", "\n", "\n", "if", "same", ":", "\n", "        ", "blur", "=", "utils", ".", "imfilter2D_SpatialDomain", "(", "x", ",", "kernel", ",", "padType", "=", "'zero'", ",", "mode", "=", "\"conv\"", ")", "\n", "shape", "=", "blur", ".", "shape", "\n", "noise", "=", "sigma", "*", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "blur_noisy", "=", "blur", "+", "noise", "\n", "", "else", ":", "\n", "        ", "blur", "=", "utils", ".", "imfilter2D_SpatialDomain", "(", "x", ",", "kernel", ",", "padType", "=", "'valid'", ",", "mode", "=", "\"conv\"", ")", "\n", "shape", "=", "blur", ".", "shape", "\n", "noise", "=", "sigma", "*", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "blur_noisy", "=", "blur", "+", "noise", "\n", "\n", "", "return", "blur_noisy", ".", "clamp", "(", "0.", ",", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.generate_LR_noisy": [[59, 82], ["utils.utils_image.imresize().type", "numpy.random.RandomState", "np.random.RandomState.randn", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "LR_noisy.clamp", "utils.utils_image.imresize", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.imresize"], ["", "def", "generate_LR_noisy", "(", "x", ",", "nstd", ",", "sf", ",", "random_seed", "=", "20180102", ")", ":", "\n", "    ", "\"\"\"\n    This function generates LR noisy images from clear ones and corresponding kernels using the following forward model: y = x_ds + n.\n    Input:\n        x: (N, C, H, W) \n        sf: scale factor (2,3,4) \n        nstd: noise sigma added to LR image\n    \"\"\"", "\n", "sigma", "=", "nstd", "\n", "dtype", "=", "x", ".", "dtype", "\n", "\n", "lr_img", "=", "utils_image", ".", "imresize", "(", "x", ",", "scale", "=", "1", "/", "sf", ")", ".", "type", "(", "dtype", ")", "\n", "#print('ds_func:', lr_img.shape, lr_img.min(), lr_img.max())", "\n", "shape", "=", "lr_img", ".", "shape", "\n", "#noise = sigma * torch.randn(*shape, dtype=dtype)", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "random_seed", ")", "\n", "random_noise", "=", "rng", ".", "randn", "(", "*", "shape", ")", "\n", "random_noise", "=", "torch", ".", "from_numpy", "(", "random_noise", ")", ".", "type", "(", "dtype", ")", "\n", "noise", "=", "sigma", "*", "random_noise", "\n", "#print('noise_func:', noise.shape, noise.min(), noise.max())", "\n", "LR_noisy", "=", "lr_img", "+", "noise", "\n", "\n", "return", "LR_noisy", ".", "clamp", "(", "0.", ",", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.generate_LR_blur_noisy": [[83, 117], ["torch.manual_seed", "torch.manual_seed", "torch.manual_seed", "LR_blurred_noisy.clamp", "utils.utils_image.imresize().type", "utils.utils_model.imfilter2D_SpatialDomain", "utils.utils_image.imresize().type", "utils.utils_model.imfilter2D_SpatialDomain", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "torch.randn", "utils.utils_image.imresize", "utils.utils_image.imresize"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter2D_SpatialDomain", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter2D_SpatialDomain", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.imresize", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.imresize"], ["", "def", "generate_LR_blur_noisy", "(", "x", ",", "kernel", ",", "nstd", ",", "sf", ",", "same", "=", "True", ",", "random_seed", "=", "20180102", ")", ":", "\n", "    ", "\"\"\"\n    This function generates LR blurred noisy images from clear ones and corresponding kernels using the following forward model: y = k * x_ds + n.\n    Input:\n        x: (N, C, H, W) \n        kernel: (N, 1, Hk, Wk) kernels\n        sf: scale factor (2,3,4) \n        nstd: noise sigma added to blur image\n        same: whether convolution keeps result same size as x. If False, result will be with size of (N, C, H-Hk+1, W-Wk+1). \n    \"\"\"", "\n", "sigma", "=", "nstd", "\n", "dtype", "=", "x", ".", "dtype", "\n", "torch", ".", "manual_seed", "(", "random_seed", ")", "\n", "\n", "if", "same", ":", "\n", "        ", "lr_img", "=", "utils_image", ".", "imresize", "(", "x", ",", "scale", "=", "1", "/", "sf", ")", ".", "type", "(", "dtype", ")", "\n", "#print('ds_func:', lr_img.shape, lr_img.min(), lr_img.max())", "\n", "LR_blurred", "=", "utils", ".", "imfilter2D_SpatialDomain", "(", "lr_img", ",", "kernel", ",", "padType", "=", "'zero'", ",", "mode", "=", "\"conv\"", ")", "\n", "#print('blur_func:', LR_blurred.shape, LR_blurred.min(), LR_blurred.max())", "\n", "shape", "=", "LR_blurred", ".", "shape", "\n", "noise", "=", "sigma", "*", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "#print('noise_func:', noise.shape, noise.min(), noise.max())", "\n", "LR_blurred_noisy", "=", "LR_blurred", "+", "noise", "\n", "", "else", ":", "\n", "        ", "lr_img", "=", "utils_image", ".", "imresize", "(", "x", ",", "scale", "=", "1", "/", "sf", ")", ".", "type", "(", "dtype", ")", "\n", "#print('ds_func:', lr_img.shape, lr_img.min(), lr_img.max())", "\n", "LR_blurred", "=", "utils", ".", "imfilter2D_SpatialDomain", "(", "lr_img", ",", "kernel", ",", "padType", "=", "'valid'", ",", "mode", "=", "\"conv\"", ")", "\n", "#print('blur_func:', LR_blurred.shape, LR_blurred.min(), LR_blurred.max())", "\n", "shape", "=", "LR_blurred", ".", "shape", "\n", "noise", "=", "sigma", "*", "torch", ".", "randn", "(", "*", "shape", ",", "dtype", "=", "dtype", ")", "\n", "#print('noise_func:', noise.shape, noise.min(), noise.max())", "\n", "LR_blurred_noisy", "=", "LR_blurred", "+", "noise", "\n", "\n", "", "return", "LR_blurred_noisy", ".", "clamp", "(", "0.", ",", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.mixup_data": [[118, 137], ["numpy.random.beta", "x.size", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm().cuda", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm"], "function", ["None"], ["", "def", "mixup_data", "(", "x", ",", "y", ",", "sigma", ",", "alpha", "=", "1.0", ",", "use_cuda", "=", "True", ")", ":", "\n", "\n", "    ", "'''Compute the mixup data. Return mixed inputs, targets, and lambda'''", "\n", "\n", "if", "alpha", ">", "0.", ":", "\n", "        ", "lam", "=", "np", ".", "random", ".", "beta", "(", "alpha", ",", "alpha", ")", "\n", "", "else", ":", "\n", "        ", "lam", "=", "1.", "\n", "", "batch_size", "=", "x", ".", "size", "(", ")", "[", "0", "]", "\n", "if", "use_cuda", ":", "\n", "        ", "index", "=", "torch", ".", "randperm", "(", "batch_size", ")", ".", "cuda", "(", ")", "\n", "", "else", ":", "\n", "        ", "index", "=", "torch", ".", "randperm", "(", "batch_size", ")", "\n", "\n", "", "mixed_x", "=", "lam", "*", "x", "+", "(", "1", "-", "lam", ")", "*", "x", "[", "index", ",", ":", "]", "\n", "mixed_y", "=", "lam", "*", "y", "+", "(", "1", "-", "lam", ")", "*", "y", "[", "index", ",", ":", "]", "\n", "mixed_sigma", "=", "lam", "*", "sigma", "+", "(", "1", "-", "lam", ")", "*", "sigma", "[", "index", "]", "\n", "\n", "return", "mixed_x", ",", "mixed_y", ",", "mixed_sigma", ",", "lam", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.psnr": [[138, 153], ["x.size", "range", "torch.mse_loss", "torch.log().numpy", "torch.log().numpy", "torch.log().numpy", "F.mse_loss.data.cpu().numpy", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "F.mse_loss.data.cpu", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.mse_loss", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log"], ["", "def", "psnr", "(", "xhat", ",", "x", ",", "border", "=", "0", ")", ":", "\n", "    ", "N", ",", "C", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "x", "=", "x", "[", ":", ",", ":", ",", "border", ":", "H", "-", "border", ",", "border", ":", "W", "-", "border", "]", "\n", "xhat", "=", "xhat", "[", ":", ",", ":", ",", "border", ":", "H", "-", "border", ",", "border", ":", "W", "-", "border", "]", "\n", "loss", "=", "0", "\n", "log10", "=", "1", "/", "torch", ".", "log", "(", "torch", ".", "FloatTensor", "(", "[", "10", "]", ")", ")", ".", "numpy", "(", ")", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "        ", "mse", "=", "F", ".", "mse_loss", "(", "xhat", "[", "i", "]", ",", "x", "[", "i", "]", ")", "\n", "\n", "if", "mse", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "==", "0", ":", "\n", "            ", "loss", "+=", "100", "\n", "continue", "\n", "", "loss", "+=", "20", "*", "torch", ".", "log", "(", "255.0", "/", "torch", ".", "sqrt", "(", "mse", ")", ")", "*", "log10", "\n", "", "loss", "/=", "N", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.get_patch": [[177, 198], ["random.randrange", "random.randrange", "random.randrange", "random.randrange"], "function", ["None"], ["", "def", "get_patch", "(", "img_in", ",", "img_tar", ",", "patch_size", ",", "scale", ")", ":", "\n", "    ", "ih", ",", "iw", "=", "img_in", ".", "shape", "[", ":", "2", "]", "\n", "oh", ",", "ow", "=", "img_tar", ".", "shape", "[", ":", "2", "]", "\n", "\n", "ip", "=", "patch_size", "\n", "\n", "if", "ih", "==", "oh", ":", "\n", "        ", "tp", "=", "ip", "\n", "ix", "=", "random", ".", "randrange", "(", "0", ",", "iw", "-", "ip", "+", "1", ")", "\n", "iy", "=", "random", ".", "randrange", "(", "0", ",", "ih", "-", "ip", "+", "1", ")", "\n", "tx", ",", "ty", "=", "ix", ",", "iy", "\n", "", "else", ":", "\n", "        ", "tp", "=", "ip", "*", "scale", "\n", "ix", "=", "random", ".", "randrange", "(", "0", ",", "iw", "-", "ip", "+", "1", ")", "\n", "iy", "=", "random", ".", "randrange", "(", "0", ",", "ih", "-", "ip", "+", "1", ")", "\n", "tx", ",", "ty", "=", "scale", "*", "ix", ",", "scale", "*", "iy", "\n", "\n", "", "img_in", "=", "img_in", "[", "iy", ":", "iy", "+", "ip", ",", "ix", ":", "ix", "+", "ip", ",", ":", "]", "\n", "img_tar", "=", "img_tar", "[", "ty", ":", "ty", "+", "tp", ",", "tx", ":", "tx", "+", "tp", ",", ":", "]", "\n", "\n", "return", "img_in", ",", "img_tar", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.modcrop": [[199, 205], ["None"], "function", ["None"], ["", "def", "modcrop", "(", "img", ",", "scale", ")", ":", "\n", "# img: Pytorch, C*H*W ", "\n", "    ", "C", ",", "H", ",", "W", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", ",", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", "]", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.modcrop_np": [[206, 220], ["numpy.copy", "ValueError"], "function", ["None"], ["", "def", "modcrop_np", "(", "img_in", ",", "scale", ")", ":", "\n", "# img_in: Numpy, HWC or HW", "\n", "    ", "img", "=", "np", ".", "copy", "(", "img_in", ")", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "H", ",", "W", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", "]", "\n", "", "elif", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "H", ",", "W", ",", "C", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wrong img ndim: [{:d}].'", ".", "format", "(", "img", ".", "ndim", ")", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.mse_grad_loss": [[221, 239], ["err.norm().pow().div", "input.unsqueeze.dim", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "target.unsqueeze.dim", "target.unsqueeze.unsqueeze", "err.numel", "utils.utils_model.imGrad().norm().pow().div", "err.norm().pow", "err.numel", "utils.utils_model.imGrad().norm().pow", "err.norm", "utils.utils_model.imGrad().norm", "utils.utils_model.imGrad"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imGrad"], ["", "def", "mse_grad_loss", "(", "input", ",", "target", ",", "grad", "=", "False", ")", ":", "\n", "\n", "    ", "assert", "(", "input", ".", "shape", "==", "target", ".", "shape", ")", ",", "\"The tensor inputs must be of the same size.\"", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<=", "4", ")", ",", "\"Tensor must be at maximum of 4 dimensions.\"", "\n", "\n", "while", "input", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "while", "target", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "target", "=", "target", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "err", "=", "input", "-", "target", "\n", "loss", "=", "err", ".", "norm", "(", "p", "=", "2", ")", ".", "pow", "(", "2", ")", ".", "div", "(", "err", ".", "numel", "(", ")", ")", "\n", "if", "grad", ":", "\n", "        ", "loss", "+=", "utils", ".", "imGrad", "(", "err", ",", "bc", "=", "'reflexive'", ")", ".", "norm", "(", "p", "=", "2", ")", ".", "pow", "(", "2", ")", ".", "div", "(", "err", ".", "numel", "(", ")", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.rgb2ycbcr": [[310, 332], ["img.astype", "rlt.round.astype", "rlt.round.round", "numpy.dot", "numpy.matmul"], "function", ["None"], ["", "", "def", "rgb2ycbcr", "(", "img", ",", "only_y", "=", "True", ")", ":", "\n", "    ", "'''same as matlab rgb2ycbcr\n    only_y: only return Y channel\n    Input:\n        uint8, [0, 255]\n        float, [0, 1]\n    '''", "\n", "in_img_type", "=", "img", ".", "dtype", "\n", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "in_img_type", "!=", "np", ".", "uint8", ":", "\n", "        ", "img", "*=", "255.", "\n", "# convert", "\n", "", "if", "only_y", ":", "\n", "        ", "rlt", "=", "np", ".", "dot", "(", "img", ",", "[", "65.481", ",", "128.553", ",", "24.966", "]", ")", "/", "255.0", "+", "16.0", "\n", "", "else", ":", "\n", "        ", "rlt", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "65.481", ",", "-", "37.797", ",", "112.0", "]", ",", "[", "128.553", ",", "-", "74.203", ",", "-", "93.786", "]", ",", "\n", "[", "24.966", ",", "112.0", ",", "-", "18.214", "]", "]", ")", "/", "255.0", "+", "[", "16", ",", "128", ",", "128", "]", "\n", "", "if", "in_img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "rlt", "=", "rlt", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "rlt", "/=", "255.", "\n", "", "return", "rlt", ".", "astype", "(", "in_img_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ycbcr2rgb": [[334, 352], ["img.astype", "rlt.round.astype", "rlt.round.round", "numpy.matmul"], "function", ["None"], ["", "def", "ycbcr2rgb", "(", "img", ")", ":", "\n", "    ", "'''same as matlab ycbcr2rgb\n    Input:\n        uint8, [0, 255]\n        float, [0, 1]\n    '''", "\n", "in_img_type", "=", "img", ".", "dtype", "\n", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "in_img_type", "!=", "np", ".", "uint8", ":", "\n", "        ", "img", "*=", "255.", "\n", "# convert", "\n", "", "rlt", "=", "np", ".", "matmul", "(", "img", ",", "[", "[", "0.00456621", ",", "0.00456621", ",", "0.00456621", "]", ",", "[", "0", ",", "-", "0.00153632", ",", "0.00791071", "]", ",", "\n", "[", "0.00625893", ",", "-", "0.00318811", ",", "0", "]", "]", ")", "*", "255.0", "+", "[", "-", "222.921", ",", "135.576", ",", "-", "276.836", "]", "\n", "if", "in_img_type", "==", "np", ".", "uint8", ":", "\n", "        ", "rlt", "=", "rlt", ".", "round", "(", ")", "\n", "", "else", ":", "\n", "        ", "rlt", "/=", "255.", "\n", "", "return", "rlt", ".", "astype", "(", "in_img_type", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.calc_metrics": [[353, 368], ["utils_common.calculate_psnr", "utils_common.calculate_ssim", "utils_common.rgb2ycbcr", "utils_common.rgb2ycbcr"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.calculate_psnr", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.calculate_ssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.rgb2ycbcr", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.rgb2ycbcr"], ["", "def", "calc_metrics", "(", "img1", ",", "img2", ",", "crop_border", ",", "test_Y", ")", ":", "\n", "    ", "img1", "=", "img1", "/", "255.", "\n", "img2", "=", "img2", "/", "255.", "\n", "\n", "if", "test_Y", "and", "img1", ".", "shape", "[", "2", "]", "==", "3", ":", "# evaluate on Y channel in YCbCr color space", "\n", "        ", "im1_in", "=", "rgb2ycbcr", "(", "img1", ")", "\n", "im2_in", "=", "rgb2ycbcr", "(", "img2", ")", "\n", "", "else", ":", "\n", "        ", "im1_in", "=", "img1", "\n", "im2_in", "=", "img2", "\n", "\n", "", "psnr", "=", "calculate_psnr", "(", "im1_in", "*", "255", ",", "im2_in", "*", "255", ",", "border", "=", "crop_border", ")", "\n", "ssim", "=", "calculate_ssim", "(", "im1_in", "*", "255", ",", "im2_in", "*", "255", ",", "border", "=", "crop_border", ")", "\n", "\n", "return", "psnr", ",", "ssim", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.calculate_psnr": [[369, 383], ["img1.astype.astype", "img2.astype.astype", "numpy.mean", "ValueError", "float", "math.log10", "math.sqrt"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.log10"], ["", "def", "calculate_psnr", "(", "img1", ",", "img2", ",", "border", "=", "0", ")", ":", "\n", "# img1 and img2 have range [0, 255]", "\n", "    ", "if", "not", "img1", ".", "shape", "==", "img2", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "'Input images must have the same dimensions.'", ")", "\n", "", "h", ",", "w", "=", "img1", ".", "shape", "[", ":", "2", "]", "\n", "img1", "=", "img1", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "img2", "=", "img2", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "mse", "=", "np", ".", "mean", "(", "(", "img1", "-", "img2", ")", "**", "2", ")", "\n", "if", "mse", "==", "0", ":", "\n", "        ", "return", "float", "(", "'inf'", ")", "\n", "", "return", "20", "*", "math", ".", "log10", "(", "255.0", "/", "math", ".", "sqrt", "(", "mse", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.calculate_ssim": [[384, 407], ["ValueError", "utils_common.ssim", "ValueError", "range", "numpy.array().mean", "ssims.append", "utils_common.ssim", "utils_common.ssim", "numpy.array", "numpy.squeeze", "numpy.squeeze"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim"], ["", "def", "calculate_ssim", "(", "img1", ",", "img2", ",", "border", "=", "0", ")", ":", "\n", "    ", "'''calculate SSIM\n    the same outputs as MATLAB's\n    img1, img2: [0, 255]\n    '''", "\n", "if", "not", "img1", ".", "shape", "==", "img2", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "'Input images must have the same dimensions.'", ")", "\n", "", "h", ",", "w", "=", "img1", ".", "shape", "[", ":", "2", "]", "\n", "img1", "=", "img1", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "img2", "=", "img2", "[", "border", ":", "h", "-", "border", ",", "border", ":", "w", "-", "border", "]", "\n", "\n", "if", "img1", ".", "ndim", "==", "2", ":", "\n", "        ", "return", "ssim", "(", "img1", ",", "img2", ")", "\n", "", "elif", "img1", ".", "ndim", "==", "3", ":", "\n", "        ", "if", "img1", ".", "shape", "[", "2", "]", "==", "3", ":", "\n", "            ", "ssims", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "3", ")", ":", "\n", "                ", "ssims", ".", "append", "(", "ssim", "(", "img1", ",", "img2", ")", ")", "\n", "", "return", "np", ".", "array", "(", "ssims", ")", ".", "mean", "(", ")", "\n", "", "elif", "img1", ".", "shape", "[", "2", "]", "==", "1", ":", "\n", "            ", "return", "ssim", "(", "np", ".", "squeeze", "(", "img1", ")", ",", "np", ".", "squeeze", "(", "img2", ")", ")", "\n", "", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wrong input image dimensions.'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.ssim": [[408, 429], ["img1.astype.astype", "img2.astype.astype", "cv2.getGaussianKernel", "numpy.outer", "ssim_map.mean", "cv2.getGaussianKernel.transpose", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D", "cv2.filter2D"], "function", ["None"], ["", "", "def", "ssim", "(", "img1", ",", "img2", ")", ":", "\n", "    ", "C1", "=", "(", "0.01", "*", "255", ")", "**", "2", "\n", "C2", "=", "(", "0.03", "*", "255", ")", "**", "2", "\n", "\n", "img1", "=", "img1", ".", "astype", "(", "np", ".", "float64", ")", "\n", "img2", "=", "img2", ".", "astype", "(", "np", ".", "float64", ")", "\n", "kernel", "=", "cv2", ".", "getGaussianKernel", "(", "11", ",", "1.5", ")", "\n", "window", "=", "np", ".", "outer", "(", "kernel", ",", "kernel", ".", "transpose", "(", ")", ")", "\n", "\n", "mu1", "=", "cv2", ".", "filter2D", "(", "img1", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "# valid", "\n", "mu2", "=", "cv2", ".", "filter2D", "(", "img2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "\n", "mu1_sq", "=", "mu1", "**", "2", "\n", "mu2_sq", "=", "mu2", "**", "2", "\n", "mu1_mu2", "=", "mu1", "*", "mu2", "\n", "sigma1_sq", "=", "cv2", ".", "filter2D", "(", "img1", "**", "2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu1_sq", "\n", "sigma2_sq", "=", "cv2", ".", "filter2D", "(", "img2", "**", "2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu2_sq", "\n", "sigma12", "=", "cv2", ".", "filter2D", "(", "img1", "*", "img2", ",", "-", "1", ",", "window", ")", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "-", "mu1_mu2", "\n", "\n", "ssim_map", "=", "(", "(", "2", "*", "mu1_mu2", "+", "C1", ")", "*", "(", "2", "*", "sigma12", "+", "C2", ")", ")", "/", "(", "(", "mu1_sq", "+", "mu2_sq", "+", "C1", ")", "*", "\n", "(", "sigma1_sq", "+", "sigma2_sq", "+", "C2", ")", ")", "\n", "return", "ssim_map", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.loadmat": [[430, 480], ["scipy.io.loadmat", "scipy.io.loadmat", "utils_common.loadmat._check_keys"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.loadmat", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.loadmat"], ["", "def", "loadmat", "(", "filename", ")", ":", "\n", "    ", "'''\n    this function should be called instead of direct spio.loadmat\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    link: https://stackoverflow.com/questions/7008608/scipy-io-loadmat-nested-structures-i-e-dictionaries\n    '''", "\n", "def", "_check_keys", "(", "d", ")", ":", "\n", "        ", "'''\n        checks if entries in dictionary are mat-objects. If yes\n        todict is called to change them to nested dictionaries\n        '''", "\n", "for", "key", "in", "d", ":", "\n", "            ", "if", "isinstance", "(", "d", "[", "key", "]", ",", "spio", ".", "matlab", ".", "mio5_params", ".", "mat_struct", ")", ":", "\n", "                ", "d", "[", "key", "]", "=", "_todict", "(", "d", "[", "key", "]", ")", "\n", "", "", "return", "d", "\n", "\n", "", "def", "_todict", "(", "matobj", ")", ":", "\n", "        ", "'''\n        A recursive function which constructs from matobjects nested dictionaries\n        '''", "\n", "d", "=", "{", "}", "\n", "for", "strg", "in", "matobj", ".", "_fieldnames", ":", "\n", "            ", "elem", "=", "matobj", ".", "__dict__", "[", "strg", "]", "\n", "if", "isinstance", "(", "elem", ",", "spio", ".", "matlab", ".", "mio5_params", ".", "mat_struct", ")", ":", "\n", "                ", "d", "[", "strg", "]", "=", "_todict", "(", "elem", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "d", "[", "strg", "]", "=", "_tolist", "(", "elem", ")", "\n", "", "else", ":", "\n", "                ", "d", "[", "strg", "]", "=", "elem", "\n", "", "", "return", "d", "\n", "\n", "", "def", "_tolist", "(", "ndarray", ")", ":", "\n", "        ", "'''\n        A recursive function which constructs lists from cellarrays\n        (which are loaded as numpy ndarrays), recursing into the elements\n        if they contain matobjects.\n        '''", "\n", "elem_list", "=", "[", "]", "\n", "for", "sub_elem", "in", "ndarray", ":", "\n", "            ", "if", "isinstance", "(", "sub_elem", ",", "spio", ".", "matlab", ".", "mio5_params", ".", "mat_struct", ")", ":", "\n", "                ", "elem_list", ".", "append", "(", "_todict", "(", "sub_elem", ")", ")", "\n", "", "elif", "isinstance", "(", "sub_elem", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "elem_list", ".", "append", "(", "_tolist", "(", "sub_elem", ")", ")", "\n", "", "else", ":", "\n", "                ", "elem_list", ".", "append", "(", "sub_elem", ")", "\n", "", "", "return", "elem_list", "\n", "", "data", "=", "scipy", ".", "io", ".", "loadmat", "(", "filename", ",", "struct_as_record", "=", "False", ",", "squeeze_me", "=", "True", ")", "\n", "return", "_check_keys", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.load_resdnet_params": [[481, 510], ["utils_common.loadmat", "model.state_dict", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "range", "model.load_state_dict", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "torch.FloatTensor().permute", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "numpy.array", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "numpy.array", "model.state_dict.keys", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "numpy.array", "numpy.array", "str"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.loadmat"], ["", "def", "load_resdnet_params", "(", "model", ",", "pretrained_model_path", ",", "depth", ")", ":", "\n", "# load the weights", "\n", "    ", "weights", "=", "loadmat", "(", "pretrained_model_path", ")", "\n", "state_dict", "=", "model", ".", "state_dict", "(", ")", "\n", "# load l2proj", "\n", "\n", "#state_dict['l2proj.alpha'] = torch.FloatTensor([weights['net']['layers'][-4]['weights']])", "\n", "# load conv2d and conv2dT", "\n", "state_dict", "[", "'conv1.bias'", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "0", "]", "[", "'weights'", "]", "[", "1", "]", ")", ")", "\n", "state_dict", "[", "'conv1.weight_g'", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "0", "]", "[", "'weights'", "]", "[", "2", "]", ")", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "state_dict", "[", "'conv1.weight_v'", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "0", "]", "[", "'weights'", "]", "[", "0", "]", ")", ")", ".", "permute", "(", "3", ",", "2", ",", "1", ",", "0", ")", "\n", "\n", "state_dict", "[", "'conv_out.bias'", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "-", "5", "]", "[", "'weights'", "]", "[", "1", "]", ")", ")", "\n", "state_dict", "[", "'conv_out.weight_g'", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "-", "5", "]", "[", "'weights'", "]", "[", "2", "]", ")", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "state_dict", "[", "'conv_out.weight_v'", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "-", "5", "]", "[", "'weights'", "]", "[", "0", "]", ")", ")", ".", "permute", "(", "3", ",", "2", ",", "1", ",", "0", ")", "\n", "# fill layers", "\n", "for", "i", "in", "range", "(", "depth", ")", ":", "\n", "        ", "layer", "=", "[", "k", "for", "k", "in", "state_dict", ".", "keys", "(", ")", "if", "'layer1.'", "+", "str", "(", "i", ")", "in", "k", "]", "\n", "state_dict", "[", "layer", "[", "0", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "1", "]", ")", ")", "\n", "state_dict", "[", "layer", "[", "1", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "2", "]", ")", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "state_dict", "[", "layer", "[", "2", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "0", "]", ")", ")", ".", "permute", "(", "3", ",", "2", ",", "1", ",", "0", ")", "\n", "state_dict", "[", "layer", "[", "3", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "-", "2", "]", ")", ")", "\n", "state_dict", "[", "layer", "[", "4", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "-", "1", "]", ")", ")", "\n", "state_dict", "[", "layer", "[", "5", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "4", "]", ")", ")", "\n", "state_dict", "[", "layer", "[", "6", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "5", "]", ")", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "state_dict", "[", "layer", "[", "7", "]", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "weights", "[", "'net'", "]", "[", "'layers'", "]", "[", "i", "+", "1", "]", "[", "'weights'", "]", "[", "3", "]", ")", ")", ".", "permute", "(", "3", ",", "2", ",", "1", ",", "0", ")", "\n", "# load all weights to model", "\n", "", "model", ".", "load_state_dict", "(", "state_dict", ")", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_common.load_srresdnet_params": [[549, 603], ["torch.load", "torch.load", "torch.load", "model.state_dict", "range", "range", "model.load_state_dict", "states_pretrain_net.keys", "model.state_dict.keys", "states_pretrain_net.keys", "model.state_dict.keys", "str", "str", "str", "str"], "function", ["None"], ["", "def", "load_srresdnet_params", "(", "pretrain_path", ",", "model", ",", "res_depth", "=", "8", ",", "upsamp_depth", "=", "1", ")", ":", "\n", "    ", "pretrain_net", "=", "torch", ".", "load", "(", "pretrain_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "states_pretrain_net", "=", "pretrain_net", "[", "'model_state_dict'", "]", "\n", "#    print('states_pretrain_net len:', len(states_pretrain_net))", "\n", "#    states_srresdnet = [k for k in states_pretrain_net.keys()]", "\n", "#    print('states srresdnet:', states_srresdnet)", "\n", "states_net", "=", "model", ".", "state_dict", "(", ")", "\n", "#    print('states_net len:', len(states_net))", "\n", "#    states_srwdnet = [k for k in states_net.keys()]", "\n", "#    print('states srresdnet:', states_srwdnet)", "\n", "\n", "# head_conv", "\n", "states_net", "[", "'head_conv.bias'", "]", "=", "states_pretrain_net", "[", "'head_conv.bias'", "]", "\n", "states_net", "[", "'head_conv.weight_g'", "]", "=", "states_pretrain_net", "[", "'head_conv.weight_g'", "]", "\n", "states_net", "[", "'head_conv.weight_v'", "]", "=", "states_pretrain_net", "[", "'head_conv.weight_v'", "]", "\n", "# tconv", "\n", "states_net", "[", "'tconv.bias'", "]", "=", "states_pretrain_net", "[", "'tconv.bias'", "]", "\n", "states_net", "[", "'tconv.weight_g'", "]", "=", "states_pretrain_net", "[", "'tconv.weight_g'", "]", "\n", "states_net", "[", "'tconv.weight_v'", "]", "=", "states_pretrain_net", "[", "'tconv.weight_v'", "]", "\n", "# tail_conv", "\n", "states_net", "[", "'tail_conv.bias'", "]", "=", "states_pretrain_net", "[", "'tail_conv.bias'", "]", "\n", "states_net", "[", "'tail_conv.weight_g'", "]", "=", "states_pretrain_net", "[", "'tail_conv.weight_g'", "]", "\n", "states_net", "[", "'tail_conv.weight_v'", "]", "=", "states_pretrain_net", "[", "'tail_conv.weight_v'", "]", "\n", "# proj alpha", "\n", "states_net", "[", "'l2proj.alpha'", "]", "=", "states_pretrain_net", "[", "'l2proj.alpha'", "]", "\n", "\n", "for", "i", "in", "range", "(", "res_depth", ")", ":", "\n", "            ", "states_srresdnet", "=", "[", "k", "for", "k", "in", "states_pretrain_net", ".", "keys", "(", ")", "if", "'resBlocks.'", "+", "str", "(", "i", ")", "in", "k", "]", "\n", "states_srwdnet", "=", "[", "k", "for", "k", "in", "states_net", ".", "keys", "(", ")", "if", "'resBlocks.'", "+", "str", "(", "i", ")", "in", "k", "]", "\n", "#print('states_srresdnet:', states_srresdnet)", "\n", "#print('states_srwdnet:', states_srwdnet)", "\n", "\n", "states_net", "[", "states_srwdnet", "[", "0", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "0", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "1", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "1", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "2", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "2", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "3", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "3", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "4", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "4", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "5", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "5", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "6", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "6", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "7", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "7", "]", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "upsamp_depth", ")", ":", "\n", "            ", "states_srresdnet", "=", "[", "k", "for", "k", "in", "states_pretrain_net", ".", "keys", "(", ")", "if", "'upsampling.upsampling.'", "+", "str", "(", "i", ")", "in", "k", "]", "\n", "states_srwdnet", "=", "[", "k", "for", "k", "in", "states_net", ".", "keys", "(", ")", "if", "'upsampling.upsampling.'", "+", "str", "(", "i", ")", "in", "k", "]", "\n", "#print('states_srresdnet:', states_srresdnet)", "\n", "#print('states_srwdnet:', states_srwdnet)", "\n", "\n", "states_net", "[", "states_srwdnet", "[", "0", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "0", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "1", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "1", "]", "]", "\n", "states_net", "[", "states_srwdnet", "[", "2", "]", "]", "=", "states_pretrain_net", "[", "states_srresdnet", "[", "2", "]", "]", "\n", "\n", "", "model", ".", "load_state_dict", "(", "states_net", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse": [[13, 19], ["input.dim", "torch.arange().type_as().long", "input.index_select", "torch.arange().type_as", "torch.arange", "input.size"], "function", ["None"], ["def", "reverse", "(", "input", ",", "dim", "=", "0", ")", ":", "\n", "    ", "r\"\"\"Reverses the specified dimension of the input tensor.\"\"\"", "\n", "Dims", "=", "input", ".", "dim", "(", ")", "\n", "assert", "(", "dim", "<", "Dims", ")", ",", "\"The selected dimension (arg 2) exceeds the tensor's dimensions.\"", "\n", "idx", "=", "th", ".", "arange", "(", "input", ".", "size", "(", "dim", ")", "-", "1", ",", "-", "1", ",", "-", "1", ")", ".", "type_as", "(", "input", ")", ".", "long", "(", ")", "\n", "return", "input", ".", "index_select", "(", "dim", ",", "idx", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.log10": [[20, 22], ["input.log().div", "torch.Tensor().type_as().log", "input.log", "torch.Tensor().type_as", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_logger.log"], ["", "def", "log10", "(", "input", ")", ":", "\n", "    ", "return", "input", ".", "log", "(", ")", ".", "div", "(", "th", ".", "Tensor", "(", "[", "10", "]", ")", ".", "type_as", "(", "input", ")", ".", "log", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.psnr": [[23, 56], ["input.unsqueeze.numel", "input.unsqueeze.size", "torch.is_tensor", "torch.is_tensor", "other.unsqueeze.max", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "other.unsqueeze.dim", "other.unsqueeze.unsqueeze", "float", "utils_model.log10", "float.mean", "float.mean", "MSE.mean"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.log10"], ["", "def", "psnr", "(", "input", ",", "other", ",", "peakVal", "=", "None", ",", "average", "=", "False", ",", "nargout", "=", "1", ")", ":", "\n", "\n", "    ", "assert", "(", "th", ".", "is_tensor", "(", "input", ")", "and", "th", ".", "is_tensor", "(", "other", ")", ")", ",", "\"The first two inputs \"", "+", "\"must be tensors.\"", "\n", "\n", "if", "peakVal", "is", "None", ":", "\n", "        ", "peakVal", "=", "other", ".", "max", "(", ")", "\n", "\n", "", "assert", "(", "input", ".", "shape", "==", "other", ".", "shape", ")", ",", "\"Dimensions mismatch between the two \"", "\"input tensors.\"", "\n", "\n", "while", "input", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "", "while", "other", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "other", "=", "other", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "N", "=", "input", ".", "numel", "(", ")", "\n", "batch", "=", "input", ".", "size", "(", "0", ")", "\n", "\n", "if", "N", "==", "0", ":", "\n", "        ", "SNR", "=", "float", "(", "'nan'", ")", "\n", "MSE", "=", "0", "\n", "return", "SNR", ",", "MSE", "\n", "\n", "", "MSE", "=", "(", "input", "-", "other", ")", ".", "view", "(", "batch", ",", "-", "1", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", "dim", "=", "1", ")", "\n", "\n", "#SNR = (10*th.log(peakVal**2/MSE)).div(math.log(10))", "\n", "SNR", "=", "10", "*", "log10", "(", "peakVal", "**", "2", "/", "MSE", ")", "\n", "\n", "if", "average", ":", "\n", "        ", "return", "(", "SNR", ".", "mean", "(", ")", ",", "MSE", ".", "mean", "(", ")", ")", "if", "nargout", "==", "2", "else", "SNR", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "SNR", ",", "MSE", ")", "if", "nargout", "==", "2", "else", "SNR", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.periodicPad2D": [[58, 118], ["isinstance", "list", "torch.empty().type_as", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "isinstance", "input.unsqueeze.size", "sum", "sum", "th.empty().type_as.squeeze_", "len", "torch.empty", "th.empty().type_as.size", "th.empty().type_as.size", "th.empty().type_as.size", "th.empty().type_as.size", "th.empty().type_as.size", "th.empty().type_as.size", "th.empty().type_as.size", "th.empty().type_as.size"], "function", ["None"], ["", "", "def", "periodicPad2D", "(", "input", ",", "pad", "=", "0", ")", ":", "\n", "    ", "r\"\"\"Pads circularly the spatial dimensions (last two dimensions) of the \n    input tensor. PAD specifies the amount of padding as [TOP, BOTTOM, LEFT, RIGHT].\n    If pad is an integer then each direction is padded by the same amount. In\n    order to achieve a different amount of padding in each direction of the \n    tensor, pad needs to be a tuple.\"\"\"", "\n", "\n", "# pad = [top,bottom,left,right]", "\n", "\n", "if", "isinstance", "(", "pad", ",", "int", ")", ":", "\n", "        ", "assert", "(", "pad", ">=", "0", ")", ",", "\"\"\"Pad must be either a non-negative integer \n        or a tuple.\"\"\"", "\n", "pad", "=", "(", "pad", ",", ")", "*", "4", "\n", "\n", "", "sflag", "=", "False", "\n", "if", "input", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "sflag", "=", "True", "\n", "input", "=", "input", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "assert", "(", "isinstance", "(", "pad", ",", "tuple", ")", "and", "len", "(", "pad", ")", "==", "4", ")", ",", "\" A tuple with 4 values for padding is expected as input.\"", "\n", "\n", "sz", "=", "list", "(", "input", ".", "size", "(", ")", ")", "\n", "\n", "assert", "(", "pad", "[", "0", "]", ">=", "0", "and", "pad", "[", "1", "]", ">=", "0", "and", "pad", "[", "2", "]", ">=", "0", "and", "pad", "[", "3", "]", ">=", "0", ")", ",", "\"Padding must be non-negative in each dimension.\"", "\n", "\n", "assert", "(", "pad", "[", "0", "]", "<=", "sz", "[", "-", "2", "]", "and", "pad", "[", "1", "]", "<=", "sz", "[", "-", "2", "]", "and", "pad", "[", "2", "]", "<=", "sz", "[", "-", "1", "]", "and", "pad", "[", "3", "]", "<=", "sz", "[", "-", "1", "]", ")", ",", "\"The padding values exceed the tensor's dimensions.\"", "\n", "\n", "sz", "[", "-", "1", "]", "=", "sz", "[", "-", "1", "]", "+", "sum", "(", "pad", "[", "2", ":", ":", "]", ")", "\n", "sz", "[", "-", "2", "]", "=", "sz", "[", "-", "2", "]", "+", "sum", "(", "pad", "[", "0", ":", "2", "]", ")", "\n", "\n", "out", "=", "th", ".", "empty", "(", "sz", ")", ".", "type_as", "(", "input", ")", "\n", "\n", "# Copy the original tensor to the central part", "\n", "out", "[", "...", ",", "pad", "[", "0", "]", ":", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", ",", "pad", "[", "2", "]", ":", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", "]", "=", "input", "\n", "\n", "# Pad Top", "\n", "if", "pad", "[", "0", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "0", ":", "pad", "[", "0", "]", ",", ":", "]", "=", "out", "[", "...", ",", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", "-", "pad", "[", "0", "]", ":", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", ",", ":", "]", "\n", "\n", "# Pad Bottom", "\n", "", "if", "pad", "[", "1", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", ":", ":", ",", ":", "]", "=", "out", "[", "...", ",", "pad", "[", "0", "]", ":", "pad", "[", "0", "]", "+", "pad", "[", "1", "]", ",", ":", "]", "\n", "\n", "# Pad Left", "\n", "", "if", "pad", "[", "2", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", ":", ",", "0", ":", "pad", "[", "2", "]", "]", "=", "out", "[", "...", ",", ":", ",", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", "-", "pad", "[", "2", "]", ":", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", "]", "\n", "\n", "# Pad Right", "\n", "", "if", "pad", "[", "3", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", ":", ",", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", ":", ":", "]", "=", "out", "[", "...", ",", ":", ",", "pad", "[", "2", "]", ":", "pad", "[", "2", "]", "+", "pad", "[", "3", "]", "]", "\n", "\n", "", "if", "sflag", ":", "\n", "        ", "out", ".", "squeeze_", "(", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.periodicPad_transpose2D": [[119, 183], ["isinstance", "list", "input.unsqueeze.clone", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "isinstance", "input.unsqueeze.size", "input.clone.squeeze_", "len"], "function", ["None"], ["", "def", "periodicPad_transpose2D", "(", "input", ",", "crop", "=", "0", ")", ":", "\n", "    ", "r\"\"\"Adjoint of the periodicPad2D operation which amounts to a special type\n    of cropping. CROP specifies the amount of cropping as [TOP, BOTTOM, LEFT, RIGHT].\n    If crop is an integer then each direction is cropped by the same amount. In\n    order to achieve a different amount of cropping in each direction of the \n    tensor, crop needs to be a tuple.\"\"\"", "\n", "\n", "# crop = [top,bottom,left,right]", "\n", "\n", "if", "isinstance", "(", "crop", ",", "int", ")", ":", "\n", "        ", "assert", "(", "crop", ">=", "0", ")", ",", "\"\"\"Crop must be either a non-negative integer \n        or a tuple.\"\"\"", "\n", "crop", "=", "(", "crop", ",", ")", "*", "4", "\n", "\n", "", "sflag", "=", "False", "\n", "if", "input", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "sflag", "=", "True", "\n", "input", "=", "input", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "assert", "(", "isinstance", "(", "crop", ",", "tuple", ")", "and", "len", "(", "crop", ")", "==", "4", ")", ",", "\" A tuple with 4 values for padding is expected as input.\"", "\n", "\n", "sz", "=", "list", "(", "input", ".", "size", "(", ")", ")", "\n", "\n", "assert", "(", "crop", "[", "0", "]", ">=", "0", "and", "crop", "[", "1", "]", ">=", "0", "and", "crop", "[", "2", "]", ">=", "0", "and", "crop", "[", "3", "]", ">=", "0", ")", ",", "\"Crop must be non-negative in each dimension.\"", "\n", "\n", "assert", "(", "crop", "[", "0", "]", "+", "crop", "[", "1", "]", "<=", "sz", "[", "-", "2", "]", "and", "crop", "[", "2", "]", "+", "crop", "[", "3", "]", "<=", "sz", "[", "-", "1", "]", ")", ",", "\"Crop does not have valid values.\"", "\n", "\n", "out", "=", "input", ".", "clone", "(", ")", "\n", "\n", "# Top", "\n", "if", "crop", "[", "0", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "crop", "[", "0", "]", ":", "crop", "[", "0", "]", "+", "crop", "[", "1", "]", ",", ":", "]", "+=", "out", "[", "...", ",", "-", "crop", "[", "1", "]", ":", ":", ",", ":", "]", "\n", "\n", "# Bottom ", "\n", "", "if", "crop", "[", "1", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "-", "crop", "[", "0", "]", "-", "crop", "[", "1", "]", ":", "-", "crop", "[", "1", "]", ",", ":", "]", "+=", "out", "[", "...", ",", "0", ":", "crop", "[", "0", "]", ",", ":", "]", "\n", "\n", "# Left ", "\n", "", "if", "crop", "[", "2", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "crop", "[", "2", "]", ":", "crop", "[", "2", "]", "+", "crop", "[", "3", "]", "]", "+=", "out", "[", "...", ",", "-", "crop", "[", "3", "]", ":", ":", "]", "\n", "\n", "# Right", "\n", "", "if", "crop", "[", "3", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "-", "crop", "[", "2", "]", "-", "crop", "[", "3", "]", ":", "-", "crop", "[", "3", "]", "]", "+=", "out", "[", "...", ",", "0", ":", "crop", "[", "2", "]", "]", "\n", "\n", "", "if", "crop", "[", "1", "]", "==", "0", ":", "\n", "        ", "end_h", "=", "sz", "[", "-", "2", "]", "+", "1", "\n", "", "else", ":", "\n", "        ", "end_h", "=", "sz", "[", "-", "2", "]", "-", "crop", "[", "1", "]", "\n", "\n", "", "if", "crop", "[", "3", "]", "==", "0", ":", "\n", "        ", "end_w", "=", "sz", "[", "-", "1", "]", "+", "1", "\n", "", "else", ":", "\n", "        ", "end_w", "=", "sz", "[", "-", "1", "]", "-", "crop", "[", "3", "]", "\n", "\n", "", "out", "=", "out", "[", "...", ",", "crop", "[", "0", "]", ":", "end_h", ",", "crop", "[", "2", "]", ":", "end_w", "]", "\n", "\n", "if", "sflag", ":", "\n", "        ", "out", ".", "squeeze_", "(", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.zeroPad2D": [[185, 226], ["isinstance", "list", "torch.zeros().type_as", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "isinstance", "input.unsqueeze.size", "sum", "sum", "th.zeros().type_as.squeeze_", "len", "torch.zeros"], "function", ["None"], ["", "def", "zeroPad2D", "(", "input", ",", "pad", "=", "0", ")", ":", "\n", "    ", "r\"\"\"Pads with zeros the spatial dimensions (last two dimensions) of the \n    input tensor. PAD specifies the amount of padding as [TOP, BOTTOM, LEFT, RIGHT].\n    If pad is an integer then each direction is padded by the same amount. In\n    order to achieve a different amount of padding in each direction of the \n    tensor, pad needs to be a tuple.\"\"\"", "\n", "\n", "# pad = [top,bottom,left,right]", "\n", "\n", "if", "isinstance", "(", "pad", ",", "int", ")", ":", "\n", "        ", "assert", "(", "pad", ">=", "0", ")", ",", "\"\"\"Pad must be either a non-negative integer \n        or a tuple.\"\"\"", "\n", "pad", "=", "(", "pad", ",", ")", "*", "4", "\n", "\n", "", "sflag", "=", "False", "\n", "if", "input", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "sflag", "=", "True", "\n", "input", "=", "input", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "assert", "(", "isinstance", "(", "pad", ",", "tuple", ")", "and", "len", "(", "pad", ")", "==", "4", ")", ",", "\" A tuple with 4 values for padding is expected as input.\"", "\n", "\n", "sz", "=", "list", "(", "input", ".", "size", "(", ")", ")", "\n", "\n", "assert", "(", "pad", "[", "0", "]", ">=", "0", "and", "pad", "[", "1", "]", ">=", "0", "and", "pad", "[", "2", "]", ">=", "0", "and", "pad", "[", "3", "]", ">=", "0", ")", ",", "\"Padding must be non-negative in each dimension.\"", "\n", "\n", "assert", "(", "pad", "[", "0", "]", "<=", "sz", "[", "-", "2", "]", "and", "pad", "[", "1", "]", "<=", "sz", "[", "-", "2", "]", "and", "pad", "[", "2", "]", "<=", "sz", "[", "-", "1", "]", "and", "pad", "[", "3", "]", "<=", "sz", "[", "-", "1", "]", ")", ",", "\"The padding values exceed the tensor's dimensions.\"", "\n", "\n", "sz", "[", "-", "1", "]", "=", "sz", "[", "-", "1", "]", "+", "sum", "(", "pad", "[", "2", ":", ":", "]", ")", "\n", "sz", "[", "-", "2", "]", "=", "sz", "[", "-", "2", "]", "+", "sum", "(", "pad", "[", "0", ":", "2", "]", ")", "\n", "\n", "out", "=", "th", ".", "zeros", "(", "sz", ")", ".", "type_as", "(", "input", ")", "\n", "out", "[", "...", ",", "pad", "[", "0", "]", ":", "sz", "[", "-", "2", "]", "-", "pad", "[", "1", "]", ":", "1", ",", "pad", "[", "2", "]", ":", "sz", "[", "-", "1", "]", "-", "pad", "[", "3", "]", ":", "1", "]", "=", "input", "\n", "\n", "if", "sflag", ":", "\n", "        ", "out", ".", "squeeze_", "(", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.crop2D": [[227, 262], ["isinstance", "list", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "isinstance", "input.unsqueeze.size", "out.unsqueeze_", "len"], "function", ["None"], ["", "def", "crop2D", "(", "input", ",", "crop", ")", ":", "\n", "    ", "r\"\"\"Cropping the spatial dimensions (last two dimensions) of the \n    input tensor. This is the adjoint operation of zeroPad2D. Crop specifies \n    the amount of cropping as [TOP, BOTTOM, LEFT, RIGHT]. If crop is an integer \n    then each direction is cropped by the same amount. In order to achieve a \n    different amount of cropping in each direction of the  tensor, crop needs \n    to be a tuple.\"\"\"", "\n", "\n", "if", "isinstance", "(", "crop", ",", "int", ")", ":", "\n", "        ", "assert", "(", "crop", ">=", "0", ")", ",", "\"\"\"Crop must be either a non-negative integer \n        or a tuple.\"\"\"", "\n", "crop", "=", "(", "crop", ",", ")", "*", "4", "\n", "\n", "", "sflag", "=", "False", "\n", "if", "input", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "sflag", "=", "True", "\n", "input", "=", "input", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "assert", "(", "isinstance", "(", "crop", ",", "tuple", ")", "and", "len", "(", "crop", ")", "==", "4", ")", ",", "\" A tuple with 4 values for padding is expected as input.\"", "\n", "\n", "sz", "=", "list", "(", "input", ".", "size", "(", ")", ")", "\n", "\n", "assert", "(", "crop", "[", "0", "]", ">=", "0", "and", "crop", "[", "1", "]", ">=", "0", "and", "crop", "[", "2", "]", ">=", "0", "and", "crop", "[", "3", "]", ">=", "0", ")", ",", "\"Crop must be non-negative in each dimension.\"", "\n", "\n", "assert", "(", "crop", "[", "0", "]", "+", "crop", "[", "1", "]", "<=", "sz", "[", "-", "2", "]", "and", "crop", "[", "2", "]", "+", "crop", "[", "3", "]", "<=", "sz", "[", "-", "1", "]", ")", ",", "\"Crop does not have valid values.\"", "\n", "\n", "out", "=", "input", "[", "...", ",", "crop", "[", "0", "]", ":", "sz", "[", "-", "2", "]", "-", "crop", "[", "1", "]", ":", "1", ",", "crop", "[", "2", "]", ":", "sz", "[", "-", "1", "]", "-", "crop", "[", "3", "]", ":", "1", "]", "\n", "\n", "if", "sflag", ":", "\n", "        ", "out", ".", "unsqueeze_", "(", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.symmetricPad2D": [[263, 325], ["isinstance", "list", "torch.zeros().type_as", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "isinstance", "input.unsqueeze.size", "sum", "sum", "utils_model.reverse", "utils_model.reverse", "utils_model.reverse", "utils_model.reverse", "th.zeros().type_as.squeeze_", "len", "torch.zeros", "th.zeros().type_as.size", "th.zeros().type_as.size", "th.zeros().type_as.size", "th.zeros().type_as.size", "th.zeros().type_as.size", "th.zeros().type_as.size", "th.zeros().type_as.size", "th.zeros().type_as.size"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "symmetricPad2D", "(", "input", ",", "pad", "=", "0", ")", ":", "\n", "    ", "r\"\"\"Pads symmetrically the spatial dimensions (last two dimensions) of the \n    input tensor. PAD specifies the amount of padding as [TOP, BOTTOM, LEFT, RIGHT].\n    If pad is an integer then each direction is padded by the same amount. In\n    order to achieve a different amount of padding in each direction of the \n    tensor, pad needs to be a tuple.\"\"\"", "\n", "\n", "# pad = [top,bottom,left,right]", "\n", "\n", "if", "isinstance", "(", "pad", ",", "int", ")", ":", "\n", "        ", "assert", "(", "pad", ">=", "0", ")", ",", "\"\"\"Pad must be either a non-negative integer \n        or a tuple.\"\"\"", "\n", "pad", "=", "(", "pad", ",", ")", "*", "4", "\n", "\n", "", "sflag", "=", "False", "\n", "if", "input", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "sflag", "=", "True", "\n", "input", "=", "input", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "assert", "(", "isinstance", "(", "pad", ",", "tuple", ")", "and", "len", "(", "pad", ")", "==", "4", ")", ",", "\" A tuple with 4 values for padding is expected as input.\"", "\n", "\n", "sz", "=", "list", "(", "input", ".", "size", "(", ")", ")", "\n", "\n", "assert", "(", "pad", "[", "0", "]", ">=", "0", "and", "pad", "[", "1", "]", ">=", "0", "and", "pad", "[", "2", "]", ">=", "0", "and", "pad", "[", "3", "]", ">=", "0", ")", ",", "\"Padding must be non-negative in each dimension.\"", "\n", "\n", "assert", "(", "pad", "[", "0", "]", "<=", "sz", "[", "-", "2", "]", "and", "pad", "[", "1", "]", "<=", "sz", "[", "-", "2", "]", "and", "pad", "[", "2", "]", "<=", "sz", "[", "-", "1", "]", "and", "pad", "[", "3", "]", "<=", "sz", "[", "-", "1", "]", ")", ",", "\"The padding values exceed the tensor's dimensions.\"", "\n", "\n", "sz", "[", "-", "1", "]", "=", "sz", "[", "-", "1", "]", "+", "sum", "(", "pad", "[", "2", ":", ":", "]", ")", "\n", "sz", "[", "-", "2", "]", "=", "sz", "[", "-", "2", "]", "+", "sum", "(", "pad", "[", "0", ":", "2", "]", ")", "\n", "\n", "out", "=", "th", ".", "zeros", "(", "sz", ")", ".", "type_as", "(", "input", ")", "\n", "\n", "# Copy the original tensor to the central part", "\n", "out", "[", "...", ",", "pad", "[", "0", "]", ":", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", ",", "pad", "[", "2", "]", ":", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", "]", "=", "input", "\n", "\n", "# Pad Top", "\n", "if", "pad", "[", "0", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "0", ":", "pad", "[", "0", "]", ",", ":", "]", "=", "reverse", "(", "out", "[", "...", ",", "pad", "[", "0", "]", ":", "2", "*", "pad", "[", "0", "]", ",", ":", "]", ",", "-", "2", ")", "\n", "\n", "# Pad Bottom", "\n", "", "if", "pad", "[", "1", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", ":", ":", ",", ":", "]", "=", "reverse", "(", "out", "[", "...", ",", "out", ".", "size", "(", "-", "2", ")", "\n", "-", "2", "*", "pad", "[", "1", "]", ":", "out", ".", "size", "(", "-", "2", ")", "-", "pad", "[", "1", "]", ",", ":", "]", ",", "-", "2", ")", "\n", "\n", "# Pad Left", "\n", "", "if", "pad", "[", "2", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", ":", ",", "0", ":", "pad", "[", "2", "]", "]", "=", "reverse", "(", "out", "[", "...", ",", ":", ",", "pad", "[", "2", "]", ":", "2", "*", "pad", "[", "2", "]", "]", ",", "-", "1", ")", "\n", "\n", "# Pad Right", "\n", "", "if", "pad", "[", "3", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", ":", ",", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", ":", ":", "]", "=", "reverse", "(", "out", "[", "...", ",", ":", ",", "out", ".", "size", "(", "-", "1", ")", "\n", "-", "2", "*", "pad", "[", "3", "]", ":", "out", ".", "size", "(", "-", "1", ")", "-", "pad", "[", "3", "]", "]", ",", "-", "1", ")", "\n", "\n", "", "if", "sflag", ":", "\n", "        ", "out", ".", "squeeze_", "(", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.symmetricPad_transpose2D": [[327, 394], ["isinstance", "list", "input.unsqueeze.clone", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "isinstance", "input.unsqueeze.size", "utils_model.reverse", "utils_model.reverse", "utils_model.reverse", "utils_model.reverse", "input.clone.squeeze_", "len"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "symmetricPad_transpose2D", "(", "input", ",", "crop", "=", "0", ")", ":", "\n", "    ", "r\"\"\"Adjoint of the SymmetricPad2D operation which amounts to a special type\n    of cropping. CROP specifies the amount of cropping as [TOP, BOTTOM, LEFT, RIGHT].\n    If crop is an integer then each direction is cropped by the same amount. In\n    order to achieve a different amount of cropping in each direction of the \n    tensor, crop needs to be a tuple.\"\"\"", "\n", "\n", "# crop = [top,bottom,left,right]", "\n", "\n", "if", "isinstance", "(", "crop", ",", "int", ")", ":", "\n", "        ", "assert", "(", "crop", ">=", "0", ")", ",", "\"\"\"Crop must be either a non-negative integer \n        or a tuple.\"\"\"", "\n", "crop", "=", "(", "crop", ",", ")", "*", "4", "\n", "\n", "", "sflag", "=", "False", "\n", "if", "input", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "sflag", "=", "True", "\n", "input", "=", "input", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "assert", "(", "isinstance", "(", "crop", ",", "tuple", ")", "and", "len", "(", "crop", ")", "==", "4", ")", ",", "\" A tuple with 4 values for padding is expected as input.\"", "\n", "\n", "sz", "=", "list", "(", "input", ".", "size", "(", ")", ")", "\n", "\n", "assert", "(", "crop", "[", "0", "]", ">=", "0", "and", "crop", "[", "1", "]", ">=", "0", "and", "crop", "[", "2", "]", ">=", "0", "and", "crop", "[", "3", "]", ">=", "0", ")", ",", "\"Crop must be non-negative in each dimension.\"", "\n", "\n", "assert", "(", "crop", "[", "0", "]", "+", "crop", "[", "1", "]", "<=", "sz", "[", "-", "2", "]", "and", "crop", "[", "2", "]", "+", "crop", "[", "3", "]", "<=", "sz", "[", "-", "1", "]", ")", ",", "\"Crop does not have valid values.\"", "\n", "\n", "out", "=", "input", ".", "clone", "(", ")", "\n", "\n", "# Top", "\n", "if", "crop", "[", "0", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "crop", "[", "0", "]", ":", "2", "*", "crop", "[", "0", "]", ",", ":", "]", "+=", "reverse", "(", "out", "[", "...", ",", "0", ":", "crop", "[", "0", "]", ",", ":", "]", ",", "-", "2", ")", "\n", "\n", "# Bottom ", "\n", "", "if", "crop", "[", "1", "]", "!=", "0", ":", "\n", "# out[...,sz[-2]-2*crop[1]:sz[-2]-crop[1],:] += reverse(out[...,sz[-2]-crop[1]::,:],-2) ", "\n", "        ", "out", "[", "...", ",", "-", "2", "*", "crop", "[", "1", "]", ":", "-", "crop", "[", "1", "]", ",", ":", "]", "+=", "reverse", "(", "out", "[", "...", ",", "-", "crop", "[", "1", "]", ":", ":", ",", ":", "]", ",", "-", "2", ")", "\n", "\n", "# Left ", "\n", "", "if", "crop", "[", "2", "]", "!=", "0", ":", "\n", "        ", "out", "[", "...", ",", "crop", "[", "2", "]", ":", "2", "*", "crop", "[", "2", "]", "]", "+=", "reverse", "(", "out", "[", "...", ",", "0", ":", "crop", "[", "2", "]", "]", ",", "-", "1", ")", "\n", "\n", "# Right", "\n", "", "if", "crop", "[", "3", "]", "!=", "0", ":", "\n", "# out[...,sz[-1]-2*crop[3]:sz[-1]-crop[3],:] += reverse(out[...,sz[-1]-crop[3]::,:],-1) ", "\n", "        ", "out", "[", "...", ",", "-", "2", "*", "crop", "[", "3", "]", ":", "-", "crop", "[", "3", "]", "]", "+=", "reverse", "(", "out", "[", "...", ",", "-", "crop", "[", "3", "]", ":", ":", "]", ",", "-", "1", ")", "\n", "\n", "", "if", "crop", "[", "1", "]", "==", "0", ":", "\n", "        ", "end_h", "=", "sz", "[", "-", "2", "]", "+", "1", "\n", "", "else", ":", "\n", "        ", "end_h", "=", "sz", "[", "-", "2", "]", "-", "crop", "[", "1", "]", "\n", "\n", "", "if", "crop", "[", "3", "]", "==", "0", ":", "\n", "        ", "end_w", "=", "sz", "[", "-", "1", "]", "+", "1", "\n", "", "else", ":", "\n", "        ", "end_w", "=", "sz", "[", "-", "1", "]", "-", "crop", "[", "3", "]", "\n", "\n", "", "out", "=", "out", "[", "...", ",", "crop", "[", "0", "]", ":", "end_h", ",", "crop", "[", "2", "]", ":", "end_w", "]", "\n", "\n", "\n", "if", "sflag", ":", "\n", "        ", "out", ".", "squeeze_", "(", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad2D": [[395, 416], ["utils_model.formatInput2Tuple", "sum", "utils_model.zeroPad2D", "utils_model.symmetricPad2D", "utils_model.periodicPad2D", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.zeroPad2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.symmetricPad2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.periodicPad2D"], ["", "def", "pad2D", "(", "input", ",", "pad", "=", "0", ",", "padType", "=", "'zero'", ")", ":", "\n", "    ", "r\"\"\"Pads the spatial dimensions (last two dimensions) of the \n    input tensor. PAD specifies the amount of padding as [TOP, BOTTOM, LEFT, RIGHT].\n    If pad is an integer then each direction is padded by the same amount. In\n    order to achieve a different amount of padding in each direction of the \n    tensor, pad needs to be a tuple. PadType specifies the type of padding.\n    Valid padding types are \"zero\",\"symmetric\" and \"periodic\". \"\"\"", "\n", "\n", "pad", "=", "formatInput2Tuple", "(", "pad", ",", "int", ",", "4", ")", "\n", "\n", "if", "sum", "(", "pad", ")", "==", "0", ":", "\n", "        ", "return", "input", "\n", "\n", "", "if", "padType", "==", "'zero'", ":", "\n", "        ", "return", "zeroPad2D", "(", "input", ",", "pad", ")", "\n", "", "elif", "padType", "==", "'symmetric'", ":", "\n", "        ", "return", "symmetricPad2D", "(", "input", ",", "pad", ")", "\n", "", "elif", "padType", "==", "'periodic'", ":", "\n", "        ", "return", "periodicPad2D", "(", "input", ",", "pad", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Unknown padding type.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad_transpose2D": [[417, 438], ["utils_model.formatInput2Tuple", "sum", "utils_model.crop2D", "utils_model.symmetricPad_transpose2D", "utils_model.periodicPad_transpose2D", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.crop2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.symmetricPad_transpose2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.periodicPad_transpose2D"], ["", "", "def", "pad_transpose2D", "(", "input", ",", "pad", "=", "0", ",", "padType", "=", "'zero'", ")", ":", "\n", "    ", "r\"\"\"Transpose operation of pad2D. PAD specifies the amount of padding as \n    [TOP, BOTTOM, LEFT, RIGHT].\n    If pad is an integer then each direction is padded by the same amount. In\n    order to achieve a different amount of padding in each direction of the \n    tensor, pad needs to be a tuple. PadType specifies the type of padding.\n    Valid padding types are \"zero\" and \"symmetric\". \"\"\"", "\n", "\n", "pad", "=", "formatInput2Tuple", "(", "pad", ",", "int", ",", "4", ")", "\n", "\n", "if", "sum", "(", "pad", ")", "==", "0", ":", "\n", "        ", "return", "input", "\n", "\n", "", "if", "padType", "==", "'zero'", ":", "\n", "        ", "return", "crop2D", "(", "input", ",", "pad", ")", "\n", "", "elif", "padType", "==", "'symmetric'", ":", "\n", "        ", "return", "symmetricPad_transpose2D", "(", "input", ",", "pad", ")", "\n", "", "elif", "padType", "==", "'periodic'", ":", "\n", "        ", "return", "periodicPad_transpose2D", "(", "input", ",", "pad", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Uknown padding type.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.signum": [[440, 444], ["torch.ones_like"], "function", ["None"], ["", "", "def", "signum", "(", "input", ")", ":", "\n", "    ", "out", "=", "-", "th", ".", "ones_like", "(", "input", ")", "\n", "out", "[", "input", ">", "0", "]", "=", "1", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx": [[445, 448], ["numpy.eye", "torch.from_numpy", "scipy.fftpack.dct"], "function", ["None"], ["", "def", "dctmtx", "(", "support", ",", "dtype", ")", ":", "\n", "    ", "D", "=", "np", ".", "eye", "(", "support", ",", "dtype", "=", "dtype", ")", "\n", "return", "th", ".", "from_numpy", "(", "dct", "(", "D", ",", "axis", "=", "0", ",", "norm", "=", "'ortho'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gen_dct2_kernel": [[449, 528], ["isinstance", "len", "utils_model.dctmtx", "dctmtx.view", "dctmtx.view", "numpy.zeros", "numpy.zeros", "numpy.arange", "torch.from_numpy", "utils_model.dctmtx", "h1.cuda.cuda", "h2.cuda.cuda", "numpy.arange", "h.cuda.cuda", "functools.reduce", "scipy.fftpack.dctn().flatten", "scipy.fftpack.dctn"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx"], ["", "def", "gen_dct2_kernel", "(", "support", ",", "dtype", "=", "'f'", ",", "GPU", "=", "False", ",", "nargout", "=", "1", ")", ":", "\n", "    ", "r\"\"\"If two output arguments are returned then:\n    h1 has dimensions [Px,1,Px,1] and h2 has dimensions [Py,1,1,Py] where\n    Px = support[0] and  Py = support[1].\n    \n    If a single output argument is returned then:\n    h has dimensions [Px*Py 1 Px Py].\n    \n    support : Either an integer or a tuple\n    \n    Usage example :\n    \n    x = th.randn(1,1,16,16).double()\n    h = utils.gen_dct2_kernel(8,'d',nargout = 1)\n    Dx = th.conv2d(x,h,stride = (8,8)) % it computes the 2D DCT of each \n    % non-overlapping block of size 8x8\n    \n    for k in range(2):\n        for l in range(2):\n            s = x[:,:,k*8:(k+1)*8,l*8:(l+1)*8].numpy().squeeze()\n            Ds = th.from_numpy(dctn(s,norm = 'ortho').flatten())\n            err = Ds - Dx[:,:,k,l]\n            print(err.abs().sum())\n    \n    Usage example 2:\n    \n    x = th.randn(1,1,16,16).double()\n    h1,h2 = utils.gen_dct2_kernel(8,'d',nargout = 2)\n    Dx = th.conv2d(x,h1,stride = (8,1)) % it computes the 1D DCT of each \n    % non-overlapping block of size 8x1\n    Dx = Dx.view(8,1,2,16)\n    Dx = th.conv2d(Dx,h2,stride = (1,8)) % it computes the 1D DCT of each\n    % non-overlapping block of size 1x8\n    Dx = Dx.view(1,64,2,2)\n    \n    for k in range(2):\n        for l in range(2):\n            s = x[:,:,k*8:(k+1)*8,l*8:(l+1)*8].numpy().squeeze()\n            Ds = th.from_numpy(dctn(s,norm = 'ortho').flatten())\n            err = Ds - Dx[:,:,k,l]\n            print(err.abs().sum())    \n    \n    \"\"\"", "\n", "assert", "(", "nargout", "==", "1", "or", "nargout", "==", "2", ")", ",", "\"One or two output arguments \"", "\"are expected.\"", "\n", "\n", "\n", "if", "isinstance", "(", "support", ",", "int", ")", ":", "\n", "        ", "support", "=", "(", "support", ",", "support", ")", "\n", "\n", "", "if", "len", "(", "support", ")", "<", "2", ":", "\n", "        ", "support", "=", "support", "*", "2", "\n", "\n", "", "if", "nargout", "==", "2", ":", "\n", "        ", "D", "=", "dctmtx", "(", "support", "[", "0", "]", ",", "dtype", ")", "\n", "h1", "=", "D", ".", "view", "(", "support", "[", "0", "]", ",", "1", ",", "support", "[", "0", "]", ",", "1", ")", "\n", "if", "support", "[", "1", "]", "!=", "support", "[", "0", "]", ":", "\n", "            ", "D", "=", "dctmtx", "(", "support", "[", "1", "]", ",", "dtype", ")", "\n", "", "h2", "=", "D", ".", "view", "(", "support", "[", "1", "]", ",", "1", ",", "1", ",", "support", "[", "1", "]", ")", "\n", "\n", "if", "th", ".", "cuda", ".", "is_available", "and", "GPU", ":", "\n", "            ", "h1", "=", "h1", ".", "cuda", "(", ")", "\n", "h2", "=", "h2", ".", "cuda", "(", ")", "\n", "\n", "", "return", "h1", ",", "h2", "\n", "", "else", ":", "\n", "        ", "h", "=", "np", ".", "zeros", "(", "(", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "support", "[", "0", ":", "2", "]", ")", ",", "1", ",", "support", "[", "0", "]", ",", "support", "[", "1", "]", ")", ",", "dtype", ")", "\n", "dirac", "=", "np", ".", "zeros", "(", "support", "[", "0", ":", "2", "]", ",", "dtype", ")", "\n", "for", "k", "in", "np", ".", "arange", "(", "support", "[", "0", "]", ")", ":", "\n", "            ", "for", "l", "in", "np", ".", "arange", "(", "support", "[", "1", "]", ")", ":", "\n", "                ", "dirac", "[", "k", ",", "l", "]", "=", "1", ";", "\n", "h", "[", ":", ",", "0", ",", "k", ",", "l", "]", "=", "dctn", "(", "dirac", ",", "norm", "=", "'ortho'", ")", ".", "flatten", "(", ")", "\n", "dirac", "[", "k", ",", "l", "]", "=", "0", "\n", "\n", "", "", "h", "=", "th", ".", "from_numpy", "(", "h", ")", "\n", "if", "th", ".", "cuda", ".", "is_available", "and", "GPU", ":", "\n", "            ", "h", "=", "h", ".", "cuda", "(", ")", "\n", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gen_dct3_kernel": [[529, 657], ["isinstance", "len", "len", "utils_model.dctmtx", "dctmtx.view", "dctmtx.view", "dctmtx.view", "utils_model.dctmtx", "utils_model.dctmtx", "h1.cuda.cuda", "h2.cuda.cuda", "h3.cuda.cuda", "utils_model.dctmtx", "dctmtx.view", "numpy.zeros", "numpy.zeros", "numpy.arange", "torch.from_numpy", "numpy.zeros", "numpy.zeros", "numpy.arange", "torch.from_numpy", "numpy.arange", "h1.cuda.cuda", "h2.cuda.cuda", "numpy.arange", "h.cuda.cuda", "functools.reduce", "scipy.fftpack.dctn().flatten", "functools.reduce", "numpy.arange", "scipy.fftpack.dctn().flatten", "scipy.fftpack.dctn", "scipy.fftpack.dctn"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.dctmtx"], ["", "", "def", "gen_dct3_kernel", "(", "support", ",", "dtype", "=", "'f'", ",", "GPU", "=", "False", ",", "nargout", "=", "1", ")", ":", "\n", "    ", "r\"\"\"If three output arguments are returned then:\n    h1 has dimensions [Pz,Pz,1,1], h2 has dimensions [Px,1,Px,1] and \n    h3 has dimensions [Py,1,1,Py] where Pz = support[0], Px = support[1] and \n    Py = support[2].\n    \n    If two output arguments are returned then:\n    h1 has dimensions [Pz,Pz,1,1] and h2 has dimensions [Px*Py,1,Px,Py].\n    \n    If a single output argument is returned then:\n    h has dimensions [Px*Py*Pz Pz Px Py].\n    \n    support : Either an integer or a tuple \n    \n    Usage example :\n    from scipy.fftpack import dctn\n    x = th.randn(1,3,16,16).double()\n    h = utils.gen_dct3_kernel((3,8,8),'d',nargout = 1)\n    Dx = th.conv2d(x,h,stride = (8,8)) % it computes the 3D DCT of each \n    % non-overlapping block of size 3x8x8\n    \n    for k in range(2):\n        for l in range(2):\n            s = x[:,:,k*8:(k+1)*8,l*8:(l+1)*8].numpy().squeeze()\n            Ds = th.from_numpy(dctn(s,norm = 'ortho').flatten())\n            err = Ds - Dx[:,:,k,l]\n            print(err.abs().sum())\n    \n    Usage example 2:\n    \n    x = th.randn(1,3,16,16).double()\n    h1,h2 = utils.gen_dct3_kernel((3,8,8),'d',nargout = 2)\n    Dx = th.conv2d(x,h1,stride = 1) % it computes the 1D DCT along the 3rd  \n    % dimension.\n    Dx = th.conv2d(Dx.view(3,1,16,16),h2,stride = (8,8)) % it computes the 2D \n    % DCT along the spatial dimensions\n    Dx = Dx.view(1,3*64,2,2)\n    \n    for k in range(2):\n        for l in range(2):\n            s = x[:,:,k*8:(k+1)*8,l*8:(l+1)*8].numpy().squeeze()\n            Ds = th.from_numpy(dctn(s,norm = 'ortho').flatten())\n            err = Ds - Dx[:,:,k,l]\n            print(err.abs().sum())\n\n    Usage example 3:\n    \n    x = th.randn(1,3,16,16).double()\n    h1,h2,h3 = utils.gen_dct3_kernel((3,8,8),'d',nargout = 3)\n    Dx = th.conv2d(x,h1,stride = 1) % it computes the 1D DCT along the 3rd \n    % dimension. \n    Dx = th.conv2d(Dx.view(3,1,16,16),h2,stride = (8,1)) % it computes the 1D \n    % DCT along the first spatial dimension\n    Dx = th.conv2d(Dx.view(3*8,1,2,16),h3,stride = (1,8)) % it computes the 1D DCT along the channel\n    % dimension (of size 3)\n    Dx = Dx.view(1,24*8,2,2)\n    \n    for k in range(2):\n        for l in range(2):\n            s = x[:,:,k*8:(k+1)*8,l*8:(l+1)*8].numpy().squeeze()\n            Ds = th.from_numpy(dctn(s,norm = 'ortho').flatten())\n            err = Ds - Dx[:,:,k,l]\n            print(err.abs().sum())\n    \n    \"\"\"", "\n", "assert", "(", "nargout", "==", "1", "or", "nargout", "==", "2", "or", "nargout", "==", "3", ")", ",", "\"From one to three \"", "\"output arguments are expected.\"", "\n", "\n", "\n", "if", "isinstance", "(", "support", ",", "int", ")", ":", "\n", "        ", "support", "=", "(", "support", ",", "support", ",", "support", ")", "\n", "\n", "", "if", "len", "(", "support", ")", "<", "2", ":", "\n", "        ", "support", "=", "support", "*", "3", "\n", "\n", "", "if", "len", "(", "support", ")", "<", "3", ":", "\n", "        ", "support", "=", "(", "1", ",", ")", "+", "support", "\n", "\n", "", "if", "nargout", "==", "3", ":", "\n", "        ", "D", "=", "dctmtx", "(", "support", "[", "0", "]", ",", "dtype", ")", "\n", "h1", "=", "D", ".", "view", "(", "support", "[", "0", "]", ",", "support", "[", "0", "]", ",", "1", ",", "1", ")", "\n", "if", "support", "[", "1", "]", "!=", "support", "[", "0", "]", ":", "\n", "            ", "D", "=", "dctmtx", "(", "support", "[", "1", "]", ",", "dtype", ")", "\n", "", "h2", "=", "D", ".", "view", "(", "support", "[", "1", "]", ",", "1", ",", "support", "[", "1", "]", ",", "1", ")", "\n", "if", "support", "[", "2", "]", "!=", "support", "[", "1", "]", ":", "\n", "            ", "D", "=", "dctmtx", "(", "support", "[", "2", "]", ",", "dtype", ")", "\n", "", "h3", "=", "D", ".", "view", "(", "support", "[", "2", "]", ",", "1", ",", "1", ",", "support", "[", "2", "]", ")", "\n", "\n", "if", "th", ".", "cuda", ".", "is_available", "and", "GPU", ":", "\n", "            ", "h1", "=", "h1", ".", "cuda", "(", ")", "\n", "h2", "=", "h2", ".", "cuda", "(", ")", "\n", "h3", "=", "h3", ".", "cuda", "(", ")", "\n", "\n", "", "return", "h1", ",", "h2", ",", "h3", "\n", "", "elif", "nargout", "==", "2", ":", "\n", "        ", "D", "=", "dctmtx", "(", "support", "[", "0", "]", ",", "dtype", ")", "\n", "h1", "=", "D", ".", "view", "(", "support", "[", "0", "]", ",", "support", "[", "0", "]", ",", "1", ",", "1", ")", "\n", "\n", "h2", "=", "np", ".", "zeros", "(", "(", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "support", "[", "1", ":", "3", "]", ")", ",", "1", ",", "support", "[", "1", "]", ",", "support", "[", "2", "]", ")", ",", "dtype", ")", "\n", "dirac", "=", "np", ".", "zeros", "(", "support", "[", "1", ":", "3", "]", ",", "dtype", ")", "\n", "for", "k", "in", "np", ".", "arange", "(", "support", "[", "1", "]", ")", ":", "\n", "            ", "for", "l", "in", "np", ".", "arange", "(", "support", "[", "2", "]", ")", ":", "\n", "                ", "dirac", "[", "k", ",", "l", "]", "=", "1", ";", "\n", "h2", "[", ":", ",", "0", ",", "k", ",", "l", "]", "=", "dctn", "(", "dirac", ",", "norm", "=", "'ortho'", ")", ".", "flatten", "(", ")", "\n", "dirac", "[", "k", ",", "l", "]", "=", "0", "\n", "\n", "", "", "h2", "=", "th", ".", "from_numpy", "(", "h2", ")", "\n", "\n", "if", "th", ".", "cuda", ".", "is_available", "and", "GPU", ":", "\n", "            ", "h1", "=", "h1", ".", "cuda", "(", ")", "\n", "h2", "=", "h2", ".", "cuda", "(", ")", "\n", "\n", "", "return", "h1", ",", "h2", "\n", "", "else", ":", "\n", "        ", "h", "=", "np", ".", "zeros", "(", "(", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "support", "[", "0", ":", "3", "]", ")", ",", "support", "[", "0", "]", ",", "support", "[", "1", "]", ",", "support", "[", "2", "]", ")", ",", "dtype", ")", "\n", "dirac", "=", "np", ".", "zeros", "(", "support", "[", "0", ":", "3", "]", ",", "dtype", ")", "\n", "for", "k", "in", "np", ".", "arange", "(", "support", "[", "0", "]", ")", ":", "\n", "            ", "for", "l", "in", "np", ".", "arange", "(", "support", "[", "1", "]", ")", ":", "\n", "                ", "for", "m", "in", "np", ".", "arange", "(", "support", "[", "2", "]", ")", ":", "\n", "                    ", "dirac", "[", "k", ",", "l", ",", "m", "]", "=", "1", ";", "\n", "h", "[", ":", ",", "k", ",", "l", ",", "m", "]", "=", "dctn", "(", "dirac", ",", "norm", "=", "'ortho'", ")", ".", "flatten", "(", ")", "\n", "dirac", "[", "k", ",", "l", ",", "m", "]", "=", "0", "\n", "\n", "", "", "", "h", "=", "th", ".", "from_numpy", "(", "h", ")", "\n", "if", "th", ".", "cuda", ".", "is_available", "and", "GPU", ":", "\n", "            ", "h", "=", "h", ".", "cuda", "(", ")", "\n", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.__shift": [[659, 742], ["functools.reduce", "range", "isinstance", "Exception", "functools.reduce", "Exception", "len", "x.dim", "Exception", "slice", "x.dim", "indices.append", "range", "len", "x.dim", "print", "slice", "x.dim", "range", "isinstance", "math.fabs", "range", "x.dim", "torch.zeros_like", "range", "Exception", "x.dim", "len", "x.dim", "x.dim", "x.dim", "numpy.arange", "tuple", "tuple", "tuple", "list", "list", "list", "list", "tuple", "slice", "slice", "slice", "slice", "range", "range", "range", "range"], "function", ["None"], ["", "", "def", "__shift", "(", "x", ",", "s", ",", "bc", "=", "'circular'", ")", ":", "\n", "    ", "\"\"\" Shift operator that can treat different boundary conditions. It applies \n    to a tensor of arbitrary dimensions. \n    ----------\n    Usage: xs = shift(x,(0,1,-3,3),'reflexive')\n    ----------\n    Parameters\n    ----------\n    x : tensor.\n    s : tuple that matches the dimensions of x, with the corresponding shifts.\n    bc: String with the prefered boundary conditions (bc='circular'|'reflexive'|'zero')\n        (Default: 'circular')\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "bc", ",", "str", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"bc must be of type string\"", ")", "\n", "\n", "", "if", "not", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "and", "y", ",", "[", "isinstance", "(", "k", ",", "int", ")", "for", "k", "in", "s", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"s must be a tuple of ints\"", ")", "\n", "\n", "", "if", "len", "(", "s", ")", "<", "x", ".", "dim", "(", ")", ":", "\n", "       ", "s", "=", "s", "+", "(", "0", ",", ")", "*", "(", "x", ".", "dim", "(", ")", "-", "len", "(", "s", ")", ")", "\n", "", "elif", "len", "(", "s", ")", ">", "x", ".", "dim", "(", ")", ":", "\n", "        ", "print", "(", "\"The shift values will be truncated to match the \"", "+", "\"dimensions of the input tensor. The trailing extra elements will\"", "+", "\" be discarded.\"", ")", "\n", "s", "=", "s", "[", "0", ":", "x", ".", "dim", "(", ")", "]", "\n", "\n", "", "if", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "or", "y", ",", "[", "math", ".", "fabs", "(", "s", "[", "i", "]", ")", ">", "x", ".", "shape", "[", "i", "]", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"The shift steps should not exceed in absolute values\"", "+", "\" the size of the corresponding dimensions.\"", ")", "\n", "\n", "# use a list sequence instead of a tuple since the latter is an ", "\n", "# immutable sequence and cannot be altered         ", "\n", "", "indices", "=", "[", "slice", "(", "0", ",", "x", ".", "shape", "[", "0", "]", ")", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "x", ".", "dim", "(", ")", ")", ":", "\n", "        ", "indices", ".", "append", "(", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", ")", ")", "\n", "\n", "", "if", "bc", "==", "'circular'", ":", "\n", "        ", "xs", "=", "x", "[", ":", "]", "# make a copy of x", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "m", "=", "x", ".", "shape", "[", "i", "]", "\n", "idx", "=", "indices", "[", ":", "]", "\n", "idx", "[", "i", "]", "=", "(", "np", ".", "arange", "(", "0", ",", "m", ")", "-", "s", "[", "i", "]", ")", "%", "m", "\n", "xs", "=", "xs", "[", "tuple", "(", "idx", ")", "]", "\n", "", "", "", "elif", "bc", "==", "'reflexive'", ":", "\n", "        ", "xs", "=", "x", "[", ":", "]", "# make a copy of x", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "idx", "=", "indices", "[", ":", "]", "\n", "if", "s", "[", "i", "]", ">", "0", ":", "# right shift                    ", "\n", "                    ", "idx", "[", "i", "]", "=", "list", "(", "range", "(", "s", "[", "i", "]", "-", "1", ",", "-", "1", ",", "-", "1", ")", ")", "+", "list", "(", "range", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "-", "s", "[", "i", "]", ")", ")", "\n", "", "else", ":", "# left shift", "\n", "                    ", "idx", "[", "i", "]", "=", "list", "(", "range", "(", "-", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", ")", "+", "list", "(", "range", "(", "x", ".", "shape", "[", "i", "]", "-", "1", ",", "x", ".", "shape", "[", "i", "]", "+", "s", "[", "i", "]", "-", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "xs", "=", "xs", "[", "tuple", "(", "idx", ")", "]", "\n", "", "", "", "elif", "bc", "==", "'zero'", ":", "\n", "        ", "xs", "=", "th", ".", "zeros_like", "(", "x", ")", "\n", "idx_x", "=", "indices", "[", ":", "]", "\n", "idx_xs", "=", "indices", "[", ":", "]", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "if", "s", "[", "i", "]", ">", "0", ":", "# right shift", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "-", "s", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "", "else", ":", "# left shift", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "-", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "+", "s", "[", "i", "]", ")", "\n", "\n", "", "", "", "xs", "[", "tuple", "(", "idx_xs", ")", "]", "=", "x", "[", "tuple", "(", "idx_x", ")", "]", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Unknown boundary conditions\"", ")", "\n", "\n", "", "return", "xs", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.__shift_transpose": [[743, 842], ["functools.reduce", "range", "isinstance", "Exception", "functools.reduce", "Exception", "len", "x.dim", "Exception", "slice", "x.dim", "indices.append", "range", "len", "x.dim", "print", "slice", "x.dim", "range", "isinstance", "math.fabs", "range", "x.dim", "torch.zeros_like", "torch.zeros_like", "range", "Exception", "x.dim", "len", "x.dim", "x.dim", "utils_model.reverse", "x.dim", "numpy.arange", "tuple", "slice", "slice", "slice", "slice", "slice", "slice", "tuple", "tuple", "tuple", "tuple", "tuple", "slice", "slice", "slice", "slice", "tuple"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "__shift_transpose", "(", "x", ",", "s", ",", "bc", "=", "'circular'", ")", ":", "\n", "\n", "    ", "r\"\"\" Transpose of the shift operator that can treat different boundary conditions. \n    It applies to a tensor of arbitrary dimensions. \n    ----------\n    Usage: xs = shift_transpose(x,(0,1,-3,3),'reflexive')\n    ----------\n    Parameters\n    ----------\n    x : tensor.\n    s : tuple that matches the dimensions of x, with the corresponding shifts.\n    bc: String with the prefered boundary conditions (bc='circular'|'reflexive'|'zero')\n        (Default: 'circular')\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "bc", ",", "str", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"bc must be of type string\"", ")", "\n", "\n", "", "if", "not", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "and", "y", ",", "[", "isinstance", "(", "k", ",", "int", ")", "for", "k", "in", "s", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"s must be a tuple of ints\"", ")", "\n", "\n", "", "if", "len", "(", "s", ")", "<", "x", ".", "dim", "(", ")", ":", "\n", "       ", "s", "=", "s", "+", "(", "0", ",", ")", "*", "(", "x", ".", "dim", "(", ")", "-", "len", "(", "s", ")", ")", "\n", "", "elif", "len", "(", "s", ")", ">", "x", ".", "dim", "(", ")", ":", "\n", "        ", "print", "(", "\"The shift values will be truncated to match the \"", "+", "\"dimensions of the input tensor. The trailing extra elements will\"", "+", "\" be discarded.\"", ")", "\n", "s", "=", "s", "[", "0", ":", "x", ".", "dim", "(", ")", "]", "\n", "\n", "", "if", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "or", "y", ",", "[", "math", ".", "fabs", "(", "s", "[", "i", "]", ")", ">", "x", ".", "shape", "[", "i", "]", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"The shift steps should not exceed in absolute values\"", "+", "\" the size of the corresponding dimensions.\"", ")", "\n", "\n", "# use a list sequence instead of a tuple since the latter is an ", "\n", "# immutable sequence and cannot be altered ", "\n", "", "indices", "=", "[", "slice", "(", "0", ",", "x", ".", "shape", "[", "0", "]", ")", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "x", ".", "dim", "(", ")", ")", ":", "\n", "        ", "indices", ".", "append", "(", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", ")", ")", "\n", "\n", "", "if", "bc", "==", "'circular'", ":", "\n", "        ", "xs", "=", "x", "[", ":", "]", "# make a copy of x", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "m", "=", "x", ".", "shape", "[", "i", "]", "\n", "idx", "=", "indices", "[", ":", "]", "\n", "idx", "[", "i", "]", "=", "(", "np", ".", "arange", "(", "0", ",", "m", ")", "+", "s", "[", "i", "]", ")", "%", "m", "\n", "xs", "=", "xs", "[", "tuple", "(", "idx", ")", "]", "\n", "", "", "", "elif", "bc", "==", "'reflexive'", ":", "\n", "        ", "y", "=", "x", "[", ":", "]", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "xs", "=", "th", ".", "zeros_like", "(", "x", ")", "\n", "idx_x_a", "=", "indices", "[", ":", "]", "\n", "#idx_x_b = indices[:]", "\n", "idx_xs_a", "=", "indices", "[", ":", "]", "\n", "idx_xs_b", "=", "indices", "[", ":", "]", "\n", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "xs", "=", "y", "[", ":", "]", "\n", "", "else", ":", "\n", "                ", "if", "s", "[", "i", "]", ">", "0", ":", "\n", "                    ", "idx_xs_a", "[", "i", "]", "=", "slice", "(", "0", ",", "-", "s", "[", "i", "]", ")", "\n", "idx_xs_b", "[", "i", "]", "=", "slice", "(", "0", ",", "s", "[", "i", "]", ")", "\n", "idx_x_a", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "None", ")", "\n", "#idx_x_b[i] = slice(s[i]-1,None,-1) #Pytorch does not ", "\n", "# support negative steps", "\n", "", "else", ":", "\n", "                    ", "idx_xs_a", "[", "i", "]", "=", "slice", "(", "-", "s", "[", "i", "]", ",", "None", ")", "\n", "idx_xs_b", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "None", ")", "\n", "idx_x_a", "[", "i", "]", "=", "slice", "(", "0", ",", "s", "[", "i", "]", ")", "\n", "#idx_x_b[i] = slice(-1,s[i]-1,-1) #Pytorch does not ", "\n", "# support negative steps", "\n", "\n", "", "xs", "[", "tuple", "(", "idx_xs_a", ")", "]", "=", "y", "[", "tuple", "(", "idx_x_a", ")", "]", "\n", "xs", "[", "tuple", "(", "idx_xs_b", ")", "]", "+=", "reverse", "(", "y", "[", "tuple", "(", "idx_xs_b", ")", "]", ",", "dim", "=", "i", ")", "\n", "#xs[tuple(idx_xs_b)] += y[tuple(idx_x_b)]", "\n", "y", "=", "xs", "[", ":", "]", "\n", "\n", "", "", "", "elif", "bc", "==", "'zero'", ":", "\n", "        ", "xs", "=", "th", ".", "zeros_like", "(", "x", ")", "\n", "idx_x", "=", "indices", "[", ":", "]", "\n", "idx_xs", "=", "indices", "[", ":", "]", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "if", "s", "[", "i", "]", "<", "0", ":", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "+", "s", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "-", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "-", "s", "[", "i", "]", ")", "\n", "\n", "", "", "", "xs", "[", "tuple", "(", "idx_xs", ")", "]", "=", "x", "[", "tuple", "(", "idx_x", ")", "]", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Unknown boundary conditions\"", ")", "\n", "\n", "", "return", "xs", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift": [[843, 925], ["functools.reduce", "range", "isinstance", "Exception", "functools.reduce", "Exception", "len", "x.dim", "Exception", "slice", "x.dim", "indices.append", "x.clone", "range", "len", "x.dim", "print", "slice", "x.dim", "x.clone", "range", "isinstance", "math.fabs", "range", "list", "x.dim", "torch.zeros_like", "range", "Exception", "x.dim", "len", "x.dim", "x.dim", "x.dim", "tuple", "tuple", "tuple", "numpy.arange", "list", "list", "list", "list", "tuple", "slice", "slice", "slice", "slice", "range", "range", "range", "range"], "function", ["None"], ["", "def", "shift", "(", "x", ",", "s", ",", "bc", "=", "'circular'", ")", ":", "\n", "    ", "\"\"\" Shift operator that can treat different boundary conditions. It applies \n    to a tensor of arbitrary dimensions. \n    ----------\n    Usage: xs = shift(x,(0,1,-3,3),'reflexive')\n    ----------\n    Parameters\n    ----------\n    x : tensor.\n    s : tuple that matches the dimensions of x, with the corresponding shifts.\n    bc: String with the prefered boundary conditions (bc='circular'|'reflexive'|'zero')\n        (Default: 'circular')\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "bc", ",", "str", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"bc must be of type string\"", ")", "\n", "\n", "", "if", "not", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "and", "y", ",", "[", "isinstance", "(", "k", ",", "int", ")", "for", "k", "in", "s", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"s must be a tuple of ints\"", ")", "\n", "\n", "", "if", "len", "(", "s", ")", "<", "x", ".", "dim", "(", ")", ":", "\n", "       ", "s", "=", "s", "+", "(", "0", ",", ")", "*", "(", "x", ".", "dim", "(", ")", "-", "len", "(", "s", ")", ")", "\n", "", "elif", "len", "(", "s", ")", ">", "x", ".", "dim", "(", ")", ":", "\n", "        ", "print", "(", "\"The shift values will be truncated to match the \"", "+", "\"dimensions of the input tensor. The trailing extra elements will\"", "+", "\" be discarded.\"", ")", "\n", "s", "=", "s", "[", "0", ":", "x", ".", "dim", "(", ")", "]", "\n", "\n", "", "if", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "or", "y", ",", "[", "math", ".", "fabs", "(", "s", "[", "i", "]", ")", ">", "x", ".", "shape", "[", "i", "]", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"The shift steps should not exceed in absolute values\"", "+", "\" the size of the corresponding dimensions.\"", ")", "\n", "\n", "# use a list sequence instead of a tuple since the latter is an ", "\n", "# immutable sequence and cannot be altered         ", "\n", "", "indices", "=", "[", "slice", "(", "0", ",", "x", ".", "shape", "[", "0", "]", ")", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "x", ".", "dim", "(", ")", ")", ":", "\n", "        ", "indices", ".", "append", "(", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", ")", ")", "\n", "\n", "", "if", "bc", "==", "'circular'", ":", "\n", "        ", "xs", "=", "x", ".", "clone", "(", ")", "# make a copy of x", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "m", "=", "x", ".", "shape", "[", "i", "]", "\n", "idx", "=", "indices", "[", ":", "]", "\n", "idx", "[", "i", "]", "=", "list", "(", "(", "np", ".", "arange", "(", "0", ",", "m", ")", "-", "s", "[", "i", "]", ")", "%", "m", ")", "\n", "xs", "=", "xs", "[", "tuple", "(", "idx", ")", "]", "\n", "", "", "", "elif", "bc", "==", "'reflexive'", ":", "\n", "        ", "xs", "=", "x", ".", "clone", "(", ")", "# make a copy of x", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "idx", "=", "indices", "[", ":", "]", "\n", "if", "s", "[", "i", "]", ">", "0", ":", "# right shift                    ", "\n", "                    ", "idx", "[", "i", "]", "=", "list", "(", "range", "(", "s", "[", "i", "]", "-", "1", ",", "-", "1", ",", "-", "1", ")", ")", "+", "list", "(", "range", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "-", "s", "[", "i", "]", ")", ")", "\n", "", "else", ":", "# left shift", "\n", "                    ", "idx", "[", "i", "]", "=", "list", "(", "range", "(", "-", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", ")", "+", "list", "(", "range", "(", "x", ".", "shape", "[", "i", "]", "-", "1", ",", "x", ".", "shape", "[", "i", "]", "+", "s", "[", "i", "]", "-", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "xs", "=", "xs", "[", "tuple", "(", "idx", ")", "]", "\n", "", "", "", "elif", "bc", "==", "'zero'", ":", "\n", "        ", "xs", "=", "th", ".", "zeros_like", "(", "x", ")", "\n", "idx_x", "=", "indices", "[", ":", "]", "\n", "idx_xs", "=", "indices", "[", ":", "]", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "if", "s", "[", "i", "]", ">", "0", ":", "# right shift", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "-", "s", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "", "else", ":", "# left shift", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "-", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "+", "s", "[", "i", "]", ")", "\n", "\n", "", "", "", "xs", "[", "tuple", "(", "idx_xs", ")", "]", "=", "x", "[", "tuple", "(", "idx_x", ")", "]", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Unknown boundary conditions\"", ")", "\n", "\n", "", "return", "xs", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift_transpose": [[926, 1025], ["functools.reduce", "range", "isinstance", "Exception", "functools.reduce", "Exception", "len", "x.dim", "Exception", "slice", "x.dim", "indices.append", "x.clone", "range", "len", "x.dim", "print", "slice", "x.dim", "x.clone", "range", "isinstance", "math.fabs", "range", "list", "x.dim", "torch.zeros_like", "torch.zeros_like", "range", "Exception", "x.dim", "len", "x.dim", "x.dim", "xs.clone.clone", "utils_model.reverse", "y.clone.clone", "x.dim", "tuple", "slice", "slice", "slice", "slice", "slice", "slice", "tuple", "tuple", "numpy.arange", "tuple", "tuple", "tuple", "slice", "slice", "slice", "slice", "tuple"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "shift_transpose", "(", "x", ",", "s", ",", "bc", "=", "'circular'", ")", ":", "\n", "\n", "    ", "r\"\"\" Transpose of the shift operator that can treat different boundary conditions. \n    It applies to a tensor of arbitrary dimensions. \n    ----------\n    Usage: xs = shift_transpose(x,(0,1,-3,3),'reflexive')\n    ----------\n    Parameters\n    ----------\n    x : tensor.\n    s : tuple that matches the dimensions of x, with the corresponding shifts.\n    bc: String with the prefered boundary conditions (bc='circular'|'reflexive'|'zero')\n        (Default: 'circular')\n    \"\"\"", "\n", "\n", "if", "not", "isinstance", "(", "bc", ",", "str", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"bc must be of type string\"", ")", "\n", "\n", "", "if", "not", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "and", "y", ",", "[", "isinstance", "(", "k", ",", "int", ")", "for", "k", "in", "s", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"s must be a tuple of ints\"", ")", "\n", "\n", "", "if", "len", "(", "s", ")", "<", "x", ".", "dim", "(", ")", ":", "\n", "       ", "s", "=", "s", "+", "(", "0", ",", ")", "*", "(", "x", ".", "dim", "(", ")", "-", "len", "(", "s", ")", ")", "\n", "", "elif", "len", "(", "s", ")", ">", "x", ".", "dim", "(", ")", ":", "\n", "        ", "print", "(", "\"The shift values will be truncated to match the \"", "+", "\"dimensions of the input tensor. The trailing extra elements will\"", "+", "\" be discarded.\"", ")", "\n", "s", "=", "s", "[", "0", ":", "x", ".", "dim", "(", ")", "]", "\n", "\n", "", "if", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "or", "y", ",", "[", "math", ".", "fabs", "(", "s", "[", "i", "]", ")", ">", "x", ".", "shape", "[", "i", "]", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", "]", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"The shift steps should not exceed in absolute values\"", "+", "\" the size of the corresponding dimensions.\"", ")", "\n", "\n", "# use a list sequence instead of a tuple since the latter is an ", "\n", "# immutable sequence and cannot be altered ", "\n", "", "indices", "=", "[", "slice", "(", "0", ",", "x", ".", "shape", "[", "0", "]", ")", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "x", ".", "dim", "(", ")", ")", ":", "\n", "        ", "indices", ".", "append", "(", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", ")", ")", "\n", "\n", "", "if", "bc", "==", "'circular'", ":", "\n", "        ", "xs", "=", "x", ".", "clone", "(", ")", "# make a copy of x", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "m", "=", "x", ".", "shape", "[", "i", "]", "\n", "idx", "=", "indices", "[", ":", "]", "\n", "idx", "[", "i", "]", "=", "list", "(", "(", "np", ".", "arange", "(", "0", ",", "m", ")", "+", "s", "[", "i", "]", ")", "%", "m", ")", "\n", "xs", "=", "xs", "[", "tuple", "(", "idx", ")", "]", "\n", "", "", "", "elif", "bc", "==", "'reflexive'", ":", "\n", "        ", "y", "=", "x", ".", "clone", "(", ")", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "xs", "=", "th", ".", "zeros_like", "(", "x", ")", "\n", "idx_x_a", "=", "indices", "[", ":", "]", "\n", "#idx_x_b = indices[:]", "\n", "idx_xs_a", "=", "indices", "[", ":", "]", "\n", "idx_xs_b", "=", "indices", "[", ":", "]", "\n", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "xs", "=", "y", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                ", "if", "s", "[", "i", "]", ">", "0", ":", "\n", "                    ", "idx_xs_a", "[", "i", "]", "=", "slice", "(", "0", ",", "-", "s", "[", "i", "]", ")", "\n", "idx_xs_b", "[", "i", "]", "=", "slice", "(", "0", ",", "s", "[", "i", "]", ")", "\n", "idx_x_a", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "None", ")", "\n", "#idx_x_b[i] = slice(s[i]-1,None,-1) #Pytorch does not ", "\n", "# support negative steps", "\n", "", "else", ":", "\n", "                    ", "idx_xs_a", "[", "i", "]", "=", "slice", "(", "-", "s", "[", "i", "]", ",", "None", ")", "\n", "idx_xs_b", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "None", ")", "\n", "idx_x_a", "[", "i", "]", "=", "slice", "(", "0", ",", "s", "[", "i", "]", ")", "\n", "#idx_x_b[i] = slice(-1,s[i]-1,-1) #Pytorch does not ", "\n", "# support negative steps", "\n", "\n", "", "xs", "[", "tuple", "(", "idx_xs_a", ")", "]", "=", "y", "[", "tuple", "(", "idx_x_a", ")", "]", "\n", "xs", "[", "tuple", "(", "idx_xs_b", ")", "]", "+=", "reverse", "(", "y", "[", "tuple", "(", "idx_xs_b", ")", "]", ",", "dim", "=", "i", ")", "\n", "#xs[tuple(idx_xs_b)] += y[tuple(idx_x_b)]", "\n", "y", "=", "xs", ".", "clone", "(", ")", "\n", "\n", "", "", "", "elif", "bc", "==", "'zero'", ":", "\n", "        ", "xs", "=", "th", ".", "zeros_like", "(", "x", ")", "\n", "idx_x", "=", "indices", "[", ":", "]", "\n", "idx_xs", "=", "indices", "[", ":", "]", "\n", "for", "i", "in", "range", "(", "x", ".", "dim", "(", ")", ")", ":", "\n", "            ", "if", "s", "[", "i", "]", "==", "0", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "if", "s", "[", "i", "]", "<", "0", ":", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "+", "s", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "-", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "                    ", "idx_x", "[", "i", "]", "=", "slice", "(", "s", "[", "i", "]", ",", "x", ".", "shape", "[", "i", "]", ")", "\n", "idx_xs", "[", "i", "]", "=", "slice", "(", "0", ",", "x", ".", "shape", "[", "i", "]", "-", "s", "[", "i", "]", ")", "\n", "\n", "", "", "", "xs", "[", "tuple", "(", "idx_xs", ")", "]", "=", "x", "[", "tuple", "(", "idx_x", ")", "]", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Unknown boundary conditions\"", ")", "\n", "\n", "", "return", "xs", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.compute_patch_overlap": [[1026, 1094], ["isinstance", "isinstance", "functools.reduce", "torch.eye().type", "h.cuda.view", "torch.ones().type", "torch.conv2d", "torch.conv_transpose2d", "th.conv_transpose2d.view", "len", "len", "torch.cuda.is_available", "x.cuda.cuda", "h.cuda.cuda", "len", "Exception", "torch.eye", "torch.ones", "len"], "function", ["None"], ["", "def", "compute_patch_overlap", "(", "shape", ",", "patchSize", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "GPU", "=", "False", ",", "dtype", "=", "'f'", ")", ":", "\n", "    ", "r\"\"\" Returns a tensor whose dimensions are equal to 'shape' and it \n    indicates how many patches extracted from the image (the patches are of \n    size patchSize and are extracted using a specified stride) each pixel of \n    the image contributes. \n\n    For example below is the array which indicates how many times each pixel\n    at the particular location of an image of size 16 x 16 has been found in \n    any of the 49 4x4 patches that have been extracted using a stride=2.\n\n    T = \n     1     1     2     2     2     2     2     2     2     2     2     2     2     2     1     1\n     1     1     2     2     2     2     2     2     2     2     2     2     2     2     1     1\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     2     2     4     4     4     4     4     4     4     4     4     4     4     4     2     2\n     1     1     2     2     2     2     2     2     2     2     2     2     2     2     1     1\n     1     1     2     2     2     2     2     2     2     2     2     2     2     2     1     1\n\n\n     Based on this table the pixel at the location (3,2) has been used in 4\n     different patches while the pixel at the location (15,4) has been used in\n     2 different patches.\"\"\"", "\n", "\n", "assert", "(", "isinstance", "(", "shape", ",", "tuple", ")", ")", ",", "\"shape is expected to be a tuple.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "if", "len", "(", "shape", ")", "<", "4", ":", "\n", "        ", "shape", "=", "(", "1", ",", ")", "*", "(", "4", "-", "len", "(", "shape", ")", ")", "+", "shape", "\n", "", "elif", "len", "(", "shape", ")", ">", "4", ":", "\n", "        ", "shape", "=", "shape", "[", "0", ":", "3", "]", "\n", "\n", "", "if", "len", "(", "patchSize", ")", "<", "2", ":", "\n", "        ", "patchSize", "=", "patchSize", "*", "2", "\n", "\n", "", "if", "dtype", "==", "'f'", ":", "\n", "        ", "dtype", "=", "th", ".", "FloatTensor", "\n", "", "elif", "dtype", "==", "'d'", ":", "\n", "        ", "dtype", "=", "th", ".", "DoubleTensor", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Supported data types are 'f' (float) and 'd' (double).\"", ")", "\n", "\n", "\n", "", "shape_", "=", "(", "shape", "[", "0", "]", "*", "shape", "[", "1", "]", ",", "1", ",", "shape", "[", "2", "]", ",", "shape", "[", "3", "]", ")", "\n", "\n", "\n", "Pn", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "patchSize", "[", "0", ":", "2", "]", ")", "\n", "h", "=", "th", ".", "eye", "(", "Pn", ")", ".", "type", "(", "dtype", ")", "\n", "h", "=", "h", ".", "view", "(", "Pn", ",", "1", ",", "patchSize", "[", "0", "]", ",", "patchSize", "[", "1", "]", ")", "\n", "\n", "x", "=", "th", ".", "ones", "(", "shape_", ")", ".", "type", "(", "dtype", ")", "\n", "\n", "if", "th", ".", "cuda", ".", "is_available", "(", ")", "and", "GPU", ":", "\n", "        ", "x", "=", "x", ".", "cuda", "(", ")", "\n", "h", "=", "h", ".", "cuda", "(", ")", "\n", "\n", "", "T", "=", "th", ".", "conv2d", "(", "x", ",", "h", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "T", "=", "th", ".", "conv_transpose2d", "(", "T", ",", "h", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ")", "\n", "\n", "return", "T", ".", "view", "(", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple": [[1095, 1113], ["isinstance", "isinstance", "tuple", "str", "len", "len", "typeB", "type", "str", "len", "str", "len", "str"], "function", ["None"], ["", "def", "formatInput2Tuple", "(", "input", ",", "typeB", ",", "numel", ",", "strict", "=", "True", ")", ":", "\n", "    ", "assert", "(", "isinstance", "(", "input", ",", "(", "tuple", ",", "typeB", ")", ")", ")", ",", "\"input is expected to be of type \"", "\"tuple or of type \"", "+", "str", "(", "typeB", ")", "[", "8", ":", "-", "2", "]", "+", "\" but instead an input of \"", "+", "\"type \"", "+", "str", "(", "type", "(", "input", ")", ")", "+", "\" was provided.\"", "\n", "\n", "if", "isinstance", "(", "input", ",", "typeB", ")", ":", "\n", "        ", "input", "=", "(", "input", ",", ")", "*", "numel", "\n", "\n", "", "if", "strict", ":", "\n", "        ", "assert", "(", "len", "(", "input", ")", "==", "numel", ")", ",", "\"An input of size \"", "+", "str", "(", "numel", ")", "+", "\" is expected \"", "\"but instead input = \"", "+", "str", "(", "input", ")", "+", "\" was provided.\"", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "input", ")", "<", "numel", ":", "\n", "            ", "input", "=", "input", "+", "(", "input", "[", "-", "1", "]", ",", ")", "*", "(", "numel", "-", "len", "(", "input", ")", ")", "\n", "", "elif", "len", "(", "input", ")", ">", "numel", ":", "\n", "            ", "input", "=", "input", "[", "0", ":", "numel", "]", "\n", "\n", "", "", "return", "tuple", "(", "typeB", "(", "i", ")", "for", "i", "in", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape": [[1114, 1127], ["utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "torch.Tensor().add().div().floor", "torch.Tensor().add().div", "int", "int", "int", "int", "torch.Tensor().add", "torch.Tensor"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple"], ["", "def", "getPad2RetainShape", "(", "kernel_size", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "r\"\"\"Returns the necessary padding in the format [TOP BOTTOM LEFT RIGHT] \n    so that the spatial dimensions of the output will remain the same with \n    the spatial dimensions of the input.\n    Note: This function assumes that the conv2d is computed using stride = 1.\"\"\"", "\n", "\n", "kernel_size", "=", "formatInput2Tuple", "(", "kernel_size", ",", "int", ",", "2", ")", "\n", "dilation", "=", "formatInput2Tuple", "(", "dilation", ",", "int", ",", "2", ")", "\n", "\n", "kernel_size", "=", "(", "(", "kernel_size", "[", "0", "]", "-", "1", ")", "*", "dilation", "[", "0", "]", "+", "1", ",", "(", "kernel_size", "[", "1", "]", "-", "1", ")", "*", "dilation", "[", "1", "]", "+", "1", ")", "\n", "Kc", "=", "th", ".", "Tensor", "(", "kernel_size", ")", ".", "add", "(", "1", ")", ".", "div", "(", "2", ")", ".", "floor", "(", ")", "\n", "return", "(", "int", "(", "Kc", "[", "0", "]", ")", "-", "1", ",", "kernel_size", "[", "0", "]", "-", "int", "(", "Kc", "[", "0", "]", ")", ",", "int", "(", "Kc", "[", "1", "]", ")", "-", "1", ",", "kernel_size", "[", "1", "]", "-", "int", "(", "Kc", "[", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPadSize": [[1129, 1176], ["isinstance", "isinstance", "isinstance", "isinstance", "numpy.array", "numpy.array", "numpy.array", "numpy.any", "numpy.any", "len", "len", "numpy.floor", "tuple", "tuple", "len", "numpy.floor", "numpy.ceil", "numpy.floor", "numpy.ceil", "int", "int", "len", "numpy.floor", "numpy.floor"], "function", ["None"], ["", "def", "getPadSize", "(", "shape", ",", "patchSize", ",", "stride", ")", ":", "\n", "    ", "r\"\"\"Computes the necessary padding so that an integer\n    number of overlapping patches (of size patchSize) can be extracted from \n    the image using a specified stride.\n\n    `padsize`:: Specifies the amount of padding of an image  as \n    [TOP, BOTTOM, LEFT, RIGHT].\n    \"\"\"", "\n", "assert", "(", "isinstance", "(", "shape", ",", "tuple", ")", ")", ",", "\"shape is expected to be a tuple.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "if", "len", "(", "shape", ")", "<", "4", ":", "\n", "        ", "shape", "=", "(", "1", ",", ")", "*", "(", "4", "-", "len", "(", "shape", ")", ")", "+", "shape", "\n", "", "elif", "len", "(", "shape", ")", ">", "4", ":", "\n", "        ", "shape", "=", "shape", "[", "0", ":", "3", "]", "\n", "\n", "", "if", "len", "(", "patchSize", ")", "<", "2", ":", "\n", "        ", "patchSize", "=", "patchSize", "*", "2", "\n", "\n", "", "if", "isinstance", "(", "stride", ",", "int", ")", ":", "\n", "        ", "stride", "=", "(", "stride", ",", ")", "*", "2", "\n", "", "assert", "(", "isinstance", "(", "stride", ",", "tuple", ")", ")", ",", "\"stride is expected to be of type int \"", "\"or of type tuple.\"", "\n", "\n", "shape", "=", "np", ".", "array", "(", "shape", "[", "2", ":", "4", "]", ")", "\n", "patchSize", "=", "np", ".", "array", "(", "patchSize", "[", "0", ":", "2", "]", ")", "\n", "stride", "=", "np", ".", "array", "(", "stride", "[", "0", ":", "2", "]", ")", "\n", "\n", "assert", "(", "np", ".", "any", "(", "stride", ">", "0", ")", ")", ",", "\"negative stride is not accepted.\"", "\n", "patchDims", "=", "(", "shape", "-", "patchSize", ")", "/", "stride", "+", "1", "\n", "assert", "(", "np", ".", "any", "(", "patchDims", ">", "0", ")", ")", ",", "\"The specified size of the patch is \"", "\"greater than the spatial dimensions of the input tensor.\"", "\n", "\n", "usePad", "=", "patchDims", "-", "np", ".", "floor", "(", "patchDims", ")", "\n", "\n", "if", "usePad", "[", "0", "]", ":", "\n", "        ", "padSizeTB", "=", "np", ".", "floor", "(", "patchDims", "[", "0", "]", ")", "*", "stride", "[", "0", "]", "+", "patchSize", "[", "0", "]", "-", "shape", "[", "0", "]", "\n", "padSizeTB", "=", "(", "np", ".", "floor", "(", "padSizeTB", "/", "2", ")", ",", "np", ".", "ceil", "(", "padSizeTB", "/", "2", ")", ")", "\n", "", "else", ":", "\n", "        ", "padSizeTB", "=", "(", "0", ",", "0", ")", "\n", "\n", "", "if", "usePad", "[", "1", "]", ":", "\n", "        ", "padSizeLR", "=", "np", ".", "floor", "(", "patchDims", "[", "1", "]", ")", "*", "stride", "[", "1", "]", "+", "patchSize", "[", "1", "]", "-", "shape", "[", "1", "]", "\n", "padSizeLR", "=", "(", "np", ".", "floor", "(", "padSizeLR", "/", "2", ")", ",", "np", ".", "ceil", "(", "padSizeLR", "/", "2", ")", ")", "\n", "", "else", ":", "\n", "        ", "padSizeLR", "=", "(", "0", ",", "0", ")", "\n", "\n", "", "return", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "padSizeTB", ")", "+", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "padSizeLR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.im2col": [[1177, 1194], ["utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "torch.nn.functional.Im2Col.apply", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple"], ["", "def", "im2col", "(", "input", ",", "block_size", ",", "stride", "=", "1", ",", "pad", "=", "0", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "r\"\"\" im2col extracts all the valid patches from the input which is a 2D, 3D \n    or 4D tensor of size [B] x [C] x H x W. The extracted patches are of size \n    patchSize and they are extracted with an overlap equal to stride. The \n    output is of size B x C*P x BS where P is the total number of elements\n    in the patch, while BS is the total number of extracted patches.\n    \"\"\"", "\n", "while", "input", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "#Im2Col(input, kernel_size, dilation, padding, stride)", "\n", "", "block_size", "=", "formatInput2Tuple", "(", "block_size", ",", "int", ",", "2", ")", "\n", "dilation", "=", "formatInput2Tuple", "(", "dilation", ",", "int", ",", "2", ")", "\n", "pad", "=", "formatInput2Tuple", "(", "pad", ",", "int", ",", "2", ")", "\n", "stride", "=", "formatInput2Tuple", "(", "stride", ",", "int", ",", "2", ")", "\n", "\n", "return", "th", ".", "nn", ".", "functional", ".", "Im2Col", ".", "apply", "(", "input", ",", "block_size", ",", "dilation", ",", "pad", ",", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.col2im": [[1195, 1210], ["utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "utils_model.formatInput2Tuple", "torch.nn.functional.Col2Im.apply", "input.dim"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple"], ["", "def", "col2im", "(", "input", ",", "output_size", ",", "block_size", ",", "stride", "=", "1", ",", "pad", "=", "0", ",", "dilation", "=", "1", ")", ":", "\n", "    ", "r\"\"\" col2im is the transpose operation of im2col.\n    \n    output_size : is the size of the original tensor from which the patches \n    where extracted.\n    \"\"\"", "\n", "#Col2Im(input, output_size, kernel_size, dilation, padding, stride)", "\n", "assert", "(", "input", ".", "dim", "(", ")", "==", "3", ")", ",", "\"The first input argument must be a 3D tensor.\"", "\n", "output_size", "=", "formatInput2Tuple", "(", "output_size", ",", "int", ",", "2", ")", "\n", "block_size", "=", "formatInput2Tuple", "(", "block_size", ",", "int", ",", "2", ")", "\n", "dilation", "=", "formatInput2Tuple", "(", "dilation", ",", "int", ",", "2", ")", "\n", "pad", "=", "formatInput2Tuple", "(", "pad", ",", "int", ",", "2", ")", "\n", "stride", "=", "formatInput2Tuple", "(", "stride", ",", "int", ",", "2", ")", "\n", "\n", "return", "th", ".", "nn", ".", "functional", ".", "Col2Im", ".", "apply", "(", "input", ",", "output_size", ",", "block_size", ",", "dilation", ",", "pad", ",", "stride", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.im2patch": [[1211, 1243], ["isinstance", "functools.reduce", "torch.eye().type", "h.view.view", "torch.conv2d", "len", "input.view.dim", "input.view.unsqueeze", "input.view.type", "input.view.view", "P.view.view", "input.view.dim", "input.view.dim", "torch.eye"], "function", ["None"], ["", "def", "im2patch", "(", "input", ",", "patchSize", ",", "stride", "=", "1", ")", ":", "\n", "    ", "r\"\"\" im2patch extracts all the valid patches from the input which is a 3D \n    or 4D tensor of size B x C x H x W. The extracted patches are of size \n    patchSize and they are extracted with an overlap equal to stride. The \n    output is of size B x C*P x PH x PW where P is the total number of elements\n    in the patch, while PH and PW is the number of patches in the horizontal and\n    vertical axes, respectively.\n    \"\"\"", "\n", "assert", "(", "input", ".", "dim", "(", ")", ">=", "3", "and", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"A 3D or 4D tensor is expected.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "\n", "if", "len", "(", "patchSize", ")", "<", "2", ":", "\n", "        ", "patchSize", "*=", "2", "\n", "\n", "", "if", "input", ".", "dim", "(", ")", "==", "3", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "Pn", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "patchSize", "[", "0", ":", "2", "]", ")", "\n", "h", "=", "th", ".", "eye", "(", "Pn", ")", ".", "type", "(", "input", ".", "type", "(", ")", ")", "\n", "h", "=", "h", ".", "view", "(", "Pn", ",", "1", ",", "patchSize", "[", "0", "]", ",", "patchSize", "[", "1", "]", ")", "\n", "\n", "batch", ",", "Nc", "=", "input", ".", "shape", "[", "0", ":", "2", "]", "\n", "\n", "if", "Nc", "!=", "1", ":", "\n", "        ", "input", "=", "input", ".", "view", "(", "batch", "*", "Nc", ",", "1", ",", "input", ".", "shape", "[", "2", "]", ",", "input", ".", "shape", "[", "3", "]", ")", "\n", "\n", "", "P", "=", "th", ".", "conv2d", "(", "input", ",", "h", ",", "stride", "=", "stride", ")", "\n", "\n", "if", "Nc", "!=", "1", ":", "\n", "        ", "P", "=", "P", ".", "view", "(", "batch", ",", "Nc", "*", "Pn", ",", "P", ".", "shape", "[", "2", "]", ",", "P", ".", "shape", "[", "3", "]", ")", "\n", "\n", "", "return", "P", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.patch2im": [[1244, 1280], ["isinstance", "isinstance", "functools.reduce", "math.floor", "torch.eye().type", "h.view.view", "torch.conv_transpose2d", "functools.reduce", "input.view.dim", "len", "len", "input.view.view", "input.view.type", "th.nn.functional.pad.view", "torch.nn.functional.pad", "len", "torch.eye", "range", "len"], "function", ["None"], ["", "def", "patch2im", "(", "input", ",", "shape", ",", "patchSize", ",", "stride", "=", "1", ")", ":", "\n", "    ", "r\"\"\" patch2im is the transpose operation of im2patch.\n    \n    shape : is the size of the original tensor from which the patches where \n    extracted.\n    \"\"\"", "\n", "assert", "(", "input", ".", "dim", "(", ")", "==", "4", ")", ",", "\"A 4D tensor is expected.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "\n", "if", "len", "(", "patchSize", ")", "<", "2", ":", "\n", "        ", "patchSize", "*=", "2", "\n", "", "if", "len", "(", "shape", ")", "<", "4", ":", "\n", "        ", "shape", "=", "(", "1", ",", ")", "*", "(", "4", "-", "len", "(", "shape", ")", ")", "+", "shape", "\n", "", "elif", "len", "(", "shape", ")", ">", "4", ":", "\n", "        ", "shape", "=", "shape", "[", "0", ":", "3", "]", "\n", "\n", "\n", "", "Pn", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "patchSize", "[", "0", ":", "2", "]", ")", "\n", "batch", "=", "shape", "[", "0", "]", "\n", "Nc", "=", "math", ".", "floor", "(", "input", ".", "shape", "[", "1", "]", "/", "Pn", ")", ";", "\n", "if", "Nc", "!=", "1", ":", "\n", "        ", "input", "=", "input", ".", "view", "(", "batch", "*", "Nc", ",", "input", ".", "shape", "[", "1", "]", "/", "Nc", ",", "input", ".", "shape", "[", "2", "]", ",", "input", ".", "shape", "[", "3", "]", ")", "\n", "\n", "", "h", "=", "th", ".", "eye", "(", "Pn", ")", ".", "type", "(", "input", ".", "type", "(", ")", ")", "\n", "h", "=", "h", ".", "view", "(", "Pn", ",", "1", ",", "patchSize", "[", "0", "]", ",", "patchSize", "[", "1", "]", ")", "\n", "\n", "out", "=", "th", ".", "conv_transpose2d", "(", "input", ",", "h", ",", "stride", "=", "stride", ")", "\n", "\n", "if", "Nc", "!=", "1", ":", "\n", "        ", "out", "=", "out", ".", "view", "(", "batch", ",", "Nc", "*", "out", ".", "shape", "[", "1", "]", ",", "out", ".", "shape", "[", "2", "]", ",", "out", ".", "shape", "[", "3", "]", ")", "\n", "\n", "", "if", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "or", "y", ",", "[", "out", ".", "shape", "[", "i", "]", "<", "shape", "[", "i", "]", "for", "i", "in", "range", "(", "4", ")", "]", ")", ":", "\n", "        ", "out", "=", "th", ".", "nn", ".", "functional", ".", "pad", "(", "out", ",", "(", "0", ",", "shape", "[", "3", "]", "-", "out", ".", "shape", "[", "3", "]", ",", "0", ",", "shape", "[", "2", "]", "-", "out", ".", "shape", "[", "2", "]", ")", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.im2patch_sinv": [[1281, 1321], ["isinstance", "isinstance", "functools.reduce", "math.floor", "torch.eye().type", "h.view.view", "torch.conv_transpose2d", "utils_model.compute_patch_overlap", "D.type.type", "th.nn.functional.pad.div", "functools.reduce", "input.view.dim", "len", "len", "input.view.view", "input.view.type", "th.nn.functional.pad.view", "input.view.type", "torch.nn.functional.pad", "len", "torch.eye", "range", "len"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.compute_patch_overlap"], ["", "def", "im2patch_sinv", "(", "input", ",", "shape", ",", "patchSize", ",", "stride", "=", "1", ")", ":", "\n", "    ", "r\"\"\" im2patch_sinv is the pseudo inverse of im2patch.\n    \n    shape : is the size of the original tensor from which the patches where \n    extracted.\n    \"\"\"", "\n", "assert", "(", "input", ".", "dim", "(", ")", "==", "4", ")", ",", "\"A 4D tensor is expected.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "assert", "(", "isinstance", "(", "patchSize", ",", "tuple", ")", ")", ",", "\"patchSize is expected to be a tuple.\"", "\n", "\n", "if", "len", "(", "patchSize", ")", "<", "2", ":", "\n", "        ", "patchSize", "*=", "2", "\n", "", "if", "len", "(", "shape", ")", "<", "4", ":", "\n", "        ", "shape", "=", "(", "1", ",", ")", "*", "(", "4", "-", "len", "(", "shape", ")", ")", "+", "shape", "\n", "", "elif", "len", "(", "shape", ")", ">", "4", ":", "\n", "        ", "shape", "=", "shape", "[", "0", ":", "3", "]", "\n", "\n", "\n", "", "Pn", "=", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "patchSize", "[", "0", ":", "2", "]", ")", "\n", "batch", "=", "shape", "[", "0", "]", "\n", "Nc", "=", "math", ".", "floor", "(", "input", ".", "shape", "[", "1", "]", "/", "Pn", ")", ";", "\n", "if", "Nc", "!=", "1", ":", "\n", "        ", "input", "=", "input", ".", "view", "(", "batch", "*", "Nc", ",", "input", ".", "shape", "[", "1", "]", "/", "Nc", ",", "input", ".", "shape", "[", "2", "]", ",", "input", ".", "shape", "[", "3", "]", ")", "\n", "\n", "", "h", "=", "th", ".", "eye", "(", "Pn", ")", ".", "type", "(", "input", ".", "type", "(", ")", ")", "\n", "h", "=", "h", ".", "view", "(", "Pn", ",", "1", ",", "patchSize", "[", "0", "]", ",", "patchSize", "[", "1", "]", ")", "\n", "\n", "out", "=", "th", ".", "conv_transpose2d", "(", "input", ",", "h", ",", "stride", "=", "stride", ")", "\n", "\n", "if", "Nc", "!=", "1", ":", "\n", "        ", "out", "=", "out", ".", "view", "(", "batch", ",", "Nc", "*", "out", ".", "shape", "[", "1", "]", ",", "out", ".", "shape", "[", "2", "]", ",", "out", ".", "shape", "[", "3", "]", ")", "\n", "\n", "", "D", "=", "compute_patch_overlap", "(", "shape", ",", "patchSize", ",", "stride", ")", "\n", "D", "=", "D", ".", "type", "(", "input", ".", "type", "(", ")", ")", "\n", "out", "=", "out", ".", "div", "(", "D", ")", "\n", "\n", "if", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "or", "y", ",", "[", "out", ".", "shape", "[", "i", "]", "<", "shape", "[", "i", "]", "for", "i", "in", "range", "(", "4", ")", "]", ")", ":", "\n", "        ", "out", "=", "th", ".", "nn", ".", "functional", ".", "pad", "(", "out", ",", "(", "0", ",", "shape", "[", "3", "]", "-", "out", ".", "shape", "[", "3", "]", ",", "0", ",", "shape", "[", "2", "]", "-", "out", ".", "shape", "[", "2", "]", ")", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctdict": [[1322, 1340], ["torch.zeros", "range", "D.cuda.float", "D.cuda.double", "math.sqrt", "torch.cos", "th.cos.mean", "th.cos.div", "torch.cuda.is_available", "D.cuda.cuda", "o.float", "th.cos.norm", "torch.arange"], "function", ["None"], ["", "def", "odctdict", "(", "n", ",", "L", ",", "dtype", "=", "'f'", ",", "GPU", "=", "False", ")", ":", "\n", "    ", "D", "=", "th", ".", "zeros", "(", "n", ",", "L", ")", "\n", "if", "dtype", "==", "'f'", ":", "\n", "        ", "D", "=", "D", ".", "float", "(", ")", "\n", "", "else", ":", "\n", "        ", "D", "=", "D", ".", "double", "(", ")", "\n", "\n", "", "D", "[", ":", ",", "0", "]", "=", "1", "/", "math", ".", "sqrt", "(", "n", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "L", ")", ":", "\n", "        ", "o", "=", "th", ".", "arange", "(", "0", ",", "n", ")", "*", "math", ".", "pi", "*", "k", "/", "L", "\n", "v", "=", "th", ".", "cos", "(", "o", ".", "float", "(", ")", ")", ";", "\n", "v", "-=", "v", ".", "mean", "(", ")", ";", "\n", "D", "[", ":", ",", "k", "]", "=", "v", ".", "div", "(", "v", ".", "norm", "(", "p", "=", "2", ")", ")", "\n", "\n", "", "if", "th", ".", "cuda", ".", "is_available", "(", ")", "and", "GPU", ":", "\n", "        ", "D", "=", "D", ".", "cuda", "(", ")", "\n", "\n", "", "return", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict": [[1341, 1390], ["numpy.asarray", "numpy.asarray", "tuple", "tuple", "utils_model.odctdict", "range", "isinstance", "isinstance", "isinstance", "isinstance", "isinstance", "numpy.prod", "numpy.ceil", "utils_model.kron", "numpy.ones", "numpy.ones", "int", "int", "utils_model.odctdict", "numpy.power"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctdict", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.kron", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctdict"], ["", "def", "odctndict", "(", "n", ",", "L", ",", "p", "=", "None", ",", "dtype", "=", "'f'", ",", "GPU", "=", "False", ")", ":", "\n", "    ", "r\"\"\"  D = ODCTNDICT((N1 N2 ... Np),(L1 L2 ... Lp)) returns an overcomplete \n    DCT dictionary for p-dimensional signals of size N1xN2x...xNp. The number \n    of DCT atoms in the i-th dimension is Li, so the combined dictionary is of\n    size (N1*N2*...*Np) x (L1*L2*...*Lp).\n\n    D = ODCTNDICT([N1 N2 ... Np],L) specifies the total number of atoms in\n    the dictionary instead of each of the Li's individually. The Li's in\n    this case are selected so their relative sizes are roughly the same as\n    the relative sizes of the Ni's. Note that the actual number of atoms in\n    the dictionary may be larger than L, as rounding might be required for\n    the computation of the Li's.\n\n    D = ODCTNDICT(N,L,P) is shorthand for the call ODCTNDICT(N*ones(1,P),L),\n    and returns the overcomplete DCT dictionary for P-dimensional signals of\n    size NxNx...xN. L is the required size of the overcomplete dictionary,\n    and is rounded up to the nearest integer with a whole P-th root.\n    \"\"\"", "\n", "assert", "(", "isinstance", "(", "n", ",", "int", ")", "or", "isinstance", "(", "n", ",", "tuple", ")", ")", ",", "\" n should be either of \"", "\"type int or of type tuple.\"", "\n", "assert", "(", "isinstance", "(", "L", ",", "int", ")", "or", "isinstance", "(", "L", ",", "tuple", ")", ")", ",", "\" L should be either of \"", "\"type int or of type tuple.\"", "\n", "assert", "(", "isinstance", "(", "p", ",", "int", ")", "or", "p", "is", "None", ")", ",", "\" p should be either of \"", "\"type int or being omitted.\"", "\n", "\n", "n", "=", "np", ".", "asarray", "(", "n", ")", "\n", "L", "=", "np", ".", "asarray", "(", "L", ")", "\n", "\n", "if", "p", "is", "None", ":", "\n", "        ", "p", "=", "n", ".", "size", "\n", "\n", "", "if", "n", ".", "size", "==", "1", ":", "\n", "        ", "n", "=", "n", "*", "np", ".", "ones", "(", "(", "1", ",", "p", ")", ")", "\n", "", "if", "L", ".", "size", "==", "1", ":", "\n", "        ", "L", "=", "L", "*", "np", ".", "ones", "(", "(", "1", ",", ")", ")", "\n", "\n", "\n", "", "if", "L", ".", "size", "==", "1", "and", "p", ">", "1", ":", "\n", "        ", "N", "=", "np", ".", "prod", "(", "n", ")", "\n", "L", "=", "np", ".", "ceil", "(", "(", "L", "*", "(", "np", ".", "power", "(", "n", ",", "p", ")", "/", "N", ")", "**", "(", "1", "/", "(", "p", "-", "1", ")", ")", ")", "**", "(", "1", "/", "p", ")", ")", "\n", "\n", "", "n", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "n", ")", "\n", "L", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "L", ")", "\n", "\n", "D", "=", "odctdict", "(", "n", "[", "0", "]", ",", "L", "[", "0", "]", ",", "dtype", ",", "GPU", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "p", ")", ":", "\n", "        ", "D", "=", "kron", "(", "D", ",", "odctdict", "(", "n", "[", "i", "]", ",", "L", "[", "i", "]", ",", "dtype", ",", "GPU", ")", ")", "\n", "\n", "", "return", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odct2dict": [[1391, 1393], ["utils_model.odctndict"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict"], ["", "def", "odct2dict", "(", "n", ",", "L", ",", "dtype", "=", "'f'", ",", "GPU", "=", "False", ")", ":", "\n", "    ", "return", "odctndict", "(", "n", ",", "L", ",", "2", ",", "dtype", ",", "GPU", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odct3dict": [[1394, 1396], ["utils_model.odctndict"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict"], ["", "def", "odct3dict", "(", "n", ",", "L", ",", "dtype", "=", "'f'", ",", "GPU", "=", "False", ")", ":", "\n", "    ", "return", "odctndict", "(", "n", ",", "L", ",", "3", ",", "dtype", ",", "GPU", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.kron": [[1397, 1434], ["x.unsqueeze.t().contiguous().view", "y.unsqueeze.t().contiguous().view", "y.unsqueeze.ger", "torch.Tensor().type_as", "range", "x.unsqueeze.dim", "x.unsqueeze.unsqueeze", "y.unsqueeze.dim", "y.unsqueeze.unsqueeze", "torch.Tensor().type_as", "range", "x.unsqueeze.dim", "x.unsqueeze.dim", "y.unsqueeze.dim", "y.unsqueeze.dim", "x.unsqueeze.t().contiguous", "y.unsqueeze.t().contiguous", "torch.Tensor", "torch.cat", "torch.cat", "torch.cat", "torch.Tensor", "x.unsqueeze.t", "y.unsqueeze.t", "z[].contiguous().view().t", "z[].contiguous().view", "z[].contiguous"], "function", ["None"], ["", "def", "kron", "(", "x", ",", "y", ")", ":", "\n", "    ", "r\"\"\" Kronecker tensor product.\n    KRON(X,Y) is the Kronecker tensor product of X and Y.\n    The result is a large matrix formed by taking all possible\n    products between the elements of X and those of Y. For\n    example, if X is 2 by 3, then KRON(X,Y) is\n \n       [ X[0,0]*Y  X[0,1]*Y  X[0,2]*Y\n         X[1,0]*Y  X[1,1]*Y  X[1,2]*Y ]\n    \"\"\"", "\n", "assert", "(", "x", ".", "dim", "(", ")", "==", "1", "or", "x", ".", "dim", "(", ")", "==", "2", ")", ",", "\"x must be either a 1D or 2D tensor.\"", "\n", "assert", "(", "y", ".", "dim", "(", ")", "==", "1", "or", "y", ".", "dim", "(", ")", "==", "2", ")", ",", "\"x must be either a 1D or 2D tensor.\"", "\n", "\n", "if", "x", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", "\n", "", "if", "y", ".", "dim", "(", ")", "==", "1", ":", "\n", "        ", "y", "=", "y", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "x_size", "=", "x", ".", "shape", "\n", "y_size", "=", "y", ".", "shape", "\n", "\n", "x", "=", "x", ".", "t", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "y", "=", "y", ".", "t", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "z", "=", "y", ".", "ger", "(", "x", ")", "\n", "\n", "D", "=", "th", ".", "Tensor", "(", ")", ".", "type_as", "(", "x", ")", "\n", "for", "m", "in", "range", "(", "0", ",", "x_size", "[", "1", "]", ")", ":", "\n", "        ", "d", "=", "th", ".", "Tensor", "(", ")", ".", "type_as", "(", "x", ")", "\n", "for", "k", "in", "range", "(", "x_size", "[", "0", "]", "*", "m", ",", "x_size", "[", "0", "]", "*", "(", "m", "+", "1", ")", ")", ":", "\n", "            ", "d", "=", "th", ".", "cat", "(", "(", "d", ",", "z", "[", ":", ",", "k", "]", ".", "contiguous", "(", ")", ".", "view", "(", "y_size", "[", "1", "]", ",", "y_size", "[", "0", "]", ")", ".", "t", "(", ")", ")", ",", "dim", "=", "0", ")", "\n", "", "if", "m", "==", "0", ":", "\n", "            ", "D", "=", "th", ".", "cat", "(", "(", "D", ",", "d", ")", ")", "\n", "", "else", ":", "\n", "            ", "D", "=", "th", ".", "cat", "(", "(", "D", ",", "d", ")", ",", "dim", "=", "1", ")", "\n", "\n", "", "", "return", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.sub2ind": [[1435, 1477], ["range", "torch.LongTensor", "torch.zeros().long", "range", "isinstance", "len", "len", "len", "len", "numpy.hstack", "len", "torch.from_numpy().long().mul", "args[].min", "args[].max", "torch.zeros", "args[].min", "args[].max", "numpy.array", "torch.from_numpy().long", "numpy.cumprod", "torch.from_numpy", "numpy.array"], "function", ["None"], ["", "def", "sub2ind", "(", "shape", ",", "*", "args", ")", ":", "\n", "    ", "r\"\"\"Linear index from multiple subscripts.\n    SUB2IND is used to determine the equivalent single index\n    corresponding to a given set of subscript values.\n \n    IND = SUB2IND(shape,I,J) returns the linear index equivalent to the\n    row and column subscripts in the arrays I and J for a matrix of\n    size SIZ. \n \n    IND = SUB2IND(shape,I1,I2,...,IN) returns the linear index\n    equivalent to the N subscripts in the arrays I1,I2,...,IN for an\n    array of size SIZ.\n \n    I1,I2,...,IN must have the same size, and IND will have the same size\n    as I1,I2,...,IN. For a tensor A, if IND = SUB2IND(A.shape,I1,...,IN),\n    then A.take(IND[k])=A(I1[k],...,IN[k]) for all k.\n    \n    The subscript arguments must be of type np.ndarrays.\n    \"\"\"", "\n", "for", "k", "in", "args", ":", "\n", "        ", "assert", "(", "isinstance", "(", "k", ",", "np", ".", "ndarray", ")", ")", ",", "\"All the subscript arguments are \"", "\"expected to be of type 'ndarray'.\"", "\n", "\n", "", "assert", "(", "len", "(", "shape", ")", "==", "len", "(", "args", ")", ")", ",", "\"%d subscript arguments are expected.\"", "%", "len", "(", "shape", ")", "\n", "\n", "s", "=", "args", "[", "0", "]", ".", "shape", "\n", "assert", "(", "args", "[", "0", "]", ".", "min", "(", ")", ">=", "0", "and", "args", "[", "0", "]", ".", "max", "(", ")", "<", "shape", "[", "0", "]", ")", ",", "\"Invalid values for the \"", "\"subscript arguments.\"", "\n", "for", "k", "in", "range", "(", "1", ",", "len", "(", "args", ")", ")", ":", "\n", "        ", "assert", "(", "s", "==", "args", "[", "k", "]", ".", "shape", ")", ",", "\"The dimensions of all the subscript arguments \"", "\"must match.\"", "\n", "assert", "(", "args", "[", "k", "]", ".", "min", "(", ")", ">=", "0", "and", "args", "[", "k", "]", ".", "max", "(", ")", "<", "shape", "[", "k", "]", ")", ",", "\"Invalid \"", "\"values for the subscript arguments.\"", "\n", "\n", "", "p", "=", "th", ".", "LongTensor", "(", "np", ".", "hstack", "(", "(", "np", ".", "cumprod", "(", "np", ".", "array", "(", "shape", "[", "1", ":", "]", ")", "[", "-", "1", ":", ":", "-", "1", "]", ")", "[", "-", "1", ":", ":", "-", "1", "]", ",", "np", ".", "array", "(", "1", ")", ")", ")", ")", "\n", "\n", "idx", "=", "th", ".", "zeros", "(", "args", "[", "0", "]", ".", "shape", ")", ".", "long", "(", ")", "\n", "for", "k", "in", "range", "(", "0", ",", "len", "(", "args", ")", ")", ":", "\n", "        ", "idx", "+=", "th", ".", "from_numpy", "(", "args", "[", "k", "]", ")", ".", "long", "(", ")", ".", "mul", "(", "p", "[", "k", "]", ")", "\n", "\n", "", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.meshgrid": [[1478, 1495], ["list", "len", "range", "range", "list.append", "range", "isinstance", "s_ind[].repeat"], "function", ["None"], ["", "def", "meshgrid", "(", "*", "args", ")", ":", "\n", "    ", "r\"\"\" Y,X,Z = meshgrid(np.arange(-3,4),np.arange(-2,3),np.arange(2,5))\"\"\"", "\n", "s_ind", "=", "list", "(", ")", "\n", "siz", "=", "len", "(", "args", ")", "\n", "for", "t", "in", "args", ":", "\n", "        ", "assert", "(", "isinstance", "(", "t", ",", "np", ".", "ndarray", ")", "and", "t", ".", "ndim", "==", "1", ")", ",", "\"Input arguments must be 1D ndarrays.\"", "\n", "\n", "", "for", "k", "in", "range", "(", "0", ",", "siz", ")", ":", "\n", "        ", "s_ind", ".", "append", "(", "args", "[", "k", "]", ")", "\n", "s_ind", "[", "k", "]", ".", "shape", "=", "(", "1", ",", ")", "*", "k", "+", "(", "args", "[", "k", "]", ".", "size", ",", ")", "+", "(", "1", ",", ")", "*", "(", "siz", "-", "1", "-", "k", ")", "\n", "\n", "", "for", "k", "in", "range", "(", "0", ",", "siz", ")", ":", "\n", "        ", "for", "m", "in", "range", "(", "0", ",", "siz", ")", ":", "\n", "            ", "if", "k", "!=", "m", ":", "\n", "                ", "s_ind", "[", "k", "]", "=", "s_ind", "[", "k", "]", ".", "repeat", "(", "args", "[", "m", "]", ".", "size", ",", "axis", "=", "m", ")", "\n", "\n", "", "", "", "return", "s_ind", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.meshgrid_": [[1496, 1511], ["list", "len", "range", "range", "list.append", "range", "numpy.arange", "s_ind[].repeat"], "function", ["None"], ["", "def", "meshgrid_", "(", "shape", ")", ":", "\n", "\n", "    ", "s_ind", "=", "list", "(", ")", "\n", "\n", "siz", "=", "len", "(", "shape", ")", "\n", "for", "k", "in", "range", "(", "0", ",", "siz", ")", ":", "\n", "        ", "s_ind", ".", "append", "(", "np", ".", "arange", "(", "0", ",", "shape", "[", "k", "]", ")", ")", "\n", "s_ind", "[", "k", "]", ".", "shape", "=", "(", "1", ",", ")", "*", "k", "+", "(", "shape", "[", "k", "]", ",", ")", "+", "(", "1", ",", ")", "*", "(", "siz", "-", "1", "-", "k", ")", "\n", "\n", "", "for", "k", "in", "range", "(", "0", ",", "siz", ")", ":", "\n", "        ", "for", "m", "in", "range", "(", "0", ",", "siz", ")", ":", "\n", "            ", "if", "k", "!=", "m", ":", "\n", "                ", "s_ind", "[", "k", "]", "=", "s_ind", "[", "k", "]", ".", "repeat", "(", "shape", "[", "m", "]", ",", "axis", "=", "m", ")", "\n", "\n", "", "", "", "return", "s_ind", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.TicTocGenerator": [[1512, 1521], ["time.time", "time.time"], "function", ["None"], ["", "def", "TicTocGenerator", "(", ")", ":", "\n", "    ", "import", "time", "\n", "# Generator that returns time differences", "\n", "ti", "=", "0", "# initial time", "\n", "tf", "=", "time", ".", "time", "(", ")", "# final time", "\n", "while", "True", ":", "\n", "        ", "ti", "=", "tf", "\n", "tf", "=", "time", ".", "time", "(", ")", "\n", "yield", "tf", "-", "ti", "# returns the time difference", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.toc": [[1525, 1531], ["next"], "function", ["None"], ["def", "toc", "(", "tempBool", "=", "True", ")", ":", "\n", "# Prints the time difference yielded by generator instance TicToc", "\n", "    ", "tempTimeInterval", "=", "next", "(", "TicToc", ")", "\n", "if", "tempBool", ":", "\n", "#print(\"Elapsed time: {:f} seconds\\n\".format(tempTimeInterval))", "\n", "        ", "return", "tempTimeInterval", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.tic": [[1532, 1535], ["utils_model.toc"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.toc"], ["", "", "def", "tic", "(", ")", ":", "\n", "# Records a time in TicToc, marks the beginning of a time interval", "\n", "    ", "toc", "(", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.im2Tensor": [[1537, 1547], ["isinstance", "torch.from_numpy().unsqueeze_().unsqueeze_().type", "torch.from_numpy().unsqueeze_().type", "torch.from_numpy().type", "torch.from_numpy().unsqueeze_().unsqueeze_", "torch.from_numpy().unsqueeze_", "torch.from_numpy", "torch.from_numpy().unsqueeze_", "img.transpose", "torch.from_numpy", "torch.from_numpy", "img.transpose"], "function", ["None"], ["", "def", "im2Tensor", "(", "img", ",", "dtype", "=", "th", ".", "FloatTensor", ")", ":", "\n", "    ", "assert", "(", "isinstance", "(", "img", ",", "np", ".", "ndarray", ")", "and", "img", ".", "ndim", "in", "(", "2", ",", "3", ",", "4", ")", ")", ",", "\"A numpy \"", "\"nd array of dimensions 2, 3, or 4 is expected.\"", "\n", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "return", "th", ".", "from_numpy", "(", "img", ")", ".", "unsqueeze_", "(", "0", ")", ".", "unsqueeze_", "(", "0", ")", ".", "type", "(", "dtype", ")", "\n", "", "elif", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "return", "th", ".", "from_numpy", "(", "img", ".", "transpose", "(", "2", ",", "0", ",", "1", ")", ")", ".", "unsqueeze_", "(", "0", ")", ".", "type", "(", "dtype", ")", "\n", "", "else", ":", "\n", "        ", "return", "th", ".", "from_numpy", "(", "img", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", ")", ".", "type", "(", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.tensor2Im": [[1548, 1558], ["img.squeeze.numpy().transpose().astype", "isinstance", "img.squeeze.size", "img.squeeze.squeeze", "img.squeeze.ndimension", "img.squeeze.numpy().transpose", "img.squeeze.numpy"], "function", ["None"], ["", "", "def", "tensor2Im", "(", "img", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "    ", "assert", "(", "isinstance", "(", "img", ",", "th", ".", "Tensor", ")", "and", "img", ".", "ndimension", "(", ")", "==", "4", ")", ",", "\"A 4D \"", "\"torch.Tensor is expected.\"", "\n", "if", "img", ".", "size", "(", "0", ")", "==", "1", ":", "\n", "        ", "img", "=", "img", ".", "squeeze", "(", "0", ")", "\n", "fshape", "=", "(", "1", ",", "2", ",", "0", ")", "\n", "", "else", ":", "\n", "        ", "fshape", "=", "(", "0", ",", "2", ",", "3", ",", "1", ")", "\n", "\n", "", "return", "img", ".", "numpy", "(", ")", ".", "transpose", "(", "fshape", ")", ".", "astype", "(", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imnormalize": [[1559, 1563], ["input.min", "out.max"], "function", ["None"], ["", "def", "imnormalize", "(", "input", ")", ":", "\n", "    ", "out", "=", "input", "-", "input", ".", "min", "(", ")", "\n", "out", "=", "out", "/", "out", ".", "max", "(", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gen_imdb_BSDS500_fromList": [[1565, 1650], ["os.listdir", "len", "open", "open.readlines", "open.close", "int", "list", "f.readlines.extend", "numpy.zeros", "range", "numpy.zeros", "range", "numpy.random.randint", "numpy.random.randint", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "numpy.round", "len", "numpy.random.choice", "Img.imread", "len", "max", "min", "numpy.array", "utils_model.gen_imdb_BSDS500_fromList.randomCropImg"], "function", ["None"], ["", "def", "gen_imdb_BSDS500_fromList", "(", "listPath", "=", "\"/home/stamatis/Documents/Work/repos/datasets/BSDS500/BSDS_validation_list.txt\"", ",", "imdbPath", "=", "\"/home/stamatis/Documents/Work/repos/datasets/BSDS500/\"", ",", "color", "=", "True", ",", "savePath", "=", "None", ",", "shape", "=", "(", "128", ",", "128", ")", ",", "img_ext", "=", "'.jpg'", ",", "dtype", "=", "'f'", ",", "train", "=", "0.8", ",", "test", "=", "0.2", ",", "data", "=", "'both'", ")", ":", "\n", "\n", "\n", "    ", "def", "randomCropImg", "(", "img", ",", "output_shape", ")", ":", "\n", "        ", "input_shape", "=", "img", ".", "shape", "[", "0", ":", "2", "]", "\n", "row_start", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "input_shape", "[", "0", "]", "-", "output_shape", "[", "0", "]", "+", "1", ")", "\n", "col_start", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "input_shape", "[", "1", "]", "-", "output_shape", "[", "1", "]", "+", "1", ")", "\n", "\n", "return", "img", "[", "row_start", ":", "row_start", "+", "output_shape", "[", "0", "]", ":", "1", ",", "col_start", ":", "col_start", "+", "output_shape", "[", "1", "]", ":", "1", ",", "...", "]", "\n", "\n", "", "import", "os", "\n", "from", "matplotlib", "import", "image", "as", "Img", "\n", "import", "numpy", "as", "np", "\n", "\n", "# read all the images in the dataset", "\n", "if", "color", ":", "\n", "        ", "imdbPath", "=", "os", ".", "path", ".", "join", "(", "imdbPath", ",", "'color'", ")", "\n", "", "else", ":", "\n", "        ", "imdbPath", "=", "os", ".", "path", ".", "join", "(", "imdbPath", ",", "'gray'", ")", "\n", "\n", "", "l", "=", "os", ".", "listdir", "(", "imdbPath", ")", "\n", "l", "=", "[", "os", ".", "path", ".", "join", "(", "imdbPath", ",", "f", ")", "for", "f", "in", "l", "if", "f", ".", "endswith", "(", "img_ext", ")", "]", "\n", "N", "=", "len", "(", "l", ")", "# number of images in the dataset", "\n", "\n", "# read all the images that should be excluded from the training set", "\n", "f", "=", "open", "(", "listPath", ",", "'r'", ")", "\n", "test_samples", "=", "f", ".", "readlines", "(", "-", "1", ")", ";", "f", ".", "close", "(", ")", "\n", "test_samples", "=", "[", "os", ".", "path", ".", "join", "(", "imdbPath", ",", "k", ".", "replace", "(", "'\\n'", ",", "''", ")", ")", "for", "k", "in", "test_samples", "]", "\n", "\n", "# images in the dataset excluding the images defined in the list", "\n", "lx", "=", "[", "f", "for", "f", "in", "l", "if", "f", "not", "in", "test_samples", "]", "\n", "\n", "train", "=", "train", "/", "(", "train", "+", "test", ")", "\n", "test", "=", "test", "/", "(", "train", "+", "test", ")", "\n", "\n", "Ntrain", "=", "int", "(", "np", ".", "round", "(", "N", "*", "train", ")", ")", "# number of train images", "\n", "Ntest", "=", "N", "-", "Ntrain", "# number of test images", "\n", "\n", "assert", "(", "Ntest", ">=", "len", "(", "test_samples", ")", ")", ",", "\"The list contains more test samples\\\n    than the specified percentage of the total number of available images.\"", "\n", "\n", "l_test", "=", "list", "(", "np", ".", "random", ".", "choice", "(", "lx", ",", "Ntest", "-", "len", "(", "test_samples", ")", ",", "replace", "=", "False", ")", ")", "\n", "test_samples", ".", "extend", "(", "l_test", ")", "\n", "train_samples", "=", "[", "f", "for", "f", "in", "l", "if", "f", "not", "in", "test_samples", "]", "\n", "\n", "\n", "im_shape", "=", "Img", ".", "imread", "(", "train_samples", "[", "0", "]", ")", ".", "shape", "\n", "if", "len", "(", "im_shape", ")", "==", "2", ":", "\n", "        ", "H", ",", "W", "=", "im_shape", "\n", "Nchannels", "=", "1", "\n", "", "else", ":", "\n", "        ", "H", ",", "W", ",", "Nchannels", "=", "im_shape", "\n", "\n", "", "assert", "(", "max", "(", "shape", ")", "<=", "min", "(", "H", ",", "W", ")", ")", ",", "\"The specified shape is incompatible with \"", "\"the dimensions of the images in the dataset.\"", "\n", "\n", "imdb_train", "=", "np", ".", "zeros", "(", "(", "shape", ")", "+", "(", "Nchannels", ",", "Ntrain", ")", ",", "dtype", "=", "dtype", ")", "\n", "for", "i", "in", "range", "(", "Ntrain", ")", ":", "\n", "        ", "img", "=", "np", ".", "array", "(", "Img", ".", "imread", "(", "train_samples", "[", "i", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "img", ".", "shape", "=", "img", ".", "shape", "+", "(", "1", ",", ")", "\n", "\n", "", "imdb_train", "[", "...", ",", "i", "]", "=", "randomCropImg", "(", "img", ",", "shape", ")", "\n", "\n", "", "imdb_test", "=", "np", ".", "zeros", "(", "(", "shape", ")", "+", "(", "Nchannels", ",", "Ntest", ")", ",", "dtype", "=", "dtype", ")", "\n", "for", "i", "in", "range", "(", "Ntest", ")", ":", "\n", "        ", "img", "=", "np", ".", "array", "(", "Img", ".", "imread", "(", "test_samples", "[", "i", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "            ", "img", ".", "shape", "=", "img", ".", "shape", "+", "(", "1", ",", ")", "\n", "\n", "", "imdb_test", "[", "...", ",", "i", "]", "=", "randomCropImg", "(", "img", ",", "shape", ")", "\n", "\n", "", "if", "savePath", "is", "not", "None", ":", "\n", "        ", "np", ".", "savez", "(", "savePath", ",", "train_set", "=", "imdb_train", ",", "test_set", "=", "imdb_test", ")", "\n", "\n", "", "if", "data", "==", "'both'", ":", "\n", "        ", "return", "imdb_train", ",", "imdb_test", "\n", "", "elif", "data", "==", "'train'", ":", "\n", "        ", "return", "imdb_train", "\n", "", "elif", "data", "==", "'test'", ":", "\n", "        ", "return", "imdb_test", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.wmad_estimator": [[1651, 1695], ["isinstance", "c.reshape.reshape", "np.median().mean.transpose", "isinstance", "torch.is_tensor", "x.unsqueeze.cpu().numpy().transpose", "dwtn", "functools.reduce", "numpy.median", "numpy.median().mean", "type", "x.unsqueeze.dim", "x.unsqueeze.dim", "x.unsqueeze.unsqueeze", "torch.from_numpy().cuda", "torch.from_numpy", "x.unsqueeze.cpu().numpy", "prod", "numpy.abs", "numpy.median", "torch.from_numpy", "x.unsqueeze.cpu", "numpy.abs"], "function", ["None"], ["", "", "def", "wmad_estimator", "(", "x", ",", "wname", "=", "'db7'", ",", "mode", "=", "'symmetric'", ",", "multichannel", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Accepts either a torch tensor or an ndarray and provides an estimate\n    of the standard deviation of the noise degrading the input. It can operate\n    on a batch of multichannel images. If the input is a torch Tensor we assume\n    that the dimensions are B x C x H x W otherwise H x W x C x B, where H, W \n    are the spatial dimensions, C the image channels and B the number of images.\n    It returns a torch tensor or an ndarray of size B x 1 (B x C if multichannel\n    is set to True) with the respective estimated standard deviations.\"\"\"", "\n", "from", "pywt", "import", "dwtn", "\n", "\n", "assert", "(", "isinstance", "(", "x", ",", "np", ".", "ndarray", ")", "or", "th", ".", "is_tensor", "(", "x", ")", ")", ",", "\"The first input \"", "+", "\"argument must be either a ndarray or a tensor.\"", "\n", "\n", "assert", "(", "isinstance", "(", "wname", ",", "str", ")", ")", ",", "\"The second input argument must be a string \"", "+", "\"indicating the wavelet basis to be used for the decomposition.\"", "\n", "\n", "tensor", "=", "False", "if", "type", "(", "x", ")", "is", "np", ".", "ndarray", "else", "True", "\n", "\n", "if", "tensor", ":", "\n", "        ", "assert", "(", "x", ".", "dim", "(", ")", "<", "5", ")", ",", "\"Input is expected to be at most a 4D tensor.\"", "\n", "while", "x", ".", "dim", "(", ")", "!=", "4", ":", "\n", "            ", "x", "=", "x", ".", "unsqueeze", "(", "0", ")", "\n", "", "cuda", "=", "x", ".", "is_cuda", "\n", "x", "=", "x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "else", ":", "\n", "        ", "assert", "(", "x", ".", "ndim", "<", "5", ")", ",", "\"Input is expected to be at most a 4D ndarray.\"", "\n", "while", "x", ".", "ndim", "!=", "4", ":", "\n", "            ", "x", ".", "shape", "+=", "(", "1", ",", ")", "\n", "\n", "\n", "", "", "c", "=", "dwtn", "(", "x", ",", "wname", ",", "mode", "=", "mode", ",", "axes", "=", "(", "0", ",", "1", ")", ")", "[", "'dd'", "]", "\n", "prod", "=", "lambda", "z", ":", "reduce", "(", "lambda", "x", ",", "y", ":", "x", "*", "y", ",", "z", ")", "\n", "c", "=", "c", ".", "reshape", "(", "(", "prod", "(", "c", ".", "shape", "[", "0", ":", "2", "]", ")", ",", ")", "+", "c", ".", "shape", "[", "2", ":", "]", ")", "\n", "\n", "if", "multichannel", ":", "\n", "        ", "sigma", "=", "np", ".", "median", "(", "np", ".", "abs", "(", "c", ")", "/", ".6745", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "sigma", "=", "np", ".", "median", "(", "np", ".", "abs", "(", "c", ")", "/", ".6745", ",", "axis", "=", "0", ")", ".", "mean", "(", "axis", "=", "0", ",", "keepdims", "=", "True", ")", "\n", "\n", "", "sigma", "=", "sigma", ".", "transpose", "(", "1", ",", "0", ")", "\n", "if", "tensor", ":", "\n", "        ", "sigma", "=", "th", ".", "from_numpy", "(", "sigma", ")", ".", "cuda", "(", ")", "if", "cuda", "else", "th", ".", "from_numpy", "(", "sigma", ")", "\n", "\n", "", "return", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.block_wmad_estimator": [[1697, 1756], ["isinstance", "numpy.floor", "patchDims.astype.astype", "numpy.asarray", "torch.from_numpy().type_as", "utils_model.reverse", "im2col().permute", "pad2D.size", "pad2D.contiguous().view", "utils_model.getPad2RetainShape", "utils_model.pad2D", "torch.conv2d", "kernel.squeeze().unsqueeze.squeeze().unsqueeze", "torch.conv2d", "stdn_est.expand.permute().view", "torch.is_tensor", "kernel.squeeze().unsqueeze.dim", "kernel.squeeze().unsqueeze.unsqueeze_", "stdn_est.expand.view().abs().div().median", "stdn_est.expand.mean", "stdn_est.expand.expand", "torch.nn.functional.upsample", "x.dim", "torch.from_numpy", "utils_model.im2col", "pad2D.contiguous", "kernel.squeeze().unsqueeze.squeeze", "stdn_est.expand.permute", "numpy.asarray", "Wavelet", "stdn_est.expand.view().abs().div", "numpy.asarray", "numpy.asarray", "stdn_est.expand.view().abs", "stdn_est.expand.view"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.upsample", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.im2col"], ["", "def", "block_wmad_estimator", "(", "x", ",", "wname", "=", "'db7'", ",", "blckSize", "=", "(", "8", ",", "8", ")", ",", "blckStride", "=", "(", "4", ",", "4", ")", ",", "mode", "=", "'symmetric'", ",", "multichannel", "=", "False", ",", "upsample", "=", "False", ",", "upsample_mode", "=", "'bilinear'", ")", ":", "\n", "    ", "r\"\"\"Accepts a torch tensor and provides an estimate of the standard deviation \n    of the noise degrading blocks of the input. The overlap of the extracted \n    blocks is defined through blckStride. The function can be applied on a\n    a batch of multichannel images. The tensor's dimensions are B x C x H x W, \n    where H, W are the spatial dimensions, C the image channels and B is the \n    number of images. It returns a torch tensor of size B x C x PH x PW \n    with the respective estimated standard deviations for all blocks P = PH x PW.\"\"\"", "\n", "\n", "assert", "(", "th", ".", "is_tensor", "(", "x", ")", "and", "x", ".", "dim", "(", ")", "==", "4", ")", ",", "\"The first input argument must be \"", "+", "\"a 4D tensor.\"", "\n", "\n", "assert", "(", "isinstance", "(", "wname", ",", "str", ")", ")", ",", "\"The second input argument must be a string \"", "+", "\"indicating the wavelet basis to be used for the decomposition.\"", "\n", "\n", "patchDims", "=", "np", ".", "floor", "(", "(", "np", ".", "asarray", "(", "x", ".", "shape", "[", "2", ":", "]", ")", "-", "np", ".", "asarray", "(", "blckSize", ")", ")", "/", "np", ".", "asarray", "(", "blckStride", ")", "+", "1", ")", "\n", "patchDims", "=", "patchDims", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n", "from", "pywt", "import", "Wavelet", "\n", "# Retrieve the high-pass decomposition filter for the wavelet transform", "\n", "dec_hi", "=", "np", ".", "asarray", "(", "Wavelet", "(", "wname", ")", ".", "filter_bank", "[", "1", "]", ")", "\n", "\n", "kernel", "=", "th", ".", "from_numpy", "(", "dec_hi", ")", ".", "type_as", "(", "x", ")", "\n", "while", "kernel", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "kernel", ".", "unsqueeze_", "(", "0", ")", "\n", "\n", "", "kernel", "=", "reverse", "(", "kernel", ",", "dim", "=", "3", ")", "\n", "\n", "batch", ",", "channels", ",", "H", ",", "W", "=", "x", ".", "shape", "\n", "\n", "P", "=", "im2col", "(", "x", ",", "blckSize", ",", "blckStride", ")", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "numPatches", "=", "P", ".", "size", "(", "0", ")", "\n", "\n", "assert", "(", "numPatches", "==", "patchDims", "[", "0", "]", "*", "patchDims", "[", "1", "]", ")", ",", "\"Something wrong happened.\"", "\n", "\n", "P", "=", "P", ".", "contiguous", "(", ")", ".", "view", "(", "numPatches", "*", "batch", "*", "channels", ",", "1", ",", "blckSize", "[", "0", "]", ",", "blckSize", "[", "1", "]", ")", "\n", "\n", "padding", "=", "getPad2RetainShape", "(", "(", "kernel", ".", "shape", "[", "-", "1", "]", ",", ")", "*", "2", ",", "dilation", "=", "1", ")", "\n", "\n", "P", "=", "pad2D", "(", "P", ",", "padding", ",", "mode", ")", "\n", "stdn_est", "=", "th", ".", "conv2d", "(", "P", ",", "kernel", ",", "stride", "=", "(", "1", ",", "2", ")", ")", "\n", "kernel", "=", "kernel", ".", "squeeze", "(", "0", ")", ".", "unsqueeze", "(", "3", ")", "\n", "stdn_est", "=", "th", ".", "conv2d", "(", "stdn_est", ",", "kernel", ",", "stride", "=", "(", "2", ",", "1", ")", ")", "\n", "\n", "stdn_est", "=", "stdn_est", ".", "view", "(", "numPatches", ",", "batch", ",", "channels", ",", "-", "1", ")", ".", "abs", "(", ")", ".", "div", "(", ".6745", ")", ".", "median", "(", "dim", "=", "3", ")", "[", "0", "]", "\n", "\n", "if", "not", "multichannel", ":", "\n", "        ", "stdn_est", "=", "stdn_est", ".", "mean", "(", "dim", "=", "2", ",", "keepdim", "=", "True", ")", "\n", "stdn_est", "=", "stdn_est", ".", "expand", "(", "-", "1", ",", "-", "1", ",", "channels", ")", "\n", "\n", "", "stdn_est", "=", "stdn_est", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "view", "(", "batch", ",", "channels", ",", "patchDims", "[", "0", "]", ",", "patchDims", "[", "1", "]", ")", "\n", "\n", "if", "upsample", ":", "\n", "        ", "return", "th", ".", "nn", ".", "functional", ".", "upsample", "(", "stdn_est", ",", "x", ".", "shape", "[", "2", ":", "]", ",", "mode", "=", "upsample_mode", ")", "\n", "", "else", ":", "\n", "        ", "return", "stdn_est", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.loadmat": [[1757, 1810], ["spio.loadmat", "utils_model.loadmat._check_keys"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.loadmat"], ["", "", "def", "loadmat", "(", "filename", ")", ":", "\n", "    ", "import", "scipy", ".", "io", "as", "spio", "\n", "'''\n    this function should be called instead of direct spio.loadmat\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    link: https://stackoverflow.com/questions/7008608/scipy-io-loadmat-nested-structures-i-e-dictionaries\n    '''", "\n", "def", "_check_keys", "(", "d", ")", ":", "\n", "        ", "'''\n        checks if entries in dictionary are mat-objects. If yes\n        todict is called to change them to nested dictionaries\n        '''", "\n", "for", "key", "in", "d", ":", "\n", "            ", "if", "isinstance", "(", "d", "[", "key", "]", ",", "spio", ".", "matlab", ".", "mio5_params", ".", "mat_struct", ")", ":", "\n", "                ", "d", "[", "key", "]", "=", "_todict", "(", "d", "[", "key", "]", ")", "\n", "", "", "return", "d", "\n", "\n", "", "def", "_todict", "(", "matobj", ")", ":", "\n", "        ", "'''\n        A recursive function which constructs from matobjects nested dictionaries\n        '''", "\n", "d", "=", "{", "}", "\n", "for", "strg", "in", "matobj", ".", "_fieldnames", ":", "\n", "            ", "elem", "=", "matobj", ".", "__dict__", "[", "strg", "]", "\n", "if", "isinstance", "(", "elem", ",", "spio", ".", "matlab", ".", "mio5_params", ".", "mat_struct", ")", ":", "\n", "                ", "d", "[", "strg", "]", "=", "_todict", "(", "elem", ")", "\n", "", "elif", "isinstance", "(", "elem", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "d", "[", "strg", "]", "=", "_tolist", "(", "elem", ")", "\n", "", "else", ":", "\n", "                ", "d", "[", "strg", "]", "=", "elem", "\n", "", "", "return", "d", "\n", "\n", "", "def", "_tolist", "(", "ndarray", ")", ":", "\n", "        ", "'''\n        A recursive function which constructs lists from cellarrays\n        (which are loaded as numpy ndarrays), recursing into the elements\n        if they contain matobjects.\n        '''", "\n", "elem_list", "=", "[", "]", "\n", "for", "sub_elem", "in", "ndarray", ":", "\n", "            ", "if", "isinstance", "(", "sub_elem", ",", "spio", ".", "matlab", ".", "mio5_params", ".", "mat_struct", ")", ":", "\n", "                ", "elem_list", ".", "append", "(", "_todict", "(", "sub_elem", ")", ")", "\n", "", "elif", "isinstance", "(", "sub_elem", ",", "np", ".", "ndarray", ")", ":", "\n", "                ", "elem_list", ".", "append", "(", "_tolist", "(", "sub_elem", ")", ")", "\n", "", "else", ":", "\n", "                ", "elem_list", ".", "append", "(", "sub_elem", ")", "\n", "", "", "return", "elem_list", "\n", "\n", "", "data", "=", "spio", ".", "loadmat", "(", "filename", ",", "struct_as_record", "=", "False", ",", "squeeze_me", "=", "True", ")", "\n", "\n", "return", "_check_keys", "(", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter2D_FrequencyDomain": [[1812, 1876], ["tuple", "tuple", "utils_model.shift", "torch.rfft", "torch.irfft", "pad2D.dim", "pad2D.dim", "pad2D.unsqueeze", "reverse.dim", "reverse.dim", "reverse.unsqueeze", "pad2D.dim", "reverse.unsqueeze", "utils_model.reverse", "utils_model.getPad2RetainShape", "utils_model.pad2D", "utils_model.getPad2RetainShape", "pad2D.dim", "torch.zeros().type_as", "torch.zeros().type_as", "pad2D.dim", "cmul", "utils_model.crop2D", "reverse.size", "reverse.size", "pad2D.size", "utils_model.reverse", "int", "torch.rfft", "torch.zeros", "torch.zeros", "pad2D.size", "pad2D.size", "pad2D.size", "pad2D.size", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.crop2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "imfilter2D_FrequencyDomain", "(", "input", ",", "kernel", ",", "padType", "=", "\"symmetric\"", ",", "mode", "=", "\"conv\"", ")", ":", "\n", "    ", "r\"\"\"If the input and the kernel are both multichannel tensors then each\n    channel of the input is filtered by the corresponding channel of the \n    kernel.Otherwise, if kernel has a single channel each channel of the input\n    is filtered by the same channel of the kernel.\"\"\"", "\n", "from", "pydl", ".", "cOps", "import", "cmul", "\n", "\n", "assert", "(", "mode", "in", "(", "\"conv\"", ",", "\"corr\"", ")", ")", ",", "\"Valid filtering modes are\"", "+", "\" 'conv' and 'corr'.\"", "\n", "assert", "(", "padType", "in", "(", "\"periodic\"", ",", "\"symmetric\"", ",", "\"zero\"", ",", "\"valid\"", ")", ")", ",", "\"Valid padType\"", "+", "\" values are 'periodic'|'symmetric'|'zero'|'valid'.\"", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The input must be at most a 4D tensor.\"", "\n", "\n", "while", "input", ".", "dim", "(", ")", "<", "3", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "assert", "(", "kernel", ".", "dim", "(", ")", "<", "4", ")", ",", "\"The filtering kernel must be at most a 3D tensor.\"", "\n", "\n", "while", "kernel", ".", "dim", "(", ")", "<", "3", ":", "\n", "        ", "kernel", "=", "kernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "assert", "(", "kernel", ".", "size", "(", "0", ")", "==", "1", "or", "kernel", ".", "size", "(", "0", ")", "==", "input", ".", "size", "(", "-", "3", ")", ")", ",", "\" Invalid \"", "+", "\"filtering kernel dimensions.\"", "\n", "\n", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "kernel", "=", "kernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "if", "mode", "!=", "\"conv\"", ":", "\n", "        ", "kernel", "=", "reverse", "(", "reverse", "(", "kernel", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "", "shape", "=", "tuple", "(", "kernel", ".", "shape", ")", "\n", "\n", "if", "padType", "==", "\"symmetric\"", "or", "padType", "==", "\"zero\"", ":", "\n", "        ", "padding", "=", "getPad2RetainShape", "(", "shape", "[", "-", "2", ":", "]", ",", "dilation", "=", "1", ")", "\n", "input", "=", "pad2D", "(", "input", ",", "padding", ",", "padType", ")", "\n", "\n", "", "if", "padType", "==", "\"valid\"", ":", "\n", "        ", "padding", "=", "getPad2RetainShape", "(", "shape", "[", "-", "2", ":", "]", ",", "dilation", "=", "1", ")", "\n", "\n", "", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "kernel_pad", "=", "th", ".", "zeros", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ",", "input", ".", "size", "(", "2", ")", ",", "input", ".", "size", "(", "3", ")", ")", ".", "type_as", "(", "kernel", ")", "\n", "kernel_pad", "[", "...", ",", "0", ":", "shape", "[", "2", "]", ",", "0", ":", "shape", "[", "3", "]", "]", "=", "kernel", "\n", "del", "kernel", "\n", "", "else", ":", "\n", "        ", "kernel_pad", "=", "th", ".", "zeros", "(", "shape", "[", "0", "]", ",", "input", ".", "size", "(", "1", ")", ",", "input", ".", "size", "(", "2", ")", ")", ".", "type_as", "(", "kernel", ")", "\n", "kernel_pad", "[", "...", ",", "0", ":", "shape", "[", "1", "]", ",", "0", ":", "shape", "[", "2", "]", "]", "=", "kernel", "\n", "del", "kernel", "\n", "\n", "", "s", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "-", "(", "np", ".", "asarray", "(", "shape", "[", "-", "2", ":", "]", ")", "//", "2", ")", ")", "\n", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "s", "=", "(", "0", ",", "0", ")", "+", "s", "\n", "", "else", ":", "\n", "        ", "s", "=", "(", "0", ",", ")", "+", "s", "\n", "", "kernel_pad", "=", "shift", "(", "kernel_pad", ",", "s", ",", "bc", "=", "'circular'", ")", "\n", "\n", "K", "=", "th", ".", "rfft", "(", "kernel_pad", ",", "2", ")", "\n", "\n", "out", "=", "th", ".", "irfft", "(", "cmul", "(", "th", ".", "rfft", "(", "input", ",", "2", ")", ",", "K", ")", ",", "2", ",", "signal_sizes", "=", "input", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "if", "padType", "!=", "\"periodic\"", ":", "\n", "        ", "out", "=", "crop2D", "(", "out", ",", "padding", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter_transpose2D_FrequencyDomain": [[1877, 1935], ["tuple", "tuple", "utils_model.shift", "conj", "torch.irfft", "pad2D.dim", "pad2D.dim", "pad2D.unsqueeze", "reverse.dim", "reverse.dim", "reverse.unsqueeze", "pad2D.dim", "reverse.unsqueeze", "utils_model.reverse", "utils_model.getPad2RetainShape", "utils_model.pad2D", "pad2D.dim", "torch.zeros().type_as", "torch.zeros().type_as", "pad2D.dim", "torch.rfft", "cmul", "utils_model.pad_transpose2D", "reverse.size", "reverse.size", "pad2D.size", "utils_model.reverse", "int", "torch.rfft", "torch.zeros", "torch.zeros", "pad2D.size", "pad2D.size", "pad2D.size", "pad2D.size", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad_transpose2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "imfilter_transpose2D_FrequencyDomain", "(", "input", ",", "kernel", ",", "padType", "=", "\"symmetric\"", ",", "mode", "=", "\"conv\"", ")", ":", "\n", "\n", "    ", "from", "pydl", ".", "cOps", "import", "cmul", ",", "conj", "\n", "\n", "assert", "(", "mode", "in", "(", "\"conv\"", ",", "\"corr\"", ")", ")", ",", "\"Valid filtering modes are\"", "+", "\" 'conv' and 'corr'.\"", "\n", "assert", "(", "padType", "in", "(", "\"periodic\"", ",", "\"symmetric\"", ",", "\"zero\"", ",", "\"valid\"", ")", ")", ",", "\"Valid padType\"", "+", "\" values are 'periodic'|'symmetric'|'zero'|'valid'.\"", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The input must be at most a 4D tensor.\"", "\n", "\n", "while", "input", ".", "dim", "(", ")", "<", "3", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "assert", "(", "kernel", ".", "dim", "(", ")", "<", "4", ")", ",", "\"The filtering kernel must be at most a 3D tensor.\"", "\n", "\n", "while", "kernel", ".", "dim", "(", ")", "<", "3", ":", "\n", "        ", "kernel", "=", "kernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "assert", "(", "kernel", ".", "size", "(", "0", ")", "==", "1", "or", "kernel", ".", "size", "(", "0", ")", "==", "input", ".", "size", "(", "-", "3", ")", ")", ",", "\" Invalid \"", "+", "\"filtering kernel dimensions.\"", "\n", "\n", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "kernel", "=", "kernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "if", "mode", "!=", "\"conv\"", ":", "\n", "        ", "kernel", "=", "reverse", "(", "reverse", "(", "kernel", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "", "shape", "=", "tuple", "(", "kernel", ".", "shape", ")", "\n", "\n", "if", "padType", "!=", "\"periodic\"", ":", "\n", "        ", "padding", "=", "getPad2RetainShape", "(", "shape", "[", "-", "2", ":", "]", ",", "dilation", "=", "1", ")", "\n", "input", "=", "pad2D", "(", "input", ",", "padding", ",", "\"zero\"", ")", "\n", "\n", "", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "kernel_pad", "=", "th", ".", "zeros", "(", "shape", "[", "0", "]", ",", "shape", "[", "1", "]", ",", "input", ".", "size", "(", "2", ")", ",", "input", ".", "size", "(", "3", ")", ")", ".", "type_as", "(", "kernel", ")", "\n", "kernel_pad", "[", "...", ",", "0", ":", "shape", "[", "2", "]", ",", "0", ":", "shape", "[", "3", "]", "]", "=", "kernel", "\n", "del", "kernel", "\n", "", "else", ":", "\n", "        ", "kernel_pad", "=", "th", ".", "zeros", "(", "shape", "[", "0", "]", ",", "input", ".", "size", "(", "1", ")", ",", "input", ".", "size", "(", "2", ")", ")", ".", "type_as", "(", "kernel", ")", "\n", "kernel_pad", "[", "...", ",", "0", ":", "shape", "[", "1", "]", ",", "0", ":", "shape", "[", "2", "]", "]", "=", "kernel", "\n", "del", "kernel", "\n", "\n", "", "s", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "-", "(", "np", ".", "asarray", "(", "shape", "[", "-", "2", ":", "]", ")", "//", "2", ")", ")", "\n", "if", "input", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "s", "=", "(", "0", ",", "0", ")", "+", "s", "\n", "", "else", ":", "\n", "        ", "s", "=", "(", "0", ",", ")", "+", "s", "\n", "", "kernel_pad", "=", "shift", "(", "kernel_pad", ",", "s", ",", "bc", "=", "'circular'", ")", "\n", "\n", "K", "=", "conj", "(", "th", ".", "rfft", "(", "kernel_pad", ",", "2", ")", ")", "\n", "\n", "out", "=", "th", ".", "irfft", "(", "cmul", "(", "th", ".", "rfft", "(", "input", ",", "2", ")", ",", "K", ")", ",", "2", ",", "signal_sizes", "=", "input", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "if", "padType", "==", "\"symmetric\"", "or", "padType", "==", "\"zero\"", ":", "\n", "        ", "out", "=", "pad_transpose2D", "(", "out", ",", "padding", ",", "padType", ")", "\n", "\n", "", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter2D_SpatialDomain": [[1936, 1982], ["input.unsqueeze.size", "utils_model.pad2D", "torch.conv2d", "input.unsqueeze.dim", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "kernel.view.dim", "kernel.view.dim", "kernel.view.unsqueeze", "kernel.view.expand", "utils_model.reverse", "utils_model.getPad2RetainShape", "kernel.view.size", "kernel.view.view", "kernel.view.size", "kernel.view.size", "utils_model.reverse"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "imfilter2D_SpatialDomain", "(", "input", ",", "kernel", ",", "padType", "=", "\"symmetric\"", ",", "mode", "=", "\"conv\"", ")", ":", "\n", "    ", "r\"\"\"If the input and the kernel are both multichannel tensors then each\n    channel of the input is filtered by the corresponding channel of the \n    kernel.Otherwise, if kernel has a single channel each channel of the input\n    is filtered by the same channel of the kernel.\"\"\"", "\n", "\n", "assert", "(", "mode", "in", "(", "\"conv\"", ",", "\"corr\"", ")", ")", ",", "\"Valid filtering modes are\"", "+", "\" 'conv' and 'corr'.\"", "\n", "assert", "(", "padType", "in", "(", "\"periodic\"", ",", "\"symmetric\"", ",", "\"zero\"", ",", "\"valid\"", ")", ")", ",", "\"Valid padType\"", "+", "\" values are 'periodic'|'symmetric'|'zero'|'valid'.\"", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The input must be at most a 4D tensor.\"", "\n", "\n", "while", "input", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "assert", "(", "kernel", ".", "dim", "(", ")", "<", "4", ")", ",", "\"The filtering kernel must be at most a 3D tensor.\"", "\n", "\n", "while", "kernel", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "kernel", "=", "kernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "channels", "=", "input", ".", "size", "(", "1", ")", "\n", "assert", "(", "kernel", ".", "size", "(", "1", ")", "==", "1", "or", "kernel", ".", "size", "(", "1", ")", "==", "channels", ")", ",", "\"Invalid \"", "+", "\"filtering kernel dimensions.\"", "\n", "\n", "if", "channels", "!=", "1", ":", "\n", "        ", "kernel", "=", "kernel", ".", "expand", "(", "1", ",", "channels", ",", "*", "kernel", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "", "if", "mode", "==", "\"conv\"", ":", "\n", "        ", "kernel", "=", "reverse", "(", "reverse", "(", "kernel", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "", "if", "padType", "==", "\"valid\"", ":", "\n", "        ", "padding", "=", "0", "\n", "", "else", ":", "\n", "        ", "padding", "=", "getPad2RetainShape", "(", "kernel", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "", "input", "=", "pad2D", "(", "input", ",", "padding", ",", "padType", ")", "\n", "\n", "groups", "=", "1", "\n", "if", "kernel", ".", "size", "(", "1", ")", "!=", "1", ":", "\n", "        ", "kernel", "=", "kernel", ".", "view", "(", "channels", ",", "1", ",", "*", "kernel", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "groups", "=", "channels", "\n", "\n", "", "out", "=", "th", ".", "conv2d", "(", "input", ",", "kernel", ",", "groups", "=", "groups", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imfilter_transpose2D_SpatialDomain": [[1983, 2023], ["input.unsqueeze.size", "torch.conv_transpose2d", "utils_model.pad_transpose2D", "input.unsqueeze.dim", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "kernel.view.dim", "kernel.view.dim", "kernel.view.unsqueeze", "kernel.view.expand", "utils_model.reverse", "utils_model.getPad2RetainShape", "kernel.view.size", "kernel.view.view", "kernel.view.size", "kernel.view.size", "utils_model.reverse"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.pad_transpose2D", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getPad2RetainShape", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.reverse"], ["", "def", "imfilter_transpose2D_SpatialDomain", "(", "input", ",", "kernel", ",", "padType", "=", "\"symmetric\"", ",", "mode", "=", "\"conv\"", ")", ":", "\n", "\n", "    ", "assert", "(", "mode", "in", "(", "\"conv\"", ",", "\"corr\"", ")", ")", ",", "\"Valid filtering modes are\"", "+", "\" 'conv' and 'corr'.\"", "\n", "assert", "(", "padType", "in", "(", "\"periodic\"", ",", "\"symmetric\"", ",", "\"zero\"", ",", "\"valid\"", ")", ")", ",", "\"Valid padType\"", "+", "\" values are 'periodic'|'symmetric'|'zero'|'valid'.\"", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The input must be at most a 4D tensor.\"", "\n", "\n", "while", "input", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "assert", "(", "kernel", ".", "dim", "(", ")", "<", "4", ")", ",", "\"The filtering kernel must be at most a 3D tensor.\"", "\n", "\n", "while", "kernel", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "kernel", "=", "kernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "channels", "=", "input", ".", "size", "(", "1", ")", "\n", "assert", "(", "kernel", ".", "size", "(", "1", ")", "==", "1", "or", "kernel", ".", "size", "(", "1", ")", "==", "channels", ")", ",", "\"Invalid \"", "+", "\"filtering kernel dimensions.\"", "\n", "\n", "if", "channels", "!=", "1", ":", "\n", "        ", "kernel", "=", "kernel", ".", "expand", "(", "1", ",", "channels", ",", "*", "kernel", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "", "if", "mode", "==", "\"conv\"", ":", "\n", "        ", "kernel", "=", "reverse", "(", "reverse", "(", "kernel", ",", "dim", "=", "-", "1", ")", ",", "dim", "=", "-", "2", ")", "\n", "\n", "", "if", "padType", "==", "\"valid\"", ":", "\n", "        ", "padding", "=", "0", "\n", "", "else", ":", "\n", "        ", "padding", "=", "getPad2RetainShape", "(", "kernel", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "", "groups", "=", "1", "\n", "if", "kernel", ".", "size", "(", "1", ")", "!=", "1", ":", "\n", "        ", "kernel", "=", "kernel", ".", "view", "(", "channels", ",", "1", ",", "*", "kernel", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "groups", "=", "channels", "\n", "\n", "", "out", "=", "th", ".", "conv_transpose2d", "(", "input", ",", "kernel", ",", "groups", "=", "groups", ")", "\n", "\n", "return", "pad_transpose2D", "(", "out", ",", "padding", ",", "padType", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.wiener_deconv": [[2024, 2091], ["input.unsqueeze.size", "input.unsqueeze.size", "tuple", "tuple", "torch.zeros().type_as", "tuple", "utils_model.shift", "torch.rfft", "torch.zeros().type_as", "tuple", "utils_model.shift", "torch.rfft", "cmul().unsqueeze", "cabs().pow().unsqueeze", "cabs().pow().sum().unsqueeze", "G.mul().unsqueeze.mul().unsqueeze", "cabs().pow().unsqueeze.unsqueeze", "torch.irfft", "input.unsqueeze.dim", "input.unsqueeze.dim", "input.unsqueeze.unsqueeze", "blurKernel.unsqueeze.dim", "blurKernel.unsqueeze.dim", "blurKernel.unsqueeze.unsqueeze", "regKernel.unsqueeze.dim", "regKernel.unsqueeze.dim", "regKernel.unsqueeze.unsqueeze", "cmul().unsqueeze.div", "torch.zeros", "int", "torch.zeros", "int", "cmul", "cabs().pow", "cabs().pow().sum", "G.mul().unsqueeze.mul", "input.unsqueeze.size", "input.unsqueeze.size", "input.unsqueeze.size", "input.unsqueeze.size", "conj", "torch.rfft", "alpha.unsqueeze().unsqueeze", "cabs", "cabs().pow", "numpy.asarray", "numpy.asarray", "alpha.unsqueeze", "cabs"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift"], ["", "def", "wiener_deconv", "(", "input", ",", "blurKernel", ",", "regKernel", ",", "alpha", ")", ":", "\n", "    ", "r\"\"\"Multi Multichannel Deconvolution Wiener Filter for a batch of input\n    images. (Filtering is taking place in the Frequency domain under the \n    assumption of periodic boundary conditions for the input image.)\n    \n    input :: tensor of size batch x channels x height x width.\n    blurKernel :: tensor of size batch x channels x b_height x b_width\n    regKernel :: tensor of size N x D x channels x r_height x r_width\n    alpha :: tensor of size batch x N x channels.\n    \n    output : batch x N x channels x height x width\"\"\"", "\n", "\n", "from", "pydl", ".", "cOps", "import", "cmul", ",", "cabs", ",", "conj", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The input must be at most a 4D tensor.\"", "\n", "while", "input", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "input", "=", "input", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "batch", "=", "input", ".", "size", "(", "0", ")", "\n", "channels", "=", "input", ".", "size", "(", "1", ")", "\n", "\n", "assert", "(", "blurKernel", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The blurring kernel must be at most a 4D tensor.\"", "\n", "while", "blurKernel", ".", "dim", "(", ")", "<", "4", ":", "\n", "        ", "blurKernel", "=", "blurKernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "bshape", "=", "tuple", "(", "blurKernel", ".", "shape", ")", "\n", "assert", "(", "bshape", "[", "0", "]", "in", "(", "1", ",", "batch", ")", "and", "bshape", "[", "1", "]", "in", "(", "1", ",", "channels", ")", ")", ",", "\"Invalid blurring kernel dimensions.\"", "\n", "\n", "assert", "(", "regKernel", ".", "dim", "(", ")", "<", "6", ")", ",", "\"The regularization kernel must be at most a 5D tensor.\"", "\n", "while", "regKernel", ".", "dim", "(", ")", "<", "5", ":", "\n", "        ", "regKernel", "=", "regKernel", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "rshape", "=", "tuple", "(", "regKernel", ".", "shape", ")", "\n", "assert", "(", "rshape", "[", "2", "]", "in", "(", "1", ",", "channels", ")", ")", ",", "\"Invalid regularization kernel dimensions.\"", "\n", "\n", "N", "=", "rshape", "[", "0", "]", "# Number of wiener filters applied to each input image of size channels x height x width", "\n", "\n", "assert", "(", "alpha", ".", "shape", "==", "(", "batch", ",", "N", ",", "channels", ")", ")", ",", "\"Invalid dimensions for \"", "+", "\"alpha parameter. The expected shape of the tensor is {} x {} x {}\"", ".", "format", "(", "batch", ",", "N", ",", "channels", ")", "\n", "\n", "K", "=", "th", ".", "zeros", "(", "bshape", "[", "0", "]", ",", "bshape", "[", "1", "]", ",", "input", ".", "size", "(", "2", ")", ",", "input", ".", "size", "(", "3", ")", ")", ".", "type_as", "(", "blurKernel", ")", "\n", "K", "[", "...", ",", "0", ":", "bshape", "[", "2", "]", ",", "0", ":", "bshape", "[", "3", "]", "]", "=", "blurKernel", "\n", "del", "blurKernel", "\n", "\n", "bs", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "-", "(", "np", ".", "asarray", "(", "bshape", "[", "-", "2", ":", "]", ")", "//", "2", ")", ")", "\n", "bs", "=", "(", "0", ",", "0", ")", "+", "bs", "\n", "K", "=", "shift", "(", "K", ",", "bs", ",", "bc", "=", "'circular'", ")", "\n", "K", "=", "th", ".", "rfft", "(", "K", ",", "2", ")", "# batch x channels x height x width x 2", "\n", "\n", "G", "=", "th", ".", "zeros", "(", "rshape", "[", "0", "]", ",", "rshape", "[", "1", "]", ",", "rshape", "[", "2", "]", ",", "input", ".", "size", "(", "2", ")", ",", "input", ".", "size", "(", "3", ")", ")", ".", "type_as", "(", "regKernel", ")", "\n", "G", "[", "...", ",", "0", ":", "rshape", "[", "3", "]", ",", "0", ":", "rshape", "[", "4", "]", "]", "=", "regKernel", "\n", "del", "regKernel", "\n", "\n", "rs", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "-", "(", "np", ".", "asarray", "(", "rshape", "[", "-", "2", ":", "]", ")", "//", "2", ")", ")", "\n", "rs", "=", "(", "0", ",", "0", ",", "0", ")", "+", "rs", "\n", "G", "=", "shift", "(", "G", ",", "rs", ",", "bc", "=", "'circular'", ")", "\n", "G", "=", "th", ".", "rfft", "(", "G", ",", "2", ")", "# N x D x channels x height x width x 2     ", "\n", "\n", "Y", "=", "cmul", "(", "conj", "(", "K", ")", ",", "th", ".", "rfft", "(", "input", ",", "2", ")", ")", ".", "unsqueeze", "(", "1", ")", "# batch x 1 x channels x height x width x 2", "\n", "\n", "K", "=", "cabs", "(", "K", ")", ".", "pow", "(", "2", ")", ".", "unsqueeze", "(", "-", "1", ")", "# batch x channels x height x width x 1", "\n", "G", "=", "cabs", "(", "G", ")", ".", "pow", "(", "2", ")", ".", "sum", "(", "dim", "=", "1", ")", ".", "unsqueeze", "(", "0", ")", "# 1 x N x channels x height x width", "\n", "# batch x N x channels x height x width x 1", "\n", "G", "=", "G", ".", "mul", "(", "alpha", ".", "unsqueeze", "(", "-", "1", ")", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "unsqueeze", "(", "-", "1", ")", "\n", "G", "+=", "K", ".", "unsqueeze", "(", "1", ")", "# batch x N x channels x height x width x 1 ", "\n", "del", "K", "\n", "return", "th", ".", "irfft", "(", "Y", ".", "div", "(", "G", ")", ",", "2", ",", "signal_sizes", "=", "input", ".", "shape", "[", "-", "2", ":", "]", ")", "# batch x N x channels x height x width", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.fftshift": [[2093, 2120], ["utils_model.shift", "torch.is_tensor", "torch.tensor().div().floor", "x.size", "isinstance", "x.dim", "x.size", "tuple", "x.dim", "torch.tensor().div", "int", "torch.tensor"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift"], ["", "def", "fftshift", "(", "x", ",", "dim", "=", "None", ")", ":", "\n", "    ", "r\"\"\"FFTSHIFT Shift zero-frequency component to the center of the spectrum.\n    For 1D complex tensors, FFTSHIFT(X) swaps the left and right halves of\n    X.  For 2D complex tensors, FFTSHIFT(X) swaps the first and third\n    quadrants and the second and fourth quadrants.  For N-D complex tensors\n    FFTSHIFT(X) swaps \"half-spaces\" of X along each dimension. \n    A complex N-D tensor is a (N+1)-D tensor whose last dimension must be equal \n    to 2.\n\n    FFTSHIFT(X,DIM) applies the FFTSHIFT operation along the \n    dimension DIM.\n\n    FFTSHIFT is useful for visualizing the Fourier transform with\n    the zero-frequency component in the middle of the spectrum.\"\"\"", "\n", "\n", "assert", "(", "th", ".", "is_tensor", "(", "x", ")", "and", "x", ".", "size", "(", "-", "1", ")", "==", "2", ")", ",", "\"input must be a complex tensor.\"", "\n", "\n", "if", "dim", "is", "not", "None", ":", "\n", "        ", "assert", "(", "isinstance", "(", "dim", ",", "int", ")", "and", "dim", ">", "-", "1", "and", "dim", "<", "x", ".", "dim", "(", ")", ")", ",", "\"Invalid specified dimension.\"", "\n", "s", "=", "(", "0", ",", ")", "*", "x", ".", "dim", "(", ")", "\n", "s", "[", "dim", "]", "=", "x", ".", "size", "(", "dim", ")", "//", "2", "\n", "", "else", ":", "\n", "        ", "s", "=", "th", ".", "tensor", "(", "x", ".", "shape", "[", "0", ":", "-", "1", "]", ",", "dtype", "=", "th", ".", "float32", ")", ".", "div", "(", "2", ")", ".", "floor", "(", ")", "\n", "s", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "s", ")", "+", "(", "0", ",", ")", "\n", "\n", "\n", "", "return", "shift", "(", "x", ",", "s", ",", "bc", "=", "'circular'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gaussian_filter": [[2122, 2138], ["utils_model.formatInput2Tuple", "tuple", "utils_model.meshgrid", "numpy.exp", "numpy.spacing", "numpy.arange", "numpy.arange", "numpy.sum", "numpy.sum", "numpy.max"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.formatInput2Tuple", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.meshgrid"], ["", "def", "gaussian_filter", "(", "shape", ",", "std", ")", ":", "\n", "\n", "    ", "shape", "=", "formatInput2Tuple", "(", "shape", ",", "float", ",", "2", ")", "\n", "siz", "=", "tuple", "(", "(", "k", "-", "1", ")", "/", "2", "for", "k", "in", "shape", ")", "\n", "\n", "[", "y", ",", "x", "]", "=", "meshgrid", "(", "np", ".", "arange", "(", "-", "siz", "[", "0", "]", ",", "siz", "[", "0", "]", "+", "1", ")", ",", "np", ".", "arange", "(", "-", "siz", "[", "1", "]", ",", "siz", "[", "1", "]", "+", "1", ")", ")", "\n", "arg", "=", "-", "(", "x", "**", "2", "+", "y", "**", "2", ")", "/", "(", "2", "*", "std", "**", "2", ")", "\n", "\n", "h", "=", "np", ".", "exp", "(", "arg", ")", "\n", "eps", "=", "np", ".", "spacing", "(", "1", ")", "\n", "h", "[", "h", "<", "eps", "*", "np", ".", "max", "(", "h", ")", "]", "=", "0", "\n", "\n", "if", "np", ".", "sum", "(", "h", ")", "!=", "0", ":", "\n", "        ", "h", "=", "h", "/", "np", ".", "sum", "(", "h", ")", "\n", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.power_iteration": [[2139, 2148], ["range", "A", "A.norm", "A().mul().sum", "x0.norm().pow", "A().mul", "x0.norm", "A"], "function", ["None"], ["", "def", "power_iteration", "(", "x0", ",", "A", ",", "numiter", "=", "20", ")", ":", "\n", "    ", "r\"\"\"Compute the largest eigenvalue of the operator A.\"\"\"", "\n", "\n", "for", "i", "in", "range", "(", "numiter", ")", ":", "\n", "        ", "x", "=", "A", "(", "x0", ")", "\n", "x", "/=", "x", ".", "norm", "(", "p", "=", "2", ")", "\n", "x0", "=", "x", "\n", "\n", "", "return", "A", "(", "x0", ")", ".", "mul", "(", "x0", ")", ".", "sum", "(", ")", "/", "x0", ".", "norm", "(", "p", "=", "2", ")", ".", "pow", "(", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.getSubArrays": [[2149, 2176], ["numpy.int32", "range", "numpy.array", "numpy.linspace", "dformat", "range"], "function", ["None"], ["", "def", "getSubArrays", "(", "start", ",", "end", ",", "numSubArrays", ",", "length", ",", "dformat", "=", "lambda", "x", ":", "np", ".", "array", "(", "x", ")", ")", ":", "\n", "    ", "r\"\"\" We want to split the array A=[start:end] in numSubArrays arrays of \n    equal  length so that all the elements in A are included in at least one of \n    the created sub-arrays.\n    \n    Returns the starting (s) and ending points (e) of each sub-array.\n    \n    The last argument 'dformat' is a lambda expression which can be defined to\n    specify the type of the structure that will hold the data (default :\n        lambda x:np.array(x))\n    \n    \"\"\"", "\n", "\n", "assert", "(", "numSubArrays", "*", "length", ">=", "end", ")", ",", "\"The combination of the selected \"", "+", "\"number of sub-arrays and length cannot cover completely all the elements \"", "+", "\"between start and end.\"", "\n", "\n", "p", "=", "end", "-", "length", "\n", "s", "=", "np", ".", "int32", "(", "np", ".", "linspace", "(", "start", ",", "p", ",", "numSubArrays", ")", ")", "\n", "e", "=", "s", "+", "length", "\n", "\n", "mask", "=", "{", "}", "\n", "for", "i", "in", "range", "(", "numSubArrays", ")", ":", "\n", "        ", "mask", "[", "i", "]", "=", "dformat", "(", "range", "(", "s", "[", "i", "]", ",", "e", "[", "i", "]", ")", ")", "\n", "\n", "\n", "", "return", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.psf2otf": [[2178, 2195], ["torch.zeros().type_as", "tuple", "utils_model.shift", "torch.rfft", "psf.dim", "len", "psf.size", "psf.size", "torch.zeros", "int", "psf.size", "psf.size", "len", "numpy.asarray"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift"], ["", "def", "psf2otf", "(", "psf", ",", "otfSize", ")", ":", "\n", "    ", "r\"\"\"Transforms a given 2D psf (point spread function) to a 2D otf (optical \n    transfer) function of a specified size\"\"\"", "\n", "\n", "assert", "(", "psf", ".", "dim", "(", ")", "==", "2", "and", "len", "(", "otfSize", ")", ">=", "2", ")", ",", "\"Invalid input for psf and/or otfSize.\"", "\n", "assert", "(", "psf", ".", "size", "(", "0", ")", "<=", "otfSize", "[", "-", "2", "]", "and", "psf", ".", "size", "(", "1", ")", "<=", "otfSize", "[", "-", "1", "]", ")", ",", "\"The \"", "+", "\"spatial support of the otf must be equal or larger to that of the psf.\"", "\n", "\n", "otf", "=", "th", ".", "zeros", "(", "otfSize", ")", ".", "type_as", "(", "psf", ")", "\n", "otf", "[", "...", ",", "0", ":", "psf", ".", "size", "(", "0", ")", ",", "0", ":", "psf", ".", "size", "(", "1", ")", "]", "=", "psf", "\n", "\n", "s", "=", "tuple", "(", "int", "(", "i", ")", "for", "i", "in", "-", "(", "np", ".", "asarray", "(", "psf", ".", "shape", "[", "0", ":", "]", ")", "//", "2", ")", ")", "\n", "s", "=", "(", "0", ",", ")", "*", "(", "len", "(", "otfSize", ")", "-", "2", ")", "+", "s", "\n", "otf", "=", "shift", "(", "otf", ",", "s", ",", "bc", "=", "'circular'", ")", "\n", "otf", "=", "th", ".", "rfft", "(", "otf", ",", "2", ")", "\n", "\n", "return", "otf", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.edgetaper": [[2196, 2242], ["utils_model.psf2otf", "torch.irfft", "torch.is_tensor", "torch.is_tensor", "input.dim", "psf.dim", "psf.size", "psf.sum", "torch.zeros().type_as", "torch.rfft", "torch.irfft", "torch.cat().div", "th.cat().div.unsqueeze", "psf.size", "psf.sum", "torch.zeros().type_as", "torch.rfft", "torch.irfft", "torch.cat().div", "th.cat().div.unsqueeze", "len", "alpha.unsqueeze.dim", "input.dim", "alpha.unsqueeze.unsqueeze", "cmul", "output.clamp", "cmul", "th.cat().div.max", "cmul", "th.cat().div.max", "beta.keys", "torch.rfft", "input.min", "input.max", "torch.zeros", "psf.size", "conj", "torch.cat", "torch.zeros", "psf.size", "conj", "torch.cat", "input.size", "input.size", "input.size", "input.size", "list", "beta.keys"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.psf2otf"], ["", "def", "edgetaper", "(", "input", ",", "psf", ")", ":", "\n", "\n", "    ", "from", "pydl", ".", "cOps", "import", "cmul", ",", "conj", "\n", "\n", "assert", "(", "th", ".", "is_tensor", "(", "input", ")", "and", "th", ".", "is_tensor", "(", "psf", ")", ")", ",", "\"The inputs must be \"", "+", "\"pytorch tensors.\"", "\n", "\n", "assert", "(", "input", ".", "dim", "(", ")", "<", "5", ")", ",", "\"The input is expected to be at most a 4D tensor.\"", "\n", "\n", "assert", "(", "psf", ".", "dim", "(", ")", "==", "2", ")", ",", "\"Only 2D psfs are accepted.\"", "\n", "\n", "beta", "=", "{", "}", "\n", "\n", "if", "psf", ".", "size", "(", "0", ")", "!=", "1", ":", "\n", "        ", "psfProj", "=", "psf", ".", "sum", "(", "dim", "=", "1", ")", "\n", "z", "=", "th", ".", "zeros", "(", "input", ".", "size", "(", "-", "2", ")", "-", "1", ")", ".", "type_as", "(", "psf", ")", "\n", "z", "[", "0", ":", "psf", ".", "size", "(", "0", ")", "]", "=", "psfProj", "\n", "z", "=", "th", ".", "rfft", "(", "z", ",", "1", ",", "onesided", "=", "True", ")", "\n", "z", "=", "th", ".", "irfft", "(", "cmul", "(", "z", ",", "conj", "(", "z", ")", ")", ",", "1", ",", "onesided", "=", "True", ",", "signal_sizes", "=", "(", "input", ".", "size", "(", "-", "2", ")", "-", "1", ",", ")", ")", "\n", "z", "=", "th", ".", "cat", "(", "(", "z", ",", "z", "[", "0", ":", "1", "]", ")", ",", "dim", "=", "0", ")", ".", "div", "(", "z", ".", "max", "(", ")", ")", "\n", "beta", "[", "'dim0'", "]", "=", "z", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "", "if", "psf", ".", "size", "(", "1", ")", "!=", "1", ":", "\n", "        ", "psfProj", "=", "psf", ".", "sum", "(", "dim", "=", "0", ")", "\n", "z", "=", "th", ".", "zeros", "(", "input", ".", "size", "(", "-", "1", ")", "-", "1", ")", ".", "type_as", "(", "psf", ")", "\n", "z", "[", "0", ":", "psf", ".", "size", "(", "1", ")", "]", "=", "psfProj", "\n", "z", "=", "th", ".", "rfft", "(", "z", ",", "1", ",", "onesided", "=", "True", ")", "\n", "z", "=", "th", ".", "irfft", "(", "cmul", "(", "z", ",", "conj", "(", "z", ")", ")", ",", "1", ",", "onesided", "=", "True", ",", "signal_sizes", "=", "(", "input", ".", "size", "(", "-", "1", ")", "-", "1", ",", ")", ")", "\n", "z", "=", "th", ".", "cat", "(", "(", "z", ",", "z", "[", "0", ":", "1", "]", ")", ",", "dim", "=", "0", ")", ".", "div", "(", "z", ".", "max", "(", ")", ")", "\n", "beta", "[", "'dim1'", "]", "=", "z", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "if", "len", "(", "beta", ".", "keys", "(", ")", ")", "==", "1", ":", "\n", "        ", "alpha", "=", "1", "-", "beta", "[", "list", "(", "beta", ".", "keys", "(", ")", ")", "[", "0", "]", "]", "\n", "", "else", ":", "\n", "        ", "alpha", "=", "(", "1", "-", "beta", "[", "'dim0'", "]", ")", "*", "(", "1", "-", "beta", "[", "'dim1'", "]", ")", "\n", "\n", "", "while", "alpha", ".", "dim", "(", ")", "<", "input", ".", "dim", "(", ")", ":", "\n", "        ", "alpha", "=", "alpha", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "otf", "=", "psf2otf", "(", "psf", ",", "input", ".", "shape", ")", "\n", "\n", "blurred_input", "=", "th", ".", "irfft", "(", "cmul", "(", "th", ".", "rfft", "(", "input", ",", "2", ")", ",", "otf", ")", ",", "2", ",", "signal_sizes", "=", "input", ".", "shape", "[", "-", "2", ":", "]", ")", "\n", "\n", "output", "=", "alpha", "*", "input", "+", "(", "1", "-", "alpha", ")", "*", "blurred_input", "\n", "\n", "return", "output", ".", "clamp", "(", "input", ".", "min", "(", ")", ",", "input", ".", "max", "(", ")", ")", ",", "alpha", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imGrad": [[2243, 2254], ["torch.cat", "torch.is_tensor", "input.dim", "utils_model.shift", "utils_model.shift"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift"], ["", "def", "imGrad", "(", "input", ",", "bc", "=", "'reflexive'", ")", ":", "\n", "    ", "r\"\"\"Computes the discrete gradient of an input batch of images of size \n    B x C x H x W. The output is of size B x 2*C x H x W where in the 2nd \n    dimension from 0:C the gradient with respect to the y-axis of each channel\n    of the image is stored, while in C:2C the gradient with respect to the \n    x-axis is stored.\"\"\"", "\n", "assert", "(", "th", ".", "is_tensor", "(", "input", ")", "and", "input", ".", "dim", "(", ")", "==", "4", ")", ",", "\"A 4D tensor is expected \"", "+", "\"as input.\"", "\n", "\n", "return", "th", ".", "cat", "(", "(", "shift", "(", "input", ",", "(", "0", ",", "0", ",", "-", "1", ",", "0", ")", ",", "bc", ")", "-", "input", ",", "shift", "(", "input", ",", "(", "0", ",", "0", ",", "0", ",", "-", "1", ")", ",", "bc", ")", "-", "input", ")", ",", "dim", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.imDivergence": [[2255, 2269], ["torch.is_tensor", "input.size", "input.dim", "input.size", "utils_model.shift_transpose", "utils_model.shift_transpose"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift_transpose", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.shift_transpose"], ["", "def", "imDivergence", "(", "input", ",", "bc", "=", "'reflexive'", ")", ":", "\n", "    ", "r\"\"\"Computes the discrete divergence ( adjoint of the gradient) of an input \n    batch of gradient images of size B x 2*C x H x W. The output is of size \n    B x C x H x W.\"\"\"", "\n", "\n", "assert", "(", "th", ".", "is_tensor", "(", "input", ")", "and", "input", ".", "dim", "(", ")", "==", "4", ")", ",", "\"A 4D tensor is expected \"", "+", "\"as input.\"", "\n", "\n", "assert", "(", "input", ".", "size", "(", "1", ")", "%", "2", "==", "0", ")", ",", "\"Invalid input dimensions: the second \"", "+", "\"dimension must be even sized.\"", "\n", "idx", "=", "input", ".", "size", "(", "1", ")", "//", "2", "\n", "\n", "return", "shift_transpose", "(", "input", "[", ":", ",", "0", ":", "idx", ",", "...", "]", ",", "(", "0", ",", "0", ",", "-", "1", ",", "0", ")", ",", "bc", ")", "-", "input", "[", ":", ",", "0", ":", "idx", ",", "...", "]", "+", "shift_transpose", "(", "input", "[", ":", ",", "idx", ":", ",", "...", "]", ",", "(", "0", ",", "0", ",", "0", ",", "-", "1", ")", ",", "bc", ")", "-", "input", "[", ":", ",", "idx", ":", ",", "...", "]", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_dct": [[2270, 2285], ["tensor.ndimension", "tensor.data.copy_", "weights[].type_as().view", "odctndict.permute", "tensor.data.copy_", "utils_model.odctndict", "utils_model.odctndict", "gen_dct3_kernel().type_as", "weights[].type_as", "utils_model.gen_dct3_kernel"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gen_dct3_kernel"], ["", "def", "init_dct", "(", "tensor", ")", ":", "\n", "    ", "r\"\"\"Initializes the input tensor with weights from the dct basis or dictionary.\"\"\"", "\n", "assert", "(", "tensor", ".", "ndimension", "(", ")", "==", "4", ")", ",", "\"A 4D tensor is expected.\"", "\n", "output_features", ",", "input_channels", ",", "H", ",", "W", "=", "tensor", ".", "shape", "\n", "\n", "if", "H", "*", "W", "*", "input_channels", "==", "output_features", "+", "1", ":", "\n", "        ", "tensor", ".", "data", ".", "copy_", "(", "gen_dct3_kernel", "(", "tensor", ".", "shape", "[", "1", ":", "]", ")", ".", "type_as", "(", "tensor", ")", "[", "1", ":", ",", "...", "]", ")", "\n", "", "else", ":", "\n", "        ", "if", "input_channels", "==", "1", ":", "\n", "            ", "weights", "=", "odctndict", "(", "(", "H", ",", "W", ")", ",", "output_features", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "weights", "=", "odctndict", "(", "(", "H", ",", "W", ",", "input_channels", ")", ",", "output_features", "+", "1", ")", "\n", "", "weights", "=", "weights", "[", ":", ",", "1", ":", "output_features", "+", "1", "]", ".", "type_as", "(", "tensor", ")", ".", "view", "(", "H", ",", "W", ",", "input_channels", ",", "output_features", ")", "\n", "weights", "=", "weights", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "tensor", ".", "data", ".", "copy_", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_dctMultiWiener": [[2286, 2311], ["tensor.data.copy_", "tensor.dim", "tensor.dim", "weights[].type_as().view", "weights.unsqueeze_().repeat.permute", "gen_dct2_kernel().type_as", "tensor.dim", "weights.unsqueeze_().repeat.repeat", "weights.unsqueeze_().repeat.unsqueeze_().repeat", "utils_model.odctndict", "utils_model.odctndict", "tensor.dim", "weights.unsqueeze_().repeat.unsqueeze_().repeat", "weights[].type_as", "utils_model.gen_dct2_kernel", "weights.unsqueeze_().repeat.unsqueeze_", "weights.unsqueeze_().repeat.unsqueeze_"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.odctndict", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gen_dct2_kernel"], ["", "", "def", "init_dctMultiWiener", "(", "tensor", ")", ":", "\n", "    ", "r\"\"\"Initializes the input tensor with weights from the dct basis or dictionary.\"\"\"", "\n", "assert", "(", "tensor", ".", "dim", "(", ")", "in", "(", "4", ",", "5", ")", ")", ",", "\"A 4D or 5D tensor is expected.\"", "\n", "if", "tensor", ".", "dim", "(", ")", "==", "4", ":", "\n", "        ", "output_features", ",", "input_channels", ",", "H", ",", "W", "=", "tensor", ".", "shape", "\n", "", "else", ":", "\n", "        ", "numFilters", ",", "output_features", ",", "input_channels", ",", "H", ",", "W", "=", "tensor", ".", "shape", "\n", "\n", "", "if", "H", "*", "W", "==", "output_features", "+", "1", ":", "\n", "        ", "weights", "=", "gen_dct2_kernel", "(", "(", "H", ",", "W", ")", ")", ".", "type_as", "(", "tensor", ")", "[", "1", ":", ",", "...", "]", "\n", "if", "tensor", ".", "dim", "(", ")", "==", "4", ":", "\n", "            ", "weights", "=", "weights", ".", "repeat", "(", "1", ",", "input_channels", ",", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "weights", "=", "weights", ".", "unsqueeze_", "(", "0", ")", ".", "repeat", "(", "numFilters", ",", "1", ",", "input_channels", ",", "1", ",", "1", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "input_channels", "==", "1", ":", "\n", "            ", "weights", "=", "odctndict", "(", "(", "H", ",", "W", ")", ",", "output_features", "+", "1", ")", "\n", "", "else", ":", "\n", "            ", "weights", "=", "odctndict", "(", "(", "H", ",", "W", ",", "input_channels", ")", ",", "output_features", "+", "1", ")", "\n", "", "weights", "=", "weights", "[", ":", ",", "1", ":", "output_features", "+", "1", "]", ".", "type_as", "(", "tensor", ")", ".", "view", "(", "H", ",", "W", ",", "input_channels", ",", "output_features", ")", "\n", "weights", "=", "weights", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "if", "tensor", ".", "dim", "(", ")", "==", "5", ":", "\n", "            ", "weights", "=", "weights", ".", "unsqueeze_", "(", "0", ")", ".", "repeat", "(", "numFilters", ",", "1", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "", "", "tensor", ".", "data", ".", "copy_", "(", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_rbf_lut": [[2313, 2319], ["torch.range().type_as", "data_samples.unsqueeze.unsqueeze", "torch.range"], "function", ["None"], ["", "def", "init_rbf_lut", "(", "centers", ",", "sigma", ",", "start", ",", "end", ",", "step", ")", ":", "\n", "    ", "r\"\"\"Computes necessary data for the Look-up table of rbf computation.\"\"\"", "\n", "data_samples", "=", "th", ".", "range", "(", "start", ",", "end", ",", "step", ")", ".", "type_as", "(", "centers", ")", "\n", "data_samples", "=", "data_samples", ".", "unsqueeze", "(", "1", ")", "\n", "data_samples", "=", "(", "data_samples", "-", "centers", ")", "/", "sigma", "\n", "return", "data_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_msra": [[2320, 2325], ["tensor.data.copy_", "torch.randn_like().mul", "torch.sqrt().type_as().div", "torch.randn_like", "torch.sqrt().type_as", "torch.sqrt", "torch.Tensor"], "function", ["None"], ["", "def", "init_msra", "(", "tensor", ")", ":", "\n", "    ", "r\"\"\"Initializes the input tensor with weights according to He initialization.\"\"\"", "\n", "output_channels", ",", "input_channels", ",", "H", ",", "W", "=", "tensor", ".", "shape", "\n", "tensor", ".", "data", ".", "copy_", "(", "th", ".", "randn_like", "(", "tensor", ")", ".", "mul", "(", "th", ".", "sqrt", "(", "th", ".", "Tensor", "(", "[", "2", "]", ")", ")", ".", "type_as", "(", "tensor", ")", ".", "div", "(", "H", "*", "W", "*", "input_channels", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_convWeights": [[2326, 2333], ["utils_model.init_dct", "utils_model.init_msra"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_dct", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.init_msra"], ["", "def", "init_convWeights", "(", "tensor", ",", "init_type", "=", "'dct'", ")", ":", "\n", "    ", "if", "init_type", "==", "'dct'", ":", "\n", "        ", "init_dct", "(", "tensor", ")", "\n", "", "elif", "init_type", "==", "'msra'", ":", "\n", "        ", "init_msra", "(", "tensor", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.load_image": [[10, 22], ["rawpy.imread", "raw.postprocess", "cv2.imread", "matplotlib.imread"], "function", ["None"], ["def", "load_image", "(", "path", ")", ":", "\n", "    ", "if", "(", "path", "[", "-", "3", ":", "]", "==", "'dng'", ")", ":", "\n", "        ", "import", "rawpy", "\n", "with", "rawpy", ".", "imread", "(", "path", ")", "as", "raw", ":", "\n", "            ", "img", "=", "raw", ".", "postprocess", "(", ")", "\n", "", "", "elif", "(", "path", "[", "-", "3", ":", "]", "==", "'bmp'", "or", "path", "[", "-", "3", ":", "]", "==", "'jpg'", "or", "path", "[", "-", "3", ":", "]", "==", "'png'", ")", ":", "\n", "        ", "import", "cv2", "\n", "return", "cv2", ".", "imread", "(", "path", ")", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "        ", "img", "=", "(", "255", "*", "plt", ".", "imread", "(", "path", ")", "[", ":", ",", ":", ",", ":", "3", "]", ")", ".", "astype", "(", "'uint8'", ")", "\n", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.save_image": [[23, 26], ["PIL.Image.fromarray", "Image.fromarray.save"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save"], ["", "def", "save_image", "(", "image_numpy", ",", "image_path", ",", ")", ":", "\n", "    ", "image_pil", "=", "Image", ".", "fromarray", "(", "image_numpy", ")", "\n", "image_pil", ".", "save", "(", "image_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.mkdirs": [[27, 33], ["isinstance", "util.mkdir", "isinstance", "util.mkdir"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.mkdir", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.mkdir"], ["", "def", "mkdirs", "(", "paths", ")", ":", "\n", "    ", "if", "isinstance", "(", "paths", ",", "list", ")", "and", "not", "isinstance", "(", "paths", ",", "str", ")", ":", "\n", "        ", "for", "path", "in", "paths", ":", "\n", "            ", "mkdir", "(", "path", ")", "\n", "", "", "else", ":", "\n", "        ", "mkdir", "(", "paths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.mkdir": [[34, 37], ["os.path.exists", "os.makedirs"], "function", ["None"], ["", "", "def", "mkdir", "(", "path", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.tensor2im": [[39, 44], ["image_tensor[].cpu().float().numpy", "image_tensor[].cpu().float().numpy.astype", "image_tensor[].cpu().float", "numpy.transpose", "image_tensor[].cpu"], "function", ["None"], ["", "", "def", "tensor2im", "(", "image_tensor", ",", "imtype", "=", "np", ".", "uint8", ",", "cent", "=", "1.", ",", "factor", "=", "255.", "/", "2.", ")", ":", "\n", "# def tensor2im(image_tensor, imtype=np.uint8, cent=1., factor=1.):", "\n", "    ", "image_numpy", "=", "image_tensor", "[", "0", "]", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "image_numpy", "=", "(", "np", ".", "transpose", "(", "image_numpy", ",", "(", "1", ",", "2", ",", "0", ")", ")", "+", "cent", ")", "*", "factor", "\n", "return", "image_numpy", ".", "astype", "(", "imtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.im2tensor": [[45, 49], ["torch.Tensor", "[].transpose"], "function", ["None"], ["", "def", "im2tensor", "(", "image", ",", "imtype", "=", "np", ".", "uint8", ",", "cent", "=", "1.", ",", "factor", "=", "255.", "/", "2.", ")", ":", "\n", "# def im2tensor(image, imtype=np.uint8, cent=1., factor=1.):", "\n", "    ", "return", "torch", ".", "Tensor", "(", "(", "image", "/", "factor", "-", "cent", ")", "\n", "[", ":", ",", ":", ",", ":", ",", "np", ".", "newaxis", "]", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.util.normalized_tensor": [[50, 52], ["None"], "function", ["None"], ["", "def", "normalized_tensor", "(", "image", ",", "cent", "=", "1.", ",", "factor", "=", "255.", "/", "2.", ")", ":", "\n", "    ", "return", "image", "/", "factor", "-", "cent", "\n", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.PNetLin.__init__": [[28, 63], ["torch.Module.__init__", "networks_basic.ScalingLayer", "len", "net_type", "networks_basic.NetLinLayer", "networks_basic.NetLinLayer", "networks_basic.NetLinLayer", "networks_basic.NetLinLayer", "networks_basic.NetLinLayer", "networks_basic.NetLinLayer", "networks_basic.NetLinLayer"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "pnet_type", "=", "'vgg'", ",", "pnet_rand", "=", "False", ",", "pnet_tune", "=", "False", ",", "use_dropout", "=", "True", ",", "spatial", "=", "False", ",", "version", "=", "'0.1'", ",", "lpips", "=", "True", ")", ":", "\n", "        ", "super", "(", "PNetLin", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "pnet_type", "=", "pnet_type", "\n", "self", ".", "pnet_tune", "=", "pnet_tune", "\n", "self", ".", "pnet_rand", "=", "pnet_rand", "\n", "self", ".", "spatial", "=", "spatial", "\n", "self", ".", "lpips", "=", "lpips", "\n", "self", ".", "version", "=", "version", "\n", "self", ".", "scaling_layer", "=", "ScalingLayer", "(", ")", "\n", "\n", "if", "(", "self", ".", "pnet_type", "in", "[", "'vgg'", ",", "'vgg16'", "]", ")", ":", "\n", "            ", "net_type", "=", "pn", ".", "vgg16", "\n", "self", ".", "chns", "=", "[", "64", ",", "128", ",", "256", ",", "512", ",", "512", "]", "\n", "", "elif", "(", "self", ".", "pnet_type", "==", "'alex'", ")", ":", "\n", "            ", "net_type", "=", "pn", ".", "alexnet", "\n", "self", ".", "chns", "=", "[", "64", ",", "192", ",", "384", ",", "256", ",", "256", "]", "\n", "", "elif", "(", "self", ".", "pnet_type", "==", "'squeeze'", ")", ":", "\n", "            ", "net_type", "=", "pn", ".", "squeezenet", "\n", "self", ".", "chns", "=", "[", "64", ",", "128", ",", "256", ",", "384", ",", "384", ",", "512", ",", "512", "]", "\n", "", "self", ".", "L", "=", "len", "(", "self", ".", "chns", ")", "\n", "\n", "self", ".", "net", "=", "net_type", "(", "pretrained", "=", "not", "self", ".", "pnet_rand", ",", "requires_grad", "=", "self", ".", "pnet_tune", ")", "\n", "\n", "if", "(", "lpips", ")", ":", "\n", "            ", "self", ".", "lin0", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "0", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lin1", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "1", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lin2", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "2", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lin3", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "3", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lin4", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "4", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lins", "=", "[", "self", ".", "lin0", ",", "self", ".", "lin1", ",", "self", ".", "lin2", ",", "self", ".", "lin3", ",", "self", ".", "lin4", "]", "\n", "if", "(", "self", ".", "pnet_type", "==", "'squeeze'", ")", ":", "# 7 layers for squeezenet", "\n", "                ", "self", ".", "lin5", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "5", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lin6", "=", "NetLinLayer", "(", "self", ".", "chns", "[", "6", "]", ",", "use_dropout", "=", "use_dropout", ")", "\n", "self", ".", "lins", "+=", "[", "self", ".", "lin5", ",", "self", ".", "lin6", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.PNetLin.forward": [[64, 93], ["range", "range", "networks_basic.PNetLin.net.forward", "networks_basic.PNetLin.net.forward", "networks_basic.PNetLin.scaling_layer", "networks_basic.PNetLin.scaling_layer", "modules.normalize_tensor", "modules.normalize_tensor", "networks_basic.upsample", "networks_basic.spatial_average", "networks_basic.upsample", "networks_basic.spatial_average", "networks_basic.PNetLin.lins[].model", "range", "networks_basic.PNetLin.lins[].model", "range", "diffs[].sum", "range", "diffs[].sum", "range"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.normalize_tensor", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.normalize_tensor", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.upsample", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.spatial_average", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.upsample", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.spatial_average"], ["", "", "", "def", "forward", "(", "self", ",", "in0", ",", "in1", ",", "retPerLayer", "=", "False", ")", ":", "\n", "# v0.0 - original release had a bug, where input was not scaled", "\n", "        ", "in0_input", ",", "in1_input", "=", "(", "self", ".", "scaling_layer", "(", "in0", ")", ",", "self", ".", "scaling_layer", "(", "in1", ")", ")", "if", "self", ".", "version", "==", "'0.1'", "else", "(", "in0", ",", "in1", ")", "\n", "outs0", ",", "outs1", "=", "self", ".", "net", ".", "forward", "(", "in0_input", ")", ",", "self", ".", "net", ".", "forward", "(", "in1_input", ")", "\n", "feats0", ",", "feats1", ",", "diffs", "=", "{", "}", ",", "{", "}", ",", "{", "}", "\n", "\n", "for", "kk", "in", "range", "(", "self", ".", "L", ")", ":", "\n", "            ", "feats0", "[", "kk", "]", ",", "feats1", "[", "kk", "]", "=", "util", ".", "normalize_tensor", "(", "outs0", "[", "kk", "]", ")", ",", "util", ".", "normalize_tensor", "(", "outs1", "[", "kk", "]", ")", "\n", "diffs", "[", "kk", "]", "=", "(", "feats0", "[", "kk", "]", "-", "feats1", "[", "kk", "]", ")", "**", "2", "\n", "\n", "", "if", "(", "self", ".", "lpips", ")", ":", "\n", "            ", "if", "(", "self", ".", "spatial", ")", ":", "\n", "                ", "res", "=", "[", "upsample", "(", "self", ".", "lins", "[", "kk", "]", ".", "model", "(", "diffs", "[", "kk", "]", ")", ",", "out_H", "=", "in0", ".", "shape", "[", "2", "]", ")", "for", "kk", "in", "range", "(", "self", ".", "L", ")", "]", "\n", "", "else", ":", "\n", "                ", "res", "=", "[", "spatial_average", "(", "self", ".", "lins", "[", "kk", "]", ".", "model", "(", "diffs", "[", "kk", "]", ")", ",", "keepdim", "=", "True", ")", "for", "kk", "in", "range", "(", "self", ".", "L", ")", "]", "\n", "", "", "else", ":", "\n", "            ", "if", "(", "self", ".", "spatial", ")", ":", "\n", "                ", "res", "=", "[", "upsample", "(", "diffs", "[", "kk", "]", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ",", "out_H", "=", "in0", ".", "shape", "[", "2", "]", ")", "for", "kk", "in", "range", "(", "self", ".", "L", ")", "]", "\n", "", "else", ":", "\n", "                ", "res", "=", "[", "spatial_average", "(", "diffs", "[", "kk", "]", ".", "sum", "(", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ",", "keepdim", "=", "True", ")", "for", "kk", "in", "range", "(", "self", ".", "L", ")", "]", "\n", "\n", "", "", "val", "=", "res", "[", "0", "]", "\n", "for", "l", "in", "range", "(", "1", ",", "self", ".", "L", ")", ":", "\n", "            ", "val", "+=", "res", "[", "l", "]", "\n", "\n", "", "if", "(", "retPerLayer", ")", ":", "\n", "            ", "return", "(", "val", ",", "res", ")", "\n", "", "else", ":", "\n", "            ", "return", "val", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.ScalingLayer.__init__": [[95, 99], ["torch.Module.__init__", "networks_basic.ScalingLayer.register_buffer", "networks_basic.ScalingLayer.register_buffer", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "ScalingLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "register_buffer", "(", "'shift'", ",", "torch", ".", "Tensor", "(", "[", "-", ".030", ",", "-", ".088", ",", "-", ".188", "]", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", ")", "\n", "self", ".", "register_buffer", "(", "'scale'", ",", "torch", ".", "Tensor", "(", "[", ".458", ",", ".448", ",", ".450", "]", ")", "[", "None", ",", ":", ",", "None", ",", "None", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.ScalingLayer.forward": [[100, 102], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "return", "(", "inp", "-", "self", ".", "shift", ")", "/", "self", ".", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.NetLinLayer.__init__": [[106, 112], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["def", "__init__", "(", "self", ",", "chn_in", ",", "chn_out", "=", "1", ",", "use_dropout", "=", "False", ")", ":", "\n", "        ", "super", "(", "NetLinLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "layers", "=", "[", "nn", ".", "Dropout", "(", ")", ",", "]", "if", "(", "use_dropout", ")", "else", "[", "]", "\n", "layers", "+=", "[", "nn", ".", "Conv2d", "(", "chn_in", ",", "chn_out", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ",", "]", "\n", "self", ".", "model", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.Dist2LogitLayer.__init__": [[116, 127], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sigmoid", "torch.Sigmoid", "torch.Sigmoid"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["def", "__init__", "(", "self", ",", "chn_mid", "=", "32", ",", "use_sigmoid", "=", "True", ")", ":", "\n", "        ", "super", "(", "Dist2LogitLayer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "layers", "=", "[", "nn", ".", "Conv2d", "(", "5", ",", "chn_mid", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ")", ",", "]", "\n", "layers", "+=", "[", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "]", "\n", "layers", "+=", "[", "nn", ".", "Conv2d", "(", "chn_mid", ",", "chn_mid", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ")", ",", "]", "\n", "layers", "+=", "[", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "]", "\n", "layers", "+=", "[", "nn", ".", "Conv2d", "(", "chn_mid", ",", "1", ",", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "True", ")", ",", "]", "\n", "if", "(", "use_sigmoid", ")", ":", "\n", "            ", "layers", "+=", "[", "nn", ".", "Sigmoid", "(", ")", ",", "]", "\n", "", "self", ".", "model", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.Dist2LogitLayer.forward": [[128, 130], ["networks_basic.Dist2LogitLayer.model.forward", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward"], ["", "def", "forward", "(", "self", ",", "d0", ",", "d1", ",", "eps", "=", "0.1", ")", ":", "\n", "        ", "return", "self", ".", "model", ".", "forward", "(", "torch", ".", "cat", "(", "(", "d0", ",", "d1", ",", "d0", "-", "d1", ",", "d0", "/", "(", "d1", "+", "eps", ")", ",", "d1", "/", "(", "d0", "+", "eps", ")", ")", ",", "dim", "=", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.BCERankingLoss.__init__": [[132, 137], ["torch.Module.__init__", "networks_basic.Dist2LogitLayer", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss", "torch.nn.BCELoss"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "chn_mid", "=", "32", ")", ":", "\n", "        ", "super", "(", "BCERankingLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "net", "=", "Dist2LogitLayer", "(", "chn_mid", "=", "chn_mid", ")", "\n", "# self.parameters = list(self.net.parameters())", "\n", "self", ".", "loss", "=", "torch", ".", "nn", ".", "BCELoss", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.BCERankingLoss.forward": [[138, 142], ["networks_basic.BCERankingLoss.net.forward", "networks_basic.BCERankingLoss.loss"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward"], ["", "def", "forward", "(", "self", ",", "d0", ",", "d1", ",", "judge", ")", ":", "\n", "        ", "per", "=", "(", "judge", "+", "1.", ")", "/", "2.", "\n", "self", ".", "logit", "=", "self", ".", "net", ".", "forward", "(", "d0", ",", "d1", ")", "\n", "return", "self", ".", "loss", "(", "self", ".", "logit", ",", "per", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.FakeNet.__init__": [[145, 149], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "use_gpu", "=", "True", ",", "colorspace", "=", "'Lab'", ")", ":", "\n", "        ", "super", "(", "FakeNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "self", ".", "colorspace", "=", "colorspace", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.L2.forward": [[152, 166], ["in0.size", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "in0.size", "modules.l2().astype", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "ret_var.cuda.cuda.cuda", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "modules.l2", "modules.tensor2np", "modules.tensor2np", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "modules.tensor2tensorlab", "modules.tensor2tensorlab", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean().view", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.l2", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2np", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2np", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2tensorlab", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2tensorlab"], ["    ", "def", "forward", "(", "self", ",", "in0", ",", "in1", ",", "retPerLayer", "=", "None", ")", ":", "\n", "        ", "assert", "(", "in0", ".", "size", "(", ")", "[", "0", "]", "==", "1", ")", "# currently only supports batchSize 1", "\n", "\n", "if", "(", "self", ".", "colorspace", "==", "'RGB'", ")", ":", "\n", "            ", "(", "N", ",", "C", ",", "X", ",", "Y", ")", "=", "in0", ".", "size", "(", ")", "\n", "value", "=", "torch", ".", "mean", "(", "torch", ".", "mean", "(", "torch", ".", "mean", "(", "(", "in0", "-", "in1", ")", "**", "2", ",", "dim", "=", "1", ")", ".", "view", "(", "N", ",", "1", ",", "X", ",", "Y", ")", ",", "dim", "=", "2", ")", ".", "view", "(", "N", ",", "1", ",", "1", ",", "Y", ")", ",", "dim", "=", "3", ")", ".", "view", "(", "N", ")", "\n", "return", "value", "\n", "", "elif", "(", "self", ".", "colorspace", "==", "'Lab'", ")", ":", "\n", "            ", "value", "=", "util", ".", "l2", "(", "util", ".", "tensor2np", "(", "util", ".", "tensor2tensorlab", "(", "in0", ".", "data", ",", "to_norm", "=", "False", ")", ")", ",", "\n", "util", ".", "tensor2np", "(", "util", ".", "tensor2tensorlab", "(", "in1", ".", "data", ",", "to_norm", "=", "False", ")", ")", ",", "range", "=", "100.", ")", ".", "astype", "(", "'float'", ")", "\n", "ret_var", "=", "Variable", "(", "torch", ".", "Tensor", "(", "(", "value", ",", ")", ")", ")", "\n", "if", "(", "self", ".", "use_gpu", ")", ":", "\n", "                ", "ret_var", "=", "ret_var", ".", "cuda", "(", ")", "\n", "", "return", "ret_var", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.DSSIM.forward": [[169, 181], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "modules.dssim().astype", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "ret_var.cuda.cuda.cuda", "in0.size", "modules.dssim().astype", "modules.dssim", "modules.dssim", "modules.tensor2im", "modules.tensor2im", "modules.tensor2np", "modules.tensor2np", "modules.tensor2tensorlab", "modules.tensor2tensorlab"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.dssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.dssim", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2np", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2np", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2tensorlab", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2tensorlab"], ["    ", "def", "forward", "(", "self", ",", "in0", ",", "in1", ",", "retPerLayer", "=", "None", ")", ":", "\n", "        ", "assert", "(", "in0", ".", "size", "(", ")", "[", "0", "]", "==", "1", ")", "# currently only supports batchSize 1", "\n", "\n", "if", "(", "self", ".", "colorspace", "==", "'RGB'", ")", ":", "\n", "            ", "value", "=", "util", ".", "dssim", "(", "1.", "*", "util", ".", "tensor2im", "(", "in0", ".", "data", ")", ",", "1.", "*", "util", ".", "tensor2im", "(", "in1", ".", "data", ")", ",", "range", "=", "255.", ")", ".", "astype", "(", "'float'", ")", "\n", "", "elif", "(", "self", ".", "colorspace", "==", "'Lab'", ")", ":", "\n", "            ", "value", "=", "util", ".", "dssim", "(", "util", ".", "tensor2np", "(", "util", ".", "tensor2tensorlab", "(", "in0", ".", "data", ",", "to_norm", "=", "False", ")", ")", ",", "\n", "util", ".", "tensor2np", "(", "util", ".", "tensor2tensorlab", "(", "in1", ".", "data", ",", "to_norm", "=", "False", ")", ")", ",", "range", "=", "100.", ")", ".", "astype", "(", "'float'", ")", "\n", "", "ret_var", "=", "Variable", "(", "torch", ".", "Tensor", "(", "(", "value", ",", ")", ")", ")", "\n", "if", "(", "self", ".", "use_gpu", ")", ":", "\n", "            ", "ret_var", "=", "ret_var", ".", "cuda", "(", ")", "\n", "", "return", "ret_var", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.spatial_average": [[17, 19], ["in_tens.mean"], "function", ["None"], ["def", "spatial_average", "(", "in_tens", ",", "keepdim", "=", "True", ")", ":", "\n", "    ", "return", "in_tens", ".", "mean", "(", "[", "2", ",", "3", "]", ",", "keepdim", "=", "keepdim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.upsample": [[20, 25], ["torch.Upsample"], "function", ["None"], ["", "def", "upsample", "(", "in_tens", ",", "out_H", "=", "64", ")", ":", "# assumes scale factor is same for H and W", "\n", "    ", "in_H", "=", "in_tens", ".", "shape", "[", "2", "]", "\n", "scale_factor", "=", "1.", "*", "out_H", "/", "in_H", "\n", "\n", "return", "nn", ".", "Upsample", "(", "scale_factor", "=", "scale_factor", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "False", ")", "(", "in_tens", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.print_network": [[182, 188], ["net.parameters", "print", "print", "param.numel"], "function", ["None"], ["", "", "def", "print_network", "(", "net", ")", ":", "\n", "    ", "num_params", "=", "0", "\n", "for", "param", "in", "net", ".", "parameters", "(", ")", ":", "\n", "        ", "num_params", "+=", "param", ".", "numel", "(", ")", "\n", "", "print", "(", "'Network'", ",", "net", ")", "\n", "print", "(", "'Total number of parameters: %d'", "%", "num_params", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.name": [[25, 27], ["None"], "methods", ["None"], ["    ", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "model_name", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.initialize": [[28, 108], ["base_model.BaseModel.initialize", "list", "networks_basic.PNetLin", "dist_model.DistModel.net.parameters", "networks_basic.BCERankingLoss", "list", "torch.optim.Adam", "dist_model.DistModel.net.eval", "dist_model.DistModel.net.to", "torch.nn.DataParallel", "print", "networks_basic.print_network", "print", "os.path.abspath", "print", "dist_model.DistModel.net.load_state_dict", "networks_basic.PNetLin", "dist_model.DistModel.rankLoss.net.parameters", "dist_model.DistModel.rankLoss.to", "os.path.join", "torch.load", "networks_basic.L2", "inspect.getfile", "networks_basic.DSSIM", "ValueError"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.initialize", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.networks_basic.print_network"], ["", "def", "initialize", "(", "self", ",", "model", "=", "'net-lin'", ",", "net", "=", "'alex'", ",", "colorspace", "=", "'Lab'", ",", "pnet_rand", "=", "False", ",", "pnet_tune", "=", "False", ",", "model_path", "=", "None", ",", "\n", "use_gpu", "=", "True", ",", "printNet", "=", "False", ",", "spatial", "=", "False", ",", "\n", "is_train", "=", "False", ",", "lr", "=", ".0001", ",", "beta1", "=", "0.5", ",", "version", "=", "'0.1'", ",", "gpu_ids", "=", "[", "0", "]", ")", ":", "\n", "        ", "'''\n        INPUTS\n            model - ['net-lin'] for linearly calibrated network\n                    ['net'] for off-the-shelf network\n                    ['L2'] for L2 distance in Lab colorspace\n                    ['SSIM'] for ssim in RGB colorspace\n            net - ['squeeze','alex','vgg']\n            model_path - if None, will look in weights/[NET_NAME].pth\n            colorspace - ['Lab','RGB'] colorspace to use for L2 and SSIM\n            use_gpu - bool - whether or not to use a GPU\n            printNet - bool - whether or not to print network architecture out\n            spatial - bool - whether to output an array containing varying distances across spatial dimensions\n            spatial_shape - if given, output spatial shape. if None then spatial shape is determined automatically via spatial_factor (see below).\n            spatial_factor - if given, specifies upsampling factor relative to the largest spatial extent of a convolutional layer. if None then resized to size of input images.\n            spatial_order - spline order of filter for upsampling in spatial mode, by default 1 (bilinear).\n            is_train - bool - [True] for training mode\n            lr - float - initial learning rate\n            beta1 - float - initial momentum term for adam\n            version - 0.1 for latest, 0.0 was original (with a bug)\n            gpu_ids - int array - [0] by default, gpus to use\n        '''", "\n", "BaseModel", ".", "initialize", "(", "self", ",", "use_gpu", "=", "use_gpu", ",", "gpu_ids", "=", "gpu_ids", ")", "\n", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "net", "=", "net", "\n", "self", ".", "is_train", "=", "is_train", "\n", "self", ".", "spatial", "=", "spatial", "\n", "self", ".", "gpu_ids", "=", "gpu_ids", "\n", "self", ".", "model_name", "=", "'%s [%s]'", "%", "(", "model", ",", "net", ")", "\n", "\n", "if", "(", "self", ".", "model", "==", "'net-lin'", ")", ":", "# pretrained net + linear layer", "\n", "            ", "self", ".", "net", "=", "networks", ".", "PNetLin", "(", "pnet_rand", "=", "pnet_rand", ",", "pnet_tune", "=", "pnet_tune", ",", "pnet_type", "=", "net", ",", "\n", "use_dropout", "=", "True", ",", "spatial", "=", "spatial", ",", "version", "=", "version", ",", "lpips", "=", "True", ")", "\n", "kw", "=", "{", "}", "\n", "if", "not", "use_gpu", ":", "\n", "                ", "kw", "[", "'map_location'", "]", "=", "'cpu'", "\n", "", "if", "(", "model_path", "is", "None", ")", ":", "\n", "                ", "import", "inspect", "\n", "model_path", "=", "os", ".", "path", ".", "abspath", "(", "os", ".", "path", ".", "join", "(", "inspect", ".", "getfile", "(", "self", ".", "initialize", ")", ",", "'..'", ",", "'weights/v%s/%s.pth'", "%", "(", "version", ",", "net", ")", ")", ")", "\n", "\n", "", "if", "(", "not", "is_train", ")", ":", "\n", "                ", "print", "(", "'Loading model from: %s'", "%", "model_path", ")", "\n", "self", ".", "net", ".", "load_state_dict", "(", "torch", ".", "load", "(", "model_path", ",", "**", "kw", ")", ",", "strict", "=", "False", ")", "\n", "\n", "", "", "elif", "(", "self", ".", "model", "==", "'net'", ")", ":", "# pretrained network", "\n", "            ", "self", ".", "net", "=", "networks", ".", "PNetLin", "(", "pnet_rand", "=", "pnet_rand", ",", "pnet_type", "=", "net", ",", "lpips", "=", "False", ")", "\n", "", "elif", "(", "self", ".", "model", "in", "[", "'L2'", ",", "'l2'", "]", ")", ":", "\n", "            ", "self", ".", "net", "=", "networks", ".", "L2", "(", "use_gpu", "=", "use_gpu", ",", "colorspace", "=", "colorspace", ")", "# not really a network, only for testing", "\n", "self", ".", "model_name", "=", "'L2'", "\n", "", "elif", "(", "self", ".", "model", "in", "[", "'DSSIM'", ",", "'dssim'", ",", "'SSIM'", ",", "'ssim'", "]", ")", ":", "\n", "            ", "self", ".", "net", "=", "networks", ".", "DSSIM", "(", "use_gpu", "=", "use_gpu", ",", "colorspace", "=", "colorspace", ")", "\n", "self", ".", "model_name", "=", "'SSIM'", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Model [%s] not recognized.\"", "%", "self", ".", "model", ")", "\n", "\n", "", "self", ".", "parameters", "=", "list", "(", "self", ".", "net", ".", "parameters", "(", ")", ")", "\n", "\n", "if", "self", ".", "is_train", ":", "# training mode", "\n", "# extra network on top to go from distances (d0,d1) => predicted human judgment (h*)", "\n", "            ", "self", ".", "rankLoss", "=", "networks", ".", "BCERankingLoss", "(", ")", "\n", "self", ".", "parameters", "+=", "list", "(", "self", ".", "rankLoss", ".", "net", ".", "parameters", "(", ")", ")", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "old_lr", "=", "lr", "\n", "self", ".", "optimizer_net", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "parameters", ",", "lr", "=", "lr", ",", "betas", "=", "(", "beta1", ",", "0.999", ")", ")", "\n", "", "else", ":", "# test mode", "\n", "            ", "self", ".", "net", ".", "eval", "(", ")", "\n", "\n", "", "if", "(", "use_gpu", ")", ":", "\n", "            ", "self", ".", "net", ".", "to", "(", "gpu_ids", "[", "0", "]", ")", "\n", "self", ".", "net", "=", "torch", ".", "nn", ".", "DataParallel", "(", "self", ".", "net", ",", "device_ids", "=", "gpu_ids", ")", "\n", "if", "(", "self", ".", "is_train", ")", ":", "\n", "                ", "self", ".", "rankLoss", "=", "self", ".", "rankLoss", ".", "to", "(", "device", "=", "gpu_ids", "[", "0", "]", ")", "# just put this on GPU0", "\n", "\n", "", "", "if", "(", "printNet", ")", ":", "\n", "            ", "print", "(", "'---------- Networks initialized -------------'", ")", "\n", "networks", ".", "print_network", "(", "self", ".", "net", ")", "\n", "print", "(", "'-----------------------------------------------'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.forward": [[109, 118], ["dist_model.DistModel.net.forward"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward"], ["", "", "def", "forward", "(", "self", ",", "in0", ",", "in1", ",", "retPerLayer", "=", "False", ")", ":", "\n", "        ", "''' Function computes the distance between image patches in0 and in1\n        INPUTS\n            in0, in1 - torch.Tensor object of shape Nx3xXxY - image patch scaled to [-1,1]\n        OUTPUT\n            computed distances between in0 and in1\n        '''", "\n", "\n", "return", "self", ".", "net", ".", "forward", "(", "in0", ",", "in1", ",", "retPerLayer", "=", "retPerLayer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.optimize_parameters": [[120, 126], ["dist_model.DistModel.forward_train", "dist_model.DistModel.optimizer_net.zero_grad", "dist_model.DistModel.backward_train", "dist_model.DistModel.optimizer_net.step", "dist_model.DistModel.clamp_weights"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.forward_train", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.backward_train", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.clamp_weights"], ["", "def", "optimize_parameters", "(", "self", ")", ":", "\n", "        ", "self", ".", "forward_train", "(", ")", "\n", "self", ".", "optimizer_net", ".", "zero_grad", "(", ")", "\n", "self", ".", "backward_train", "(", ")", "\n", "self", ".", "optimizer_net", ".", "step", "(", ")", "\n", "self", ".", "clamp_weights", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.clamp_weights": [[127, 131], ["dist_model.DistModel.net.modules", "hasattr", "torch.clamp"], "methods", ["None"], ["", "def", "clamp_weights", "(", "self", ")", ":", "\n", "        ", "for", "module", "in", "self", ".", "net", ".", "modules", "(", ")", ":", "\n", "            ", "if", "(", "hasattr", "(", "module", ",", "'weight'", ")", "and", "module", ".", "kernel_size", "==", "(", "1", ",", "1", ")", ")", ":", "\n", "                ", "module", ".", "weight", ".", "data", "=", "torch", ".", "clamp", "(", "module", ".", "weight", ".", "data", ",", "min", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.set_input": [[132, 147], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "dist_model.DistModel.input_ref.to", "dist_model.DistModel.input_p0.to", "dist_model.DistModel.input_p1.to", "dist_model.DistModel.input_judge.to"], "methods", ["None"], ["", "", "", "def", "set_input", "(", "self", ",", "data", ")", ":", "\n", "        ", "self", ".", "input_ref", "=", "data", "[", "'ref'", "]", "\n", "self", ".", "input_p0", "=", "data", "[", "'p0'", "]", "\n", "self", ".", "input_p1", "=", "data", "[", "'p1'", "]", "\n", "self", ".", "input_judge", "=", "data", "[", "'judge'", "]", "\n", "\n", "if", "(", "self", ".", "use_gpu", ")", ":", "\n", "            ", "self", ".", "input_ref", "=", "self", ".", "input_ref", ".", "to", "(", "device", "=", "self", ".", "gpu_ids", "[", "0", "]", ")", "\n", "self", ".", "input_p0", "=", "self", ".", "input_p0", ".", "to", "(", "device", "=", "self", ".", "gpu_ids", "[", "0", "]", ")", "\n", "self", ".", "input_p1", "=", "self", ".", "input_p1", ".", "to", "(", "device", "=", "self", ".", "gpu_ids", "[", "0", "]", ")", "\n", "self", ".", "input_judge", "=", "self", ".", "input_judge", ".", "to", "(", "device", "=", "self", ".", "gpu_ids", "[", "0", "]", ")", "\n", "\n", "", "self", ".", "var_ref", "=", "Variable", "(", "self", ".", "input_ref", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "var_p0", "=", "Variable", "(", "self", ".", "input_p0", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "var_p1", "=", "Variable", "(", "self", ".", "input_p1", ",", "requires_grad", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.forward_train": [[148, 161], ["dist_model.DistModel.forward", "dist_model.DistModel.forward", "dist_model.DistModel.compute_accuracy", "torch.autograd.Variable().view", "dist_model.DistModel.rankLoss.forward", "dist_model.DistModel.d0.size", "torch.autograd.Variable"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.compute_accuracy", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward"], ["", "def", "forward_train", "(", "self", ")", ":", "# run forward pass", "\n", "# print(self.net.module.scaling_layer.shift)", "\n", "# print(torch.norm(self.net.module.net.slice1[0].weight).item(), torch.norm(self.net.module.lin0.model[1].weight).item())", "\n", "\n", "        ", "self", ".", "d0", "=", "self", ".", "forward", "(", "self", ".", "var_ref", ",", "self", ".", "var_p0", ")", "\n", "self", ".", "d1", "=", "self", ".", "forward", "(", "self", ".", "var_ref", ",", "self", ".", "var_p1", ")", "\n", "self", ".", "acc_r", "=", "self", ".", "compute_accuracy", "(", "self", ".", "d0", ",", "self", ".", "d1", ",", "self", ".", "input_judge", ")", "\n", "\n", "self", ".", "var_judge", "=", "Variable", "(", "1.", "*", "self", ".", "input_judge", ")", ".", "view", "(", "self", ".", "d0", ".", "size", "(", ")", ")", "\n", "\n", "self", ".", "loss_total", "=", "self", ".", "rankLoss", ".", "forward", "(", "self", ".", "d0", ",", "self", ".", "d1", ",", "self", ".", "var_judge", "*", "2.", "-", "1.", ")", "\n", "\n", "return", "self", ".", "loss_total", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.backward_train": [[162, 164], ["torch.mean().backward", "torch.mean"], "methods", ["None"], ["", "def", "backward_train", "(", "self", ")", ":", "\n", "        ", "torch", ".", "mean", "(", "self", ".", "loss_total", ")", ".", "backward", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.compute_accuracy": [[165, 170], ["judge.cpu().numpy().flatten", "judge.cpu().numpy", "judge.cpu"], "methods", ["None"], ["", "def", "compute_accuracy", "(", "self", ",", "d0", ",", "d1", ",", "judge", ")", ":", "\n", "        ", "''' d0, d1 are Variables, judge is a Tensor '''", "\n", "d1_lt_d0", "=", "(", "d1", "<", "d0", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "judge_per", "=", "judge", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", "\n", "return", "d1_lt_d0", "*", "judge_per", "+", "(", "1", "-", "d1_lt_d0", ")", "*", "(", "1", "-", "judge_per", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.get_current_errors": [[171, 179], ["collections.OrderedDict", "collections.OrderedDict.keys", "numpy.mean", "dist_model.DistModel.loss_total.data.cpu().numpy", "dist_model.DistModel.loss_total.data.cpu"], "methods", ["None"], ["", "def", "get_current_errors", "(", "self", ")", ":", "\n", "        ", "retDict", "=", "OrderedDict", "(", "[", "(", "'loss_total'", ",", "self", ".", "loss_total", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ",", "\n", "(", "'acc_r'", ",", "self", ".", "acc_r", ")", "]", ")", "\n", "\n", "for", "key", "in", "retDict", ".", "keys", "(", ")", ":", "\n", "            ", "retDict", "[", "key", "]", "=", "np", ".", "mean", "(", "retDict", "[", "key", "]", ")", "\n", "\n", "", "return", "retDict", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.get_current_visuals": [[180, 194], ["models.tensor2im", "models.tensor2im", "models.tensor2im", "scipy.ndimage.zoom", "scipy.ndimage.zoom", "scipy.ndimage.zoom", "collections.OrderedDict", "dist_model.DistModel.var_ref.data.size"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im"], ["", "def", "get_current_visuals", "(", "self", ")", ":", "\n", "        ", "zoom_factor", "=", "256", "/", "self", ".", "var_ref", ".", "data", ".", "size", "(", ")", "[", "2", "]", "\n", "\n", "ref_img", "=", "util", ".", "tensor2im", "(", "self", ".", "var_ref", ".", "data", ")", "\n", "p0_img", "=", "util", ".", "tensor2im", "(", "self", ".", "var_p0", ".", "data", ")", "\n", "p1_img", "=", "util", ".", "tensor2im", "(", "self", ".", "var_p1", ".", "data", ")", "\n", "\n", "ref_img_vis", "=", "zoom", "(", "ref_img", ",", "[", "zoom_factor", ",", "zoom_factor", ",", "1", "]", ",", "order", "=", "0", ")", "\n", "p0_img_vis", "=", "zoom", "(", "p0_img", ",", "[", "zoom_factor", ",", "zoom_factor", ",", "1", "]", ",", "order", "=", "0", ")", "\n", "p1_img_vis", "=", "zoom", "(", "p1_img", ",", "[", "zoom_factor", ",", "zoom_factor", ",", "1", "]", ",", "order", "=", "0", ")", "\n", "\n", "return", "OrderedDict", "(", "[", "(", "'ref'", ",", "ref_img_vis", ")", ",", "\n", "(", "'p0'", ",", "p0_img_vis", ")", ",", "\n", "(", "'p1'", ",", "p1_img_vis", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.save": [[195, 201], ["dist_model.DistModel.save_network", "dist_model.DistModel.save_network", "dist_model.DistModel.save_network"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save_network", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save_network"], ["", "def", "save", "(", "self", ",", "path", ",", "label", ")", ":", "\n", "        ", "if", "(", "self", ".", "use_gpu", ")", ":", "\n", "            ", "self", ".", "save_network", "(", "self", ".", "net", ".", "module", ",", "path", ",", "''", ",", "label", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "save_network", "(", "self", ".", "net", ",", "path", ",", "''", ",", "label", ")", "\n", "", "self", ".", "save_network", "(", "self", ".", "rankLoss", ".", "net", ",", "path", ",", "'rank'", ",", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.DistModel.update_learning_rate": [[202, 211], ["print"], "methods", ["None"], ["", "def", "update_learning_rate", "(", "self", ",", "nepoch_decay", ")", ":", "\n", "        ", "lrd", "=", "self", ".", "lr", "/", "nepoch_decay", "\n", "lr", "=", "self", ".", "old_lr", "-", "lrd", "\n", "\n", "for", "param_group", "in", "self", ".", "optimizer_net", ".", "param_groups", ":", "\n", "            ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n", "", "print", "(", "'update lr [%s] decay: %f -> %f'", "%", "(", "type", ",", "self", ".", "old_lr", ",", "lr", ")", ")", "\n", "self", ".", "old_lr", "=", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.score_2afc_dataset": [[212, 246], ["tqdm.tqdm", "numpy.array", "numpy.array", "numpy.array", "data_loader.load_data", "func().data.cpu().numpy().flatten().tolist", "func().data.cpu().numpy().flatten().tolist", "data[].cpu().numpy().flatten().tolist", "numpy.mean", "dict", "func().data.cpu().numpy().flatten", "func().data.cpu().numpy().flatten", "data[].cpu().numpy().flatten", "func().data.cpu().numpy", "func().data.cpu().numpy", "data[].cpu().numpy", "func().data.cpu", "func().data.cpu", "data[].cpu", "func", "func"], "function", ["None"], ["", "", "def", "score_2afc_dataset", "(", "data_loader", ",", "func", ",", "name", "=", "''", ")", ":", "\n", "    ", "''' Function computes Two Alternative Forced Choice (2AFC) score using\n        distance function 'func' in dataset 'data_loader'\n    INPUTS\n        data_loader - CustomDatasetDataLoader object - contains a TwoAFCDataset inside\n        func - callable distance function - calling d=func(in0,in1) should take 2\n            pytorch tensors with shape Nx3xXxY, and return numpy array of length N\n    OUTPUTS\n        [0] - 2AFC score in [0,1], fraction of time func agrees with human evaluators\n        [1] - dictionary with following elements\n            d0s,d1s - N arrays containing distances between reference patch to perturbed patches \n            gts - N array in [0,1], preferred patch selected by human evaluators\n                (closer to \"0\" for left patch p0, \"1\" for right patch p1,\n                \"0.6\" means 60pct people preferred right patch, 40pct preferred left)\n            scores - N array in [0,1], corresponding to what percentage function agreed with humans\n    CONSTS\n        N - number of test triplets in data_loader\n    '''", "\n", "\n", "d0s", "=", "[", "]", "\n", "d1s", "=", "[", "]", "\n", "gts", "=", "[", "]", "\n", "\n", "for", "data", "in", "tqdm", "(", "data_loader", ".", "load_data", "(", ")", ",", "desc", "=", "name", ")", ":", "\n", "        ", "d0s", "+=", "func", "(", "data", "[", "'ref'", "]", ",", "data", "[", "'p0'", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "d1s", "+=", "func", "(", "data", "[", "'ref'", "]", ",", "data", "[", "'p1'", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "gts", "+=", "data", "[", "'judge'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "", "d0s", "=", "np", ".", "array", "(", "d0s", ")", "\n", "d1s", "=", "np", ".", "array", "(", "d1s", ")", "\n", "gts", "=", "np", ".", "array", "(", "gts", ")", "\n", "scores", "=", "(", "d0s", "<", "d1s", ")", "*", "(", "1.", "-", "gts", ")", "+", "(", "d1s", "<", "d0s", ")", "*", "gts", "+", "(", "d1s", "==", "d0s", ")", "*", ".5", "\n", "\n", "return", "(", "np", ".", "mean", "(", "scores", ")", ",", "dict", "(", "d0s", "=", "d0s", ",", "d1s", "=", "d1s", ",", "gts", "=", "gts", ",", "scores", "=", "scores", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.dist_model.score_jnd_dataset": [[247, 285], ["tqdm.tqdm", "numpy.array", "numpy.array", "numpy.argsort", "numpy.cumsum", "numpy.cumsum", "models.voc_ap", "data_loader.load_data", "func().data.cpu().numpy().tolist", "data[].cpu().numpy().flatten().tolist", "numpy.sum", "dict", "func().data.cpu().numpy", "data[].cpu().numpy().flatten", "func().data.cpu", "data[].cpu().numpy", "data[].cpu", "func"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.voc_ap"], ["", "def", "score_jnd_dataset", "(", "data_loader", ",", "func", ",", "name", "=", "''", ")", ":", "\n", "    ", "''' Function computes JND score using distance function 'func' in dataset 'data_loader'\n    INPUTS\n        data_loader - CustomDatasetDataLoader object - contains a JNDDataset inside\n        func - callable distance function - calling d=func(in0,in1) should take 2\n            pytorch tensors with shape Nx3xXxY, and return pytorch array of length N\n    OUTPUTS\n        [0] - JND score in [0,1], mAP score (area under precision-recall curve)\n        [1] - dictionary with following elements\n            ds - N array containing distances between two patches shown to human evaluator\n            sames - N array containing fraction of people who thought the two patches were identical\n    CONSTS\n        N - number of test triplets in data_loader\n    '''", "\n", "\n", "ds", "=", "[", "]", "\n", "gts", "=", "[", "]", "\n", "\n", "for", "data", "in", "tqdm", "(", "data_loader", ".", "load_data", "(", ")", ",", "desc", "=", "name", ")", ":", "\n", "        ", "ds", "+=", "func", "(", "data", "[", "'p0'", "]", ",", "data", "[", "'p1'", "]", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "tolist", "(", ")", "\n", "gts", "+=", "data", "[", "'same'", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "flatten", "(", ")", ".", "tolist", "(", ")", "\n", "\n", "", "sames", "=", "np", ".", "array", "(", "gts", ")", "\n", "ds", "=", "np", ".", "array", "(", "ds", ")", "\n", "\n", "sorted_inds", "=", "np", ".", "argsort", "(", "ds", ")", "\n", "ds_sorted", "=", "ds", "[", "sorted_inds", "]", "\n", "sames_sorted", "=", "sames", "[", "sorted_inds", "]", "\n", "\n", "TPs", "=", "np", ".", "cumsum", "(", "sames_sorted", ")", "\n", "FPs", "=", "np", ".", "cumsum", "(", "1", "-", "sames_sorted", ")", "\n", "FNs", "=", "np", ".", "sum", "(", "sames_sorted", ")", "-", "TPs", "\n", "\n", "precs", "=", "TPs", "/", "(", "TPs", "+", "FPs", ")", "\n", "recs", "=", "TPs", "/", "(", "TPs", "+", "FNs", ")", "\n", "score", "=", "util", ".", "voc_ap", "(", "recs", ",", "precs", ")", "\n", "\n", "return", "(", "score", ",", "dict", "(", "ds", "=", "ds", ",", "sames", "=", "sames", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.filters.GaussianFilter.__init__": [[6, 31], ["torch.nn.Module.__init__", "torch.arange", "torch.arange.repeat().view", "torch.arange.repeat().view.t", "torch.stack().float", "torch.exp", "gaussian_kernel.repeat.repeat.view", "gaussian_kernel.repeat.repeat.repeat", "torch.nn.Conv2d", "torch.sum", "torch.arange.repeat", "torch.stack", "torch.sum"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "kernel_size", "=", "13", ",", "stride", "=", "1", ",", "padding", "=", "6", ")", ":", "\n", "        ", "super", "(", "GaussianFilter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# initialize guassian kernel", "\n", "mean", "=", "(", "kernel_size", "-", "1", ")", "/", "2.0", "\n", "variance", "=", "(", "(", "kernel_size", "-", "1", ")", "/", "6.0", ")", "**", "2.0", "\n", "# Create a x, y coordinate grid of shape (kernel_size, kernel_size, 2)", "\n", "x_coord", "=", "torch", ".", "arange", "(", "kernel_size", ")", "\n", "x_grid", "=", "x_coord", ".", "repeat", "(", "kernel_size", ")", ".", "view", "(", "kernel_size", ",", "kernel_size", ")", "\n", "y_grid", "=", "x_grid", ".", "t", "(", ")", "\n", "xy_grid", "=", "torch", ".", "stack", "(", "[", "x_grid", ",", "y_grid", "]", ",", "dim", "=", "-", "1", ")", ".", "float", "(", ")", "\n", "\n", "# Calculate the 2-dimensional gaussian kernel", "\n", "gaussian_kernel", "=", "torch", ".", "exp", "(", "-", "torch", ".", "sum", "(", "(", "xy_grid", "-", "mean", ")", "**", "2.", ",", "dim", "=", "-", "1", ")", "/", "(", "2", "*", "variance", ")", ")", "\n", "\n", "# Make sure sum of values in gaussian kernel equals 1.", "\n", "gaussian_kernel", "=", "gaussian_kernel", "/", "torch", ".", "sum", "(", "gaussian_kernel", ")", "\n", "\n", "# Reshape to 2d depthwise convolutional weight", "\n", "gaussian_kernel", "=", "gaussian_kernel", ".", "view", "(", "1", ",", "1", ",", "kernel_size", ",", "kernel_size", ")", "\n", "gaussian_kernel", "=", "gaussian_kernel", ".", "repeat", "(", "3", ",", "1", ",", "1", ",", "1", ")", "\n", "\n", "# create gaussian filter as convolutional layer", "\n", "self", ".", "gaussian_filter", "=", "nn", ".", "Conv2d", "(", "3", ",", "3", ",", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "padding", ",", "groups", "=", "3", ",", "bias", "=", "False", ")", "\n", "self", ".", "gaussian_filter", ".", "weight", ".", "data", "=", "gaussian_kernel", "\n", "self", ".", "gaussian_filter", ".", "weight", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.filters.GaussianFilter.forward": [[32, 34], ["filters.GaussianFilter.gaussian_filter"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.gaussian_filter"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "gaussian_filter", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.filters.FilterLow.__init__": [[37, 48], ["torch.nn.Module.__init__", "int", "filters.GaussianFilter", "torch.nn.AvgPool2d"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recursions", "=", "1", ",", "kernel_size", "=", "9", ",", "stride", "=", "1", ",", "padding", "=", "True", ",", "include_pad", "=", "True", ",", "gaussian", "=", "False", ")", ":", "\n", "        ", "super", "(", "FilterLow", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "padding", ":", "\n", "            ", "pad", "=", "int", "(", "(", "kernel_size", "-", "1", ")", "/", "2", ")", "\n", "", "else", ":", "\n", "            ", "pad", "=", "0", "\n", "", "if", "gaussian", ":", "\n", "            ", "self", ".", "filter", "=", "GaussianFilter", "(", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "pad", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "filter", "=", "nn", ".", "AvgPool2d", "(", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "padding", "=", "pad", ",", "count_include_pad", "=", "include_pad", ")", "\n", "", "self", ".", "recursions", "=", "recursions", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.filters.FilterLow.forward": [[49, 53], ["range", "filters.FilterLow.filter"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "self", ".", "recursions", ")", ":", "\n", "            ", "img", "=", "self", ".", "filter", "(", "img", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.filters.FilterHigh.__init__": [[56, 62], ["torch.nn.Module.__init__", "filters.FilterLow"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "recursions", "=", "1", ",", "kernel_size", "=", "9", ",", "stride", "=", "1", ",", "include_pad", "=", "True", ",", "normalize", "=", "True", ",", "gaussian", "=", "False", ")", ":", "\n", "        ", "super", "(", "FilterHigh", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "filter_low", "=", "FilterLow", "(", "recursions", "=", "1", ",", "kernel_size", "=", "kernel_size", ",", "stride", "=", "stride", ",", "include_pad", "=", "include_pad", ",", "\n", "gaussian", "=", "gaussian", ")", "\n", "self", ".", "recursions", "=", "recursions", "\n", "self", ".", "normalize", "=", "normalize", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.filters.FilterHigh.forward": [[63, 72], ["range", "filters.FilterHigh.filter_low", "filters.FilterHigh.filter_low"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "img", ")", ":", "\n", "        ", "if", "self", ".", "recursions", ">", "1", ":", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "recursions", "-", "1", ")", ":", "\n", "                ", "img", "=", "self", ".", "filter_low", "(", "img", ")", "\n", "", "", "img", "=", "img", "-", "self", ".", "filter_low", "(", "img", ")", "\n", "if", "self", ".", "normalize", ":", "\n", "            ", "return", "0.5", "+", "img", "*", "0.5", "\n", "", "else", ":", "\n", "            ", "return", "img", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.squeezenet.__init__": [[7, 35], ["super().__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "range", "range", "range", "range", "range", "range", "range", "torchvision.models.squeezenet1_1", "pretrained_networks.squeezenet.slice1.add_module", "pretrained_networks.squeezenet.slice2.add_module", "pretrained_networks.squeezenet.slice3.add_module", "pretrained_networks.squeezenet.slice4.add_module", "pretrained_networks.squeezenet.slice5.add_module", "pretrained_networks.squeezenet.slice6.add_module", "pretrained_networks.squeezenet.slice7.add_module", "pretrained_networks.squeezenet.parameters", "str", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "requires_grad", "=", "False", ",", "pretrained", "=", "True", ")", ":", "\n", "        ", "super", "(", "squeezenet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "pretrained_features", "=", "tv", ".", "squeezenet1_1", "(", "pretrained", "=", "pretrained", ")", ".", "features", "\n", "self", ".", "slice1", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice2", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice3", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice4", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice5", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice6", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice7", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "N_slices", "=", "7", "\n", "for", "x", "in", "range", "(", "2", ")", ":", "\n", "            ", "self", ".", "slice1", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "2", ",", "5", ")", ":", "\n", "            ", "self", ".", "slice2", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "5", ",", "8", ")", ":", "\n", "            ", "self", ".", "slice3", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "8", ",", "10", ")", ":", "\n", "            ", "self", ".", "slice4", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "10", ",", "11", ")", ":", "\n", "            ", "self", ".", "slice5", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "11", ",", "12", ")", ":", "\n", "            ", "self", ".", "slice6", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "12", ",", "13", ")", ":", "\n", "            ", "self", ".", "slice7", ".", "add_module", "(", "str", "(", "x", ")", ",", "pretrained_features", "[", "x", "]", ")", "\n", "", "if", "not", "requires_grad", ":", "\n", "            ", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.squeezenet.forward": [[36, 55], ["pretrained_networks.squeezenet.slice1", "pretrained_networks.squeezenet.slice2", "pretrained_networks.squeezenet.slice3", "pretrained_networks.squeezenet.slice4", "pretrained_networks.squeezenet.slice5", "pretrained_networks.squeezenet.slice6", "pretrained_networks.squeezenet.slice7", "collections.namedtuple", "collections.namedtuple."], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "h", "=", "self", ".", "slice1", "(", "X", ")", "\n", "h_relu1", "=", "h", "\n", "h", "=", "self", ".", "slice2", "(", "h", ")", "\n", "h_relu2", "=", "h", "\n", "h", "=", "self", ".", "slice3", "(", "h", ")", "\n", "h_relu3", "=", "h", "\n", "h", "=", "self", ".", "slice4", "(", "h", ")", "\n", "h_relu4", "=", "h", "\n", "h", "=", "self", ".", "slice5", "(", "h", ")", "\n", "h_relu5", "=", "h", "\n", "h", "=", "self", ".", "slice6", "(", "h", ")", "\n", "h_relu6", "=", "h", "\n", "h", "=", "self", ".", "slice7", "(", "h", ")", "\n", "h_relu7", "=", "h", "\n", "vgg_outputs", "=", "namedtuple", "(", "\"SqueezeOutputs\"", ",", "[", "'relu1'", ",", "'relu2'", ",", "'relu3'", ",", "'relu4'", ",", "'relu5'", ",", "'relu6'", ",", "'relu7'", "]", ")", "\n", "out", "=", "vgg_outputs", "(", "h_relu1", ",", "h_relu2", ",", "h_relu3", ",", "h_relu4", ",", "h_relu5", ",", "h_relu6", ",", "h_relu7", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.alexnet.__init__": [[58, 80], ["super().__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "range", "range", "range", "range", "range", "torchvision.models.alexnet", "pretrained_networks.alexnet.slice1.add_module", "pretrained_networks.alexnet.slice2.add_module", "pretrained_networks.alexnet.slice3.add_module", "pretrained_networks.alexnet.slice4.add_module", "pretrained_networks.alexnet.slice5.add_module", "pretrained_networks.alexnet.parameters", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "requires_grad", "=", "False", ",", "pretrained", "=", "True", ")", ":", "\n", "        ", "super", "(", "alexnet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "alexnet_pretrained_features", "=", "tv", ".", "alexnet", "(", "pretrained", "=", "pretrained", ")", ".", "features", "\n", "self", ".", "slice1", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice2", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice3", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice4", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice5", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "N_slices", "=", "5", "\n", "for", "x", "in", "range", "(", "2", ")", ":", "\n", "            ", "self", ".", "slice1", ".", "add_module", "(", "str", "(", "x", ")", ",", "alexnet_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "2", ",", "5", ")", ":", "\n", "            ", "self", ".", "slice2", ".", "add_module", "(", "str", "(", "x", ")", ",", "alexnet_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "5", ",", "8", ")", ":", "\n", "            ", "self", ".", "slice3", ".", "add_module", "(", "str", "(", "x", ")", ",", "alexnet_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "8", ",", "10", ")", ":", "\n", "            ", "self", ".", "slice4", ".", "add_module", "(", "str", "(", "x", ")", ",", "alexnet_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "10", ",", "12", ")", ":", "\n", "            ", "self", ".", "slice5", ".", "add_module", "(", "str", "(", "x", ")", ",", "alexnet_pretrained_features", "[", "x", "]", ")", "\n", "", "if", "not", "requires_grad", ":", "\n", "            ", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.alexnet.forward": [[81, 96], ["pretrained_networks.alexnet.slice1", "pretrained_networks.alexnet.slice2", "pretrained_networks.alexnet.slice3", "pretrained_networks.alexnet.slice4", "pretrained_networks.alexnet.slice5", "collections.namedtuple", "collections.namedtuple."], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "h", "=", "self", ".", "slice1", "(", "X", ")", "\n", "h_relu1", "=", "h", "\n", "h", "=", "self", ".", "slice2", "(", "h", ")", "\n", "h_relu2", "=", "h", "\n", "h", "=", "self", ".", "slice3", "(", "h", ")", "\n", "h_relu3", "=", "h", "\n", "h", "=", "self", ".", "slice4", "(", "h", ")", "\n", "h_relu4", "=", "h", "\n", "h", "=", "self", ".", "slice5", "(", "h", ")", "\n", "h_relu5", "=", "h", "\n", "alexnet_outputs", "=", "namedtuple", "(", "\"AlexnetOutputs\"", ",", "[", "'relu1'", ",", "'relu2'", ",", "'relu3'", ",", "'relu4'", ",", "'relu5'", "]", ")", "\n", "out", "=", "alexnet_outputs", "(", "h_relu1", ",", "h_relu2", ",", "h_relu3", ",", "h_relu4", ",", "h_relu5", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.vgg16.__init__": [[98, 120], ["super().__init__", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "range", "range", "range", "range", "range", "torchvision.models.vgg16", "pretrained_networks.vgg16.slice1.add_module", "pretrained_networks.vgg16.slice2.add_module", "pretrained_networks.vgg16.slice3.add_module", "pretrained_networks.vgg16.slice4.add_module", "pretrained_networks.vgg16.slice5.add_module", "pretrained_networks.vgg16.parameters", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "requires_grad", "=", "False", ",", "pretrained", "=", "True", ")", ":", "\n", "        ", "super", "(", "vgg16", ",", "self", ")", ".", "__init__", "(", ")", "\n", "vgg_pretrained_features", "=", "tv", ".", "vgg16", "(", "pretrained", "=", "pretrained", ")", ".", "features", "\n", "self", ".", "slice1", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice2", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice3", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice4", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "slice5", "=", "torch", ".", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "N_slices", "=", "5", "\n", "for", "x", "in", "range", "(", "4", ")", ":", "\n", "            ", "self", ".", "slice1", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "4", ",", "9", ")", ":", "\n", "            ", "self", ".", "slice2", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "9", ",", "16", ")", ":", "\n", "            ", "self", ".", "slice3", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "16", ",", "23", ")", ":", "\n", "            ", "self", ".", "slice4", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "for", "x", "in", "range", "(", "23", ",", "30", ")", ":", "\n", "            ", "self", ".", "slice5", ".", "add_module", "(", "str", "(", "x", ")", ",", "vgg_pretrained_features", "[", "x", "]", ")", "\n", "", "if", "not", "requires_grad", ":", "\n", "            ", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "                ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.vgg16.forward": [[121, 136], ["pretrained_networks.vgg16.slice1", "pretrained_networks.vgg16.slice2", "pretrained_networks.vgg16.slice3", "pretrained_networks.vgg16.slice4", "pretrained_networks.vgg16.slice5", "collections.namedtuple", "collections.namedtuple."], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "h", "=", "self", ".", "slice1", "(", "X", ")", "\n", "h_relu1_2", "=", "h", "\n", "h", "=", "self", ".", "slice2", "(", "h", ")", "\n", "h_relu2_2", "=", "h", "\n", "h", "=", "self", ".", "slice3", "(", "h", ")", "\n", "h_relu3_3", "=", "h", "\n", "h", "=", "self", ".", "slice4", "(", "h", ")", "\n", "h_relu4_3", "=", "h", "\n", "h", "=", "self", ".", "slice5", "(", "h", ")", "\n", "h_relu5_3", "=", "h", "\n", "vgg_outputs", "=", "namedtuple", "(", "\"VggOutputs\"", ",", "[", "'relu1_2'", ",", "'relu2_2'", ",", "'relu3_3'", ",", "'relu4_3'", ",", "'relu5_3'", "]", ")", "\n", "out", "=", "vgg_outputs", "(", "h_relu1_2", ",", "h_relu2_2", ",", "h_relu3_3", ",", "h_relu4_3", ",", "h_relu5_3", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.resnet.__init__": [[140, 162], ["super().__init__", "torchvision.models.resnet18", "torchvision.models.resnet34", "torchvision.models.resnet50", "torchvision.models.resnet101", "torchvision.models.resnet152"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "requires_grad", "=", "False", ",", "pretrained", "=", "True", ",", "num", "=", "18", ")", ":", "\n", "        ", "super", "(", "resnet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "(", "num", "==", "18", ")", ":", "\n", "            ", "self", ".", "net", "=", "tv", ".", "resnet18", "(", "pretrained", "=", "pretrained", ")", "\n", "", "elif", "(", "num", "==", "34", ")", ":", "\n", "            ", "self", ".", "net", "=", "tv", ".", "resnet34", "(", "pretrained", "=", "pretrained", ")", "\n", "", "elif", "(", "num", "==", "50", ")", ":", "\n", "            ", "self", ".", "net", "=", "tv", ".", "resnet50", "(", "pretrained", "=", "pretrained", ")", "\n", "", "elif", "(", "num", "==", "101", ")", ":", "\n", "            ", "self", ".", "net", "=", "tv", ".", "resnet101", "(", "pretrained", "=", "pretrained", ")", "\n", "", "elif", "(", "num", "==", "152", ")", ":", "\n", "            ", "self", ".", "net", "=", "tv", ".", "resnet152", "(", "pretrained", "=", "pretrained", ")", "\n", "", "self", ".", "N_slices", "=", "5", "\n", "\n", "self", ".", "conv1", "=", "self", ".", "net", ".", "conv1", "\n", "self", ".", "bn1", "=", "self", ".", "net", ".", "bn1", "\n", "self", ".", "relu", "=", "self", ".", "net", ".", "relu", "\n", "self", ".", "maxpool", "=", "self", ".", "net", ".", "maxpool", "\n", "self", ".", "layer1", "=", "self", ".", "net", ".", "layer1", "\n", "self", ".", "layer2", "=", "self", ".", "net", ".", "layer2", "\n", "self", ".", "layer3", "=", "self", ".", "net", ".", "layer3", "\n", "self", ".", "layer4", "=", "self", ".", "net", ".", "layer4", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.pretrained_networks.resnet.forward": [[163, 182], ["pretrained_networks.resnet.conv1", "pretrained_networks.resnet.bn1", "pretrained_networks.resnet.relu", "pretrained_networks.resnet.maxpool", "pretrained_networks.resnet.layer1", "pretrained_networks.resnet.layer2", "pretrained_networks.resnet.layer3", "pretrained_networks.resnet.layer4", "collections.namedtuple", "collections.namedtuple."], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "X", ")", ":", "\n", "        ", "h", "=", "self", ".", "conv1", "(", "X", ")", "\n", "h", "=", "self", ".", "bn1", "(", "h", ")", "\n", "h", "=", "self", ".", "relu", "(", "h", ")", "\n", "h_relu1", "=", "h", "\n", "h", "=", "self", ".", "maxpool", "(", "h", ")", "\n", "h", "=", "self", ".", "layer1", "(", "h", ")", "\n", "h_conv2", "=", "h", "\n", "h", "=", "self", ".", "layer2", "(", "h", ")", "\n", "h_conv3", "=", "h", "\n", "h", "=", "self", ".", "layer3", "(", "h", ")", "\n", "h_conv4", "=", "h", "\n", "h", "=", "self", ".", "layer4", "(", "h", ")", "\n", "h_conv5", "=", "h", "\n", "\n", "outputs", "=", "namedtuple", "(", "\"Outputs\"", ",", "[", "'relu1'", ",", "'conv2'", ",", "'conv3'", ",", "'conv4'", ",", "'conv5'", "]", ")", "\n", "out", "=", "outputs", "(", "h_relu1", ",", "h_conv2", ",", "h_conv3", ",", "h_conv4", ",", "h_conv5", ")", "\n", "\n", "return", "out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.wmad_estimator.Wmad_estimator.__init__": [[9, 21], ["torch.nn.Module.__init__", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Wmad_estimator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# DB7 high pass decomposition filter", "\n", "#self.db7_decomp_high = torch.Tensor([-0.48296291314469025, 0.836516303737469, -0.22414386804185735,", "\n", "#                                     -0.12940952255092145])[:,None]", "\n", "self", ".", "db7_decomp_high", "=", "torch", ".", "Tensor", "(", "[", "-", "0.07785205408506236", ",", "0.39653931948230575", ",", "-", "0.7291320908465551", ",", "\n", "0.4697822874053586", ",", "0.14390600392910627", ",", "-", "0.22403618499416572", ",", "\n", "-", "0.07130921926705004", ",", "0.0806126091510659", ",", "0.03802993693503463", ",", "\n", "-", "0.01657454163101562", ",", "-", "0.012550998556013784", ",", "0.00042957797300470274", ",", "\n", "0.0018016407039998328", ",", "0.0003537138000010399", "]", ")", "[", ":", ",", "None", "]", "\n", "self", ".", "db7_decomp_high", "=", "self", ".", "db7_decomp_high", "[", "None", ",", "None", ",", ":", "]", "\n", "#self.db7_decomp_high = torch.stack([self.db7_decomp_high,self.db7_decomp_high,self.db7_decomp_high])", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.wmad_estimator.Wmad_estimator.forward": [[24, 49], ["torch.pad", "torch.pad", "torch.conv2d", "torch.conv2d", "torch.pad", "torch.pad", "torch.conv2d", "torch.conv2d", "diagonal.view.view.view", "range", "sigma.detach.detach.detach", "x.max", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "db7_decomp_high.cuda.cuda.cuda", "diagonal.view.view.transpose", "torch.median", "torch.median", "torch.median", "torch.median", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "x", ".", "max", "(", ")", ">", "1", ":", "\n", "            ", "x", "=", "x", "/", "255", "\n", "", "db7_decomp_high", "=", "self", ".", "db7_decomp_high", "\n", "if", "x", ".", "shape", "[", "1", "]", ">", "1", ":", "\n", "            ", "db7_decomp_high", "=", "torch", ".", "cat", "(", "[", "self", ".", "db7_decomp_high", "]", "*", "x", ".", "shape", "[", "1", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "x", ".", "is_cuda", ":", "\n", "            ", "db7_decomp_high", "=", "db7_decomp_high", ".", "cuda", "(", ")", "\n", "\n", "#print('wmad x:', x.shape, x.min(), x.max())", "\n", "", "diagonal", "=", "F", ".", "pad", "(", "x", ",", "(", "0", ",", "0", ",", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ",", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ")", ",", "mode", "=", "'reflect'", ")", "\n", "diagonal", "=", "F", ".", "conv2d", "(", "diagonal", ",", "db7_decomp_high", ",", "stride", "=", "(", "2", ",", "1", ")", ",", "groups", "=", "x", ".", "shape", "[", "1", "]", ")", "\n", "diagonal", "=", "F", ".", "pad", "(", "diagonal", ",", "(", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ",", "self", ".", "db7_decomp_high", ".", "shape", "[", "2", "]", "//", "2", ",", "0", ",", "0", ")", ",", "mode", "=", "'reflect'", ")", "\n", "diagonal", "=", "F", ".", "conv2d", "(", "diagonal", ".", "transpose", "(", "2", ",", "3", ")", ",", "db7_decomp_high", ",", "stride", "=", "(", "2", ",", "1", ")", ",", "groups", "=", "x", ".", "shape", "[", "1", "]", ")", "\n", "#diagonal = diagonal.transpose(2,3)", "\n", "sigma", "=", "0", "\n", "diagonal", "=", "diagonal", ".", "view", "(", "diagonal", ".", "shape", "[", "0", "]", ",", "diagonal", ".", "shape", "[", "1", "]", ",", "-", "1", ")", "\n", "for", "c", "in", "range", "(", "diagonal", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "d", "=", "diagonal", "[", ":", ",", "c", "]", "\n", "sigma", "+=", "torch", ".", "median", "(", "torch", ".", "abs", "(", "d", ")", ",", "dim", "=", "1", ")", "[", "0", "]", "/", "0.6745", "\n", "", "sigma", "=", "sigma", "/", "diagonal", ".", "shape", "[", "1", "]", "\n", "sigma", "=", "sigma", ".", "detach", "(", ")", "\n", "del", "db7_decomp_high", "\n", "return", "sigma", "\n", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.CharbonnierLoss.__init__": [[8, 11], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["def", "__init__", "(", "self", ",", "eps", "=", "1e-6", ")", ":", "\n", "        ", "super", "(", "CharbonnierLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.CharbonnierLoss.forward": [[12, 16], ["torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "diff", "=", "x", "-", "y", "\n", "loss", "=", "torch", ".", "sum", "(", "torch", ".", "sqrt", "(", "diff", "*", "diff", "+", "self", ".", "eps", ")", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GANLoss.__init__": [[20, 39], ["torch.Module.__init__", "gan_type.lower", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "torch.MSELoss", "torch.MSELoss", "NotImplementedError", "input.mean", "input.mean"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "gan_type", ",", "real_label_val", "=", "1.0", ",", "fake_label_val", "=", "0.0", ")", ":", "\n", "        ", "super", "(", "GANLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gan_type", "=", "gan_type", ".", "lower", "(", ")", "\n", "self", ".", "real_label_val", "=", "real_label_val", "\n", "self", ".", "fake_label_val", "=", "fake_label_val", "\n", "\n", "if", "self", ".", "gan_type", "==", "'gan'", "or", "self", ".", "gan_type", "==", "'ragan'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "", "elif", "self", ".", "gan_type", "==", "'lsgan'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "MSELoss", "(", ")", "\n", "", "elif", "self", ".", "gan_type", "==", "'wgan-gp'", ":", "\n", "\n", "            ", "def", "wgan_loss", "(", "input", ",", "target", ")", ":", "\n", "# target is boolean", "\n", "                ", "return", "-", "1", "*", "input", ".", "mean", "(", ")", "if", "target", "else", "input", ".", "mean", "(", ")", "\n", "\n", "", "self", ".", "loss", "=", "wgan_loss", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'GAN type [{:s}] is not found'", ".", "format", "(", "self", ".", "gan_type", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GANLoss.get_target_label": [[40, 47], ["torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like().fill_", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like", "torch.empty_like"], "methods", ["None"], ["", "", "def", "get_target_label", "(", "self", ",", "input", ",", "target_is_real", ")", ":", "\n", "        ", "if", "self", ".", "gan_type", "==", "'wgan-gp'", ":", "\n", "            ", "return", "target_is_real", "\n", "", "if", "target_is_real", ":", "\n", "            ", "return", "torch", ".", "empty_like", "(", "input", ")", ".", "fill_", "(", "self", ".", "real_label_val", ")", "\n", "", "else", ":", "\n", "            ", "return", "torch", ".", "empty_like", "(", "input", ")", ".", "fill_", "(", "self", ".", "fake_label_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GANLoss.forward": [[48, 52], ["loss.GANLoss.GANLoss.get_target_label", "loss.GANLoss.GANLoss.loss"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GANLoss.get_target_label"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "target_is_real", ")", ":", "\n", "        ", "target_label", "=", "self", ".", "get_target_label", "(", "input", ",", "target_is_real", ")", "\n", "loss", "=", "self", ".", "loss", "(", "input", ",", "target_label", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GradientPenaltyLoss.__init__": [[55, 59], ["torch.device", "torch.device", "torch.device", "torch.device", "torch.Module.__init__", "loss.GradientPenaltyLoss.register_buffer", "loss.GradientPenaltyLoss.grad_outputs.to", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", ")", ":", "\n", "        ", "super", "(", "GradientPenaltyLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "register_buffer", "(", "'grad_outputs'", ",", "torch", ".", "Tensor", "(", ")", ")", "\n", "self", ".", "grad_outputs", "=", "self", ".", "grad_outputs", ".", "to", "(", "device", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GradientPenaltyLoss.get_grad_outputs": [[60, 64], ["loss.GradientPenaltyLoss.grad_outputs.size", "input.size", "loss.GradientPenaltyLoss.grad_outputs.resize_().fill_", "loss.GradientPenaltyLoss.grad_outputs.resize_", "input.size"], "methods", ["None"], ["", "def", "get_grad_outputs", "(", "self", ",", "input", ")", ":", "\n", "        ", "if", "self", ".", "grad_outputs", ".", "size", "(", ")", "!=", "input", ".", "size", "(", ")", ":", "\n", "            ", "self", ".", "grad_outputs", ".", "resize_", "(", "input", ".", "size", "(", ")", ")", ".", "fill_", "(", "1.0", ")", "\n", "", "return", "self", ".", "grad_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GradientPenaltyLoss.forward": [[65, 75], ["loss.GradientPenaltyLoss.get_grad_outputs", "grad_interp.view.view.view", "grad_interp.view.view.norm", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "torch.autograd.grad", "grad_interp.view.view.size"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.GradientPenaltyLoss.get_grad_outputs"], ["", "def", "forward", "(", "self", ",", "interp", ",", "interp_crit", ")", ":", "\n", "        ", "grad_outputs", "=", "self", ".", "get_grad_outputs", "(", "interp_crit", ")", "\n", "grad_interp", "=", "torch", ".", "autograd", ".", "grad", "(", "outputs", "=", "interp_crit", ",", "inputs", "=", "interp", ",", "\n", "grad_outputs", "=", "grad_outputs", ",", "create_graph", "=", "True", ",", "\n", "retain_graph", "=", "True", ",", "only_inputs", "=", "True", ")", "[", "0", "]", "\n", "grad_interp", "=", "grad_interp", ".", "view", "(", "grad_interp", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "grad_interp_norm", "=", "grad_interp", ".", "norm", "(", "2", ",", "dim", "=", "1", ")", "\n", "\n", "loss", "=", "(", "(", "grad_interp_norm", "-", "1", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L2Loss.__init__": [[77, 79], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TV_L2Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L2Loss.forward": [[80, 89], ["loss.TV_L2Loss.tensor_size", "loss.TV_L2Loss.tensor_size", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "x.size", "x.size", "x.size", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.tensor_size", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.tensor_size"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "batch_size", "=", "x", ".", "size", "(", ")", "[", "0", "]", "\n", "h_x", "=", "x", ".", "size", "(", ")", "[", "2", "]", "\n", "w_x", "=", "x", ".", "size", "(", ")", "[", "3", "]", "\n", "count_h", "=", "self", ".", "tensor_size", "(", "x", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", ")", "\n", "count_w", "=", "self", ".", "tensor_size", "(", "x", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", ")", "\n", "h_tv", "=", "torch", ".", "pow", "(", "(", "x", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "x", "[", ":", ",", ":", ",", ":", "h_x", "-", "1", ",", ":", "]", ")", ",", "2", ")", ".", "sum", "(", ")", "\n", "w_tv", "=", "torch", ".", "pow", "(", "(", "x", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", "-", "x", "[", ":", ",", ":", ",", ":", ",", ":", "w_x", "-", "1", "]", ")", ",", "2", ")", ".", "sum", "(", ")", "\n", "return", "(", "h_tv", "/", "count_h", "+", "w_tv", "/", "count_w", ")", "/", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L2Loss.tensor_size": [[90, 92], ["t.size", "t.size", "t.size"], "methods", ["None"], ["", "def", "tensor_size", "(", "self", ",", "t", ")", ":", "\n", "        ", "return", "t", ".", "size", "(", ")", "[", "1", "]", "*", "t", ".", "size", "(", ")", "[", "2", "]", "*", "t", ".", "size", "(", ")", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.__init__": [[94, 96], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "tv_loss_weight", "=", "1", ")", ":", "\n", "        ", "super", "(", "TV_L1Loss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.forward": [[97, 106], ["loss.TV_L1Loss.tensor_size", "loss.TV_L1Loss.tensor_size", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "x.size", "x.size", "x.size", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.tensor_size", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.tensor_size"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "batch_size", "=", "x", ".", "size", "(", ")", "[", "0", "]", "\n", "h_x", "=", "x", ".", "size", "(", ")", "[", "2", "]", "\n", "w_x", "=", "x", ".", "size", "(", ")", "[", "3", "]", "\n", "count_h", "=", "self", ".", "tensor_size", "(", "x", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", ")", "\n", "count_w", "=", "self", ".", "tensor_size", "(", "x", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", ")", "\n", "h_tv", "=", "torch", ".", "abs", "(", "(", "x", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "x", "[", ":", ",", ":", ",", ":", "h_x", "-", "1", ",", ":", "]", ")", ")", ".", "sum", "(", ")", "\n", "w_tv", "=", "torch", ".", "abs", "(", "(", "x", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", "-", "x", "[", ":", ",", ":", ",", ":", ",", ":", "w_x", "-", "1", "]", ")", ")", ".", "sum", "(", ")", "\n", "return", "(", "h_tv", "/", "count_h", "+", "w_tv", "/", "count_w", ")", "/", "batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1Loss.tensor_size": [[107, 109], ["t.size", "t.size", "t.size"], "methods", ["None"], ["", "def", "tensor_size", "(", "self", ",", "t", ")", ":", "\n", "        ", "return", "t", ".", "size", "(", ")", "[", "1", "]", "*", "t", ".", "size", "(", ")", "[", "2", "]", "*", "t", ".", "size", "(", ")", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1LOSS.__init__": [[111, 113], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "TV_L1LOSS", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.loss.TV_L1LOSS.forward": [[114, 119], ["x.size", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs().sum", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs", "torch.abs"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "size", "=", "x", ".", "size", "(", ")", "\n", "h_tv_diff", "=", "torch", ".", "abs", "(", "(", "x", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "x", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", "-", "(", "y", "[", ":", ",", ":", ",", "1", ":", ",", ":", "]", "-", "y", "[", ":", ",", ":", ",", ":", "-", "1", ",", ":", "]", ")", ")", ")", ".", "sum", "(", ")", "\n", "w_tv_diff", "=", "torch", ".", "abs", "(", "(", "x", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", "-", "x", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", "]", "-", "(", "y", "[", ":", ",", ":", ",", ":", ",", "1", ":", "]", "-", "y", "[", ":", ",", ":", ",", ":", ",", ":", "-", "1", "]", ")", ")", ")", ".", "sum", "(", ")", "\n", "return", "(", "h_tv_diff", "+", "w_tv_diff", ")", "/", "size", "[", "0", "]", "/", "size", "[", "1", "]", "/", "size", "[", "2", "]", "/", "size", "[", "3", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.L2Proj.__init__": [[24, 26], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "L2Proj", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.L2Proj.forward": [[27, 42], ["torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "torch.sqrt", "x.view", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.norm().reshape", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "x.size", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.cuda.FloatTensor().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.norm", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.cuda.FloatTensor", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "x.size", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "stdn", ",", "alpha", ")", ":", "\n", "        ", "if", "x", ".", "is_cuda", ":", "\n", "            ", "x_size", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "1", ")", ".", "fill_", "(", "x", ".", "shape", "[", "1", "]", "*", "x", ".", "shape", "[", "2", "]", "*", "x", ".", "shape", "[", "3", "]", ")", "\n", "", "else", ":", "\n", "            ", "x_size", "=", "torch", ".", "Tensor", "(", "[", "x", ".", "shape", "[", "1", "]", "*", "x", ".", "shape", "[", "2", "]", "*", "x", ".", "shape", "[", "3", "]", "]", ")", "\n", "", "numX", "=", "torch", ".", "sqrt", "(", "x_size", "-", "1", ")", "\n", "if", "x", ".", "is_cuda", ":", "\n", "            ", "epsilon", "=", "torch", ".", "cuda", ".", "FloatTensor", "(", "x", ".", "shape", "[", "0", "]", ",", "1", ",", "1", ",", "1", ")", ".", "fill_", "(", "1", ")", "*", "(", "torch", ".", "exp", "(", "alpha", ")", "*", "stdn", "*", "numX", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "", "else", ":", "\n", "            ", "epsilon", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", ".", "fill_", "(", "1", ")", "*", "(", "torch", ".", "exp", "(", "alpha", ")", "*", "stdn", "*", "numX", ")", "[", ":", ",", "None", ",", "None", ",", "None", "]", "\n", "", "x_resized", "=", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "-", "1", ")", "\n", "x_norm", "=", "torch", ".", "norm", "(", "x_resized", ",", "2", ",", "dim", "=", "1", ")", ".", "reshape", "(", "x", ".", "size", "(", "0", ")", ",", "1", ",", "1", ",", "1", ")", "\n", "max_norm", "=", "torch", ".", "max", "(", "x_norm", ",", "epsilon", ")", "\n", "result", "=", "x", "*", "(", "epsilon", "/", "max_norm", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.l2proj.mse_loss": [[44, 46], ["torch.sum", "torch.sum", "torch.sum", "input.data.nelement"], "function", ["None"], ["", "", "def", "mse_loss", "(", "input", ",", "target", ")", ":", "\n", "    ", "return", "torch", ".", "sum", "(", "(", "input", "-", "target", ")", "**", "2", ")", "/", "input", ".", "data", ".", "nelement", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.lr_scheduler.MultiStepLR_Restart.__init__": [[9, 20], ["collections.Counter", "torch.optim.lr_scheduler._LRScheduler.__init__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "optimizer", ",", "milestones", ",", "restarts", "=", "None", ",", "weights", "=", "None", ",", "gamma", "=", "0.1", ",", "\n", "clear_state", "=", "False", ",", "last_epoch", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "milestones", "=", "Counter", "(", "milestones", ")", "\n", "self", ".", "gamma", "=", "gamma", "\n", "self", ".", "clear_state", "=", "clear_state", "\n", "self", ".", "restarts", "=", "restarts", "if", "restarts", "else", "[", "0", "]", "\n", "self", ".", "restarts", "=", "[", "v", "+", "1", "for", "v", "in", "self", ".", "restarts", "]", "\n", "self", ".", "restart_weights", "=", "weights", "if", "weights", "else", "[", "1", "]", "\n", "assert", "len", "(", "self", ".", "restarts", ")", "==", "len", "(", "\n", "self", ".", "restart_weights", ")", ",", "'restarts and their weights do not match.'", "\n", "super", "(", "MultiStepLR_Restart", ",", "self", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.lr_scheduler.MultiStepLR_Restart.get_lr": [[21, 32], ["collections.defaultdict", "lr_scheduler.MultiStepLR_Restart.restarts.index"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "last_epoch", "in", "self", ".", "restarts", ":", "\n", "            ", "if", "self", ".", "clear_state", ":", "\n", "                ", "self", ".", "optimizer", ".", "state", "=", "defaultdict", "(", "dict", ")", "\n", "", "weight", "=", "self", ".", "restart_weights", "[", "self", ".", "restarts", ".", "index", "(", "self", ".", "last_epoch", ")", "]", "\n", "return", "[", "group", "[", "'initial_lr'", "]", "*", "weight", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "", "if", "self", ".", "last_epoch", "not", "in", "self", ".", "milestones", ":", "\n", "            ", "return", "[", "group", "[", "'lr'", "]", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "", "return", "[", "\n", "group", "[", "'lr'", "]", "*", "self", ".", "gamma", "**", "self", ".", "milestones", "[", "self", ".", "last_epoch", "]", "\n", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "\n", "]", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.lr_scheduler.CosineAnnealingLR_Restart.__init__": [[36, 47], ["torch.optim.lr_scheduler._LRScheduler.__init__", "len", "len"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "optimizer", ",", "T_period", ",", "restarts", "=", "None", ",", "weights", "=", "None", ",", "eta_min", "=", "0", ",", "last_epoch", "=", "-", "1", ")", ":", "\n", "        ", "self", ".", "T_period", "=", "T_period", "\n", "self", ".", "T_max", "=", "self", ".", "T_period", "[", "0", "]", "# current T period", "\n", "self", ".", "eta_min", "=", "eta_min", "\n", "self", ".", "restarts", "=", "restarts", "if", "restarts", "else", "[", "0", "]", "\n", "self", ".", "restarts", "=", "[", "v", "+", "1", "for", "v", "in", "self", ".", "restarts", "]", "\n", "self", ".", "restart_weights", "=", "weights", "if", "weights", "else", "[", "1", "]", "\n", "self", ".", "last_restart", "=", "0", "\n", "assert", "len", "(", "self", ".", "restarts", ")", "==", "len", "(", "\n", "self", ".", "restart_weights", ")", ",", "'restarts and their weights do not match.'", "\n", "super", "(", "CosineAnnealingLR_Restart", ",", "self", ")", ".", "__init__", "(", "optimizer", ",", "last_epoch", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.lr_scheduler.CosineAnnealingLR_Restart.get_lr": [[48, 65], ["lr_scheduler.CosineAnnealingLR_Restart.restarts.index", "lr_scheduler.CosineAnnealingLR_Restart.restarts.index", "zip", "math.cos", "math.cos", "math.cos"], "methods", ["None"], ["", "def", "get_lr", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "last_epoch", "==", "0", ":", "\n", "            ", "return", "self", ".", "base_lrs", "\n", "", "elif", "self", ".", "last_epoch", "in", "self", ".", "restarts", ":", "\n", "            ", "self", ".", "last_restart", "=", "self", ".", "last_epoch", "\n", "self", ".", "T_max", "=", "self", ".", "T_period", "[", "self", ".", "restarts", ".", "index", "(", "self", ".", "last_epoch", ")", "+", "1", "]", "\n", "weight", "=", "self", ".", "restart_weights", "[", "self", ".", "restarts", ".", "index", "(", "self", ".", "last_epoch", ")", "]", "\n", "return", "[", "group", "[", "'initial_lr'", "]", "*", "weight", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "", "elif", "(", "self", ".", "last_epoch", "-", "self", ".", "last_restart", "-", "1", "-", "self", ".", "T_max", ")", "%", "(", "2", "*", "self", ".", "T_max", ")", "==", "0", ":", "\n", "            ", "return", "[", "\n", "group", "[", "'lr'", "]", "+", "(", "base_lr", "-", "self", ".", "eta_min", ")", "*", "(", "1", "-", "math", ".", "cos", "(", "math", ".", "pi", "/", "self", ".", "T_max", ")", ")", "/", "2", "\n", "for", "base_lr", ",", "group", "in", "zip", "(", "self", ".", "base_lrs", ",", "self", ".", "optimizer", ".", "param_groups", ")", "\n", "]", "\n", "", "return", "[", "(", "1", "+", "math", ".", "cos", "(", "math", ".", "pi", "*", "(", "self", ".", "last_epoch", "-", "self", ".", "last_restart", ")", "/", "self", ".", "T_max", ")", ")", "/", "\n", "(", "1", "+", "math", ".", "cos", "(", "math", ".", "pi", "*", "(", "(", "self", ".", "last_epoch", "-", "self", ".", "last_restart", ")", "-", "1", ")", "/", "self", ".", "T_max", ")", ")", "*", "\n", "(", "group", "[", "'lr'", "]", "-", "self", ".", "eta_min", ")", "+", "self", ".", "eta_min", "\n", "for", "group", "in", "self", ".", "optimizer", ".", "param_groups", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.PerceptualLoss.__init__": [[14, 25], ["super().__init__", "print", "modules.dist_model.DistModel", "__init__.PerceptualLoss.model.initialize", "print", "print", "__init__.PerceptualLoss.model.name"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.initialize", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.name"], ["    ", "def", "__init__", "(", "self", ",", "model", "=", "'net-lin'", ",", "net", "=", "'alex'", ",", "colorspace", "=", "'rgb'", ",", "spatial", "=", "False", ",", "use_gpu", "=", "True", ",", "gpu_ids", "=", "[", "0", "]", ")", ":", "# VGG using our perceptually-learned weights (LPIPS metric)", "\n", "# def __init__(self, model='net', net='vgg', use_gpu=True): # \"default\" way of using VGG as a perceptual loss", "\n", "        ", "super", "(", "PerceptualLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "print", "(", "'Setting up Perceptual loss...'", ")", "\n", "self", ".", "use_gpu", "=", "use_gpu", "\n", "self", ".", "spatial", "=", "spatial", "\n", "self", ".", "gpu_ids", "=", "gpu_ids", "\n", "self", ".", "model", "=", "dist_model", ".", "DistModel", "(", ")", "\n", "self", ".", "model", ".", "initialize", "(", "model", "=", "model", ",", "net", "=", "net", ",", "use_gpu", "=", "use_gpu", ",", "colorspace", "=", "colorspace", ",", "spatial", "=", "self", ".", "spatial", ",", "gpu_ids", "=", "gpu_ids", ")", "\n", "print", "(", "'...[%s] initialized'", "%", "self", ".", "model", ".", "name", "(", ")", ")", "\n", "print", "(", "'...Done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.PerceptualLoss.forward": [[26, 41], ["__init__.PerceptualLoss.model.forward"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward"], ["", "def", "forward", "(", "self", ",", "pred", ",", "target", ",", "normalize", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Pred and target are Variables.\n        If normalize is True, assumes the images are between [0,1] and then scales them between [-1,+1]\n        If normalize is False, assumes the images are already between [-1,+1]\n\n        Inputs pred and target are Nx3xHxW\n        Output pytorch Variable N long\n        \"\"\"", "\n", "\n", "if", "normalize", ":", "\n", "            ", "target", "=", "2", "*", "target", "-", "1", "\n", "pred", "=", "2", "*", "pred", "-", "1", "\n", "\n", "", "return", "self", ".", "model", ".", "forward", "(", "target", ",", "pred", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.normalize_tensor": [[42, 45], ["torch.sqrt", "torch.sum"], "function", ["None"], ["", "", "def", "normalize_tensor", "(", "in_feat", ",", "eps", "=", "1e-10", ")", ":", "\n", "    ", "norm_factor", "=", "torch", ".", "sqrt", "(", "torch", ".", "sum", "(", "in_feat", "**", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", ")", "\n", "return", "in_feat", "/", "(", "norm_factor", "+", "eps", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.l2": [[46, 48], ["numpy.mean"], "function", ["None"], ["", "def", "l2", "(", "p0", ",", "p1", ",", "range", "=", "255.", ")", ":", "\n", "    ", "return", ".5", "*", "np", ".", "mean", "(", "(", "p0", "/", "range", "-", "p1", "/", "range", ")", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.psnr": [[49, 51], ["numpy.log10", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_model.log10"], ["", "def", "psnr", "(", "p0", ",", "p1", ",", "peak", "=", "255.", ")", ":", "\n", "    ", "return", "10", "*", "np", ".", "log10", "(", "peak", "**", "2", "/", "np", ".", "mean", "(", "(", "1.", "*", "p0", "-", "1.", "*", "p1", ")", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.dssim": [[52, 54], ["skimage.measure.compare_ssim"], "function", ["None"], ["", "def", "dssim", "(", "p0", ",", "p1", ",", "range", "=", "255.", ")", ":", "\n", "    ", "return", "(", "1", "-", "compare_ssim", "(", "p0", ",", "p1", ",", "data_range", "=", "range", ",", "multichannel", "=", "True", ")", ")", "/", "2.", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.rgb2lab": [[102, 105], ["color.rgb2lab"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.rgb2lab"], ["", "", "def", "rgb2lab", "(", "input", ")", ":", "\n", "    ", "from", "skimage", "import", "color", "\n", "return", "color", ".", "rgb2lab", "(", "input", "/", "255.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2np": [[62, 65], ["tensor_obj[].cpu().float().numpy().transpose", "tensor_obj[].cpu().float().numpy", "tensor_obj[].cpu().float", "tensor_obj[].cpu"], "function", ["None"], ["", "def", "tensor2np", "(", "tensor_obj", ")", ":", "\n", "# change dimension of a tensor object into a numpy array", "\n", "    ", "return", "tensor_obj", "[", "0", "]", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.np2tensor": [[66, 69], ["torch.Tensor", "np_obj[].transpose"], "function", ["None"], ["", "def", "np2tensor", "(", "np_obj", ")", ":", "\n", "# change dimenion of np array into tensor array", "\n", "    ", "return", "torch", ".", "Tensor", "(", "np_obj", "[", ":", ",", ":", ",", ":", ",", "np", ".", "newaxis", "]", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2tensorlab": [[70, 83], ["__init__.tensor2im", "color.rgb2lab", "__init__.np2tensor"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.rgb2lab", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.np2tensor"], ["", "def", "tensor2tensorlab", "(", "image_tensor", ",", "to_norm", "=", "True", ",", "mc_only", "=", "False", ")", ":", "\n", "# image tensor to lab tensor", "\n", "    ", "from", "skimage", "import", "color", "\n", "\n", "img", "=", "tensor2im", "(", "image_tensor", ")", "\n", "img_lab", "=", "color", ".", "rgb2lab", "(", "img", ")", "\n", "if", "(", "mc_only", ")", ":", "\n", "        ", "img_lab", "[", ":", ",", ":", ",", "0", "]", "=", "img_lab", "[", ":", ",", ":", ",", "0", "]", "-", "50", "\n", "", "if", "(", "to_norm", "and", "not", "mc_only", ")", ":", "\n", "        ", "img_lab", "[", ":", ",", ":", ",", "0", "]", "=", "img_lab", "[", ":", ",", ":", ",", "0", "]", "-", "50", "\n", "img_lab", "=", "img_lab", "/", "100.", "\n", "\n", "", "return", "np2tensor", "(", "img_lab", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensorlab2tensor": [[84, 101], ["warnings.filterwarnings", "__init__.tensor2np", "numpy.clip", "color.rgb2lab", "__init__.np2tensor", "__init__.im2tensor", "color.lab2rgb", "rgb_back.astype", "numpy.isclose", "__init__.im2tensor", "lab.astype", "numpy.prod"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2np", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.rgb2lab", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.np2tensor", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.im2tensor", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.im2tensor"], ["", "def", "tensorlab2tensor", "(", "lab_tensor", ",", "return_inbnd", "=", "False", ")", ":", "\n", "    ", "from", "skimage", "import", "color", "\n", "import", "warnings", "\n", "warnings", ".", "filterwarnings", "(", "\"ignore\"", ")", "\n", "\n", "lab", "=", "tensor2np", "(", "lab_tensor", ")", "*", "100.", "\n", "lab", "[", ":", ",", ":", ",", "0", "]", "=", "lab", "[", ":", ",", ":", ",", "0", "]", "+", "50", "\n", "\n", "rgb_back", "=", "255.", "*", "np", ".", "clip", "(", "color", ".", "lab2rgb", "(", "lab", ".", "astype", "(", "'float'", ")", ")", ",", "0", ",", "1", ")", "\n", "if", "(", "return_inbnd", ")", ":", "\n", "# convert back to lab, see if we match", "\n", "        ", "lab_back", "=", "color", ".", "rgb2lab", "(", "rgb_back", ".", "astype", "(", "'uint8'", ")", ")", "\n", "mask", "=", "1.", "*", "np", ".", "isclose", "(", "lab_back", ",", "lab", ",", "atol", "=", "2.", ")", "\n", "mask", "=", "np2tensor", "(", "np", ".", "prod", "(", "mask", ",", "axis", "=", "2", ")", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "return", "(", "im2tensor", "(", "rgb_back", ")", ",", "mask", ")", "\n", "", "else", ":", "\n", "        ", "return", "im2tensor", "(", "rgb_back", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2im": [[151, 156], ["image_tensor[].cpu().float().numpy", "image_tensor[].cpu().float().numpy.astype", "image_tensor[].cpu().float", "numpy.transpose", "image_tensor[].cpu"], "function", ["None"], ["", "def", "tensor2im", "(", "image_tensor", ",", "imtype", "=", "np", ".", "uint8", ",", "cent", "=", "1.", ",", "factor", "=", "255.", "/", "2.", ")", ":", "\n", "# def tensor2im(image_tensor, imtype=np.uint8, cent=1., factor=1.):", "\n", "    ", "image_numpy", "=", "image_tensor", "[", "0", "]", ".", "cpu", "(", ")", ".", "float", "(", ")", ".", "numpy", "(", ")", "\n", "image_numpy", "=", "(", "np", ".", "transpose", "(", "image_numpy", ",", "(", "1", ",", "2", ",", "0", ")", ")", "+", "cent", ")", "*", "factor", "\n", "return", "image_numpy", ".", "astype", "(", "imtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.im2tensor": [[157, 161], ["torch.Tensor", "[].transpose"], "function", ["None"], ["", "def", "im2tensor", "(", "image", ",", "imtype", "=", "np", ".", "uint8", ",", "cent", "=", "1.", ",", "factor", "=", "255.", "/", "2.", ")", ":", "\n", "# def im2tensor(image, imtype=np.uint8, cent=1., factor=1.):", "\n", "    ", "return", "torch", ".", "Tensor", "(", "(", "image", "/", "factor", "-", "cent", ")", "\n", "[", ":", ",", ":", ",", ":", ",", "np", ".", "newaxis", "]", ".", "transpose", "(", "(", "3", ",", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.tensor2vec": [[115, 117], ["vector_tensor.data.cpu().numpy", "vector_tensor.data.cpu"], "function", ["None"], ["", "def", "tensor2vec", "(", "vector_tensor", ")", ":", "\n", "    ", "return", "vector_tensor", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "[", ":", ",", ":", ",", "0", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.__init__.voc_ap": [[118, 150], ["numpy.arange", "numpy.concatenate", "numpy.concatenate", "range", "numpy.sum", "numpy.maximum", "numpy.where", "numpy.sum", "numpy.max"], "function", ["None"], ["", "def", "voc_ap", "(", "rec", ",", "prec", ",", "use_07_metric", "=", "False", ")", ":", "\n", "    ", "\"\"\" ap = voc_ap(rec, prec, [use_07_metric])\n    Compute VOC AP given precision and recall.\n    If use_07_metric is true, uses the\n    VOC 07 11 point method (default:False).\n    \"\"\"", "\n", "if", "use_07_metric", ":", "\n", "# 11 point metric", "\n", "        ", "ap", "=", "0.", "\n", "for", "t", "in", "np", ".", "arange", "(", "0.", ",", "1.1", ",", "0.1", ")", ":", "\n", "            ", "if", "np", ".", "sum", "(", "rec", ">=", "t", ")", "==", "0", ":", "\n", "                ", "p", "=", "0", "\n", "", "else", ":", "\n", "                ", "p", "=", "np", ".", "max", "(", "prec", "[", "rec", ">=", "t", "]", ")", "\n", "", "ap", "=", "ap", "+", "p", "/", "11.", "\n", "", "", "else", ":", "\n", "# correct AP calculation", "\n", "# first append sentinel values at the end", "\n", "        ", "mrec", "=", "np", ".", "concatenate", "(", "(", "[", "0.", "]", ",", "rec", ",", "[", "1.", "]", ")", ")", "\n", "mpre", "=", "np", ".", "concatenate", "(", "(", "[", "0.", "]", ",", "prec", ",", "[", "0.", "]", ")", ")", "\n", "\n", "# compute the precision envelope", "\n", "for", "i", "in", "range", "(", "mpre", ".", "size", "-", "1", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "mpre", "[", "i", "-", "1", "]", "=", "np", ".", "maximum", "(", "mpre", "[", "i", "-", "1", "]", ",", "mpre", "[", "i", "]", ")", "\n", "\n", "# to calculate area under PR curve, look for points", "\n", "# where X axis (recall) changes value", "\n", "", "i", "=", "np", ".", "where", "(", "mrec", "[", "1", ":", "]", "!=", "mrec", "[", ":", "-", "1", "]", ")", "[", "0", "]", "\n", "\n", "# and sum (\\Delta recall) * prec", "\n", "ap", "=", "np", ".", "sum", "(", "(", "mrec", "[", "i", "+", "1", "]", "-", "mrec", "[", "i", "]", ")", "*", "mpre", "[", "i", "+", "1", "]", ")", "\n", "", "return", "ap", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.__init__": [[8, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", ";", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.name": [[11, 13], ["None"], "methods", ["None"], ["", "def", "name", "(", "self", ")", ":", "\n", "        ", "return", "'BaseModel'", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.initialize": [[14, 17], ["None"], "methods", ["None"], ["", "def", "initialize", "(", "self", ",", "use_gpu", "=", "True", ",", "gpu_ids", "=", "[", "0", "]", ")", ":", "\n", "        ", "self", ".", "use_gpu", "=", "use_gpu", "\n", "self", ".", "gpu_ids", "=", "gpu_ids", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.forward": [[18, 20], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.get_image_paths": [[52, 54], ["None"], "methods", ["None"], ["", "def", "get_image_paths", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "image_paths", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.optimize_parameters": [[24, 26], ["None"], "methods", ["None"], ["", "def", "optimize_parameters", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.get_current_visuals": [[27, 29], ["None"], "methods", ["None"], ["", "def", "get_current_visuals", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.get_current_errors": [[30, 32], ["None"], "methods", ["None"], ["", "def", "get_current_errors", "(", "self", ")", ":", "\n", "        ", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save": [[33, 35], ["None"], "methods", ["None"], ["", "def", "save", "(", "self", ",", "label", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save_network": [[37, 41], ["os.path.join", "torch.save", "network.state_dict"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save"], ["", "def", "save_network", "(", "self", ",", "network", ",", "path", ",", "network_label", ",", "epoch_label", ")", ":", "\n", "        ", "save_filename", "=", "'%s_net_%s.pth'", "%", "(", "epoch_label", ",", "network_label", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "save_filename", ")", "\n", "torch", ".", "save", "(", "network", ".", "state_dict", "(", ")", ",", "save_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.load_network": [[43, 48], ["os.path.join", "print", "network.load_state_dict", "torch.load"], "methods", ["None"], ["", "def", "load_network", "(", "self", ",", "network", ",", "network_label", ",", "epoch_label", ")", ":", "\n", "        ", "save_filename", "=", "'%s_net_%s.pth'", "%", "(", "epoch_label", ",", "network_label", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "save_filename", ")", "\n", "print", "(", "'Loading network from %s'", "%", "save_path", ")", "\n", "network", ".", "load_state_dict", "(", "torch", ".", "load", "(", "save_path", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.update_learning_rate": [[49, 51], ["None"], "methods", ["None"], ["", "def", "update_learning_rate", "(", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save_done": [[55, 58], ["np.save", "np.savetxt", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save"], ["", "def", "save_done", "(", "self", ",", "flag", "=", "False", ")", ":", "\n", "        ", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'done_flag'", ")", ",", "flag", ")", "\n", "np", ".", "savetxt", "(", "os", ".", "path", ".", "join", "(", "self", ".", "save_dir", ",", "'done_flag'", ")", ",", "[", "flag", ",", "]", ",", "fmt", "=", "'%i'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.is_image_file": [[18, 20], ["any", "filename.endswith"], "function", ["None"], ["def", "is_image_file", "(", "filename", ")", ":", "\n", "    ", "return", "any", "(", "filename", ".", "endswith", "(", "extension", ")", "for", "extension", "in", "IMG_EXTENSIONS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.is_binary_file": [[22, 24], ["any", "filename.endswith"], "function", ["None"], ["", "def", "is_binary_file", "(", "filename", ")", ":", "\n", "    ", "return", "any", "(", "filename", ".", "endswith", "(", "extension", ")", "for", "extension", "in", "BINARY_EXTENSIONS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common._get_paths_from_images": [[26, 36], ["os.path.isdir", "sorted", "os.walk", "sorted", "common.is_image_file", "os.path.join", "images.append"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file"], ["", "def", "_get_paths_from_images", "(", "path", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "isdir", "(", "path", ")", ",", "'[Error] [%s] is not a valid directory'", "%", "path", "\n", "images", "=", "[", "]", "\n", "for", "dirpath", ",", "_", ",", "fnames", "in", "sorted", "(", "os", ".", "walk", "(", "path", ")", ")", ":", "\n", "        ", "for", "fname", "in", "sorted", "(", "fnames", ")", ":", "\n", "            ", "if", "is_image_file", "(", "fname", ")", ":", "\n", "                ", "img_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "fname", ")", "\n", "images", ".", "append", "(", "img_path", ")", "\n", "", "", "", "assert", "images", ",", "'[%s] has no valid image file'", "%", "path", "\n", "return", "images", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common._get_paths_from_binary": [[38, 48], ["os.path.isdir", "sorted", "os.walk", "sorted", "common.is_binary_file", "os.path.join", "files.append"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.is_binary_file"], ["", "def", "_get_paths_from_binary", "(", "path", ")", ":", "\n", "    ", "assert", "os", ".", "path", ".", "isdir", "(", "path", ")", ",", "'[Error] [%s] is not a valid directory'", "%", "path", "\n", "files", "=", "[", "]", "\n", "for", "dirpath", ",", "_", ",", "fnames", "in", "sorted", "(", "os", ".", "walk", "(", "path", ")", ")", ":", "\n", "        ", "for", "fname", "in", "sorted", "(", "fnames", ")", ":", "\n", "            ", "if", "is_binary_file", "(", "fname", ")", ":", "\n", "                ", "binary_path", "=", "os", ".", "path", ".", "join", "(", "dirpath", ",", "fname", ")", "\n", "files", ".", "append", "(", "binary_path", ")", "\n", "", "", "", "assert", "files", ",", "'[%s] has no valid binary file'", "%", "path", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_image_paths": [[50, 77], ["sorted", "common._get_paths_from_images", "sorted", "NotImplementedError", "dataroot.find", "common._get_paths_from_binary", "os.path.exists", "print", "os.makedirs", "sorted", "tqdm.tqdm", "print", "common._get_paths_from_images", "imageio.imread", "os.path.basename", "numpy.save", "os.path.splitext", "v.replace", "os.path.join", "os.path.basename"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common._get_paths_from_images", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common._get_paths_from_binary", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common._get_paths_from_images", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.modules.base_model.BaseModel.save"], ["", "def", "get_image_paths", "(", "data_type", ",", "dataroot", ")", ":", "\n", "    ", "paths", "=", "None", "\n", "if", "dataroot", "is", "not", "None", ":", "\n", "        ", "if", "data_type", "==", "'img'", ":", "\n", "            ", "paths", "=", "sorted", "(", "_get_paths_from_images", "(", "dataroot", ")", ")", "\n", "", "elif", "data_type", "==", "'npy'", ":", "\n", "            ", "if", "dataroot", ".", "find", "(", "'_npy'", ")", "<", "0", ":", "\n", "                ", "old_dir", "=", "dataroot", "\n", "dataroot", "=", "dataroot", "+", "'_npy'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dataroot", ")", ":", "\n", "                    ", "print", "(", "'===> Creating binary files in [%s]'", "%", "dataroot", ")", "\n", "os", ".", "makedirs", "(", "dataroot", ")", "\n", "img_paths", "=", "sorted", "(", "_get_paths_from_images", "(", "old_dir", ")", ")", "\n", "path_bar", "=", "tqdm", "(", "img_paths", ")", "\n", "for", "v", "in", "path_bar", ":", "\n", "                        ", "img", "=", "imageio", ".", "imread", "(", "v", ",", "pilmode", "=", "'RGB'", ")", "\n", "ext", "=", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "v", ")", ")", "[", "-", "1", "]", "\n", "name_sep", "=", "os", ".", "path", ".", "basename", "(", "v", ".", "replace", "(", "ext", ",", "'.npy'", ")", ")", "\n", "np", ".", "save", "(", "os", ".", "path", ".", "join", "(", "dataroot", ",", "name_sep", ")", ",", "img", ")", "\n", "", "", "else", ":", "\n", "                    ", "print", "(", "'===> Binary files already exists in [%s]. Skip binary files generation.'", "%", "dataroot", ")", "\n", "\n", "", "", "paths", "=", "sorted", "(", "_get_paths_from_binary", "(", "dataroot", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "\"[Error] Data_type [%s] is not recognized.\"", "%", "data_type", ")", "\n", "", "", "return", "paths", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.find_benchmark": [[79, 87], ["bm_list.index", "dataroot.find", "sum"], "function", ["None"], ["", "def", "find_benchmark", "(", "dataroot", ")", ":", "\n", "    ", "bm_list", "=", "[", "dataroot", ".", "find", "(", "bm", ")", ">=", "0", "for", "bm", "in", "BENCHMARK", "]", "\n", "if", "not", "sum", "(", "bm_list", ")", "==", "0", ":", "\n", "        ", "bm_idx", "=", "bm_list", ".", "index", "(", "True", ")", "\n", "bm_name", "=", "BENCHMARK", "[", "bm_idx", "]", "\n", "", "else", ":", "\n", "        ", "bm_name", "=", "'MyImage'", "\n", "", "return", "bm_name", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.read_img": [[89, 102], ["imageio.imread", "numpy.expand_dims", "data_type.find", "numpy.load"], "function", ["None"], ["", "def", "read_img", "(", "path", ",", "data_type", ")", ":", "\n", "# read image by misc or from .npy", "\n", "# return: Numpy float32, HWC, RGB, [0,255]", "\n", "    ", "if", "data_type", "==", "'img'", ":", "\n", "        ", "img", "=", "imageio", ".", "imread", "(", "path", ",", "pilmode", "=", "'RGB'", ")", "\n", "", "elif", "data_type", ".", "find", "(", "'npy'", ")", ">=", "0", ":", "\n", "        ", "img", "=", "np", ".", "load", "(", "path", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "img", "=", "np", ".", "expand_dims", "(", "img", ",", "axis", "=", "2", ")", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.np2Tensor": [[108, 119], ["numpy.ascontiguousarray", "torch.from_numpy().float", "torch.from_numpy().float.mul_", "common.np2Tensor._np2Tensor"], "function", ["None"], ["", "def", "np2Tensor", "(", "l", ",", "rgb_range", ")", ":", "\n", "    ", "def", "_np2Tensor", "(", "img", ")", ":", "\n", "# if img.shape[2] == 3: # for opencv imread", "\n", "#     img = img[:, :, [2, 1, 0]]", "\n", "        ", "np_transpose", "=", "np", ".", "ascontiguousarray", "(", "img", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", ")", "\n", "tensor", "=", "torch", ".", "from_numpy", "(", "np_transpose", ")", ".", "float", "(", ")", "\n", "tensor", ".", "mul_", "(", "rgb_range", "/", "255.", ")", "\n", "\n", "return", "tensor", "\n", "\n", "", "return", "[", "_np2Tensor", "(", "_l", ")", "for", "_l", "in", "l", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_patch": [[121, 142], ["random.randrange", "random.randrange", "random.randrange", "random.randrange"], "function", ["None"], ["", "def", "get_patch", "(", "img_in", ",", "img_tar", ",", "patch_size", ",", "scale", ")", ":", "\n", "    ", "ih", ",", "iw", "=", "img_in", ".", "shape", "[", ":", "2", "]", "\n", "oh", ",", "ow", "=", "img_tar", ".", "shape", "[", ":", "2", "]", "\n", "\n", "ip", "=", "patch_size", "\n", "\n", "if", "ih", "==", "oh", ":", "\n", "        ", "tp", "=", "ip", "\n", "ix", "=", "random", ".", "randrange", "(", "0", ",", "iw", "-", "ip", "+", "1", ")", "\n", "iy", "=", "random", ".", "randrange", "(", "0", ",", "ih", "-", "ip", "+", "1", ")", "\n", "tx", ",", "ty", "=", "ix", ",", "iy", "\n", "", "else", ":", "\n", "        ", "tp", "=", "ip", "*", "scale", "\n", "ix", "=", "random", ".", "randrange", "(", "0", ",", "iw", "-", "ip", "+", "1", ")", "\n", "iy", "=", "random", ".", "randrange", "(", "0", ",", "ih", "-", "ip", "+", "1", ")", "\n", "tx", ",", "ty", "=", "scale", "*", "ix", ",", "scale", "*", "iy", "\n", "\n", "", "img_in", "=", "img_in", "[", "iy", ":", "iy", "+", "ip", ",", "ix", ":", "ix", "+", "ip", ",", ":", "]", "\n", "img_tar", "=", "img_tar", "[", "ty", ":", "ty", "+", "tp", ",", "tx", ":", "tx", "+", "tp", ",", ":", "]", "\n", "\n", "return", "img_in", ",", "img_tar", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.center_crop": [[143, 157], ["None"], "function", ["None"], ["", "def", "center_crop", "(", "img_in", ",", "img_tar", ",", "patch_size", "=", "256", ")", ":", "\n", "    ", "ch", ",", "cw", "=", "patch_size", ",", "patch_size", "\n", "\n", "img_in_w", ",", "img_in_h", "=", "img_in", ".", "shape", "[", "0", "]", ",", "img_in", ".", "shape", "[", "1", "]", "\n", "img_in_c1", "=", "(", "img_in_w", "-", "cw", ")", "//", "2", "\n", "img_in_c2", "=", "(", "img_in_h", "-", "ch", ")", "//", "2", "\n", "img_in", "=", "img_in", "[", "img_in_c1", ":", "img_in_c1", "+", "cw", ",", "img_in_c2", ":", "img_in_c2", "+", "ch", ",", ":", "]", "\n", "\n", "img_tar_w", ",", "img_tar_h", "=", "img_tar", ".", "shape", "[", "0", "]", ",", "img_tar", ".", "shape", "[", "1", "]", "\n", "img_tar_c1", "=", "(", "img_tar_w", "-", "cw", ")", "//", "2", "\n", "img_tar_c2", "=", "(", "img_tar_h", "-", "ch", ")", "//", "2", "\n", "img_tar", "=", "img_tar", "[", "img_tar_c1", ":", "img_tar_c1", "+", "cw", ",", "img_tar_c2", ":", "img_tar_c2", "+", "ch", ",", ":", "]", "\n", "\n", "return", "img_in", ",", "img_tar", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.add_noise": [[159, 175], ["float", "x_noise.clip().astype.clip().astype", "numpy.random.normal", "noises.round.round", "x.astype", "noises.round.astype", "x_noise.clip().astype.clip", "numpy.random.poisson", "noises.round.mean().mean", "noises.round.mean"], "function", ["None"], ["", "def", "add_noise", "(", "x", ",", "noise", "=", "'.'", ")", ":", "\n", "    ", "if", "noise", "is", "not", "'.'", ":", "\n", "        ", "noise_type", "=", "noise", "[", "0", "]", "\n", "noise_value", "=", "float", "(", "noise", "[", "1", ":", "]", ")", "\n", "if", "noise_type", "==", "'G'", ":", "\n", "            ", "noises", "=", "np", ".", "random", ".", "normal", "(", "scale", "=", "noise_value", ",", "size", "=", "x", ".", "shape", ")", "\n", "noises", "=", "noises", ".", "round", "(", ")", "\n", "", "elif", "noise_type", "==", "'S'", ":", "\n", "            ", "noises", "=", "np", ".", "random", ".", "poisson", "(", "x", "*", "noise_value", ")", "/", "noise_value", "\n", "noises", "=", "noises", "-", "noises", ".", "mean", "(", "axis", "=", "0", ")", ".", "mean", "(", "axis", "=", "0", ")", "\n", "\n", "", "x_noise", "=", "x", ".", "astype", "(", "np", ".", "int16", ")", "+", "noises", ".", "astype", "(", "np", ".", "int16", ")", "\n", "x_noise", "=", "x_noise", ".", "clip", "(", "0", ",", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "return", "x_noise", "\n", "", "else", ":", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.generate_LR": [[176, 180], ["utils.utils_image.imresize_np().clip", "utils.utils_image.imresize_np"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.utils.utils_image.imresize_np"], ["", "", "def", "generate_LR", "(", "x", ",", "sf", ")", ":", "\n", "    ", "lr", "=", "utils_image", ".", "imresize_np", "(", "x", ",", "scale", "=", "1", "/", "sf", ")", ".", "clip", "(", "0", ",", "255", ")", "\n", "\n", "return", "lr", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.augment": [[181, 194], ["common.augment._augment"], "function", ["None"], ["", "def", "augment", "(", "img_list", ",", "hflip", "=", "True", ",", "rot", "=", "True", ")", ":", "\n", "# horizontal flip OR rotate", "\n", "    ", "hflip", "=", "hflip", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "vflip", "=", "rot", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "rot90", "=", "rot", "and", "random", ".", "random", "(", ")", "<", "0.5", "\n", "\n", "def", "_augment", "(", "img", ")", ":", "\n", "        ", "if", "hflip", ":", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "if", "vflip", ":", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "if", "rot90", ":", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "\n", "", "return", "[", "_augment", "(", "img", ")", "for", "img", "in", "img_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.augment_img": [[195, 212], ["numpy.flipud", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.flipud", "numpy.rot90", "numpy.rot90", "numpy.rot90", "numpy.flipud", "numpy.rot90"], "function", ["None"], ["", "def", "augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ")", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "img", ")", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.augment_img_np3": [[213, 239], ["img.transpose.transpose", "img.transpose.transpose", "img.transpose.transpose", "img.transpose.transpose"], "function", ["None"], ["", "", "def", "augment_img_np3", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "return", "img", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.modcrop": [[241, 254], ["numpy.copy", "ValueError"], "function", ["None"], ["", "", "def", "modcrop", "(", "img_in", ",", "scale", ")", ":", "\n", "    ", "img", "=", "np", ".", "copy", "(", "img_in", ")", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "H", ",", "W", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", "]", "\n", "", "elif", "img", ".", "ndim", "==", "3", ":", "\n", "        ", "H", ",", "W", ",", "C", "=", "img", ".", "shape", "\n", "H_r", ",", "W_r", "=", "H", "%", "scale", ",", "W", "%", "scale", "\n", "img", "=", "img", "[", ":", "H", "-", "H_r", ",", ":", "W", "-", "W_r", ",", ":", "]", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'Wrong img ndim: [%d].'", "%", "img", ".", "ndim", ")", "\n", "", "return", "img", "", "", ""]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.TrainDataset.__init__": [[17, 36], ["torch.utils.data.dataset.Dataset.__init__", "isinstance", "torchvision.Compose", "torchvision.Compose", "torchvision.Compose", "torchvision.RandomCrop", "torchvision.RandomCrop", "torchvision.RandomCrop", "os.path.join", "torchvision.RandomVerticalFlip", "torchvision.RandomVerticalFlip", "torchvision.RandomVerticalFlip", "torchvision.RandomHorizontalFlip", "torchvision.RandomHorizontalFlip", "torchvision.RandomHorizontalFlip", "torchvision.RandomCrop", "torchvision.RandomCrop", "torchvision.RandomCrop", "os.listdir", "data_loader.utils.is_image_file"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file"], ["    ", "def", "__init__", "(", "self", ",", "noisy_dir", ",", "crop_size", ",", "upscale_factor", "=", "4", ",", "cropped", "=", "False", ",", "flips", "=", "False", ",", "rotations", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "TrainDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# get all directories used for training", "\n", "if", "isinstance", "(", "noisy_dir", ",", "str", ")", ":", "\n", "            ", "noisy_dir", "=", "[", "noisy_dir", "]", "\n", "", "self", ".", "files", "=", "[", "]", "\n", "for", "n_dir", "in", "noisy_dir", ":", "\n", "            ", "self", ".", "files", "+=", "[", "join", "(", "n_dir", ",", "x", ")", "for", "x", "in", "listdir", "(", "n_dir", ")", "if", "utils", ".", "is_image_file", "(", "x", ")", "]", "\n", "# intitialize image transformations and variables", "\n", "", "self", ".", "input_transform", "=", "T", ".", "Compose", "(", "[", "\n", "T", ".", "RandomVerticalFlip", "(", "0.5", "if", "flips", "else", "0.0", ")", ",", "\n", "T", ".", "RandomHorizontalFlip", "(", "0.5", "if", "flips", "else", "0.0", ")", ",", "\n", "T", ".", "RandomCrop", "(", "crop_size", ")", "\n", "]", ")", "\n", "self", ".", "crop_transform", "=", "T", ".", "RandomCrop", "(", "crop_size", "//", "upscale_factor", ")", "\n", "self", ".", "upscale_factor", "=", "upscale_factor", "\n", "self", ".", "cropped", "=", "cropped", "\n", "self", ".", "rotations", "=", "rotations", "\n", "self", ".", "repeat", "=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.TrainDataset.__getitem__": [[37, 52], ["DS_dataset.TrainDataset._get_index", "DS_dataset.TrainDataset.input_transform", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "data_loader.utils.imresize", "PIL.Image.open", "random.choice", "torchvision.rotate", "torchvision.rotate", "torchvision.rotate", "DS_dataset.TrainDataset.crop_transform", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._get_index", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.imresize"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "# get downscaled and cropped image (if necessary)", "\n", "        ", "idx", "=", "self", ".", "_get_index", "(", "idx", ")", "\n", "noisy_image", "=", "self", ".", "input_transform", "(", "Image", ".", "open", "(", "self", ".", "files", "[", "idx", "]", ")", ")", "\n", "if", "self", ".", "rotations", ":", "\n", "            ", "angle", "=", "random", ".", "choice", "(", "[", "0", ",", "90", ",", "180", ",", "270", "]", ")", "\n", "noisy_image", "=", "TF", ".", "rotate", "(", "noisy_image", ",", "angle", ")", "\n", "", "if", "self", ".", "cropped", ":", "\n", "            ", "cropped_image", "=", "self", ".", "crop_transform", "(", "noisy_image", ")", "\n", "", "noisy_image", "=", "TF", ".", "to_tensor", "(", "noisy_image", ")", "\n", "resized_image", "=", "utils", ".", "imresize", "(", "noisy_image", ",", "1.0", "/", "self", ".", "upscale_factor", ",", "True", ")", "\n", "if", "self", ".", "cropped", ":", "\n", "            ", "return", "resized_image", ",", "TF", ".", "to_tensor", "(", "cropped_image", ")", "\n", "", "else", ":", "\n", "            ", "return", "resized_image", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.TrainDataset.__len__": [[53, 55], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "(", "len", "(", "self", ".", "files", ")", "*", "self", ".", "repeat", ")", "+", "250", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.TrainDataset._get_index": [[56, 58], ["len"], "methods", ["None"], ["", "def", "_get_index", "(", "self", ",", "idx", ")", ":", "\n", "        ", "return", "idx", "%", "len", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.DiscDataset.__init__": [[61, 70], ["torch.utils.data.dataset.Dataset.__init__", "torchvision.Compose", "torchvision.Compose", "torchvision.Compose", "os.path.join", "os.listdir", "data_loader.utils.is_image_file", "torchvision.RandomVerticalFlip", "torchvision.RandomVerticalFlip", "torchvision.RandomVerticalFlip", "torchvision.RandomHorizontalFlip", "torchvision.RandomHorizontalFlip", "torchvision.RandomHorizontalFlip", "torchvision.RandomCrop", "torchvision.RandomCrop", "torchvision.RandomCrop"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file"], ["    ", "def", "__init__", "(", "self", ",", "dataset_dir", ",", "crop_size", ",", "upscale_factor", "=", "4", ",", "flips", "=", "False", ",", "rotations", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "DiscDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "files", "=", "[", "join", "(", "dataset_dir", ",", "x", ")", "for", "x", "in", "listdir", "(", "dataset_dir", ")", "if", "utils", ".", "is_image_file", "(", "x", ")", "]", "\n", "self", ".", "input_transform", "=", "T", ".", "Compose", "(", "[", "\n", "T", ".", "RandomVerticalFlip", "(", "0.5", "if", "flips", "else", "0.0", ")", ",", "\n", "T", ".", "RandomHorizontalFlip", "(", "0.5", "if", "flips", "else", "0.0", ")", ",", "\n", "T", ".", "RandomCrop", "(", "crop_size", "//", "upscale_factor", ")", "\n", "]", ")", "\n", "self", ".", "rotations", "=", "rotations", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.DiscDataset.__getitem__": [[71, 78], ["DS_dataset.DiscDataset.input_transform", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "PIL.Image.open", "random.choice", "torchvision.rotate", "torchvision.rotate", "torchvision.rotate"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# get real image for discriminator (same as cropped in TrainDataset)", "\n", "        ", "image", "=", "self", ".", "input_transform", "(", "Image", ".", "open", "(", "self", ".", "files", "[", "index", "]", ")", ")", "\n", "if", "self", ".", "rotations", ":", "\n", "            ", "angle", "=", "random", ".", "choice", "(", "[", "0", ",", "90", ",", "180", ",", "270", "]", ")", "\n", "image", "=", "TF", ".", "rotate", "(", "image", ",", "angle", ")", "\n", "", "return", "TF", ".", "to_tensor", "(", "image", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.DiscDataset.__len__": [[79, 81], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.ValDataset.__init__": [[84, 93], ["torch.utils.data.dataset.Dataset.__init__", "os.path.join", "os.listdir", "data_loader.utils.is_image_file", "os.path.join", "os.listdir", "data_loader.utils.is_image_file"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file"], ["    ", "def", "__init__", "(", "self", ",", "hr_dir", ",", "lr_dir", ",", "upscale_factor", ",", "crop_size_val", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "ValDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hr_files", "=", "[", "join", "(", "hr_dir", ",", "x", ")", "for", "x", "in", "listdir", "(", "hr_dir", ")", "if", "utils", ".", "is_image_file", "(", "x", ")", "]", "\n", "self", ".", "upscale_factor", "=", "upscale_factor", "\n", "self", ".", "crop_size", "=", "crop_size_val", "\n", "if", "lr_dir", "is", "None", ":", "\n", "            ", "self", ".", "lr_files", "=", "None", "\n", "", "else", ":", "\n", "            ", "self", ".", "lr_files", "=", "[", "join", "(", "lr_dir", ",", "x", ")", "for", "x", "in", "listdir", "(", "lr_dir", ")", "if", "utils", ".", "is_image_file", "(", "x", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.ValDataset.__getitem__": [[94, 111], ["PIL.Image.open", "data_loader.utils.calculate_valid_crop_size", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "data_loader.utils.imresize", "min", "min", "torchvision.CenterCrop", "torchvision.CenterCrop", "torchvision.CenterCrop", "PIL.Image.open", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.to_tensor", "torchvision.CenterCrop", "torchvision.CenterCrop", "torchvision.CenterCrop", "torchvision.CenterCrop", "torchvision.CenterCrop", "torchvision.CenterCrop"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_valid_crop_size", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.imresize"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "# get downscaled, cropped and gt (if available) image", "\n", "        ", "hr_image", "=", "Image", ".", "open", "(", "self", ".", "hr_files", "[", "index", "]", ")", "\n", "w", ",", "h", "=", "hr_image", ".", "size", "\n", "cs", "=", "utils", ".", "calculate_valid_crop_size", "(", "min", "(", "w", ",", "h", ")", ",", "self", ".", "upscale_factor", ")", "\n", "if", "self", ".", "crop_size", "is", "not", "None", ":", "\n", "            ", "cs", "=", "min", "(", "cs", ",", "self", ".", "crop_size", ")", "\n", "", "cropped_image", "=", "TF", ".", "to_tensor", "(", "T", ".", "CenterCrop", "(", "cs", "//", "self", ".", "upscale_factor", ")", "(", "hr_image", ")", ")", "\n", "hr_image", "=", "T", ".", "CenterCrop", "(", "cs", ")", "(", "hr_image", ")", "\n", "hr_image", "=", "TF", ".", "to_tensor", "(", "hr_image", ")", "\n", "resized_image", "=", "utils", ".", "imresize", "(", "hr_image", ",", "1.0", "/", "self", ".", "upscale_factor", ",", "True", ")", "\n", "if", "self", ".", "lr_files", "is", "None", ":", "\n", "            ", "return", "resized_image", ",", "cropped_image", ",", "resized_image", "\n", "", "else", ":", "\n", "            ", "lr_image", "=", "Image", ".", "open", "(", "self", ".", "lr_files", "[", "index", "]", ")", "\n", "lr_image", "=", "TF", ".", "to_tensor", "(", "T", ".", "CenterCrop", "(", "cs", "//", "self", ".", "upscale_factor", ")", "(", "lr_image", ")", ")", "\n", "return", "resized_image", ",", "lr_image", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.ValDataset.__len__": [[112, 114], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "hr_files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.DS_dataset.imshow": [[115, 119], ["img.numpy", "matplotlib.imshow", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.imshow"], ["", "", "def", "imshow", "(", "img", ")", ":", "\n", "    ", "npimg", "=", "img", ".", "numpy", "(", ")", "\n", "#print('npimg:', npimg.shape)", "\n", "plt", ".", "imshow", "(", "np", ".", "transpose", "(", "npimg", ",", "(", "1", ",", "2", ",", "0", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__": [[14, 59], ["torch.utils.data.Dataset.__init__", "data_loader.common.get_image_paths", "data_loader.common.get_image_paths", "data_loader.common.get_image_paths", "data_loader.common.get_image_paths", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__init__", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_image_paths", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_image_paths", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_image_paths", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_image_paths"], ["def", "__init__", "(", "self", ",", "dataroot", ",", "is_train", ",", "scale", ",", "patch_size", ",", "rgb_range", ",", "noise_std", ")", ":", "\n", "        ", "super", "(", "LRHRDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "train", "=", "is_train", "\n", "self", ".", "scale", "=", "scale", "\n", "self", ".", "patch_size", "=", "patch_size", "\n", "self", ".", "rgb_range", "=", "rgb_range", "\n", "self", ".", "noise_std", "=", "noise_std", "\n", "self", ".", "paths_HR", "=", "None", "\n", "self", ".", "paths_LR", "=", "None", "\n", "dataroot_HR", "=", "[", "]", "\n", "dataroot_LR", "=", "[", "]", "\n", "\n", "if", "self", ".", "train", ":", "\n", "            ", "self", ".", "dataroot_hr", "=", "dataroot", "+", "'DF2K/generated/HR/'", "\n", "self", ".", "dataroot_lr", "=", "dataroot", "+", "'DF2K/generated/LR/'", "\n", "\n", "# read image list from image/binary files", "\n", "self", ".", "paths_imgs_hr", "=", "common", ".", "get_image_paths", "(", "\"img\"", ",", "self", ".", "dataroot_hr", ")", "\n", "self", ".", "paths_imgs_lr", "=", "common", ".", "get_image_paths", "(", "\"img\"", ",", "self", ".", "dataroot_lr", ")", "\n", "\n", "HR_list", "=", "dataroot_HR", "+", "self", ".", "paths_imgs_hr", "\n", "LR_list", "=", "dataroot_LR", "+", "self", ".", "paths_imgs_lr", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "dataroot_hr", "=", "dataroot", "+", "'DF2K/valid/clean/'", "\n", "self", ".", "dataroot_lr", "=", "dataroot", "+", "'DF2K/valid/corrupted/'", "\n", "\n", "self", ".", "paths_imgs_hr", "=", "common", ".", "get_image_paths", "(", "\"img\"", ",", "self", ".", "dataroot_hr", ")", "\n", "self", ".", "paths_imgs_lr", "=", "common", ".", "get_image_paths", "(", "\"img\"", ",", "self", ".", "dataroot_lr", ")", "\n", "\n", "HR_list", "=", "dataroot_HR", "+", "self", ".", "paths_imgs_hr", "\n", "LR_list", "=", "dataroot_LR", "+", "self", ".", "paths_imgs_lr", "\n", "\n", "# change the length of train dataset (influence the number of iterations in each epoch)", "\n", "", "self", ".", "repeat", "=", "3", "\n", "\n", "self", ".", "paths_HR", "=", "HR_list", "\n", "self", ".", "paths_LR", "=", "LR_list", "\n", "\n", "assert", "self", ".", "paths_HR", ",", "'[Error] HR paths are empty.'", "\n", "if", "self", ".", "paths_LR", "and", "self", ".", "paths_HR", ":", "\n", "            ", "assert", "len", "(", "self", ".", "paths_LR", ")", "==", "len", "(", "self", ".", "paths_HR", ")", ",", "'[Error] HR: [%d] and LR: [%d] have different number of images.'", "%", "(", "\n", "len", "(", "self", ".", "paths_LR", ")", ",", "len", "(", "self", ".", "paths_HR", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__getitem__": [[60, 71], ["LRHR_dataset.LRHRDataset._load_file", "data_loader.common.np2Tensor", "torch.tensor", "LRHR_dataset.LRHRDataset._get_patch", "LRHR_dataset.LRHRDataset._get_patch"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._load_file", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.np2Tensor", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._get_patch", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._get_patch"], ["", "", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "lr", ",", "hr", ",", "lr_path", ",", "hr_path", "=", "self", ".", "_load_file", "(", "idx", ")", "\n", "\n", "if", "self", ".", "train", ":", "\n", "            ", "lr", ",", "hr", ",", "sigma", "=", "self", ".", "_get_patch", "(", "lr", ",", "hr", ")", "\n", "", "else", ":", "\n", "            ", "lr", ",", "hr", ",", "sigma", "=", "self", ".", "_get_patch", "(", "lr", ",", "hr", ")", "\n", "\n", "", "lr_tensor", ",", "hr_tensor", "=", "common", ".", "np2Tensor", "(", "[", "lr", ",", "hr", "]", ",", "self", ".", "rgb_range", ")", "\n", "sigma_tensor", "=", "torch", ".", "tensor", "(", "sigma", ")", "\n", "return", "{", "'LR'", ":", "lr_tensor", ",", "'HR'", ":", "hr_tensor", ",", "'sigma'", ":", "sigma_tensor", ",", "'LR_path'", ":", "lr_path", ",", "'HR_path'", ":", "hr_path", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset.__len__": [[73, 78], ["len", "len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "train", ":", "\n", "            ", "return", "len", "(", "self", ".", "paths_HR", ")", "*", "self", ".", "repeat", "\n", "", "else", ":", "\n", "            ", "return", "len", "(", "self", ".", "paths_HR", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._get_index": [[80, 85], ["len"], "methods", ["None"], ["", "", "def", "_get_index", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "self", ".", "train", ":", "\n", "            ", "return", "idx", "%", "len", "(", "self", ".", "paths_HR", ")", "\n", "", "else", ":", "\n", "            ", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._load_file": [[86, 94], ["LRHR_dataset.LRHRDataset._get_index", "data_loader.common.read_img", "data_loader.common.read_img"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._get_index", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.read_img", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.read_img"], ["", "", "def", "_load_file", "(", "self", ",", "idx", ")", ":", "\n", "        ", "idx", "=", "self", ".", "_get_index", "(", "idx", ")", "\n", "lr_path", "=", "self", ".", "paths_LR", "[", "idx", "]", "\n", "hr_path", "=", "self", ".", "paths_HR", "[", "idx", "]", "\n", "lr", "=", "common", ".", "read_img", "(", "lr_path", ",", "'img'", ")", "\n", "hr", "=", "common", ".", "read_img", "(", "hr_path", ",", "'img'", ")", "\n", "\n", "return", "lr", ",", "hr", ",", "lr_path", ",", "hr_path", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.LRHRDataset._get_patch": [[95, 109], ["random.choice", "str", "data_loader.common.get_patch", "data_loader.common.augment", "data_loader.common.add_noise", "data_loader.common.add_noise"], "methods", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.get_patch", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.augment", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.add_noise", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.common.add_noise"], ["", "def", "_get_patch", "(", "self", ",", "lr", ",", "hr", ")", ":", "\n", "        ", "sigma", "=", "random", ".", "choice", "(", "self", ".", "noise_std", ")", "\n", "noise", "=", "'G'", "+", "str", "(", "sigma", ")", "\n", "if", "self", ".", "train", ":", "\n", "            ", "LR_size", "=", "self", ".", "patch_size", "\n", "# random crop and augment", "\n", "lr", ",", "hr", "=", "common", ".", "get_patch", "(", "\n", "lr", ",", "hr", ",", "LR_size", ",", "self", ".", "scale", ")", "\n", "lr", ",", "hr", "=", "common", ".", "augment", "(", "[", "lr", ",", "hr", "]", ")", "\n", "lr", "=", "common", ".", "add_noise", "(", "lr", ",", "noise", ")", "\n", "", "else", ":", "\n", "            ", "lr", "=", "common", ".", "add_noise", "(", "lr", ",", "noise", ")", "\n", "\n", "", "return", "lr", ",", "hr", ",", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.imshow": [[110, 114], ["img.numpy", "matplotlib.imshow", "numpy.transpose"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.LRHR_dataset.imshow"], ["", "", "def", "imshow", "(", "img", ")", ":", "\n", "    ", "npimg", "=", "img", ".", "numpy", "(", ")", "\n", "#print('npimg:', npimg.shape)", "\n", "plt", ".", "imshow", "(", "np", ".", "transpose", "(", "npimg", ",", "(", "1", ",", "2", ",", "0", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.is_image_file": [[12, 14], ["any", "filename.endswith"], "function", ["None"], ["\n", "", "def", "toc", "(", "self", ",", "restart", "=", "False", ")", ":", "\n", "        ", "diff", "=", "time", ".", "time", "(", ")", "-", "self", ".", "t0", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_valid_crop_size": [[16, 18], ["None"], "function", ["None"], ["return", "diff", "\n", "\n", "", "def", "hold", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.gaussian_noise": [[20, 23], ["numpy.rint", "PIL.Image.fromarray", "numpy.random.normal", "numpy.clip().astype", "numpy.shape", "numpy.clip"], "function", ["None"], ["\n", "", "def", "release", "(", "self", ")", ":", "\n", "        ", "ret", "=", "self", ".", "acc", "\n", "self", ".", "acc", "=", "0", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.display_transform": [[25, 31], ["torchvision.transforms.Compose", "torchvision.transforms.ToPILImage", "torchvision.transforms.Resize", "torchvision.transforms.CenterCrop", "torchvision.transforms.ToTensor"], "function", ["None"], ["return", "ret", "\n", "\n", "", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "acc", "=", "0", "\n", "\n", "", "", "def", "augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic": [[37, 44], ["torch.abs"], "function", ["None"], ["", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices": [[46, 99], ["torch.linspace", "torch.floor", "torch.sum().view", "torch.sum", "weights.narrow.contiguous", "indices.narrow.contiguous", "math.ceil", "torch.floor.view().expand", "torch.linspace().view().expand", "u.view().expand", "utils.cubic", "torch.sum().view.expand", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "math.isclose", "indices.narrow.narrow", "weights.narrow.narrow", "indices.narrow.max", "int", "int", "utils.cubic", "torch.sum", "indices.narrow.min", "torch.floor.view", "torch.linspace().view", "u.view", "torch.linspace"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.cubic"], ["        ", "return", "np", ".", "flipud", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "\n", "", "", "def", "inv_augment_img", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "np", ".", "flipud", "(", "img", ")", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ")", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "img", ")", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "3", ")", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "return", "np", ".", "rot90", "(", "img", ",", "k", "=", "2", ")", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "return", "np", ".", "fliplr", "(", "np", ".", "rot90", "(", "img", ")", ")", "\n", "\n", "\n", "", "", "def", "augment_img_np3", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "if", "mode", "==", "0", ":", "\n", "        ", "return", "img", "\n", "", "elif", "mode", "==", "1", ":", "\n", "        ", "return", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "", "elif", "mode", "==", "2", ":", "\n", "        ", "return", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "elif", "mode", "==", "3", ":", "\n", "        ", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "4", ":", "\n", "        ", "return", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "elif", "mode", "==", "5", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "", "elif", "mode", "==", "6", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "return", "img", "\n", "", "elif", "mode", "==", "7", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "img", "=", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "img", "=", "img", ".", "transpose", "(", "1", ",", "0", ",", "2", ")", "\n", "return", "img", "\n", "\n", "\n", "", "", "def", "augment_img_tensor", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "img_size", "=", "img", ".", "size", "(", ")", "\n", "img_np", "=", "img", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n"]], "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.imresize": [[101, 168], ["img.size", "utils.calculate_weights_indices", "utils.calculate_weights_indices", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_H.size", "range", "torch.FloatTensor", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.arange().long", "sym_patch.index_select", "torch.FloatTensor.narrow().copy_", "torch.FloatTensor", "weights_W.size", "range", "torch.clamp", "math.ceil", "math.ceil", "int", "img_aug[].transpose().mv", "img_aug[].transpose().mv", "img_aug[].transpose().mv", "int", "out_1_aug[].mv", "out_1_aug[].mv", "out_1_aug[].mv", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "torch.arange", "torch.FloatTensor.narrow", "img_aug[].transpose", "img_aug[].transpose", "img_aug[].transpose", "sym_patch.size", "sym_patch.size", "sym_patch.size", "sym_patch.size"], "function", ["home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices", "home.repos.pwc.inspect_result.RaoUmer_SRResCGAN.data_loader.utils.calculate_weights_indices"], ["        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "img_np", "=", "augment_img", "(", "img_np", ",", "mode", "=", "mode", ")", "\n", "img_tensor", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img_np", ")", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "return", "img_tensor", ".", "type_as", "(", "img", ")", "\n", "\n", "", "def", "inv_augment_img_tensor", "(", "img", ",", "mode", "=", "0", ")", ":", "\n", "    ", "img_size", "=", "img", ".", "size", "(", ")", "\n", "img_np", "=", "img", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_np", "=", "np", ".", "transpose", "(", "img_np", ",", "(", "2", ",", "3", ",", "1", ",", "0", ")", ")", "\n", "", "img_np", "=", "inv_augment_img", "(", "img_np", ",", "mode", "=", "mode", ")", "\n", "img_tensor", "=", "torch", ".", "from_numpy", "(", "np", ".", "ascontiguousarray", "(", "img_np", ")", ")", "\n", "if", "len", "(", "img_size", ")", "==", "3", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "2", ",", "0", ",", "1", ")", "\n", "", "elif", "len", "(", "img_size", ")", "==", "4", ":", "\n", "        ", "img_tensor", "=", "img_tensor", ".", "permute", "(", "3", ",", "2", ",", "0", ",", "1", ")", "\n", "\n", "", "return", "img_tensor", ".", "type_as", "(", "img", ")", "", "", ""]]}