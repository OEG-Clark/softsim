{"home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_bci_competition.notch": [[15, 23], ["numpy.array", "numpy.poly", "numpy.poly", "numpy.exp", "numpy.exp"], "function", ["None"], ["def", "notch", "(", "Wn", ",", "notchWidth", ")", ":", "\n", "# Compute zeros", "\n", "    ", "nzeros", "=", "array", "(", "[", "exp", "(", "1j", "*", "pi", "*", "Wn", ")", ",", "exp", "(", "-", "1j", "*", "pi", "*", "Wn", ")", "]", ")", "\n", "# Compute poles", "\n", "poles", "=", "(", "1", "-", "notchWidth", ")", "*", "nzeros", "\n", "b", "=", "poly", "(", "nzeros", ")", "# Get moving average filter coefficients", "\n", "a", "=", "poly", "(", "poles", ")", "# Get autoregressive filter coefficients", "\n", "return", "b", ",", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_bci_competition.read_BCI_signals": [[25, 119], ["os.listdir", "list", "list", "list", "os.path.exists", "numpy.array", "experiment_bci_competition.notch", "scipy.signal.butter", "print", "str", "open", "pickle.load", "open", "pickle.dump", "hash", "print", "scipy.io.loadmat", "numpy.nan_to_num", "enumerate", "numpy.zeros_like", "range", "numpy.zeros_like", "range", "list.append", "list.append", "list.append", "str", "scipy.signal.filtfilt", "scipy.signal.filtfilt", "scipy.signal.decimate", "str", "numpy.real", "numpy.real", "numpy.int", "tmpfs.mean", "str", "numpy.int", "numpy.int", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_bci_competition.notch"], ["", "def", "read_BCI_signals", "(", ")", ":", "\n", "    ", "kppath", "=", "\"../../datasets/BCIcompetition4/\"", "\n", "lkp", "=", "listdir", "(", "kppath", ")", "\n", "sujets", "=", "list", "(", ")", "\n", "classes", "=", "list", "(", ")", "\n", "signals", "=", "list", "(", ")", "\n", "\n", "preprocessing", "=", "True", "\n", "decimation", "=", "True", "\n", "\n", "if", "preprocessing", ":", "\n", "# Notch filtering", "\n", "        ", "f0", "=", "50.0", "# notch frequency", "\n", "notchWidth", "=", "0.1", "# width of the notch", "\n", "# Bandpass filtering", "\n", "order", "=", "8", "\n", "fc", "=", "array", "(", "[", "8.0", ",", "30.0", "]", ")", "# [0.1, 100]", "\n", "sr", "=", "250", "# sampling rate, o['SampleRate'][0,0] from loadmat", "\n", "Wn", "=", "f0", "/", "(", "sr", "/", "2.0", ")", "# ratio of notch freq. to Nyquist freq.", "\n", "[", "bn", ",", "an", "]", "=", "notch", "(", "Wn", ",", "notchWidth", ")", "\n", "[", "bb", ",", "ab", "]", "=", "butter", "(", "order", ",", "fc", "/", "(", "sr", "/", "2.0", ")", ",", "\"bandpass\"", ")", "\n", "", "else", ":", "\n", "        ", "f0", "=", "-", "1.0", "\n", "notchWidth", "=", "0.0", "\n", "order", "=", "0", "\n", "fc", "=", "0", "\n", "\n", "", "if", "decimation", ":", "\n", "        ", "dfactor", "=", "2.0", "\n", "", "else", ":", "\n", "        ", "dfactor", "=", "1.0", "\n", "\n", "", "fn", "=", "(", "\n", "\"bcicompdata\"", "\n", "+", "str", "(", "\n", "hash", "(", "\n", "str", "(", "preprocessing", ")", "\n", "+", "str", "(", "f0", ")", "\n", "+", "str", "(", "notchWidth", ")", "\n", "+", "str", "(", "order", ")", "\n", "+", "str", "(", "fc", ")", "\n", "+", "str", "(", "decimation", ")", "\n", "+", "str", "(", "dfactor", ")", "\n", ")", "\n", ")", "\n", "+", "\".pickle\"", "\n", ")", "\n", "\n", "if", "exists", "(", "fn", ")", ":", "\n", "        ", "with", "open", "(", "fn", ",", "\"rb\"", ")", "as", "f", ":", "\n", "            ", "o", "=", "pickle", ".", "load", "(", "f", ")", "\n", "signals", "=", "o", "[", "\"signals\"", "]", "\n", "classes", "=", "o", "[", "\"classes\"", "]", "\n", "", "print", "(", "\"Previous preprocessing of BCI dataset found, reusing it\"", ")", "\n", "", "else", ":", "\n", "        ", "for", "item", "in", "lkp", ":", "\n", "            ", "if", "item", "[", "-", "8", ":", "]", "==", "\"-EOG.mat\"", ":", "\n", "                ", "print", "(", "\"loading\"", ",", "item", ")", "\n", "o", "=", "loadmat", "(", "kppath", "+", "item", ",", "struct_as_record", "=", "True", ")", "\n", "s", "=", "nan_to_num", "(", "o", "[", "\"s\"", "]", ")", "\n", "# sample_rate = o['SampleRate']", "\n", "event_type", "=", "o", "[", "\"EVENTTYP\"", "]", "\n", "event_pos", "=", "o", "[", "\"EVENTPOS\"", "]", "\n", "class_label", "=", "o", "[", "\"Classlabel\"", "]", "\n", "if", "preprocessing", ":", "\n", "# Use a Notch filter to remove 50Hz power line", "\n", "                    ", "ns", "=", "zeros_like", "(", "s", ")", "\n", "for", "e", "in", "range", "(", "s", ".", "shape", "[", "1", "]", ")", ":", "\n", "                        ", "ns", "[", ":", ",", "e", "]", "=", "filtfilt", "(", "bn", ",", "an", ",", "s", "[", ":", ",", "e", "]", ")", "\n", "# Apply a bandpass filter", "\n", "", "fs", "=", "zeros_like", "(", "s", ")", "\n", "for", "e", "in", "range", "(", "s", ".", "shape", "[", "1", "]", ")", ":", "\n", "                        ", "fs", "[", ":", ",", "e", "]", "=", "filtfilt", "(", "real", "(", "bb", ")", ",", "real", "(", "ab", ")", ",", "ns", "[", ":", ",", "e", "]", ")", "\n", "# decimate the signal", "\n", "", "if", "decimation", ":", "\n", "                        ", "fs", "=", "decimate", "(", "fs", ",", "int", "(", "dfactor", ")", ",", "axis", "=", "0", ",", "zero_phase", "=", "True", ")", "\n", "\n", "# Event Type", "\n", "", "", "trial_begin", "=", "768", "\n", "\n", "start", "=", "3", "*", "sr", "/", "dfactor", "# 2s fixation, 1s after cue", "\n", "stop", "=", "6", "*", "sr", "/", "dfactor", "# 4s after cue, 3s of EEG", "\n", "\n", "trials", "=", "event_pos", "[", "event_type", "==", "trial_begin", "]", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "trials", ")", ":", "\n", "                    ", "tmpfs", "=", "fs", "[", "int", "(", "t", "/", "dfactor", "+", "start", ")", ":", "int", "(", "t", "/", "dfactor", "+", "stop", ")", ",", "0", ":", "22", "]", "\n", "signals", ".", "append", "(", "(", "tmpfs", "-", "tmpfs", ".", "mean", "(", "axis", "=", "0", ")", ")", ")", "# center data", "\n", "sujets", ".", "append", "(", "item", "[", "2", ":", "3", "]", ")", "\n", "classes", ".", "append", "(", "class_label", "[", "i", "]", ")", "\n", "\n", "", "", "", "with", "open", "(", "fn", ",", "\"wb\"", ")", "as", "f", ":", "\n", "            ", "o", "=", "{", "\"signals\"", ":", "signals", ",", "\"classes\"", ":", "classes", "}", "\n", "pickle", ".", "dump", "(", "o", ",", "f", ")", "\n", "", "", "return", "signals", ",", "classes", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_dictionary_recovering._generate_testbed": [[14, 59], ["range", "list", "list", "range", "numpy.array", "numpy.random.randn", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "numpy.random.permutation", "range", "list.append", "numpy.random.randn", "numpy.array.append", "range", "range", "numpy.random.randint", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.rand"], "function", ["None"], ["def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "\n", "n_nonzero_coefs", ",", "\n", "n_kernels", ",", "\n", "n_samples", "=", "10", ",", "\n", "n_features", "=", "5", ",", "\n", "n_dims", "=", "3", ",", "\n", "snr", "=", "1000", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary\n\n    Generate a random dictionary and a dataset, where samples are combination\n    of n_nonzero_coefs dictionary atoms. Noise is added, based on SNR value,\n    with 1000 indicated that no noise should be added.\n    Return the dictionary, the dataset and an array indicated how atoms are\n    combined to obtain each sample\n    \"\"\"", "\n", "dico", "=", "[", "randn", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "noise", "=", "randn", "(", "n_features", ",", "n_dims", ")", "\n", "if", "snr", "==", "1000", ":", "\n", "            ", "alpha", "=", "0", "\n", "", "else", ":", "\n", "            ", "ps", "=", "norm", "(", "s", ",", "\"fro\"", ")", "\n", "pn", "=", "norm", "(", "noise", ",", "\"fro\"", ")", "\n", "alpha", "=", "ps", "/", "(", "pn", "*", "10", "**", "(", "snr", "/", "20.0", ")", ")", "\n", "", "signals", ".", "append", "(", "s", "+", "alpha", "*", "noise", ")", "\n", "", "signals", "=", "array", "(", "signals", ")", "\n", "\n", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_dictionary_recovering.plot_recov": [[61, 206], ["matplotlib.figure", "enumerate", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "matplotlib.tight_layout", "matplotlib.savefig", "plt.figure.add_subplot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.legend", "plt.figure.add_subplot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "plt.figure.add_subplot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "fig.add_subplot.set_title", "plt.figure.add_subplot", "fig.add_subplot.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "fig.add_subplot.annotate", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "median.get_ydata", "enumerate", "median.get_ydata", "enumerate", "median.get_ydata", "enumerate", "median.get_ydata", "enumerate", "median.get_ydata", "enumerate", "median.get_ydata", "enumerate", "median.get_ydata", "enumerate"], "function", ["None"], ["", "def", "plot_recov", "(", "wc", ",", "wfs", ",", "hc", ",", "hfs", ",", "bd", ",", "dr99", ",", "dr97", ",", "n_iter", ",", "figname", ")", ":", "\n", "    ", "snr", "=", "[", "\"30\"", ",", "\"20\"", ",", "\"10\"", "]", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "18", ",", "10", ")", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "snr", ")", ":", "\n", "# plotting data from detection rate", "\n", "        ", "detection", "=", "fig", ".", "add_subplot", "(", "3", ",", "4", ",", "i", "*", "4", "+", "1", ")", "\n", "det99", "=", "detection", ".", "boxplot", "(", "dr99", "[", "i", ",", ":", ",", ":", "]", "/", "100.0", ")", "\n", "plt", ".", "setp", "(", "det99", "[", "\"medians\"", "]", ",", "color", "=", "\"green\"", ")", "\n", "plt", ".", "setp", "(", "det99", "[", "\"caps\"", "]", ",", "color", "=", "\"green\"", ")", "\n", "plt", ".", "setp", "(", "det99", "[", "\"boxes\"", "]", ",", "color", "=", "\"green\"", ")", "\n", "plt", ".", "setp", "(", "det99", "[", "\"fliers\"", "]", ",", "color", "=", "\"green\"", ")", "\n", "plt", ".", "setp", "(", "det99", "[", "\"whiskers\"", "]", ",", "color", "=", "\"green\"", ")", "\n", "medianlt99", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "det99", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "detection", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "\n", "medianlt99", ",", "\n", "linewidth", "=", "1", ",", "\n", "color", "=", "\"green\"", ",", "\n", "label", "=", "r\"$c_\\operatorname{99}$\"", ",", "\n", ")", "\n", "det97", "=", "detection", ".", "boxplot", "(", "dr97", "[", "i", ",", ":", ",", ":", "]", "/", "100.0", ")", "\n", "plt", ".", "setp", "(", "det97", "[", "\"medians\"", "]", ",", "color", "=", "\"magenta\"", ")", "\n", "plt", ".", "setp", "(", "det97", "[", "\"caps\"", "]", ",", "color", "=", "\"magenta\"", ")", "\n", "plt", ".", "setp", "(", "det97", "[", "\"boxes\"", "]", ",", "color", "=", "\"magenta\"", ")", "\n", "plt", ".", "setp", "(", "det97", "[", "\"fliers\"", "]", ",", "color", "=", "\"magenta\"", ")", "\n", "plt", ".", "setp", "(", "det97", "[", "\"whiskers\"", "]", ",", "color", "=", "\"magenta\"", ")", "\n", "medianlt97", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "det97", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "detection", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "\n", "medianlt97", ",", "\n", "linewidth", "=", "1", ",", "\n", "color", "=", "\"magenta\"", ",", "\n", "label", "=", "r\"$c_\\operatorname{97}$\"", ",", "\n", ")", "\n", "detection", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "detection", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "detection", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "# plotting data from hausdorff metric", "\n", "methaus", "=", "fig", ".", "add_subplot", "(", "3", ",", "4", ",", "i", "*", "4", "+", "2", ")", "\n", "hausch", "=", "methaus", ".", "boxplot", "(", "1", "-", "hc", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "plt", ".", "setp", "(", "hausch", "[", "\"medians\"", "]", ",", "color", "=", "\"cyan\"", ")", "\n", "plt", ".", "setp", "(", "hausch", "[", "\"caps\"", "]", ",", "color", "=", "\"cyan\"", ")", "\n", "plt", ".", "setp", "(", "hausch", "[", "\"boxes\"", "]", ",", "color", "=", "\"cyan\"", ")", "\n", "plt", ".", "setp", "(", "hausch", "[", "\"fliers\"", "]", ",", "color", "=", "\"cyan\"", ")", "\n", "plt", ".", "setp", "(", "hausch", "[", "\"whiskers\"", "]", ",", "color", "=", "\"cyan\"", ")", "\n", "medianhc", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "hausch", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "methaus", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "medianhc", ",", "linewidth", "=", "1", ",", "label", "=", "r\"$1-d_H^c$\"", ",", "color", "=", "\"cyan\"", "\n", ")", "\n", "hausfs", "=", "methaus", ".", "boxplot", "(", "1", "-", "hfs", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "plt", ".", "setp", "(", "hausfs", "[", "\"medians\"", "]", ",", "color", "=", "\"yellow\"", ")", "\n", "plt", ".", "setp", "(", "hausfs", "[", "\"caps\"", "]", ",", "color", "=", "\"yellow\"", ")", "\n", "plt", ".", "setp", "(", "hausfs", "[", "\"boxes\"", "]", ",", "color", "=", "\"yellow\"", ")", "\n", "plt", ".", "setp", "(", "hausfs", "[", "\"fliers\"", "]", ",", "color", "=", "\"yellow\"", ")", "\n", "plt", ".", "setp", "(", "hausfs", "[", "\"whiskers\"", "]", ",", "color", "=", "\"yellow\"", ")", "\n", "medianhfs", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "hausfs", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "methaus", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "\n", "medianhfs", ",", "\n", "linewidth", "=", "1", ",", "\n", "label", "=", "r\"$1-d_H^{fs}$\"", ",", "\n", "color", "=", "\"yellow\"", ",", "\n", ")", "\n", "methaus", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "methaus", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "methaus", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "methaus", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "# plotting data from wasserstein metric", "\n", "metwass", "=", "fig", ".", "add_subplot", "(", "3", ",", "4", ",", "i", "*", "4", "+", "3", ")", "\n", "wassch", "=", "metwass", ".", "boxplot", "(", "1", "-", "wc", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "plt", ".", "setp", "(", "wassch", "[", "\"medians\"", "]", ",", "color", "=", "\"red\"", ")", "\n", "plt", ".", "setp", "(", "wassch", "[", "\"caps\"", "]", ",", "color", "=", "\"red\"", ")", "\n", "plt", ".", "setp", "(", "wassch", "[", "\"boxes\"", "]", ",", "color", "=", "\"red\"", ")", "\n", "plt", ".", "setp", "(", "wassch", "[", "\"fliers\"", "]", ",", "color", "=", "\"red\"", ")", "\n", "plt", ".", "setp", "(", "wassch", "[", "\"whiskers\"", "]", ",", "color", "=", "\"red\"", ")", "\n", "medianwc", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "wassch", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "metwass", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "medianwc", ",", "linewidth", "=", "1", ",", "label", "=", "r\"$1-d_W^c$\"", ",", "color", "=", "\"red\"", "\n", ")", "\n", "wassfs", "=", "metwass", ".", "boxplot", "(", "1", "-", "wfs", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "plt", ".", "setp", "(", "wassfs", "[", "\"medians\"", "]", ",", "color", "=", "\"blue\"", ")", "\n", "plt", ".", "setp", "(", "wassfs", "[", "\"caps\"", "]", ",", "color", "=", "\"blue\"", ")", "\n", "plt", ".", "setp", "(", "wassfs", "[", "\"boxes\"", "]", ",", "color", "=", "\"blue\"", ")", "\n", "plt", ".", "setp", "(", "wassfs", "[", "\"fliers\"", "]", ",", "color", "=", "\"blue\"", ")", "\n", "plt", ".", "setp", "(", "wassfs", "[", "\"whiskers\"", "]", ",", "color", "=", "\"blue\"", ")", "\n", "medianwfs", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "wassfs", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "metwass", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "\n", "medianwfs", ",", "\n", "linewidth", "=", "1", ",", "\n", "label", "=", "r\"$1-d_W^{fs}$\"", ",", "\n", "color", "=", "\"blue\"", ",", "\n", ")", "\n", "metwass", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "metwass", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "metwass", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "metwass", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "metwass", ".", "set_title", "(", "\" \"", ")", "\n", "\n", "# plotting data from Beta", "\n", "metbeta", "=", "fig", ".", "add_subplot", "(", "3", ",", "4", ",", "i", "*", "4", "+", "4", ")", "\n", "betad", "=", "metbeta", ".", "boxplot", "(", "1", "-", "bd", "[", "i", ",", ":", ",", ":", "]", ")", "\n", "plt", ".", "setp", "(", "betad", "[", "\"medians\"", "]", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "setp", "(", "betad", "[", "\"caps\"", "]", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "setp", "(", "betad", "[", "\"boxes\"", "]", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "setp", "(", "betad", "[", "\"fliers\"", "]", ",", "color", "=", "\"black\"", ")", "\n", "plt", ".", "setp", "(", "betad", "[", "\"whiskers\"", "]", ",", "color", "=", "\"black\"", ")", "\n", "medianbd", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "betad", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "metbeta", ".", "plot", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "\n", "medianbd", ",", "\n", "linewidth", "=", "1", ",", "\n", "label", "=", "r\"$1-d_\\beta$\"", ",", "\n", "color", "=", "\"black\"", ",", "\n", ")", "\n", "metbeta", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "metbeta", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metbeta", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "metbeta", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "metbeta", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "metbeta", ".", "annotate", "(", "\n", "\"SNR \"", "+", "s", ",", "\n", "xy", "=", "(", "0.51", ",", "1.0", "-", "i", "*", "1.0", "/", "3.0", "+", "i", "*", "0.01", "-", "0.001", ")", ",", "\n", "xycoords", "=", "\"figure fraction\"", ",", "\n", "horizontalalignment", "=", "\"center\"", ",", "\n", "verticalalignment", "=", "\"top\"", ",", "\n", "fontsize", "=", "\"large\"", ",", "\n", ")", "\n", "\n", "", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "detection", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metbeta", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metbeta", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "plt", ".", "tight_layout", "(", "1.2", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_dictionary_recovering.callback_recovery": [[208, 219], ["d.wc.append", "d.wfs.append", "d.hc.append", "d.hfs.append", "d.bd.append", "d.dr99.append", "d.dr97.append", "dict_metrics.emd", "dict_metrics.emd", "dict_metrics.hausdorff", "dict_metrics.hausdorff", "dict_metrics.beta_dist", "dict_metrics.detection_rate", "dict_metrics.detection_rate"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.beta_dist", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate"], ["", "def", "callback_recovery", "(", "loc", ")", ":", "\n", "    ", "d", "=", "loc", "[", "\"dict_obj\"", "]", "\n", "d", ".", "wc", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "wfs", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"fubinistudy\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "hc", ".", "append", "(", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "hfs", ".", "append", "(", "\n", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"fubinistudy\"", ",", "scale", "=", "True", ")", "\n", ")", "\n", "d", ".", "bd", ".", "append", "(", "beta_dist", "(", "d", ".", "generating_dict", ",", "loc", "[", "\"dictionary\"", "]", ")", ")", "\n", "d", ".", "dr99", ".", "append", "(", "detection_rate", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "0.99", ")", ")", "\n", "d", ".", "dr97", ".", "append", "(", "detection_rate", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "0.97", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering._generate_testbed": [[23, 68], ["range", "list", "list", "range", "numpy.array", "numpy.random.randn", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "numpy.random.permutation", "range", "list.append", "numpy.random.randn", "numpy.array.append", "range", "range", "numpy.random.randint", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.rand"], "function", ["None"], ["", "def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "\n", "n_nonzero_coefs", ",", "\n", "n_kernels", ",", "\n", "n_samples", "=", "10", ",", "\n", "n_features", "=", "5", ",", "\n", "n_dims", "=", "3", ",", "\n", "snr", "=", "1000", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary\n\n    Generate a random dictionary and a dataset, where samples are combination\n    of n_nonzero_coefs dictionary atoms. Noise is added, based on SNR value,\n    with 1000 indicated that no noise should be added.\n    Return the dictionary, the dataset and an array indicated how atoms are\n    combined to obtain each sample\n    \"\"\"", "\n", "dico", "=", "[", "randn", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "noise", "=", "randn", "(", "n_features", ",", "n_dims", ")", "\n", "if", "snr", "==", "1000", ":", "\n", "            ", "alpha", "=", "0", "\n", "", "else", ":", "\n", "            ", "ps", "=", "norm", "(", "s", ",", "\"fro\"", ")", "\n", "pn", "=", "norm", "(", "noise", ",", "\"fro\"", ")", "\n", "alpha", "=", "ps", "/", "(", "pn", "*", "10", "**", "(", "snr", "/", "20.0", ")", ")", "\n", "", "signals", ".", "append", "(", "s", "+", "alpha", "*", "noise", ")", "\n", "", "signals", "=", "array", "(", "signals", ")", "\n", "\n", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes": [[70, 79], ["fig.boxplot", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "matplotlib.setp", "fig.plot", "numpy.arange", "m.get_ydata", "enumerate"], "function", ["None"], ["", "def", "plot_boxes", "(", "fig", ",", "data", ",", "color", "=", "\"blue\"", ",", "n_iter", "=", "100", ",", "label", "=", "\"\"", ")", ":", "\n", "    ", "bp", "=", "fig", ".", "boxplot", "(", "data", ")", "\n", "plt", ".", "setp", "(", "bp", "[", "\"medians\"", "]", ",", "color", "=", "color", ")", "\n", "plt", ".", "setp", "(", "bp", "[", "\"caps\"", "]", ",", "color", "=", "color", ")", "\n", "plt", ".", "setp", "(", "bp", "[", "\"boxes\"", "]", ",", "color", "=", "color", ")", "\n", "plt", ".", "setp", "(", "bp", "[", "\"fliers\"", "]", ",", "color", "=", "color", ")", "\n", "plt", ".", "setp", "(", "bp", "[", "\"whiskers\"", "]", ",", "color", "=", "color", ")", "\n", "med", "=", "[", "m", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "m", "in", "enumerate", "(", "bp", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "fig", ".", "plot", "(", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "med", ",", "linewidth", "=", "1", ",", "color", "=", "color", ",", "label", "=", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_recov_all": [[81, 145], ["matplotlib.figure", "enumerate", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "matplotlib.tight_layout", "matplotlib.savefig", "plt.figure.add_subplot", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.legend", "plt.figure.add_subplot", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "plt.figure.add_subplot", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "fig.add_subplot.set_title", "fig.add_subplot.annotate", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes"], ["", "def", "plot_recov_all", "(", "\n", "wc", ",", "wfs", ",", "wcpa", ",", "wbc", ",", "wg", ",", "wfb", ",", "hc", ",", "hfs", ",", "hcpa", ",", "hbc", ",", "hg", ",", "hfb", ",", "dr99", ",", "dr97", ",", "n_iter", ",", "figname", "\n", ")", ":", "\n", "    ", "snr", "=", "[", "\"30\"", ",", "\"20\"", ",", "\"10\"", "]", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "18", ",", "10", ")", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "snr", ")", ":", "\n", "# plotting data from detection rate", "\n", "        ", "detection", "=", "fig", ".", "add_subplot", "(", "3", ",", "3", ",", "i", "*", "3", "+", "1", ")", "\n", "plot_boxes", "(", "\n", "detection", ",", "dr99", "[", "i", ",", ":", ",", ":", "]", "/", "100.0", ",", "\"green\"", ",", "n_iter", ",", "r\"$c_\\operatorname{99}$\"", "\n", ")", "\n", "plot_boxes", "(", "\n", "detection", ",", "dr97", "[", "i", ",", ":", ",", ":", "]", "/", "100.0", ",", "\"magenta\"", ",", "n_iter", ",", "r\"$c_\\operatorname{97}$\"", "\n", ")", "\n", "detection", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "detection", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "detection", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "methaus", "=", "fig", ".", "add_subplot", "(", "3", ",", "3", ",", "i", "*", "3", "+", "2", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hc", "[", "i", ",", ":", ",", ":", "]", ",", "\"chartreuse\"", ",", "n_iter", ",", "r\"$1-d_H^c$\"", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hcpa", "[", "i", ",", ":", ",", ":", "]", ",", "\"red\"", ",", "n_iter", ",", "r\"$1-d_H^{cpa}$\"", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hfs", "[", "i", ",", ":", ",", ":", "]", ",", "\"magenta\"", ",", "n_iter", ",", "r\"$1-d_H^{fs}$\"", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hbc", "[", "i", ",", ":", ",", ":", "]", ",", "\"blue\"", ",", "n_iter", ",", "r\"$1-d_H^{bc}$\"", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hg", "[", "i", ",", ":", ",", ":", "]", ",", "\"deepskyblue\"", ",", "n_iter", ",", "r\"$1-d_H^{g}$\"", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hfb", "[", "i", ",", ":", ",", ":", "]", ",", "\"orange\"", ",", "n_iter", ",", "r\"$1-d_H^{fb}$\"", ")", "\n", "\n", "methaus", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "methaus", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "methaus", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "methaus", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "metwass", "=", "fig", ".", "add_subplot", "(", "3", ",", "3", ",", "i", "*", "3", "+", "3", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wc", "[", "i", ",", ":", ",", ":", "]", ",", "\"chartreuse\"", ",", "n_iter", ",", "r\"$1-d_W^c$\"", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wcpa", "[", "i", ",", ":", ",", ":", "]", ",", "\"red\"", ",", "n_iter", ",", "r\"$1-d_W^{cpa}$\"", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wfs", "[", "i", ",", ":", ",", ":", "]", ",", "\"magenta\"", ",", "n_iter", ",", "r\"$1-d_W^{fs}$\"", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wbc", "[", "i", ",", ":", ",", ":", "]", ",", "\"blue\"", ",", "n_iter", ",", "r\"$1-d_W^{bc}$\"", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wg", "[", "i", ",", ":", ",", ":", "]", ",", "\"deepskyblue\"", ",", "n_iter", ",", "r\"$1-d_W^{g}$\"", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wfb", "[", "i", ",", ":", ",", ":", "]", ",", "\"orange\"", ",", "n_iter", ",", "r\"$1-d_W^{fb}$\"", ")", "\n", "metwass", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "metwass", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "metwass", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "metwass", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "metwass", ".", "set_title", "(", "\" \"", ")", "\n", "\n", "metwass", ".", "annotate", "(", "\n", "\"SNR \"", "+", "s", ",", "\n", "xy", "=", "(", "0.51", ",", "1.0", "-", "i", "*", "1.0", "/", "3.0", "+", "i", "*", "0.01", "-", "0.001", ")", ",", "\n", "xycoords", "=", "\"figure fraction\"", ",", "\n", "horizontalalignment", "=", "\"center\"", ",", "\n", "verticalalignment", "=", "\"top\"", ",", "\n", "fontsize", "=", "\"large\"", ",", "\n", ")", "\n", "\n", "", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "detection", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "plt", ".", "tight_layout", "(", "1.2", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_recov": [[147, 202], ["matplotlib.figure", "enumerate", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "matplotlib.tight_layout", "matplotlib.savefig", "plt.figure.add_subplot", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.legend", "plt.figure.add_subplot", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "plt.figure.add_subplot", "experiment_multivariate_recovering.plot_boxes", "experiment_multivariate_recovering.plot_boxes", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.legend", "fig.add_subplot.set_title", "fig.add_subplot.annotate", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes", "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.plot_boxes"], ["", "def", "plot_recov", "(", "wc", ",", "wfs", ",", "hc", ",", "hfs", ",", "dr99", ",", "dr97", ",", "n_iter", ",", "figname", ")", ":", "\n", "    ", "snr", "=", "[", "\"30\"", ",", "\"20\"", ",", "\"10\"", "]", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "18", ",", "10", ")", ")", "\n", "for", "i", ",", "s", "in", "enumerate", "(", "snr", ")", ":", "\n", "# plotting data from detection rate", "\n", "        ", "detection", "=", "fig", ".", "add_subplot", "(", "3", ",", "3", ",", "i", "*", "3", "+", "1", ")", "\n", "plot_boxes", "(", "\n", "detection", ",", "dr99", "[", "i", ",", ":", ",", ":", "]", "/", "100.0", ",", "\"green\"", ",", "n_iter", ",", "r\"$c_\\operatorname{99}$\"", "\n", ")", "\n", "plot_boxes", "(", "\n", "detection", ",", "dr97", "[", "i", ",", ":", ",", ":", "]", "/", "100.0", ",", "\"magenta\"", ",", "n_iter", ",", "r\"$c_\\operatorname{97}$\"", "\n", ")", "\n", "detection", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "detection", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "detection", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "# plotting data from hausdorff metric", "\n", "methaus", "=", "fig", ".", "add_subplot", "(", "3", ",", "3", ",", "i", "*", "3", "+", "2", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hc", "[", "i", ",", ":", ",", ":", "]", ",", "\"cyan\"", ",", "n_iter", ",", "r\"$1-d_H^c$\"", ")", "\n", "plot_boxes", "(", "methaus", ",", "1", "-", "hfs", "[", "i", ",", ":", ",", ":", "]", ",", "\"yellow\"", ",", "n_iter", ",", "r\"$1-d_H^{fs}$\"", ")", "\n", "methaus", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "methaus", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "methaus", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "methaus", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "\n", "# plotting data from wasserstein metric", "\n", "metwass", "=", "fig", ".", "add_subplot", "(", "3", ",", "3", ",", "i", "*", "3", "+", "3", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wc", "[", "i", ",", ":", ",", ":", "]", ",", "\"red\"", ",", "n_iter", ",", "r\"$1-d_W^c$\"", ")", "\n", "plot_boxes", "(", "metwass", ",", "1", "-", "wfs", "[", "i", ",", ":", ",", ":", "]", ",", "\"blue\"", ",", "n_iter", ",", "r\"$1-d_W^{fs}$\"", ")", "\n", "metwass", ".", "axis", "(", "[", "0", ",", "n_iter", ",", "0", ",", "1", "]", ")", "\n", "metwass", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "metwass", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "metwass", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "metwass", ".", "set_title", "(", "\" \"", ")", "\n", "\n", "metwass", ".", "annotate", "(", "\n", "\"SNR \"", "+", "s", ",", "\n", "xy", "=", "(", "0.51", ",", "1.0", "-", "i", "*", "1.0", "/", "3.0", "+", "i", "*", "0.01", "-", "0.001", ")", ",", "\n", "xycoords", "=", "\"figure fraction\"", ",", "\n", "horizontalalignment", "=", "\"center\"", ",", "\n", "verticalalignment", "=", "\"top\"", ",", "\n", "fontsize", "=", "\"large\"", ",", "\n", ")", "\n", "\n", "", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "detection", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "methaus", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticks", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "metwass", ".", "set_xticklabels", "(", "arange", "(", "0", ",", "n_iter", "+", "1", ",", "10", ")", ")", "\n", "plt", ".", "tight_layout", "(", "1.2", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.experiments.experiment_multivariate_recovering.callback_recovery": [[204, 230], ["d.wc.append", "d.wfs.append", "d.wcpa.append", "d.wbc.append", "d.wg.append", "d.wfb.append", "d.hc.append", "d.hfs.append", "d.hcpa.append", "d.hbc.append", "d.hg.append", "d.hfb.append", "d.dr99.append", "d.dr97.append", "dict_metrics.emd", "dict_metrics.emd", "dict_metrics.emd", "dict_metrics.emd", "dict_metrics.emd", "dict_metrics.emd", "dict_metrics.hausdorff", "dict_metrics.hausdorff", "dict_metrics.hausdorff", "dict_metrics.hausdorff", "dict_metrics.hausdorff", "dict_metrics.hausdorff", "dict_metrics.detection_rate", "dict_metrics.detection_rate"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate"], ["", "def", "callback_recovery", "(", "loc", ")", ":", "\n", "    ", "d", "=", "loc", "[", "\"dict_obj\"", "]", "\n", "d", ".", "wc", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "wfs", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"fubinistudy\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "wcpa", ".", "append", "(", "\n", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal_principal_angles\"", ",", "scale", "=", "True", ")", "\n", ")", "\n", "d", ".", "wbc", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"binetcauchy\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "wg", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"geodesic\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "wfb", ".", "append", "(", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"frobenius\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "hc", ".", "append", "(", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "hfs", ".", "append", "(", "\n", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"fubinistudy\"", ",", "scale", "=", "True", ")", "\n", ")", "\n", "d", ".", "hcpa", ".", "append", "(", "\n", "hausdorff", "(", "\n", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal_principal_angles\"", ",", "scale", "=", "True", "\n", ")", "\n", ")", "\n", "d", ".", "hbc", ".", "append", "(", "\n", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"binetcauchy\"", ",", "scale", "=", "True", ")", "\n", ")", "\n", "d", ".", "hg", ".", "append", "(", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"geodesic\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "hfb", ".", "append", "(", "hausdorff", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"frobenius\"", ",", "scale", "=", "True", ")", ")", "\n", "d", ".", "dr99", ".", "append", "(", "detection_rate", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "0.99", ")", ")", "\n", "d", ".", "dr97", ".", "append", "(", "detection_rate", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "0.97", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_sparse_decomposition._generate_testbed": [[12, 78], ["sklearn.utils.check_random_state", "range", "list", "list", "range", "print", "print", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "sklearn.utils.check_random_state.permutation", "range", "list.append", "sklearn.utils.check_random_state.randn", "list.append", "sklearn.utils.check_random_state.randn", "sklearn.utils.check_random_state.rand", "range", "sklearn.utils.check_random_state.randint", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "range", "range", "sklearn.utils.check_random_state.rand"], "function", ["None"], ["def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "\n", "n_nonzero_coefs", ",", "\n", "n_kernels", ",", "\n", "rng", "=", "None", ",", "\n", "n_samples", "=", "10", ",", "\n", "n_features", "=", "5", ",", "\n", "n_dims", "=", "3", ",", "\n", "snr", "=", "1000", ",", "\n", "Gaussian", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary\n\n    Generate a random dictionary and a dataset, where samples are combination of\n    n_nonzero_coefs dictionary atoms. Noise is added, based on SNR value, with\n    1000 indicated that no noise should be added.\n    Return the dictionary, the dataset and an array indicated how atoms are\n    combined to obtain each sample\n    \"\"\"", "\n", "rng", "=", "check_random_state", "(", "rng", ")", "\n", "\n", "if", "Gaussian", ":", "\n", "        ", "print", "(", "\n", "\"Dictionary of size (\"", ",", "\n", "kernel_init_len", ",", "\n", "\",\"", ",", "\n", "n_dims", ",", "\n", "\") sampled from Gaussian distribution\"", ",", "\n", ")", "\n", "dico", "=", "[", "rng", ".", "randn", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "", "else", ":", "\n", "        ", "print", "(", "\n", "\"Dictionary of size (\"", ",", "\n", "kernel_init_len", ",", "\n", "\",\"", ",", "\n", "n_dims", ",", "\n", "\") sampled from uniform distribution\"", ",", "\n", ")", "\n", "dico", "=", "[", "rng", ".", "rand", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "rng", ".", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "rng", ".", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "rng", ".", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "noise", "=", "rng", ".", "randn", "(", "n_features", ",", "n_dims", ")", "\n", "if", "snr", "==", "1000", ":", "\n", "            ", "alpha", "=", "0", "\n", "", "else", ":", "\n", "            ", "ps", "=", "norm", "(", "s", ",", "\"fro\"", ")", "\n", "pn", "=", "norm", "(", "noise", ",", "\"fro\"", ")", "\n", "alpha", "=", "ps", "/", "(", "pn", "*", "10", "**", "(", "snr", "/", "20.0", ")", ")", "\n", "", "signals", ".", "append", "(", "s", "+", "alpha", "*", "noise", ")", "\n", "\n", "", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_sparse_decomposition.decomposition_random_dictionary": [[84, 127], ["example_sparse_decomposition._generate_testbed", "numpy.zeros", "range", "enumerate", "mdla.multivariate_sparse_encode", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._generate_testbed", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode"], ["def", "decomposition_random_dictionary", "(", "Gaussian", "=", "True", ",", "rng", "=", "None", ",", "n_features", "=", "65", ",", "n_dims", "=", "1", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary and compute decomposition\n\n    A dataset of n_samples examples is generated from a random dictionary,\n    each sample containing a random mixture of n_nonzero_coef atoms and has\n    a dimension of n_features by n_dims. All the examples are decomposed with\n    sparse multivariate OMP, written as:\n    (Eq. 1) min_a ||x - Da ||^2 s.t. ||a||_0 <= k\n    with x in R^(n_features x n_dims), D in R^(n_features x n_kernels) and\n    a in R^n_kernels.\n\n    Returns a ndarray of (n_nonzero_coefs, n_samples) containing all the\n    root mean square error (RMSE) computed as the residual of the decomposition\n    for all samples for sparsity constraint values of (Eq. 1) going from 1\n    to n_nonzero_coefs.\n    \"\"\"", "\n", "n_samples", "=", "100", "\n", "kernel_init_len", "=", "n_features", "\n", "n_kernels", "=", "50", "\n", "n_jobs", "=", "1", "\n", "\n", "dictionary", ",", "X", ",", "code", "=", "_generate_testbed", "(", "\n", "kernel_init_len", "=", "kernel_init_len", ",", "\n", "n_nonzero_coefs", "=", "n_nonzero_coefs", ",", "\n", "n_kernels", "=", "n_kernels", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "n_features", "=", "n_features", ",", "\n", "n_dims", "=", "n_dims", ",", "\n", "rng", "=", "rng_global", ",", "\n", "Gaussian", "=", "Gaussian", ",", "\n", ")", "\n", "rmse", "=", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "n_samples", ")", ")", "\n", "for", "k", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "        ", "for", "idx", ",", "s", "in", "enumerate", "(", "X", ")", ":", "\n", "            ", "r", ",", "_", "=", "multivariate_sparse_encode", "(", "\n", "array", "(", "s", ",", "ndmin", "=", "3", ")", ",", "\n", "dictionary", ",", "\n", "n_nonzero_coefs", "=", "k", "+", "1", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "verbose", "=", "1", ",", "\n", ")", "\n", "rmse", "[", "k", ",", "idx", "]", "=", "norm", "(", "r", "[", "0", "]", ",", "\"fro\"", ")", "/", "norm", "(", "s", ",", "\"fro\"", ")", "*", "100", "\n", "", "", "return", "rmse", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_multivariate.plot_multivariate": [[12, 60], ["matplotlib.figure", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.legend", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.legend", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.legend", "matplotlib.tight_layout", "matplotlib.savefig", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.min", "numpy.max", "numpy.arange", "len", "numpy.arange", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["None"], ["def", "plot_multivariate", "(", "objective_error", ",", "detection_rate", ",", "wasserstein", ",", "n_iter", ",", "figname", ")", ":", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "5", ")", ")", "\n", "step", "=", "n_iter", "\n", "\n", "# plotting data from objective error", "\n", "objerr", "=", "fig", ".", "add_subplot", "(", "1", ",", "3", ",", "1", ")", "\n", "_", "=", "objerr", ".", "plot", "(", "\n", "step", "*", "arange", "(", "1", ",", "len", "(", "objective_error", ")", "+", "1", ")", ",", "\n", "objective_error", ",", "\n", "color", "=", "\"green\"", ",", "\n", "label", "=", "r\"Objective error\"", ",", "\n", ")", "\n", "objerr", ".", "axis", "(", "[", "0", ",", "len", "(", "objective_error", ")", "-", "1", ",", "min", "(", "objective_error", ")", ",", "max", "(", "objective_error", ")", "]", ")", "\n", "objerr", ".", "set_xticks", "(", "arange", "(", "0", ",", "step", "*", "len", "(", "objective_error", ")", "+", "1", ",", "step", ")", ")", "\n", "objerr", ".", "set_xlabel", "(", "\"Iteration\"", ")", "\n", "objerr", ".", "set_ylabel", "(", "r\"Error (no unit)\"", ")", "\n", "objerr", ".", "legend", "(", "loc", "=", "\"upper right\"", ")", "\n", "\n", "# plotting data from detection rate 0.99", "\n", "detection", "=", "fig", ".", "add_subplot", "(", "1", ",", "3", ",", "2", ")", "\n", "_", "=", "detection", ".", "plot", "(", "\n", "step", "*", "arange", "(", "1", ",", "len", "(", "detection_rate", ")", "+", "1", ")", ",", "\n", "detection_rate", ",", "\n", "color", "=", "\"magenta\"", ",", "\n", "label", "=", "r\"Detection rate 0.99\"", ",", "\n", ")", "\n", "detection", ".", "axis", "(", "[", "0", ",", "len", "(", "detection_rate", ")", ",", "0", ",", "100", "]", ")", "\n", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "step", "*", "len", "(", "detection_rate", ")", "+", "1", ",", "step", ")", ")", "\n", "detection", ".", "set_xlabel", "(", "\"Iteration\"", ")", "\n", "detection", ".", "set_ylabel", "(", "r\"Recovery rate (in %)\"", ")", "\n", "detection", ".", "legend", "(", "loc", "=", "\"upper left\"", ")", "\n", "\n", "# plotting data from our metric", "\n", "met", "=", "fig", ".", "add_subplot", "(", "1", ",", "3", ",", "3", ")", "\n", "_", "=", "met", ".", "plot", "(", "\n", "step", "*", "arange", "(", "1", ",", "len", "(", "wasserstein", ")", "+", "1", ")", ",", "\n", "1", "-", "wasserstein", ",", "\n", "label", "=", "r\"$d_W$\"", ",", "\n", "color", "=", "\"red\"", ",", "\n", ")", "\n", "met", ".", "axis", "(", "[", "0", ",", "len", "(", "wasserstein", ")", ",", "0", ",", "1", "]", ")", "\n", "met", ".", "set_xticks", "(", "arange", "(", "0", ",", "step", "*", "len", "(", "wasserstein", ")", "+", "1", ",", "step", ")", ")", "\n", "met", ".", "set_xlabel", "(", "\"Iteration\"", ")", "\n", "met", ".", "set_ylabel", "(", "r\"Recovery distance\"", ")", "\n", "met", ".", "legend", "(", "loc", "=", "\"upper left\"", ")", "\n", "\n", "plt", ".", "tight_layout", "(", "0.5", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_multivariate._generate_testbed": [[62, 107], ["range", "list", "list", "range", "numpy.array", "numpy.random.randn", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "numpy.random.permutation", "range", "list.append", "numpy.random.randn", "np.array.append", "range", "range", "numpy.random.randint", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.rand"], "function", ["None"], ["", "def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "\n", "n_nonzero_coefs", ",", "\n", "n_kernels", ",", "\n", "n_samples", "=", "10", ",", "\n", "n_features", "=", "5", ",", "\n", "n_dims", "=", "3", ",", "\n", "snr", "=", "1000", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary\n\n    Generate a random dictionary and a dataset, where samples are combination of\n    n_nonzero_coefs dictionary atoms. Noise is added, based on SNR value, with\n    1000 indicated that no noise should be added.\n    Return the dictionary, the dataset and an array indicated how atoms are combined\n    to obtain each sample\n    \"\"\"", "\n", "dico", "=", "[", "randn", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "noise", "=", "randn", "(", "n_features", ",", "n_dims", ")", "\n", "if", "snr", "==", "1000", ":", "\n", "            ", "alpha", "=", "0", "\n", "", "else", ":", "\n", "            ", "ps", "=", "norm", "(", "s", ",", "\"fro\"", ")", "\n", "pn", "=", "norm", "(", "noise", ",", "\"fro\"", ")", "\n", "alpha", "=", "ps", "/", "(", "pn", "*", "10", "**", "(", "snr", "/", "20.0", ")", ")", "\n", "", "signals", ".", "append", "(", "s", "+", "alpha", "*", "noise", ")", "\n", "", "signals", "=", "np", ".", "array", "(", "signals", ")", "\n", "\n", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_multivariate.callback_distance": [[161, 172], ["numpy.mod", "d.wasserstein.append", "d.detect_rate.append", "d.objective_error.append", "dict_metrics.emd", "dict_metrics.detection_rate", "int"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate"], ["def", "callback_distance", "(", "loc", ")", ":", "\n", "    ", "ii", ",", "iter_offset", "=", "loc", "[", "\"ii\"", "]", ",", "loc", "[", "\"iter_offset\"", "]", "\n", "n_batches", "=", "loc", "[", "\"n_batches\"", "]", "\n", "if", "np", ".", "mod", "(", "(", "ii", "-", "iter_offset", ")", "/", "int", "(", "n_batches", ")", ",", "n_iter", ")", "==", "0", ":", "\n", "# Compute distance only every 5 iterations, as in previous case", "\n", "        ", "d", "=", "loc", "[", "\"dict_obj\"", "]", "\n", "d", ".", "wasserstein", ".", "append", "(", "\n", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal\"", ",", "scale", "=", "True", ")", "\n", ")", "\n", "d", ".", "detect_rate", ".", "append", "(", "detection_rate", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "0.99", ")", ")", "\n", "d", ".", "objective_error", ".", "append", "(", "loc", "[", "\"current_cost\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_kernels": [[19, 67], ["int", "range", "range", "range", "range", "int", "matplotlib.figure", "range", "matplotlib.tight_layout", "matplotlib.savefig", "int", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "fig.add_subplot.set_title", "int", "int", "int", "str", "int"], "function", ["None"], ["def", "plot_kernels", "(", "\n", "kernels", ",", "\n", "n_kernels", ",", "\n", "col", "=", "5", ",", "\n", "row", "=", "-", "1", ",", "\n", "order", "=", "None", ",", "\n", "amp", "=", "None", ",", "\n", "figname", "=", "\"allkernels\"", ",", "\n", "label", "=", "None", ",", "\n", ")", ":", "\n", "    ", "n_display", "=", "idx", "=", "0", "\n", "if", "n_kernels", "==", "row", "*", "col", ":", "\n", "        ", "pass", "\n", "", "elif", "row", "==", "-", "1", ":", "\n", "        ", "row", "=", "n_kernels", "/", "int", "(", "col", ")", "\n", "if", "n_kernels", "%", "int", "(", "col", ")", "!=", "0", ":", "\n", "            ", "row", "+=", "1", "\n", "", "", "elif", "col", "==", "-", "1", ":", "\n", "        ", "col", "=", "n_kernels", "/", "int", "(", "row", ")", "\n", "if", "n_kernels", "%", "int", "(", "row", ")", "!=", "0", ":", "\n", "            ", "col", "+=", "1", "\n", "", "", "n_display", "=", "row", "*", "col", "\n", "n_figure", "=", "int", "(", "n_kernels", "/", "n_display", ")", "\n", "if", "n_kernels", "%", "int", "(", "n_display", ")", "!=", "0", ":", "\n", "        ", "n_figure", "+=", "1", "\n", "", "if", "order", "is", "None", ":", "\n", "        ", "order", "=", "range", "(", "n_kernels", ")", "\n", "", "if", "label", "is", "None", ":", "\n", "        ", "label", "=", "range", "(", "n_kernels", ")", "\n", "", "if", "amp", "is", "None", ":", "\n", "        ", "amp", "=", "range", "(", "n_kernels", ")", "\n", "\n", "", "for", "j", "in", "range", "(", "int", "(", "n_figure", ")", ")", ":", "\n", "        ", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "10", ")", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_display", "+", "1", ")", ":", "\n", "            ", "if", "idx", "+", "i", ">", "n_kernels", ":", "\n", "                ", "break", "\n", "", "k", "=", "fig", ".", "add_subplot", "(", "row", ",", "col", ",", "i", ")", "\n", "k", ".", "plot", "(", "kernels", "[", "order", "[", "-", "(", "idx", "+", "i", ")", "]", "]", ")", "\n", "k", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "k", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "k", ".", "set_title", "(", "\n", "\"k %d: %d-%g\"", "\n", "%", "(", "order", "[", "-", "(", "idx", "+", "i", ")", "]", ",", "label", "[", "order", "[", "-", "(", "idx", "+", "i", ")", "]", "]", ",", "amp", "[", "order", "[", "-", "(", "idx", "+", "i", ")", "]", "]", ")", "\n", ")", "\n", "", "idx", "+=", "n_display", "\n", "plt", ".", "tight_layout", "(", "0.5", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\"-part\"", "+", "str", "(", "j", ")", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_reconstruction_samples": [[69, 109], ["numpy.zeros", "range", "numpy.zeros", "range", "numpy.argsort", "matplotlib.figure", "plt.figure.add_subplot", "fig.add_subplot.set_xticklabels", "fig.add_subplot.set_yticklabels", "range", "zip", "matplotlib.tight_layout", "matplotlib.savefig", "len", "len", "numpy.linalg.norm", "len", "len", "numpy.linalg.norm", "fig.add_subplot.plot", "fig.add_subplot.set_title", "plt.figure.add_subplot", "fig.add_subplot.plot", "plt.figure.add_subplot", "mdla.reconstruct_from_code", "fig.add_subplot.plot", "range", "range", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.set_title", "plt.figure.add_subplot", "fig.add_subplot.plot", "plt.figure.add_subplot", "mdla.reconstruct_from_code", "fig.add_subplot.plot", "plt.figure.add_subplot"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.reconstruct_from_code", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.reconstruct_from_code"], ["", "", "def", "plot_reconstruction_samples", "(", "X", ",", "r", ",", "code", ",", "kernels", ",", "n", ",", "figname", ")", ":", "\n", "    ", "n_features", "=", "X", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "energy_residual", "=", "zeros", "(", "len", "(", "r", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "r", ")", ")", ":", "\n", "        ", "energy_residual", "[", "i", "]", "=", "norm", "(", "r", "[", "i", "]", ",", "\"fro\"", ")", "\n", "", "energy_sample", "=", "zeros", "(", "len", "(", "X", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "        ", "energy_sample", "[", "i", "]", "=", "norm", "(", "X", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "energy_explained", "=", "energy_residual", "/", "energy_sample", "\n", "index", "=", "argsort", "(", "energy_explained", ")", "# 0 =worse, end=best", "\n", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "9", ")", ")", "\n", "k", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "1", ")", "\n", "k", ".", "set_xticklabels", "(", "[", "]", ")", "\n", "k", ".", "set_yticklabels", "(", "[", "]", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "if", "i", "!=", "0", ":", "\n", "            ", "ka", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "i", "+", "1", ",", "sharex", "=", "k", ",", "sharey", "=", "k", ")", "\n", "", "else", ":", "\n", "            ", "ka", "=", "k", "\n", "", "ka", ".", "plot", "(", "X", "[", "index", "[", "i", "]", "]", ")", "\n", "ka", ".", "set_title", "(", "\"s%d: %.1f%%\"", "%", "(", "index", "[", "i", "]", ",", "100.0", "*", "(", "1", "-", "energy_explained", "[", "index", "[", "i", "]", "]", ")", ")", ")", "\n", "ka", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "2", "*", "n", "+", "i", "+", "1", ",", "sharex", "=", "k", ",", "sharey", "=", "k", ")", "\n", "ka", ".", "plot", "(", "r", "[", "index", "[", "i", "]", "]", ")", "\n", "ka", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "4", "*", "n", "+", "i", "+", "1", ",", "sharex", "=", "k", ",", "sharey", "=", "k", ")", "\n", "s", "=", "reconstruct_from_code", "(", "[", "code", "[", "index", "[", "i", "]", "]", "]", ",", "kernels", ",", "n_features", ")", "\n", "ka", ".", "plot", "(", "s", "[", "0", ",", ":", ",", ":", "]", ")", "\n", "", "for", "j", ",", "i", "in", "zip", "(", "range", "(", "n", ",", "2", "*", "n", ")", ",", "range", "(", "n", ",", "0", ",", "-", "1", ")", ")", ":", "\n", "        ", "ka", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "j", "+", "1", ",", "sharex", "=", "k", ",", "sharey", "=", "k", ")", "\n", "ka", ".", "plot", "(", "X", "[", "index", "[", "-", "i", "]", "]", ")", "\n", "ka", ".", "set_title", "(", "\n", "\"s%d: %.1f%%\"", "%", "(", "index", "[", "-", "i", "]", ",", "100.0", "*", "(", "1", "-", "energy_explained", "[", "index", "[", "-", "i", "]", "]", ")", ")", "\n", ")", "\n", "ka", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "2", "*", "n", "+", "j", "+", "1", ",", "sharex", "=", "k", ",", "sharey", "=", "k", ")", "\n", "ka", ".", "plot", "(", "r", "[", "index", "[", "-", "i", "]", "]", ")", "\n", "ka", "=", "fig", ".", "add_subplot", "(", "3", ",", "2", "*", "n", ",", "4", "*", "n", "+", "j", "+", "1", ",", "sharex", "=", "k", ",", "sharey", "=", "k", ")", "\n", "s", "=", "reconstruct_from_code", "(", "[", "code", "[", "index", "[", "-", "i", "]", "]", "]", ",", "kernels", ",", "n_features", ")", "\n", "ka", ".", "plot", "(", "s", "[", "0", ",", ":", ",", ":", "]", ")", "\n", "", "plt", ".", "tight_layout", "(", "0.5", ")", "\n", "plt", ".", "savefig", "(", "\"EEG-reconstruction\"", "+", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_objective_func_box": [[111, 118], ["matplotlib.figure", "plt.figure.add_subplot", "fig.add_subplot.boxplot", "fig.add_subplot.plot", "matplotlib.savefig", "numpy.arange", "median.get_ydata", "enumerate"], "function", ["None"], ["", "def", "plot_objective_func_box", "(", "error", ",", "n_iter", ",", "figname", ")", ":", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "objf", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "ofun", "=", "objf", ".", "boxplot", "(", "error", ".", "T", ")", "\n", "medianof", "=", "[", "median", ".", "get_ydata", "(", ")", "[", "0", "]", "for", "n", ",", "median", "in", "enumerate", "(", "ofun", "[", "\"medians\"", "]", ")", "]", "\n", "_", "=", "objf", ".", "plot", "(", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "medianof", ",", "linewidth", "=", "1", ")", "\n", "plt", ".", "savefig", "(", "\"EEG-decomposition-error\"", "+", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_objective_func": [[120, 135], ["matplotlib.figure", "plt.figure.add_subplot", "numpy.percentile", "fig.add_subplot.fill_between", "fig.add_subplot.fill_between", "fig.add_subplot.plot", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "matplotlib.tight_layout", "matplotlib.savefig", "numpy.arange", "numpy.arange", "numpy.arange"], "function", ["None"], ["", "def", "plot_objective_func", "(", "error", ",", "n_iter", ",", "figname", ")", ":", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "objf", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "p0", ",", "p25", ",", "med", ",", "p75", ",", "p100", "=", "percentile", "(", "error", ",", "(", "0", ",", "25", ",", "50", ",", "75", ",", "100", ")", ",", "axis", "=", "1", ")", "\n", "objf", ".", "fill_between", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "p0", ",", "p100", ",", "facecolor", "=", "\"blue\"", ",", "alpha", "=", "0.1", ",", "interpolate", "=", "True", "\n", ")", "\n", "objf", ".", "fill_between", "(", "\n", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "p25", ",", "p75", ",", "facecolor", "=", "\"blue\"", ",", "alpha", "=", "0.3", ",", "interpolate", "=", "True", "\n", ")", "\n", "objf", ".", "plot", "(", "arange", "(", "1", ",", "n_iter", "+", "1", ")", ",", "med", ",", "linewidth", "=", "2.5", ",", "color", "=", "\"blue\"", ")", "\n", "objf", ".", "set_xlabel", "(", "\"Iterations\"", ")", "\n", "objf", ".", "set_ylabel", "(", "\"Objective function\"", ")", "\n", "plt", ".", "tight_layout", "(", "0.5", ")", "\n", "plt", ".", "savefig", "(", "\"EEG-decomposition-error\"", "+", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_coef_hist": [[137, 144], ["sorted", "zip", "numpy.arange", "matplotlib.figure", "matplotlib.bar", "matplotlib.savefig", "collections.Counter().items", "len", "collections.Counter"], "function", ["None"], ["", "def", "plot_coef_hist", "(", "decomposition_weight", ",", "figname", ",", "width", "=", "1", ")", ":", "\n", "    ", "correlation", "=", "sorted", "(", "Counter", "(", "decomposition_weight", ")", ".", "items", "(", ")", ")", "\n", "labels", ",", "values", "=", "zip", "(", "*", "correlation", ")", "\n", "indexes", "=", "arange", "(", "len", "(", "correlation", ")", ")", "\n", "plt", ".", "figure", "(", ")", "\n", "plt", ".", "bar", "(", "indexes", ",", "values", ",", "width", ",", "linewidth", "=", "0", ")", "\n", "plt", ".", "savefig", "(", "\"EEG-coeff_hist_sorted\"", "+", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_weight_hist": [[146, 153], ["amplitudes.sort", "numpy.arange", "matplotlib.figure", "matplotlib.bar", "matplotlib.savefig", "len"], "function", ["None"], ["", "def", "plot_weight_hist", "(", "amplitudes", ",", "figname", ",", "width", "=", "1", ")", ":", "\n", "    ", "amplitudes", ".", "sort", "(", ")", "\n", "indexes", "=", "arange", "(", "len", "(", "amplitudes", ")", ")", "\n", "plt", ".", "figure", "(", ")", "\n", "width", "=", "1", "\n", "plt", ".", "bar", "(", "indexes", ",", "amplitudes", ",", "width", ",", "linewidth", "=", "0", ")", "\n", "plt", ".", "savefig", "(", "\"EEG-weight_sorted\"", "+", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_atom_usage": [[155, 181], ["mdla.multivariate_sparse_encode", "len", "numpy.zeros", "range", "numpy.hstack", "numpy.hstack.sort", "numpy.histogram", "weight.argsort", "plot_bci_dict.plot_kernels", "plot_bci_dict.plot_coef_hist", "plot_bci_dict.plot_weight_hist", "plot_bci_dict.plot_reconstruction_samples", "len", "range", "len", "len", "numpy.abs", "range", "int", "len"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode", "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_kernels", "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_coef_hist", "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_weight_hist", "home.repos.pwc.inspect_result.sylvchev_mdla.examples.plot_bci_dict.plot_reconstruction_samples"], ["", "def", "plot_atom_usage", "(", "X", ",", "kernels", ",", "n_nonzero_coefs", ",", "n_jobs", ",", "figname", ")", ":", "\n", "    ", "r", ",", "code", "=", "multivariate_sparse_encode", "(", "\n", "X", ",", "kernels", ",", "n_nonzero_coefs", "=", "n_nonzero_coefs", ",", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "2", "\n", ")", "\n", "n_kernels", "=", "len", "(", "kernels", ")", "\n", "amplitudes", "=", "zeros", "(", "n_kernels", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "code", ")", ")", ":", "\n", "        ", "for", "s", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "amplitudes", "[", "int", "(", "code", "[", "i", "]", "[", "s", ",", "2", "]", ")", "]", "+=", "abs", "(", "code", "[", "i", "]", "[", "s", ",", "0", "]", ")", "\n", "\n", "", "", "decomposition_weight", "=", "hstack", "(", "[", "code", "[", "i", "]", "[", ":", ",", "2", "]", "for", "i", "in", "range", "(", "len", "(", "code", ")", ")", "]", ")", "\n", "decomposition_weight", ".", "sort", "(", ")", "\n", "weight", ",", "_", "=", "histogram", "(", "decomposition_weight", ",", "len", "(", "kernels", ")", ",", "normed", "=", "False", ")", "\n", "order", "=", "weight", ".", "argsort", "(", ")", "\n", "plot_kernels", "(", "\n", "kernels", ",", "\n", "len", "(", "kernels", ")", ",", "\n", "order", "=", "order", ",", "\n", "label", "=", "weight", ",", "\n", "amp", "=", "amplitudes", ",", "\n", "figname", "=", "\"EEG-kernels\"", "+", "figname", ",", "\n", "row", "=", "6", ",", "\n", ")", "\n", "plot_coef_hist", "(", "decomposition_weight", ",", "figname", ")", "\n", "plot_weight_hist", "(", "amplitudes", ",", "figname", ")", "\n", "plot_reconstruction_samples", "(", "X", ",", "r", ",", "code", ",", "kernels", ",", "3", ",", "figname", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_benchmark_performance.benchmarking_plot": [[19, 63], ["matplotlib.figure", "matplotlib.bar", "range", "range", "matplotlib.ylabel", "matplotlib.title", "tick.extend", "tick.extend", "matplotlib.xticks", "matplotlib.legend", "matplotlib.savefig", "numpy.array", "index.append", "index.append", "map", "map", "tuple", "matplotlib.bar", "matplotlib.bar", "matplotlib.bar", "matplotlib.bar", "numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["def", "benchmarking_plot", "(", "figname", ",", "pst", ",", "plot_sep", ",", "minibatchRange", ",", "mprocessRange", ")", ":", "\n", "    ", "_", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "10", ")", ")", "\n", "bar_width", "=", "0.35", "\n", "_", "=", "plt", ".", "bar", "(", "\n", "np", ".", "array", "(", "[", "0", "]", ")", ",", "\n", "pst", "[", "0", "]", ",", "\n", "bar_width", ",", "\n", "color", "=", "\"b\"", ",", "\n", "label", "=", "\"Online, no multiprocessing (baseline)\"", ",", "\n", ")", "\n", "index", "=", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "plot_sep", "[", "1", "]", ")", ":", "\n", "        ", "if", "i", "==", "1", ":", "\n", "            ", "_", "=", "plt", ".", "bar", "(", "\n", "np", ".", "array", "(", "[", "i", "+", "1", "]", ")", ",", "\n", "pst", "[", "i", "]", ",", "\n", "bar_width", ",", "\n", "color", "=", "\"r\"", ",", "\n", "label", "=", "\"Online with minibatch\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "_", "=", "plt", ".", "bar", "(", "np", ".", "array", "(", "[", "i", "+", "1", "]", ")", ",", "pst", "[", "i", "]", ",", "bar_width", ",", "color", "=", "\"r\"", ")", "\n", "", "index", ".", "append", "(", "i", "+", "1", ")", "\n", "", "for", "_", "in", "range", "(", "plot_sep", "[", "1", "]", ",", "plot_sep", "[", "2", "]", ")", ":", "\n", "        ", "if", "i", "==", "plot_sep", "[", "1", "]", ":", "\n", "            ", "_", "=", "plt", ".", "bar", "(", "\n", "np", ".", "array", "(", "[", "i", "+", "2", "]", ")", ",", "\n", "pst", "[", "i", "]", ",", "\n", "bar_width", ",", "\n", "label", "=", "\"Batch with multiprocessing\"", ",", "\n", "color", "=", "\"magenta\"", ",", "\n", ")", "\n", "", "else", ":", "\n", "            ", "_", "=", "plt", ".", "bar", "(", "np", ".", "array", "(", "[", "i", "+", "2", "]", ")", ",", "pst", "[", "i", "]", ",", "bar_width", ",", "color", "=", "\"magenta\"", ")", "\n", "", "index", ".", "append", "(", "i", "+", "2", ")", "\n", "\n", "", "plt", ".", "ylabel", "(", "\"Time per iteration (s)\"", ")", "\n", "plt", ".", "title", "(", "\"Processing time for online and batch processing\"", ")", "\n", "tick", "=", "[", "\"\"", "]", "\n", "tick", ".", "extend", "(", "map", "(", "str", ",", "minibatchRange", ")", ")", "\n", "tick", ".", "extend", "(", "map", "(", "str", ",", "mprocessRange", ")", ")", "\n", "plt", ".", "xticks", "(", "index", ",", "tuple", "(", "tick", ")", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_benchmark_performance._generate_testbed": [[65, 111], ["print", "range", "list", "list", "range", "numpy.array", "numpy.random.rand", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "numpy.random.permutation", "range", "list.append", "numpy.random.randn", "np.array.append", "range", "range", "numpy.random.randint", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.rand"], "function", ["None"], ["", "def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "\n", "n_nonzero_coefs", ",", "\n", "n_kernels", ",", "\n", "n_samples", "=", "10", ",", "\n", "n_features", "=", "5", ",", "\n", "n_dims", "=", "3", ",", "\n", "snr", "=", "1000", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary\n\n    Generate a random dictionary and a dataset, where samples are combination of\n    n_nonzero_coefs dictionary atoms. Noise is added, based on SNR value, with\n    1000 indicated that no noise should be added.\n    Return the dictionary, the dataset and an array indicated how atoms are combined\n    to obtain each sample\n    \"\"\"", "\n", "print", "(", "\"Dictionary sampled from uniform distribution\"", ")", "\n", "dico", "=", "[", "rand", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "noise", "=", "randn", "(", "n_features", ",", "n_dims", ")", "\n", "if", "snr", "==", "1000", ":", "\n", "            ", "alpha", "=", "0", "\n", "", "else", ":", "\n", "            ", "ps", "=", "norm", "(", "s", ",", "\"fro\"", ")", "\n", "pn", "=", "norm", "(", "noise", ",", "\"fro\"", ")", "\n", "alpha", "=", "ps", "/", "(", "pn", "*", "10", "**", "(", "snr", "/", "20.0", ")", ")", "\n", "", "signals", ".", "append", "(", "s", "+", "alpha", "*", "noise", ")", "\n", "", "signals", "=", "np", ".", "array", "(", "signals", ")", "\n", "\n", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_univariate.plot_univariate": [[12, 68], ["matplotlib.figure", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.legend", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.legend", "plt.figure.add_subplot", "fig.add_subplot.plot", "fig.add_subplot.axis", "fig.add_subplot.set_xticks", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.legend", "matplotlib.tight_layout", "matplotlib.savefig", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.min", "numpy.max", "numpy.arange", "len", "numpy.arange", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["None"], ["def", "plot_univariate", "(", "objective_error", ",", "detect_rate", ",", "wasserstein", ",", "n_iter", ",", "figname", ")", ":", "\n", "    ", "fig", "=", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "5", ")", ")", "\n", "if", "n_iter", "==", "1", ":", "\n", "        ", "step", "=", "5", "\n", "", "else", ":", "\n", "        ", "step", "=", "n_iter", "\n", "\n", "# plotting data from objective error", "\n", "", "objerr", "=", "fig", ".", "add_subplot", "(", "1", ",", "3", ",", "1", ")", "\n", "# ofun = objerr.boxplot(objective_error)", "\n", "# medianof = [median.get_ydata()[0]", "\n", "#             for n, median in enumerate(ofun['medians'])]", "\n", "# _ = objerr.plot(arange(1, n_iter+1), medianof, linewidth=1)", "\n", "\n", "_", "=", "objerr", ".", "plot", "(", "\n", "step", "*", "arange", "(", "1", ",", "len", "(", "objective_error", ")", "+", "1", ")", ",", "\n", "objective_error", ",", "\n", "color", "=", "\"green\"", ",", "\n", "label", "=", "r\"Objective error\"", ",", "\n", ")", "\n", "objerr", ".", "axis", "(", "[", "0", ",", "len", "(", "objective_error", ")", "-", "1", ",", "min", "(", "objective_error", ")", ",", "max", "(", "objective_error", ")", "]", ")", "\n", "objerr", ".", "set_xticks", "(", "arange", "(", "0", ",", "step", "*", "len", "(", "objective_error", ")", "+", "1", ",", "step", ")", ")", "\n", "objerr", ".", "set_xlabel", "(", "\"Iteration\"", ")", "\n", "objerr", ".", "set_ylabel", "(", "r\"Error (no unit)\"", ")", "\n", "objerr", ".", "legend", "(", "loc", "=", "\"upper right\"", ")", "\n", "\n", "# plotting data from detection rate 0.99", "\n", "detection", "=", "fig", ".", "add_subplot", "(", "1", ",", "3", ",", "2", ")", "\n", "_", "=", "detection", ".", "plot", "(", "\n", "step", "*", "arange", "(", "1", ",", "len", "(", "detect_rate", ")", "+", "1", ")", ",", "\n", "detect_rate", ",", "\n", "color", "=", "\"magenta\"", ",", "\n", "label", "=", "r\"Detection rate 0.99\"", ",", "\n", ")", "\n", "detection", ".", "axis", "(", "[", "0", ",", "len", "(", "detect_rate", ")", ",", "0", ",", "100", "]", ")", "\n", "detection", ".", "set_xticks", "(", "arange", "(", "0", ",", "step", "*", "len", "(", "detect_rate", ")", "+", "1", ",", "step", ")", ")", "\n", "detection", ".", "set_xlabel", "(", "\"Iteration\"", ")", "\n", "detection", ".", "set_ylabel", "(", "r\"Recovery rate (in %)\"", ")", "\n", "detection", ".", "legend", "(", "loc", "=", "\"upper left\"", ")", "\n", "\n", "# plotting data from our metric", "\n", "met", "=", "fig", ".", "add_subplot", "(", "1", ",", "3", ",", "3", ")", "\n", "_", "=", "met", ".", "plot", "(", "\n", "step", "*", "arange", "(", "1", ",", "len", "(", "wasserstein", ")", "+", "1", ")", ",", "\n", "100", "*", "(", "1", "-", "wasserstein", ")", ",", "\n", "label", "=", "r\"$d_W$\"", ",", "\n", "color", "=", "\"red\"", ",", "\n", ")", "\n", "met", ".", "axis", "(", "[", "0", ",", "len", "(", "wasserstein", ")", ",", "0", ",", "100", "]", ")", "\n", "met", ".", "set_xticks", "(", "arange", "(", "0", ",", "step", "*", "len", "(", "wasserstein", ")", "+", "1", ",", "step", ")", ")", "\n", "met", ".", "set_xlabel", "(", "\"Iteration\"", ")", "\n", "met", ".", "set_ylabel", "(", "r\"Recovery rate (in %)\"", ")", "\n", "met", ".", "legend", "(", "loc", "=", "\"upper left\"", ")", "\n", "\n", "plt", ".", "tight_layout", "(", "0.5", ")", "\n", "plt", ".", "savefig", "(", "figname", "+", "\".png\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_univariate._generate_testbed": [[70, 115], ["range", "list", "list", "range", "numpy.array", "numpy.random.randn", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "numpy.random.permutation", "range", "list.append", "numpy.random.randn", "np.array.append", "range", "range", "numpy.random.randint", "numpy.array", "numpy.linalg.norm", "numpy.linalg.norm", "numpy.random.rand"], "function", ["None"], ["", "def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "\n", "n_nonzero_coefs", ",", "\n", "n_kernels", ",", "\n", "n_samples", "=", "10", ",", "\n", "n_features", "=", "5", ",", "\n", "n_dims", "=", "3", ",", "\n", "snr", "=", "1000", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Generate a dataset from a random dictionary\n\n    Generate a random dictionary and a dataset, where samples are combination of\n    n_nonzero_coefs dictionary atoms. Noise is added, based on SNR value, with\n    1000 indicated that no noise should be added.\n    Return the dictionary, the dataset and an array indicated how atoms are combined\n    to obtain each sample\n    \"\"\"", "\n", "dico", "=", "[", "randn", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "noise", "=", "randn", "(", "n_features", ",", "n_dims", ")", "\n", "if", "snr", "==", "1000", ":", "\n", "            ", "alpha", "=", "0", "\n", "", "else", ":", "\n", "            ", "ps", "=", "norm", "(", "s", ",", "\"fro\"", ")", "\n", "pn", "=", "norm", "(", "noise", ",", "\"fro\"", ")", "\n", "alpha", "=", "ps", "/", "(", "pn", "*", "10", "**", "(", "snr", "/", "20.0", ")", ")", "\n", "", "signals", ".", "append", "(", "s", "+", "alpha", "*", "noise", ")", "\n", "", "signals", "=", "np", ".", "array", "(", "signals", ")", "\n", "\n", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.examples.example_univariate.callback_distance": [[169, 180], ["numpy.mod", "d.wasserstein.append", "d.detect_rate.append", "d.objective_error.append", "dict_metrics.emd", "dict_metrics.detection_rate", "int"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate"], ["def", "callback_distance", "(", "loc", ")", ":", "\n", "    ", "ii", ",", "iter_offset", "=", "loc", "[", "\"ii\"", "]", ",", "loc", "[", "\"iter_offset\"", "]", "\n", "n_batches", "=", "loc", "[", "\"n_batches\"", "]", "\n", "if", "np", ".", "mod", "(", "(", "ii", "-", "iter_offset", ")", "/", "int", "(", "n_batches", ")", ",", "n_iter", ")", "==", "0", ":", "\n", "# Compute distance only every 5 iterations, as in previous case", "\n", "        ", "d", "=", "loc", "[", "\"dict_obj\"", "]", "\n", "d", ".", "wasserstein", ".", "append", "(", "\n", "emd", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "\"chordal\"", ",", "scale", "=", "True", ")", "\n", ")", "\n", "d", ".", "detect_rate", ".", "append", "(", "detection_rate", "(", "loc", "[", "\"dictionary\"", "]", ",", "d", ".", "generating_dict", ",", "0.99", ")", ")", "\n", "d", ".", "objective_error", ".", "append", "(", "loc", "[", "\"current_cost\"", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_shapes": [[16, 31], ["mdla.MultivariateDictLearning().fit", "range", "mdla.MiniBatchMultivariateDictLearning().fit", "range", "rng_global.randn", "range", "mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["def", "test_mdla_shapes", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "10", ",", "verbose", "=", "5", "\n", ")", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert", "dico", ".", "kernels_", "[", "i", "]", ".", "shape", "==", "(", "n_features", ",", "n_dims", ")", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "verbose", "=", "5", ",", "n_iter", "=", "10", "\n", ")", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert", "dico", ".", "kernels_", "[", "i", "]", ".", "shape", "==", "(", "n_features", ",", "n_dims", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_multivariate_input_shape": [[33, 60], ["mdla.MultivariateDictLearning().fit", "range", "mdla.MultivariateDictLearning", "numpy.testing.assert_raises", "mdla.MiniBatchMultivariateDictLearning().fit", "range", "mdla.MiniBatchMultivariateDictLearning", "numpy.testing.assert_raises", "mdla.MiniBatchMultivariateDictLearning().partial_fit", "range", "mdla.MiniBatchMultivariateDictLearning", "numpy.testing.assert_raises", "rng_global.randn", "rng_global.randn", "range", "range", "mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.partial_fit"], ["", "", "def", "test_multivariate_input_shape", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "7", "\n", "n_dims_w", "=", "6", "\n", "Xw", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims_w", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "\n", "dico", "=", "MultivariateDictLearning", "(", "n_kernels", "=", "n_kernels", ")", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert", "dico", ".", "kernels_", "[", "i", "]", ".", "shape", "==", "(", "n_features", ",", "n_dims", ")", "\n", "\n", "", "dico", "=", "MultivariateDictLearning", "(", "n_kernels", "=", "n_kernels", ")", "\n", "assert_raises", "(", "ValueError", ",", "dico", ".", "fit", ",", "Xw", ")", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "n_kernels", "=", "n_kernels", ")", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert", "dico", ".", "kernels_", "[", "i", "]", ".", "shape", "==", "(", "n_features", ",", "n_dims", ")", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "n_kernels", "=", "n_kernels", ")", "\n", "assert_raises", "(", "ValueError", ",", "dico", ".", "fit", ",", "Xw", ")", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "n_kernels", "=", "n_kernels", ")", ".", "partial_fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert", "dico", ".", "kernels_", "[", "i", "]", ".", "shape", "==", "(", "n_features", ",", "n_dims", ")", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "n_kernels", "=", "n_kernels", ")", "\n", "assert_raises", "(", "ValueError", ",", "dico", ".", "partial_fit", ",", "Xw", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_normalization": [[62, 77], ["mdla.MultivariateDictLearning().fit", "mdla.MiniBatchMultivariateDictLearning().fit", "rng_global.randn", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "range", "mdla.MultivariateDictLearning", "numpy.linalg.norm", "mdla.MiniBatchMultivariateDictLearning", "numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "def", "test_mdla_normalization", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "2", ",", "verbose", "=", "1", "\n", ")", ".", "fit", "(", "X", ")", "\n", "for", "k", "in", "dico", ".", "kernels_", ":", "\n", "        ", "assert_almost_equal", "(", "np", ".", "linalg", ".", "norm", "(", "k", ",", "\"fro\"", ")", ",", "1.0", ")", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "n_iter", "=", "2", ",", "verbose", "=", "1", "\n", ")", ".", "fit", "(", "X", ")", "\n", "for", "k", "in", "dico", ".", "kernels_", ":", "\n", "        ", "assert_almost_equal", "(", "np", ".", "linalg", ".", "norm", "(", "k", ",", "\"fro\"", ")", ",", "1.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_callback": [[79, 105], ["mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "rng_global.randn", "len", "len", "range", "mdla.MiniBatchMultivariateDictLearning.fit", "mdla.MiniBatchMultivariateDictLearning.fit"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "", "def", "test_callback", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "\n", "def", "my_callback", "(", "loc", ")", ":", "\n", "        ", "_", "=", "loc", "[", "\"dict_obj\"", "]", "\n", "\n", "", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "\n", "random_state", "=", "0", ",", "\n", "max_iter", "=", "2", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "callback", "=", "my_callback", ",", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "1", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "\n", "random_state", "=", "0", ",", "\n", "n_iter", "=", "2", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "callback", "=", "my_callback", ",", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_nonzero_coefs": [[107, 122], ["mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "rng_global.randn", "len", "len", "range", "mdla.MiniBatchMultivariateDictLearning.fit", "mdla.MiniBatchMultivariateDictLearning.fit"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "def", "test_mdla_nonzero_coefs", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "3", ",", "n_nonzero_coefs", "=", "3", ",", "verbose", "=", "5", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "3", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "n_iter", "=", "3", ",", "n_nonzero_coefs", "=", "3", ",", "verbose", "=", "5", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_X_array": [[124, 139], ["rng_global.randn", "mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "len", "len", "mdla.MiniBatchMultivariateDictLearning.fit", "mdla.MiniBatchMultivariateDictLearning.fit"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "def", "test_X_array", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "n_kernels", "=", "8", "\n", "X", "=", "rng_global", ".", "randn", "(", "n_samples", ",", "n_features", ",", "n_dims", ")", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "3", ",", "n_nonzero_coefs", "=", "3", ",", "verbose", "=", "5", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "3", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "n_iter", "=", "3", ",", "n_nonzero_coefs", "=", "3", ",", "verbose", "=", "5", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "3", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_shuffle": [[141, 155], ["mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning.fit().transform", "rng_global.randn", "len", "range", "mdla.MiniBatchMultivariateDictLearning.fit"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "def", "test_mdla_shuffle", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "\n", "random_state", "=", "0", ",", "\n", "n_iter", "=", "3", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "verbose", "=", "5", ",", "\n", "shuffle", "=", "False", ",", "\n", ")", "\n", "code", "=", "dico", ".", "fit", "(", "X", ")", ".", "transform", "(", "X", "[", "0", "]", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_n_kernels": [[157, 174], ["mdla.MultivariateDictLearning().fit", "mdla.MiniBatchMultivariateDictLearning().fit", "mdla.MiniBatchMultivariateDictLearning().partial_fit", "rng_global.randn", "len", "len", "len", "range", "mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.partial_fit"], ["", "def", "test_n_kernels", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "random_state", "=", "0", ",", "max_iter", "=", "2", ",", "n_nonzero_coefs", "=", "1", ",", "verbose", "=", "5", "\n", ")", ".", "fit", "(", "X", ")", "\n", "assert", "len", "(", "dico", ".", "kernels_", ")", "==", "2", "*", "n_features", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "random_state", "=", "0", ",", "n_iter", "=", "2", ",", "n_nonzero_coefs", "=", "1", ",", "verbose", "=", "5", "\n", ")", ".", "fit", "(", "X", ")", "\n", "assert", "len", "(", "dico", ".", "kernels_", ")", "==", "2", "*", "n_features", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "random_state", "=", "0", ",", "n_iter", "=", "2", ",", "n_nonzero_coefs", "=", "1", ",", "verbose", "=", "5", "\n", ")", ".", "partial_fit", "(", "X", ")", "\n", "assert", "len", "(", "dico", ".", "kernels_", ")", "==", "2", "*", "n_features", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_nonzero_coef_errors": [[176, 189], ["mdla.MultivariateDictLearning", "numpy.testing.assert_raises", "mdla.MiniBatchMultivariateDictLearning", "numpy.testing.assert_raises", "rng_global.randn", "range"], "function", ["None"], ["", "def", "test_mdla_nonzero_coef_errors", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "2", ",", "n_nonzero_coefs", "=", "0", "\n", ")", "\n", "assert_raises", "(", "ValueError", ",", "dico", ".", "fit", ",", "X", ")", "\n", "\n", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "n_iter", "=", "2", ",", "n_nonzero_coefs", "=", "n_kernels", "+", "1", "\n", ")", "\n", "assert_raises", "(", "ValueError", ",", "dico", ".", "fit", ",", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_sparse_encode": [[191, 201], ["mdla.MultivariateDictLearning", "dico.fit.fit", "mdla.multivariate_sparse_encode", "rng_global.randn", "len", "range"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode"], ["", "def", "test_sparse_encode", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "2", ",", "n_nonzero_coefs", "=", "1", "\n", ")", "\n", "dico", "=", "dico", ".", "fit", "(", "X", ")", "\n", "_", ",", "code", "=", "multivariate_sparse_encode", "(", "X", ",", "dico", ",", "n_nonzero_coefs", "=", "1", ",", "n_jobs", "=", "-", "1", ",", "verbose", "=", "3", ")", "\n", "assert", "len", "(", "code", "[", "0", "]", ")", "<=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_dict_init": [[203, 237], ["range", "mdla.MultivariateDictLearning().fit", "dico.fit.fit", "range", "mdla.MiniBatchMultivariateDictLearning().fit", "dico.fit.fit", "range", "rng_global.randn", "rng_global.randn", "len", "numpy.linalg.norm", "numpy.testing.assert_array_almost_equal", "numpy.testing.assert_array_almost_equal", "range", "range", "mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "def", "test_dict_init", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "d", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "d", ")", ")", ":", "\n", "        ", "d", "[", "i", "]", "/=", "np", ".", "linalg", ".", "norm", "(", "d", "[", "i", "]", ",", "\"fro\"", ")", "\n", "", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "\n", "random_state", "=", "0", ",", "\n", "max_iter", "=", "1", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "learning_rate", "=", "0.0", ",", "\n", "dict_init", "=", "d", ",", "\n", "verbose", "=", "5", ",", "\n", ")", ".", "fit", "(", "X", ")", "\n", "dico", "=", "dico", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert_array_almost_equal", "(", "dico", ".", "kernels_", "[", "i", "]", ",", "d", "[", "i", "]", ")", "\n", "# code = dico.fit(X).transform(X[0])", "\n", "# assert (len(code[0]) > 1)", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "\n", "random_state", "=", "0", ",", "\n", "n_iter", "=", "1", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "dict_init", "=", "d", ",", "\n", "verbose", "=", "1", ",", "\n", "learning_rate", "=", "0.0", ",", "\n", ")", ".", "fit", "(", "X", ")", "\n", "dico", "=", "dico", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert_array_almost_equal", "(", "dico", ".", "kernels_", "[", "i", "]", ",", "d", "[", "i", "]", ")", "\n", "# code = dico.fit(X).transform(X[0])", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_dict_init": [[241, 253], ["mdla.MultivariateDictLearning().fit", "range", "rng_global.randn", "numpy.random.randn", "range", "range", "mdla.MultivariateDictLearning"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "", "def", "test_mdla_dict_init", "(", ")", ":", "\n", "    ", "n_kernels", "=", "10", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "20", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "dict_init", "=", "[", "np", ".", "random", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "10", ",", "dict_init", "=", "dict_init", "\n", ")", ".", "fit", "(", "X", ")", "\n", "diff", "=", "0.0", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "diff", "=", "diff", "+", "(", "dico", ".", "kernels_", "[", "i", "]", "-", "dict_init", "[", "i", "]", ")", ".", "sum", "(", ")", "\n", "", "assert", "diff", "!=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_dict_update": [[255, 286], ["mdla.MultivariateDictLearning().fit", "list", "dico.partial_fit.fit", "list", "zip", "mdla.MiniBatchMultivariateDictLearning().fit", "list", "dico.partial_fit.fit", "list", "zip", "mdla.MiniBatchMultivariateDictLearning().partial_fit", "list", "dico.partial_fit.partial_fit", "list", "zip", "rng_global.randn", "range", "mdla.MultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning", "mdla.MiniBatchMultivariateDictLearning"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.partial_fit", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.partial_fit"], ["", "def", "test_mdla_dict_update", "(", ")", ":", "\n", "    ", "n_kernels", "=", "10", "\n", "# n_samples, n_features, n_dims = 100, 5, 3", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "80", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "dico", "=", "MultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "max_iter", "=", "10", ",", "n_jobs", "=", "-", "1", "\n", ")", ".", "fit", "(", "X", ")", "\n", "first_epoch", "=", "list", "(", "dico", ".", "kernels_", ")", "\n", "dico", "=", "dico", ".", "fit", "(", "X", ")", "\n", "second_epoch", "=", "list", "(", "dico", ".", "kernels_", ")", "\n", "for", "k", ",", "c", "in", "zip", "(", "first_epoch", ",", "second_epoch", ")", ":", "\n", "        ", "assert", "(", "k", "-", "c", ")", ".", "sum", "(", ")", "!=", "0.0", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "n_iter", "=", "10", ",", "n_jobs", "=", "-", "1", "\n", ")", ".", "fit", "(", "X", ")", "\n", "first_epoch", "=", "list", "(", "dico", ".", "kernels_", ")", "\n", "dico", "=", "dico", ".", "fit", "(", "X", ")", "\n", "second_epoch", "=", "list", "(", "dico", ".", "kernels_", ")", "\n", "for", "k", ",", "c", "in", "zip", "(", "first_epoch", ",", "second_epoch", ")", ":", "\n", "        ", "assert", "(", "k", "-", "c", ")", ".", "sum", "(", ")", "!=", "0.0", "\n", "\n", "", "dico", "=", "MiniBatchMultivariateDictLearning", "(", "\n", "n_kernels", "=", "n_kernels", ",", "random_state", "=", "0", ",", "n_iter", "=", "10", ",", "n_jobs", "=", "-", "1", "\n", ")", ".", "partial_fit", "(", "X", ")", "\n", "first_epoch", "=", "list", "(", "dico", ".", "kernels_", ")", "\n", "dico", "=", "dico", ".", "partial_fit", "(", "X", ")", "\n", "second_epoch", "=", "list", "(", "dico", ".", "kernels_", ")", "\n", "for", "k", ",", "c", "in", "zip", "(", "first_epoch", ",", "second_epoch", ")", ":", "\n", "        ", "assert", "(", "k", "-", "c", ")", ".", "sum", "(", ")", "!=", "0.0", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_sparse_multivariate_coder": [[288, 297], ["mdla.SparseMultivariateCoder", "mdla.SparseMultivariateCoder.fit", "range", "rng_global.randn", "numpy.random.randn", "numpy.testing.assert_array_almost_equal", "range", "range"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit"], ["", "", "def", "test_sparse_multivariate_coder", "(", ")", ":", "\n", "    ", "n_samples", ",", "n_features", ",", "n_dims", "=", "10", ",", "5", ",", "3", "\n", "X", "=", "[", "rng_global", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_samples", ")", "]", "\n", "n_kernels", "=", "8", "\n", "d", "=", "[", "np", ".", "random", ".", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "coder", "=", "SparseMultivariateCoder", "(", "dictionary", "=", "d", ",", "n_nonzero_coefs", "=", "1", ",", "n_jobs", "=", "-", "1", ")", "\n", "coder", ".", "fit", "(", "X", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "assert_array_almost_equal", "(", "d", "[", "i", "]", ",", "coder", ".", "kernels_", "[", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.TODO_test_shift_invariant_input": [[299, 302], ["list", "list.append", "numpy.array"], "function", ["None"], ["", "", "def", "TODO_test_shift_invariant_input", "(", ")", ":", "\n", "    ", "dico", "=", "list", "(", ")", "\n", "dico", ".", "append", "(", "np", ".", "array", "(", "[", "1", ",", "2", ",", "3", ",", "2", ",", "1", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._generate_testbed": [[304, 328], ["range", "list", "list", "range", "numpy.array", "numpy.random.randn", "len", "numpy.linalg.norm", "numpy.zeros", "numpy.zeros", "numpy.random.permutation", "range", "list.append", "np.array.append", "range", "range", "numpy.random.randint", "numpy.array", "numpy.random.rand"], "function", ["None"], ["", "def", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "n_nonzero_coefs", ",", "n_kernels", ",", "n_samples", "=", "10", ",", "n_features", "=", "5", ",", "n_dims", "=", "3", "\n", ")", ":", "\n", "    ", "dico", "=", "[", "np", ".", "random", ".", "randn", "(", "kernel_init_len", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dico", ")", ")", ":", "\n", "        ", "dico", "[", "i", "]", "/=", "np", ".", "linalg", ".", "norm", "(", "dico", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "signals", "=", "list", "(", ")", "\n", "decomposition", "=", "list", "(", ")", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "s", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "d", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_nonzero_coefs", ",", "3", ")", ")", "\n", "rk", "=", "np", ".", "random", ".", "permutation", "(", "range", "(", "n_kernels", ")", ")", "\n", "for", "j", "in", "range", "(", "n_nonzero_coefs", ")", ":", "\n", "            ", "k_idx", "=", "rk", "[", "j", "]", "\n", "k_amplitude", "=", "3.0", "*", "np", ".", "random", ".", "rand", "(", ")", "+", "1.0", "\n", "k_offset", "=", "np", ".", "random", ".", "randint", "(", "n_features", "-", "kernel_init_len", "+", "1", ")", "\n", "s", "[", "k_offset", ":", "k_offset", "+", "kernel_init_len", ",", ":", "]", "+=", "k_amplitude", "*", "dico", "[", "k_idx", "]", "\n", "d", "[", "j", ",", ":", "]", "=", "np", ".", "array", "(", "[", "k_amplitude", ",", "k_offset", ",", "k_idx", "]", ")", "\n", "", "decomposition", ".", "append", "(", "d", ")", "\n", "signals", ".", "append", "(", "s", ")", "\n", "", "signals", "=", "np", ".", "array", "(", "signals", ")", "\n", "\n", "return", "dico", ",", "signals", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_mdla_reconstruction": [[330, 341], ["test_mdla._generate_testbed", "numpy.testing.assert_array_almost_equal", "mdla.reconstruct_from_code"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._generate_testbed", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.reconstruct_from_code"], ["", "def", "test_mdla_reconstruction", "(", ")", ":", "\n", "    ", "n_features", "=", "5", "\n", "n_kernels", "=", "8", "\n", "n_nonzero_coefs", "=", "3", "\n", "kernel_init_len", "=", "n_features", "\n", "dico", ",", "signals", ",", "decomposition", "=", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "n_nonzero_coefs", ",", "n_kernels", "\n", ")", "\n", "\n", "assert_array_almost_equal", "(", "\n", "reconstruct_from_code", "(", "decomposition", ",", "dico", ",", "n_features", ")", ",", "signals", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla.test_multivariate_OMP": [[344, 377], ["test_mdla._generate_testbed", "mdla.multivariate_sparse_encode", "numpy.testing.assert_array_almost_equal", "range", "mdla.reconstruct_from_code", "numpy.zeros_like().view", "range", "np.zeros_like().view.sort", "reversed", "numpy.zeros_like().view", "range", "np.zeros_like().view.sort", "reversed", "tuple", "print", "tuple", "print", "numpy.zeros_like", "[].tolist", "numpy.zeros_like", "[].tolist"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._generate_testbed", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.reconstruct_from_code"], ["", "def", "test_multivariate_OMP", "(", ")", ":", "\n", "    ", "n_samples", "=", "10", "\n", "n_features", "=", "100", "\n", "n_dims", "=", "90", "\n", "n_kernels", "=", "8", "\n", "n_nonzero_coefs", "=", "3", "\n", "kernel_init_len", "=", "n_features", "\n", "verbose", "=", "False", "\n", "\n", "dico", ",", "signals", ",", "decomposition", "=", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "n_nonzero_coefs", ",", "n_kernels", ",", "n_samples", ",", "n_features", ",", "n_dims", "\n", ")", "\n", "r", ",", "d", "=", "multivariate_sparse_encode", "(", "signals", ",", "dico", ",", "n_nonzero_coefs", ",", "n_jobs", "=", "1", ")", "\n", "if", "verbose", "is", "True", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "# original signal decomposition, sorted by amplitude", "\n", "            ", "sorted_decomposition", "=", "np", ".", "zeros_like", "(", "decomposition", "[", "i", "]", ")", ".", "view", "(", "\"float, int, int\"", ")", "\n", "for", "j", "in", "range", "(", "decomposition", "[", "i", "]", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "sorted_decomposition", "[", "j", "]", "=", "tuple", "(", "decomposition", "[", "i", "]", "[", "j", ",", ":", "]", ".", "tolist", "(", ")", ")", "\n", "", "sorted_decomposition", ".", "sort", "(", "order", "=", "[", "\"f0\"", "]", ",", "axis", "=", "0", ")", "\n", "for", "j", "in", "reversed", "(", "sorted_decomposition", ")", ":", "\n", "                ", "print", "(", "j", ")", "\n", "\n", "# decomposition found by OMP, also sorted", "\n", "", "sorted_d", "=", "np", ".", "zeros_like", "(", "d", "[", "i", "]", ")", ".", "view", "(", "\"float, int, int\"", ")", "\n", "for", "j", "in", "range", "(", "d", "[", "i", "]", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "sorted_d", "[", "j", "]", "=", "tuple", "(", "d", "[", "i", "]", "[", "j", ",", ":", "]", ".", "tolist", "(", ")", ")", "\n", "", "sorted_d", ".", "sort", "(", "order", "=", "[", "\"f0\"", "]", ",", "axis", "=", "0", ")", "\n", "for", "j", "in", "reversed", "(", "sorted_d", ")", ":", "\n", "                ", "print", "(", "j", ")", "\n", "\n", "", "", "", "assert_array_almost_equal", "(", "\n", "reconstruct_from_code", "(", "d", ",", "dico", ",", "n_features", ")", ",", "signals", ",", "decimal", "=", "3", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._test_with_pydico": [[380, 401], ["test_mdla._generate_testbed", "f.close", "shutil.copy", "print", "print", "mdla.multivariate_sparse_encode", "open", "pickle.dump"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._generate_testbed", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode"], ["", "def", "_test_with_pydico", "(", ")", ":", "\n", "    ", "import", "pickle", "\n", "import", "shutil", "\n", "\n", "n_features", "=", "5", "\n", "n_kernels", "=", "8", "\n", "n_nonzero_coefs", "=", "3", "\n", "kernel_init_len", "=", "n_features", "\n", "dico", ",", "signals", ",", "decomposition", "=", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "n_nonzero_coefs", ",", "n_kernels", "\n", ")", "\n", "o", "=", "{", "\"signals\"", ":", "signals", ",", "\"dico\"", ":", "dico", ",", "\"decomposition\"", ":", "decomposition", "}", "\n", "with", "open", "(", "\"skmdla.pck\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "o", ",", "f", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "shutil", ".", "copy", "(", "\"skmdla.pck\"", ",", "\"../RC/skmdla.pck\"", ")", "\n", "\n", "print", "(", "signals", ")", "\n", "print", "(", "dico", ")", "\n", "\n", "r", ",", "d", "=", "multivariate_sparse_encode", "(", "signals", ",", "dico", ",", "n_nonzero_coefs", ",", "n_jobs", "=", "1", ",", "verbose", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._test_with_pydico_reload": [[403, 415], ["f.close", "mdla.multivariate_sparse_encode", "open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode"], ["", "def", "_test_with_pydico_reload", "(", ")", ":", "\n", "    ", "import", "pickle", "\n", "\n", "n_nonzero_coefs", "=", "3", "\n", "with", "open", "(", "\"skmdla.pck\"", ",", "\"w\"", ")", "as", "f", ":", "\n", "        ", "o", "=", "pickle", ".", "load", "(", "f", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "dico", "=", "o", "[", "\"dico\"", "]", "\n", "signals", "=", "o", "[", "\"signals\"", "]", "\n", "_", "=", "o", "[", "\"decomposition\"", "]", "\n", "\n", "r", ",", "d", "=", "multivariate_sparse_encode", "(", "signals", ",", "dico", ",", "n_nonzero_coefs", ",", "n_jobs", "=", "1", ",", "verbose", "=", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._verif_OMP": [[417, 446], ["range", "test_mdla._generate_testbed", "mdla.multivariate_sparse_encode", "mdla.reconstruct_from_code", "zip", "print"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_mdla._generate_testbed", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.reconstruct_from_code"], ["", "def", "_verif_OMP", "(", ")", ":", "\n", "    ", "n_samples", "=", "1000", "\n", "n_nonzero_coefs", "=", "3", "\n", "\n", "for", "n_features", "in", "range", "(", "5", ",", "50", ",", "5", ")", ":", "\n", "        ", "kernel_init_len", "=", "n_features", "-", "n_features", "/", "2", "\n", "n_dims", "=", "n_features", "/", "2", "\n", "n_kernels", "=", "n_features", "*", "5", "\n", "dico", ",", "signals", ",", "_", "=", "_generate_testbed", "(", "\n", "kernel_init_len", ",", "n_nonzero_coefs", ",", "n_kernels", ",", "n_samples", ",", "n_features", ",", "n_dims", "\n", ")", "\n", "r", ",", "d", "=", "multivariate_sparse_encode", "(", "signals", ",", "dico", ",", "n_nonzero_coefs", ",", "n_jobs", "=", "1", ")", "\n", "reconstructed", "=", "reconstruct_from_code", "(", "d", ",", "dico", ",", "n_features", ")", "\n", "\n", "residual_energy", "=", "0.0", "\n", "for", "sig", ",", "rec", "in", "zip", "(", "signals", ",", "reconstructed", ")", ":", "\n", "            ", "residual_energy", "+=", "(", "(", "sig", "-", "rec", ")", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", ")", "\n", "\n", "", "print", "(", "\n", "\"Mean energy of the\"", ",", "\n", "n_samples", ",", "\n", "\"residuals for\"", ",", "\n", "(", "n_features", ",", "n_dims", ")", ",", "\n", "\"features and\"", ",", "\n", "n_kernels", ",", "\n", "\"kernels of\"", ",", "\n", "(", "kernel_init_len", ",", "n_dims", ")", ",", "\n", "\" is\"", ",", "\n", "residual_energy", "/", "n_samples", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_scale": [[43, 51], ["print", "numpy.testing.assert_almost_equal", "print", "numpy.testing.assert_almost_equal", "m", "m"], "function", ["None"], ["def", "test_scale", "(", ")", ":", "\n", "    ", "for", "m", "in", "[", "hausdorff", ",", "emd", "]", ":", "\n", "        ", "for", "g", "in", "gdm", ":", "\n", "            ", "print", "(", "\"for\"", ",", "g", ",", "\":\"", ")", "\n", "assert_almost_equal", "(", "0.0", ",", "m", "(", "dm", ",", "dm", ",", "g", ",", "scale", "=", "True", ")", ")", "\n", "", "for", "g", "in", "gdu", ":", "\n", "            ", "print", "(", "\"for\"", ",", "g", ",", "\":\"", ")", "\n", "assert_almost_equal", "(", "0.0", ",", "m", "(", "du", ",", "du", ",", "g", ",", "scale", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_kernel_registration": [[53, 94], ["range", "range", "range", "range", "zip", "numpy.random.randn", "len", "numpy.linalg.norm", "len", "dm3.append", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "numpy.random.randn", "len", "numpy.linalg.norm", "len", "du3.append", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "int", "range", "m", "m", "numpy.concatenate", "m", "m", "int", "range", "numpy.concatenate", "m", "m", "m", "m", "numpy.zeros", "numpy.zeros"], "function", ["None"], ["", "", "", "def", "test_kernel_registration", "(", ")", ":", "\n", "    ", "dm2", "=", "[", "randn", "(", "int", "(", "n_features", "+", "i", "/", "2", ")", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dm2", ")", ")", ":", "\n", "        ", "dm2", "[", "i", "]", "/=", "norm", "(", "dm2", "[", "i", "]", ",", "\"fro\"", ")", "\n", "\n", "", "for", "m", "in", "[", "hausdorff", ",", "emd", "]", ":", "\n", "        ", "assert", "0.0", "!=", "m", "(", "dm", ",", "dm2", ",", "\"chordal\"", ")", "\n", "assert", "0.0", "!=", "m", "(", "dm2", ",", "dm", ",", "\"chordal\"", ")", "\n", "\n", "", "dm3", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dm", ")", ")", ":", "\n", "        ", "dm3", ".", "append", "(", "concatenate", "(", "(", "zeros", "(", "(", "4", ",", "3", ")", ")", ",", "dm", "[", "i", "]", ")", ",", "axis", "=", "0", ")", ")", "\n", "\n", "", "for", "m", "in", "[", "hausdorff", ",", "emd", "]", ":", "\n", "        ", "assert_almost_equal", "(", "0.0", ",", "m", "(", "dm", ",", "dm3", ",", "\"chordal\"", ")", ")", "\n", "assert_almost_equal", "(", "0.0", ",", "m", "(", "dm3", ",", "dm", ",", "\"chordal\"", ")", ")", "\n", "\n", "# max(dm3) > max(dm4), min(dm4) > min(dm3)", "\n", "# dm4 = []", "\n", "# for i in range(len(dm)):", "\n", "#     k_l = dm[i].shape[0]", "\n", "#     dm4.append(concatenate((zeros((i/2+1, 3)), dm[i]), axis=0))", "\n", "# dm5 = []", "\n", "# for i in range(len(dm)):", "\n", "#     k_l = dm[i].shape[0]", "\n", "#     dm5.append(concatenate((zeros((3, 3)), dm[i]), axis=0))", "\n", "# for m in [hausdorff, emd]:", "\n", "#     assert_almost_equal(0., m(dm4, dm5, 'chordal'))", "\n", "#     assert_almost_equal(0., m(dm5, dm4, 'chordal'))", "\n", "\n", "", "du2", "=", "[", "randn", "(", "int", "(", "n_features", "+", "i", "/", "2", ")", ",", "1", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "du2", ")", ")", ":", "\n", "        ", "du2", "[", "i", "]", "/=", "norm", "(", "du2", "[", "i", "]", ")", "\n", "", "du3", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "du", ")", ")", ":", "\n", "        ", "du3", ".", "append", "(", "concatenate", "(", "(", "zeros", "(", "(", "4", ",", "1", ")", ")", ",", "du", "[", "i", "]", ")", ",", "axis", "=", "0", ")", ")", "\n", "", "for", "g", ",", "m", "in", "zip", "(", "gdu", ",", "[", "hausdorff", ",", "emd", "]", ")", ":", "\n", "        ", "assert", "0.0", "!=", "m", "(", "du", ",", "du2", ",", "g", ")", "\n", "assert", "0.0", "!=", "m", "(", "du2", ",", "du", ",", "g", ")", "\n", "assert_almost_equal", "(", "0.0", ",", "m", "(", "du", ",", "du3", ",", "g", ")", ")", "\n", "assert_almost_equal", "(", "0.0", ",", "m", "(", "du3", ",", "du", ",", "g", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_unknown_metric": [[96, 99], ["m"], "function", ["None"], ["", "", "def", "test_unknown_metric", "(", ")", ":", "\n", "    ", "for", "m", "in", "[", "hausdorff", ",", "emd", "]", ":", "\n", "        ", "assert", "m", "(", "dm", ",", "dm", ",", "\"inexistant_metric\"", ")", "is", "NaN", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_inhomogeneous_dims": [[101, 112], ["numpy.arange", "range", "numpy.testing.assert_raises", "numpy.testing.assert_raises", "numpy.testing.assert_almost_equal", "numpy.testing.assert_almost_equal", "mdla.dict_metrics.emd", "mdla.dict_metrics.hausdorff"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff"], ["", "", "def", "test_inhomogeneous_dims", "(", ")", ":", "\n", "    ", "idx", "=", "arange", "(", "n_dims", ")", "\n", "for", "g", "in", "[", "\"chordal_principal_angles\"", ",", "\"binetcauchy\"", ",", "\"geodesic\"", "]", ":", "\n", "        ", "for", "i", "in", "range", "(", "n_dims", ",", "0", ",", "-", "1", ")", ":", "\n", "            ", "assert_almost_equal", "(", "0.0", ",", "emd", "(", "dm", ",", "[", "a", "[", ":", ",", "idx", "[", ":", "i", "]", "]", "for", "a", "in", "dm", "]", ",", "g", ",", "scale", "=", "True", ")", ")", "\n", "assert_almost_equal", "(", "\n", "0.0", ",", "hausdorff", "(", "dm", ",", "[", "a", "[", ":", ",", "idx", "[", ":", "i", "]", "]", "for", "a", "in", "dm", "]", ",", "g", ",", "scale", "=", "True", ")", "\n", ")", "\n", "", "", "for", "g", "in", "[", "\"chordal\"", ",", "\"fubinistudy\"", ",", "\"frobenius\"", "]", ":", "\n", "        ", "assert_raises", "(", "ValueError", ",", "emd", ",", "dm", ",", "[", "a", "[", ":", ",", ":", "-", "1", "]", "for", "a", "in", "dm", "]", ",", "g", ")", "\n", "assert_raises", "(", "ValueError", ",", "hausdorff", ",", "dm", ",", "[", "a", "[", ":", ",", ":", "-", "1", "]", "for", "a", "in", "dm", "]", ",", "g", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_univariate": [[114, 118], ["numpy.testing.assert_raises"], "function", ["None"], ["", "", "def", "test_univariate", "(", ")", ":", "\n", "    ", "for", "m", "in", "[", "hausdorff", ",", "emd", "]", ":", "\n", "        ", "for", "g", "in", "gdu", ":", "\n", "            ", "assert_raises", "(", "ValueError", ",", "m", ",", "dm", ",", "dm", ",", "g", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_correlation": [[120, 141], ["range", "range", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.testing.assert_equal", "numpy.allclose", "numpy.random.randn", "len", "numpy.linalg.norm", "numpy.random.randn", "len", "numpy.linalg.norm", "mdla.dict_metrics.detection_rate", "mdla.dict_metrics.detection_rate", "mdla.dict_metrics.detection_rate", "mdla.dict_metrics.detection_rate", "mdla.dict_metrics.precision_recall", "mdla.dict_metrics.precision_recall", "mdla.dict_metrics.precision_recall_points", "numpy.allclose", "range", "range", "numpy.ones", "numpy.ones", "mdla.dict_metrics.precision_recall_points", "len", "len", "numpy.ones", "numpy.ones", "len", "len"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.precision_recall", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.precision_recall", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.precision_recall_points", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.precision_recall_points"], ["", "", "", "def", "test_correlation", "(", ")", ":", "\n", "    ", "du2", "=", "[", "\n", "randn", "(", "\n", "n_features", ",", "\n", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", "\n", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "du2", ")", ")", ":", "\n", "        ", "du2", "[", "i", "]", "/=", "norm", "(", "du2", "[", "i", "]", ")", "\n", "", "dm2", "=", "[", "randn", "(", "n_features", ",", "n_dims", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "dm2", ")", ")", ":", "\n", "        ", "dm2", "[", "i", "]", "/=", "norm", "(", "dm2", "[", "i", "]", ")", "\n", "\n", "", "assert_equal", "(", "100.0", ",", "detection_rate", "(", "du", ",", "du", ",", "0.97", ")", ")", "\n", "assert", "100.0", "!=", "detection_rate", "(", "du", ",", "du2", ",", "0.99", ")", "\n", "assert_equal", "(", "100.0", ",", "detection_rate", "(", "dm", ",", "dm", ",", "0.97", ")", ")", "\n", "assert", "100.0", "!=", "detection_rate", "(", "dm", ",", "dm2", ",", "0.99", ")", "\n", "assert_equal", "(", "(", "100.0", ",", "100.0", ")", ",", "precision_recall", "(", "du", ",", "du", ",", "0.97", ")", ")", "\n", "assert_equal", "(", "(", "0.0", ",", "0.0", ")", ",", "precision_recall", "(", "du", ",", "du2", ",", "0.99", ")", ")", "\n", "assert", "allclose", "(", "precision_recall_points", "(", "du", ",", "du", ")", ",", "(", "ones", "(", "len", "(", "du", ")", ")", ",", "ones", "(", "len", "(", "du", ")", ")", ")", ")", "\n", "assert", "not", "allclose", "(", "precision_recall_points", "(", "du", ",", "du2", ")", ",", "(", "ones", "(", "len", "(", "du", ")", ")", ",", "ones", "(", "len", "(", "du2", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_beta_dist": [[143, 155], ["range", "numpy.testing.assert_equal", "range", "numpy.testing.assert_raises", "numpy.random.randn", "len", "numpy.linalg.norm", "mdla.dict_metrics.beta_dist", "mdla.dict_metrics.beta_dist", "numpy.random.randn", "len", "numpy.linalg.norm", "range", "range"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.beta_dist", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.beta_dist"], ["", "def", "test_beta_dist", "(", ")", ":", "\n", "    ", "du2", "=", "[", "randn", "(", "n_features", ",", "1", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "du2", ")", ")", ":", "\n", "        ", "du2", "[", "i", "]", "/=", "norm", "(", "du2", "[", "i", "]", ")", "\n", "\n", "", "assert_equal", "(", "0.0", ",", "beta_dist", "(", "du", ",", "du", ")", ")", "\n", "assert", "0.0", "!=", "beta_dist", "(", "du", ",", "du2", ")", "\n", "\n", "du2", "=", "[", "randn", "(", "n_features", "+", "2", ",", "1", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "du2", ")", ")", ":", "\n", "        ", "du2", "[", "i", "]", "/=", "norm", "(", "du2", "[", "i", "]", ")", "\n", "", "assert_raises", "(", "ValueError", ",", "beta_dist", ",", "du", ",", "du2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.tests.test_dict_metrics.test_beta_dict_length": [[157, 163], ["range", "numpy.random.randn", "len", "numpy.linalg.norm", "mdla.dict_metrics.beta_dist", "range"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.beta_dist"], ["", "def", "test_beta_dict_length", "(", ")", ":", "\n", "    ", "du2", "=", "[", "randn", "(", "n_features", ",", "1", ")", "for", "i", "in", "range", "(", "n_kernels", "+", "2", ")", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "du2", ")", ")", ":", "\n", "        ", "du2", "[", "i", "]", "/=", "norm", "(", "du2", "[", "i", "]", ")", "\n", "\n", "", "assert", "0.0", "!=", "beta_dist", "(", "du", ",", "du2", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin._set_mdla_params": [[1132, 1150], ["None"], "methods", ["None"], ["def", "_set_mdla_params", "(", "\n", "self", ",", "\n", "n_kernels", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "kernel_init_len", "=", "None", ",", "\n", "n_jobs", "=", "1", ",", "\n", "learning_rate", "=", "None", ",", "\n", ")", ":", "\n", "# TODO: add kernel_init_len=None, kernel_max_len=None,", "\n", "# kernel_adapt_thres=None, kernel_adapt_inc=None", "\n", "        ", "self", ".", "n_kernels", "=", "n_kernels", "\n", "self", ".", "n_nonzero_coefs", "=", "n_nonzero_coefs", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "self", ".", "kernel_init_len", "=", "kernel_init_len", "\n", "if", "learning_rate", "is", "not", "None", ":", "\n", "            ", "self", ".", "learning_rate", "=", "learning_rate", "\n", "", "else", ":", "\n", "            ", "self", ".", "learning_rate", "=", "1.5", "\n", "# split_sign=False ?", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin.transform": [[1155, 1183], ["mdla.array3d", "mdla.multivariate_sparse_encode"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.array3d", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode"], ["", "", "def", "transform", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"Encode the data as a sparse combination of the dictionary atoms.\n\n        The coding method is the multivariate OMP, whose parameters are\n        n_kernels: the number of dictionary kernels\n        n_nonzero_coefs: sparsity term\n        n_jobs: for parallel jobs\n\n        Parameters\n        ----------\n        X : array of shape (n_samples, n_features, n_dims)\n            Test data to be transformed, must have the same number of\n            features as the data used to train the model.\n\n        Returns\n        -------\n        X_new : array, shape (n_samples, n_kernels, n_dims)\n            Transformed data\n\n        \"\"\"", "\n", "X", "=", "array3d", "(", "X", ")", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "\n", "_", ",", "code", "=", "multivariate_sparse_encode", "(", "\n", "X", ",", "self", ".", "kernels_", ",", "n_nonzero_coefs", "=", "self", ".", "n_nonzero_coefs", ",", "n_jobs", "=", "self", ".", "n_jobs", "\n", ")", "\n", "\n", "return", "code", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.SparseMultivariateCoder.__init__": [[1225, 1237], ["mdla.SparseMultivariateCoder._set_mdla_params", "list", "len"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin._set_mdla_params"], ["def", "__init__", "(", "\n", "self", ",", "\n", "dictionary", ",", "\n", "n_nonzero_coefs", "=", "None", ",", "\n", "kernel_init_len", "=", "None", ",", "\n", "n_jobs", "=", "1", ",", "\n", "learning_rate", "=", "None", ",", "\n", ")", ":", "\n", "        ", "self", ".", "_set_mdla_params", "(", "\n", "len", "(", "dictionary", ")", ",", "n_nonzero_coefs", ",", "kernel_init_len", ",", "n_jobs", ",", "learning_rate", "\n", ")", "\n", "self", ".", "kernels_", "=", "list", "(", "dictionary", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.SparseMultivariateCoder.fit": [[1238, 1245], ["None"], "methods", ["None"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"Do nothing and return the estimator unchanged\n\n        This method is just there to implement the usual API and hence\n        work in pipelines.\n        \"\"\"", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictLearning.__init__": [[1324, 1351], ["mdla.MultivariateDictLearning._set_mdla_params", "mdla._normalize", "list"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin._set_mdla_params", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_kernels", "=", "None", ",", "\n", "max_iter", "=", "1000", ",", "\n", "tol", "=", "1e-8", ",", "\n", "n_nonzero_coefs", "=", "None", ",", "\n", "n_jobs", "=", "1", ",", "\n", "kernel_init_len", "=", "None", ",", "\n", "dict_init", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "learning_rate", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "callback", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "_set_mdla_params", "(", "\n", "n_kernels", ",", "n_nonzero_coefs", ",", "kernel_init_len", ",", "n_jobs", ",", "learning_rate", "\n", ")", "\n", "self", ".", "max_iter", "=", "max_iter", "\n", "self", ".", "tol", "=", "tol", "\n", "if", "dict_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "dict_init", "=", "_normalize", "(", "list", "(", "dict_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "dict_init", "=", "None", "\n", "", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "callback", "=", "callback", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictLearning.fit": [[1352, 1413], ["sklearn.utils.check_random_state", "mdla.array3d", "hasattr", "mdla.multivariate_dict_learning", "list", "mdla._normalize", "len", "ValueError", "print", "list", "print"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.array3d", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_dict_learning", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"Fit the model from data in X.\n\n        Parameters\n        ----------\n        X: array-like, shape (n_samples, n_features, n_dims)\n            Training matrices, where n_samples in the number of samples.\n            Each sample is a matrix of shape (n_features, n_dims) with\n            n_features >= n_dims.\n\n        Returns\n        -------\n        self: object\n            Returns the object itself\n        \"\"\"", "\n", "random_state", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "X", "=", "array3d", "(", "X", ")", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "if", "hasattr", "(", "self", ",", "\"kernels_\"", ")", ":", "\n", "            ", "self", ".", "dict_init", "=", "_normalize", "(", "list", "(", "self", ".", "kernels_", ")", ")", "\n", "if", "self", ".", "verbose", ">=", "1", ":", "\n", "                ", "print", "(", "\"\\nWarm restart with existing kernels\"", ")", "\n", "# print (self.kernels_[7])", "\n", "# print ('')", "\n", "", "", "if", "self", ".", "dict_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "n_kernels", "=", "len", "(", "self", ".", "dict_init", ")", "\n", "", "elif", "self", ".", "n_kernels", "is", "None", ":", "\n", "            ", "self", ".", "n_kernels", "=", "2", "*", "n_features", "\n", "", "if", "self", ".", "kernel_init_len", "is", "None", ":", "\n", "            ", "self", ".", "kernel_init_len", "=", "n_features", "\n", "\n", "", "if", "n_dims", ">", "self", ".", "kernel_init_len", ":", "\n", "            ", "raise", "ValueError", "(", "\"X should have more n_dims than n_features\"", ")", "\n", "", "if", "self", ".", "n_kernels", "<", "self", ".", "kernel_init_len", ":", "\n", "            ", "print", "(", "\"Warning: X has more features than dictionary kernels\"", ")", "\n", "# raise ValueError('X has more features than dictionary kernels')", "\n", "\n", "", "code", ",", "dictionary", ",", "err", "=", "multivariate_dict_learning", "(", "\n", "X", ",", "\n", "self", ".", "n_kernels", ",", "\n", "n_nonzero_coefs", "=", "self", ".", "n_nonzero_coefs", ",", "\n", "tol", "=", "self", ".", "tol", ",", "\n", "learning_rate", "=", "self", ".", "learning_rate", ",", "\n", "n_jobs", "=", "self", ".", "n_jobs", ",", "\n", "dict_init", "=", "self", ".", "dict_init", ",", "\n", "verbose", "=", "self", ".", "verbose", ",", "\n", "kernel_init_len", "=", "self", ".", "kernel_init_len", ",", "\n", "random_state", "=", "random_state", ",", "\n", "max_iter", "=", "self", ".", "max_iter", ",", "\n", "callback", "=", "self", ".", "callback", ",", "\n", "dict_obj", "=", "self", ",", "\n", ")", "\n", "self", ".", "kernels_", "=", "list", "(", "dictionary", ")", "\n", "self", ".", "error_", "=", "err", "\n", "\n", "# if self.verbose >= 1:", "\n", "#     print ('\\nEnd of fit')", "\n", "#     print (self.kernels_[7])", "\n", "#     print ()", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.__init__": [[1492, 1521], ["mdla.MiniBatchMultivariateDictLearning._set_mdla_params", "mdla._normalize", "list"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MultivariateDictMixin._set_mdla_params", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize"], ["def", "__init__", "(", "\n", "self", ",", "\n", "n_kernels", "=", "None", ",", "\n", "n_iter", "=", "10", ",", "\n", "n_jobs", "=", "1", ",", "\n", "batch_size", "=", "None", ",", "\n", "shuffle", "=", "True", ",", "\n", "dict_init", "=", "None", ",", "\n", "n_nonzero_coefs", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "kernel_init_len", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "learning_rate", "=", "None", ",", "\n", "callback", "=", "None", ",", "\n", ")", ":", "\n", "\n", "        ", "self", ".", "_set_mdla_params", "(", "\n", "n_kernels", ",", "n_nonzero_coefs", ",", "kernel_init_len", ",", "n_jobs", ",", "learning_rate", "\n", ")", "\n", "self", ".", "n_iter", "=", "n_iter", "\n", "if", "dict_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "dict_init", "=", "_normalize", "(", "list", "(", "dict_init", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "dict_init", "=", "None", "\n", "", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "shuffle", "=", "shuffle", "\n", "self", ".", "batch_size", "=", "batch_size", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "callback", "=", "callback", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.fit": [[1522, 1582], ["sklearn.utils.check_random_state", "mdla.array3d", "hasattr", "mdla.multivariate_dict_learning_online", "list", "mdla._normalize", "len", "ValueError", "print", "list", "print"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.array3d", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_dict_learning_online", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ")", ":", "\n", "        ", "\"\"\"Fit the model from data in X.\n\n        Parameters\n        ----------\n        X: array-like, shape (n_samples, n_features, n_dims)\n            Training matrices, where n_samples in the number of samples\n            Each sample is a matrix of shape (n_features, n_dims) with\n            n_features >= n_dims.\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"", "\n", "random_state", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "X", "=", "array3d", "(", "X", ")", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "if", "hasattr", "(", "self", ",", "\"kernels_\"", ")", ":", "\n", "            ", "self", ".", "dict_init", "=", "_normalize", "(", "list", "(", "self", ".", "kernels_", ")", ")", "\n", "if", "self", ".", "verbose", ":", "\n", "                ", "print", "(", "\"\\nWarm restart with existing kernels_\"", ")", "\n", "# print (self.kernels_[7])", "\n", "# print ('')", "\n", "", "", "if", "self", ".", "dict_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "n_kernels", "=", "len", "(", "self", ".", "dict_init", ")", "\n", "", "elif", "self", ".", "n_kernels", "is", "None", ":", "\n", "            ", "self", ".", "n_kernels", "=", "2", "*", "n_features", "\n", "", "if", "self", ".", "kernel_init_len", "is", "None", ":", "\n", "            ", "self", ".", "kernel_init_len", "=", "n_features", "\n", "\n", "", "if", "n_dims", ">", "self", ".", "kernel_init_len", ":", "\n", "            ", "raise", "ValueError", "(", "\"X should have more n_dims than n_features\"", ")", "\n", "", "if", "self", ".", "n_kernels", "<", "self", ".", "kernel_init_len", ":", "\n", "            ", "print", "(", "\"Warning: X has more features than dictionary kernels\"", ")", "\n", "# raise ValueError('X has more features than dictionary kernels')", "\n", "# if n_samples < self.n_kernels:", "\n", "#     raise ValueError('There is more kernel (%d) than samples (%d)' % (self.n_kernels, n_samples))", "\n", "\n", "", "dictionary", ",", "e", "=", "multivariate_dict_learning_online", "(", "\n", "X", ",", "\n", "self", ".", "n_kernels", ",", "\n", "n_nonzero_coefs", "=", "self", ".", "n_nonzero_coefs", ",", "\n", "n_iter", "=", "self", ".", "n_iter", ",", "\n", "n_jobs", "=", "self", ".", "n_jobs", ",", "\n", "dict_init", "=", "self", ".", "dict_init", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "self", ".", "shuffle", ",", "\n", "verbose", "=", "self", ".", "verbose", ",", "\n", "kernel_init_len", "=", "self", ".", "kernel_init_len", ",", "\n", "random_state", "=", "random_state", ",", "\n", "learning_rate", "=", "self", ".", "learning_rate", ",", "\n", "callback", "=", "self", ".", "callback", ",", "\n", "dict_obj", "=", "self", ",", "\n", ")", "\n", "self", ".", "kernels_", "=", "list", "(", "dictionary", ")", "\n", "self", ".", "iter_offset_", "=", "self", ".", "n_iter", "\n", "self", ".", "error_", "=", "e", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.MiniBatchMultivariateDictLearning.partial_fit": [[1583, 1650], ["mdla.array3d", "hasattr", "mdla.multivariate_dict_learning_online", "list", "hasattr", "sklearn.utils.check_random_state", "mdla._normalize", "len", "ValueError", "print", "getattr", "list"], "methods", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.array3d", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_dict_learning_online", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize"], ["", "def", "partial_fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "iter_offset", "=", "None", ")", ":", "\n", "        ", "\"\"\"Updates the model using the data in X as a mini-batch.\n\n        Parameters\n        ----------\n        X: array-like, shape (n_samples, n_features, n_dims)\n            Training matrices, where n_samples in the number of samples\n            Each sample is a matrix of shape (n_features, n_dims) with\n            n_features >= n_dims.\n\n        iter_offset: integer, optional\n            The number of iteration on data batches that has been\n            performed before this call to partial_fit. This is optional:\n            if no number is passed, the memory of the object is\n            used.\n\n        Returns\n        -------\n        self : object\n            Returns the instance itself.\n        \"\"\"", "\n", "if", "not", "hasattr", "(", "self", ",", "\"random_state_\"", ")", ":", "\n", "            ", "self", ".", "random_state_", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "", "X", "=", "array3d", "(", "X", ")", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "if", "hasattr", "(", "self", ",", "\"kernels_\"", ")", ":", "\n", "            ", "self", ".", "dict_init", "=", "_normalize", "(", "list", "(", "self", ".", "kernels_", ")", ")", "\n", "", "if", "self", ".", "dict_init", "is", "not", "None", ":", "\n", "            ", "self", ".", "n_kernels", "=", "len", "(", "self", ".", "dict_init", ")", "\n", "", "elif", "self", ".", "n_kernels", "is", "None", ":", "\n", "            ", "self", ".", "n_kernels", "=", "2", "*", "n_features", "\n", "", "if", "self", ".", "kernel_init_len", "is", "None", ":", "\n", "            ", "self", ".", "kernel_init_len", "=", "n_features", "\n", "\n", "", "if", "n_dims", ">", "self", ".", "kernel_init_len", ":", "\n", "            ", "raise", "ValueError", "(", "\"X should have more n_dims than n_features\"", ")", "\n", "", "if", "self", ".", "n_kernels", "<", "self", ".", "kernel_init_len", ":", "\n", "            ", "print", "(", "\"Warning: X has more features than dictionary kernels\"", ")", "\n", "# raise ValueError('X has more features than dictionary kernels')", "\n", "# if n_samples < self.n_kernels:", "\n", "#     raise ValueError('There is more kernel than samples')", "\n", "\n", "", "if", "iter_offset", "is", "None", ":", "\n", "            ", "iter_offset", "=", "getattr", "(", "self", ",", "\"iter_offset_\"", ",", "0", ")", "\n", "\n", "", "dictionary", ",", "e", "=", "multivariate_dict_learning_online", "(", "\n", "X", ",", "\n", "self", ".", "n_kernels", ",", "\n", "n_nonzero_coefs", "=", "self", ".", "n_nonzero_coefs", ",", "\n", "n_iter", "=", "self", ".", "n_iter", ",", "\n", "n_jobs", "=", "self", ".", "n_jobs", ",", "\n", "dict_init", "=", "self", ".", "dict_init", ",", "\n", "batch_size", "=", "self", ".", "batch_size", ",", "\n", "shuffle", "=", "self", ".", "shuffle", ",", "\n", "verbose", "=", "self", ".", "verbose", ",", "\n", "iter_offset", "=", "iter_offset", ",", "\n", "kernel_init_len", "=", "self", ".", "kernel_init_len", ",", "\n", "learning_rate", "=", "self", ".", "learning_rate", ",", "\n", "random_state", "=", "self", ".", "random_state_", ",", "\n", "callback", "=", "self", ".", "callback", ",", "\n", "dict_obj", "=", "self", ",", "\n", ")", "\n", "self", ".", "kernels_", "=", "list", "(", "dictionary", ")", "\n", "self", ".", "iter_offset_", "=", "iter_offset", "+", "self", ".", "n_iter", "\n", "self", ".", "error_", "=", "e", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.find": [[26, 29], ["numpy.nonzero", "numpy.ravel"], "function", ["None"], ["def", "find", "(", "condition", ")", ":", "\n", "    ", "(", "res", ",", ")", "=", "np", ".", "nonzero", "(", "np", ".", "ravel", "(", "condition", ")", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._shift_and_extend": [[31, 38], ["numpy.zeros"], "function", ["None"], ["", "def", "_shift_and_extend", "(", "signal", ",", "extended_length", ",", "shift_offset", ")", ":", "\n", "    ", "\"\"\"_shift_and_extend put a copy of signal in a new container of size\n    extended_length and at position shift_offset.\n    \"\"\"", "\n", "extended_signal", "=", "np", ".", "zeros", "(", "shape", "=", "(", "extended_length", ",", "signal", ".", "shape", "[", "1", "]", ")", ")", "\n", "extended_signal", "[", "shift_offset", ":", "shift_offset", "+", "signal", ".", "shape", "[", "0", "]", ",", ":", "]", "=", "signal", "\n", "return", "extended_signal", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize": [[40, 45], ["range", "len", "numpy.linalg.norm"], "function", ["None"], ["", "def", "_normalize", "(", "dictionary", ")", ":", "\n", "    ", "\"\"\"Normalize all dictionary elements to have a unit norm\"\"\"", "\n", "for", "i", "in", "range", "(", "len", "(", "dictionary", ")", ")", ":", "\n", "        ", "dictionary", "[", "i", "]", "/=", "np", ".", "linalg", ".", "norm", "(", "dictionary", "[", "i", "]", ",", "\"fro\"", ")", "\n", "", "return", "dictionary", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._get_learning_rate": [[47, 57], ["numpy.floor"], "function", ["None"], ["", "def", "_get_learning_rate", "(", "iteration", ",", "max_iteration", ",", "learning_rate", ")", ":", "\n", "# TODO: change to have last_iterations=max_iterations", "\n", "# TODO: verify that max_iter=1 is not a problem for partial_fit", "\n", "    ", "if", "learning_rate", "==", "0.0", ":", "\n", "        ", "return", "0.0", "\n", "", "last_iterations", "=", "np", ".", "floor", "(", "max_iteration", "*", "2.0", "/", "3.0", ")", "\n", "if", "iteration", ">=", "last_iterations", ":", "\n", "        ", "return", "last_iterations", "**", "learning_rate", "\n", "", "else", ":", "\n", "        ", "return", "(", "iteration", "+", "1", ")", "**", "learning_rate", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._multivariate_OMP": [[59, 262], ["len", "numpy.max", "numpy.min", "signal.copy", "numpy.zeros", "numpy.zeros", "range", "numpy.unravel_index", "mdla._shift_and_extend", "_shift_and_extend.flatten", "numpy.array", "numpy.zeros", "print", "print", "range", "print", "numpy.argmax", "print", "print", "print", "print", "print", "numpy.zeros", "range", "numpy.unravel_index", "numpy.any", "mdla._shift_and_extend", "numpy.array", "numpy.array", "np.array.dot", "numpy.allclose", "numpy.array", "numpy.vstack", "numpy.zeros", "range", "print", "print", "numpy.correlate", "numpy.abs", "range", "print", "numpy.argmax", "print", "np.vstack.dot", "Ainv[].dot", "np.array.dot", "int", "int", "print", "print", "numpy.correlate", "numpy.abs", "print", "_shift_and_extend.flatten", "_shift_and_extend.flatten", "len", "max", "min", "len"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._shift_and_extend", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._shift_and_extend"], ["", "", "def", "_multivariate_OMP", "(", "signal", ",", "dictionary", ",", "n_nonzero_coefs", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Sparse coding multivariate signal with OMP\n\n    Returns residual and a decomposition array (n_nonzero_coefs, 3),\n    each line indicating (amplitude, offset, kernel).\n\n    Parameters\n    ----------\n    signal: array of shape (n_features, n_dims)\n        Data matrix.\n        Each sample is a matrix of shape (n_features, n_dims) with\n        n_features >= n_dims.\n\n    dictionary: list of arrays\n        The dictionary against which to solve the sparse coding of\n        the data. The dictionary learned is a list of n_kernels\n        elements. Each element is a convolution kernel, i.e. an\n        array of shape (k, n_dims), where k <= n_features and is\n        kernel specific. The algorithm normalizes the kernels.\n\n    n_nonzero_coefs : int\n        Sparsity controller parameter for multivariate variant\n        of OMP\n\n    verbose:\n        Degree of output the procedure will print.\n\n    Returns\n    -------\n    residual: array of (n_features, n_dims)\n        Reconstruction error residual.\n\n    decomposition: array of shape (n_nonzero_coefs, 3)\n        The sparse code decomposition : (amplitude, offset, kernel)\n        for each n_nonzero_coefs.\n\n    See also\n    --------\n    SparseCoder\n    \"\"\"", "\n", "n_features", ",", "n_dims", "=", "signal", ".", "shape", "\n", "n_kernels", "=", "len", "(", "dictionary", ")", "\n", "k_max_len", "=", "np", ".", "max", "(", "[", "k", ".", "shape", "[", "0", "]", "for", "k", "in", "dictionary", "]", ")", "\n", "k_min_len", "=", "np", ".", "min", "(", "[", "k", ".", "shape", "[", "0", "]", "for", "k", "in", "dictionary", "]", ")", "\n", "\n", "residual", "=", "signal", ".", "copy", "(", ")", "\n", "# signal decomposition is [amplitude, offset, kernel]*n_nonzero_coefs", "\n", "decomposition", "=", "np", ".", "zeros", "(", "(", "n_nonzero_coefs", ",", "3", ")", ")", "-", "1", "\n", "if", "verbose", ">=", "4", ":", "\n", "        ", "print", "(", "\"[M-OMP # 0 ] signal is\"", ")", "\n", "print", "(", "residual", ")", "\n", "", "Ainv", "=", "np", ".", "zeros", "(", "(", "n_kernels", ",", "n_kernels", ")", ",", "np", ".", "float", ")", "\n", "Ainv", "[", "0", ",", "0", "]", "=", "1.0", "\n", "\n", "# First iteration", "\n", "correlation_score", "=", "np", ".", "zeros", "(", "(", "n_kernels", ",", "n_features", ")", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "corr", "=", "0", "\n", "for", "j", "in", "range", "(", "n_dims", ")", ":", "\n", "            ", "corr", "+=", "np", ".", "correlate", "(", "residual", "[", ":", ",", "j", "]", ",", "dictionary", "[", "i", "]", "[", ":", ",", "j", "]", ",", "\"valid\"", ")", "\n", "", "correlation_score", "[", "i", ",", ":", "len", "(", "corr", ")", "]", "=", "corr", "\n", "\n", "", "if", "verbose", ">=", "4", ":", "\n", "        ", "print", "(", "\"[M-OMP # 0 ] correlation is\"", ",", "correlation_score", ")", "\n", "\n", "", "(", "k_selected", ",", "k_off", ")", "=", "np", ".", "unravel_index", "(", "\n", "np", ".", "argmax", "(", "np", ".", "abs", "(", "correlation_score", ")", ")", ",", "correlation_score", ".", "shape", "\n", ")", "\n", "k_amplitude", "=", "correlation_score", "[", "k_selected", ",", "k_off", "]", "\n", "\n", "# Put the selected kernel into an atom", "\n", "selected_atom", "=", "_shift_and_extend", "(", "dictionary", "[", "k_selected", "]", ",", "n_features", ",", "k_off", ")", "\n", "\n", "if", "verbose", ">=", "3", ":", "\n", "        ", "print", "(", "\n", "\"[M-OMP # 0 ] kernel\"", ",", "k_selected", ",", "\"is selected with amplitude\"", ",", "k_amplitude", "\n", ")", "\n", "", "if", "verbose", ">=", "4", ":", "\n", "        ", "print", "(", "selected_atom", ")", "\n", "\n", "# List of selected atoms is flatten", "\n", "", "selected_list", "=", "selected_atom", ".", "flatten", "(", ")", "\n", "estimated_signal", "=", "k_amplitude", "*", "selected_atom", "\n", "residual", "=", "signal", "-", "estimated_signal", "\n", "\n", "if", "verbose", ">=", "4", ":", "\n", "        ", "print", "(", "\"[M-OMP # 0 ] residual is now\"", ")", "\n", "print", "(", "residual", ")", "\n", "\n", "", "signal_energy", "=", "(", "signal", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", ")", "\n", "residual_energy", "=", "(", "residual", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", ")", "\n", "\n", "if", "verbose", ">=", "3", ":", "\n", "        ", "print", "(", "\n", "\"[M-OMP # 0 ] signal energy is\"", ",", "\n", "signal_energy", ",", "\n", "\"and residual energy is\"", ",", "\n", "residual_energy", ",", "\n", ")", "\n", "\n", "", "decomposition", "[", "0", ",", ":", "]", "=", "np", ".", "array", "(", "[", "k_amplitude", ",", "k_off", ",", "k_selected", "]", ")", "\n", "\n", "# Main loop", "\n", "atoms_in_estimate", "=", "1", "\n", "while", "atoms_in_estimate", "<", "n_nonzero_coefs", ":", "\n", "        ", "correlation_score", "=", "np", ".", "zeros", "(", "\n", "(", "n_kernels", ",", "max", "(", "n_features", ",", "k_max_len", ")", "-", "min", "(", "n_features", ",", "k_min_len", ")", "+", "1", ")", "\n", ")", "\n", "# TODO: compute correlation only if kernel has not been selected", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "            ", "corr", "=", "0", "\n", "for", "j", "in", "range", "(", "n_dims", ")", ":", "\n", "                ", "corr", "+=", "np", ".", "correlate", "(", "residual", "[", ":", ",", "j", "]", ",", "dictionary", "[", "i", "]", "[", ":", ",", "j", "]", ",", "\"valid\"", ")", "\n", "", "correlation_score", "[", "i", ",", ":", "len", "(", "corr", ")", "]", "=", "corr", "\n", "", "if", "verbose", ">=", "4", ":", "\n", "            ", "print", "(", "\"[M-OMP #\"", ",", "atoms_in_estimate", ",", "\"] correlation is\"", ",", "correlation_score", ")", "\n", "", "(", "k_selected", ",", "k_off", ")", "=", "np", ".", "unravel_index", "(", "\n", "np", ".", "argmax", "(", "np", ".", "abs", "(", "correlation_score", ")", ")", ",", "correlation_score", ".", "shape", "\n", ")", "\n", "k_amplitude", "=", "correlation_score", "[", "k_selected", ",", "k_off", "]", "\n", "\n", "# Verify that the atom is not already selected", "\n", "if", "np", ".", "any", "(", "(", "k_off", "==", "decomposition", "[", ":", ",", "1", "]", ")", "&", "(", "k_selected", "==", "decomposition", "[", ":", ",", "2", "]", ")", ")", ":", "\n", "            ", "if", "verbose", ">=", "4", ":", "\n", "                ", "print", "(", "\n", "\"kernel\"", ",", "\n", "k_selected", ",", "\n", "\"already selected from\"", ",", "\n", "\"a previous iteration. Exiting loop.\"", ",", "\n", ")", "\n", "", "break", "\n", "", "selected_atom", "=", "_shift_and_extend", "(", "dictionary", "[", "k_selected", "]", ",", "n_features", ",", "k_off", ")", "\n", "if", "verbose", ">=", "3", ":", "\n", "            ", "print", "(", "\n", "\"[M-OMP #\"", ",", "\n", "atoms_in_estimate", ",", "\n", "\"] kernel\"", ",", "\n", "k_selected", ",", "\n", "\"at position\"", ",", "\n", "k_off", ",", "\n", ")", "\n", "\n", "# Update decomposition coefficients", "\n", "", "v", "=", "np", ".", "array", "(", "selected_list", ".", "dot", "(", "selected_atom", ".", "flatten", "(", ")", ")", ",", "ndmin", "=", "2", ")", "\n", "b", "=", "np", ".", "array", "(", "Ainv", "[", "0", ":", "atoms_in_estimate", ",", "0", ":", "atoms_in_estimate", "]", ".", "dot", "(", "v", ".", "T", ")", ",", "ndmin", "=", "2", ")", "\n", "vb", "=", "v", ".", "dot", "(", "b", ")", "\n", "if", "np", ".", "allclose", "(", "vb", ",", "1.0", ")", ":", "\n", "            ", "beta", "=", "0.0", "\n", "", "else", ":", "\n", "            ", "beta", "=", "1.0", "/", "(", "1.0", "-", "vb", ")", "\n", "", "alpha", "=", "correlation_score", "[", "k_selected", ",", "k_off", "]", "*", "beta", "\n", "decomposition", "[", "0", ":", "atoms_in_estimate", ",", "0", ":", "1", "]", "-=", "alpha", "*", "b", "\n", "Ainv", "[", "0", ":", "atoms_in_estimate", ",", "0", ":", "atoms_in_estimate", "]", "+=", "beta", "*", "b", ".", "dot", "(", "b", ".", "T", ")", "\n", "Ainv", "[", "atoms_in_estimate", ":", "atoms_in_estimate", "+", "1", ",", "0", ":", "atoms_in_estimate", "]", "=", "-", "beta", "*", "b", ".", "T", "\n", "Ainv", "[", "0", ":", "atoms_in_estimate", ",", "atoms_in_estimate", ":", "atoms_in_estimate", "+", "1", "]", "=", "-", "beta", "*", "b", "\n", "Ainv", "[", "atoms_in_estimate", ",", "atoms_in_estimate", "]", "=", "beta", "\n", "decomposition", "[", "atoms_in_estimate", "]", "=", "np", ".", "array", "(", "\n", "[", "alpha", ",", "k_off", ",", "k_selected", "]", ",", "dtype", "=", "np", ".", "float64", "\n", ")", "\n", "atoms_in_estimate", "+=", "1", "\n", "selected_list", "=", "np", ".", "vstack", "(", "(", "selected_list", ",", "selected_atom", ".", "flatten", "(", ")", ")", ")", "\n", "\n", "# Update the estimated signal and residual", "\n", "estimated_signal", "=", "np", ".", "zeros", "(", "(", "n_features", ",", "n_dims", ")", ")", "\n", "for", "i", "in", "range", "(", "atoms_in_estimate", ")", ":", "\n", "            ", "k_amp", "=", "decomposition", "[", "i", ",", "0", "]", "\n", "k_off", "=", "int", "(", "decomposition", "[", "i", ",", "1", "]", ")", "\n", "k_kernel", "=", "int", "(", "decomposition", "[", "i", ",", "2", "]", ")", "\n", "k_len", "=", "dictionary", "[", "k_kernel", "]", ".", "shape", "[", "0", "]", "\n", "\n", "estimated_signal", "[", "k_off", ":", "k_off", "+", "k_len", ",", ":", "]", "+=", "k_amp", "*", "dictionary", "[", "k_kernel", "]", "\n", "", "residual", "=", "signal", "-", "estimated_signal", "\n", "\n", "if", "verbose", ">=", "3", ":", "\n", "            ", "residual_energy", "=", "(", "residual", "**", "2", ")", ".", "sum", "(", "1", ")", ".", "mean", "(", ")", "\n", "print", "(", "\n", "\"[M-OMP #\"", ",", "\n", "atoms_in_estimate", "-", "1", ",", "\n", "\"] signal energy is\"", ",", "\n", "signal_energy", ",", "\n", "\"and residual energy is\"", ",", "\n", "residual_energy", ",", "\n", ")", "\n", "", "if", "verbose", ">=", "4", ":", "\n", "            ", "print", "(", "\n", "\"[M-OMP #\"", ",", "\n", "atoms_in_estimate", "-", "1", ",", "\n", "\"]: partial decomposition\"", ",", "\n", "\"is\"", ",", "\n", "decomposition", "[", ":", "atoms_in_estimate", ",", ":", "]", ",", "\n", ")", "\n", "\n", "# End big loop", "\n", "", "", "decomposition", "=", "decomposition", "[", "0", ":", "atoms_in_estimate", ",", ":", "]", "\n", "if", "verbose", ">=", "4", ":", "\n", "        ", "print", "(", "\n", "\"[M-OMP # end ]: decomposition matrix is: \"", ",", "\n", "\"(amplitude, offset, kernel_id)\"", ",", "\n", "decomposition", ",", "\n", ")", "\n", "print", "(", "\"\"", ")", "\n", "\n", "", "return", "residual", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._multivariate_sparse_encode": [[264, 321], ["len", "list", "list", "range", "ValueError", "ValueError", "mdla._multivariate_OMP", "list.append", "list.append"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._multivariate_OMP"], ["", "def", "_multivariate_sparse_encode", "(", "X", ",", "kernels", ",", "n_nonzero_coefs", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "    ", "\"\"\"Sparse coding multivariate signal\n\n    Each columns of the results is the OMP approximation on a\n    multivariate dictionary.\n\n    Parameters\n    ----------\n    X: array of shape (n_samples, n_features, n_dims)\n        Data matrices, where n_samples in the number of samples\n        Each sample is a matrix of shape (n_features, n_dims) with\n        n_features >= n_dims.\n\n    kernels: list of arrays\n        The dictionary against which to solve the sparse coding of\n        the data. The dictionary learned is a list of n_kernels\n        elements. Each element is a convolution kernel, i.e. an\n        array of shape (k, n_dims), where k <= n_features and is\n        kernel specific. The algorithm normalizes the kernels.\n\n    n_nonzero_coefs : int\n        Sparsity controller parameter for multivariate variant\n        of OMP\n\n    verbose:\n        Degree of output the procedure will print.\n\n    Returns\n    -------\n\n    residual: list of arrays (n_features, n_dims)\n        The sparse decomposition residuals\n\n    decomposition: list of arrays (n_nonzero_coefs, 3)\n        The sparse code decomposition : (amplitude, offset, kernel)\n        for all n_nonzero_coefs. The list concatenates all the\n        decomposition of the n_samples of X.\n\n    See also\n    --------\n    SparseCoder\n    \"\"\"", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "n_kernels", "=", "len", "(", "kernels", ")", "\n", "\n", "if", "n_nonzero_coefs", ">", "n_kernels", ":", "\n", "        ", "raise", "ValueError", "(", "\"The sparsity should be less than the \"", "\"number of atoms\"", ")", "\n", "", "if", "n_nonzero_coefs", "<=", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"The sparsity should be positive\"", ")", "\n", "\n", "", "decomposition", "=", "list", "(", ")", "\n", "residual", "=", "list", "(", ")", "\n", "for", "k", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "r", ",", "d", "=", "_multivariate_OMP", "(", "X", "[", "k", ",", ":", ",", ":", "]", ",", "kernels", ",", "n_nonzero_coefs", ",", "verbose", ")", "\n", "decomposition", ".", "append", "(", "d", ")", "\n", "residual", ".", "append", "(", "r", ")", "\n", "", "return", "residual", ",", "decomposition", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode": [[323, 421], ["mdla.array3d", "list", "list", "list", "time.time", "isinstance", "isinstance", "max", "joblib.cpu_count", "mdla._multivariate_sparse_encode", "sklearn.utils.gen_even_slices", "print", "joblib.Parallel", "list.extend", "list.extend", "print", "int", "numpy.round", "joblib.delayed", "time.time"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.array3d", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._multivariate_sparse_encode"], ["", "def", "multivariate_sparse_encode", "(", "\n", "X", ",", "dictionary", ",", "n_nonzero_coefs", "=", "None", ",", "n_jobs", "=", "1", ",", "verbose", "=", "False", "\n", ")", ":", "\n", "    ", "\"\"\"Sparse coding\n\n    Each row of the result is the solution to a sparse coding problem.\n    The goal is to find a sparse array `code` such that::\n\n        X ~= code * dictionary\n\n    Parameters\n    ----------\n    X: array of shape (n_samples, n_features, n_dims)\n        Data matrices, where n_samples in the number of samples\n        Each sample is a matrix of shape (n_features, n_dims) with\n        n_features >= n_dims.\n\n    dictionary: list of arrays or MultivariateDictLearning instance\n        The dictionary against which to solve the sparse coding of\n        the data. The dictionary learned is a list of n_kernels\n        elements. Each element is a convolution kernel, i.e. an\n        array of shape (k, n_dims), where k <= n_features and is\n        kernel specific. The algorithm normalizes the kernels.\n\n    n_nonzero_coefs: int, 0.1 * n_features by default\n        Number of nonzero coefficients to target in each column of the\n        solution.\n\n    n_jobs: int, optional\n        Number of parallel jobs to run.\n\n    verbose:\n        Degree of output the procedure will print.\n\n    Returns\n    -------\n    residual: list of array(n_features, n_dims)\n        Decomposition residual\n\n    code: list of arrays (n_nonzero_coefs, 3)\n        The sparse code decomposition: (amplitude, offset, kernel)\n        for all n_nonzero_coefs. The list concatenates all the\n        decomposition of the n_samples of X\n\n    See also\n    --------\n    sklearn.linear_model.lars_path\n    sklearn.linear_model.orthogonal_mp\n    sklearn.linear_model.Lasso\n    SparseCoder\n    \"\"\"", "\n", "if", "verbose", ">=", "2", ":", "\n", "        ", "tstart", "=", "time", "(", ")", "\n", "\n", "", "X", "=", "array3d", "(", "X", ")", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "if", "isinstance", "(", "dictionary", ",", "MultivariateDictLearning", ")", "or", "isinstance", "(", "\n", "dictionary", ",", "MiniBatchMultivariateDictLearning", "\n", ")", ":", "\n", "        ", "kernels", "=", "dictionary", ".", "kernels_", "\n", "", "else", ":", "\n", "        ", "kernels", "=", "dictionary", "\n", "\n", "", "if", "n_nonzero_coefs", "is", "None", ":", "\n", "        ", "n_nonzero_coefs", "=", "max", "(", "int", "(", "np", ".", "round", "(", "n_features", "/", "10", ")", ")", ",", "1", ")", "\n", "\n", "", "if", "n_jobs", "==", "-", "1", ":", "\n", "        ", "n_jobs", "=", "cpu_count", "(", ")", "\n", "\n", "", "if", "n_jobs", "==", "1", ":", "\n", "        ", "r", ",", "d", "=", "_multivariate_sparse_encode", "(", "X", ",", "kernels", ",", "n_nonzero_coefs", ",", "verbose", ")", "\n", "return", "r", ",", "d", "\n", "\n", "# Enter parallel code block", "\n", "", "residuals", "=", "list", "(", ")", "\n", "decompositions", "=", "list", "(", ")", "\n", "slices", "=", "list", "(", "gen_even_slices", "(", "n_samples", ",", "n_jobs", ")", ")", "\n", "\n", "if", "verbose", ">=", "3", ":", "\n", "        ", "print", "(", "\n", "\"[Debug-MOMP] starting parallel %d jobs for %d samples\"", "%", "(", "n_jobs", ",", "n_samples", ")", "\n", ")", "\n", "\n", "", "views", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ")", "(", "\n", "delayed", "(", "_multivariate_sparse_encode", ")", "(", "\n", "X", "[", "this_slice", "]", ",", "kernels", ",", "n_nonzero_coefs", ",", "verbose", "\n", ")", "\n", "for", "this_slice", "in", "slices", "\n", ")", "\n", "# for this_slice, this_res, this_code in zip(slices, res_views, code_views):", "\n", "for", "this_res", ",", "this_code", "in", "views", ":", "\n", "        ", "residuals", ".", "extend", "(", "this_res", ")", "\n", "decompositions", ".", "extend", "(", "this_code", ")", "\n", "\n", "", "if", "verbose", ">=", "3", ":", "\n", "        ", "print", "(", "\"sparse decomposition: \"", ",", "time", "(", ")", "-", "tstart", ",", "\"s\"", ")", "\n", "\n", "", "return", "residuals", ",", "decompositions", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.reconstruct_from_code": [[423, 462], ["len", "list", "range", "numpy.array", "numpy.zeros", "list.append", "mdla._shift_and_extend", "int", "int", "int"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._shift_and_extend"], ["", "def", "reconstruct_from_code", "(", "code", ",", "dictionary", ",", "n_features", ")", ":", "\n", "    ", "\"\"\"Reconstruct input from multivariate dictionary decomposition\n\n    Parameters\n    ----------\n    code: list of arrays (n_nonzero_coefs, 3)\n        The sparse code decomposition: (amplitude, offset, kernel)\n        for all n_nonzero_coefs. The list concatenates all the\n        decomposition of the n_samples of input X\n\n    dictionary: list of arrays\n        The dictionary against which to solve the sparse coding of\n        the data. The dictionary learned is a list of n_kernels\n        elements. Each element is a convolution kernel, i.e. an\n        array of shape (k, n_dims), where k <= n_features and is\n        kernel specific. The algorithm normalizes the kernels.\n\n    n_features: int\n        A signal is an array of shape (n_features, n_dims)\n\n    Returns\n    -------\n    signal: array of shape (n_samples, n_features, n_dims)\n        Data matrices of the reconstructed signal, where n_samples\n        in the number of samples. Each sample is a matrix of shape\n        (n_features, n_dims) with n_features >= n_dims.\n    \"\"\"", "\n", "n_dims", "=", "dictionary", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "n_samples", "=", "len", "(", "code", ")", "\n", "signal", "=", "list", "(", ")", "\n", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "decomposition", "=", "code", "[", "i", "]", "\n", "s", "=", "np", ".", "zeros", "(", "shape", "=", "(", "n_features", ",", "n_dims", ")", ")", "\n", "for", "k_amplitude", ",", "k_offset", ",", "k_selected", "in", "decomposition", ":", "\n", "            ", "s", "+=", "k_amplitude", "*", "_shift_and_extend", "(", "\n", "dictionary", "[", "int", "(", "k_selected", ")", "]", ",", "int", "(", "n_features", ")", ",", "int", "(", "k_offset", ")", "\n", ")", "\n", "", "signal", ".", "append", "(", "s", ")", "\n", "", "return", "np", ".", "array", "(", "signal", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._compute_gradient": [[464, 578], ["len", "sklearn.utils.check_random_state", "decomposition[].astype", "decomposition[].astype", "range", "numpy.zeros", "range", "numpy.zeros_like", "mdla.find", "numpy.sort", "numpy.argsort", "mdla.find", "numpy.sum", "print", "print", "print", "print", "print", "print", "range", "numpy.conj", "print", "range", "numpy.abs", "numpy.sum", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.find", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.find"], ["", "def", "_compute_gradient", "(", "\n", "dictionary", ",", "\n", "decomposition", ",", "\n", "residual", ",", "\n", "learning_rate", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Compute the gradient to apply on the dictionary.\n\n    Parameters\n    ----------\n    dictionary: list of arrays of\n        Value of the dictionary at the previous iteration.\n        The dictionary is a list of n_kernels\n        elements. Each element is a convolution kernel, i.e. an\n        array of shape (k, n_dims), where k <= n_features and is\n        kernel specific. The algorithm normalizes the kernels.\n\n    decomposition: array of shape (n_nonzero_coefs, 3)\n        Sparse decomposition of the data against which to optimize\n        the dictionary.\n\n    residual: array of shape (n_features, n_dims)\n        Residual of the sparse decomposition\n\n    learning_rate: real,\n        hyperparameter controling the convergence rate\n\n    random_state: int or RandomState\n        Pseudo number generator state used for random sampling.\n\n    verbose:\n        Degree of output the procedure will print.\n\n    Returns\n    -------\n    gradient: list of arrays\n        list of gradients to apply on the dictionnary.\n    \"\"\"", "\n", "n_kernels", "=", "len", "(", "dictionary", ")", "\n", "random_state", "=", "check_random_state", "(", "random_state", ")", "\n", "\n", "n_active_atoms", "=", "decomposition", ".", "shape", "[", "0", "]", "\n", "signal_len", ",", "n_dims", "=", "residual", ".", "shape", "\n", "coefs", "=", "decomposition", "[", ":", ",", "0", "]", "\n", "offsets", "=", "decomposition", "[", ":", ",", "1", "]", ".", "astype", "(", "int", ")", "\n", "index_atoms", "=", "decomposition", "[", ":", ",", "2", "]", ".", "astype", "(", "int", ")", "\n", "hessian_sum", "=", "0", "\n", "hessian_count", "=", "0", "\n", "\n", "# Initialization", "\n", "gradient", "=", "[", "np", ".", "zeros_like", "(", "dictionary", "[", "i", "]", ")", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "n_active_atoms", ")", ":", "\n", "        ", "k_len", "=", "dictionary", "[", "index_atoms", "[", "i", "]", "]", ".", "shape", "[", "0", "]", "\n", "if", "k_len", "+", "offsets", "[", "i", "]", "-", "1", "<=", "signal_len", ":", "\n", "# Do not consider oversized atoms", "\n", "            ", "r", "=", "residual", "[", "offsets", "[", "i", "]", ":", "k_len", "+", "offsets", "[", "i", "]", ",", ":", "]", "# modif", "\n", "gradient", "[", "index_atoms", "[", "i", "]", "]", "+=", "np", ".", "conj", "(", "coefs", "[", "i", "]", "*", "r", ")", "\n", "", "if", "verbose", ">=", "5", ":", "\n", "            ", "print", "(", "\"[M-DU] Update kernel\"", ",", "i", ",", "\", gradient is\"", ",", "gradient", "[", "index_atoms", "[", "i", "]", "]", ")", "\n", "\n", "# First pass to estimate the step", "\n", "", "", "step", "=", "np", ".", "zeros", "(", "(", "n_kernels", ",", "1", ")", ")", "\n", "for", "i", "in", "range", "(", "n_kernels", ")", ":", "\n", "        ", "k_len", "=", "dictionary", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "active_idx", "=", "find", "(", "index_atoms", "==", "i", ")", "\n", "offsets_sorted", "=", "np", ".", "sort", "(", "offsets", "[", "active_idx", "]", ")", "\n", "offsets_sorted_idx", "=", "np", ".", "argsort", "(", "offsets", "[", "active_idx", "]", ")", "\n", "active_coefs", "=", "coefs", "[", "active_idx", "]", "\n", "active_coefs", "=", "active_coefs", "[", "offsets_sorted_idx", "]", "\n", "dOffsets", "=", "offsets_sorted", "[", "1", ":", "]", "-", "offsets_sorted", "[", "0", ":", "-", "1", "]", "\n", "dOffsets_idx", "=", "find", "(", "dOffsets", "<", "k_len", ")", "\n", "if", "dOffsets_idx", ".", "size", "==", "0", ":", "\n", "# Good separation, use a direct approximation of", "\n", "# the Hessian", "\n", "            ", "hessian_corr", "=", "0", "\n", "", "else", ":", "\n", "# Weak Hessian approximation, crude correction to include", "\n", "# the overlapping atoms", "\n", "            ", "hessian_corr", "=", "(", "\n", "2.0", "\n", "*", "np", ".", "sum", "(", "\n", "np", ".", "abs", "(", "active_coefs", "[", "dOffsets_idx", "]", "*", "active_coefs", "[", "dOffsets_idx", "+", "1", "]", ")", "\n", "*", "(", "k_len", "-", "dOffsets", "[", "dOffsets_idx", "]", ")", "\n", ")", "\n", "/", "k_len", "\n", ")", "\n", "", "hessian_base", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "coefs", "[", "active_idx", "]", ")", "**", "2", ")", "\n", "# if learning_rate+hessian_corr+hessian_base == 0.:", "\n", "if", "learning_rate", "==", "0.0", ":", "\n", "# Gauss-Newton method if mu = 0", "\n", "            ", "step", "[", "i", "]", "=", "0", "\n", "", "else", ":", "\n", "            ", "step", "[", "i", "]", "=", "1.0", "/", "(", "learning_rate", "+", "hessian_corr", "+", "hessian_base", ")", "\n", "", "if", "(", "hessian_corr", "+", "hessian_base", ")", "!=", "0", ":", "\n", "            ", "hessian_sum", "+=", "hessian_corr", "+", "hessian_base", "\n", "hessian_count", "+=", "1", "\n", "\n", "", "", "if", "verbose", ">=", "5", ":", "\n", "        ", "print", "(", "\"[M-DU]: step is:\"", ")", "\n", "print", "(", "step", ")", "\n", "print", "(", "\"[M-DU]: gradient is:\"", ")", "\n", "print", "(", "gradient", ")", "\n", "", "gradient", "=", "[", "gradient", "[", "i", "]", "*", "step", "[", "i", "]", "for", "i", "in", "range", "(", "n_kernels", ")", "]", "\n", "\n", "# TODO: add forget factor?", "\n", "\n", "if", "verbose", ">=", "5", ":", "\n", "        ", "print", "(", "\"[M-DU]: diff is:\"", ")", "\n", "print", "(", "gradient", ")", "\n", "\n", "", "return", "gradient", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._update_dict": [[580, 663], ["list", "zip", "range", "mdla._normalize", "time.time", "mdla._compute_gradient", "list.append", "numpy.zeros", "range", "print", "print", "print", "len", "print", "len", "time.time", "range", "len"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._compute_gradient"], ["", "def", "_update_dict", "(", "\n", "dictionary", ",", "\n", "decomposition", ",", "\n", "residual", ",", "\n", "learning_rate", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Update the dense dictionary in place\n\n    Update the dictionary based on sparse codes and residuals\n\n    Parameters\n    ----------\n    dictionary: list of arrays\n        The dictionary against which to solve the sparse coding of\n        the data. The dictionary learned is a list of n_kernels\n        elements. Each element is a convolution kernel, i.e. an\n        array of shape (k, n_dims), where k <= n_features and is\n        kernel specific. The algorithm normalizes the kernels.\n\n    decomposition: list of array of shape (n_features, n_dims)\n        Each sample is a matrix of shape (n_features, n_dims) with\n        n_features >= n_dims.\n\n    residual: list of array of shape (n_features, n_dims)\n        Residual of the sparse decomposition\n\n    learning_rate: real,\n        hyperparameter controling the convergence rate\n\n    random_state: int or RandomState\n        Pseudo number generator state used for random sampling.\n\n    verbose:\n        Degree of output the procedure will print.\n\n    Returns\n    -------\n    dictionary: list of arrays\n        Updated dictionary.\n\n    \"\"\"", "\n", "if", "verbose", ">=", "2", ":", "\n", "        ", "tstart", "=", "time", "(", ")", "\n", "\n", "", "gradients", "=", "list", "(", ")", "\n", "for", "c", ",", "r", "in", "zip", "(", "decomposition", ",", "residual", ")", ":", "\n", "        ", "g", "=", "_compute_gradient", "(", "dictionary", ",", "c", ",", "r", ",", "learning_rate", ",", "random_state", ",", "verbose", ")", "\n", "gradients", ".", "append", "(", "g", ")", "\n", "\n", "", "_g", "=", "[", "np", ".", "zeros", "(", "k", ".", "shape", ")", "for", "k", "in", "dictionary", "]", "\n", "for", "g", "in", "gradients", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "dictionary", ")", ")", ":", "\n", "            ", "_g", "[", "i", "]", "=", "_g", "[", "i", "]", "+", "g", "[", "i", "]", "\n", "\n", "", "", "if", "verbose", ">=", "3", ":", "\n", "        ", "print", "(", "\"[M-DU] energy change ratio is \"", ")", "\n", "print", "(", "\n", "[", "\n", "(", "_g", "[", "i", "]", "**", "2", ")", ".", "sum", "(", "0", ")", ".", "mean", "(", ")", "/", "(", "dictionary", "[", "i", "]", "**", "2", ")", ".", "sum", "(", "0", ")", ".", "mean", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "dictionary", ")", ")", "\n", "]", "\n", ")", "\n", "print", "(", "\"learning_rate is \"", ",", "learning_rate", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "dictionary", ")", ")", ":", "\n", "        ", "dictionary", "[", "i", "]", "=", "dictionary", "[", "i", "]", "+", "_g", "[", "i", "]", "\n", "", "dictionary", "=", "_normalize", "(", "dictionary", ")", "\n", "\n", "if", "verbose", ">=", "3", ":", "\n", "        ", "print", "(", "\"dict update: \"", ",", "time", "(", ")", "-", "tstart", ",", "\"s\"", ")", "\n", "\n", "# if verbose >= 1:", "\n", "#     diff = grad = 0.", "\n", "#     for i in range(len(dictionary)):", "\n", "#         grad += (_g[i]**2).sum(0).mean()", "\n", "#         diff += ((dictionary[i]-initial[i])**2).sum(0).mean()", "\n", "#     print ('[MDLA-DU] Gradient energy is', grad, 'and energy change is', diff)", "\n", "#     print ([((dictionary[i]-initial[i])**2).sum(0).mean() for i in range(len(dictionary))])", "\n", "#     print (dictionary[7])", "\n", "\n", "", "return", "dictionary", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_dict_learning": [[722, 911], ["time.time", "sklearn.utils.check_random_state", "range", "joblib.cpu_count", "list", "len", "sklearn.utils.check_random_state.randint", "mdla._normalize", "print", "len", "numpy.array().reshape", "numpy.array().reshape", "print", "print", "sklearn.utils.check_random_state.permutation", "time.time", "print", "mdla.multivariate_sparse_encode", "mdla._get_learning_rate", "mdla._update_dict", "range", "np.array().reshape.append", "abs", "callback", "len", "zip", "sys.stdout.write", "sys.stdout.flush", "print", "len", "print", "locals", "numpy.array", "len", "numpy.array", "numpy.linalg.norm", "len", "len", "print", "print", "time.time"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._get_learning_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._update_dict"], ["", "def", "multivariate_dict_learning", "(", "\n", "X", ",", "\n", "n_kernels", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "max_iter", "=", "100", ",", "\n", "tol", "=", "1e-8", ",", "\n", "n_jobs", "=", "1", ",", "\n", "learning_rate", "=", "None", ",", "\n", "dict_init", "=", "None", ",", "\n", "callback", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "kernel_init_len", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "dict_obj", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Solves a dictionary learning matrix factorization problem.\n\n    Finds the best dictionary and the corresponding sparse code for\n    approximating the data matrix X by solving::\n\n        (U^*, V^*) = argmin 0.5 || X - U V ||_F^2 s.t. || U ||_0 < K\n                     (U,V)\n                    with || V_i ||_F = 1 for all  0 <= i < n_kernels\n\n    where V is the dictionary and U is the sparse code.\n\n    Parameters\n    ----------\n    X: array of shape (n_samples, n_features, n_dims)\n        Data matrices, where n_samples in the number of samples\n        Each sample is a matrix of shape (n_features, n_dims) with\n        n_features >= n_dims.\n\n    n_kernels: int,\n        Number of dictionary atoms to extract.\n\n    n_nonzero_coefs: int,\n        Sparsity controlling parameter.\n\n    max_iter: int,\n        Maximum number of iterations to perform.\n\n    tol: float,\n        Tolerance for the stopping condition.\n\n    n_jobs: int,\n        Number of parallel jobs to run, or -1 to autodetect.\n\n    learning_rate: real,\n        hyperparameter controling the convergence rate\n\n    dict_init: list of arrays\n        Initial value for the dictionary for warm restart scenarios.\n        List of n_kernels elements, each one is an array of shape\n        (k, n_dims), where k <= n_features and is kernel specific\n\n    callback:\n        Callable that gets invoked every iterations.\n\n    verbose:\n        Degree of output the procedure will print.\n\n    kernel_init_len: int,\n        Initial length for all the dictionary kernel\n\n    random_state: int or RandomState\n        Pseudo number generator state used for random sampling.\n\n    Returns\n    -------\n    code: list of arrays (n_nonzero_coefs, 3)\n        The sparse code decomposition: (amplitude, offset, kernel)\n        for all n_nonzero_coefs. The list concatenates all the\n        decomposition of the n_samples of X\n\n    dictionary: list of arrays\n        The dictionary learned is a list of n_kernels elements.\n        Each element is a convolution kernel, i.e. an array\n        of shape (k, n_dims), where k <= n_features and is kernel\n        specific\n\n    errors: array\n        matrix of errors at each iteration.\n\n    See also\n    --------\n    multivariate_dict_learning_online\n    DictionaryLearning\n    MiniBatchDictionaryLearning\n    SparsePCA\n    MiniBatchSparsePCA\n    \"\"\"", "\n", "t0", "=", "time", "(", ")", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "random_state", "=", "check_random_state", "(", "random_state", ")", "\n", "\n", "if", "n_jobs", "==", "-", "1", ":", "\n", "        ", "n_jobs", "=", "cpu_count", "(", ")", "\n", "\n", "", "if", "dict_init", "is", "not", "None", ":", "\n", "        ", "dictionary", "=", "list", "(", "dict_init", ")", "\n", "n_kernels", "=", "len", "(", "dictionary", ")", "\n", "if", "verbose", ">=", "2", ":", "\n", "            ", "print", "(", "\"\\n[MDL] Warm restart with dictionary of\"", ",", "len", "(", "dictionary", ")", ",", "\"kernels\"", ")", "\n", "", "", "else", ":", "\n", "# Init the dictionary with random samples of X", "\n", "        ", "k_len", "=", "kernel_init_len", "\n", "max_offset", "=", "n_features", "-", "k_len", "\n", "\n", "if", "verbose", ">=", "2", ":", "\n", "            ", "print", "(", "\"[MDL] Initializing dictionary from samples\"", ")", "\n", "", "offset", "=", "random_state", ".", "randint", "(", "0", ",", "max_offset", "+", "1", ",", "n_kernels", ")", "\n", "ind_kernels", "=", "random_state", ".", "permutation", "(", "n_samples", ")", "[", ":", "n_kernels", "]", "\n", "dictionary", "=", "[", "X", "[", "p", "[", "0", "]", ",", "p", "[", "1", "]", ":", "p", "[", "1", "]", "+", "k_len", ",", ":", "]", "for", "p", "in", "zip", "(", "ind_kernels", ",", "offset", ")", "]", "\n", "dictionary", "=", "_normalize", "(", "dictionary", ")", "\n", "\n", "", "errors", "=", "[", "]", "\n", "current_cost", "=", "np", ".", "nan", "\n", "\n", "if", "verbose", "==", "1", ":", "\n", "        ", "print", "(", "\"\\n[dict_learning]\"", ",", "end", "=", "\" \"", ")", "\n", "\n", "", "for", "ii", "in", "range", "(", "max_iter", ")", ":", "\n", "        ", "dt", "=", "time", "(", ")", "-", "t0", "\n", "if", "verbose", ">=", "2", ":", "\n", "            ", "print", "(", "\n", "\"[MDL] Iteration % 3i \"", "\n", "\"(elapsed time: % 3is, % 4.1fmn, current cost % 7.3f)\"", "\n", "%", "(", "ii", ",", "dt", ",", "dt", "/", "60", ",", "current_cost", "/", "n_samples", ")", "\n", ")", "\n", "", "elif", "verbose", "==", "1", ":", "\n", "            ", "sys", ".", "stdout", ".", "write", "(", "\".\"", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "\n", "", "try", ":", "\n", "# Update code", "\n", "            ", "r", ",", "code", "=", "multivariate_sparse_encode", "(", "\n", "X", ",", "\n", "dictionary", ",", "\n", "n_nonzero_coefs", "=", "n_nonzero_coefs", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "verbose", "=", "verbose", ",", "\n", ")", "\n", "# Update dictionary", "\n", "mu", "=", "_get_learning_rate", "(", "ii", ",", "max_iter", ",", "learning_rate", ")", "\n", "dictionary", "=", "_update_dict", "(", "\n", "dictionary", ",", "\n", "decomposition", "=", "code", ",", "\n", "residual", "=", "r", ",", "\n", "verbose", "=", "verbose", ",", "\n", "learning_rate", "=", "mu", ",", "\n", "random_state", "=", "random_state", ",", "\n", ")", "\n", "if", "verbose", ">=", "2", ":", "\n", "                ", "print", "(", "\"[MDL] Dictionary updated, iteration\"", ",", "ii", ",", "\"with learning rate\"", ",", "mu", ")", "\n", "\n", "# Cost function", "\n", "", "current_cost", "=", "0.0", "\n", "for", "i", "in", "range", "(", "len", "(", "r", ")", ")", ":", "\n", "                ", "current_cost", "+=", "np", ".", "linalg", ".", "norm", "(", "r", "[", "i", "]", ",", "\"fro\"", ")", "+", "len", "(", "code", "[", "i", "]", ")", "\n", "# current_cost = 0.5 * residuals + np.sum(np.abs(code))", "\n", "", "errors", ".", "append", "(", "current_cost", "/", "len", "(", "r", ")", ")", "\n", "", "except", "KeyboardInterrupt", ":", "\n", "            ", "break", "\n", "\n", "", "if", "ii", ">", "0", ":", "\n", "            ", "dE", "=", "abs", "(", "errors", "[", "-", "2", "]", "-", "errors", "[", "-", "1", "]", ")", "\n", "# assert(dE >= -tol * errors[-1])", "\n", "if", "ii", "==", "1", "and", "verbose", "==", "1", ":", "\n", "                ", "print", "(", "\n", "\"Expecting this learning experiment to finish in %.2f m\"", "\n", "%", "(", "(", "time", "(", ")", "-", "t0", ")", "*", "max_iter", "/", "60.0", ")", "\n", ")", "\n", "", "if", "dE", "<", "tol", "*", "errors", "[", "-", "1", "]", ":", "\n", "                ", "if", "verbose", ">=", "1", ":", "\n", "# A line return", "\n", "                    ", "print", "(", "\"\"", ")", "\n", "", "elif", "verbose", ":", "\n", "                    ", "print", "(", "\"--- Convergence reached after %d iterations\"", "%", "ii", ")", "\n", "", "break", "\n", "", "", "if", "callback", "is", "not", "None", ":", "\n", "            ", "callback", "(", "locals", "(", ")", ")", "\n", "# reformating the error", "\n", "# print (\"errors=\", len(errors), \", reshape into\", (max_iter,))", "\n", "", "", "if", "len", "(", "errors", ")", "<", "max_iter", ":", "\n", "        ", "errors", "=", "np", ".", "array", "(", "errors", ")", ".", "reshape", "(", "(", "len", "(", "errors", ")", ",", ")", ")", "\n", "", "else", ":", "\n", "        ", "errors", "=", "np", ".", "array", "(", "errors", ")", ".", "reshape", "(", "(", "max_iter", ",", ")", ")", "\n", "", "return", "code", ",", "dictionary", ",", "errors", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_dict_learning_online": [[913, 1126], ["time.time", "sklearn.utils.check_random_state", "int", "numpy.array_split", "itertools.cycle", "zip", "numpy.array().reshape", "joblib.cpu_count", "list", "len", "sklearn.utils.check_random_state.randint", "mdla._normalize", "print", "numpy.floor", "X.copy", "sklearn.utils.check_random_state.shuffle", "print", "range", "print", "print", "print", "sklearn.utils.check_random_state.permutation", "time.time", "mdla.multivariate_sparse_encode", "mdla._get_learning_rate", "mdla._update_dict", "range", "np.array().reshape.append", "time.time", "numpy.array", "len", "zip", "float", "len", "numpy.mod", "print", "len", "numpy.linalg.norm", "len", "len", "print", "callback", "sys.stdout.write", "sys.stdout.flush", "locals", "time.time"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._normalize", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.multivariate_sparse_encode", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._get_learning_rate", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla._update_dict"], ["", "def", "multivariate_dict_learning_online", "(", "\n", "X", ",", "\n", "n_kernels", "=", "2", ",", "\n", "n_nonzero_coefs", "=", "1", ",", "\n", "n_iter", "=", "100", ",", "\n", "iter_offset", "=", "0", ",", "\n", "dict_init", "=", "None", ",", "\n", "callback", "=", "None", ",", "\n", "batch_size", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "shuffle", "=", "True", ",", "\n", "n_jobs", "=", "1", ",", "\n", "kernel_init_len", "=", "None", ",", "\n", "learning_rate", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "dict_obj", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"Solves an online multivariate dictionary learning factorization problem\n\n    Finds the best dictionary and the corresponding sparse code for\n    approximating the data matrices X by solving::\n\n        (U^*, V^*) = argmin 0.5 || X - U V ||_F^2 s.t. || U ||_0 < k\n                     (U,V)\n                     with || V_i ||_F = 1 for all  0 <= i < n_kernels\n\n    where V is the dictionary and U is the sparse code. This is\n    accomplished by repeatedly iterating over mini-batches by slicing\n    the input data.\n\n    Parameters\n    ----------\n    X: array of shape (n_samples, n_features, n_dims)\n        Set of n_samples data matrix.\n\n    n_kernels : int,\n        Number of dictionary atoms to extract.\n\n    n_nonzero_coefs : int,\n        Sparsity controlling parameter.\n\n    n_iter : int,\n        Number of iterations to perform.\n\n    iter_offset : int, default 0\n        Number of previous iterations completed on the dictionary used for\n        initialization.\n\n    dict_init : list of arrays\n        Initial value for the dictionary for warm restart scenarios.\n        The dictionary is a list of n_kernels elements. Each element\n        is a convolution kernel, i.e. an array of shape (k, n_dims),\n        where k <= n_features and is kernel specific.\n\n    callback :\n        Callable that gets invoked every iterations.\n\n    batch_size : int,\n        The number of samples to take in each batch. If None, initialised\n        as 5 * n_jobs\n\n    verbose :\n        Degree of output the procedure will print.\n\n    shuffle : boolean,\n        Whether to shuffle the data before splitting it in batches.\n\n    n_jobs : int,\n        Number of parallel jobs to run, or -1 to autodetect.\n\n    learning_rate: real,\n        hyperparameter controling the convergence rate\n\n    random_state : int or RandomState\n        Pseudo number generator state used for random sampling.\n\n    Returns\n    -------\n    dictionary : list of arrays\n        the solutions to the dictionary learning problem\n\n    errors: array\n        matrix of errors at each iteration.\n\n    See also\n    --------\n    multivariate_dict_learning\n    DictionaryLearning\n    MiniBatchDictionaryLearning\n    SparsePCA\n    MiniBatchSparsePCA\n    \"\"\"", "\n", "t0", "=", "time", "(", ")", "\n", "\n", "n_samples", ",", "n_features", ",", "n_dims", "=", "X", ".", "shape", "\n", "# if n_samples < n_kernels:", "\n", "#     print ('Too few examples, reducing the number of kernel to', n_samples)", "\n", "#     n_kernels = n_samples", "\n", "random_state", "=", "check_random_state", "(", "random_state", ")", "\n", "\n", "# if n_jobs == -1 and cpu_count() != 0:", "\n", "#     n_jobs = cpu_count()", "\n", "# else: n_jobs = 1", "\n", "if", "n_jobs", "==", "-", "1", ":", "\n", "        ", "n_jobs", "=", "cpu_count", "(", ")", "\n", "\n", "", "if", "batch_size", "is", "None", ":", "\n", "        ", "batch_size", "=", "5", "*", "n_jobs", "\n", "\n", "", "if", "dict_init", "is", "not", "None", ":", "\n", "        ", "dictionary", "=", "list", "(", "dict_init", ")", "\n", "n_kernels", "=", "len", "(", "dictionary", ")", "\n", "if", "verbose", ">=", "2", ":", "\n", "            ", "print", "(", "\"\\n[MDL] Warm restart with dictionary of\"", ",", "len", "(", "dictionary", ")", ",", "\"kernels\"", ")", "\n", "", "", "else", ":", "\n", "# Init dictionary with random X samples", "\n", "        ", "k_len", "=", "kernel_init_len", "\n", "max_offset", "=", "n_features", "-", "k_len", "\n", "\n", "if", "verbose", ">=", "2", ":", "\n", "            ", "print", "(", "\"[MDL] Initializing dictionary from samples\"", ")", "\n", "", "offset", "=", "random_state", ".", "randint", "(", "0", ",", "max_offset", "+", "1", ",", "n_kernels", ")", "\n", "ind_kernels", "=", "random_state", ".", "permutation", "(", "n_samples", ")", "[", ":", "n_kernels", "]", "\n", "dictionary", "=", "[", "X", "[", "p", "[", "0", "]", ",", "p", "[", "1", "]", ":", "p", "[", "1", "]", "+", "k_len", ",", ":", "]", "for", "p", "in", "zip", "(", "ind_kernels", ",", "offset", ")", "]", "\n", "dictionary", "=", "_normalize", "(", "dictionary", ")", "\n", "\n", "", "errors", "=", "[", "]", "\n", "current_cost", "=", "np", ".", "nan", "\n", "\n", "if", "verbose", "==", "1", ":", "\n", "        ", "print", "(", "\"\\n[dict_learning]\"", ",", "end", "=", "\" \"", ")", "\n", "\n", "", "n_batches", "=", "int", "(", "floor", "(", "float", "(", "len", "(", "X", ")", ")", "/", "batch_size", ")", ")", "\n", "if", "n_batches", "==", "0", ":", "\n", "        ", "n_batches", "=", "1", "\n", "", "if", "shuffle", ":", "\n", "        ", "X_train", "=", "X", ".", "copy", "(", ")", "\n", "random_state", ".", "shuffle", "(", "X_train", ")", "\n", "", "else", ":", "\n", "        ", "X_train", "=", "X", "\n", "", "batches", "=", "np", ".", "array_split", "(", "X_train", ",", "n_batches", ")", "\n", "batches", "=", "itertools", ".", "cycle", "(", "batches", ")", "\n", "\n", "if", "verbose", ">=", "2", ":", "\n", "        ", "print", "(", "\n", "\"[MDL] Using %d jobs and %d batch of %d examples\"", "\n", "%", "(", "n_jobs", ",", "n_batches", ",", "batch_size", ")", "\n", ")", "\n", "\n", "", "for", "ii", ",", "this_X", "in", "zip", "(", "\n", "range", "(", "iter_offset", "*", "n_batches", ",", "(", "iter_offset", "+", "n_iter", ")", "*", "n_batches", ")", ",", "batches", "\n", ")", ":", "\n", "        ", "dt", "=", "time", "(", ")", "-", "t0", "\n", "\n", "try", ":", "\n", "            ", "r", ",", "code", "=", "multivariate_sparse_encode", "(", "\n", "this_X", ",", "\n", "dictionary", ",", "\n", "n_nonzero_coefs", "=", "n_nonzero_coefs", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "verbose", "=", "verbose", ",", "\n", ")", "\n", "# Update dictionary", "\n", "mu", "=", "_get_learning_rate", "(", "\n", "ii", "/", "n_batches", "+", "1", ",", "iter_offset", "+", "n_iter", "+", "1", ",", "learning_rate", "\n", ")", "\n", "dictionary", "=", "_update_dict", "(", "\n", "dictionary", ",", "\n", "decomposition", "=", "code", ",", "\n", "residual", "=", "r", ",", "\n", "verbose", "=", "verbose", ",", "\n", "learning_rate", "=", "mu", ",", "\n", "random_state", "=", "random_state", ",", "\n", ")", "\n", "\n", "# Cost function", "\n", "current_cost", "=", "0.0", "\n", "for", "i", "in", "range", "(", "len", "(", "r", ")", ")", ":", "\n", "                ", "current_cost", "+=", "np", ".", "linalg", ".", "norm", "(", "r", "[", "i", "]", ",", "\"fro\"", ")", "+", "len", "(", "code", "[", "i", "]", ")", "\n", "", "errors", ".", "append", "(", "current_cost", "/", "len", "(", "r", ")", ")", "\n", "\n", "if", "np", ".", "mod", "(", "(", "ii", "-", "iter_offset", ")", ",", "n_batches", ")", "==", "0", ":", "\n", "                ", "if", "verbose", ">=", "2", ":", "\n", "                    ", "print", "(", "\n", "\"[MDL] Dictionary updated, iteration %d \"", "\n", "\"with learning rate %.2f (elapsed time: \"", "\n", "\"% 3is, % 4.1fmn)\"", "\n", "%", "(", "(", "ii", "-", "iter_offset", ")", "/", "n_batches", ",", "mu", ",", "dt", ",", "dt", "/", "60", ")", "\n", ")", "\n", "", "elif", "verbose", "==", "1", ":", "\n", "                    ", "sys", ".", "stdout", ".", "write", "(", "\".\"", ")", "\n", "sys", ".", "stdout", ".", "flush", "(", ")", "\n", "", "if", "callback", "is", "not", "None", ":", "\n", "                    ", "callback", "(", "locals", "(", ")", ")", "\n", "\n", "", "", "if", "ii", "==", "(", "iter_offset", "+", "1", ")", "*", "n_batches", "and", "verbose", ">=", "1", ":", "\n", "                ", "print", "(", "\n", "\"Expecting this learning iterations to finish in %.2f m\"", "\n", "%", "(", "(", "time", "(", ")", "-", "t0", ")", "*", "n_iter", "/", "60.0", ")", "\n", ")", "\n", "# if verbose == 1:", "\n", "# print ('Time from begining is',time()-t0,'s, with n_iter=',", "\n", "#         n_iter, ', iter_offset=', iter_offset,", "\n", "#         ', i.e.', n_iter, 'iterations to go.')", "\n", "", "", "except", "KeyboardInterrupt", ":", "\n", "            ", "break", "\n", "\n", "", "", "if", "verbose", ">=", "2", ":", "\n", "        ", "dt", "=", "time", "(", ")", "-", "t0", "\n", "print", "(", "\"[MDL] learning done (total time: % 3is, % 4.1fmn)\"", "%", "(", "dt", ",", "dt", "/", "60", ")", ")", "\n", "# reformating the error", "\n", "", "errors", "=", "np", ".", "array", "(", "errors", ")", ".", "reshape", "(", "(", "n_iter", ",", "n_batches", ")", ")", "\n", "return", "dictionary", ",", "errors", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.mdla.array3d": [[1652, 1666], ["scipy.issparse", "numpy.array", "TypeError", "numpy.atleast_3d", "X_3d.swapaxes.swapaxes", "X_3d.swapaxes.swapaxes", "sklearn.utils.assert_all_finite", "type"], "function", ["None"], ["", "", "def", "array3d", "(", "X", ",", "dtype", "=", "None", ",", "order", "=", "None", ",", "copy", "=", "False", ",", "force_all_finite", "=", "True", ")", ":", "\n", "    ", "\"\"\"Returns at least 3-d array with data from X\"\"\"", "\n", "if", "sp", ".", "issparse", "(", "X", ")", ":", "\n", "        ", "raise", "TypeError", "(", "\n", "\"A sparse matrix was passed, but dense data \"", "\n", "\"is required. Use X.toarray() to convert to dense.\"", "\n", ")", "\n", "", "X_3d", "=", "np", ".", "array", "(", "np", ".", "atleast_3d", "(", "X", ")", ",", "dtype", "=", "dtype", ",", "order", "=", "order", ",", "copy", "=", "copy", ")", "\n", "if", "type", "(", "X", ")", "is", "np", ".", "ndarray", "and", "X", ".", "ndim", "==", "2", ":", "\n", "        ", "X_3d", "=", "X_3d", ".", "swapaxes", "(", "0", ",", "2", ")", "\n", "X_3d", "=", "X_3d", ".", "swapaxes", "(", "1", ",", "2", ")", "\n", "", "if", "force_all_finite", ":", "\n", "        ", "assert_all_finite", "(", "X_3d", ")", "\n", "", "return", "X_3d", "\n", "", ""]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._kernel_registration": [[47, 66], ["len", "numpy.array().max", "numpy.zeros", "enumerate", "numpy.ones", "range", "numpy.array", "g", "numpy.trace", "this_kernel.T.dot", "numpy.linalg.norm", "numpy.linalg.norm"], "function", ["None"], ["def", "_kernel_registration", "(", "this_kernel", ",", "dictionary", ",", "g", ")", ":", "\n", "    ", "k_len", "=", "this_kernel", ".", "shape", "[", "0", "]", "\n", "n_kernels", "=", "len", "(", "dictionary", ")", "\n", "k_max_len", "=", "array", "(", "[", "i", ".", "shape", "[", "0", "]", "for", "i", "in", "dictionary", "]", ")", ".", "max", "(", ")", "\n", "\n", "m_dist", "=", "ones", "(", "(", "n_kernels", ",", "k_max_len", "-", "k_len", "+", "1", ")", ")", "*", "infty", "\n", "m_corr", "=", "zeros", "(", "(", "n_kernels", ",", "k_max_len", "-", "k_len", "+", "1", ")", ")", "\n", "for", "i", ",", "kernel", "in", "enumerate", "(", "dictionary", ")", ":", "# kernel loop", "\n", "        ", "ks", "=", "kernel", ".", "shape", "[", "0", "]", "\n", "# for t in range(k_max_len-k_len+1): # convolution loop", "\n", "for", "t", "in", "range", "(", "ks", "-", "k_len", "+", "1", ")", ":", "# convolution loop", "\n", "# print (\"t = \", t, \"and l =\", l)", "\n", "# print (\"kernel = \", kernel.shape,", "\n", "#        \"and kernel[t:t+l,:] = \", kernel[t:t+k_len,:].shape)", "\n", "            ", "m_dist", "[", "i", ",", "t", "]", "=", "g", "(", "this_kernel", ",", "kernel", "[", "t", ":", "t", "+", "k_len", ",", ":", "]", ")", "\n", "m_corr", "[", "i", ",", "t", "]", "=", "trace", "(", "this_kernel", ".", "T", ".", "dot", "(", "kernel", "[", "t", ":", "t", "+", "k_len", ",", ":", "]", ")", ")", "/", "(", "\n", "norm", "(", "this_kernel", ",", "\"fro\"", ")", "*", "norm", "(", "kernel", "[", "t", ":", "t", "+", "k_len", ",", ":", "]", ",", "\"fro\"", ")", "\n", ")", "\n", "", "", "return", "m_dist", ",", "m_corr", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.principal_angles": [[68, 100], ["scipy.orth", "scipy.orth", "numpy.linalg.svd", "numpy.minimum", "numpy.maximum", "sl.orth.dot", "numpy.any", "sl.orth.T.dot", "numpy.ones_like", "numpy.arccos", "numpy.zeros_like", "numpy.linalg.svd", "numpy.flipud", "numpy.sqrt", "numpy.maximum", "sl.orth.dot", "numpy.arcsin", "numpy.zeros_like", "sl.orth.T.dot", "numpy.minimum", "numpy.ones_like"], "function", ["None"], ["", "def", "principal_angles", "(", "A", ",", "B", ")", ":", "\n", "    ", "\"\"\"Compute the principal angles between subspaces A and B.\n\n    The algorithm for computing the principal angles is described in :\n    A. V. Knyazev and M. E. Argentati,\n    Principal Angles between Subspaces in an A-Based Scalar Product:\n    Algorithms and Perturbation Estimates. SIAM Journal on Scientific Computing,\n    23 (2002), no. 6, 2009-2041.\n    http://epubs.siam.org/sam-bin/dbq/article/37733\n    \"\"\"", "\n", "# eps = np.finfo(np.float64).eps**.981", "\n", "# for i in range(A.shape[1]):", "\n", "#     normi = la.norm(A[:,i],np.inf)", "\n", "#     if normi > eps: A[:,i] = A[:,i]/normi", "\n", "# for i in range(B.shape[1]):", "\n", "#     normi = la.norm(B[:,i],np.inf)", "\n", "#     if normi > eps: B[:,i] = B[:,i]/normi", "\n", "QA", "=", "sl", ".", "orth", "(", "A", ")", "\n", "QB", "=", "sl", ".", "orth", "(", "B", ")", "\n", "_", ",", "s", ",", "Zs", "=", "svd", "(", "QA", ".", "T", ".", "dot", "(", "QB", ")", ",", "full_matrices", "=", "False", ")", "\n", "s", "=", "np", ".", "minimum", "(", "s", ",", "ones_like", "(", "s", ")", ")", "\n", "theta", "=", "np", ".", "maximum", "(", "np", ".", "arccos", "(", "s", ")", ",", "np", ".", "zeros_like", "(", "s", ")", ")", "\n", "V", "=", "QB", ".", "dot", "(", "Zs", ")", "\n", "idxSmall", "=", "s", ">", "np", ".", "sqrt", "(", "2.0", ")", "/", "2.0", "\n", "if", "np", ".", "any", "(", "idxSmall", ")", ":", "\n", "        ", "RB", "=", "V", "[", ":", ",", "idxSmall", "]", "\n", "_", ",", "x", ",", "_", "=", "svd", "(", "RB", "-", "QA", ".", "dot", "(", "QA", ".", "T", ".", "dot", "(", "RB", ")", ")", ",", "full_matrices", "=", "False", ")", "\n", "thetaSmall", "=", "np", ".", "flipud", "(", "\n", "np", ".", "maximum", "(", "arcsin", "(", "np", ".", "minimum", "(", "x", ",", "ones_like", "(", "x", ")", ")", ")", ",", "zeros_like", "(", "x", ")", ")", "\n", ")", "\n", "theta", "[", "idxSmall", "]", "=", "thetaSmall", "\n", "", "return", "theta", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.chordal_principal_angles": [[102, 110], ["numpy.sqrt", "numpy.sum", "numpy.sin", "dict_metrics.principal_angles"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.principal_angles"], ["", "def", "chordal_principal_angles", "(", "A", ",", "B", ")", ":", "\n", "    ", "\"\"\"\n    chordal_principal_angles(A, B) Compute the chordal distance based on\n    principal angles.\n    Compute the chordal distance based on principal angles between A and B\n    as :math:`d=\\sqrt{ \\sum_i \\sin^2 \\theta_i}`\n    \"\"\"", "\n", "return", "sqrt", "(", "np", ".", "sum", "(", "np", ".", "sin", "(", "principal_angles", "(", "A", ",", "B", ")", ")", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.chordal": [[112, 134], ["numpy.allclose", "ValueError", "numpy.sqrt", "numpy.sqrt", "numpy.linalg.norm", "numpy.abs", "scipy.orth().T.dot", "scipy.orth", "scipy.orth"], "function", ["None"], ["", "def", "chordal", "(", "A", ",", "B", ")", ":", "\n", "    ", "\"\"\"\n    chordal(A, B) Compute the chordal distance\n    Compute the chordal distance between A and B\n    as d=\\sqrt{K - ||\\bar{A}^T\\bar{B}||_F^2}\n    where K is the rank of A and B, || . ||_F is the Frobenius norm,\n    \\bar{A} is the orthogonal basis associated with A and the same goes for B.\n    \"\"\"", "\n", "if", "A", ".", "shape", "!=", "B", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Atoms have not the same dimension ({A.shape} and {B.shape}). Error raised\"", "\n", "f\"in chordal(A, B)\"", ",", "\n", ")", "\n", "\n", "", "if", "np", ".", "allclose", "(", "A", ",", "B", ")", ":", "\n", "        ", "return", "0.0", "\n", "", "else", ":", "\n", "        ", "d2", "=", "A", ".", "shape", "[", "1", "]", "-", "norm", "(", "sl", ".", "orth", "(", "A", ")", ".", "T", ".", "dot", "(", "sl", ".", "orth", "(", "B", ")", ")", ",", "\"fro\"", ")", "**", "2", "\n", "if", "d2", "<", "0.0", ":", "\n", "            ", "return", "sqrt", "(", "abs", "(", "d2", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "sqrt", "(", "d2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.fubini_study": [[136, 150], ["numpy.allclose", "numpy.arccos", "ValueError", "numpy.linalg.det", "scipy.orth().T.dot", "scipy.orth", "scipy.orth"], "function", ["None"], ["", "", "", "def", "fubini_study", "(", "A", ",", "B", ")", ":", "\n", "    ", "\"\"\"\n    fubini_study(A, B) Compute the Fubini-Study distance\n    Compute the Fubini-Study distance based on principal angles between A and B\n    as d=\\acos{ \\prod_i \\theta_i}\n    \"\"\"", "\n", "if", "A", ".", "shape", "!=", "B", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Atoms have different dim ({A.shape} and {B.shape}). Error raised in\"", "\n", "f\"fubini_study(A, B)\"", ",", "\n", ")", "\n", "", "if", "np", ".", "allclose", "(", "A", ",", "B", ")", ":", "\n", "        ", "return", "0.0", "\n", "", "return", "arccos", "(", "det", "(", "sl", ".", "orth", "(", "A", ")", ".", "T", ".", "dot", "(", "sl", ".", "orth", "(", "B", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.binet_cauchy": [[152, 159], ["dict_metrics.principal_angles", "numpy.sqrt", "numpy.prod", "numpy.cos"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.principal_angles"], ["", "def", "binet_cauchy", "(", "A", ",", "B", ")", ":", "\n", "    ", "\"\"\"Compute the Binet-Cauchy distance\n    Compute the Binet-Cauchy distance based on principal angles between A\n    and B with d=\\sqrt{ 1 - \\prod_i \\cos^2 \\theta_i}\n    \"\"\"", "\n", "theta", "=", "principal_angles", "(", "A", ",", "B", ")", "\n", "return", "sqrt", "(", "1.0", "-", "np", ".", "prod", "(", "np", ".", "cos", "(", "theta", ")", "**", "2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.geodesic": [[161, 169], ["dict_metrics.principal_angles", "numpy.linalg.norm"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.principal_angles"], ["", "def", "geodesic", "(", "A", ",", "B", ")", ":", "\n", "    ", "\"\"\"\n    geodesic (A, B) Compute the arc length or geodesic distance\n    Compute the arc length or geodesic distance based on principal angles between A\n    and B with d=\\sqrt{ \\sum_i \\theta_i^2}\n    \"\"\"", "\n", "theta", "=", "principal_angles", "(", "A", ",", "B", ")", "\n", "return", "norm", "(", "theta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.frobenius": [[171, 178], ["numpy.linalg.norm", "ValueError"], "function", ["None"], ["", "def", "frobenius", "(", "A", ",", "B", ")", ":", "\n", "    ", "if", "A", ".", "shape", "!=", "B", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Atoms have different dim ({A.shape} and {B.shape}). Error raised in\"", "\n", "f\"frobenius(A, B)\"", ",", "\n", ")", "\n", "", "return", "norm", "(", "A", "-", "B", ",", "\"fro\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.abs_euclidean": [[180, 190], ["numpy.allclose", "ValueError", "numpy.sqrt", "numpy.abs", "A.T.dot"], "function", ["None"], ["", "def", "abs_euclidean", "(", "A", ",", "B", ")", ":", "\n", "    ", "if", "(", "A", ".", "ndim", "!=", "1", "and", "A", ".", "shape", "[", "1", "]", "!=", "1", ")", "or", "(", "B", ".", "ndim", "!=", "1", "and", "B", ".", "shape", "[", "1", "]", "!=", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Atoms are not univariate ({A.shape} and {B.shape}). Error raised\"", "\n", "f\"in abs_euclidean(A, B)\"", ",", "\n", ")", "\n", "", "if", "np", ".", "allclose", "(", "A", ",", "B", ")", ":", "\n", "        ", "return", "0.0", "\n", "", "else", ":", "\n", "        ", "return", "sqrt", "(", "2.0", "*", "(", "1.0", "-", "np", ".", "abs", "(", "A", ".", "T", ".", "dot", "(", "B", ")", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.euclidean": [[192, 202], ["numpy.allclose", "ValueError", "numpy.sqrt", "A.T.dot"], "function", ["None"], ["", "", "def", "euclidean", "(", "A", ",", "B", ")", ":", "\n", "    ", "if", "(", "A", ".", "ndim", "!=", "1", "and", "A", ".", "shape", "[", "1", "]", "!=", "1", ")", "or", "(", "B", ".", "ndim", "!=", "1", "and", "B", ".", "shape", "[", "1", "]", "!=", "1", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Atoms are not univariate ({A.shape} and {B.shape}). Error raised in\"", "\n", "f\"euclidean(A, B)\"", ",", "\n", ")", "\n", "", "if", "np", ".", "allclose", "(", "A", ",", "B", ")", ":", "\n", "        ", "return", "0.0", "\n", "", "else", ":", "\n", "        ", "return", "sqrt", "(", "2.0", "*", "(", "1.0", "-", "A", ".", "T", ".", "dot", "(", "B", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._valid_atom_metric": [[204, 224], ["None"], "function", ["None"], ["", "", "def", "_valid_atom_metric", "(", "gdist", ")", ":", "\n", "    ", "\"\"\"Verify that atom metric exist and return the correct function\"\"\"", "\n", "if", "gdist", "==", "\"chordal\"", ":", "\n", "        ", "return", "chordal", "\n", "", "elif", "gdist", "==", "\"chordal_principal_angles\"", ":", "\n", "        ", "return", "chordal_principal_angles", "\n", "", "elif", "gdist", "==", "\"fubinistudy\"", ":", "\n", "        ", "return", "fubini_study", "\n", "", "elif", "gdist", "==", "\"binetcauchy\"", ":", "\n", "        ", "return", "binet_cauchy", "\n", "", "elif", "gdist", "==", "\"geodesic\"", ":", "\n", "        ", "return", "geodesic", "\n", "", "elif", "gdist", "==", "\"frobenius\"", ":", "\n", "        ", "return", "frobenius", "\n", "", "elif", "gdist", "==", "\"abs_euclidean\"", ":", "\n", "        ", "return", "abs_euclidean", "\n", "", "elif", "gdist", "==", "\"euclidean\"", ":", "\n", "        ", "return", "euclidean", "\n", "", "else", ":", "\n", "        ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._scale_metric": [[226, 240], ["numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "", "def", "_scale_metric", "(", "gdist", ",", "d", ",", "D1", ")", ":", "\n", "    ", "if", "(", "\n", "gdist", "==", "\"chordal\"", "\n", "or", "gdist", "==", "\"chordal_principal_angles\"", "\n", "or", "gdist", "==", "\"fubinistudy\"", "\n", "or", "gdist", "==", "\"binetcauchy\"", "\n", "or", "gdist", "==", "\"geodesic\"", "\n", ")", ":", "\n", "# TODO: scale with max n_features", "\n", "        ", "return", "d", "/", "sqrt", "(", "D1", "[", "0", "]", ".", "shape", "[", "0", "]", ")", "\n", "", "elif", "gdist", "==", "\"frobenius\"", ":", "\n", "        ", "return", "d", "/", "sqrt", "(", "2.0", ")", "\n", "", "else", ":", "\n", "        ", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._compute_gdm": [[242, 285], ["numpy.all", "numpy.array().max", "numpy.array().max", "range", "numpy.zeros", "range", "numpy.zeros", "range", "len", "Dbe.append", "len", "dict_metrics._kernel_registration", "range", "len", "range", "numpy.array", "numpy.array", "numpy.array", "numpy.concatenate", "len", "len", "len", "len", "len", "len", "g", "numpy.zeros", "numpy.unravel_index", "numpy.abs().argmax", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._kernel_registration"], ["", "", "def", "_compute_gdm", "(", "D1", ",", "D2", ",", "g", ")", ":", "\n", "    ", "\"\"\"Compute ground distance matrix from dictionaries D1 and D2\n\n    Distance g acts as ground distance.\n    A kernel registration is applied if dictionary atoms do not have\n    the same size.\n    \"\"\"", "\n", "# Do we need a registration? If kernel do not have the same shape, yes", "\n", "if", "not", "all", "(", "array", "(", "[", "i", ".", "shape", "[", "0", "]", "for", "i", "in", "D1", "+", "D2", "]", ")", "==", "D1", "[", "0", "]", ".", "shape", "[", "0", "]", ")", ":", "\n", "# compute correlation and distance matrices", "\n", "        ", "k_dim", "=", "D1", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "# minl = np.array([i.shape[1] for i in D1+D2]).min()", "\n", "max_l1", "=", "array", "(", "[", "i", ".", "shape", "[", "0", "]", "for", "i", "in", "D1", "]", ")", ".", "max", "(", ")", "\n", "max_l2", "=", "array", "(", "[", "i", ".", "shape", "[", "0", "]", "for", "i", "in", "D2", "]", ")", ".", "max", "(", ")", "\n", "if", "max_l2", ">", "max_l1", ":", "\n", "            ", "Da", "=", "D1", "\n", "Db", "=", "D2", "\n", "max_l", "=", "max_l2", "\n", "", "else", ":", "\n", "            ", "Da", "=", "D2", "\n", "Db", "=", "D1", "\n", "max_l", "=", "max_l1", "\n", "# Set all Db atom to largest value", "\n", "", "Dbe", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "Db", ")", ")", ":", "\n", "            ", "k_l", "=", "Db", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "Dbe", ".", "append", "(", "concatenate", "(", "(", "zeros", "(", "(", "max_l", "-", "k_l", ",", "k_dim", ")", ")", ",", "Db", "[", "i", "]", ")", ",", "axis", "=", "0", ")", ")", "\n", "", "gdm", "=", "zeros", "(", "(", "len", "(", "Da", ")", ",", "len", "(", "Db", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "Da", ")", ")", ":", "\n", "            ", "m_dist", ",", "m_corr", "=", "_kernel_registration", "(", "Da", "[", "i", "]", ",", "Dbe", ",", "g", ")", "\n", "k_l", "=", "Da", "[", "i", "]", ".", "shape", "[", "0", "]", "\n", "# m_dist, m_corr = _kernel_registration(np.concatenate((zeros((np.int(np.floor((max_l-k_l)/2.)), k_dim)), Da[i], zeros((np.int(np.ceil((max_l-k_l)/2.)), k_dim))), axis=0), Dbe, g)", "\n", "for", "j", "in", "range", "(", "len", "(", "Dbe", ")", ")", ":", "\n", "                ", "gdm", "[", "i", ",", "j", "]", "=", "m_dist", "[", "\n", "j", ",", "unravel_index", "(", "abs", "(", "m_corr", "[", "j", ",", ":", "]", ")", ".", "argmax", "(", ")", ",", "m_corr", "[", "j", ",", ":", "]", ".", "shape", ")", "\n", "]", "\n", "", "", "", "else", ":", "\n", "# all atoms have the same length, no registration", "\n", "        ", "gdm", "=", "zeros", "(", "(", "len", "(", "D1", ")", ",", "len", "(", "D2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "D1", ")", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "len", "(", "D2", ")", ")", ":", "\n", "                ", "gdm", "[", "i", ",", "j", "]", "=", "g", "(", "D1", "[", "i", "]", ",", "D2", "[", "j", "]", ")", "\n", "", "", "", "return", "gdm", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.hausdorff": [[287, 305], ["dict_metrics._valid_atom_metric", "dict_metrics._compute_gdm", "numpy.max", "print", "dict_metrics._scale_metric", "numpy.max", "numpy.max", "numpy.min", "numpy.min"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._valid_atom_metric", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._compute_gdm", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._scale_metric"], ["", "def", "hausdorff", "(", "D1", ",", "D2", ",", "gdist", ",", "scale", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Compute the Hausdorff distance between two sets of elements, here\n    dictionary atoms, using a ground distance.\n    Possible choice are \"chordal\", \"fubinistudy\", \"binetcauchy\", \"geodesic\",\n    \"frobenius\", \"abs_euclidean\" or \"euclidean\".\n    The scale parameter changes the return value to be between 0 and 1.\n    \"\"\"", "\n", "g", "=", "_valid_atom_metric", "(", "gdist", ")", "\n", "if", "g", "is", "None", ":", "\n", "        ", "print", "(", "\"Unknown ground distance, exiting.\"", ")", "\n", "return", "NaN", "\n", "", "gdm", "=", "_compute_gdm", "(", "D1", ",", "D2", ",", "g", ")", "\n", "d", "=", "max", "(", "[", "max", "(", "min", "(", "gdm", ",", "axis", "=", "0", ")", ")", ",", "max", "(", "min", "(", "gdm", ",", "axis", "=", "1", ")", ")", "]", ")", "\n", "if", "not", "scale", ":", "\n", "        ", "return", "d", "\n", "", "else", ":", "\n", "        ", "return", "_scale_metric", "(", "gdist", ",", "d", ",", "D1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.emd": [[307, 397], ["dict_metrics._valid_atom_metric", "dict_metrics._compute_gdm", "cvxopt.matrix", "cvxopt.spmatrix", "cvxopt.spmatrix", "cvxopt.spmatrix", "range", "cvxopt.sparse", "cvxopt.matrix", "cvxopt.matrix", "cvxopt.spmatrix", "cvxopt.matrix", "cvxopt.matrix", "cvxopt.matrix", "cvxopt.lp", "print", "_compute_gdm.flatten", "range", "range", "len", "range", "dict_metrics._scale_metric", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._valid_atom_metric", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._compute_gdm", "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._scale_metric"], ["", "", "def", "emd", "(", "D1", ",", "D2", ",", "gdist", ",", "scale", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Compute the Earth Mover's Distance (EMD) between two sets of elements,\n    here dictionary atoms, using a ground distance.\n    Possible choice are \"chordal\", \"fubinistudy\", \"binetcauchy\", \"geodesic\",\n    \"frobenius\", \"abs_euclidean\" or \"euclidean\".\n    The scale parameter changes the return value to be between 0 and 1.\n    \"\"\"", "\n", "g", "=", "_valid_atom_metric", "(", "gdist", ")", "\n", "if", "g", "is", "None", ":", "\n", "        ", "print", "(", "\"Unknown ground distance, exiting.\"", ")", "\n", "return", "NaN", "\n", "# if gdist == \"chordal\":", "\n", "#     g = chordal", "\n", "# elif gdist == \"chordal_principal_angles\":", "\n", "#     g = chordal_principal_angles", "\n", "# elif gdist == \"fubinistudy\":", "\n", "#     g = fubini_study", "\n", "# elif gdist == \"binetcauchy\":", "\n", "#     g = binet_cauchy", "\n", "# elif gdist == \"geodesic\":", "\n", "#     g = geodesic", "\n", "# elif gdist == \"frobenius\":", "\n", "#     g = frobenius", "\n", "# elif gdist == \"abs_euclidean\":", "\n", "#     g = abs_euclidean", "\n", "# elif gdist == \"euclidean\":", "\n", "#     g = euclidean", "\n", "# else:", "\n", "#     print 'Unknown ground distance, exiting.'", "\n", "#     return NaN", "\n", "\n", "# # Do we need a registration? If kernel do not have the same shape, yes", "\n", "# if not np.all(np.array([i.shape[0] for i in D1+D2]) == D1[0].shape[0]):", "\n", "#     # compute correlation and distance matrices", "\n", "#     k_dim = D1[0].shape[1]", "\n", "#     # minl = np.array([i.shape[1] for i in D1+D2]).min()", "\n", "#     max_l1 = np.array([i.shape[0] for i in D1]).max()", "\n", "#     max_l2 = np.array([i.shape[0] for i in D2]).max()", "\n", "#     if max_l2 > max_l1:", "\n", "#         Da = D1", "\n", "#         Db = D2", "\n", "#         max_l = max_l2", "\n", "#     else:", "\n", "#         Da = D2", "\n", "#         Db = D1", "\n", "#         max_l = max_l1", "\n", "#     Dbe = []", "\n", "#     for i in range(len(Db)):", "\n", "#         k_l = Db[i].shape[0]", "\n", "#         Dbe.append(np.concatenate((zeros((max_l-k_l, k_dim)), Db[i]), axis=0))", "\n", "#     gdm = zeros((len(Da), len(Db)))", "\n", "#     for i in range(len(Da)):", "\n", "#         k_l = Da[i].shape[0]", "\n", "#         m_dist, m_corr = _kernel_registration(np.concatenate((zeros(( np.int(np.floor((max_l-k_l)/2.)), k_dim)), Da[i], zeros((np.int(np.ceil((max_l-k_l)/2.)), k_dim))), axis=0), Dbe, g)", "\n", "#         for j in range(len(Dbe)):", "\n", "#             gdm[i,j] = m_dist[j, np.unravel_index(np.abs(m_corr[j,:]).argmax(), m_corr[j,:].shape)]", "\n", "# else:", "\n", "#     # all atoms have the same length, no registration", "\n", "#     gdm = np.zeros((len(D1), len(D2)))", "\n", "#     for i in range(len(D1)):", "\n", "#         for j in range(len(D2)):", "\n", "#             gdm[i,j] = g(D1[i], D2[j])", "\n", "", "gdm", "=", "_compute_gdm", "(", "D1", ",", "D2", ",", "g", ")", "\n", "\n", "c", "=", "co", ".", "matrix", "(", "gdm", ".", "flatten", "(", "order", "=", "\"F\"", ")", ")", "\n", "G1", "=", "co", ".", "spmatrix", "(", "[", "]", ",", "[", "]", ",", "[", "]", ",", "(", "len", "(", "D1", ")", ",", "len", "(", "D1", ")", "*", "len", "(", "D2", ")", ")", ")", "\n", "G2", "=", "co", ".", "spmatrix", "(", "[", "]", ",", "[", "]", ",", "[", "]", ",", "(", "len", "(", "D2", ")", ",", "len", "(", "D1", ")", "*", "len", "(", "D2", ")", ")", ")", "\n", "G3", "=", "co", ".", "spmatrix", "(", "-", "1.0", ",", "range", "(", "len", "(", "D1", ")", "*", "len", "(", "D2", ")", ")", ",", "range", "(", "len", "(", "D1", ")", "*", "len", "(", "D2", ")", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "D1", ")", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "D2", ")", ")", ":", "\n", "            ", "k", "=", "j", "+", "(", "i", "*", "len", "(", "D2", ")", ")", "\n", "G1", "[", "i", ",", "k", "]", "=", "1.0", "\n", "G2", "[", "j", ",", "k", "]", "=", "1.0", "\n", "", "", "G", "=", "co", ".", "sparse", "(", "[", "G1", ",", "G2", ",", "G3", "]", ")", "\n", "h1", "=", "co", ".", "matrix", "(", "1.0", "/", "len", "(", "D1", ")", ",", "(", "len", "(", "D1", ")", ",", "1", ")", ")", "\n", "h2", "=", "co", ".", "matrix", "(", "1.0", "/", "len", "(", "D2", ")", ",", "(", "len", "(", "D2", ")", ",", "1", ")", ")", "\n", "h3", "=", "co", ".", "spmatrix", "(", "[", "]", ",", "[", "]", ",", "[", "]", ",", "(", "len", "(", "D1", ")", "*", "len", "(", "D2", ")", ",", "1", ")", ")", "\n", "h", "=", "co", ".", "matrix", "(", "[", "h1", ",", "h2", ",", "h3", "]", ")", "\n", "A", "=", "co", ".", "matrix", "(", "1.0", ",", "(", "1", ",", "len", "(", "D1", ")", "*", "len", "(", "D2", ")", ")", ")", "\n", "b", "=", "co", ".", "matrix", "(", "[", "1.0", "]", ")", "\n", "\n", "co", ".", "solvers", ".", "options", "[", "\"show_progress\"", "]", "=", "False", "\n", "sol", "=", "solv", ".", "lp", "(", "c", ",", "G", ",", "h", ",", "A", ",", "b", ")", "\n", "d", "=", "sol", "[", "\"primal objective\"", "]", "\n", "\n", "if", "not", "scale", ":", "\n", "        ", "return", "d", "\n", "", "else", ":", "\n", "        ", "return", "_scale_metric", "(", "gdist", ",", "d", ",", "D1", ")", "\n", "# if (gdist == \"chordal\" or gdist == \"chordal_principal_angles\" or", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._multivariate_correlation": [[407, 423], ["len", "numpy.zeros", "range", "range", "numpy.correlate", "len"], "function", ["None"], ["", "", "def", "_multivariate_correlation", "(", "s", ",", "D", ")", ":", "\n", "    ", "\"\"\"Compute correlation between multivariate atoms\n\n    Compute the correlation between a multivariate atome s and dictionary D\n    as the sum of the correlation in each n_dims dimensions.\n    \"\"\"", "\n", "n_features", "=", "s", ".", "shape", "[", "0", "]", "\n", "n_dims", "=", "s", ".", "shape", "[", "1", "]", "\n", "n_kernels", "=", "len", "(", "D", ")", "\n", "corr", "=", "np", ".", "zeros", "(", "(", "n_kernels", ",", "n_features", ")", ")", "\n", "for", "k", "in", "range", "(", "n_kernels", ")", ":", "# for all atoms", "\n", "        ", "corrTmp", "=", "0", "\n", "for", "j", "in", "range", "(", "n_dims", ")", ":", "# for all dimensions", "\n", "            ", "corrTmp", "+=", "np", ".", "correlate", "(", "s", "[", ":", ",", "j", "]", ",", "D", "[", "k", "]", "[", ":", ",", "j", "]", ")", "\n", "", "corr", "[", "k", ",", ":", "len", "(", "corrTmp", ")", "]", "=", "corrTmp", "\n", "", "return", "corr", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.detection_rate": [[425, 469], ["numpy.zeros", "range", "numpy.abs", "range", "len", "len", "range", "range", "dict_metrics._multivariate_correlation", "range", "numpy.zeros.copy", "np.abs.max", "numpy.unravel_index", "numpy.zeros", "numpy.zeros", "numpy.concatenate", "numpy.argmax", "np.abs.argmax", "float", "numpy.atleast_2d", "numpy.atleast_2d", "numpy.abs", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._multivariate_correlation"], ["", "def", "detection_rate", "(", "ref", ",", "recov", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"Compute the detection rate between reference and recovered dictionaries\n\n    The reference ref and the recovered recov are univariate or multivariate\n    dictionaries. An atom a of the ref dictionary is considered as recovered if\n    $c < threshold$ with $c = argmax_{r \\in R} |<a, r>|$, that is the absolute\n    value of the maximum correlation between a and any atom r of the recovered\n    dictionary R is above a given threshold.\n    The process is iterative and an atom r could be matched only once with an\n    atom a of the reference dictionary. In other word, each atom a is matched\n    with a different atom r.\n    \"\"\"", "\n", "n_kernels_ref", ",", "n_kernels_recov", "=", "len", "(", "ref", ")", ",", "len", "(", "recov", ")", "\n", "n_features", "=", "ref", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "if", "ref", "[", "0", "]", ".", "ndim", "==", "1", ":", "\n", "        ", "n_dims", "=", "1", "\n", "for", "k", "in", "range", "(", "n_kernels_ref", ")", ":", "\n", "            ", "ref", "[", "k", "]", "=", "atleast_2d", "(", "ref", "[", "k", "]", ")", ".", "T", "\n", "", "", "else", ":", "\n", "        ", "n_dims", "=", "ref", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "", "if", "recov", "[", "0", "]", ".", "ndim", "==", "1", ":", "\n", "        ", "for", "k", "in", "range", "(", "n_kernels_recov", ")", ":", "\n", "            ", "recov", "[", "k", "]", "=", "atleast_2d", "(", "recov", "[", "k", "]", ")", ".", "T", "\n", "", "", "dr", "=", "0", "\n", "corr", "=", "zeros", "(", "(", "n_kernels_ref", ",", "n_kernels_recov", ")", ")", "\n", "for", "k", "in", "range", "(", "n_kernels_ref", ")", ":", "\n", "        ", "c_tmp", "=", "_multivariate_correlation", "(", "\n", "concatenate", "(", "\n", "(", "zeros", "(", "(", "n_features", ",", "n_dims", ")", ")", ",", "ref", "[", "k", "]", ",", "zeros", "(", "(", "n_features", ",", "n_dims", ")", ")", ")", ",", "axis", "=", "0", "\n", ")", ",", "\n", "recov", ",", "\n", ")", "\n", "for", "j", "in", "range", "(", "n_kernels_recov", ")", ":", "\n", "            ", "idx_max", "=", "argmax", "(", "abs", "(", "c_tmp", "[", "j", ",", ":", "]", ")", ")", "\n", "corr", "[", "k", ",", "j", "]", "=", "c_tmp", "[", "j", ",", "idx_max", "]", "\n", "", "", "c_local", "=", "np", ".", "abs", "(", "corr", ".", "copy", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "n_kernels_ref", ")", ":", "\n", "        ", "max_corr", "=", "c_local", ".", "max", "(", ")", "\n", "if", "max_corr", ">=", "threshold", ":", "\n", "            ", "dr", "+=", "1", "\n", "", "idx_max", "=", "np", ".", "unravel_index", "(", "c_local", ".", "argmax", "(", ")", ",", "c_local", ".", "shape", ")", "\n", "c_local", "[", ":", ",", "idx_max", "[", "1", "]", "]", "=", "zeros", "(", "n_kernels_ref", ")", "\n", "c_local", "[", "idx_max", "[", "0", "]", ",", ":", "]", "=", "zeros", "(", "n_kernels_recov", ")", "\n", "", "return", "float", "(", "dr", ")", "/", "n_kernels_recov", "*", "100.0", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._convert_array": [[471, 485], ["numpy.array", "numpy.array", "D1.reshape.reshape", "D2.reshape.reshape", "range", "range", "len", "len", "numpy.atleast_2d", "numpy.atleast_2d"], "function", ["None"], ["", "def", "_convert_array", "(", "ref", ",", "recov", ")", ":", "\n", "    ", "if", "ref", "[", "0", "]", ".", "ndim", "==", "1", ":", "\n", "        ", "for", "k", "in", "range", "(", "len", "(", "ref", ")", ")", ":", "\n", "            ", "ref", "[", "k", "]", "=", "atleast_2d", "(", "ref", "[", "k", "]", ")", ".", "T", "\n", "", "", "if", "recov", "[", "0", "]", ".", "ndim", "==", "1", ":", "\n", "        ", "for", "k", "in", "range", "(", "len", "(", "recov", ")", ")", ":", "\n", "            ", "recov", "[", "k", "]", "=", "atleast_2d", "(", "recov", "[", "k", "]", ")", ".", "T", "\n", "", "", "D1", "=", "np", ".", "array", "(", "ref", ")", "\n", "D2", "=", "np", ".", "array", "(", "recov", ")", "\n", "M", "=", "D1", ".", "shape", "[", "0", "]", "\n", "N", "=", "D1", ".", "shape", "[", "1", "]", "\n", "D1", "=", "D1", ".", "reshape", "(", "(", "M", ",", "N", ")", ")", "\n", "D2", "=", "D2", ".", "reshape", "(", "(", "M", ",", "N", ")", ")", "\n", "return", "D1", ",", "D2", ",", "M", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.precision_recall": [[487, 494], ["dict_metrics._convert_array", "D1.dot", "float", "float", "float", "float", "numpy.max", "numpy.max"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._convert_array"], ["", "def", "precision_recall", "(", "ref", ",", "recov", ",", "threshold", ")", ":", "\n", "    ", "\"\"\"Compute precision and recall for recovery experiment\"\"\"", "\n", "D1", ",", "D2", ",", "M", "=", "_convert_array", "(", "ref", ",", "recov", ")", "\n", "corr", "=", "D1", ".", "dot", "(", "D2", ".", "T", ")", "\n", "precision", "=", "float", "(", "(", "np", ".", "max", "(", "corr", ",", "axis", "=", "0", ")", ">", "threshold", ")", ".", "sum", "(", ")", ")", "/", "float", "(", "M", ")", "\n", "recall", "=", "float", "(", "(", "np", ".", "max", "(", "corr", ",", "axis", "=", "1", ")", ">", "threshold", ")", ".", "sum", "(", ")", ")", "/", "float", "(", "M", ")", "\n", "return", "precision", "*", "100.0", ",", "recall", "*", "100.0", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.precision_recall_points": [[496, 515], ["dict_metrics._convert_array", "D1.dot", "numpy.max", "numpy.max"], "function", ["home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics._convert_array"], ["", "def", "precision_recall_points", "(", "ref", ",", "recov", ")", ":", "\n", "    ", "\"\"\"Compute the precision and recall for each atom in a recovery experiment\"\"\"", "\n", "# if ref[0].ndim == 1:", "\n", "#     for k in range(len(ref)):", "\n", "#         ref[k] = atleast_2d(ref[k]).T", "\n", "# if recov[0].ndim == 1:", "\n", "#     for k in range(len(recov)):", "\n", "#         recov[k] = atleast_2d(recov[k]).T", "\n", "# D1 = np.array(ref)", "\n", "# D2 = np.array(recov)", "\n", "# M = D1.shape[0]", "\n", "# N = D1.shape[1]", "\n", "# D1 = D1.reshape((M, N))", "\n", "# D2 = D2.reshape((M, N))", "\n", "D1", ",", "D2", ",", "_", "=", "_convert_array", "(", "ref", ",", "recov", ")", "\n", "corr", "=", "D1", ".", "dot", "(", "D2", ".", "T", ")", "\n", "precision", "=", "np", ".", "max", "(", "corr", ",", "axis", "=", "0", ")", "\n", "recall", "=", "np", ".", "max", "(", "corr", ",", "axis", "=", "1", ")", "\n", "return", "precision", ",", "recall", "\n", "\n"]], "home.repos.pwc.inspect_result.sylvchev_mdla.mdla.dict_metrics.beta_dist": [[517, 547], ["numpy.array", "D1.reshape.reshape", "numpy.array", "D2.reshape.reshape", "D1.reshape.dot", "ValueError", "numpy.allclose", "numpy.allclose", "numpy.max", "numpy.ones", "numpy.max", "numpy.ones", "numpy.sum", "numpy.sum", "numpy.arccos", "numpy.arccos", "numpy.max", "numpy.max"], "function", ["None"], ["", "def", "beta_dist", "(", "D1", ",", "D2", ")", ":", "\n", "    ", "\"\"\"Compute the Beta-distance proposed by Skretting and Engan\n\n    The beta-distance is:\n    $\\beta(D1, D2)=1/(M1+M2)(\\sum_j \\beta(D1, d^2_j)+\\sum_j \\beta(D2, d^1_j))$\n    with $\\beta(D, x) = arccos(\\max_i |d^T_i x|/||x||)$\n    as proposed in:\n    Karl Skretting and Kjersti Engan,\n    Learned dictionaries for sparse image representation: properties and results,\n    SPIE, 2011.\n    \"\"\"", "\n", "if", "D1", "[", "0", "]", ".", "shape", "!=", "D2", "[", "0", "]", ".", "shape", ":", "\n", "        ", "raise", "ValueError", "(", "\n", "f\"Dictionaries have different dim : {D1[0].shape} and {D2[0].shape}.\"", "\n", ")", "\n", "", "D1", "=", "np", ".", "array", "(", "D1", ")", "\n", "M1", "=", "D1", ".", "shape", "[", "0", "]", "\n", "N", "=", "D1", ".", "shape", "[", "1", "]", "\n", "D1", "=", "D1", ".", "reshape", "(", "(", "M1", ",", "N", ")", ")", "\n", "D2", "=", "np", ".", "array", "(", "D2", ")", "\n", "M2", "=", "D2", ".", "shape", "[", "0", "]", "\n", "D2", "=", "D2", ".", "reshape", "(", "(", "M2", ",", "N", ")", ")", "\n", "corr", "=", "D1", ".", "dot", "(", "D2", ".", "T", ")", "\n", "if", "np", ".", "allclose", "(", "np", ".", "max", "(", "corr", ",", "axis", "=", "0", ")", ",", "ones", "(", "M2", ")", ")", "and", "np", ".", "allclose", "(", "\n", "np", ".", "max", "(", "corr", ",", "axis", "=", "1", ")", ",", "ones", "(", "M1", ")", "\n", ")", ":", "\n", "        ", "return", "0.0", "\n", "", "return", "(", "\n", "np", ".", "sum", "(", "np", ".", "arccos", "(", "np", ".", "max", "(", "corr", ",", "axis", "=", "0", ")", ")", ")", "+", "np", ".", "sum", "(", "np", ".", "arccos", "(", "np", ".", "max", "(", "corr", ",", "axis", "=", "1", ")", ")", ")", "\n", ")", "/", "(", "M1", "+", "M2", ")", "\n", "", ""]]}