{"home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.Continuum.__init__": [[37, 77], ["len", "range", "args.samples_per_task.split", "range", "range", "len", "torch.randperm().tolist", "[].size", "print", "sample_permutations.append", "range", "len", "min", "torch.randperm", "random.shuffle", "torch.randperm", "int", "min", "[].size", "int"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "data", ",", "args", ")", ":", "\n", "        ", "self", ".", "data", "=", "data", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "n_tasks", "=", "len", "(", "data", ")", "\n", "\n", "task_permutation", "=", "range", "(", "n_tasks", ")", "\n", "\n", "if", "args", ".", "shuffle_tasks", "==", "'yes'", ":", "\n", "            ", "task_permutation", "=", "torch", ".", "randperm", "(", "n_tasks", ")", ".", "tolist", "(", ")", "\n", "\n", "", "sample_permutations", "=", "[", "]", "\n", "\n", "samples_per_task", "=", "args", ".", "samples_per_task", ".", "split", "(", "\"-\"", ")", "\n", "n", "=", "1000", "\n", "for", "t", "in", "range", "(", "n_tasks", ")", ":", "\n", "            ", "N", "=", "data", "[", "t", "]", "[", "1", "]", ".", "size", "(", "0", ")", "\n", "if", "len", "(", "samples_per_task", ")", ">", "t", ":", "\n", "\n", "                ", "if", "int", "(", "samples_per_task", "[", "t", "]", ")", "<=", "0", ":", "\n", "                    ", "n", "=", "N", "\n", "", "else", ":", "\n", "                    ", "n", "=", "min", "(", "int", "(", "samples_per_task", "[", "t", "]", ")", ",", "N", ")", "\n", "", "", "else", ":", "\n", "                ", "n", "=", "min", "(", "n", ",", "N", ")", "\n", "", "print", "(", "\"*********Task\"", ",", "t", ",", "\"Samples are\"", ",", "n", ")", "\n", "p", "=", "torch", ".", "randperm", "(", "data", "[", "t", "]", "[", "1", "]", ".", "size", "(", "0", ")", ")", "[", "0", ":", "n", "]", "\n", "sample_permutations", ".", "append", "(", "p", ")", "\n", "\n", "", "self", ".", "permutation", "=", "[", "]", "\n", "\n", "for", "t", "in", "range", "(", "n_tasks", ")", ":", "\n", "            ", "task_t", "=", "task_permutation", "[", "t", "]", "\n", "\n", "for", "_", "in", "range", "(", "args", ".", "n_epochs", ")", ":", "\n", "                ", "task_p", "=", "[", "[", "task_t", ",", "i", "]", "for", "i", "in", "sample_permutations", "[", "task_t", "]", "]", "\n", "random", ".", "shuffle", "(", "task_p", ")", "\n", "self", ".", "permutation", "+=", "task_p", "\n", "\n", "", "", "self", ".", "length", "=", "len", "(", "self", ".", "permutation", ")", "\n", "self", ".", "current", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.Continuum.__iter__": [[78, 80], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.Continuum.next": [[81, 83], ["main.Continuum.__next__"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.Continuum.__next__"], ["", "def", "next", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "__next__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.Continuum.__next__": [[84, 99], ["torch.LongTensor", "torch.LongTensor.append"], "methods", ["None"], ["", "def", "__next__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "current", ">=", "self", ".", "length", ":", "\n", "            ", "raise", "StopIteration", "\n", "", "else", ":", "\n", "            ", "ti", "=", "self", ".", "permutation", "[", "self", ".", "current", "]", "[", "0", "]", "\n", "j", "=", "[", "]", "\n", "i", "=", "0", "\n", "while", "(", "(", "(", "self", ".", "current", "+", "i", ")", "<", "self", ".", "length", ")", "and", "\n", "(", "self", ".", "permutation", "[", "self", ".", "current", "+", "i", "]", "[", "0", "]", "==", "ti", ")", "and", "\n", "(", "i", "<", "self", ".", "batch_size", ")", ")", ":", "\n", "                ", "j", ".", "append", "(", "self", ".", "permutation", "[", "self", ".", "current", "+", "i", "]", "[", "1", "]", ")", "\n", "i", "+=", "1", "\n", "", "self", ".", "current", "+=", "i", "\n", "j", "=", "torch", ".", "LongTensor", "(", "j", ")", "\n", "return", "self", ".", "data", "[", "ti", "]", "[", "1", "]", "[", "j", "]", ",", "ti", ",", "self", ".", "data", "[", "ti", "]", "[", "2", "]", "[", "j", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.load_datasets": [[23, 33], ["print", "torch.load", "[].size", "range", "len", "max", "max", "len", "[].max().item", "[].max().item", "[].max", "[].max"], "function", ["None"], ["def", "load_datasets", "(", "args", ")", ":", "\n", "\n", "    ", "print", "(", "\"path\"", ",", "args", ".", "data_path", "+", "'/'", "+", "args", ".", "data_file", ")", "\n", "d_tr", ",", "d_te", "=", "torch", ".", "load", "(", "args", ".", "data_path", "+", "'/'", "+", "args", ".", "data_file", ")", "\n", "n_inputs", "=", "d_tr", "[", "0", "]", "[", "1", "]", ".", "size", "(", "1", ")", "\n", "n_outputs", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "d_tr", ")", ")", ":", "\n", "        ", "n_outputs", "=", "max", "(", "n_outputs", ",", "d_tr", "[", "i", "]", "[", "2", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "n_outputs", "=", "max", "(", "n_outputs", ",", "d_te", "[", "i", "]", "[", "2", "]", ".", "max", "(", ")", ".", "item", "(", ")", ")", "\n", "", "return", "d_tr", ",", "d_te", ",", "n_inputs", ",", "n_outputs", "+", "1", ",", "len", "(", "d_tr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.eval_tasks": [[105, 159], ["model.eval", "enumerate", "print", "print", "print", "torch.save", "x.size", "range", "result.append", "x.size", "x.size", "min", "torch.max", "model.state_dict", "x[].view", "torch.LongTensor().view", "xb.cuda.cuda", "model().data.cpu", "x.size", "x.size", "torch.LongTensor", "model"], "function", ["None"], ["", "", "", "def", "eval_tasks", "(", "model", ",", "tasks", ",", "current_task", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    it also evaluates the performance of the model on samples from all the tasks and gives the average performance on all the samples regardless of their task\n    :param model:\n    :param tasks:\n    :param args:\n    :return:\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "result", "=", "[", "]", "\n", "total_size", "=", "0", "\n", "total_pred", "=", "0", "\n", "current_result", "=", "[", "]", "\n", "current_avg_acc", "=", "0", "\n", "for", "i", ",", "task", "in", "enumerate", "(", "tasks", ")", ":", "\n", "\n", "        ", "t", "=", "i", "\n", "x", "=", "task", "[", "1", "]", "\n", "y", "=", "task", "[", "2", "]", "\n", "rt", "=", "0", "\n", "\n", "eval_bs", "=", "x", ".", "size", "(", "0", ")", "\n", "\n", "for", "b_from", "in", "range", "(", "0", ",", "x", ".", "size", "(", "0", ")", ",", "eval_bs", ")", ":", "\n", "            ", "b_to", "=", "min", "(", "b_from", "+", "eval_bs", ",", "x", ".", "size", "(", "0", ")", "-", "1", ")", "\n", "if", "b_from", "==", "b_to", ":", "\n", "                ", "xb", "=", "x", "[", "b_from", "]", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "yb", "=", "torch", ".", "LongTensor", "(", "[", "y", "[", "b_to", "]", "]", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "xb", "=", "x", "[", "b_from", ":", "b_to", "]", "\n", "yb", "=", "y", "[", "b_from", ":", "b_to", "]", "\n", "", "if", "args", ".", "cuda", ":", "\n", "                ", "xb", "=", "xb", ".", "cuda", "(", ")", "\n", "", "_", ",", "pb", "=", "torch", ".", "max", "(", "model", "(", "xb", ",", "t", ")", ".", "data", ".", "cpu", "(", ")", ",", "1", ",", "keepdim", "=", "False", ")", "\n", "rt", "+=", "(", "pb", "==", "yb", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "\n", "\n", "", "result", ".", "append", "(", "rt", "/", "x", ".", "size", "(", "0", ")", ")", "\n", "\n", "total_size", "+=", "x", ".", "size", "(", "0", ")", "\n", "total_pred", "+=", "rt", "\n", "\n", "if", "t", "==", "current_task", ":", "\n", "            ", "current_result", "=", "[", "res", "for", "res", "in", "result", "]", "\n", "current_avg_acc", "=", "total_pred", "/", "total_size", "\n", "\n", "\n", "", "", "print", "(", "\"###################### EVAL BEGIN ##########################\"", ")", "\n", "print", "(", "result", ")", "\n", "\n", "print", "(", "\"###################### EVAL ENDS ##########################\"", ")", "\n", "torch", ".", "save", "(", "(", "model", ".", "state_dict", "(", ")", ",", "current_result", ",", "current_avg_acc", ")", ",", "model", ".", "fname", "+", "'.pt'", ")", "\n", "\n", "return", "result", ",", "total_pred", "/", "total_size", ",", "current_avg_acc", ",", "current_avg_acc", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.eval_on_memory": [[160, 177], ["model.eval", "zip", "torch.max", "model.sampled_memory_data.size", "x.cuda.cuda", "model().data.cpu", "y.data.cpu", "model", "x.cuda.unsqueeze"], "function", ["None"], ["", "def", "eval_on_memory", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    compute accuracy on the buffer\n    :return:\n    \"\"\"", "\n", "model", ".", "eval", "(", ")", "\n", "acc_on_mem", "=", "0", "\n", "if", "'yes'", "in", "args", ".", "eval_memory", ":", "\n", "        ", "for", "x", ",", "y", "in", "zip", "(", "model", ".", "sampled_memory_data", ",", "model", ".", "sampled_memory_labs", ")", ":", "\n", "            ", "if", "args", ".", "cuda", ":", "\n", "                ", "x", "=", "x", ".", "cuda", "(", ")", "\n", "", "_", ",", "pb", "=", "torch", ".", "max", "(", "model", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ".", "data", ".", "cpu", "(", ")", ",", "1", ",", "keepdim", "=", "False", ")", "\n", "\n", "acc_on_mem", "+=", "(", "pb", "==", "y", ".", "data", ".", "cpu", "(", ")", ")", ".", "float", "(", ")", "\n", "\n", "", "acc_on_mem", "=", "(", "acc_on_mem", "/", "model", ".", "sampled_memory_data", ".", "size", "(", "0", ")", ")", "\n", "", "return", "acc_on_mem", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.life_experience": [[178, 222], ["time.time", "enumerate", "main.eval_tasks", "main.eval_on_memory", "result_a.append", "result_t.append", "current_res_per_t.append", "current_avg_acc_list.append", "result_all.append", "time.time", "x.view", "y.long", "model.train", "model.observe", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "main.eval_tasks", "result_a.append", "result_all.append", "result_t.append", "current_res_per_t.append", "current_avg_acc_list.append", "x.size", "v_x.cuda.cuda", "v_y.cuda.cuda"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.eval_tasks", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.eval_on_memory", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.observe", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.None.main.eval_tasks"], ["", "def", "life_experience", "(", "model", ",", "continuum", ",", "x_te", ",", "args", ")", ":", "\n", "    ", "result_a", "=", "[", "]", "\n", "result_t", "=", "[", "]", "\n", "result_all", "=", "[", "]", "#avg performance on all test samples", "\n", "current_res_per_t", "=", "[", "]", "#per task accuracy up until the current task", "\n", "current_avg_acc_list", "=", "[", "]", "#avg accuracy on task seen so far", "\n", "current_task", "=", "0", "\n", "time_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "for", "(", "i", ",", "(", "x", ",", "t", ",", "y", ")", ")", "in", "enumerate", "(", "continuum", ")", ":", "\n", "        ", "if", "t", ">", "args", ".", "tasks_to_preserve", ":", "\n", "            ", "break", "\n", "", "if", "(", "(", "(", "i", "%", "args", ".", "log_every", ")", "==", "0", ")", "or", "(", "t", "!=", "current_task", ")", ")", ":", "\n", "\n", "            ", "res_per_t", ",", "res_all", ",", "current_result", ",", "current_avg_acc", "=", "eval_tasks", "(", "model", ",", "x_te", ",", "current_task", ",", "args", ")", "\n", "result_a", ".", "append", "(", "res_per_t", ")", "\n", "result_all", ".", "append", "(", "res_all", ")", "\n", "result_t", ".", "append", "(", "current_task", ")", "\n", "current_res_per_t", ".", "append", "(", "current_result", ")", "\n", "current_avg_acc_list", ".", "append", "(", "current_avg_acc", ")", "\n", "current_task", "=", "t", "\n", "\n", "", "v_x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "v_y", "=", "y", ".", "long", "(", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "v_x", "=", "v_x", ".", "cuda", "(", ")", "\n", "v_y", "=", "v_y", ".", "cuda", "(", ")", "\n", "\n", "", "model", ".", "train", "(", ")", "\n", "model", ".", "observe", "(", "v_x", ",", "t", ",", "v_y", ")", "\n", "\n", "", "res_per_t", ",", "res_all", ",", "current_result", ",", "current_avg_acc", "=", "eval_tasks", "(", "model", ",", "x_te", ",", "args", ".", "tasks_to_preserve", ",", "args", ")", "\n", "res_on_mem", "=", "eval_on_memory", "(", "args", ")", "\n", "result_a", ".", "append", "(", "res_per_t", ")", "\n", "result_t", ".", "append", "(", "current_task", ")", "\n", "current_res_per_t", ".", "append", "(", "current_result", ")", "#at the end those are similar to the previous two", "\n", "current_avg_acc_list", ".", "append", "(", "current_avg_acc", ")", "\n", "result_all", ".", "append", "(", "res_all", ")", "\n", "\n", "time_end", "=", "time", ".", "time", "(", ")", "\n", "time_spent", "=", "time_end", "-", "time_start", "\n", "\n", "return", "torch", ".", "Tensor", "(", "result_t", ")", ",", "torch", ".", "Tensor", "(", "result_a", ")", ",", "torch", ".", "Tensor", "(", "result_all", ")", ",", "torch", ".", "Tensor", "(", "current_res_per_t", ")", ",", "torch", ".", "Tensor", "(", "current_avg_acc_list", ")", ",", "res_on_mem", ",", "time_spent", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.read_yaml_file.read_and_plot": [[16, 79], ["enumerate", "print", "matplotlib.figure", "matplotlib.plot", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.yticks", "matplotlib.ylabel", "matplotlib.savefig", "print", "matplotlib.figure", "matplotlib.plot", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.yticks", "matplotlib.ylabel", "matplotlib.savefig", "open", "yaml.load", "numpy.array", "numpy.array", "open.close", "numpy.concatenate", "numpy.linalg.solve", "numpy.matmul", "matplotlib.figure", "matplotlib.plot", "matplotlib.plot", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.yticks", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.savefig", "correlation_coefs.append", "pearson_p_values.append", "range", "os.path.join", "range", "os.path.join", "numpy.matmul", "numpy.matmul", "surrogate_empirical_study.pearson_correlation_test.compute_correlation", "surrogate_empirical_study.pearson_correlation_test.compute_pearson_correlation_p_value", "np.array.reshape", "numpy.ones_like().reshape", "len", "len", "file_name.split", "numpy.ones_like"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.pearson_correlation_test.compute_correlation", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.pearson_correlation_test.compute_pearson_correlation_p_value"], ["def", "read_and_plot", "(", "list_of_files_names", ":", "Iterable", "[", "str", "]", ",", "\n", "plot_fontsize", ":", "int", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Load a list of yaml files containing correlation data and plot them\n\n    :param list_of_files_names: (list[str]) list of yaml files names\n    :param plot_fontsize:\n\n    \"\"\"", "\n", "\n", "# Initialize results lists", "\n", "correlation_coefs", "=", "[", "]", "\n", "pearson_p_values", "=", "[", "]", "\n", "\n", "# Come across all files in the input list", "\n", "for", "rank", ",", "file_name", "in", "enumerate", "(", "list_of_files_names", ")", ":", "\n", "\n", "# Load the current file and parse data", "\n", "        ", "file", "=", "open", "(", "file_name", ",", "'r'", ")", "\n", "correlation_data", "=", "yaml", ".", "load", "(", "file", ")", "\n", "angle_measure", "=", "np", ".", "array", "(", "correlation_data", "[", "'angle_measure'", "]", ")", "\n", "criterion", "=", "np", ".", "array", "(", "correlation_data", "[", "'criterion'", "]", ")", "\n", "file", ".", "close", "(", ")", "\n", "\n", "# Compute a linear regression on the data", "\n", "biased_criterion", "=", "np", ".", "concatenate", "(", "(", "criterion", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "np", ".", "ones_like", "(", "criterion", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "w", "=", "np", ".", "linalg", ".", "solve", "(", "np", ".", "matmul", "(", "biased_criterion", ".", "T", ",", "biased_criterion", ")", ",", "np", ".", "matmul", "(", "biased_criterion", ".", "T", ",", "angle_measure", ")", ")", "\n", "lin_pred", "=", "np", ".", "matmul", "(", "biased_criterion", ",", "w", ")", "\n", "\n", "# Plot the correlation data of the current file as well as the regression line", "\n", "plt", ".", "figure", "(", "rank", "+", "1", ",", "figsize", "=", "(", "15", ",", "9", ")", ")", "\n", "plt", ".", "plot", "(", "criterion", ",", "angle_measure", ",", "'.'", ")", "\n", "plt", ".", "plot", "(", "criterion", ",", "lin_pred", ",", "'r'", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "xlabel", "(", "'Criterion'", ",", "fontsize", "=", "plot_fontsize", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "ylabel", "(", "'Angle value'", ",", "fontsize", "=", "plot_fontsize", ")", "\n", "plt", ".", "legend", "(", "[", "'Generated samples'", ",", "'Linear approximation'", "]", ",", "prop", "=", "{", "'size'", ":", "28", "}", ")", "\n", "plt", ".", "savefig", "(", "file_name", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "'.pdf'", ")", "\n", "\n", "# Compute and store the pearson p-value", "\n", "correlation_coefs", ".", "append", "(", "compute_correlation", "(", "criterion", ",", "angle_measure", ")", ")", "\n", "pearson_p_values", ".", "append", "(", "compute_pearson_correlation_p_value", "(", "criterion", ",", "angle_measure", ",", "n", "=", "10000", ")", ")", "\n", "\n", "# Plot correlation evolution through files as well as p values", "\n", "", "print", "(", "correlation_coefs", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "9", ")", ")", "\n", "plt", ".", "plot", "(", "range", "(", "3", ",", "3", "+", "len", "(", "list_of_files_names", ")", ")", ",", "correlation_coefs", ",", "'-X'", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "xlabel", "(", "'Dimension'", ",", "fontsize", "=", "plot_fontsize", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "ylabel", "(", "'Pearson correlation coefficient'", ",", "fontsize", "=", "plot_fontsize", ")", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root_dir", ",", "'results'", ",", "'surrogate'", ",", "'Pearson_correlation_coefs.pdf'", ")", ")", "\n", "\n", "print", "(", "pearson_p_values", ")", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "15", ",", "9", ")", ")", "\n", "plt", ".", "plot", "(", "range", "(", "3", ",", "3", "+", "len", "(", "list_of_files_names", ")", ")", ",", "pearson_p_values", ",", "'-X'", ")", "\n", "plt", ".", "xticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "xlabel", "(", "'Dimension'", ",", "fontsize", "=", "plot_fontsize", ")", "\n", "plt", ".", "yticks", "(", "fontsize", "=", "18", ")", "\n", "plt", ".", "ylabel", "(", "'Pearson p-values'", ",", "fontsize", "=", "plot_fontsize", ")", "\n", "plt", ".", "savefig", "(", "os", ".", "path", ".", "join", "(", "root_dir", ",", "'results'", ",", "'surrogate'", ",", "'Pearson_p_values.pdf'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.__init__": [[10, 31], ["range", "numpy.sqrt", "numpy.sum"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "G", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Store parameters of the angle such as the dimension of the space and the family of vector that defines the angle\n\n        :param G: (ndarray) A square ndarray of dtype float that encodes a family of n vectors in an n dimensional\n        space, for a certain n.\n\n        \"\"\"", "\n", "\n", "# Store dimension of the space", "\n", "self", ".", "dimension", "=", "G", ".", "shape", "[", "0", "]", "\n", "\n", "# Check that the number of dimensions correspond to the number of vectors", "\n", "assert", "G", ".", "shape", "==", "(", "self", ".", "dimension", ",", "self", ".", "dimension", ")", "\n", "\n", "# Normalize each and every vector", "\n", "for", "i", "in", "range", "(", "G", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "G", "[", ":", ",", "i", "]", "=", "G", "[", ":", ",", "i", "]", "/", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "G", "[", ":", ",", "i", "]", "*", "G", "[", ":", ",", "i", "]", ")", ")", "\n", "\n", "# Store G", "\n", "", "self", ".", "G", "=", "G", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.check_feasibility": [[32, 58], ["range", "numpy.sum"], "methods", ["None"], ["", "def", "check_feasibility", "(", "self", ",", "v", ":", "np", ".", "array", ")", ":", "\n", "        ", "\"\"\"\n        Compute the feasibility of a given vector v defined by:\n        v is feasible iif\n\n        .. math::\n            \\\\forall i \\in \\left[|1; n|\\right], ~ \\left< v \\mid G_i \\right> \\leq 0\n\n        :param v: (ndarray) A n dimensional vector\n\n        :return: 1 if v is feasible, 0 otherwise\n\n        \"\"\"", "\n", "\n", "# Come across all vector in G", "\n", "for", "i", "in", "range", "(", "self", ".", "dimension", ")", ":", "\n", "\n", "# Compute the inner between v and G_i", "\n", "            ", "inner", "=", "np", ".", "sum", "(", "v", "*", "self", ".", "G", "[", ":", ",", "i", "]", ")", "\n", "\n", "# Break the loop and return 0 as soon as the feasible condition is violated", "\n", "if", "inner", ">=", "0", ":", "\n", "                ", "return", "0.", "\n", "\n", "# Return 1 if v is feasible", "\n", "", "", "return", "1.", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.angle_estimation": [[59, 86], ["range", "numpy.random.randn", "angle.Angle.check_feasibility"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.check_feasibility"], ["", "def", "angle_estimation", "(", "self", ",", "n", ":", "int", ")", ":", "\n", "        ", "\"\"\"\n        Compute an estimation of the solid angle defined by G, by MC method.\n        The angle is normalized so that the entire sphere described an angle of 1.\n\n        :param n: (int) number of draws in the MC procedure\n\n        :return: (float) angle estimation\n\n        \"\"\"", "\n", "\n", "# Initialize the probability that a random vector falls into the feasible set", "\n", "p", "=", "0.", "\n", "\n", "# Draw n vector to update p, the estimation of the angle", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "\n", "# Draw v as a standard normal variable so that after normalization, v is a uniform r.v. on the sphere", "\n", "            ", "v", "=", "np", ".", "random", ".", "randn", "(", "self", ".", "dimension", ")", "\n", "\n", "# Update p", "\n", "p", "+=", "self", ".", "check_feasibility", "(", "v", ")", "\n", "\n", "# Compute the final angle estimation", "\n", "", "p", "/=", "n", "\n", "\n", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.angle_heuristic": [[87, 106], ["numpy.sum", "float", "numpy.sum"], "methods", ["None"], ["", "def", "angle_heuristic", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute the heuristic proposed in the ICML2019 paper \"Online continual learning with no task boundaries\" by\n        Rahaf Aljundi, Min Lin, Baptiste Goujaud and Yoshua Bengio.\n\n        .. math::\n            \\\\Vert \\\\sum_i G_i \\\\Vert_2^2\n\n        :return: (float) the value obtained by the proposed heuristic\n\n        \"\"\"", "\n", "\n", "# Compute the sum of all the gradients in G", "\n", "sum_grads", "=", "np", ".", "sum", "(", "self", ".", "G", ",", "1", ")", "\n", "\n", "# Compute the square of the L2 norm of the above", "\n", "heuristic_value", "=", "float", "(", "np", ".", "sum", "(", "sum_grads", "**", "2", ")", ")", "\n", "\n", "return", "heuristic_value", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.feasible_space_angle_heuristic_correlation.collect_correlation_data": [[11, 55], ["print", "dict", "tqdm.tqdm", "os.path.dirname", "os.path.join", "os.path.join", "open", "yaml.dump", "open.close", "range", "numpy.random.rand", "numpy.random.randn", "range", "range", "surrogate_empirical_study.angle.Angle", "correlation_data[].append", "correlation_data[].append", "os.path.dirname", "os.path.exists", "os.makedirs", "surrogate_empirical_study.angle.Angle.angle_estimation", "surrogate_empirical_study.angle.Angle.angle_heuristic", "os.path.abspath", "numpy.sqrt", "numpy.sum", "numpy.sqrt", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.angle_estimation", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.angle.Angle.angle_heuristic"], ["def", "collect_correlation_data", "(", "d", ":", "int", "=", "3", ")", ":", "\n", "    ", "\"\"\"\n    Collect correlation data, namely angle MC estimation and heuristic value\n\n    :param d: (int) number of dimension\n\n    \"\"\"", "\n", "print", "(", "\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n d={}\"", ".", "format", "(", "d", ")", ")", "\n", "\n", "# Initialize correlation_data dict", "\n", "correlation_data", "=", "dict", "(", ")", "\n", "correlation_data", "[", "'angle_measure'", "]", "=", "[", "]", "\n", "correlation_data", "[", "'criterion'", "]", "=", "[", "]", "\n", "\n", "# Repeat the list update a number of time equivalent to the number of needed data", "\n", "for", "j", "in", "tqdm", "(", "range", "(", "1000", ")", ")", ":", "\n", "\n", "# Generate the d grads in d dimensional space that define the feasible set", "\n", "        ", "projected_norm", "=", "np", ".", "random", ".", "rand", "(", ")", "\n", "grads", "=", "np", ".", "random", ".", "randn", "(", "d", ",", "d", ")", "\n", "for", "column", "in", "range", "(", "d", ")", ":", "\n", "            ", "grads", "[", ":", ",", "column", "]", "=", "grads", "[", ":", ",", "column", "]", "/", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "grads", "[", ":", ",", "column", "]", "**", "2", ")", ")", "\n", "", "for", "column", "in", "range", "(", "1", ",", "d", ")", ":", "\n", "            ", "grads", "[", ":", ",", "column", "]", "=", "projected_norm", "*", "grads", "[", ":", ",", "0", "]", "+", "np", ".", "sqrt", "(", "1", "-", "projected_norm", "**", "2", ")", "*", "(", "grads", "[", ":", ",", "column", "]", "-", "np", ".", "sum", "(", "grads", "[", ":", ",", "column", "]", "*", "grads", "[", ":", ",", "0", "]", ")", "*", "grads", "[", ":", ",", "0", "]", ")", "\n", "\n", "# Instantiate Angle", "\n", "", "angle", "=", "Angle", "(", "grads", ")", "\n", "\n", "# Store the MC angle estimation with variance of sqrt(p/(1000*2^d)) where p is the estimated angle", "\n", "# Then if p = 1/2^d, variance = p/sqrt(1000)", "\n", "correlation_data", "[", "'angle_measure'", "]", ".", "append", "(", "angle", ".", "angle_estimation", "(", "1000", "*", "2", "**", "d", ")", ")", "\n", "\n", "# Store the value given by the heuristic", "\n", "correlation_data", "[", "'criterion'", "]", ".", "append", "(", "angle", ".", "angle_heuristic", "(", ")", ")", "\n", "\n", "# Dump the data on the hard drive", "\n", "", "root_dir", "=", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "dirname", "(", "os", ".", "path", ".", "abspath", "(", "__file__", ")", ")", ")", "\n", "result_folder", "=", "os", ".", "path", ".", "join", "(", "root_dir", ",", "'results'", ",", "'surrogate'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "result_folder", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "result_folder", ")", "\n", "", "yaml_file_name", "=", "os", ".", "path", ".", "join", "(", "result_folder", ",", "'correlation_data_{}_dimensions.yaml'", ".", "format", "(", "d", ")", ")", "\n", "yaml_file", "=", "open", "(", "yaml_file_name", ",", "'w'", ")", "\n", "yaml", ".", "dump", "(", "correlation_data", ",", "yaml_file", ")", "\n", "yaml_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.pearson_correlation_test.compute_correlation": [[8, 29], ["numpy.mean", "numpy.std", "numpy.std", "numpy.mean", "numpy.mean"], "function", ["None"], ["def", "compute_correlation", "(", "X", ":", "Iterable", "[", "float", "]", ",", "\n", "Y", ":", "Iterable", "[", "float", "]", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Compute the Pearson correlation coefficient from a sequence of samples of a joint variables (X_i, Y_i)\n\n    :param X: (Iterable[float]) List of samples drawn from the first variable\n    :param Y: (Iterable[float]) List of samples drawn from the second variable\n\n    :return: Pearson coefficient of the joint variable (X, Y)\n\n    \"\"\"", "\n", "\n", "# Normalize the two variables", "\n", "X_normalized", "=", "(", "X", "-", "np", ".", "mean", "(", "X", ")", ")", "/", "np", ".", "std", "(", "X", ")", "\n", "Y_normalized", "=", "(", "Y", "-", "np", ".", "mean", "(", "Y", ")", ")", "/", "np", ".", "std", "(", "Y", ")", "\n", "\n", "# Compute the covariance of the normalized variables", "\n", "r", "=", "np", ".", "mean", "(", "X_normalized", "*", "Y_normalized", ")", "\n", "\n", "return", "r", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.pearson_correlation_test.compute_pearson_correlation_p_value": [[31, 66], ["pearson_correlation_test.compute_correlation", "range", "numpy.mean", "numpy.random.permutation", "numpy.random.permutation", "r_list.append", "float", "pearson_correlation_test.compute_correlation"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.pearson_correlation_test.compute_correlation", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.surrogate_empirical_study.pearson_correlation_test.compute_correlation"], ["", "def", "compute_pearson_correlation_p_value", "(", "X", ":", "Iterable", "[", "float", "]", ",", "\n", "Y", ":", "Iterable", "[", "float", "]", ",", "\n", "n", ":", "int", "=", "10000.", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Compute the Pearson correlation p-value by permutation\n\n    :param X: (Iterable[float]) List of samples drawn from the first variable\n    :param Y: (Iterable[float]) List of samples drawn from the second variable\n    :param n: (int) Number of times we simulate a correlation coefficient by permutation\n\n    :return: p-values of the Pearson correlation test by permutation\n\n    \"\"\"", "\n", "\n", "# Compute the correlation coefficient on (X, Y)", "\n", "r", "=", "compute_correlation", "(", "X", ",", "Y", ")", "\n", "\n", "# Initialize the list of values comparisons", "\n", "r_list", "=", "[", "]", "\n", "\n", "# MC", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "\n", "# Randomly permute X and Y to make the draws independent", "\n", "        ", "X", "=", "np", ".", "random", ".", "permutation", "(", "X", ")", "\n", "Y", "=", "np", ".", "random", ".", "permutation", "(", "Y", ")", "\n", "\n", "# Compute correlation on permuted variables and compare with r", "\n", "r_list", ".", "append", "(", "float", "(", "compute_correlation", "(", "X", ",", "Y", ")", ">", "r", ")", ")", "\n", "\n", "# Compute the p-value of the Pearson correlation test", "\n", "", "p_value", "=", "np", ".", "mean", "(", "r_list", ")", "\n", "\n", "return", "p_value", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.icarl.Net.__init__": [[19, 65], ["super().__init__", "int", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.KLDivLoss", "torch.nn.LogSoftmax", "torch.nn.Softmax", "int", "error", "common.ResNet18", "common.MLP", "icarl.Net.parameters"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nt", "=", "n_tasks", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "num_exemplars", "=", "0", "\n", "self", ".", "n_feat", "=", "n_outputs", "\n", "self", ".", "n_classes", "=", "n_outputs", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "self", ".", "samples_per_task", "=", "(", "int", ")", "(", "self", ".", "samples_per_task", ")", "\n", "if", "self", ".", "samples_per_task", "<=", "0", ":", "\n", "            ", "error", "(", "'set explicitly args.samples_per_task'", ")", "\n", "", "self", ".", "examples_seen", "=", "0", "\n", "\n", "# setup network", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "\n", "# setup optimizer", "\n", "", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "#BCELoss", "\n", "self", ".", "kl", "=", "torch", ".", "nn", ".", "KLDivLoss", "(", ")", "# for distillation", "\n", "self", ".", "lsm", "=", "torch", ".", "nn", ".", "LogSoftmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "sm", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "# memory", "\n", "self", ".", "memx", "=", "None", "# stores raw inputs, PxD", "\n", "self", ".", "memy", "=", "None", "\n", "self", ".", "mem_class_x", "=", "{", "}", "# stores exemplars class by class", "\n", "self", ".", "mem_class_y", "=", "{", "}", "\n", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "self", ".", "nc_per_batch", "=", "int", "(", "n_outputs", "/", "n_tasks", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.icarl.Net.compute_offsets": [[66, 71], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "\n", "        ", "offset1", "=", "task", "*", "self", ".", "nc_per_batch", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_batch", "\n", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.icarl.Net.forward": [[72, 111], ["x.size", "icarl.Net.mem_class_x.keys", "torch.LongTensor", "icarl.Net.net().data.clone", "range", "torch.zeros", "range", "icarl.Net.mem_class_x.keys", "torch.Tensor().fill_", "out[].fill_", "torch.ones", "float", "means.cuda.cuda.cuda", "icarl.Net.net().data.mean", "dist.min", "ii.squeeze.squeeze.squeeze", "ii.squeeze.squeeze.item", "out.cuda.cuda.cuda", "out.cuda.cuda.cuda", "len", "torch.Tensor", "icarl.Net.mem_class_x.keys", "icarl.Net.net", "icarl.Net.net", "preds[].expand", "len", "icarl.Net.mem_class_x.keys"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "# nearest neighbor", "\n", "        ", "nd", "=", "self", ".", "n_feat", "\n", "ns", "=", "x", ".", "size", "(", "0", ")", "\n", "\n", "if", "t", "*", "self", ".", "nc_per_batch", "not", "in", "self", ".", "mem_class_x", ".", "keys", "(", ")", ":", "\n", "# no exemplar in memory yet, output uniform distr. over classes in", "\n", "# task t above, we check presence of first class for this task, we", "\n", "# should check them all", "\n", "            ", "out", "=", "torch", ".", "Tensor", "(", "ns", ",", "self", ".", "n_classes", ")", ".", "fill_", "(", "-", "10e10", ")", "\n", "out", "[", ":", ",", "0", ":", "self", ".", "n_classes", "]", ".", "fill_", "(", "\n", "1.0", "/", "self", ".", "n_classes", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                ", "out", "=", "out", ".", "cuda", "(", ")", "\n", "", "return", "out", "\n", "", "means", "=", "torch", ".", "ones", "(", "len", "(", "self", ".", "mem_class_x", ".", "keys", "(", ")", ")", ",", "nd", ")", "*", "float", "(", "'inf'", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "            ", "means", "=", "means", ".", "cuda", "(", ")", "\n", "\n", "#for cc in range(offset1, offset2):", "\n", "#    means[cc -", "\n", "#          offset1] = self.net(self.mem_class_x[cc]).data.mean(0)", "\n", "\n", "", "for", "cc", "in", "self", ".", "mem_class_x", ".", "keys", "(", ")", ":", "\n", "            ", "means", "[", "cc", "]", "=", "self", ".", "net", "(", "self", ".", "mem_class_x", "[", "cc", "]", ")", ".", "data", ".", "mean", "(", "0", ")", "\n", "", "classpred", "=", "torch", ".", "LongTensor", "(", "ns", ")", "\n", "preds", "=", "self", ".", "net", "(", "x", ")", ".", "data", ".", "clone", "(", ")", "\n", "for", "ss", "in", "range", "(", "ns", ")", ":", "\n", "            ", "dist", "=", "(", "means", "-", "preds", "[", "ss", "]", ".", "expand", "(", "len", "(", "self", ".", "mem_class_x", ".", "keys", "(", ")", ")", ",", "nd", ")", ")", ".", "norm", "(", "2", ",", "1", ")", "\n", "_", ",", "ii", "=", "dist", ".", "min", "(", "0", ")", "\n", "ii", "=", "ii", ".", "squeeze", "(", ")", "\n", "classpred", "[", "ss", "]", "=", "ii", ".", "item", "(", ")", "\n", "\n", "", "out", "=", "torch", ".", "zeros", "(", "ns", ",", "self", ".", "n_classes", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "            ", "out", "=", "out", ".", "cuda", "(", ")", "\n", "", "for", "ss", "in", "range", "(", "ns", ")", ":", "\n", "            ", "out", "[", "ss", ",", "classpred", "[", "ss", "]", "]", "=", "1", "\n", "", "return", "out", "# return 1-of-C code, ns x nc", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.icarl.Net.forward_training": [[112, 117], ["icarl.Net.net"], "methods", ["None"], ["", "def", "forward_training", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "# make sure we predict classes within the current task", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.icarl.Net.observe": [[118, 229], ["icarl.Net.net.train", "x.size", "range", "x.data.clone", "y.data.clone", "torch.cat", "torch.cat", "icarl.Net.net.zero_grad", "icarl.Net.bce", "icarl.Net.backward", "icarl.Net.opt.step", "torch.LongTensor.size", "int", "range", "icarl.Net.mem_class_x.keys", "icarl.Net.net", "torch.zeros", "torch.zeros", "icarl.Net.mem_class_x.keys", "torch.LongTensor", "torch.LongTensor", "icarl.Net.memx.index_select", "icarl.Net.net().data.clone().mean", "torch.zeros", "icarl.Net.size", "torch.zeros", "icarl.Net.net().data.clone", "range", "exemplars[].clone.clone", "icarl.Net.net().data.clone", "x.data.clone", "y.data.clone", "len", "x.size", "len", "inp_dist.cuda.cuda.cuda", "target_dist.cuda.cuda.cuda", "random.randint", "[].clone", "[].clone", "icarl.Net.kl", "numpy.unique", "numpy.unique", "lab.cuda.cuda.cuda", "x.size", "exemplars[].clone.cuda", "torch.zeros", "cost.sort", "icarl.Net.mem_class_x.keys", "icarl.Net.mem_class_x.keys", "icarl.Net.lsm", "icarl.Net.sm", "icarl.Net.memy.cpu().numpy", "icarl.Net.memy.numpy", "len", "icarl.Net.net().data.clone", "icarl.Net.cuda", "icarl.Net.net().data.clone().sum", "random.randint.size", "cdata[].clone", "exemplars[].clone", "random.randint.size", "lab.cuda.cuda.item", "len", "icarl.Net.net", "icarl.Net.mem_class_x.keys", "icarl.Net.net", "random.randint.size", "icarl.Net.net", "icarl.Net.memy.cpu", "icarl.Net.net().data.clone", "icarl.Net.net", "icarl.Net.expand", "icarl.Net.net", "random.randint.size", "icarl.Net.expand"], "methods", ["None"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "\n", "        ", "self", ".", "net", ".", "train", "(", ")", "\n", "self", ".", "examples_seen", "+=", "x", ".", "size", "(", "0", ")", "\n", "\n", "if", "self", ".", "memx", "is", "None", ":", "\n", "            ", "self", ".", "memx", "=", "x", ".", "data", ".", "clone", "(", ")", "\n", "self", ".", "memy", "=", "y", ".", "data", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "cat", "(", "(", "self", ".", "memx", ",", "x", ".", "data", ".", "clone", "(", ")", ")", ")", "\n", "self", ".", "memy", "=", "torch", ".", "cat", "(", "(", "self", ".", "memy", ",", "y", ".", "data", ".", "clone", "(", ")", ")", ")", "\n", "", "for", "iter", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "            ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "loss", "=", "self", ".", "bce", "(", "(", "self", ".", "net", "(", "x", ")", ")", ",", "\n", "y", ")", "\n", "\n", "if", "self", ".", "num_exemplars", ">", "0", ":", "\n", "\n", "\n", "# distillation", "\n", "\n", "# first generate a minibatch with one example per class from", "\n", "# previous tasks", "\n", "\n", "                ", "inp_dist", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "mem_class_x", ".", "keys", "(", ")", ")", ",", "x", ".", "size", "(", "1", ")", ")", "\n", "target_dist", "=", "torch", ".", "zeros", "(", "len", "(", "self", ".", "mem_class_x", ".", "keys", "(", ")", ")", ",", "self", ".", "n_feat", ")", "\n", "\n", "if", "self", ".", "gpu", ":", "\n", "                    ", "inp_dist", "=", "inp_dist", ".", "cuda", "(", ")", "\n", "target_dist", "=", "target_dist", ".", "cuda", "(", ")", "\n", "", "for", "cc", "in", "self", ".", "mem_class_x", ".", "keys", "(", ")", ":", "\n", "                    ", "indx", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "mem_class_x", "[", "cc", "]", ")", "-", "1", ")", "\n", "inp_dist", "[", "cc", "]", "=", "self", ".", "mem_class_x", "[", "cc", "]", "[", "indx", "]", ".", "clone", "(", ")", "\n", "target_dist", "[", "cc", "]", "=", "self", ".", "mem_class_y", "[", "cc", "]", "[", "indx", "]", ".", "clone", "(", ")", "\n", "# Add distillation loss", "\n", "", "loss", "+=", "self", ".", "reg", "*", "self", ".", "kl", "(", "\n", "self", ".", "lsm", "(", "self", ".", "net", "(", "inp_dist", ")", "\n", ")", ",", "\n", "self", ".", "sm", "(", "target_dist", ")", ")", "\n", "# bprop and update", "\n", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "\n", "# check whether this is the last minibatch of the current task", "\n", "# We assume only 1 epoch!", "\n", "\n", "", "if", "self", ".", "examples_seen", "==", "self", ".", "samples_per_task", ":", "\n", "\n", "            ", "self", ".", "examples_seen", "=", "0", "\n", "# get labels from previous task; we assume labels are consecutive", "\n", "if", "self", ".", "gpu", ":", "\n", "                ", "all_labs", "=", "torch", ".", "LongTensor", "(", "np", ".", "unique", "(", "self", ".", "memy", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "all_labs", "=", "torch", ".", "LongTensor", "(", "np", ".", "unique", "(", "self", ".", "memy", ".", "numpy", "(", ")", ")", ")", "\n", "", "num_classes", "=", "all_labs", ".", "size", "(", "0", ")", "\n", "#assert(num_classes == self.nc_per_task)", "\n", "# Reduce exemplar set by updating value of num. exemplars per class", "\n", "self", ".", "num_exemplars", "=", "int", "(", "self", ".", "n_memories", "/", "\n", "(", "num_classes", "+", "len", "(", "self", ".", "mem_class_x", ".", "keys", "(", ")", ")", ")", ")", "\n", "\n", "for", "ll", "in", "range", "(", "num_classes", ")", ":", "\n", "                ", "lab", "=", "all_labs", "[", "ll", "]", "\n", "if", "self", ".", "gpu", ":", "\n", "                    ", "lab", "=", "lab", ".", "cuda", "(", ")", "\n", "\n", "", "indxs", "=", "(", "self", ".", "memy", "==", "lab", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", "\n", "cdata", "=", "self", ".", "memx", ".", "index_select", "(", "0", ",", "indxs", ")", "\n", "\n", "# Construct exemplar set for last task", "\n", "mean_feature", "=", "self", ".", "net", "(", "cdata", ")", ".", "data", ".", "clone", "(", ")", ".", "mean", "(", "0", ")", "\n", "nd", "=", "self", ".", "n_feat", "\n", "\n", "exemplars", "=", "torch", ".", "zeros", "(", "self", ".", "num_exemplars", ",", "x", ".", "size", "(", "1", ")", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                    ", "exemplars", "=", "exemplars", ".", "cuda", "(", ")", "\n", "", "ntr", "=", "cdata", ".", "size", "(", "0", ")", "\n", "# used to keep track of which examples we have already used", "\n", "taken", "=", "torch", ".", "zeros", "(", "ntr", ")", "\n", "model_output", "=", "self", ".", "net", "(", "cdata", ")", ".", "data", ".", "clone", "(", ")", "\n", "for", "ee", "in", "range", "(", "self", ".", "num_exemplars", ")", ":", "\n", "                    ", "prev", "=", "torch", ".", "zeros", "(", "1", ",", "nd", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                        ", "prev", "=", "prev", ".", "cuda", "(", ")", "\n", "", "if", "ee", ">", "0", ":", "\n", "                        ", "prev", "=", "self", ".", "net", "(", "exemplars", "[", ":", "ee", "]", ")", ".", "data", ".", "clone", "(", ")", ".", "sum", "(", "0", ")", "\n", "", "cost", "=", "(", "mean_feature", ".", "expand", "(", "ntr", ",", "nd", ")", "-", "(", "model_output", "\n", "+", "prev", ".", "expand", "(", "ntr", ",", "nd", ")", ")", "/", "(", "ee", "+", "1", ")", ")", ".", "norm", "(", "2", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "_", ",", "indx", "=", "cost", ".", "sort", "(", "0", ")", "\n", "winner", "=", "0", "\n", "while", "winner", "<", "indx", ".", "size", "(", "0", ")", "and", "taken", "[", "indx", "[", "winner", "]", "]", "==", "1", ":", "\n", "                        ", "winner", "+=", "1", "\n", "", "if", "winner", "<", "indx", ".", "size", "(", "0", ")", ":", "\n", "                        ", "taken", "[", "indx", "[", "winner", "]", "]", "=", "1", "\n", "exemplars", "[", "ee", "]", "=", "cdata", "[", "indx", "[", "winner", "]", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                        ", "exemplars", "=", "exemplars", "[", ":", "indx", ".", "size", "(", "0", ")", ",", ":", "]", ".", "clone", "(", ")", "\n", "self", ".", "num_exemplars", "=", "indx", ".", "size", "(", "0", ")", "\n", "break", "\n", "# update memory with exemplars", "\n", "", "", "self", ".", "mem_class_x", "[", "lab", ".", "item", "(", ")", "]", "=", "exemplars", ".", "clone", "(", ")", "\n", "\n", "# recompute outputs for distillation purposes", "\n", "\n", "", "for", "cc", "in", "self", ".", "mem_class_x", ".", "keys", "(", ")", ":", "\n", "#reduce number of examplers", "\n", "\n", "                ", "self", ".", "mem_class_x", "[", "cc", "]", "=", "self", ".", "mem_class_x", "[", "cc", "]", "[", "0", ":", "self", ".", "num_exemplars", "]", "\n", "self", ".", "mem_class_y", "[", "cc", "]", "=", "self", ".", "net", "(", "\n", "self", ".", "mem_class_x", "[", "cc", "]", ")", ".", "data", ".", "clone", "(", ")", "\n", "", "self", ".", "memx", "=", "None", "\n", "self", ".", "memy", "=", "None", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.__init__": [[204, 266], ["torch.Module.__init__", "miosqp.MIOSQP", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "GSS_IQP_Rehearse.Net.parameters", "common.ResNet18", "common.MLP", "GSS_IQP_Rehearse.Net.parameters", "GSS_IQP_Rehearse.Net.memory_data.cuda", "GSS_IQP_Rehearse.Net.memory_labs.cuda", "GSS_IQP_Rehearse.Net.grad_dims.append", "param.data.numel"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "margin", "=", "args", ".", "memory_strength", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "m", "=", "miosqp", ".", "MIOSQP", "(", ")", "\n", "self", ".", "solver", "=", "m", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "normalize", "=", "args", ".", "normalize", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "n_sampled_memories", "=", "args", ".", "n_sampled_memories", "\n", "self", ".", "n_constraints", "=", "args", ".", "n_constraints", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "self", ".", "slack", "=", "args", ".", "slack", "\n", "self", ".", "normalize", "=", "args", ".", "normalize", "\n", "self", ".", "change_th", "=", "args", ".", "change_th", "# gradient direction change threshold to re-select constraints", "\n", "# allocate ring buffer", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "self", ".", "n_memories", ")", "\n", "# allocate  selected  memory", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "self", ".", "sampled_memory_taskids", "=", "None", "\n", "self", ".", "sampled_memory_age", "=", "None", "\n", "\n", "self", ".", "subselect", "=", "args", ".", "subselect", "# if 1, first select from recent memory and then add to samples memories", "\n", "# allocate selected constraints", "\n", "self", ".", "constraints_data", "=", "None", "\n", "self", ".", "constraints_labs", "=", "None", "\n", "# old grads to measure changes", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "# we keep few samples per task and use their gradients", "\n", "\n", "# if args.cuda:", "\n", "#    self.grads = self.grads.cuda()", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.forward": [[268, 273], ["GSS_IQP_Rehearse.Net.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", "=", "0", ")", ":", "\n", "# t is there to be used by the main caller", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_taskids_stats": [[274, 282], ["torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "range", "torch.unique.size", "torch.unique.size", "torch.unique.size", "print", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "torch.sort", "print", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq"], "methods", ["None"], ["", "def", "print_taskids_stats", "(", "self", ")", ":", "\n", "\n", "        ", "tasks", "=", "torch", ".", "unique", "(", "self", ".", "sampled_memory_taskids", ")", "\n", "for", "t", "in", "range", "(", "tasks", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "print", "(", "'task number '", ",", "t", ",", "'samples in buffer'", ",", "torch", ".", "eq", "(", "self", ".", "sampled_memory_taskids", ",", "t", ")", ".", "nonzero", "(", ")", ".", "size", "(", "0", ")", ")", "\n", "\n", "", "for", "lab", "in", "torch", ".", "sort", "(", "torch", ".", "unique", "(", "self", ".", "sampled_memory_labs", ")", ")", "[", "0", "]", ":", "\n", "            ", "print", "(", "\"number of samples from class\"", ",", "lab", ",", "torch", ".", "nonzero", "(", "torch", ".", "eq", "(", "self", ".", "sampled_memory_labs", ",", "lab", ")", ")", ".", "size", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.select_samples_per_group": [[283, 374], ["print", "GSS_IQP_Rehearse.Net.eval", "zip", "GSS_IQP_Rehearse.Net.print_loss", "print", "torch.arange.size", "torch.arange.size", "torch.arange.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "GSS_IQP_Rehearse.Net.mem_grads[].clone", "print", "GSS_IQP_Rehearse.Net.print_taskids_stats", "GSS_IQP_Rehearse.Net.train", "GSS_IQP_Rehearse.Net.zero_grad", "GSS_IQP_Rehearse.Net.ce", "GSS_IQP_Rehearse.Net.backward", "GSS_IQP_Rehearse.add_memory_grad", "GSS_IQP_Rehearse.cosine_similarity_selector_IQP_Exact", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.ge().nonzero().size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.arange.size", "torch.arange.size", "torch.arange.size", "zip", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "GSS_IQP_Rehearse.cosine_similarity_selector_IQP_Exact", "print", "GSS_IQP_Rehearse.Net.print_loss", "GSS_IQP_Rehearse.Net.sampled_memory_data[].clone", "GSS_IQP_Rehearse.Net.sampled_memory_labs[].clone", "GSS_IQP_Rehearse.Net.sampled_memory_taskids[].clone", "GSS_IQP_Rehearse.Net.sampled_memory_age[].clone", "GSS_IQP_Rehearse.Net.forward", "y.unsqueeze", "GSS_IQP_Rehearse.Net.memory_data.size", "torch.arange.size", "torch.arange.size", "torch.arange.size", "GSS_IQP_Rehearse.Net.zero_grad", "GSS_IQP_Rehearse.Net.ce", "GSS_IQP_Rehearse.Net.backward", "GSS_IQP_Rehearse.add_memory_grad", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "pdb.set_trace", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "GSS_IQP_Rehearse.Net.memory_data[].clone", "GSS_IQP_Rehearse.Net.memory_labs[].clone", "new_task_ids.clone", "torch.zeros.clone", "torch.zeros.clone", "torch.zeros.clone", "x.unsqueeze", "int", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "torch.ge().nonzero", "GSS_IQP_Rehearse.Net.sampled_memory_data.size", "GSS_IQP_Rehearse.Net.forward", "y.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "x.unsqueeze", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_loss", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.print_taskids_stats", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_loss", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "", "def", "select_samples_per_group", "(", "self", ",", "task", ")", ":", "\n", "        ", "\"\"\"\n        Assuming a ring buffer, backup constraints and constrains,\n        re-estimate the backup constrains and constrains\n\n        \"\"\"", "\n", "\n", "print", "(", "\"constraints selector\"", ")", "\n", "self", ".", "mem_grads", "=", "None", "\n", "# get gradients from the ring buffer", "\n", "self", ".", "eval", "(", ")", "\n", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "memory_data", ",", "self", ".", "memory_labs", ")", ":", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "self", ".", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "self", ".", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "\n", "", "if", "self", ".", "subselect", ":", "\n", "            ", "added_inds", "=", "cosine_similarity_selector_IQP_Exact", "(", "self", ".", "mem_grads", ",", "nb_selected", "=", "int", "(", "self", ".", "n_memories", "/", "10", ")", ",", "\n", "solver", "=", "self", ".", "solver", ")", "\n", "", "else", ":", "\n", "            ", "added_inds", "=", "torch", ".", "arange", "(", "0", ",", "self", ".", "memory_data", ".", "size", "(", "0", ")", ")", "\n", "", "self", ".", "print_loss", "(", "self", ".", "memory_data", "[", "added_inds", "]", ",", "self", ".", "memory_labs", "[", "added_inds", "]", ",", "\"loss on selected samples from Mr\"", ")", "\n", "# 10 her is batch size", "\n", "print", "(", "\"Number of added inds from the very new batch\"", ",", "\n", "torch", ".", "ge", "(", "added_inds", ",", "self", ".", "n_memories", "-", "10", ")", ".", "nonzero", "(", ")", ".", "size", "(", "0", ")", ")", "\n", "from_buffer_size", "=", "added_inds", ".", "size", "(", "0", ")", "\n", "\n", "new_task_ids", "=", "torch", ".", "zeros", "(", "added_inds", ".", "size", "(", "0", ")", ")", "+", "task", "\n", "new_age", "=", "torch", ".", "zeros", "(", "added_inds", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "new_mem_grads", "=", "self", ".", "mem_grads", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "# estimate the active constraints from the backup samples", "\n", "self", ".", "mem_grads", "=", "None", "\n", "# buffer is full", "\n", "if", "not", "self", ".", "sampled_memory_data", "is", "None", "and", "self", ".", "n_sampled_memories", "<", "(", "\n", "self", ".", "sampled_memory_data", ".", "size", "(", "0", ")", "+", "from_buffer_size", ")", ":", "\n", "# ReDo Selection", "\n", "            ", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "sampled_memory_labs", ")", ":", "\n", "                ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "self", ".", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "self", ".", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "\n", "# update the backup constraints:", "\n", "", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "(", "self", ".", "memory_data", "[", "added_inds", "]", ",", "self", ".", "sampled_memory_data", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "(", "self", ".", "memory_labs", "[", "added_inds", "]", ",", "self", ".", "sampled_memory_labs", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "\n", "self", ".", "sampled_memory_taskids", "=", "torch", ".", "cat", "(", "(", "new_task_ids", ",", "self", ".", "sampled_memory_taskids", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_age", "=", "torch", ".", "cat", "(", "(", "new_age", ",", "self", ".", "sampled_memory_age", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "mem_grads", "=", "torch", ".", "cat", "(", "(", "self", ".", "new_mem_grads", ",", "self", ".", "mem_grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "# select samples that minimize the feasible region", "\n", "inds", "=", "cosine_similarity_selector_IQP_Exact", "(", "self", ".", "mem_grads", ",", "nb_selected", "=", "self", ".", "n_sampled_memories", ",", "\n", "solver", "=", "self", ".", "solver", ",", "age", "=", "self", ".", "sampled_memory_age", ")", "\n", "\n", "print", "(", "\"number of retained memories\"", ",", "torch", ".", "nonzero", "(", "torch", ".", "ge", "(", "inds", ",", "from_buffer_size", ")", ")", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "print_loss", "(", "self", ".", "sampled_memory_data", "[", "inds", "[", "torch", ".", "ge", "(", "inds", ",", "from_buffer_size", ")", "]", "]", ",", "\n", "self", ".", "sampled_memory_labs", "[", "inds", "[", "torch", ".", "ge", "(", "inds", ",", "from_buffer_size", ")", "]", "]", ",", "\n", "\"loss on the selected Mb Samples\"", ")", "\n", "if", "torch", ".", "nonzero", "(", "torch", ".", "ge", "(", "inds", ",", "from_buffer_size", ")", ")", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "                ", "pdb", ".", "set_trace", "(", ")", "\n", "", "self", ".", "sampled_memory_data", "=", "self", ".", "sampled_memory_data", "[", "inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "sampled_memory_labs", "[", "inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_taskids", "=", "self", ".", "sampled_memory_taskids", "[", "inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_age", "=", "self", ".", "sampled_memory_age", "[", "inds", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "\n", "            ", "if", "not", "self", ".", "sampled_memory_data", "is", "None", ":", "\n", "                ", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "(", "self", ".", "memory_data", "[", "added_inds", "]", ",", "self", ".", "sampled_memory_data", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "(", "self", ".", "memory_labs", "[", "added_inds", "]", ",", "self", ".", "sampled_memory_labs", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_taskids", "=", "torch", ".", "cat", "(", "(", "new_task_ids", ",", "self", ".", "sampled_memory_taskids", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_age", "=", "torch", ".", "cat", "(", "(", "new_age", ",", "self", ".", "sampled_memory_age", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "sampled_memory_data", "=", "self", ".", "memory_data", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "memory_labs", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_taskids", "=", "new_task_ids", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_age", "=", "new_age", ".", "clone", "(", ")", "\n", "", "", "print", "(", "\"selected labels are\"", ",", "self", ".", "sampled_memory_labs", ")", "\n", "self", ".", "print_taskids_stats", "(", ")", "\n", "self", ".", "mem_grads", "=", "None", "\n", "self", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_loss": [[376, 382], ["GSS_IQP_Rehearse.Net.ce", "print", "GSS_IQP_Rehearse.Net.forward"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "print_loss", "(", "self", ",", "x", ",", "y", ",", "msg", ")", ":", "\n", "# estimate the loss and print it on a given batch of samples", "\n", "        ", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "\n", "x", ")", ",", "\n", "y", ")", "\n", "print", "(", "\"$$\"", ",", "msg", ",", "\"$$\"", ",", "ptloss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.observe": [[385, 448], ["y.data.size", "min", "GSS_IQP_Rehearse.Net.memory_data[].copy_", "range", "GSS_IQP_Rehearse.Net.memory_labs[].copy_", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "min", "GSS_IQP_Rehearse.Net.zero_grad", "GSS_IQP_Rehearse.Net.ce", "GSS_IQP_Rehearse.Net.backward", "GSS_IQP_Rehearse.Net.opt.step", "GSS_IQP_Rehearse.Net.print_loss", "print", "GSS_IQP_Rehearse.Net.select_samples_per_group", "GSS_IQP_Rehearse.Net.sampled_memory_labs.size", "GSS_IQP_Rehearse.Net.sampled_memory_labs.size", "GSS_IQP_Rehearse.Net.forward", "GSS_IQP_Rehearse.Net.zero_grad", "GSS_IQP_Rehearse.Net.ce", "GSS_IQP_Rehearse.Net.backward", "GSS_IQP_Rehearse.Net.opt.step", "GSS_IQP_Rehearse.Net.print_loss", "GSS_IQP_Rehearse.Net.print_loss", "GSS_IQP_Rehearse.Net.forward", "GSS_IQP_Rehearse.Net.sampled_memory_labs.size"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_loss", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.select_samples_per_group", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_loss", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.Net.print_loss", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "#", "\n", "# we dont use it :)", "\n", "\n", "# Update ring buffer storing examples from current task", "\n", "        ", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "            ", "shuffeled_inds", "=", "torch", ".", "randperm", "(", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "effective_batch_size", "=", "min", "(", "self", ".", "n_constraints", ",", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "b_index", "=", "0", "\n", "\n", "", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "\n", "# get gradients on previous constraints", "\n", "\n", "# now compute the grad on the current minibatch", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ")", ",", "y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "\n", "                ", "random_batch_inds", "=", "shuffeled_inds", "[", "\n", "b_index", "*", "effective_batch_size", ":", "b_index", "*", "effective_batch_size", "+", "effective_batch_size", "]", "\n", "\n", "batch_x", "=", "self", ".", "sampled_memory_data", "[", "random_batch_inds", "]", "\n", "batch_y", "=", "self", ".", "sampled_memory_labs", "[", "random_batch_inds", "]", "\n", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "batch_x", ")", ",", "batch_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "b_index", "+=", "1", "\n", "if", "b_index", "*", "effective_batch_size", ">=", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ":", "\n", "                    ", "b_index", "=", "0", "\n", "\n", "# update buffer", "\n", "", "", "", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "print_loss", "(", "self", ".", "memory_data", ",", "self", ".", "memory_labs", ",", "msg", "=", "\"Mr Loss Before Buffer rehearsal\"", ")", "\n", "\n", "if", "self", ".", "sampled_memory_labs", "is", "not", "None", ":", "\n", "                ", "self", ".", "print_loss", "(", "self", ".", "memory_data", ",", "self", ".", "memory_labs", ",", "msg", "=", "\"Mr Loss Before selection\"", ")", "\n", "self", ".", "print_loss", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "sampled_memory_labs", ",", "msg", "=", "\"Mb Loss Before selection\"", ")", "\n", "", "self", ".", "mem_cnt", "=", "0", "\n", "print", "(", "\"ring buffer is full, re-estimating of the constrains, we are at task\"", ",", "t", ")", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "\n", "self", ".", "select_samples_per_group", "(", "t", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.store_grad": [[42, 59], ["grads[].fill_", "pp", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["def", "store_grad", "(", "pp", ",", "grads", ",", "grad_dims", ",", "tid", ")", ":", "\n", "    ", "\"\"\"\n        This stores parameter gradients of past tasks.\n        pp: parameters\n        grads: gradients\n        grad_dims: list with number of parameters per layers\n        tid: task id\n    \"\"\"", "\n", "# store the gradients", "\n", "grads", "[", ":", ",", "tid", "]", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", ",", "tid", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.cosine_similarity_selector_IQP_Exact": [[61, 116], ["x1.norm", "spa.csc_matrix.size", "spa.csc_matrix.double().numpy", "numpy.zeros", "numpy.ones", "numpy.eye", "numpy.zeros", "numpy.ones", "numpy.arange", "numpy.concatenate", "numpy.transpose", "numpy.concatenate", "numpy.concatenate", "scipy.csc_matrix", "scipy.csc_matrix", "solver.setup", "solver.solve", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.arange.size", "print", "torch.arange", "torch.arange", "torch.arange", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "numpy.zeros", "torch.Tensor", "torch.Tensor", "torch.Tensor", "sum", "torch.gt", "torch.gt", "torch.gt", "x1.size", "x2.t", "w2.t", "spa.csc_matrix.double", "torch.nonzero.squeeze"], "function", ["None"], ["", "", "def", "cosine_similarity_selector_IQP_Exact", "(", "x1", ",", "solver", ",", "nb_selected", ",", "eps", "=", "1e-3", ",", "slack", "=", "0.0", ",", "normalize", "=", "False", ",", "age", "=", "None", ",", "\n", "age_weight", "=", "-", "1", ")", ":", "\n", "    ", "\"\"\"\n    Integer programming\n    \"\"\"", "\n", "\n", "x2", "=", "None", "\n", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "gt", "(", "w1", ",", "slack", ")", ")", "[", ":", ",", "0", "]", "\n", "if", "inds", ".", "size", "(", "0", ")", "<", "nb_selected", ":", "\n", "        ", "print", "(", "\"WARNING GRADIENTS ARE TOO SMALL!!!!!!!!\"", ")", "\n", "inds", "=", "torch", ".", "arange", "(", "0", ",", "x1", ".", "size", "(", "0", ")", ")", "\n", "", "w1", "=", "w1", "[", "inds", "]", "\n", "x1", "=", "x1", "[", "inds", "]", "\n", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "G", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "# .clamp(min=eps)", "\n", "t", "=", "G", ".", "size", "(", "0", ")", "\n", "\n", "G", "=", "G", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "a", "=", "np", ".", "zeros", "(", "t", ")", "\n", "# a=np.ones(t)*-1", "\n", "\n", "# a=((w1-torch.min(w1))/(torch.max(w1)-torch.min(w1))).squeeze().double().numpy()*-0.01", "\n", "C", "=", "np", ".", "ones", "(", "(", "t", ",", "1", ")", ")", "\n", "h", "=", "np", ".", "zeros", "(", "1", ")", "+", "nb_selected", "\n", "C2", "=", "np", ".", "eye", "(", "t", ")", "\n", "\n", "hlower", "=", "np", ".", "zeros", "(", "t", ")", "\n", "hupper", "=", "np", ".", "ones", "(", "t", ")", "\n", "idx", "=", "np", ".", "arange", "(", "t", ")", "\n", "\n", "#################", "\n", "C", "=", "np", ".", "concatenate", "(", "(", "C2", ",", "C", ")", ",", "axis", "=", "1", ")", "\n", "C", "=", "np", ".", "transpose", "(", "C", ")", "\n", "h_final_lower", "=", "np", ".", "concatenate", "(", "(", "hlower", ",", "h", ")", ",", "axis", "=", "0", ")", "\n", "h_final_upper", "=", "np", ".", "concatenate", "(", "(", "hupper", ",", "h", ")", ",", "axis", "=", "0", ")", "\n", "#################", "\n", "G", "=", "spa", ".", "csc_matrix", "(", "G", ")", "\n", "\n", "C", "=", "spa", ".", "csc_matrix", "(", "C", ")", "\n", "\n", "solver", ".", "setup", "(", "G", ",", "a", ",", "C", ",", "h_final_lower", ",", "h_final_upper", ",", "idx", ",", "hlower", ",", "hupper", ",", "miosqp_settings", ",", "osqp_settings", ")", "\n", "results", "=", "solver", ".", "solve", "(", ")", "\n", "print", "(", "\"STATUS\"", ",", "results", ".", "status", ")", "\n", "coeffiecents_np", "=", "results", ".", "x", "\n", "coeffiecents", "=", "torch", ".", "nonzero", "(", "torch", ".", "Tensor", "(", "coeffiecents_np", ")", ")", "\n", "print", "(", "\"number of selected items is\"", ",", "sum", "(", "coeffiecents_np", ")", ")", "\n", "if", "\"Infeasible\"", "in", "results", ".", "status", ":", "\n", "        ", "return", "inds", "\n", "\n", "", "return", "inds", "[", "coeffiecents", ".", "squeeze", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.get_grad_vector": [[118, 132], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor.fill_", "pp", "sum", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["", "def", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n     gather the gradients in one vector\n    \"\"\"", "\n", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "grad_dims", ")", ")", "\n", "grads", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.add_memory_grad": [[134, 159], ["GSS_IQP_Rehearse.get_grad_vector", "grads.unsqueeze.unsqueeze", "grads.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "def", "add_memory_grad", "(", "pp", ",", "mem_grads", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This stores the gradient of a new memory and compute the dot product with the previously stored memories.\n        pp: parameters\n\n        mem_grads: gradients of previous memories\n        grad_dims: list with number of parameters per layers\n\n    \"\"\"", "\n", "\n", "# gather the gradient of the new memory", "\n", "grads", "=", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", "\n", "\n", "if", "mem_grads", "is", "None", ":", "\n", "\n", "        ", "mem_grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "mem_grads", "=", "torch", ".", "cat", "(", "(", "mem_grads", ",", "grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "return", "mem_grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.overwrite_grad": [[161, 178], ["pp", "sum", "newgrad[].contiguous().view", "param.grad.data.copy_", "sum", "param.grad.data.size", "newgrad[].contiguous"], "function", ["None"], ["", "def", "overwrite_grad", "(", "pp", ",", "newgrad", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This is used to overwrite the gradients with a new gradient\n        vector, whenever violations occur.\n        pp: parameters\n        newgrad: corrected gradient\n        grad_dims: list storing number of parameters at each layer\n    \"\"\"", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "this_grad", "=", "newgrad", "[", "beg", ":", "en", "]", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "param", ".", "grad", ".", "data", ".", "size", "(", ")", ")", "\n", "param", ".", "grad", ".", "data", ".", "copy_", "(", "this_grad", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_Rehearse.project2cone2": [[180, 201], ["memories.cpu().t().double().numpy", "gradient.cpu().contiguous().view().double().numpy", "numpy.dot", "numpy.eye", "gradient.copy_", "memories.cpu().t().double().numpy.transpose", "numpy.dot", "numpy.zeros", "quadprog.solve_qp", "numpy.dot", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "memories.cpu().t().double", "gradient.cpu().contiguous().view().double", "numpy.eye", "np.dot.transpose", "torch.Tensor", "torch.Tensor", "torch.Tensor", "memories.cpu().t", "gradient.cpu().contiguous().view", "memories.cpu", "gradient.cpu().contiguous", "gradient.cpu"], "function", ["None"], ["", "", "def", "project2cone2", "(", "gradient", ",", "memories", ",", "margin", "=", "0.5", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"\n        Solves the GEM dual QP described in the paper given a proposed\n        gradient \"gradient\", and a memory of task gradients \"memories\".\n        Overwrites \"gradient\" with the final projected update.\n        input:  gradient, p-vector\n        input:  memories, (t * p)-vector\n        output: x, p-vector\n    \"\"\"", "\n", "\n", "memories_np", "=", "memories", ".", "cpu", "(", ")", ".", "t", "(", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "gradient_np", "=", "gradient", ".", "cpu", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "t", "=", "memories_np", ".", "shape", "[", "0", "]", "\n", "P", "=", "np", ".", "dot", "(", "memories_np", ",", "memories_np", ".", "transpose", "(", ")", ")", "\n", "P", "=", "0.5", "*", "(", "P", "+", "P", ".", "transpose", "(", ")", ")", "+", "np", ".", "eye", "(", "t", ")", "*", "eps", "\n", "q", "=", "np", ".", "dot", "(", "memories_np", ",", "gradient_np", ")", "*", "-", "1", "\n", "G", "=", "np", ".", "eye", "(", "t", ")", "\n", "h", "=", "np", ".", "zeros", "(", "t", ")", "+", "margin", "\n", "v", "=", "quadprog", ".", "solve_qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "[", "0", "]", "\n", "x", "=", "np", ".", "dot", "(", "v", ",", "memories_np", ")", "+", "gradient_np", "\n", "gradient", ".", "copy_", "(", "torch", ".", "Tensor", "(", "x", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.MLP.__init__": [[24, 40], ["torch.Module.__init__", "range", "torch.Sequential", "torch.Sequential", "common.MLP.net.apply", "len", "layers.append", "layers.append", "layers.append", "len", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__"], ["    ", "def", "__init__", "(", "self", ",", "sizes", ",", "bias", "=", "True", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "layers", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "sizes", ")", "-", "1", ")", ":", "\n", "\n", "\n", "            ", "if", "i", "<", "(", "len", "(", "sizes", ")", "-", "2", ")", ":", "\n", "                ", "layers", ".", "append", "(", "nn", ".", "Linear", "(", "sizes", "[", "i", "]", ",", "sizes", "[", "i", "+", "1", "]", ")", ")", "\n", "\n", "layers", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "layers", ".", "append", "(", "nn", ".", "Linear", "(", "sizes", "[", "i", "]", ",", "sizes", "[", "i", "+", "1", "]", ",", "bias", "=", "bias", ")", ")", "\n", "\n", "", "", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "self", ".", "net", ".", "apply", "(", "Xavier", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.MLP.forward": [[41, 43], ["common.MLP.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "net", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.BasicBlock.__init__": [[53, 66], ["torch.Module.__init__", "common.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "common.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.conv3x3", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.conv3x3"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "in_planes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.BasicBlock.forward": [[68, 74], ["torch.nn.functional.relu", "torch.nn.functional.relu", "common.BasicBlock.bn2", "common.BasicBlock.shortcut", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.BasicBlock.bn1", "common.BasicBlock.conv2", "common.BasicBlock.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet.__init__": [[77, 89], ["torch.Module.__init__", "common.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "common.ResNet._make_layer", "common.ResNet._make_layer", "common.ResNet._make_layer", "common.ResNet._make_layer", "print", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.conv3x3", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet._make_layer", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet._make_layer", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet._make_layer", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "num_blocks", ",", "num_classes", ",", "nf", ",", "bias", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "nf", "\n", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "3", ",", "nf", "*", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "1", ",", "num_blocks", "[", "0", "]", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "2", ",", "num_blocks", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "4", ",", "num_blocks", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "8", ",", "num_blocks", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "print", "(", "\"BIAS IS\"", ",", "bias", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "nf", "*", "8", "*", "block", ".", "expansion", ",", "num_classes", ",", "bias", "=", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet._make_layer": [[91, 98], ["torch.Sequential", "torch.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet.forward": [[99, 110], ["x.size", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.ResNet.layer1", "common.ResNet.layer2", "common.ResNet.layer3", "common.ResNet.layer4", "torch.nn.functional.avg_pool2d", "torch.nn.functional.avg_pool2d", "common.ResNet.view", "common.ResNet.linear", "common.ResNet.bn1", "common.ResNet.size", "common.ResNet.conv1", "x.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "bsz", "=", "x", ".", "size", "(", "0", ")", "\n", "out", "=", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ".", "view", "(", "bsz", ",", "3", ",", "32", ",", "32", ")", ")", ")", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "self", ".", "layer4", "(", "out", ")", "\n", "out", "=", "avg_pool2d", "(", "out", ",", "4", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.Xavier": [[13, 21], ["m.weight.data.uniform_", "m.weight.data.size", "m.weight.data.size", "math.sqrt", "math.sqrt", "m.bias.data.fill_"], "function", ["None"], ["def", "Xavier", "(", "m", ")", ":", "\n", "    ", "if", "m", ".", "__class__", ".", "__name__", "==", "'Linear'", ":", "\n", "        ", "fan_in", ",", "fan_out", "=", "m", ".", "weight", ".", "data", ".", "size", "(", "1", ")", ",", "m", ".", "weight", ".", "data", ".", "size", "(", "0", ")", "\n", "std", "=", "1.0", "*", "math", ".", "sqrt", "(", "2.0", "/", "(", "fan_in", "+", "fan_out", ")", ")", "\n", "a", "=", "math", ".", "sqrt", "(", "3.0", ")", "*", "std", "\n", "m", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "a", ",", "a", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "            ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.conv3x3": [[45, 48], ["torch.Conv2d"], "function", ["None"], ["", "", "def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18": [[112, 114], ["common.ResNet"], "function", ["None"], ["", "", "def", "ResNet18", "(", "nclasses", ",", "nf", "=", "20", ",", "bias", "=", "True", ")", ":", "\n", "    ", "return", "ResNet", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "nclasses", ",", "nf", ",", "bias", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.Net.__init__": [[320, 376], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "rehearse_per_batch_rand.Net.parameters", "common.ResNet18", "common.MLP", "rehearse_per_batch_rand.Net.parameters", "rehearse_per_batch_rand.Net.memory_data.cuda", "rehearse_per_batch_rand.Net.memory_labs.cuda", "rehearse_per_batch_rand.Net.grad_dims.append", "param.data.numel"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "n_sampled_memories", "=", "args", ".", "n_sampled_memories", "\n", "self", ".", "n_constraints", "=", "args", ".", "n_constraints", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "\n", "\n", "# allocate ring buffer", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "self", ".", "n_memories", ")", "\n", "# allocate  selected  memory", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "self", ".", "sampled_memory_taskids", "=", "None", "\n", "# allocate selected constraints", "\n", "self", ".", "constraints_data", "=", "None", "\n", "self", ".", "constraints_labs", "=", "None", "\n", "self", ".", "subselect", "=", "args", ".", "subselect", "# first select from recent memory and then add to samples memories", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.Net.forward": [[377, 382], ["rehearse_per_batch_rand.Net.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", "=", "0", ")", ":", "\n", "# t is there to be used by the main caller", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.Net.select_random_samples": [[383, 414], ["torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "torch.randint().squeeze", "print", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze", "[].unsqueeze"], "methods", ["None"], ["", "def", "select_random_samples", "(", "self", ",", "task", ")", ":", "\n", "        ", "\"\"\"\n        To estimate the effectiveness of selecting random samples instead of using our strategy\n\n        \"\"\"", "\n", "#         import random", "\n", "#         seed=0", "\n", "#         torch.backends.cudnn.enabled = False", "\n", "#         torch.manual_seed(seed)", "\n", "#         np.random.seed(seed)", "\n", "#         random.seed(seed)", "\n", "inds", "=", "torch", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "self", ".", "n_memories", ",", "size", "=", "(", "self", ".", "n_sampled_memories", ",", "1", ")", ")", ".", "squeeze", "(", ")", "\n", "\n", "task", "=", "0", "\n", "self", ".", "mem_grads", "=", "None", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "for", "index", "in", "inds", ":", "\n", "            ", "task", "=", "index", "/", "self", ".", "n_memories", "\n", "task_index", "=", "index", "%", "self", ".", "n_memories", "\n", "if", "not", "self", ".", "sampled_memory_data", "is", "None", ":", "\n", "\n", "                ", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "\n", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "memory_data", "[", "task", "]", "[", "task_index", "]", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "\n", "(", "self", ".", "sampled_memory_labs", ",", "self", ".", "memory_labs", "[", "task", "]", "[", "task_index", "]", ".", "unsqueeze", "(", "0", ")", ")", ",", "dim", "=", "0", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "sampled_memory_data", "=", "self", ".", "memory_data", "[", "task", "]", "[", "task_index", "]", ".", "unsqueeze", "(", "0", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "memory_labs", "[", "task", "]", "[", "task_index", "]", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "", "", "print", "(", "\"selected labels are\"", ",", "self", ".", "sampled_memory_labs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.Net.print_taskids_stats": [[416, 422], ["torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "range", "print", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq"], "methods", ["None"], ["", "def", "print_taskids_stats", "(", "self", ",", "task", ")", ":", "\n", "\n", "        ", "tasks", "=", "torch", ".", "unique", "(", "self", ".", "sampled_memory_taskids", ")", "\n", "for", "t", "in", "range", "(", "task", "+", "1", ")", ":", "\n", "\n", "            ", "print", "(", "'task number '", ",", "t", ",", "'samples in buffer'", ",", "torch", ".", "eq", "(", "self", ".", "sampled_memory_taskids", ",", "t", ")", ".", "nonzero", "(", ")", ".", "size", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.Net.observe": [[432, 487], ["y.data.size", "min", "rehearse_per_batch_rand.Net.memory_data[].copy_", "range", "rehearse_per_batch_rand.Net.memory_labs[].copy_", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "min", "rehearse_per_batch_rand.Net.zero_grad", "rehearse_per_batch_rand.Net.ce", "rehearse_per_batch_rand.Net.backward", "rehearse_per_batch_rand.Net.opt.step", "print", "rehearse_per_batch_rand.Net.select_samples_per_group", "rehearse_per_batch_rand.Net.sampled_memory_labs.size", "rehearse_per_batch_rand.Net.sampled_memory_labs.size", "rehearse_per_batch_rand.Net.forward", "rehearse_per_batch_rand.Net.zero_grad", "rehearse_per_batch_rand.Net.ce", "rehearse_per_batch_rand.Net.backward", "rehearse_per_batch_rand.Net.opt.step", "rehearse_per_batch_rand.Net.forward", "rehearse_per_batch_rand.Net.sampled_memory_labs.size"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.select_samples_per_group", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "# temp", "\n", "# we dont use t :)", "\n", "\n", "# Update ring buffer storing examples from current task", "\n", "        ", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "\n", "# self.select_random_samples_per_group()", "\n", "# self.select_random_samples_per_group()", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "            ", "shuffeled_inds", "=", "torch", ".", "randperm", "(", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "effective_batch_size", "=", "min", "(", "self", ".", "n_constraints", ",", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "b_index", "=", "0", "\n", "", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "\n", "# get gradients on previous constraints", "\n", "\n", "# now compute the grad on the current minibatch", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ")", ",", "y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "\n", "#print(random_batch_inds)", "\n", "                ", "random_batch_inds", "=", "shuffeled_inds", "[", "b_index", "*", "effective_batch_size", ":", "b_index", "*", "effective_batch_size", "+", "effective_batch_size", "]", "\n", "batch_x", "=", "self", ".", "sampled_memory_data", "[", "random_batch_inds", "]", "\n", "batch_y", "=", "self", ".", "sampled_memory_labs", "[", "random_batch_inds", "]", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "batch_x", ")", ",", "batch_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "b_index", "+=", "1", "\n", "if", "b_index", "*", "effective_batch_size", ">=", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ":", "\n", "                    ", "b_index", "=", "0", "\n", "", "", "", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "print", "(", "\"ring buffer is full, re-estimating of the constrains, we are at task\"", ",", "t", ")", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "self", ".", "cosine_sim", "=", "[", "1", "]", "*", "self", ".", "n_constraints", "\n", "self", ".", "select_samples_per_group", "(", "t", ")", "", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.compute_offsets": [[41, 53], ["None"], "function", ["None"], ["def", "compute_offsets", "(", "task", ",", "nc_per_task", ",", "is_cifar", ")", ":", "\n", "    ", "\"\"\"\n        Compute offsets for cifar to determine which\n        outputs to select for a given task.\n    \"\"\"", "\n", "if", "is_cifar", ":", "\n", "        ", "offset1", "=", "task", "*", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "nc_per_task", "\n", "", "else", ":", "\n", "        ", "offset1", "=", "0", "\n", "offset2", "=", "nc_per_task", "\n", "", "return", "offset1", ",", "offset2", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.store_grad": [[55, 72], ["grads[].fill_", "pp", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["", "def", "store_grad", "(", "pp", ",", "grads", ",", "grad_dims", ",", "tid", ")", ":", "\n", "    ", "\"\"\"\n        This stores parameter gradients of past tasks.\n        pp: parameters\n        grads: gradients\n        grad_dims: list with number of parameters per layers\n        tid: task id\n    \"\"\"", "\n", "# store the gradients", "\n", "grads", "[", ":", ",", "tid", "]", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", ",", "tid", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.cosine_similarity_selector_QP": [[74, 111], ["x1.norm", "G.double().numpy.size", "G.double().numpy.double().numpy", "numpy.ones", "numpy.ones", "numpy.eye", "numpy.zeros", "numpy.concatenate", "numpy.concatenate", "torch.tensor", "torch.tensor", "torch.tensor", "torch.sort", "torch.sort", "torch.sort", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "numpy.zeros", "numpy.eye", "numpy.ones", "quadprog.solve_qp", "x2.t", "w2.t", "G.double().numpy.double", "numpy.eye"], "function", ["None"], ["", "", "def", "cosine_similarity_selector_QP", "(", "x1", ",", "nb_selected", "=", "16", ",", "eps", "=", "1e-3", ")", ":", "\n", "# x1=gradient memories", "\n", "\n", "    ", "x2", "=", "None", "\n", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "G", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "# .clamp(min=eps)", "\n", "# G=torch.mm(Gr,Gr.t())#cosine_similarity(G)", "\n", "\n", "t", "=", "G", ".", "size", "(", "0", ")", "\n", "G", "=", "G", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "G", "=", "G", "+", "np", ".", "eye", "(", "t", ")", "*", "eps", "\n", "# G = 0.5 * (G + G.transpose()) +np.eye(t) * eps", "\n", "# a=np.zeros(t)", "\n", "a", "=", "np", ".", "ones", "(", "t", ")", "\n", "C", "=", "np", ".", "ones", "(", "(", "t", ",", "1", ")", ")", "\n", "h", "=", "np", ".", "zeros", "(", "1", ")", "+", "nb_selected", "\n", "# constraints for no smaller than zero coeffiecent", "\n", "C2", "=", "np", ".", "eye", "(", "t", ")", "\n", "h2", "=", "np", ".", "zeros", "(", "t", ")", "\n", "# constraints for no larger than one coeffiecent", "\n", "C3", "=", "np", ".", "eye", "(", "t", ")", "*", "-", "1", "\n", "h3", "=", "np", ".", "ones", "(", "t", ")", "*", "-", "1", "\n", "C", "=", "np", ".", "concatenate", "(", "(", "C2", ",", "C3", ")", ",", "axis", "=", "1", ")", "\n", "\n", "h", "=", "np", ".", "concatenate", "(", "(", "h2", ",", "h3", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# np.concatenate((a, b), axis=0)", "\n", "# coeffiecents_np = quadprog.solve_qp(G, a, C2, h2)[0]", "\n", "# add a constraint to be at max 1", "\n", "coeffiecents_np", "=", "quadprog", ".", "solve_qp", "(", "G", ",", "a", ",", "C", ",", "h", ")", "[", "0", "]", "\n", "\n", "coeffiecents", "=", "torch", ".", "tensor", "(", "coeffiecents_np", ")", "\n", "\n", "_", ",", "inds", "=", "torch", ".", "sort", "(", "coeffiecents", ",", "descending", "=", "True", ")", "\n", "return", "inds", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.cosine_similarity_selector_IQP_Exact": [[113, 170], ["x1.norm", "print", "spa.csc_matrix.size", "spa.csc_matrix.double().numpy", "numpy.zeros", "numpy.ones", "numpy.eye", "numpy.zeros", "numpy.ones", "numpy.arange", "numpy.concatenate", "numpy.transpose", "numpy.concatenate", "numpy.concatenate", "scipy.csc_matrix", "scipy.csc_matrix", "solver.setup", "solver.solve", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.arange.size", "print", "torch.arange", "torch.arange", "torch.arange", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "numpy.zeros", "torch.Tensor", "torch.Tensor", "torch.Tensor", "sum", "torch.gt", "torch.gt", "torch.gt", "x1.norm.size", "torch.arange.size", "x1.size", "x2.t", "w2.t", "spa.csc_matrix.double", "torch.nonzero.squeeze"], "function", ["None"], ["", "def", "cosine_similarity_selector_IQP_Exact", "(", "x1", ",", "solver", ",", "nb_selected", ",", "eps", "=", "1e-3", ",", "slack", "=", "0.01", ")", ":", "\n", "    ", "\"\"\"\n    Integer programming\n    \"\"\"", "\n", "\n", "# x1=gradient memories", "\n", "\n", "x2", "=", "None", "\n", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "gt", "(", "w1", ",", "slack", ")", ")", "[", ":", ",", "0", "]", "\n", "print", "(", "\"removed due to gradients\"", ",", "w1", ".", "size", "(", "0", ")", "-", "inds", ".", "size", "(", "0", ")", ")", "\n", "if", "inds", ".", "size", "(", "0", ")", "<", "nb_selected", ":", "\n", "        ", "print", "(", "\"WARNING GRADIENTS ARE TOO SMALL!!!!!!!!\"", ")", "\n", "inds", "=", "torch", ".", "arange", "(", "0", ",", "x1", ".", "size", "(", "0", ")", ")", "\n", "", "w1", "=", "w1", "[", "inds", "]", "\n", "x1", "=", "x1", "[", "inds", "]", "\n", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "G", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "# .clamp(min=eps)", "\n", "t", "=", "G", ".", "size", "(", "0", ")", "\n", "\n", "G", "=", "G", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "a", "=", "np", ".", "zeros", "(", "t", ")", "\n", "# a=np.ones(t)*-1", "\n", "\n", "# a=((w1-torch.min(w1))/(torch.max(w1)-torch.min(w1))).squeeze().double().numpy()*-0.01", "\n", "C", "=", "np", ".", "ones", "(", "(", "t", ",", "1", ")", ")", "\n", "h", "=", "np", ".", "zeros", "(", "1", ")", "+", "nb_selected", "\n", "C2", "=", "np", ".", "eye", "(", "t", ")", "\n", "\n", "hlower", "=", "np", ".", "zeros", "(", "t", ")", "\n", "hupper", "=", "np", ".", "ones", "(", "t", ")", "\n", "idx", "=", "np", ".", "arange", "(", "t", ")", "\n", "\n", "#################", "\n", "C", "=", "np", ".", "concatenate", "(", "(", "C2", ",", "C", ")", ",", "axis", "=", "1", ")", "\n", "C", "=", "np", ".", "transpose", "(", "C", ")", "\n", "h_final_lower", "=", "np", ".", "concatenate", "(", "(", "hlower", ",", "h", ")", ",", "axis", "=", "0", ")", "\n", "h_final_upper", "=", "np", ".", "concatenate", "(", "(", "hupper", ",", "h", ")", ",", "axis", "=", "0", ")", "\n", "#################", "\n", "G", "=", "spa", ".", "csc_matrix", "(", "G", ")", "\n", "\n", "C", "=", "spa", ".", "csc_matrix", "(", "C", ")", "\n", "\n", "solver", ".", "setup", "(", "G", ",", "a", ",", "C", ",", "h_final_lower", ",", "h_final_upper", ",", "idx", ",", "hlower", ",", "hupper", ",", "miosqp_settings", ",", "osqp_settings", ")", "\n", "results", "=", "solver", ".", "solve", "(", ")", "\n", "print", "(", "\"STATUS\"", ",", "results", ".", "status", ")", "\n", "coeffiecents_np", "=", "results", ".", "x", "\n", "coeffiecents", "=", "torch", ".", "nonzero", "(", "torch", ".", "Tensor", "(", "coeffiecents_np", ")", ")", "\n", "print", "(", "\"number of selected items is\"", ",", "sum", "(", "coeffiecents_np", ")", ")", "\n", "if", "\"Infeasible\"", "in", "results", ".", "status", ":", "\n", "        ", "return", "inds", "\n", "\n", "", "return", "inds", "[", "coeffiecents", ".", "squeeze", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.cosine_similarity_selector_IQP": [[172, 232], ["x1.norm", "spa.csc_matrix.size", "spa.csc_matrix.double().numpy", "numpy.eye", "numpy.zeros", "numpy.ones", "numpy.arange", "scipy.csc_matrix", "scipy.csc_matrix", "solver.setup", "solver.solve", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "numpy.ones", "torch.Tensor", "torch.Tensor", "torch.Tensor", "sum", "torch.gt", "torch.gt", "torch.gt", "x2.t", "w2.t", "spa.csc_matrix.double", "torch.nonzero.squeeze"], "function", ["None"], ["", "def", "cosine_similarity_selector_IQP", "(", "x1", ",", "solver", ",", "nb_selected", ",", "eps", "=", "1e-3", ",", "slack", "=", "0.01", ")", ":", "\n", "    ", "\"\"\"\n    Integer programming\n    \"\"\"", "\n", "\n", "# x1=gradient memories", "\n", "\n", "x2", "=", "None", "\n", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "gt", "(", "w1", ",", "slack", ")", ")", "[", ":", ",", "0", "]", "\n", "\n", "w1", "=", "w1", "[", "inds", "]", "\n", "x1", "=", "x1", "[", "inds", "]", "\n", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "G", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "# .clamp(min=eps)", "\n", "t", "=", "G", ".", "size", "(", "0", ")", "\n", "# a=torch.sum(G-torch.eye(t),1)/(t-1)*-0.1", "\n", "# a=torch.max(G-torch.eye(t),1)[0]*-0.1", "\n", "# a=a.double().numpy()", "\n", "\n", "G", "=", "G", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "# G=G+ np.eye(t) * eps", "\n", "# G = 0.5 * (G + G.transpose()) +np.eye(t) * eps", "\n", "# a=(w1*-1).view(t).numpy()", "\n", "# a=np.zeros(t)", "\n", "a", "=", "np", ".", "ones", "(", "t", ")", "*", "-", "1", "\n", "\n", "# a=((w1-torch.min(w1))/(torch.max(w1)-torch.min(w1))).squeeze().double().numpy()*-0.01", "\n", "\n", "# h = np.zeros(1) + nb_selected", "\n", "C2", "=", "np", ".", "eye", "(", "t", ")", "\n", "\n", "hlower", "=", "np", ".", "zeros", "(", "t", ")", "\n", "hupper", "=", "np", ".", "ones", "(", "t", ")", "\n", "idx", "=", "np", ".", "arange", "(", "t", ")", "\n", "# np.concatenate((a, b), axis=0)", "\n", "\n", "#################", "\n", "# C=np.concatenate((C2, C), axis=1)", "\n", "# C=np.transpose(C)", "\n", "\n", "# h_final_lower=np.concatenate((hlower,h), axis=0)", "\n", "# h_final_upper=np.concatenate((hupper,h), axis=0)", "\n", "#################", "\n", "G", "=", "spa", ".", "csc_matrix", "(", "G", ")", "\n", "\n", "C2", "=", "spa", ".", "csc_matrix", "(", "C2", ")", "\n", "\n", "solver", ".", "setup", "(", "G", ",", "a", ",", "C2", ",", "hlower", ",", "hupper", ",", "idx", ",", "hlower", ",", "hupper", ",", "miosqp_settings", ",", "osqp_settings", ")", "\n", "results", "=", "solver", ".", "solve", "(", ")", "\n", "print", "(", "\"STATUS\"", ",", "results", ".", "status", ")", "\n", "coeffiecents_np", "=", "results", ".", "x", "\n", "coeffiecents", "=", "torch", ".", "nonzero", "(", "torch", ".", "Tensor", "(", "coeffiecents_np", ")", ")", "\n", "print", "(", "\"number of selected items is\"", ",", "sum", "(", "coeffiecents_np", ")", ")", "\n", "# _,inds=torch.sort(coeffiecents,descending=True)", "\n", "\n", "return", "inds", "[", "coeffiecents", ".", "squeeze", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.get_grad_vector": [[234, 248], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor.fill_", "pp", "sum", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["", "def", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n     gather the gradients in one vector\n    \"\"\"", "\n", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "grad_dims", ")", ")", "\n", "grads", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.add_memory_grad": [[250, 275], ["rehearse_per_batch_rand.get_grad_vector", "grads.unsqueeze.unsqueeze", "grads.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "def", "add_memory_grad", "(", "pp", ",", "mem_grads", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This stores the gradient of a new memory and compute the dot product with the previously stored memories.\n        pp: parameters\n\n        mem_grads: gradients of previous memories\n        grad_dims: list with number of parameters per layers\n\n    \"\"\"", "\n", "\n", "# gather the gradient of the new memory", "\n", "grads", "=", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", "\n", "\n", "if", "mem_grads", "is", "None", ":", "\n", "\n", "        ", "mem_grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "mem_grads", "=", "torch", ".", "cat", "(", "(", "mem_grads", ",", "grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "return", "mem_grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.overwrite_grad": [[277, 294], ["pp", "sum", "newgrad[].contiguous().view", "param.grad.data.copy_", "sum", "param.grad.data.size", "newgrad[].contiguous"], "function", ["None"], ["", "def", "overwrite_grad", "(", "pp", ",", "newgrad", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This is used to overwrite the gradients with a new gradient\n        vector, whenever violations occur.\n        pp: parameters\n        newgrad: corrected gradient\n        grad_dims: list storing number of parameters at each layer\n    \"\"\"", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "this_grad", "=", "newgrad", "[", "beg", ":", "en", "]", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "param", ".", "grad", ".", "data", ".", "size", "(", ")", ")", "\n", "param", ".", "grad", ".", "data", ".", "copy_", "(", "this_grad", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.rehearse_per_batch_rand.project2cone2": [[296, 317], ["memories.cpu().t().double().numpy", "gradient.cpu().contiguous().view().double().numpy", "numpy.dot", "numpy.eye", "gradient.copy_", "memories.cpu().t().double().numpy.transpose", "numpy.dot", "numpy.zeros", "quadprog.solve_qp", "numpy.dot", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "memories.cpu().t().double", "gradient.cpu().contiguous().view().double", "numpy.eye", "np.dot.transpose", "torch.Tensor", "torch.Tensor", "torch.Tensor", "memories.cpu().t", "gradient.cpu().contiguous().view", "memories.cpu", "gradient.cpu().contiguous", "gradient.cpu"], "function", ["None"], ["", "", "def", "project2cone2", "(", "gradient", ",", "memories", ",", "margin", "=", "0.5", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"\n        Solves the GEM dual QP described in the paper given a proposed\n        gradient \"gradient\", and a memory of task gradients \"memories\".\n        Overwrites \"gradient\" with the final projected update.\n        input:  gradient, p-vector\n        input:  memories, (t * p)-vector\n        output: x, p-vector\n    \"\"\"", "\n", "\n", "memories_np", "=", "memories", ".", "cpu", "(", ")", ".", "t", "(", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "gradient_np", "=", "gradient", ".", "cpu", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "t", "=", "memories_np", ".", "shape", "[", "0", "]", "\n", "P", "=", "np", ".", "dot", "(", "memories_np", ",", "memories_np", ".", "transpose", "(", ")", ")", "\n", "P", "=", "0.5", "*", "(", "P", "+", "P", ".", "transpose", "(", ")", ")", "+", "np", ".", "eye", "(", "t", ")", "*", "eps", "\n", "q", "=", "np", ".", "dot", "(", "memories_np", ",", "gradient_np", ")", "*", "-", "1", "\n", "G", "=", "np", ".", "eye", "(", "t", ")", "\n", "h", "=", "np", ".", "zeros", "(", "t", ")", "+", "margin", "\n", "v", "=", "quadprog", ".", "solve_qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "[", "0", "]", "\n", "x", "=", "np", ".", "dot", "(", "v", ",", "memories_np", ")", "+", "gradient_np", "\n", "gradient", ".", "copy_", "(", "torch", ".", "Tensor", "(", "x", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.__init__": [[70, 129], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "GSS_Greedy.Net.parameters", "common.ResNet18", "common.MLP", "GSS_Greedy.Net.parameters", "GSS_Greedy.Net.memory_data.cuda", "GSS_Greedy.Net.memory_labs.cuda", "GSS_Greedy.Net.grad_dims.append", "param.data.numel"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "rn", "=", "args", ".", "memory_strength", "# n the number of gradient vectors to estimate new samples similarity, line 5 in alg.2", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "# auxiliary storage before deciding samples to the buffer,", "\n", "# if this is equal to the batch size, then every batch the method decides which samples to add to the buffer.", "\n", "self", ".", "n_sampled_memories", "=", "args", ".", "n_sampled_memories", "#buffer size, M", "\n", "self", ".", "n_constraints", "=", "args", ".", "n_constraints", "#n_samples to be replayed from the buffer at each time a new batch is recieved, default equal to batch size", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "#number of iteraions (update steps) for each recieved batch", "\n", "self", ".", "sim_th", "=", "args", ".", "change_th", "# cosine similarity threshold for being a candidate for buffer entrance", "\n", "# allocate ring buffer (default new batch size)", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "self", ".", "n_memories", ")", "\n", "\n", "self", ".", "added_index", "=", "self", ".", "n_sampled_memories", "\n", "# allocate  buffer", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "\n", "self", ".", "sampled_memory_cos", "=", "None", "# buffer cosine similarity score", "\n", "self", ".", "subselect", "=", "args", ".", "subselect", "# for estimating new samples score, draw samples in batch of size subselect", "\n", "# allocate selected constraints", "\n", "\n", "\n", "\n", "# old grads to measure changes", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.forward": [[132, 137], ["GSS_Greedy.Net.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", "=", "0", ")", ":", "\n", "# t is there to be used by the main caller", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.cosine_similarity": [[143, 151], ["x1.norm", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "x2.t", "w2.t"], "methods", ["None"], ["", "def", "cosine_similarity", "(", "self", ",", "x1", ",", "x2", "=", "None", ",", "eps", "=", "1e-8", ")", ":", "\n", "        ", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "sim", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "#, w1  # .clamp(min=eps), 1/cosinesim", "\n", "\n", "return", "sim", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.print_taskids_stats": [[156, 162], ["torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "range", "torch.unique.size", "torch.unique.size", "torch.unique.size", "print", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero().size", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq().nonzero", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq"], "methods", ["None"], ["", "def", "print_taskids_stats", "(", "self", ")", ":", "\n", "\n", "        ", "tasks", "=", "torch", ".", "unique", "(", "self", ".", "sampled_memory_taskids", ")", "\n", "for", "t", "in", "range", "(", "tasks", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "            ", "print", "(", "'task number '", ",", "tasks", "[", "t", "]", ",", "'samples in buffer'", ",", "torch", ".", "eq", "(", "self", ".", "sampled_memory_taskids", ",", "tasks", "[", "t", "]", ")", ".", "nonzero", "(", ")", ".", "size", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.observe": [[169, 293], ["y.data.size", "min", "GSS_Greedy.Net.memory_data[].copy_", "range", "GSS_Greedy.Net.memory_labs[].copy_", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "min", "GSS_Greedy.Net.zero_grad", "GSS_Greedy.Net.ce", "GSS_Greedy.Net.backward", "get_grad_vector().unsqueeze", "GSS_Greedy.Net.opt.step", "GSS_Greedy.Net.eval", "GSS_Greedy.Net.print_taskids_stats", "GSS_Greedy.Net.train", "GSS_Greedy.Net.sampled_memory_labs.size", "GSS_Greedy.Net.sampled_memory_labs.size", "GSS_Greedy.Net.forward", "GSS_Greedy.Net.zero_grad", "GSS_Greedy.Net.ce", "GSS_Greedy.Net.backward", "GSS_Greedy.Net.opt.step", "GSS_Greedy.Net.get_batch_sim", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "GSS_Greedy.get_grad_vector", "GSS_Greedy.Net.forward", "GSS_Greedy.Net.sampled_memory_labs.size", "GSS_Greedy.Net.sampled_memory_data.size", "x.clone", "y.clone", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "GSS_Greedy.Net.get_each_batch_sample_sim", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.multinomial.squeeze().byte", "torch.multinomial.squeeze().byte", "torch.multinomial.squeeze().byte", "mem_data[].clone", "mem_lab[].clone", "batch_item_sim[].clone", "GSS_Greedy.Net.memory_data.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "GSS_Greedy.Net.memory_data[].clone", "GSS_Greedy.Net.memory_labs[].clone", "new_task_ids.clone", "GSS_Greedy.Net.get_batch_sim", "GSS_Greedy.Net.get_each_batch_sample_sim().clone", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "x.clone.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.arange.size", "torch.arange.size", "torch.arange.size", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "GSS_Greedy.Net.size", "torch.multinomial.squeeze", "torch.multinomial.squeeze", "torch.multinomial.squeeze", "torch.arange.size", "torch.arange.size", "torch.arange.size", "GSS_Greedy.Net.get_each_batch_sample_sim", "GSS_Greedy.Net.clone", "GSS_Greedy.Net.memory_data[].clone", "GSS_Greedy.Net.memory_labs[].clone", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.print_taskids_stats", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.get_batch_sim", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.get_each_batch_sample_sim", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.get_batch_sim", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.get_each_batch_sample_sim"], ["", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "# temp", "\n", "# we dont really use it :) in the greedy variant", "\n", "\n", "# Update ring buffer storing examples from current task, equals to batch size", "\n", "        ", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "\n", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "#shuffle buffer, determine batch size of buffer sampled memories", "\n", "            ", "shuffeled_inds", "=", "torch", ".", "randperm", "(", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "effective_batch_size", "=", "min", "(", "self", ".", "n_constraints", ",", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "b_index", "=", "0", "\n", "#gradients of used buffer samples", "\n", "", "self", ".", "mem_grads", "=", "None", "\n", "\n", "this_sim", "=", "0", "\n", "\n", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "#numbrt of iterations over a given batch of samples, i.e. number of update steps", "\n", "\n", "\n", "\n", "# now compute the grad on the current minibatch and perform update step on the newly recieved batch", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ")", ",", "y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "this_grad", "=", "get_grad_vector", "(", "self", ".", "parameters", ",", "self", ".", "grad_dims", ")", ".", "unsqueeze", "(", "0", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "#update steps on the replayed sampels from buffer, we only draw once", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "\n", "#print(random_batch_inds)", "\n", "                ", "random_batch_inds", "=", "shuffeled_inds", "[", "b_index", "*", "effective_batch_size", ":", "b_index", "*", "effective_batch_size", "+", "effective_batch_size", "]", "\n", "batch_x", "=", "self", ".", "sampled_memory_data", "[", "random_batch_inds", "]", "\n", "batch_y", "=", "self", ".", "sampled_memory_labs", "[", "random_batch_inds", "]", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "batch_x", ")", ",", "batch_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "b_index", "+=", "1", "\n", "if", "b_index", "*", "effective_batch_size", ">=", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ":", "\n", "                    ", "b_index", "=", "0", "\n", "\n", "\n", "##HERE MEMORY IS EQUAL TO THE BATCH SIZE, this procedure is performed for every recieved batch", "\n", "", "", "", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "eval", "(", ")", "\n", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", "and", "self", ".", "n_sampled_memories", "<=", "self", ".", "sampled_memory_data", ".", "size", "(", "0", ")", ":", "#buffer is full", "\n", "\n", "\n", "                ", "batch_sim", "=", "self", ".", "get_batch_sim", "(", "effective_batch_size", ")", "#estimate similarity score for the recieved samples to randomly drawn samples from buffer", "\n", "# for effecency we estimate the similarity for the whole batch", "\n", "\n", "if", "(", "batch_sim", ")", "<", "self", ".", "sim_th", ":", "\n", "\n", "\n", "                    ", "mem_data", "=", "x", ".", "clone", "(", ")", "\n", "mem_lab", "=", "y", ".", "clone", "(", ")", "\n", "\n", "\n", "buffer_sim", "=", "(", "self", ".", "sampled_memory_cos", "-", "torch", ".", "min", "(", "self", ".", "sampled_memory_cos", ")", ")", "/", "(", "(", "torch", ".", "max", "(", "self", ".", "sampled_memory_cos", ")", "-", "torch", ".", "min", "(", "self", ".", "sampled_memory_cos", ")", ")", "+", "0.01", ")", "\n", "\n", "index", "=", "torch", ".", "multinomial", "(", "buffer_sim", ",", "mem_data", ".", "size", "(", "0", ")", ",", "replacement", "=", "False", ")", "#draw candidates for replacement from the buffer", "\n", "\n", "batch_item_sim", "=", "self", ".", "get_each_batch_sample_sim", "(", ")", "# estimate the similarity of each sample in the recieved batch to the randomly drawn samples from the buffer.", "\n", "scaled_batch_item_sim", "=", "(", "(", "batch_item_sim", "+", "1", ")", "/", "2", ")", ".", "unsqueeze", "(", "1", ")", ".", "clone", "(", ")", "\n", "buffer_repl_batch_sim", "=", "(", "(", "self", ".", "sampled_memory_cos", "[", "index", "]", "+", "1", ")", "/", "2", ")", ".", "unsqueeze", "(", "1", ")", ".", "clone", "(", ")", "\n", "#draw an event to decide on replacement decision", "\n", "outcome", "=", "torch", ".", "multinomial", "(", "torch", ".", "cat", "(", "(", "scaled_batch_item_sim", ",", "buffer_repl_batch_sim", ")", ",", "dim", "=", "1", ")", ",", "1", ",", "replacement", "=", "False", ")", "#", "\n", "#replace samples with outcome =1", "\n", "added_indx", "=", "torch", ".", "arange", "(", "end", "=", "batch_item_sim", ".", "size", "(", "0", ")", ")", "\n", "sub_index", "=", "outcome", ".", "squeeze", "(", "1", ")", ".", "byte", "(", ")", "\n", "self", ".", "sampled_memory_data", "[", "index", "[", "sub_index", "]", "]", "=", "mem_data", "[", "added_indx", "[", "sub_index", "]", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "[", "index", "[", "sub_index", "]", "]", "=", "mem_lab", "[", "added_indx", "[", "sub_index", "]", "]", ".", "clone", "(", ")", "\n", "\n", "self", ".", "sampled_memory_cos", "[", "index", "[", "sub_index", "]", "]", "=", "batch_item_sim", "[", "added_indx", "[", "sub_index", "]", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_taskids", "[", "index", "[", "sub_index", "]", "]", "=", "t", "\n", "\n", "\n", "\n", "", "", "else", ":", "\n", "#add new samples to the buffer", "\n", "                ", "added_inds", "=", "torch", ".", "arange", "(", "0", ",", "self", ".", "memory_data", ".", "size", "(", "0", ")", ")", "\n", "\n", "new_task_ids", "=", "torch", ".", "zeros", "(", "added_inds", ".", "size", "(", "0", ")", ")", "+", "t", "\n", "#first buffer insertion", "\n", "if", "self", ".", "sampled_memory_data", "is", "None", ":", "\n", "\n", "                    ", "self", ".", "sampled_memory_data", "=", "self", ".", "memory_data", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "memory_labs", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_taskids", "=", "new_task_ids", ".", "clone", "(", ")", "\n", "\n", "self", ".", "sampled_memory_cos", "=", "torch", ".", "zeros", "(", "added_inds", ".", "size", "(", "0", ")", ")", "+", "0.1", "\n", "", "else", ":", "\n", "                    ", "self", ".", "get_batch_sim", "(", "effective_batch_size", ")", "#draw random samples from buffer", "\n", "this_sampled_memory_cos", "=", "self", ".", "get_each_batch_sample_sim", "(", ")", ".", "clone", "(", ")", "#estimate a score for each added sample", "\n", "self", ".", "sampled_memory_cos", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_cos", ",", "this_sampled_memory_cos", ".", "clone", "(", ")", ")", ",", "\n", "dim", "=", "0", ")", "\n", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "memory_data", "[", "added_inds", "]", ".", "clone", "(", ")", ")", ",", "dim", "=", "0", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_labs", ",", "self", ".", "memory_labs", "[", "added_inds", "]", ".", "clone", "(", ")", ")", ",", "dim", "=", "0", ")", "\n", "self", ".", "sampled_memory_taskids", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_taskids", ",", "new_task_ids", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "\n", "\n", "\n", "", "", "self", ".", "print_taskids_stats", "(", ")", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.get_batch_sim": [[294, 322], ["torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "range", "GSS_Greedy.Net.zero_grad", "GSS_Greedy.Net.ce", "GSS_Greedy.Net.backward", "get_grad_vector().unsqueeze", "max", "GSS_Greedy.Net.sampled_memory_labs.size", "int", "GSS_Greedy.Net.zero_grad", "GSS_Greedy.Net.ce", "GSS_Greedy.Net.backward", "GSS_Greedy.add_memory_grad", "GSS_Greedy.Net.forward", "GSS_Greedy.Net.cosine_similarity", "GSS_Greedy.Net.forward", "GSS_Greedy.Net.sampled_memory_labs.size", "GSS_Greedy.get_grad_vector"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "", "def", "get_batch_sim", "(", "self", ",", "effective_batch_size", ")", ":", "\n", "\n", "        ", "b_index", "=", "0", "\n", "self", ".", "mem_grads", "=", "None", "\n", "shuffeled_inds", "=", "torch", ".", "randperm", "(", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "\n", "for", "iter_i", "in", "range", "(", "int", "(", "self", ".", "rn", ")", ")", ":", "\n", "\n", "            ", "random_batch_inds", "=", "shuffeled_inds", "[", "\n", "b_index", "*", "effective_batch_size", ":", "b_index", "*", "effective_batch_size", "+", "effective_batch_size", "]", "\n", "batch_x", "=", "self", ".", "sampled_memory_data", "[", "random_batch_inds", "]", "\n", "batch_y", "=", "self", ".", "sampled_memory_labs", "[", "random_batch_inds", "]", "\n", "b_index", "+=", "1", "\n", "self", ".", "zero_grad", "(", ")", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "batch_x", ")", ",", "batch_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "self", ".", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "if", "b_index", "*", "effective_batch_size", ">=", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ":", "\n", "\n", "                ", "break", "\n", "\n", "", "", "self", ".", "zero_grad", "(", ")", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "self", ".", "memory_data", ")", ",", "self", ".", "memory_labs", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "this_grad", "=", "get_grad_vector", "(", "self", ".", "parameters", ",", "self", ".", "grad_dims", ")", ".", "unsqueeze", "(", "0", ")", "\n", "batch_sim", "=", "max", "(", "(", "self", ".", "cosine_similarity", "(", "self", ".", "mem_grads", ",", "this_grad", ")", ")", ")", "\n", "\n", "return", "batch_sim", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.Net.get_each_batch_sample_sim": [[323, 338], ["torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "zip", "GSS_Greedy.Net.memory_labs.size", "GSS_Greedy.Net.zero_grad", "GSS_Greedy.Net.ce", "GSS_Greedy.Net.backward", "get_grad_vector().unsqueeze", "max", "GSS_Greedy.Net.forward", "y.unsqueeze", "GSS_Greedy.Net.cosine_similarity", "x.unsqueeze", "GSS_Greedy.get_grad_vector"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "def", "get_each_batch_sample_sim", "(", "self", ")", ":", "\n", "        ", "cosine_sim", "=", "torch", ".", "zeros", "(", "self", ".", "memory_labs", ".", "size", "(", "0", ")", ")", "\n", "item_index", "=", "0", "\n", "\n", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "memory_data", ",", "self", ".", "memory_labs", ")", ":", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "this_grad", "=", "get_grad_vector", "(", "self", ".", "parameters", ",", "self", ".", "grad_dims", ")", ".", "unsqueeze", "(", "0", ")", "\n", "\n", "cosine_sim", "[", "item_index", "]", "=", "max", "(", "self", ".", "cosine_similarity", "(", "self", ".", "mem_grads", ",", "this_grad", ")", ")", "\n", "item_index", "+=", "1", "\n", "\n", "", "return", "cosine_sim", "\n", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.get_grad_vector": [[23, 37], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor.fill_", "pp", "sum", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["def", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n     gather the gradients in one vector\n    \"\"\"", "\n", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "grad_dims", ")", ")", "\n", "grads", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Greedy.add_memory_grad": [[39, 64], ["GSS_Greedy.get_grad_vector", "grads.unsqueeze.unsqueeze", "grads.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "def", "add_memory_grad", "(", "pp", ",", "mem_grads", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This stores the gradient of a new memory and compute the dot product with the previously stored memories.\n        pp: parameters\n\n        mem_grads: gradients of previous memories\n        grad_dims: list with number of parameters per layers\n\n    \"\"\"", "\n", "\n", "# gather the gradient of the new memory", "\n", "grads", "=", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", "\n", "\n", "if", "mem_grads", "is", "None", ":", "\n", "\n", "        ", "mem_grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "mem_grads", "=", "torch", ".", "cat", "(", "(", "mem_grads", ",", "grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "return", "mem_grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.Net.__init__": [[95, 143], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "gem.Net.parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "common.ResNet18", "common.MLP", "gem.Net.parameters", "gem.Net.memory_data.cuda", "gem.Net.memory_labs.cuda", "gem.Net.grad_dims.append", "sum", "gem.Net.grads.cuda", "int", "param.data.numel"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "margin", "=", "args", ".", "memory_strength", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "\n", "# allocate episodic memory", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "\n", "n_tasks", ",", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "", "self", ".", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "self", ".", "grad_dims", ")", ",", "n_tasks", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "grads", "=", "self", ".", "grads", ".", "cuda", "(", ")", "\n", "\n", "# allocate counters", "\n", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "int", "(", "n_outputs", "/", "n_tasks", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.Net.forward": [[144, 156], ["gem.Net.net", "int", "int", "output[].data.fill_", "output[].data.fill_"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "self", ".", "is_cifar", ":", "#thi", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", "=", "int", "(", "t", "*", "self", ".", "nc_per_task", ")", "\n", "offset2", "=", "int", "(", "(", "t", "+", "1", ")", "*", "self", ".", "nc_per_task", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "offset2", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.Net.observe": [[157, 221], ["y.data.size", "min", "gem.Net.memory_data[].copy_", "range", "gem.Net.observed_tasks.append", "print", "gem.Net.memory_labs[].copy_", "gem.Net.zero_grad", "gem.compute_offsets", "gem.Net.ce", "gem.Net.backward", "gem.Net.opt.step", "len", "range", "len", "gem.store_grad", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "gem.Net.zero_grad", "gem.compute_offsets", "gem.Net.ce", "gem.Net.backward", "gem.store_grad", "gem.Net.forward", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "gem.Net.grads[].unsqueeze", "gem.Net.grads.index_select", "gem.project2cone2", "gem.overwrite_grad", "len", "gem.Net.grads[].unsqueeze", "gem.Net.grads.index_select", "gem.Net.forward"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.store_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.store_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.project2cone2", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.overwrite_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "\n", "        ", "if", "t", "!=", "self", ".", "old_task", ":", "\n", "            ", "self", ".", "observed_tasks", ".", "append", "(", "t", ")", "\n", "self", ".", "old_task", "=", "t", "\n", "print", "(", "\"task number \"", ",", "t", ")", "\n", "# Update ring buffer storing examples from current task", "\n", "", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "t", ",", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "# compute gradient on previous tasks", "\n", "            ", "if", "len", "(", "self", ".", "observed_tasks", ")", ">", "1", ":", "\n", "                ", "for", "tt", "in", "range", "(", "len", "(", "self", ".", "observed_tasks", ")", "-", "1", ")", ":", "\n", "\n", "                    ", "self", ".", "zero_grad", "(", ")", "\n", "# fwd/bwd on the examples in the memory", "\n", "past_task", "=", "self", ".", "observed_tasks", "[", "tt", "]", "\n", "\n", "offset1", ",", "offset2", "=", "compute_offsets", "(", "past_task", ",", "self", ".", "nc_per_task", ",", "\n", "self", ".", "is_cifar", ")", "\n", "\n", "ptloss", "=", "self", ".", "ce", "(", "\n", "self", ".", "forward", "(", "\n", "self", ".", "memory_data", "[", "past_task", "]", ",", "\n", "past_task", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "\n", "self", ".", "memory_labs", "[", "past_task", "]", "-", "offset1", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "store_grad", "(", "self", ".", "parameters", ",", "self", ".", "grads", ",", "self", ".", "grad_dims", ",", "\n", "past_task", ")", "\n", "\n", "# now compute the grad on the current minibatch", "\n", "", "", "self", ".", "zero_grad", "(", ")", "\n", "\n", "offset1", ",", "offset2", "=", "compute_offsets", "(", "t", ",", "self", ".", "nc_per_task", ",", "self", ".", "is_cifar", ")", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ",", "t", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "y", "-", "offset1", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# check if gradient violates constraints", "\n", "if", "len", "(", "self", ".", "observed_tasks", ")", ">", "1", ":", "\n", "# copy gradient", "\n", "                ", "store_grad", "(", "self", ".", "parameters", ",", "self", ".", "grads", ",", "self", ".", "grad_dims", ",", "t", ")", "\n", "indx", "=", "torch", ".", "cuda", ".", "LongTensor", "(", "self", ".", "observed_tasks", "[", ":", "-", "1", "]", ")", "if", "self", ".", "gpu", "else", "torch", ".", "LongTensor", "(", "self", ".", "observed_tasks", "[", ":", "-", "1", "]", ")", "\n", "dotp", "=", "torch", ".", "mm", "(", "self", ".", "grads", "[", ":", ",", "t", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "self", ".", "grads", ".", "index_select", "(", "1", ",", "indx", ")", ")", "\n", "if", "(", "dotp", "<", "0", ")", ".", "sum", "(", ")", "!=", "0", ":", "\n", "                    ", "project2cone2", "(", "self", ".", "grads", "[", ":", ",", "t", "]", ".", "unsqueeze", "(", "1", ")", ",", "\n", "self", ".", "grads", ".", "index_select", "(", "1", ",", "indx", ")", ",", "self", ".", "margin", ")", "\n", "# copy gradients back", "\n", "overwrite_grad", "(", "self", ".", "parameters", ",", "self", ".", "grads", "[", ":", ",", "t", "]", ",", "\n", "self", ".", "grad_dims", ")", "\n", "", "", "self", ".", "opt", ".", "step", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.compute_offsets": [[18, 30], ["None"], "function", ["None"], ["def", "compute_offsets", "(", "task", ",", "nc_per_task", ",", "is_cifar", ")", ":", "\n", "    ", "\"\"\"\n        Compute offsets for cifar to determine which\n        outputs to select for a given task.\n    \"\"\"", "\n", "if", "is_cifar", ":", "\n", "        ", "offset1", "=", "task", "*", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "nc_per_task", "\n", "", "else", ":", "\n", "        ", "offset1", "=", "0", "\n", "offset2", "=", "nc_per_task", "\n", "", "return", "offset1", ",", "offset2", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.store_grad": [[32, 49], ["grads[].fill_", "pp", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["", "def", "store_grad", "(", "pp", ",", "grads", ",", "grad_dims", ",", "tid", ")", ":", "\n", "    ", "\"\"\"\n        This stores parameter gradients of past tasks.\n        pp: parameters\n        grads: gradients\n        grad_dims: list with number of parameters per layers\n        tid: task id\n    \"\"\"", "\n", "# store the gradients", "\n", "grads", "[", ":", ",", "tid", "]", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", ",", "tid", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.overwrite_grad": [[51, 68], ["pp", "sum", "newgrad[].contiguous().view", "param.grad.data.copy_", "sum", "param.grad.data.size", "newgrad[].contiguous"], "function", ["None"], ["", "", "def", "overwrite_grad", "(", "pp", ",", "newgrad", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This is used to overwrite the gradients with a new gradient\n        vector, whenever violations occur.\n        pp: parameters\n        newgrad: corrected gradient\n        grad_dims: list storing number of parameters at each layer\n    \"\"\"", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "this_grad", "=", "newgrad", "[", "beg", ":", "en", "]", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "param", ".", "grad", ".", "data", ".", "size", "(", ")", ")", "\n", "param", ".", "grad", ".", "data", ".", "copy_", "(", "this_grad", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.gem.project2cone2": [[70, 92], ["memories.cpu().t().double().numpy", "gradient.cpu().contiguous().view().double().numpy", "numpy.dot", "numpy.eye", "gradient.copy_", "memories.cpu().t().double().numpy.transpose", "numpy.dot", "numpy.zeros", "quadprog.solve_qp", "numpy.dot", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "memories.cpu().t().double", "gradient.cpu().contiguous().view().double", "numpy.eye", "np.dot.transpose", "torch.Tensor", "torch.Tensor", "torch.Tensor", "memories.cpu().t", "gradient.cpu().contiguous().view", "memories.cpu", "gradient.cpu().contiguous", "gradient.cpu"], "function", ["None"], ["", "", "def", "project2cone2", "(", "gradient", ",", "memories", ",", "margin", "=", "0.5", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"\n        Solves the GEM dual QP described in the paper given a proposed\n        gradient \"gradient\", and a memory of task gradients \"memories\".\n        Overwrites \"gradient\" with the final projected update.\n\n        input:  gradient, p-vector\n        input:  memories, (t * p)-vector\n        output: x, p-vector\n    \"\"\"", "\n", "\n", "memories_np", "=", "memories", ".", "cpu", "(", ")", ".", "t", "(", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "gradient_np", "=", "gradient", ".", "cpu", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "t", "=", "memories_np", ".", "shape", "[", "0", "]", "\n", "P", "=", "np", ".", "dot", "(", "memories_np", ",", "memories_np", ".", "transpose", "(", ")", ")", "\n", "P", "=", "0.5", "*", "(", "P", "+", "P", ".", "transpose", "(", ")", ")", "+", "np", ".", "eye", "(", "t", ")", "*", "eps", "\n", "q", "=", "np", ".", "dot", "(", "memories_np", ",", "gradient_np", ")", "*", "-", "1", "\n", "G", "=", "np", ".", "eye", "(", "t", ")", "\n", "h", "=", "np", ".", "zeros", "(", "t", ")", "+", "margin", "\n", "v", "=", "quadprog", ".", "solve_qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "[", "0", "]", "\n", "x", "=", "np", ".", "dot", "(", "v", ",", "memories_np", ")", "+", "gradient_np", "\n", "gradient", ".", "copy_", "(", "torch", ".", "Tensor", "(", "x", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.__init__": [[64, 126], ["torch.Module.__init__", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "GSS_Clust.Net.parameters", "common.ResNet18", "common.MLP", "GSS_Clust.Net.parameters", "GSS_Clust.Net.memory_data.cuda", "GSS_Clust.Net.memory_labs.cuda", "GSS_Clust.Net.grad_dims.append", "param.data.numel"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "margin", "=", "args", ".", "memory_strength", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "n_sampled_memories", "=", "args", ".", "n_sampled_memories", "\n", "self", ".", "n_constraints", "=", "args", ".", "n_constraints", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "self", ".", "repass", "=", "args", ".", "repass", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "\n", "self", ".", "change_th", "=", "args", ".", "change_th", "# gradient direction change threshold to re-select constraints", "\n", "# allocate ring buffer", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "self", ".", "n_memories", ")", "\n", "self", ".", "added_index", "=", "self", ".", "n_sampled_memories", "\n", "# allocate  selected  memory", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "# allocate selected constraints", "\n", "self", ".", "constraints_data", "=", "None", "\n", "self", ".", "constraints_labs", "=", "None", "\n", "self", ".", "cluster_distance", "=", "0", "\n", "self", ".", "age_weight", "=", "args", ".", "age", "\n", "# old grads to measure changes", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "# we keep few samples per task and use their gradients", "\n", "# self.grads = torch.Tensor(sum(self.grad_dims), n_tasks*self.n_sampled_memories)", "\n", "# initialize a tensor for storing temprorarly the gradient of the current task", "\n", "# self.mem_grads = torch.Tensor(sum(self.grad_dims), 1)", "\n", "\n", "# if args.cuda:", "\n", "#    self.grads = self.grads.cuda()", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.forward": [[128, 133], ["GSS_Clust.Net.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", "=", "0", ")", ":", "\n", "# t is there to be used by the main caller", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.get_samples_gradients": [[134, 145], ["zip", "GSS_Clust.Net.zero_grad", "GSS_Clust.Net.zero_grad", "GSS_Clust.Net.ce", "GSS_Clust.Net.backward", "GSS_Clust.add_memory_grad", "GSS_Clust.Net.forward", "y.unsqueeze", "x.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "get_samples_gradients", "(", "self", ",", "mem_data", ",", "mem_labs", ")", ":", "\n", "\n", "        ", "mem_grads", "=", "None", "\n", "for", "x", ",", "y", "in", "zip", "(", "mem_data", ",", "mem_labs", ")", ":", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "", "self", ".", "zero_grad", "(", ")", "\n", "return", "mem_grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.select_k_centers": [[146, 208], ["GSS_Clust.Net.eval", "GSS_Clust.Net.get_samples_gradients().clone", "GSS_Clust.Net.get_samples_gradients().clone", "GSS_Clust.Net.cosine_similarity", "range", "print", "GSS_Clust.Net.train", "GSS_Clust.Net.memory_data[].unsqueeze().clone", "GSS_Clust.Net.memory_labs[].unsqueeze().clone", "GSS_Clust.Net.memory_data[].clone", "GSS_Clust.Net.memory_labs[].clone", "GSS_Clust.Net.memory_data.clone", "GSS_Clust.Net.memory_labs.clone", "GSS_Clust.Net.cosine_similarity", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "GSS_Clust.Net.size", "len", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat().clone.size", "GSS_Clust.Net.cosine_similarity", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "print", "init_points[].clone", "init_points_labels[].clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "GSS_Clust.Net.get_samples_gradients", "GSS_Clust.Net.get_samples_gradients", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "added_indes.append", "len", "GSS_Clust.Net.sampled_memory_data.size", "range", "len", "GSS_Clust.Net.memory_data[].unsqueeze", "GSS_Clust.Net.memory_labs[].unsqueeze", "GSS_Clust.Net.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "first_ind.item", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat().clone.size", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "cent_inds.append", "GSS_Clust.Net.size"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.get_samples_gradients", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.get_samples_gradients"], ["", "def", "select_k_centers", "(", "self", ",", "beta", "=", "0.1", ",", "alpha", "=", "1", ")", ":", "\n", "        ", "self", ".", "eval", "(", ")", "\n", "if", "self", ".", "sampled_memory_data", "is", "None", ":", "\n", "\n", "\n", "            ", "self", ".", "sampled_memory_data", "=", "self", ".", "memory_data", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "memory_labs", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", ".", "clone", "(", ")", "\n", "new_memories_data", "=", "self", ".", "memory_data", "[", "1", ":", "]", ".", "clone", "(", ")", "\n", "new_memories_labs", "=", "self", ".", "memory_labs", "[", "1", ":", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "new_memories_data", "=", "self", ".", "memory_data", ".", "clone", "(", ")", "\n", "new_memories_labs", "=", "self", ".", "memory_labs", ".", "clone", "(", ")", "\n", "\n", "", "new_mem_features", "=", "self", ".", "get_samples_gradients", "(", "new_memories_data", ",", "new_memories_labs", ")", ".", "clone", "(", ")", "\n", "samples_mem_features", "=", "self", ".", "get_samples_gradients", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "sampled_memory_labs", ")", ".", "clone", "(", ")", "\n", "new_dist", "=", "self", ".", "cosine_similarity", "(", "new_mem_features", ",", "samples_mem_features", ")", "\n", "#intra_distance", "\n", "if", "self", ".", "cluster_distance", "==", "0", ":", "\n", "\n", "            ", "intra_dist", "=", "self", ".", "cosine_similarity", "(", "samples_mem_features", ")", "\n", "max_dis", "=", "torch", ".", "max", "(", "intra_dist", ")", "\n", "\n", "eye", "=", "(", "torch", ".", "eye", "(", "intra_dist", ".", "size", "(", "0", ")", ")", "*", "max_dis", ")", "\n", "self", ".", "cluster_distance", "=", "alpha", "*", "torch", ".", "min", "(", "intra_dist", "+", "eye", ")", "#", "\n", "\n", "", "added_indes", "=", "[", "]", "\n", "for", "new_mem_index", "in", "range", "(", "new_mem_features", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "            ", "if", "torch", ".", "min", "(", "new_dist", "[", "new_mem_index", "]", ")", ">", "self", ".", "cluster_distance", ":", "\n", "                ", "added_indes", ".", "append", "(", "new_mem_index", ")", "\n", "\n", "", "", "print", "(", "\"length of added inds\"", ",", "len", "(", "added_indes", ")", ")", "\n", "if", "(", "len", "(", "added_indes", ")", "+", "self", ".", "sampled_memory_data", ".", "size", "(", "0", ")", ")", ">", "self", ".", "n_sampled_memories", ":", "\n", "\n", "            ", "init_points", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_data", ",", "new_memories_data", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "init_points_labels", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_labs", ",", "new_memories_labs", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "init_points_feat", "=", "torch", ".", "cat", "(", "(", "samples_mem_features", ",", "new_mem_features", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "est_mem_size", "=", "init_points_feat", ".", "size", "(", "0", ")", "\n", "init_feat_dist", "=", "self", ".", "cosine_similarity", "(", "init_points_feat", ")", "\n", "\n", "self", ".", "cluster_distance", "=", "torch", ".", "min", "(", "init_feat_dist", "+", "torch", ".", "eye", "(", "init_feat_dist", ".", "size", "(", "0", ")", ")", "*", "torch", ".", "max", "(", "init_feat_dist", ")", ")", "\n", "\n", "while", "est_mem_size", ">", "self", ".", "n_sampled_memories", ":", "\n", "                ", "self", ".", "cluster_distance", "=", "self", ".", "cluster_distance", "+", "beta", "*", "self", ".", "cluster_distance", "\n", "first_ind", "=", "torch", ".", "randint", "(", "0", ",", "init_points_feat", ".", "size", "(", "0", ")", ",", "(", "1", ",", ")", ")", "[", "0", "]", "\n", "#cent_feat=init_points_feat[first_ind].clone()", "\n", "cent_inds", "=", "[", "first_ind", ".", "item", "(", ")", "]", "\n", "for", "feat_indx", "in", "range", "(", "init_points_feat", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "                    ", "if", "torch", ".", "min", "(", "init_feat_dist", "[", "feat_indx", "]", "[", "cent_inds", "]", ")", ">", "self", ".", "cluster_distance", ":", "\n", "                        ", "cent_inds", ".", "append", "(", "feat_indx", ")", "\n", "\n", "\n", "", "", "est_mem_size", "=", "len", "(", "cent_inds", ")", "\n", "", "print", "(", "\"BUFFER SIZE,\"", ",", "est_mem_size", ")", "\n", "self", ".", "sampled_memory_data", "=", "init_points", "[", "cent_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "init_points_labels", "[", "cent_inds", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_data", ",", "new_memories_data", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_labs", ",", "new_memories_labs", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "\n", "", "self", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.cosine_similarity": [[210, 218], ["x1.norm", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "x2.t", "w2.t"], "methods", ["None"], ["", "def", "cosine_similarity", "(", "self", ",", "x1", ",", "x2", "=", "None", ",", "eps", "=", "1e-8", ")", ":", "\n", "        ", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "sim", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "#, w1  # .clamp(min=eps), 1/cosinesim", "\n", "\n", "return", "1", "-", "sim", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.Net.observe": [[222, 278], ["y.data.size", "min", "GSS_Clust.Net.memory_data[].copy_", "range", "GSS_Clust.Net.memory_labs[].copy_", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "min", "GSS_Clust.Net.zero_grad", "GSS_Clust.Net.ce", "GSS_Clust.Net.backward", "GSS_Clust.Net.opt.step", "print", "GSS_Clust.Net.select_k_centers", "GSS_Clust.Net.sampled_memory_labs.size", "GSS_Clust.Net.sampled_memory_labs.size", "GSS_Clust.Net.forward", "GSS_Clust.Net.zero_grad", "GSS_Clust.Net.ce", "GSS_Clust.Net.backward", "GSS_Clust.Net.opt.step", "GSS_Clust.Net.forward", "GSS_Clust.Net.sampled_memory_labs.size"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.select_k_centers", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "# temp", "\n", "# we dont use it :)", "\n", "\n", "# Update ring buffer storing examples from current task", "\n", "        ", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "\n", "# self.select_random_samples_per_group()", "\n", "# self.select_random_samples_per_group()", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "            ", "shuffeled_inds", "=", "torch", ".", "randperm", "(", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "effective_batch_size", "=", "min", "(", "self", ".", "n_constraints", ",", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "b_index", "=", "0", "\n", "", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "\n", "# get gradients on previous constraints", "\n", "\n", "# now compute the grad on the current minibatch", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ")", ",", "y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "\n", "#print(random_batch_inds)", "\n", "                ", "random_batch_inds", "=", "shuffeled_inds", "[", "b_index", "*", "effective_batch_size", ":", "b_index", "*", "effective_batch_size", "+", "effective_batch_size", "]", "\n", "batch_x", "=", "self", ".", "sampled_memory_data", "[", "random_batch_inds", "]", "\n", "batch_y", "=", "self", ".", "sampled_memory_labs", "[", "random_batch_inds", "]", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "batch_x", ")", ",", "batch_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "b_index", "+=", "1", "\n", "if", "b_index", "*", "effective_batch_size", ">=", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ":", "\n", "                    ", "b_index", "=", "0", "\n", "#self.opt.step()", "\n", "", "", "", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "print", "(", "\"ring buffer is full, re-estimating of the constrains, we are at task\"", ",", "t", ")", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "self", ".", "cosine_sim", "=", "[", "1", "]", "*", "self", ".", "n_constraints", "\n", "self", ".", "select_k_centers", "(", "self", ".", "age_weight", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.get_grad_vector": [[19, 33], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor.fill_", "pp", "sum", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["def", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n     gather the gradients in one vector\n    \"\"\"", "\n", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "grad_dims", ")", ")", "\n", "grads", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_Clust.add_memory_grad": [[35, 60], ["GSS_Clust.get_grad_vector", "grads.unsqueeze.unsqueeze", "grads.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "def", "add_memory_grad", "(", "pp", ",", "mem_grads", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This stores the gradient of a new memory and compute the dot product with the previously stored memories.\n        pp: parameters\n\n        mem_grads: gradients of previous memories\n        grad_dims: list with number of parameters per layers\n\n    \"\"\"", "\n", "\n", "# gather the gradient of the new memory", "\n", "grads", "=", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", "\n", "\n", "if", "mem_grads", "is", "None", ":", "\n", "\n", "        ", "mem_grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "mem_grads", "=", "torch", ".", "cat", "(", "(", "mem_grads", ",", "grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "return", "mem_grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.__init__": [[13, 41], ["super().__init__", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "common.ResNet18", "common.MLP", "single.Net.parameters"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "(", "args", ".", "data_file", "==", "'cifar100.pt'", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "# setup optimizer", "\n", "", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "n_epochs", "=", "args", ".", "n_iter", "\n", "self", ".", "mini_batch_size", "=", "args", ".", "mini_batch_size", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.compute_offsets": [[42, 50], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.forward": [[51, 63], ["single.Net.net", "single.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "#pdb.set_trace()", "\n", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "offset2", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.single.Net.observe": [[64, 79], ["single.Net.train", "range", "torch.randperm", "range", "single.Net.zero_grad", "single.Net.bce", "single.Net.backward", "single.Net.opt.step", "x.size", "x.size", "single.Net.forward"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "self", ".", "train", "(", ")", "\n", "for", "epoch", "in", "range", "(", "self", ".", "n_epochs", ")", ":", "\n", "\n", "            ", "permutation", "=", "torch", ".", "randperm", "(", "x", ".", "size", "(", ")", "[", "0", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "x", ".", "size", "(", ")", "[", "0", "]", ",", "self", ".", "mini_batch_size", ")", ":", "\n", "                ", "self", ".", "zero_grad", "(", ")", "\n", "indices", "=", "permutation", "[", "i", ":", "i", "+", "self", ".", "mini_batch_size", "]", "\n", "batch_x", ",", "batch_y", "=", "x", "[", "indices", "]", ",", "y", "[", "indices", "]", "\n", "ptloss", "=", "self", ".", "bce", "(", "self", ".", "forward", "(", "\n", "batch_x", ",", "t", ")", ",", "\n", "batch_y", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.__init__": [[218, 274], ["torch.Module.__init__", "miosqp.MIOSQP", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "GSS_IQP_ConsOpt.Net.parameters", "common.ResNet18", "common.MLP", "GSS_IQP_ConsOpt.Net.parameters", "GSS_IQP_ConsOpt.Net.memory_data.cuda", "GSS_IQP_ConsOpt.Net.memory_labs.cuda", "GSS_IQP_ConsOpt.Net.grad_dims.append", "param.data.numel"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "margin", "=", "args", ".", "memory_strength", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "m", "=", "miosqp", ".", "MIOSQP", "(", ")", "\n", "self", ".", "solver", "=", "m", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "n_sampled_memories", "=", "args", ".", "n_sampled_memories", "\n", "self", ".", "n_constraints", "=", "args", ".", "n_constraints", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "self", ".", "repass", "=", "args", ".", "repass", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "self", ".", "mini_batch_size", "=", "args", ".", "mini_batch_size", "\n", "self", ".", "slack", "=", "args", ".", "slack", "\n", "self", ".", "change_th", "=", "args", ".", "change_th", "# gradient direction change threshold to re-select constraints", "\n", "# allocate ring buffer", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "self", ".", "n_memories", ")", "\n", "# allocate  selected  memory", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "# allocate selected constraints", "\n", "self", ".", "constraints_data", "=", "None", "\n", "self", ".", "constraints_labs", "=", "None", "\n", "self", ".", "subselect", "=", "args", ".", "subselect", "# first select from recent memory and then add to samples memories", "\n", "# old grads to measure changes", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.forward": [[276, 281], ["GSS_IQP_ConsOpt.Net.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", "=", "0", ")", ":", "\n", "# t is there to be used by the main caller", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.select_samples_per_group": [[282, 348], ["print", "zip", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange.size", "torch.arange.size", "torch.arange.size", "GSS_IQP_ConsOpt.Net.mem_grads[].clone", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "torch.unique", "GSS_IQP_ConsOpt.Net.zero_grad", "GSS_IQP_ConsOpt.Net.ce", "GSS_IQP_ConsOpt.Net.backward", "GSS_IQP_ConsOpt.add_memory_grad", "zip", "GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "GSS_IQP_ConsOpt.Net.sampled_memory_data[].clone", "GSS_IQP_ConsOpt.Net.sampled_memory_labs[].clone", "print", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "GSS_IQP_ConsOpt.Net.memory_data[].clone", "GSS_IQP_ConsOpt.Net.memory_labs[].clone", "print", "GSS_IQP_ConsOpt.Net.forward", "y.unsqueeze", "GSS_IQP_ConsOpt.Net.zero_grad", "GSS_IQP_ConsOpt.Net.ce", "GSS_IQP_ConsOpt.Net.backward", "GSS_IQP_ConsOpt.add_memory_grad", "GSS_IQP_ConsOpt.Net.mem_grads.size", "GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "print", "GSS_IQP_ConsOpt.Net.sampled_memory_data[].clone", "GSS_IQP_ConsOpt.Net.sampled_memory_labs[].clone", "print", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "x.unsqueeze", "GSS_IQP_ConsOpt.Net.forward", "y.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "torch.nonzero().size", "pdb.set_trace", "x.unsqueeze", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge", "torch.ge"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "select_samples_per_group", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Assuming a ring buffer, backup constraints and constrains,\n        re-estimate the backup constrains and constrains\n\n        \"\"\"", "\n", "\n", "print", "(", "\"constraints selector\"", ")", "\n", "self", ".", "mem_grads", "=", "None", "\n", "# get gradients from the ring buffer", "\n", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "memory_data", ",", "self", ".", "memory_labs", ")", ":", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "self", ".", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "self", ".", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "\n", "", "added_inds", "=", "torch", ".", "arange", "(", "self", ".", "n_memories", ")", "\n", "from_buffer_size", "=", "added_inds", ".", "size", "(", "0", ")", "\n", "self", ".", "new_mem_grads", "=", "self", ".", "mem_grads", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "# estimate the active constraints from the backup samples", "\n", "self", ".", "mem_grads", "=", "None", "\n", "if", "not", "self", ".", "sampled_memory_data", "is", "None", ":", "\n", "            ", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "sampled_memory_labs", ")", ":", "\n", "                ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "self", ".", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "self", ".", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "# select main constrains", "\n", "\n", "", "inds", "=", "cosine_similarity_selector_IQP_Exact", "(", "self", ".", "mem_grads", ",", "nb_selected", "=", "self", ".", "n_constraints", ",", "\n", "solver", "=", "self", ".", "solver", ",", "slack", "=", "self", ".", "slack", ")", "\n", "\n", "self", ".", "constraints_data", "=", "self", ".", "sampled_memory_data", "[", "inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "constraints_labs", "=", "self", ".", "sampled_memory_labs", "[", "inds", "]", ".", "clone", "(", ")", "\n", "\n", "print", "(", "\"selected labels are\"", ",", "self", ".", "constraints_labs", ")", "\n", "# self.compute_similarity_between_classes(self.mem_grads,self.sampled_memory_labs)", "\n", "\n", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "(", "self", ".", "memory_data", "[", "added_inds", "]", ",", "self", ".", "sampled_memory_data", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "(", "self", ".", "memory_labs", "[", "added_inds", "]", ",", "self", ".", "sampled_memory_labs", ",", ")", ",", "\n", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "\n", "self", ".", "mem_grads", "=", "torch", ".", "cat", "(", "(", "self", ".", "new_mem_grads", ",", "self", ".", "mem_grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "if", "self", ".", "n_sampled_memories", "<", "self", ".", "mem_grads", ".", "size", "(", "0", ")", ":", "\n", "\n", "                ", "inds", "=", "cosine_similarity_selector_IQP_Exact", "(", "self", ".", "mem_grads", ",", "nb_selected", "=", "self", ".", "n_sampled_memories", ",", "\n", "solver", "=", "self", ".", "solver", ",", "slack", "=", "self", ".", "slack", ")", "\n", "print", "(", "\"number of retained memories\"", ",", "torch", ".", "nonzero", "(", "torch", ".", "ge", "(", "inds", ",", "from_buffer_size", ")", ")", ".", "size", "(", "0", ")", ")", "\n", "if", "torch", ".", "nonzero", "(", "torch", ".", "ge", "(", "inds", ",", "from_buffer_size", ")", ")", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "                    ", "pdb", ".", "set_trace", "(", ")", "\n", "", "self", ".", "sampled_memory_data", "=", "self", ".", "sampled_memory_data", "[", "inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "sampled_memory_labs", "[", "inds", "]", ".", "clone", "(", ")", "\n", "print", "(", "\"selected Buffer labels are\"", ",", "self", ".", "sampled_memory_labs", ")", "\n", "\n", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "sampled_memory_data", "=", "self", ".", "memory_data", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "memory_labs", "[", "added_inds", "]", ".", "clone", "(", ")", "\n", "", "labels", "=", "torch", ".", "unique", "(", "self", ".", "sampled_memory_labs", ")", "\n", "for", "lab", "in", "labels", ":", "\n", "            ", "print", "(", "\"number of samples from class\"", ",", "lab", ",", "torch", ".", "nonzero", "(", "torch", ".", "eq", "(", "self", ".", "sampled_memory_labs", ",", "lab", ")", ")", ".", "size", "(", "0", ")", ")", "\n", "", "self", ".", "mem_grads", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.select_samples_from_backup": [[352, 378], ["print", "zip", "GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "GSS_IQP_ConsOpt.Net.sampled_memory_data[].clone", "GSS_IQP_ConsOpt.Net.sampled_memory_labs[].clone", "print", "GSS_IQP_ConsOpt.Net.zero_grad", "GSS_IQP_ConsOpt.Net.ce", "GSS_IQP_ConsOpt.Net.backward", "GSS_IQP_ConsOpt.add_memory_grad", "GSS_IQP_ConsOpt.Net.forward", "y.unsqueeze", "x.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "select_samples_from_backup", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Assuming a buffer of stored samples\n        re-estimate the constraints\n\n        \"\"\"", "\n", "\n", "print", "(", "\"active constraints selector\"", ")", "\n", "\n", "self", ".", "mem_grads", "=", "None", "\n", "\n", "for", "x", ",", "y", "in", "zip", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "sampled_memory_labs", ")", ":", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ".", "unsqueeze", "(", "0", ")", ")", ",", "y", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "# add the new grad to the memory grads and add it is cosine similarity", "\n", "self", ".", "mem_grads", "=", "add_memory_grad", "(", "self", ".", "parameters", ",", "self", ".", "mem_grads", ",", "self", ".", "grad_dims", ")", "\n", "\n", "# select main constrains", "\n", "", "back_up_inds", "=", "cosine_similarity_selector_IQP_Exact", "(", "self", ".", "mem_grads", ",", "nb_selected", "=", "self", ".", "n_constraints", ",", "\n", "solver", "=", "self", ".", "solver", ",", "slack", "=", "self", ".", "slack", ")", "\n", "self", ".", "constraints_data", "=", "self", ".", "sampled_memory_data", "[", "back_up_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "constraints_labs", "=", "self", ".", "sampled_memory_labs", "[", "back_up_inds", "]", ".", "clone", "(", ")", "\n", "print", "(", "\"selected labels are\"", ",", "self", ".", "constraints_labs", ")", "\n", "self", ".", "mem_grads", "=", "None", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.forward_constraints": [[383, 404], ["range", "GSS_IQP_ConsOpt.Net.constraints_data.size", "GSS_IQP_ConsOpt.Net.zero_grad", "GSS_IQP_ConsOpt.Net.ce", "GSS_IQP_ConsOpt.Net.backward", "GSS_IQP_ConsOpt.get_grad_vector", "print", "GSS_IQP_ConsOpt.Net.mem_grads.clone", "GSS_IQP_ConsOpt.Net.forward", "GSS_IQP_ConsOpt.Net.constraints_labs[].unsqueeze", "get_grad_vector.unsqueeze().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "GSS_IQP_ConsOpt.Net.constraints_data[].unsqueeze", "get_grad_vector.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "get_grad_vector.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "forward_constraints", "(", "self", ")", ":", "\n", "        ", "self", ".", "mem_grads", "=", "None", "\n", "if", "self", ".", "constraints_data", "is", "not", "None", ":", "\n", "\n", "            ", "for", "i", "in", "range", "(", "self", ".", "constraints_data", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "\n", "                ", "self", ".", "zero_grad", "(", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "self", ".", "constraints_data", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", ",", "\n", "self", ".", "constraints_labs", "[", "i", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "this_grad_vec", "=", "get_grad_vector", "(", "self", ".", "parameters", ",", "self", ".", "grad_dims", ")", "\n", "if", "self", ".", "mem_grads", "is", "None", ":", "\n", "                    ", "self", ".", "mem_grads", "=", "this_grad_vec", ".", "unsqueeze", "(", "1", ")", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                    ", "self", ".", "mem_grads", "=", "torch", ".", "cat", "(", "(", "self", ".", "mem_grads", ",", "this_grad_vec", ".", "unsqueeze", "(", "1", ")", ")", ",", "dim", "=", "1", ")", ".", "clone", "(", ")", "\n", "\n", "", "", "if", "self", ".", "mem_grads", "is", "not", "None", "and", "self", ".", "old_mem_grads", "is", "None", ":", "\n", "                ", "print", "(", "\"Updating old grds, similarity must be one!\"", ")", "\n", "\n", "self", ".", "old_mem_grads", "=", "self", ".", "mem_grads", ".", "clone", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.observe": [[409, 487], ["y.data.size", "min", "GSS_IQP_ConsOpt.Net.memory_data[].copy_", "range", "GSS_IQP_ConsOpt.Net.memory_labs[].copy_", "GSS_IQP_ConsOpt.Net.forward_constraints", "GSS_IQP_ConsOpt.Net.zero_grad", "GSS_IQP_ConsOpt.Net.ce", "GSS_IQP_ConsOpt.Net.backward", "GSS_IQP_ConsOpt.Net.opt.step", "print", "GSS_IQP_ConsOpt.Net.select_samples_per_group", "range", "print", "GSS_IQP_ConsOpt.Net.forward", "GSS_IQP_ConsOpt.get_grad_vector", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "print", "GSS_IQP_ConsOpt.Net.zero_grad", "GSS_IQP_ConsOpt.Net.rehearse_st", "GSS_IQP_ConsOpt.Net.old_mem_grads.size", "GSS_IQP_ConsOpt.Net.mem_grads.size", "GSS_IQP_ConsOpt.cosine_similarity", "min", "min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "print", "GSS_IQP_ConsOpt.Net.select_samples_from_backup", "GSS_IQP_ConsOpt.Net.forward_constraints", "this_grad_vec.unsqueeze.unsqueeze.unsqueeze", "this_grad_vec.unsqueeze.unsqueeze.unsqueeze", "GSS_IQP_ConsOpt.project2cone2", "GSS_IQP_ConsOpt.overwrite_grad", "GSS_IQP_ConsOpt.Net.mem_grads[].unsqueeze", "GSS_IQP_ConsOpt.Net.old_mem_grads[].unsqueeze", "cosine_sim.item", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.forward_constraints", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.select_samples_per_group", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.select_samples_from_backup", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.Net.forward_constraints", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.project2cone2", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.overwrite_grad"], ["", "", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "# temp", "\n", "# we dont use it :)", "\n", "\n", "# Update ring buffer storing examples from current task", "\n", "        ", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "\n", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "\n", "# get gradients on previous constraints", "\n", "            ", "self", ".", "forward_constraints", "(", ")", "\n", "\n", "# check the chnages in the gradients of the samples", "\n", "if", "self", ".", "old_mem_grads", "is", "not", "None", ":", "\n", "\n", "                ", "self", ".", "cosine_sim", "=", "[", "None", "]", "*", "self", ".", "old_mem_grads", ".", "size", "(", "1", ")", "\n", "for", "index", "in", "range", "(", "self", ".", "mem_grads", ".", "size", "(", "1", ")", ")", ":", "\n", "                    ", "cosine_sim", ",", "norm", "=", "cosine_similarity", "(", "self", ".", "mem_grads", "[", ":", ",", "index", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "self", ".", "old_mem_grads", "[", ":", ",", "index", "]", ".", "unsqueeze", "(", "0", ")", ")", "\n", "self", ".", "cosine_sim", "[", "index", "]", "=", "cosine_sim", ".", "item", "(", ")", "if", "norm", ">", "self", ".", "slack", "else", "1", "\n", "", "str_osine_sim", "=", "[", "'%.2f'", "%", "elem", "for", "elem", "in", "self", ".", "cosine_sim", "]", "\n", "print", "(", "\"minimum gradients_cosine_similarity\"", ",", "min", "(", "self", ".", "cosine_sim", ")", ")", "\n", "if", "min", "(", "self", ".", "cosine_sim", ")", "<", "self", ".", "change_th", ":", "\n", "                    ", "_", ",", "index", "=", "torch", ".", "min", "(", "torch", ".", "tensor", "(", "self", ".", "cosine_sim", ")", ",", "dim", "=", "0", ")", "\n", "\n", "print", "(", "\n", "\"Restimating the Active Constraints to preserve\"", ")", "# ,torch.norm(self.old_mem_grads[:,index],p=2)", "\n", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "self", ".", "select_samples_from_backup", "(", ")", "\n", "self", ".", "forward_constraints", "(", ")", "\n", "# now compute the grad on the current minibatch", "\n", "", "", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ")", ",", "y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# check if gradient violates constraints", "\n", "if", "self", ".", "constraints_data", "is", "not", "None", ":", "\n", "# copy gradient", "\n", "\n", "                ", "this_grad_vec", "=", "get_grad_vector", "(", "self", ".", "parameters", ",", "self", ".", "grad_dims", ")", "\n", "\n", "dotp", "=", "torch", ".", "mm", "(", "this_grad_vec", ".", "unsqueeze", "(", "0", ")", ",", "\n", "self", ".", "mem_grads", ")", "\n", "if", "(", "dotp", "<", "0", ")", ".", "sum", "(", ")", "!=", "0", ":", "\n", "# print(\"number of violated samples\",(dotp < 0).sum())", "\n", "                    ", "this_grad_vec", "=", "this_grad_vec", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "project2cone2", "(", "this_grad_vec", ",", "self", ".", "mem_grads", ",", "self", ".", "margin", ")", "\n", "\n", "# copy gradients back", "\n", "overwrite_grad", "(", "self", ".", "parameters", ",", "this_grad_vec", ",", "\n", "self", ".", "grad_dims", ")", "\n", "", "", "self", ".", "opt", ".", "step", "(", ")", "\n", "\n", "", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "if", "self", ".", "repass", ">", "0", "and", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "                ", "print", "(", "\"repassing\"", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "self", ".", "rehearse_st", "(", "self", ".", "sampled_memory_data", ",", "self", ".", "sampled_memory_labs", ")", "\n", "", "self", ".", "mem_cnt", "=", "0", "\n", "print", "(", "\"ring buffer is full, re-estimating of the constrains, we are at task\"", ",", "t", ")", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "self", ".", "cosine_sim", "=", "[", "1", "]", "*", "self", ".", "n_constraints", "\n", "self", ".", "select_samples_per_group", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.store_grad": [[42, 59], ["grads[].fill_", "pp", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["def", "store_grad", "(", "pp", ",", "grads", ",", "grad_dims", ",", "tid", ")", ":", "\n", "    ", "\"\"\"\n        This stores parameter gradients of past tasks.\n        pp: parameters\n        grads: gradients\n        grad_dims: list with number of parameters per layers\n        tid: task id\n    \"\"\"", "\n", "# store the gradients", "\n", "grads", "[", ":", ",", "tid", "]", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", ",", "tid", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity_selector_IQP_Exact": [[61, 125], ["time.time", "x1.norm", "print", "spa.csc_matrix.size", "spa.csc_matrix.double().numpy", "numpy.zeros", "numpy.ones", "numpy.eye", "numpy.zeros", "numpy.ones", "numpy.arange", "numpy.concatenate", "numpy.transpose", "numpy.concatenate", "numpy.concatenate", "scipy.csc_matrix", "scipy.csc_matrix", "solver.solve", "print", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "print", "torch.nonzero", "torch.nonzero", "torch.nonzero", "torch.arange.size", "print", "torch.arange", "torch.arange", "torch.arange", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "numpy.zeros", "solver.setup", "time.time", "torch.Tensor", "torch.Tensor", "torch.Tensor", "sum", "torch.gt", "torch.gt", "torch.gt", "x1.norm.size", "torch.arange.size", "x1.size", "x2.t", "w2.t", "spa.csc_matrix.double", "pdb.set_trace", "torch.nonzero.squeeze"], "function", ["None"], ["", "", "def", "cosine_similarity_selector_IQP_Exact", "(", "x1", ",", "solver", ",", "nb_selected", ",", "eps", "=", "1e-3", ",", "slack", "=", "0.01", ")", ":", "\n", "# your code", "\n", "\n", "    ", "\"\"\"\n    Integer programming\n    \"\"\"", "\n", "\n", "# x1=gradient memories", "\n", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "x2", "=", "None", "\n", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "inds", "=", "torch", ".", "nonzero", "(", "torch", ".", "gt", "(", "w1", ",", "slack", ")", ")", "[", ":", ",", "0", "]", "\n", "print", "(", "\"removed due to gradients\"", ",", "w1", ".", "size", "(", "0", ")", "-", "inds", ".", "size", "(", "0", ")", ")", "\n", "if", "inds", ".", "size", "(", "0", ")", "<", "nb_selected", ":", "\n", "        ", "print", "(", "\"WARNING GRADIENTS ARE TOO SMALL!!!!!!!!\"", ")", "\n", "inds", "=", "torch", ".", "arange", "(", "0", ",", "x1", ".", "size", "(", "0", ")", ")", "\n", "", "w1", "=", "w1", "[", "inds", "]", "\n", "x1", "=", "x1", "[", "inds", "]", "\n", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "G", "=", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", "# .clamp(min=eps)", "\n", "t", "=", "G", ".", "size", "(", "0", ")", "\n", "\n", "G", "=", "G", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "a", "=", "np", ".", "zeros", "(", "t", ")", "\n", "# a=np.ones(t)*-1", "\n", "\n", "# a=((w1-torch.min(w1))/(torch.max(w1)-torch.min(w1))).squeeze().double().numpy()*-0.01", "\n", "C", "=", "np", ".", "ones", "(", "(", "t", ",", "1", ")", ")", "\n", "h", "=", "np", ".", "zeros", "(", "1", ")", "+", "nb_selected", "\n", "C2", "=", "np", ".", "eye", "(", "t", ")", "\n", "\n", "hlower", "=", "np", ".", "zeros", "(", "t", ")", "\n", "hupper", "=", "np", ".", "ones", "(", "t", ")", "\n", "idx", "=", "np", ".", "arange", "(", "t", ")", "\n", "\n", "#################", "\n", "C", "=", "np", ".", "concatenate", "(", "(", "C2", ",", "C", ")", ",", "axis", "=", "1", ")", "\n", "C", "=", "np", ".", "transpose", "(", "C", ")", "\n", "h_final_lower", "=", "np", ".", "concatenate", "(", "(", "hlower", ",", "h", ")", ",", "axis", "=", "0", ")", "\n", "h_final_upper", "=", "np", ".", "concatenate", "(", "(", "hupper", ",", "h", ")", ",", "axis", "=", "0", ")", "\n", "#################", "\n", "G", "=", "spa", ".", "csc_matrix", "(", "G", ")", "\n", "\n", "C", "=", "spa", ".", "csc_matrix", "(", "C", ")", "\n", "try", ":", "\n", "        ", "solver", ".", "setup", "(", "G", ",", "a", ",", "C", ",", "h_final_lower", ",", "h_final_upper", ",", "idx", ",", "hlower", ",", "hupper", ",", "miosqp_settings", ",", "osqp_settings", ")", "\n", "", "except", ":", "\n", "        ", "import", "pdb", "\n", "pdb", ".", "set_trace", "(", ")", "\n", "", "results", "=", "solver", ".", "solve", "(", ")", "\n", "elapsed_time", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "print", "(", "\"ELAPSED TIME IS \"", ",", "elapsed_time", ")", "\n", "print", "(", "\"STATUS\"", ",", "results", ".", "status", ")", "\n", "coeffiecents_np", "=", "results", ".", "x", "\n", "coeffiecents", "=", "torch", ".", "nonzero", "(", "torch", ".", "Tensor", "(", "coeffiecents_np", ")", ")", "\n", "print", "(", "\"number of selected items is\"", ",", "sum", "(", "coeffiecents_np", ")", ")", "\n", "if", "\"Infeasible\"", "in", "results", ".", "status", ":", "\n", "        ", "return", "inds", "\n", "", "return", "inds", "[", "coeffiecents", ".", "squeeze", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector": [[127, 141], ["torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor.fill_", "pp", "sum", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["", "def", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n     gather the gradients in one vector\n    \"\"\"", "\n", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "grad_dims", ")", ")", "\n", "grads", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "", "return", "grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.cosine_similarity": [[142, 148], ["x1.norm", "x2.norm", "torch.mm", "torch.mm", "torch.mm", "x2.t", "w2.t"], "function", ["None"], ["", "def", "cosine_similarity", "(", "self", ",", "x1", ",", "x2", "=", "None", ",", "eps", "=", "1e-8", ")", ":", "\n", "    ", "x2", "=", "x1", "if", "x2", "is", "None", "else", "x2", "\n", "w1", "=", "x1", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "\n", "w2", "=", "w1", "if", "x2", "is", "x1", "else", "x2", ".", "norm", "(", "p", "=", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "return", "torch", ".", "mm", "(", "x1", ",", "x2", ".", "t", "(", ")", ")", "/", "(", "w1", "*", "w2", ".", "t", "(", ")", ")", ",", "w1", "# .clamp(min=eps)", "\n", "", "def", "add_memory_grad", "(", "pp", ",", "mem_grads", ",", "grad_dims", ")", ":", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.add_memory_grad": [[148, 173], ["GSS_IQP_ConsOpt.get_grad_vector", "grads.unsqueeze.unsqueeze", "grads.unsqueeze.unsqueeze", "torch.cat", "torch.cat", "torch.cat"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.get_grad_vector"], ["", "def", "add_memory_grad", "(", "pp", ",", "mem_grads", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This stores the gradient of a new memory and compute the dot product with the previously stored memories.\n        pp: parameters\n\n        mem_grads: gradients of previous memories\n        grad_dims: list with number of parameters per layers\n\n    \"\"\"", "\n", "\n", "# gather the gradient of the new memory", "\n", "grads", "=", "get_grad_vector", "(", "pp", ",", "grad_dims", ")", "\n", "\n", "if", "mem_grads", "is", "None", ":", "\n", "\n", "        ", "mem_grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "\n", "", "else", ":", "\n", "\n", "        ", "grads", "=", "grads", ".", "unsqueeze", "(", "dim", "=", "0", ")", "\n", "\n", "mem_grads", "=", "torch", ".", "cat", "(", "(", "mem_grads", ",", "grads", ")", ",", "dim", "=", "0", ")", "\n", "\n", "", "return", "mem_grads", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.overwrite_grad": [[175, 192], ["pp", "sum", "newgrad[].contiguous().view", "param.grad.data.copy_", "sum", "param.grad.data.size", "newgrad[].contiguous"], "function", ["None"], ["", "def", "overwrite_grad", "(", "pp", ",", "newgrad", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This is used to overwrite the gradients with a new gradient\n        vector, whenever violations occur.\n        pp: parameters\n        newgrad: corrected gradient\n        grad_dims: list storing number of parameters at each layer\n    \"\"\"", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "this_grad", "=", "newgrad", "[", "beg", ":", "en", "]", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "param", ".", "grad", ".", "data", ".", "size", "(", ")", ")", "\n", "param", ".", "grad", ".", "data", ".", "copy_", "(", "this_grad", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.GSS_IQP_ConsOpt.project2cone2": [[194, 215], ["memories.cpu().t().double().numpy", "gradient.cpu().contiguous().view().double().numpy", "numpy.dot", "numpy.eye", "gradient.copy_", "memories.cpu().t().double().numpy.transpose", "numpy.dot", "numpy.zeros", "quadprog.solve_qp", "numpy.dot", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "memories.cpu().t().double", "gradient.cpu().contiguous().view().double", "numpy.eye", "np.dot.transpose", "torch.Tensor", "torch.Tensor", "torch.Tensor", "memories.cpu().t", "gradient.cpu().contiguous().view", "memories.cpu", "gradient.cpu().contiguous", "gradient.cpu"], "function", ["None"], ["", "", "def", "project2cone2", "(", "gradient", ",", "memories", ",", "margin", "=", "0.5", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"\n        Solves the GEM dual QP described in the paper given a proposed\n        gradient \"gradient\", and a memory of task gradients \"memories\".\n        Overwrites \"gradient\" with the final projected update.\n        input:  gradient, p-vector\n        input:  memories, (t * p)-vector\n        output: x, p-vector\n    \"\"\"", "\n", "\n", "memories_np", "=", "memories", ".", "cpu", "(", ")", ".", "t", "(", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "gradient_np", "=", "gradient", ".", "cpu", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "t", "=", "memories_np", ".", "shape", "[", "0", "]", "\n", "P", "=", "np", ".", "dot", "(", "memories_np", ",", "memories_np", ".", "transpose", "(", ")", ")", "\n", "P", "=", "0.5", "*", "(", "P", "+", "P", ".", "transpose", "(", ")", ")", "+", "np", ".", "eye", "(", "t", ")", "*", "eps", "\n", "q", "=", "np", ".", "dot", "(", "memories_np", ",", "gradient_np", ")", "*", "-", "1", "\n", "G", "=", "np", ".", "eye", "(", "t", ")", "\n", "h", "=", "np", ".", "zeros", "(", "t", ")", "+", "margin", "\n", "v", "=", "quadprog", ".", "solve_qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "[", "0", "]", "\n", "x", "=", "np", ".", "dot", "(", "v", ",", "memories_np", ")", "+", "gradient_np", "\n", "gradient", ".", "copy_", "(", "torch", ".", "Tensor", "(", "x", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__": [[25, 74], ["torch.Module.__init__", "miosqp.MIOSQP", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "common.ResNet18", "common.MLP", "FSS_Clust.Net.parameters", "FSS_Clust.Net.memory_data.cuda", "FSS_Clust.Net.memory_labs.cuda"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.__init__", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.common.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "nl", ",", "nh", "=", "args", ".", "n_layers", ",", "args", ".", "n_hiddens", "\n", "self", ".", "margin", "=", "args", ".", "memory_strength", "\n", "self", ".", "is_cifar", "=", "(", "'cifar10'", "in", "args", ".", "data_file", ")", "\n", "m", "=", "miosqp", ".", "MIOSQP", "(", ")", "\n", "self", ".", "solver", "=", "m", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ",", "bias", "=", "args", ".", "bias", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "n_inputs", "]", "+", "[", "nh", "]", "*", "nl", "+", "[", "n_outputs", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "n_sampled_memories", "=", "args", ".", "n_sampled_memories", "\n", "self", ".", "n_constraints", "=", "args", ".", "n_constraints", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "self", ".", "batch_size", "=", "args", ".", "batch_size", "\n", "self", ".", "n_iter", "=", "args", ".", "n_iter", "\n", "# allocate ring buffer", "\n", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "self", ".", "n_memories", ")", "\n", "self", ".", "added_index", "=", "self", ".", "n_sampled_memories", "\n", "# allocate  selected  memory", "\n", "self", ".", "sampled_memory_data", "=", "None", "\n", "self", ".", "sampled_memory_labs", "=", "None", "\n", "# allocate selected constraints", "\n", "self", ".", "constraints_data", "=", "None", "\n", "self", ".", "constraints_labs", "=", "None", "\n", "self", ".", "cluster_distance", "=", "0", "\n", "# old grads to measure changes", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward": [[76, 81], ["FSS_Clust.Net.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", "=", "0", ")", ":", "\n", "# t is there to be used by the main caller", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.select_k_centers": [[84, 147], ["FSS_Clust.Net.eval", "FSS_Clust.Net.net().data.clone", "FSS_Clust.Net.net().data.clone", "FSS_Clust.Net.dist_matrix", "range", "print", "FSS_Clust.Net.train", "FSS_Clust.Net.memory_data[].unsqueeze().clone", "FSS_Clust.Net.memory_labs[].unsqueeze().clone", "FSS_Clust.Net.memory_data[].clone", "FSS_Clust.Net.memory_labs[].clone", "FSS_Clust.Net.memory_data.clone", "FSS_Clust.Net.memory_labs.clone", "FSS_Clust.Net.dist_matrix", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "FSS_Clust.Net.size", "len", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat().clone.size", "FSS_Clust.Net.dist_matrix", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "print", "init_points[].clone", "init_points_labels[].clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.cat().clone", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "eye.cuda.cuda.cuda", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "added_indes.append", "len", "FSS_Clust.Net.sampled_memory_data.size", "FSS_Clust.Net.size", "eye.cuda.cuda.cuda", "range", "len", "FSS_Clust.Net.memory_data[].unsqueeze", "FSS_Clust.Net.memory_labs[].unsqueeze", "FSS_Clust.Net.net", "FSS_Clust.Net.net", "FSS_Clust.Net.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "first_ind.item", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.max", "torch.cat().clone.size", "torch.cat().clone.size", "torch.cat().clone.size", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "torch.min", "cent_inds.append"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.dist_matrix", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.dist_matrix", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.dist_matrix"], ["", "def", "select_k_centers", "(", "self", ",", "beta", "=", "2", ",", "alpha", "=", "1", ")", ":", "\n", "        ", "self", ".", "eval", "(", ")", "\n", "if", "self", ".", "sampled_memory_data", "is", "None", ":", "\n", "#this is wrong of self.n_memories>self.n_sampled_memories which shouldn't happen in this implementation", "\n", "\n", "            ", "self", ".", "sampled_memory_data", "=", "self", ".", "memory_data", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "self", ".", "memory_labs", "[", "0", "]", ".", "unsqueeze", "(", "0", ")", ".", "clone", "(", ")", "\n", "new_memories_data", "=", "self", ".", "memory_data", "[", "1", ":", "]", ".", "clone", "(", ")", "\n", "new_memories_labs", "=", "self", ".", "memory_labs", "[", "1", ":", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "new_memories_data", "=", "self", ".", "memory_data", ".", "clone", "(", ")", "\n", "new_memories_labs", "=", "self", ".", "memory_labs", ".", "clone", "(", ")", "\n", "\n", "", "new_mem_features", "=", "self", ".", "net", "(", "new_memories_data", ")", ".", "data", ".", "clone", "(", ")", "\n", "samples_mem_features", "=", "self", ".", "net", "(", "self", ".", "sampled_memory_data", ")", ".", "data", ".", "clone", "(", ")", "\n", "new_dist", "=", "self", ".", "dist_matrix", "(", "new_mem_features", ",", "samples_mem_features", ")", "\n", "#intra_distance", "\n", "if", "self", ".", "cluster_distance", "==", "0", ":", "\n", "            ", "intra_dist", "=", "self", ".", "dist_matrix", "(", "samples_mem_features", ")", "\n", "max_dis", "=", "torch", ".", "max", "(", "intra_dist", ")", "\n", "eye", "=", "(", "torch", ".", "eye", "(", "intra_dist", ".", "size", "(", "0", ")", ")", "*", "max_dis", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                ", "eye", "=", "eye", ".", "cuda", "(", ")", "\n", "", "self", ".", "cluster_distance", "=", "alpha", "*", "torch", ".", "min", "(", "intra_dist", "+", "eye", ")", "#", "\n", "\n", "", "added_indes", "=", "[", "]", "\n", "for", "new_mem_index", "in", "range", "(", "new_mem_features", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "            ", "if", "torch", ".", "min", "(", "new_dist", "[", "new_mem_index", "]", ")", ">", "self", ".", "cluster_distance", ":", "\n", "                ", "added_indes", ".", "append", "(", "new_mem_index", ")", "\n", "", "", "print", "(", "\"length of added inds\"", ",", "len", "(", "added_indes", ")", ")", "\n", "if", "(", "len", "(", "added_indes", ")", "+", "self", ".", "sampled_memory_data", ".", "size", "(", "0", ")", ")", ">", "self", ".", "n_sampled_memories", ":", "\n", "\n", "            ", "init_points", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_data", ",", "new_memories_data", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "init_points_labels", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_labs", ",", "new_memories_labs", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "init_points_feat", "=", "torch", ".", "cat", "(", "(", "samples_mem_features", ",", "new_mem_features", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "est_mem_size", "=", "init_points_feat", ".", "size", "(", "0", ")", "\n", "init_feat_dist", "=", "self", ".", "dist_matrix", "(", "init_points_feat", ")", "\n", "eye", "=", "torch", ".", "eye", "(", "init_feat_dist", ".", "size", "(", "0", ")", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                ", "eye", "=", "eye", ".", "cuda", "(", ")", "\n", "", "self", ".", "cluster_distance", "=", "torch", ".", "min", "(", "init_feat_dist", "+", "eye", "*", "torch", ".", "max", "(", "init_feat_dist", ")", ")", "\n", "\n", "while", "est_mem_size", ">", "self", ".", "n_sampled_memories", ":", "\n", "                ", "self", ".", "cluster_distance", "=", "self", ".", "cluster_distance", "*", "beta", "\n", "first_ind", "=", "torch", ".", "randint", "(", "0", ",", "init_points_feat", ".", "size", "(", "0", ")", ",", "(", "1", ",", ")", ")", "[", "0", "]", "\n", "#cent_feat=init_points_feat[first_ind].clone()", "\n", "cent_inds", "=", "[", "first_ind", ".", "item", "(", ")", "]", "\n", "for", "feat_indx", "in", "range", "(", "init_points_feat", ".", "size", "(", "0", ")", ")", ":", "\n", "\n", "                    ", "if", "torch", ".", "min", "(", "init_feat_dist", "[", "feat_indx", "]", "[", "cent_inds", "]", ")", ">", "self", ".", "cluster_distance", ":", "\n", "                        ", "cent_inds", ".", "append", "(", "feat_indx", ")", "\n", "\n", "\n", "", "", "est_mem_size", "=", "len", "(", "cent_inds", ")", "\n", "", "print", "(", "\"BUFFER SIZE,\"", ",", "est_mem_size", ")", "\n", "self", ".", "sampled_memory_data", "=", "init_points", "[", "cent_inds", "]", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "init_points_labels", "[", "cent_inds", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "sampled_memory_data", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_data", ",", "new_memories_data", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "self", ".", "sampled_memory_labs", "=", "torch", ".", "cat", "(", "(", "self", ".", "sampled_memory_labs", ",", "new_memories_labs", "[", "added_indes", "]", ")", ",", "dim", "=", "0", ")", ".", "clone", "(", ")", "\n", "\n", "", "self", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.dist_matrix": [[150, 164], ["x.unsqueeze().expand.unsqueeze().expand.size", "x.unsqueeze().expand.clone.size", "x.unsqueeze().expand.unsqueeze().expand.size", "x.unsqueeze().expand.unsqueeze().expand.unsqueeze().expand", "x.unsqueeze().expand.clone.unsqueeze().expand", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "torch.pow().sum", "x.unsqueeze().expand.unsqueeze().expand.clone", "x.unsqueeze().expand.unsqueeze().expand.unsqueeze", "x.unsqueeze().expand.clone.unsqueeze", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow", "torch.pow"], "methods", ["None"], ["", "def", "dist_matrix", "(", "self", ",", "x", ",", "y", "=", "None", ")", ":", "\n", "        ", "if", "y", "is", "None", ":", "\n", "            ", "y", "=", "x", ".", "clone", "(", ")", "\n", "", "n", "=", "x", ".", "size", "(", "0", ")", "\n", "m", "=", "y", ".", "size", "(", "0", ")", "\n", "d", "=", "x", ".", "size", "(", "1", ")", "\n", "\n", "x", "=", "x", ".", "unsqueeze", "(", "1", ")", ".", "expand", "(", "n", ",", "m", ",", "d", ")", "\n", "y", "=", "y", ".", "unsqueeze", "(", "0", ")", ".", "expand", "(", "n", ",", "m", ",", "d", ")", "\n", "\n", "#dist[i, j] = | | x[i, :] - y[j, :] | | ^ 2 in the", "\n", "\n", "dist", "=", "torch", ".", "pow", "(", "x", "-", "y", ",", "2", ")", ".", "sum", "(", "2", ")", "\n", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.observe": [[168, 224], ["y.data.size", "min", "FSS_Clust.Net.memory_data[].copy_", "range", "FSS_Clust.Net.memory_labs[].copy_", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "torch.randperm", "min", "FSS_Clust.Net.zero_grad", "FSS_Clust.Net.ce", "FSS_Clust.Net.backward", "FSS_Clust.Net.opt.step", "print", "FSS_Clust.Net.select_k_centers", "FSS_Clust.Net.sampled_memory_labs.size", "FSS_Clust.Net.sampled_memory_labs.size", "FSS_Clust.Net.forward", "FSS_Clust.Net.zero_grad", "FSS_Clust.Net.ce", "FSS_Clust.Net.backward", "FSS_Clust.Net.opt.step", "FSS_Clust.Net.forward", "FSS_Clust.Net.sampled_memory_labs.size"], "methods", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.select_k_centers", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward", "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.model.FSS_Clust.Net.forward"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "# temp", "\n", "# we dont use t :)", "\n", "\n", "# Update ring buffer storing examples from current task", "\n", "        ", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "\n", "# self.select_random_samples_per_group()", "\n", "# self.select_random_samples_per_group()", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "            ", "shuffeled_inds", "=", "torch", ".", "randperm", "(", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "effective_batch_size", "=", "min", "(", "self", ".", "n_constraints", ",", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ")", "\n", "b_index", "=", "0", "\n", "", "for", "iter_i", "in", "range", "(", "self", ".", "n_iter", ")", ":", "\n", "\n", "# get gradients on previous constraints", "\n", "\n", "# now compute the grad on the current minibatch", "\n", "            ", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ")", ",", "y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "if", "self", ".", "sampled_memory_data", "is", "not", "None", ":", "\n", "\n", "\n", "                ", "random_batch_inds", "=", "shuffeled_inds", "[", "b_index", "*", "effective_batch_size", ":", "b_index", "*", "effective_batch_size", "+", "effective_batch_size", "]", "\n", "batch_x", "=", "self", ".", "sampled_memory_data", "[", "random_batch_inds", "]", "\n", "batch_y", "=", "self", ".", "sampled_memory_labs", "[", "random_batch_inds", "]", "\n", "self", ".", "zero_grad", "(", ")", "\n", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "batch_x", ")", ",", "batch_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "b_index", "+=", "1", "\n", "if", "b_index", "*", "effective_batch_size", ">=", "self", ".", "sampled_memory_labs", ".", "size", "(", "0", ")", ":", "\n", "                    ", "b_index", "=", "0", "\n", "#self.opt.step()", "\n", "", "", "", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "print", "(", "\"ring buffer is full, re-estimating of the constrains, we are at task\"", ",", "t", ")", "\n", "self", ".", "old_mem_grads", "=", "None", "\n", "self", ".", "cosine_sim", "=", "[", "1", "]", "*", "self", ".", "n_constraints", "\n", "self", ".", "select_k_centers", "(", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.metrics.metrics.task_changes": [[12, 22], ["int", "enumerate", "result_t.max", "changes.append"], "function", ["None"], ["def", "task_changes", "(", "result_t", ")", ":", "\n", "    ", "n_tasks", "=", "int", "(", "result_t", ".", "max", "(", ")", "+", "1", ")", "\n", "changes", "=", "[", "]", "\n", "current", "=", "result_t", "[", "0", "]", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "result_t", ")", ":", "\n", "        ", "if", "t", "!=", "current", ":", "\n", "            ", "changes", ".", "append", "(", "i", ")", "\n", "current", "=", "t", "\n", "\n", "", "", "return", "n_tasks", ",", "changes", "\n", "\n"]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.metrics.metrics.confusion_matrix": [[24, 65], ["metrics.task_changes", "result.diag", "torch.zeros", "range", "stats.append", "stats.append", "stats.append", "torch.LongTensor", "open", "print", "print", "range", "print", "print", "print", "print", "print", "print", "open.close", "fin.mean", "bwt.mean", "torch.zeros.mean", "result.size", "print", "fin.mean", "bwt.mean", "torch.zeros.mean", "result_a.size"], "function", ["home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.metrics.metrics.task_changes"], ["", "def", "confusion_matrix", "(", "result_t", ",", "result_a", ",", "avg_acc", ",", "accurcy_on_mem", ",", "tasks_to_preserve", "=", "0", ",", "fname", "=", "None", ")", ":", "\n", "    ", "nt", ",", "changes", "=", "task_changes", "(", "result_t", ")", "\n", "\n", "baseline", "=", "result_a", "[", "0", "]", "\n", "changes", "=", "torch", ".", "LongTensor", "(", "changes", "+", "[", "result_a", ".", "size", "(", "0", ")", "]", ")", "-", "1", "\n", "result", "=", "result_a", "[", "changes", "]", "\n", "\n", "# acc[t] equals result[t,t]", "\n", "acc", "=", "result", ".", "diag", "(", ")", "\n", "fin", "=", "result", "[", "nt", "-", "1", "]", "[", ":", "tasks_to_preserve", "+", "1", "]", "\n", "# bwt[t] equals result[T,t] - acc[t]", "\n", "\n", "bwt", "=", "result", "[", "nt", "-", "1", "]", "[", ":", "tasks_to_preserve", "+", "1", "]", "-", "acc", "\n", "\n", "# fwt[t] equals result[t-1,t] - baseline[t]", "\n", "fwt", "=", "torch", ".", "zeros", "(", "nt", ")", "\n", "for", "t", "in", "range", "(", "1", ",", "nt", ")", ":", "\n", "        ", "fwt", "[", "t", "]", "=", "result", "[", "t", "-", "1", ",", "t", "]", "-", "baseline", "[", "t", "]", "\n", "\n", "", "if", "fname", "is", "not", "None", ":", "\n", "        ", "f", "=", "open", "(", "fname", ",", "'w'", ")", "\n", "\n", "print", "(", "' '", ".", "join", "(", "[", "'%.4f'", "%", "r", "for", "r", "in", "baseline", "]", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'|'", ",", "file", "=", "f", ")", "\n", "for", "row", "in", "range", "(", "result", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "print", "(", "' '", ".", "join", "(", "[", "'%.4f'", "%", "r", "for", "r", "in", "result", "[", "row", "]", "]", ")", ",", "file", "=", "f", ")", "\n", "", "print", "(", "''", ",", "file", "=", "f", ")", "\n", "# print('Diagonal Accuracy: %.4f' % acc.mean(), file=f)", "\n", "print", "(", "'Final Accuracy: %.4f'", "%", "fin", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Backward: %.4f'", "%", "bwt", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Forward:  %.4f'", "%", "fwt", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Average Accuracy:  %.4f'", "%", "avg_acc", "[", "-", "1", "]", ",", "file", "=", "f", ")", "\n", "print", "(", "'Memory Accuracy:  %.4f'", "%", "accurcy_on_mem", ",", "file", "=", "f", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n", "", "stats", "=", "[", "]", "\n", "# stats.append(acc.mean())", "\n", "stats", ".", "append", "(", "fin", ".", "mean", "(", ")", ")", "\n", "stats", ".", "append", "(", "bwt", ".", "mean", "(", ")", ")", "\n", "stats", ".", "append", "(", "fwt", ".", "mean", "(", ")", ")", "\n", "return", "stats", "\n", "", ""]], "home.repos.pwc.inspect_result.rahafaljundi_Gradient-based-Sample-Selection.raw.raw.unpickle": [[33, 37], ["open", "pickle.load"], "function", ["None"], ["", "def", "unpickle", "(", "file", ")", ":", "\n", "    ", "with", "open", "(", "file", ",", "'rb'", ")", "as", "fo", ":", "\n", "        ", "dict", "=", "pickle", ".", "load", "(", "fo", ",", "encoding", "=", "'bytes'", ")", "\n", "", "return", "dict", "\n", "\n"]]}