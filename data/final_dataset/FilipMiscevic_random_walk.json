{"home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.plotting.plot_curve": [[22, 55], ["matplotlib.figure", "plt.figure.gca", "map", "scipy.interpolate.griddata", "fig.gca.plot_surface", "fig.gca.set_xlabel", "fig.gca.set_ylabel", "fig.gca.set_zlabel", "matplotlib.savefig", "min", "max", "min", "max"], "function", ["None"], ["def", "plot_curve", "(", "x", ",", "y", ",", "z", ",", "x_lab", "=", "''", ",", "y_lab", "=", "''", ",", "z_lab", "=", "''", ",", "title", "=", "''", ",", "color", "=", "'none'", ")", ":", "\n", "    ", "'''List,List,List -> None\n    Given lists of x,y,z coordinates, plot a 3 dimensional surface.'''", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "gca", "(", "projection", "=", "'3d'", ")", "\n", "#X = np.arange(-5, 5, 0.25)", "\n", "#Y = np.arange(-5, 5, 0.25)", "\n", "z", "=", "map", "(", "float", ",", "z", ")", "\n", "grid_x", ",", "grid_y", "=", "np", ".", "mgrid", "[", "min", "(", "x", ")", ":", "max", "(", "x", ")", ":", "100j", ",", "min", "(", "y", ")", ":", "max", "(", "y", ")", ":", "100j", "]", "\n", "grid_z", "=", "griddata", "(", "(", "x", ",", "y", ")", ",", "z", ",", "(", "grid_x", ",", "grid_y", ")", ",", "method", "=", "'cubic'", ")", "\n", "\n", "ax", ".", "plot_surface", "(", "grid_x", ",", "grid_y", ",", "grid_z", ",", "cmap", "=", "plt", ".", "cm", ".", "Spectral", ")", "\n", "\n", "ax", ".", "set_xlabel", "(", "x_lab", ")", "\n", "ax", ".", "set_ylabel", "(", "y_lab", ")", "\n", "ax", ".", "set_zlabel", "(", "z_lab", ")", "\n", "#ax.set_title(title)", "\n", "\n", "#plt.show()", "\n", "\n", "plt", ".", "savefig", "(", "title", ")", "\n", "\n", "#Z = np.sin(R)", "\n", "##surf = ax.plot_surface(grid_x, grid_y, grid_z, rstride=1, cstride=1, cmap=cm.coolwarm,", "\n", "##                       linewidth=0, antialiased=False)", "\n", "##ax.set_zlim(-1.01, 1.01)", "\n", "\n", "##ax.zaxis.set_major_locator(LinearLocator(10))", "\n", "##ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))", "\n", "\n", "##fig.colorbar(surf, shrink=0.5, aspect=5)", "\n", "return", "fig", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.plotting.plot_scatter": [[56, 76], ["matplotlib.figure", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.set_title", "plt.figure.add_subplot", "fig.add_subplot.scatter", "plt.figure.add_subplot", "fig.add_subplot.set_zlabel", "fig.add_subplot.scatter"], "function", ["None"], ["", "def", "plot_scatter", "(", "X", ",", "Y", ",", "Z", ",", "x_lab", "=", "''", ",", "y_lab", "=", "''", ",", "z_lab", "=", "''", ",", "title", "=", "''", ",", "label", "=", "None", ",", "color", "=", "'none'", ")", ":", "\n", "    ", "'''Plot a 3-dimensional scatter plot.'''", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "\n", "if", "not", "Z", ":", "\n", "        ", "ax", "=", "fig", ".", "add_subplot", "(", "111", ")", "\n", "ax", ".", "scatter", "(", "X", ",", "Y", ",", "label", "=", "label", ",", "c", "=", "color", ")", "#,c=color)#, s=area, c=colors, alpha=0.5)", "\n", "", "else", ":", "\n", "        ", "ax", "=", "fig", ".", "add_subplot", "(", "111", ",", "projection", "=", "'3d'", ")", "\n", "ax", ".", "set_zlabel", "(", "z_lab", ")", "\n", "\n", "ax", ".", "scatter", "(", "X", ",", "Y", ",", "Z", ",", "label", "=", "label", ",", "c", "=", "color", ")", "\n", "\n", "", "ax", ".", "set_xlabel", "(", "x_lab", ")", "\n", "ax", ".", "set_ylabel", "(", "y_lab", ")", "\n", "ax", ".", "set_title", "(", "title", ")", "\n", "\n", "\n", "#plt.show()", "\n", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.plotting.plot_scatter2": [[77, 94], ["matplotlib.figure", "plt.figure.add_subplot", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.set_zlabel", "fig.add_subplot.set_title", "fig.add_subplot.scatter"], "function", ["None"], ["", "def", "plot_scatter2", "(", "X", ",", "Y", ",", "Z", ",", "Q", ",", "x_lab", "=", "''", ",", "y_lab", "=", "''", ",", "z_lab", "=", "''", ",", "color", "=", "'none'", ",", "title", "=", "''", ")", ":", "\n", "    ", "'''Plot a 3-dimensional scatter plot with two data series in the Z axis.'''", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "111", ",", "projection", "=", "'3d'", ")", "\n", "n", "=", "100", "\n", "for", "c", ",", "m", ",", "z_i", "in", "[", "(", "'b'", ",", "'^'", ",", "Z", ")", ",", "(", "color", ",", "'o'", ",", "Q", ")", "]", ":", "\n", "\n", "        ", "ax", ".", "scatter", "(", "X", ",", "Y", ",", "z_i", ",", "c", "=", "c", ",", "marker", "=", "m", ")", "\n", "\n", "", "ax", ".", "set_xlabel", "(", "x_lab", ")", "\n", "ax", ".", "set_ylabel", "(", "y_lab", ")", "\n", "ax", ".", "set_zlabel", "(", "z_lab", ")", "\n", "ax", ".", "set_title", "(", "title", ")", "\n", "\n", "#plt.show()", "\n", "\n", "return", "fig", "", "", ""]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.fit_hdbscan": [[8, 40], ["rw.get_cluster", "rw.get_cluster.shortest_paths_dijkstra", "numpy.array", "hdbscan.HDBSCAN", "h.HDBSCAN.fit_predict"], "function", ["None"], ["def", "fit_hdbscan", "(", "g", ",", "min_cluster_size", "=", "2", ")", ":", "\n", "#name = 'learner_af_0.85_24000_A0.4'", "\n", "#name = 'all_dev_utt_learner_af_HILLS_SHARED_0.8_A0.4'", "\n", "\n", "#name = 'BEAGLE_HILLS_SHARED_0.5_A0.4'", "\n", "\n", "#g = get_model(name)", "\n", "    ", "g", "=", "rw", ".", "get_cluster", "(", "g", ",", "'animal:N'", ")", "\n", "#g.remove_vertex(g.vs.find(label='animal:N'))    ", "\n", "\n", "d", "=", "g", ".", "shortest_paths_dijkstra", "(", "weights", "=", "'distance'", ")", "\n", "d", "=", "np", ".", "array", "(", "d", ")", "\n", "\n", "'''\n    ##first way of \n    d = g.get_adjacency(attribute='distance')\n    d = np.matrix(d.data)\n    d[d == 0] = 1 #non-connected nodes have a distance of 1 #try something that is larger than longest path\n    ##try using minimum paths\n    np.fill_diagonal(d,0)\n    \n    names = None\n    \n    #assert (d.transpose() == d).all()\n\n    '''", "\n", "##also try using", "\n", "\n", "\n", "c", "=", "h", ".", "HDBSCAN", "(", "metric", "=", "'precomputed'", ",", "min_cluster_size", "=", "min_cluster_size", ",", "gen_min_span_tree", "=", "True", ")", "\n", "c", ".", "fit_predict", "(", "d", ")", "\n", "return", "c", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_clusters": [[41, 58], ["enumerate", "clusters.pop", "clusters.values", "clusters.get", "clusters[].append"], "function", ["None"], ["", "def", "get_hdbscan_clusters", "(", "g", ",", "c", ")", ":", "\n", "    ", "clusters", "=", "{", "}", "\n", "\n", "for", "vid", ",", "cid", "in", "enumerate", "(", "c", ".", "labels_", ")", ":", "\n", "\n", "        ", "if", "g", ".", "vs", "[", "vid", "]", "[", "'label'", "]", "==", "'animal:N'", ":", "\n", "            ", "continue", "\n", "\n", "", "if", "clusters", ".", "get", "(", "cid", ",", "None", ")", "is", "None", ":", "\n", "            ", "clusters", "[", "cid", "]", "=", "[", "vid", "]", "\n", "", "else", ":", "\n", "            ", "clusters", "[", "cid", "]", ".", "append", "(", "vid", ")", "\n", "\n", "#uncategorized nodes", "\n", "", "", "qq", "=", "clusters", ".", "pop", "(", "-", "1", ",", "None", ")", "\n", "\n", "return", "clusters", ".", "values", "(", ")", "+", "[", "[", "q", "]", "for", "q", "in", "qq", "]", "#comment to exclude singletons", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_fscore_unweighted": [[59, 61], ["clustering.get_hdbscan_fscore"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_fscore"], ["", "def", "get_hdbscan_fscore_unweighted", "(", "g", ")", ":", "\n", "    ", "return", "get_hdbscan_fscore", "(", "g", ",", "weighted", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_fscore": [[62, 74], ["clustering.fit_hdbscan", "clustering.get_hdbscan_clusters", "precision_recall", "calculate_fscore"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.fit_hdbscan", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_clusters"], ["", "def", "get_hdbscan_fscore", "(", "g", ",", "weighted", "=", "True", ")", ":", "\n", "\n", "    ", "c", "=", "fit_hdbscan", "(", "g", ")", "\n", "\n", "clusters", "=", "get_hdbscan_clusters", "(", "g", ",", "c", ")", "\n", "\n", "\n", "p", ",", "r", ",", "c", "=", "precision_recall", "(", "g", ",", "\n", "clusters", "\n", ")", "\n", "\n", "return", "calculate_fscore", "(", "p", ",", "r", ",", "c", ",", "weighted", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_fscore_unweighted_all": [[76, 78], ["clustering.get_hdbscan_fscore"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_fscore"], ["", "def", "get_hdbscan_fscore_unweighted_all", "(", "g", ")", ":", "\n", "    ", "return", "get_hdbscan_fscore", "(", "g", ",", "weighted", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_fscore_all": [[79, 91], ["clustering.fit_hdbscan", "clustering.get_hdbscan_clusters", "precision_recall_with_singletons", "calculate_fscore"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.fit_hdbscan", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_clusters"], ["", "def", "get_hdbscan_fscore_all", "(", "g", ",", "weighted", "=", "True", ")", ":", "\n", "\n", "    ", "c", "=", "fit_hdbscan", "(", "g", ")", "\n", "\n", "clusters", "=", "get_hdbscan_clusters", "(", "g", ",", "c", ")", "\n", "\n", "\n", "p", ",", "r", ",", "c", "=", "precision_recall_with_singletons", "(", "g", ",", "\n", "clusters", "\n", ")", "\n", "\n", "return", "calculate_fscore", "(", "p", ",", "r", ",", "c", ",", "weighted", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_adj_rand_idx": [[92, 101], ["clustering.fit_hdbscan", "clustering.get_hdbscan_clusters", "adj_rand.test_get_cluster_cat_labels", "adj_rand.test_avg_adj_rand"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.fit_hdbscan", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.clustering.get_hdbscan_clusters", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.adj_rand.test_get_cluster_cat_labels", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.adj_rand.test_avg_adj_rand"], ["", "def", "get_hdbscan_adj_rand_idx", "(", "g", ",", "weighted", "=", "False", ")", ":", "\n", "\n", "    ", "c", "=", "fit_hdbscan", "(", "g", ")", "\n", "\n", "clusters", "=", "get_hdbscan_clusters", "(", "g", ",", "c", ")", "\n", "\n", "cat_clusters", "=", "test_get_cluster_cat_labels", "(", "g", ",", "clusters", ")", "\n", "\n", "return", "test_avg_adj_rand", "(", "cat_clusters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean": [[30, 38], ["numpy.mean", "type", "type"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean"], ["def", "mean", "(", "a", ")", ":", "\n", "    ", "'''List -> float\n       float -> float\n    Return the average of a list of numbers, excluding None values. If a is a number, return a.\n    '''", "\n", "if", "type", "(", "a", ")", "is", "float", "or", "type", "(", "a", ")", "is", "int", ":", "\n", "        ", "return", "a", "\n", "", "return", "np", ".", "mean", "(", "[", "i", "for", "i", "in", "a", "if", "i", "!=", "None", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.a_len": [[40, 45], ["len"], "function", ["None"], ["", "def", "a_len", "(", "a", ")", ":", "\n", "    ", "'''List -> int\n    Return the length of a list excluding None values.\n    '''", "\n", "return", "len", "(", "[", "i", "for", "i", "in", "a", "if", "i", "!=", "None", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.random_walk_possible": [[51, 65], ["get_cluster", "len", "get_cluster.neighbors", "get_cluster.vs.find"], "function", ["None"], ["", "def", "random_walk_possible", "(", "g", ")", ":", "\n", "    ", "'''For a given graph g, determine if a random walk starting at 'animal:N' is possible.\n    Criteria: 'animal:N' exists and has neighbors.\n    '''", "\n", "start", "=", "'animal:N'", "\n", "\n", "g", "=", "get_cluster", "(", "g", ",", "start", ")", "\n", "if", "g", "==", "None", ":", "\n", "        ", "return", "False", "\n", "#return a,b,cat,title, full_paths,full_cats", "\n", "", "elif", "len", "(", "g", ".", "neighbors", "(", "g", ".", "vs", ".", "find", "(", "label", "=", "start", ")", ".", "index", ")", ")", "==", "0", ":", "\n", "        ", "return", "False", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.random_walk_trial": [[67, 108], ["range", "rw.gen_random_walk", "b.append", "cat.append", "a.append", "full_cats.append", "full_paths.append", "str", "str", "str", "str"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.gen_random_walk"], ["", "def", "random_walk_trial", "(", "g", ",", "m", ",", "weight_opt", ",", "walk_length", ",", "restart", "=", "None", ")", ":", "\n", "    ", "'''Wrapper function to conduct a random walk as many times as ITR.'''", "\n", "#if animal not in network or connected to anything, skip", "\n", "'''\n    start = 'animal:N'\n    \n    g = g.get_cluster(start)\n    if g == None:\n        return None\n        #return a,b,cat,title, full_paths,full_cats\n    elif len(g.neighbors(g.vs.find(label=start).index)) == 0:\n        return None\n        #return a,b,cat,title, full_paths,full_cats\n    '''", "\n", "\n", "#print \"test \" + str(g)", "\n", "b", "=", "[", "]", "\n", "cat", "=", "[", "]", "\n", "a", "=", "[", "]", "\n", "\n", "full_cats", "=", "[", "]", "\n", "full_paths", "=", "[", "]", "\n", "\n", "title", "=", "\"_\"", ".", "join", "(", "[", "m", ",", "str", "(", "weight_opt", ")", ",", "str", "(", "ITR", ")", ",", "str", "(", "walk_length", ")", ",", "'restart '", "+", "str", "(", "restart", ")", "if", "restart", "else", "''", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "ITR", ")", ":", "\n", "\n", "        ", "b_i", ",", "c_i", ",", "a_i", ",", "f_p", ",", "c_f", "=", "gen_random_walk", "(", "g", "=", "g", ",", "weighted", "=", "weight_opt", ",", "log_file", "=", "title", ",", "stop", "=", "walk_length", ",", "restart", "=", "restart", ",", "name", "=", "title", ")", "\n", "\n", "b", ".", "append", "(", "b_i", ")", "\n", "cat", ".", "append", "(", "c_i", ")", "\n", "a", ".", "append", "(", "a_i", ")", "\n", "\n", "full_cats", ".", "append", "(", "c_f", ")", "\n", "full_paths", ".", "append", "(", "f_p", ")", "\n", "\n", "#log the trial", "\n", "#write_summary(title,a,cat,walk_length)", "\n", "#precision_recall(g,title)", "\n", "\n", "", "return", "a", ",", "b", ",", "cat", ",", "title", ",", "full_paths", ",", "full_cats", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.get_walk_length": [[110, 123], ["name.lower.lower"], "function", ["None"], ["", "def", "get_walk_length", "(", "name", ")", ":", "\n", "    ", "'''Str -> int\n    Return the walk length for a particular graph.\n    '''", "\n", "name", "=", "name", ".", "lower", "(", ")", "\n", "if", "'gold_af'", "in", "name", ":", "\n", "        ", "return", "50", "\n", "", "elif", "'learner_af'", "in", "name", ":", "\n", "        ", "return", "95", "\n", "", "elif", "'beagle_shared'", "in", "name", ":", "\n", "        ", "return", "45", "\n", "", "elif", "'beagle'", "in", "name", ":", "\n", "        ", "return", "70", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.gen_random_walk": [[124, 160], ["get_cluster", "rw.genX", "rw.get_fluid_cat_switches", "rw.get_fluid_cat_switches"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.genX", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.get_fluid_cat_switches", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.get_fluid_cat_switches"], ["", "", "def", "gen_random_walk", "(", "g", ",", "weighted", "=", "True", ",", "log_file", "=", "''", ",", "itr", "=", "1", ",", "name", "=", "''", ",", "stop", "=", "None", ",", "restart", "=", "0", ")", ":", "\n", "    ", "'''Perform a single random walk and determine the categories of each word.'''", "\n", "\n", "start", "=", "'animal:N'", "\n", "\n", "g", "=", "get_cluster", "(", "g", ",", "start", ")", "\n", "\n", "a", ",", "rwalk", ",", "b", "=", "genX", "(", "g", ",", "s", "=", "start", ",", "use_irts", "=", "1", ",", "weighted", "=", "weighted", ",", "stop", "=", "stop", ",", "restart", "=", "restart", ")", "\n", "\n", "a_names", "=", "g", ".", "vs", "[", "a", "]", "[", "'label'", "]", "\n", "#a_categories = [SHARED_HILLS_POS_CATEG_NUM.get(i,-1) for i in g.vs[a]['label']]", "\n", "#a_cat_changed = [1 if a_categories[i-1] != a_categories[i] else 0 for i in range(1,len(a_categories))]", "\n", "\n", "\n", "##calculate whether category changes as per Abbott et al.", "\n", "cat", "=", "get_fluid_cat_switches", "(", "a_names", ",", "start", ")", "\n", "\n", "\n", "full_path", "=", "[", "g", ".", "vs", "[", "'label'", "]", "[", "rwalk", "[", "0", "]", "[", "0", "]", "]", "]", "+", "[", "g", ".", "vs", "[", "'label'", "]", "[", "z", "[", "1", "]", "]", "for", "z", "in", "rwalk", "]", "\n", "\n", "cat_full", "=", "get_fluid_cat_switches", "(", "full_path", ",", "start", ")", "\n", "\n", "##LOG", "\n", "'''\n    #append to logfile\n    if log_file:\n        with open(log_file + '.txt','a') as f:\n            lines = 'Walk #:' + 'Weighted: ' + str(weighted),'Full Path: [' + ', '.join(full_path) + ']\\n'+'IRTS:'+str(b)+'\\nWords: ' + str(a_names), 'Categ: ' + str(cat)\n            #print '\\n'.join(lines)+'\\n\\n'\n            #print b\n            f.write('\\n'.join(lines)+'\\n\\n')\n    '''", "\n", "\n", "#cats_altered = [c for i,c in zip(full_path,cat_full) if i", "\n", "\n", "return", "b", ",", "cat", ",", "a", ",", "full_path", ",", "cat_full", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.random_walk_am": [[162, 206], ["set", "set.remove", "type", "range", "len", "walk.append", "len", "numpy.random.choice", "numpy.sum", "numpy.divide", "numpy.random.choice", "set.remove", "numpy.random.binomial", "enumerate"], "function", ["None"], ["", "def", "random_walk_am", "(", "g", ",", "start", "=", "None", ",", "seed", "=", "None", ",", "weighted", "=", "False", ",", "stop", "=", "None", ",", "restart", "=", "0", ")", ":", "\n", "    ", "'''Perform a random walk on adjacency matrix g.'''", "\n", "#seed(seed)", "\n", "\n", "#if type(start) == str:", "\n", "#    try:", "\n", "#        start = g.vs.find(label=start).index", "\n", "#    except Exception as e:", "\n", "#        start=random.choice(range(g.vcount()))", "\n", "\n", "assert", "type", "(", "start", ")", "==", "int", "\n", "\n", "walk", "=", "[", "]", "\n", "unused_nodes", "=", "set", "(", "range", "(", "len", "(", "g", ")", ")", ")", "\n", "unused_nodes", ".", "remove", "(", "start", ")", "\n", "s", "=", "start", "\n", "count", "=", "0", "\n", "while", "len", "(", "unused_nodes", ")", ">", "0", ":", "\n", "        ", "_p", "=", "start", "\n", "neighbors", "=", "[", "i", "for", "i", ",", "jj", "in", "enumerate", "(", "g", "[", "start", ",", ":", "]", ")", "if", "jj", "!=", "0", "]", "\n", "if", "weighted", "==", "False", ":", "\n", "            ", "start", "=", "choice", "(", "neighbors", ")", "# follow random edge", "\n", "", "else", ":", "\n", "            ", "weights", "=", "g", "[", "start", ",", "neighbors", "]", "\n", "#distances = g.es[neighboring_edges]['distance']", "\n", "#weights = [1-i for i in distances]", "\n", "total", "=", "np", ".", "sum", "(", "weights", ")", "\n", "normalized_weights", "=", "np", ".", "divide", "(", "weights", ",", "total", ")", "\n", "\n", "start", "=", "choice", "(", "neighbors", ",", "p", "=", "normalized_weights", ")", "\n", "\n", "", "walk", ".", "append", "(", "(", "_p", ",", "start", ")", ")", "\n", "if", "start", "in", "unused_nodes", ":", "\n", "            ", "unused_nodes", ".", "remove", "(", "start", ")", "\n", "\n", "", "if", "restart", ":", "\n", "            ", "if", "np", ".", "random", ".", "binomial", "(", "1", ",", "restart", ")", ":", "\n", "                ", "start", "=", "s", "\n", "", "", "if", "stop", ":", "\n", "            ", "if", "count", ">=", "stop", ":", "\n", "                ", "break", "\n", "\n", "", "", "count", "+=", "1", "\n", "", "return", "walk", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.random_walk": [[207, 250], ["set", "set.remove", "type", "type", "range", "len", "walk.append", "g.vcount", "numpy.random.choice", "sum", "numpy.random.choice", "set.remove", "numpy.random.binomial", "g.vs.find", "random.choice", "g.neighbors", "g.get_eid", "g.neighbors", "range", "g.neighbors", "g.vcount", "numpy.random.seed"], "function", ["None"], ["", "def", "random_walk", "(", "g", ",", "start", "=", "None", ",", "seed", "=", "None", ",", "weighted", "=", "False", ",", "stop", "=", "None", ",", "restart", "=", "0", ")", ":", "\n", "    ", "'''Perform a random walk on graph g.'''", "\n", "#seed(seed)", "\n", "\n", "if", "type", "(", "start", ")", "==", "str", ":", "\n", "        ", "try", ":", "\n", "            ", "start", "=", "g", ".", "vs", ".", "find", "(", "label", "=", "start", ")", ".", "index", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "start", "=", "random", ".", "choice", "(", "range", "(", "g", ".", "vcount", "(", ")", ")", ")", "\n", "\n", "", "", "assert", "type", "(", "start", ")", "==", "int", "\n", "\n", "walk", "=", "[", "]", "\n", "unused_nodes", "=", "set", "(", "range", "(", "g", ".", "vcount", "(", ")", ")", ")", "\n", "unused_nodes", ".", "remove", "(", "start", ")", "\n", "s", "=", "start", "\n", "count", "=", "0", "\n", "while", "len", "(", "unused_nodes", ")", ">", "0", ":", "\n", "        ", "_p", "=", "start", "\n", "if", "weighted", "==", "False", ":", "\n", "            ", "start", "=", "choice", "(", "g", ".", "neighbors", "(", "start", ")", ")", "# follow random edge", "\n", "", "else", ":", "\n", "            ", "neighboring_edges", "=", "[", "g", ".", "get_eid", "(", "start", ",", "n", ")", "for", "n", "in", "g", ".", "neighbors", "(", "start", ")", "]", "\n", "distances", "=", "g", ".", "es", "[", "neighboring_edges", "]", "[", "'distance'", "]", "\n", "weights", "=", "[", "1", "-", "i", "for", "i", "in", "distances", "]", "\n", "total", "=", "sum", "(", "weights", ")", "\n", "normalized_weights", "=", "[", "w", "/", "total", "for", "w", "in", "weights", "]", "\n", "\n", "start", "=", "choice", "(", "g", ".", "neighbors", "(", "start", ")", ",", "p", "=", "normalized_weights", ")", "\n", "\n", "", "walk", ".", "append", "(", "(", "_p", ",", "start", ")", ")", "\n", "if", "start", "in", "unused_nodes", ":", "\n", "            ", "unused_nodes", ".", "remove", "(", "start", ")", "\n", "\n", "", "if", "restart", ":", "\n", "            ", "if", "np", ".", "random", ".", "binomial", "(", "1", ",", "restart", ")", ":", "\n", "                ", "start", "=", "s", "\n", "", "", "if", "stop", ":", "\n", "            ", "if", "count", ">=", "stop", ":", "\n", "                ", "break", "\n", "\n", "", "", "count", "+=", "1", "\n", "", "return", "walk", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.firstHits": [[254, 260], ["rw.path_from_walk", "rw.observed_walk", "zip", "firsthit.append", "rw.observed_walk", "path_from_walk.index"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.path_from_walk", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.observed_walk", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.observed_walk"], ["", "def", "firstHits", "(", "walk", ")", ":", "\n", "    ", "firsthit", "=", "[", "]", "\n", "path", "=", "path_from_walk", "(", "walk", ")", "\n", "for", "i", "in", "observed_walk", "(", "walk", ")", ":", "\n", "        ", "firsthit", ".", "append", "(", "path", ".", "index", "(", "i", ")", ")", "\n", "", "return", "zip", "(", "observed_walk", "(", "walk", ")", ",", "firsthit", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.observed_walk": [[264, 272], ["rw.path_from_walk", "result.append"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.path_from_walk"], ["", "def", "observed_walk", "(", "walk", ")", ":", "\n", "    ", "seen", "=", "{", "}", "\n", "result", "=", "[", "]", "\n", "for", "item", "in", "path_from_walk", "(", "walk", ")", ":", "\n", "        ", "if", "item", "in", "seen", ":", "continue", "\n", "seen", "[", "item", "]", "=", "1", "\n", "result", ".", "append", "(", "item", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.path_from_walk": [[274, 278], ["list", "list.append", "zip"], "function", ["None"], ["", "def", "path_from_walk", "(", "walk", ")", ":", "\n", "    ", "path", "=", "list", "(", "zip", "(", "*", "walk", ")", "[", "0", "]", ")", "# first element from each tuple", "\n", "path", ".", "append", "(", "walk", "[", "-", "1", "]", "[", "1", "]", ")", "# second element from last tuple", "\n", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.genX": [[281, 291], ["rw.random_walk", "rw.observed_walk", "list", "zip", "range", "len", "rw.firstHits"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.random_walk", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.observed_walk", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.firstHits"], ["", "def", "genX", "(", "g", ",", "s", "=", "None", ",", "use_irts", "=", "0", ",", "seed", "=", "None", ",", "weighted", "=", "False", ",", "stop", "=", "None", ",", "restart", "=", "0", ")", ":", "\n", "    ", "rwalk", "=", "random_walk", "(", "g", ",", "s", ",", "seed", ",", "weighted", ",", "stop", ",", "restart", ")", "\n", "Xs", "=", "observed_walk", "(", "rwalk", ")", "\n", "\n", "if", "use_irts", "==", "0", ":", "\n", "        ", "return", "Xs", ",", "rwalk", "\n", "", "else", ":", "\n", "        ", "fh", "=", "list", "(", "zip", "(", "*", "firstHits", "(", "rwalk", ")", ")", "[", "1", "]", ")", "\n", "irts", "=", "[", "fh", "[", "i", "]", "-", "fh", "[", "i", "-", "1", "]", "for", "i", "in", "range", "(", "1", ",", "len", "(", "fh", ")", ")", "]", "\n", "return", "Xs", ",", "rwalk", ",", "irts", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.get_fluid_cat_switches": [[298, 325], ["enumerate", "cat.append", "A_NAME.get", "A_NAME.get", "A_NAME.get.intersection", "cat.append", "len", "cat.append", "cat.append", "cat.append"], "function", ["None"], ["", "", "def", "get_fluid_cat_switches", "(", "a_names", ",", "start", ")", ":", "\n", "##calculate whether category changes as per Abbott et al.: i.e., category switch only when next word has no categories in common with previous word.", "\n", "    ", "j", "=", "0", "\n", "cat", "=", "[", "]", "\n", "#cat_names=[]", "\n", "for", "i", ",", "n", "in", "enumerate", "(", "a_names", ")", ":", "\n", "        ", "if", "(", "n", "==", "start", "and", "i", "==", "0", ")", "or", "i", "==", "0", ":", "\n", "            ", "cat", ".", "append", "(", "j", ")", "\n", "#cat_names.append(None)           ", "\n", "", "else", ":", "\n", "##!!!change this back", "\n", "            ", "s", "=", "A_NAME", ".", "get", "(", "n", ")", "\n", "t", "=", "A_NAME", ".", "get", "(", "a_names", "[", "i", "-", "1", "]", ")", "\n", "if", "s", "==", "None", "or", "t", "==", "None", ":", "\n", "                ", "if", "n", "==", "'animal:N'", "or", "a_names", "[", "i", "-", "1", "]", "==", "'animal:N'", ":", "#or n == 'billy_goat:N' or a_names[i-1] == 'billy_goat:N':", "\n", "                    ", "cat", ".", "append", "(", "j", ")", "\n", "continue", "\n", "", "cat", ".", "append", "(", "None", ")", "\n", "continue", "\n", "", "intsct", "=", "t", ".", "intersection", "(", "s", ")", "\n", "if", "len", "(", "intsct", ")", "==", "0", ":", "\n", "                ", "j", "+=", "1", "\n", "cat", ".", "append", "(", "j", ")", "\n", "#cat_names.append", "\n", "", "else", ":", "\n", "                ", "cat", ".", "append", "(", "j", ")", "\n", "", "", "", "return", "cat", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.create_irt_graph": [[330, 417], ["len", "enumerate", "enumerate", "enumerate", "scipy.stats.sem", "enumerate", "n.append", "p.append", "neg_order.append", "cat.index", "pos_order.append", "enumerate", "float", "float", "neg_order.append", "w.index", "pos_order.append", "cat.index", "binned.get", "w.index", "binned_sem[].append", "len", "len"], "function", ["None"], ["", "def", "create_irt_graph", "(", "b", ",", "cat", ",", "multi", "=", "False", ")", ":", "\n", "    ", "'''Determine the IRT for patch entry positions normalized to the average long-term IRT within one trial.'''", "\n", "orders", "=", "[", "]", "\n", "\n", "n", "=", "[", "]", "\n", "p", "=", "[", "]", "\n", "irts", "=", "[", "]", "\n", "\n", "if", "multi", "==", "True", ":", "\n", "#assert len(b)==len(cat)", "\n", "        ", "size", "=", "len", "(", "cat", ")", "\n", "\n", "\n", "for", "q", ",", "w", "in", "enumerate", "(", "cat", ")", ":", "\n", "\n", "            ", "neg_order", "=", "[", "]", "\n", "pos_order", "=", "[", "]", "\n", "\n", "for", "j", ",", "k", "in", "enumerate", "(", "w", ")", ":", "\n", "\n", "#if k==cat[j]:", "\n", "#k==cat[j]", "\n", "                ", "if", "k", ">=", "w", "[", "len", "(", "w", ")", "-", "1", "]", ":", "\n", "                    ", "to_next", "=", "0", "\n", "", "else", ":", "\n", "                    ", "next_cat", "=", "w", ".", "index", "(", "k", "+", "1", ")", "\n", "to_next", "=", "next_cat", "-", "j", "\n", "\n", "", "neg_order", ".", "append", "(", "-", "to_next", ")", "\n", "\n", "same_cat", "=", "w", ".", "index", "(", "k", ")", "\n", "\n", "to_same", "=", "j", "-", "same_cat", "+", "1", "\n", "\n", "pos_order", ".", "append", "(", "to_same", ")", "\n", "\n", "", "n", ".", "append", "(", "neg_order", ")", "\n", "p", ".", "append", "(", "pos_order", ")", "\n", "#orders += [n,p]", "\n", "#irts += b[q]", "\n", "", "", "else", ":", "\n", "        ", "neg_order", "=", "[", "]", "\n", "pos_order", "=", "[", "]", "\n", "\n", "for", "j", ",", "k", "in", "enumerate", "(", "cat", ")", ":", "\n", "            ", "if", "k", ">=", "cat", "[", "len", "(", "cat", ")", "-", "1", "]", ":", "\n", "                ", "to_next", "=", "0", "\n", "", "else", ":", "\n", "                ", "next_cat", "=", "cat", ".", "index", "(", "k", "+", "1", ")", "\n", "to_next", "=", "next_cat", "-", "j", "\n", "\n", "", "neg_order", ".", "append", "(", "-", "to_next", ")", "\n", "\n", "same_cat", "=", "cat", ".", "index", "(", "k", ")", "\n", "\n", "to_same", "=", "j", "-", "same_cat", "+", "1", "\n", "\n", "pos_order", ".", "append", "(", "to_same", ")", "\n", "\n", "", "order", "=", "[", "neg_order", ",", "pos_order", "]", "\n", "\n", "", "binned", "=", "{", "}", "\n", "binned_counts", "=", "{", "}", "\n", "binned_final", "=", "{", "}", "\n", "binned_sem", "=", "{", "}", "\n", "\n", "orders", "=", "[", "n", ",", "p", "]", "\n", "#print orders", "\n", "\n", "for", "g", "in", "orders", ":", "\n", "        ", "for", "s", ",", "order", "in", "enumerate", "(", "g", ")", ":", "\n", "            ", "for", "j", ",", "k", "in", "enumerate", "(", "order", ")", ":", "\n", "\n", "                ", "if", "binned", ".", "get", "(", "k", ",", "None", ")", ":", "\n", "                    ", "binned", "[", "k", "]", "+=", "b", "[", "s", "]", "[", "j", "-", "1", "]", "\n", "binned_counts", "[", "k", "]", "+=", "1", "\n", "binned_sem", "[", "k", "]", ".", "append", "(", "b", "[", "s", "]", "[", "j", "-", "1", "]", ")", "\n", "", "else", ":", "\n", "                    ", "binned", "[", "k", "]", "=", "b", "[", "s", "]", "[", "j", "-", "1", "]", "if", "not", "j", "==", "0", "else", "0", "\n", "binned_counts", "[", "k", "]", "=", "1", "\n", "binned_sem", "[", "k", "]", "=", "[", "]", "\n", "\n", "", "", "", "", "for", "key", "in", "binned", ":", "\n", "        ", "binned_final", "[", "key", "]", "=", "float", "(", "binned", "[", "key", "]", ")", "/", "float", "(", "binned_counts", "[", "key", "]", ")", "\n", "binned_sem", "[", "key", "]", "=", "scipy", ".", "stats", ".", "sem", "(", "binned_sem", "[", "key", "]", ")", "\n", "\n", "", "return", "binned_final", ",", "binned_sem", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.irt_self_longterm_avg": [[419, 510], ["len", "enumerate", "enumerate", "enumerate", "scipy.stats.sem", "enumerate", "n.append", "p.append", "neg_order.append", "cat.index", "pos_order.append", "rw.mean", "enumerate", "float", "float", "neg_order.append", "w.index", "pos_order.append", "cat.index", "binned.get", "max", "binned_sem[].append", "w.index", "len"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean"], ["", "def", "irt_self_longterm_avg", "(", "b", ",", "cat", ",", "multi", "=", "True", ")", ":", "\n", "    ", "'''Determine IRTs for each patch entry positions using fluid categories normalized to the long-term average IRT accross all trials in the experiment.'''", "\n", "orders", "=", "[", "]", "\n", "\n", "n", "=", "[", "]", "\n", "p", "=", "[", "]", "\n", "irts", "=", "[", "]", "\n", "\n", "if", "multi", "==", "True", ":", "\n", "#assert len(b)==len(cat)", "\n", "        ", "size", "=", "len", "(", "cat", ")", "\n", "\n", "\n", "for", "q", ",", "w", "in", "enumerate", "(", "cat", ")", ":", "\n", "\n", "            ", "neg_order", "=", "[", "]", "\n", "pos_order", "=", "[", "]", "\n", "\n", "for", "j", ",", "kk", "in", "enumerate", "(", "w", ")", ":", "\n", "\n", "                ", "if", "kk", ">=", "max", "(", "w", ")", ":", "\n", "                    ", "to_next", "=", "0", "\n", "", "elif", "kk", "==", "None", ":", "\n", "                    ", "continue", "\n", "#print 'Error: list index'", "\n", "", "else", ":", "\n", "                    ", "next_cat", "=", "w", ".", "index", "(", "kk", "+", "1", ")", "\n", "to_next", "=", "next_cat", "-", "j", "\n", "\n", "", "neg_order", ".", "append", "(", "-", "to_next", ")", "\n", "\n", "same_cat", "=", "w", ".", "index", "(", "kk", ")", "\n", "\n", "to_same", "=", "j", "-", "same_cat", "+", "1", "\n", "\n", "pos_order", ".", "append", "(", "to_same", ")", "\n", "\n", "", "n", ".", "append", "(", "neg_order", ")", "\n", "p", ".", "append", "(", "pos_order", ")", "\n", "\n", "", "", "else", ":", "\n", "\n", "        ", "neg_order", "=", "[", "]", "\n", "pos_order", "=", "[", "]", "\n", "\n", "for", "j", ",", "k", "in", "enumerate", "(", "cat", ")", ":", "\n", "            ", "if", "k", ">=", "cat", "[", "len", "(", "cat", ")", "-", "1", "]", ":", "\n", "                ", "to_next", "=", "0", "\n", "", "else", ":", "\n", "                ", "next_cat", "=", "cat", ".", "index", "(", "k", "+", "1", ")", "\n", "to_next", "=", "next_cat", "-", "j", "\n", "\n", "", "neg_order", ".", "append", "(", "-", "to_next", ")", "\n", "\n", "same_cat", "=", "cat", ".", "index", "(", "k", ")", "\n", "\n", "to_same", "=", "j", "-", "same_cat", "+", "1", "\n", "\n", "pos_order", ".", "append", "(", "to_same", ")", "\n", "\n", "", "order", "=", "[", "neg_order", ",", "pos_order", "]", "\n", "\n", "", "binned", "=", "{", "}", "\n", "binned_counts", "=", "{", "}", "\n", "binned_final", "=", "{", "}", "\n", "binned_sem", "=", "{", "}", "\n", "\n", "orders", "=", "[", "n", ",", "p", "]", "\n", "\n", "\n", "for", "g", "in", "orders", ":", "\n", "        ", "for", "s", ",", "order", "in", "enumerate", "(", "g", ")", ":", "\n", "            ", "ind_mean", "=", "mean", "(", "b", "[", "s", "]", ")", "\n", "for", "j", ",", "k", "in", "enumerate", "(", "order", ")", ":", "\n", "\n", "                ", "if", "binned", ".", "get", "(", "k", ",", "None", ")", ":", "\n", "#", "\n", "                    ", "binned", "[", "k", "]", "+=", "b", "[", "s", "]", "[", "j", "-", "1", "]", "/", "ind_mean", "\n", "binned_counts", "[", "k", "]", "+=", "1", "\n", "#", "\n", "binned_sem", "[", "k", "]", ".", "append", "(", "b", "[", "s", "]", "[", "j", "-", "1", "]", "/", "ind_mean", ")", "\n", "", "else", ":", "\n", "                    ", "binned", "[", "k", "]", "=", "b", "[", "s", "]", "[", "j", "-", "1", "]", "/", "ind_mean", "if", "not", "j", "==", "0", "else", "0", "\n", "binned_counts", "[", "k", "]", "=", "1", "\n", "binned_sem", "[", "k", "]", "=", "[", "]", "\n", "\n", "", "", "", "", "for", "key", "in", "binned", ":", "\n", "        ", "binned_final", "[", "key", "]", "=", "float", "(", "binned", "[", "key", "]", ")", "/", "float", "(", "binned_counts", "[", "key", "]", ")", "\n", "binned_sem", "[", "key", "]", "=", "scipy", ".", "stats", ".", "sem", "(", "binned_sem", "[", "key", "]", ")", "\n", "\n", "", "return", "binned_final", ",", "binned_sem", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.write_summary": [[511, 523], ["open", "l.write", "l.write", "l.write", "l.write", "l.write", "l.write", "l.write", "rw.mean", "rw.mean", "rw.a_len", "rw.mean", "scipy.stats.tstd", "rw.mean", "scipy.stats.tstd", "rw.mean", "scipy.stats.tstd", "len", "rw.mean", "list", "itertools.groupby"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.a_len", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean"], ["", "def", "write_summary", "(", "title", ",", "a", ",", "c", ",", "itr", ")", ":", "\n", "    ", "with", "open", "(", "title", "+", "'_summary.txt'", ",", "'a'", ")", "as", "l", ":", "\n", "        ", "l", ".", "write", "(", "'\\n----------------------------------\\n'", ")", "\n", "l", ".", "write", "(", "'SUMMARY STATISTICS:'", ")", "\n", "l", ".", "write", "(", "'\\n----------------------------------\\n'", ")", "\n", "avg_words", "=", "[", "mean", "(", "a_len", "(", "z", ")", ")", "for", "z", "in", "c", "]", "\n", "avg_patch_switch", "=", "[", "q", "[", "-", "1", ":", "]", "[", "0", "]", "for", "q", "in", "c", "]", "\n", "avg_itm_ptch", "=", "[", "mean", "(", "[", "len", "(", "list", "(", "group", ")", ")", "for", "key", ",", "group", "in", "groupby", "(", "m", ")", "]", ")", "for", "m", "in", "c", "]", "\n", "l", ".", "write", "(", "'Avg words: {0:.3f} (SD {1:.3f})\\n'", ".", "format", "(", "mean", "(", "avg_words", ")", ",", "scipy", ".", "stats", ".", "tstd", "(", "avg_words", ")", ")", ")", "\n", "l", ".", "write", "(", "'Avg backtracking: {0:.3f}\\n'", ".", "format", "(", "itr", "-", "mean", "(", "avg_words", ")", ")", ")", "\n", "l", ".", "write", "(", "'Avg patch switches: {0:.3f} (SD {1:.3f})\\n'", ".", "format", "(", "mean", "(", "avg_patch_switch", ")", ",", "scipy", ".", "stats", ".", "tstd", "(", "avg_patch_switch", ")", ")", ")", "\n", "l", ".", "write", "(", "'Avg itms/patch: {0:.3f} (SD {1:.3f})\\n'", ".", "format", "(", "mean", "(", "avg_itm_ptch", ")", ",", "scipy", ".", "stats", ".", "tstd", "(", "avg_itm_ptch", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.has_irt_pattern": [[526, 564], ["rw.mean", "scipy.stats.sem", "binned_final.items", "rw.mean", "rw.mean", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean"], ["", "", "def", "has_irt_pattern", "(", "irts", ",", "binned_final", ",", "binned_sem", ",", "weak", "=", "False", ")", ":", "\n", "    ", "'''Determine whether IRTs conform to the expected pattern observed in human data. If weak = True, use less stringesnt cut-offs for the first and last patch entry positions.\n    Return 2 for yes,\n    1 for yes but weak (see above),\n    0 for no.'''", "\n", "upper", "=", "1.2", "\n", "lower", "=", "0.8", "\n", "\n", "if", "weak", ":", "\n", "        ", "upper", "=", "1.1", "\n", "lower", "=", "0.9", "\n", "\n", "", "lt_average", "=", "mean", "(", "[", "mean", "(", "irt", ")", "for", "irt", "in", "irts", "]", ")", "\n", "lt_sem", "=", "scipy", ".", "stats", ".", "sem", "(", "[", "mean", "(", "irt", ")", "/", "lt_average", "for", "irt", "in", "irts", "]", ")", "\n", "\n", "#print 'LT_SEM: ' + str(lt_sem)", "\n", "\n", "for", "i", ",", "v", "in", "binned_final", ".", "items", "(", ")", ":", "\n", "#check if items before patch entry are below 1", "\n", "\n", "#we exclude 0 because it represents the last category visited when calculating negative patch entries (i.e. [-1,-2,-3,0,0]", "\n", "        ", "if", "i", "==", "0", ":", "\n", "            ", "continue", "\n", "\n", "#print i,v-binned_sem[i]", "\n", "\n", "", "if", "i", "==", "1", ":", "\n", "            ", "if", "v", "+", "binned_sem", "[", "i", "]", "<", "upper", ":", "\n", "                ", "return", "False", "\n", "", "", "elif", "i", "in", "np", ".", "arange", "(", "-", "4", ",", "3", ",", "1", ")", ":", "\n", "            ", "if", "v", "-", "binned_sem", "[", "i", "]", ">", "1", "+", "lt_sem", ":", "\n", "                ", "return", "False", "\n", "#check that second patch entry item is at least 0.8", "\n", "", "if", "i", "==", "2", "and", "v", "-", "binned_sem", "[", "i", "]", ">", "lower", ":", "\n", "                ", "return", "False", "\n", "#make sure first patch entry item is at least 1.2", "\n", "\n", "", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.plot_irt": [[566, 591], ["rw..", "range", "scipy.array", "pylab.figure", "pylab.figure.add_axes", "f.add_axes.bar", "f.add_axes.set_xticks", "f.add_axes.set_xticklabels", "f.add_axes.set_xlabel", "f.add_axes.set_ylabel", "f.add_axes.set_title", "pylab.plot", "f.add_axes.errorbar", "pylab.figure.savefig", "binned_sem.get", "binned_final.get", "str", "rw.mean", "rw.mean", "rw.a_len"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.mean", "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.a_len"], ["", "def", "plot_irt", "(", "a", ",", "b", ",", "cat", ",", "title", ")", ":", "\n", "    ", "'''Create a plot of IRTs.'''", "\n", "binned_final", ",", "binned_sem", "=", "irt_self_longterm_avg", "(", "b", ",", "cat", ",", "multi", "=", "True", ")", "\n", "\n", "r", "=", "[", "-", "3", ",", "-", "2", ",", "-", "1", ",", "1", ",", "2", ",", "3", ",", "4", "]", "\n", "\n", "x", "=", "range", "(", "0", ",", "7", ")", "\n", "#y = scipy.array([binned_final.get(i,None) for i in r])", "\n", "#yerr=[binned_sem.get(i,None) for i in r]", "\n", "y", "=", "scipy", ".", "array", "(", "[", "binned_final", ".", "get", "(", "i", ",", "0", ")", "for", "i", "in", "r", "]", ")", "\n", "yerr", "=", "[", "binned_sem", ".", "get", "(", "i", ",", "0", ")", "for", "i", "in", "r", "]", "\n", "f", "=", "pylab", ".", "figure", "(", ")", "\n", "#merge in one figure (TODO not working)", "\n", "##pylab.subplot(x_dim,y_dim,p)                    ", "\n", "ax", "=", "f", ".", "add_axes", "(", "[", "0.1", ",", "0.1", ",", "0.8", ",", "0.8", "]", ")", "\n", "ax", ".", "bar", "(", "x", ",", "y", ",", "align", "=", "'center'", ")", "\n", "ax", ".", "set_xticks", "(", "x", ")", "\n", "ax", ".", "set_xticklabels", "(", "r", ")", "\n", "ax", ".", "set_xlabel", "(", "'Patch Entry Position'", ")", "\n", "ax", ".", "set_ylabel", "(", "'Average IRT/Long-term Average IRT'", ")", "\n", "ax", ".", "set_title", "(", "title", "+", "' avg-words:'", "+", "str", "(", "mean", "(", "[", "mean", "(", "a_len", "(", "z", ")", ")", "for", "z", "in", "cat", "]", ")", ")", ")", "\n", "pylab", ".", "plot", "(", "[", "-", "1", ",", "7", "]", ",", "[", "1", ",", "1", "]", ")", "\n", "ax", ".", "errorbar", "(", "x", ",", "y", ",", "yerr", "=", "yerr", ",", "fmt", "=", "'o'", ")", "\n", "#f.show()", "\n", "f", ".", "savefig", "(", "'irts/'", "+", "title", "+", "'.png'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.annotate_curve_IRTs": [[595, 638], ["zip", "fig.canvas.mpl_connect", "fig.get_axes", "mpl_toolkits.mplot3d.proj3d.proj_transform", "matplotlib._png.read_png", "matplotlib.offsetbox.OffsetImage", "matplotlib.offsetbox.AnnotationBbox", "ax.add_artist", "matplotlib.offsetbox.AnnotationBbox.draggable", "ax.set_xlim", "ax.set_ylim", "plotlabels.append", "ax.get_proj", "rw.update_position", "dict", "zip", "str", "str"], "function", ["home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.update_position"], ["", "def", "annotate_curve_IRTs", "(", "fig", ",", "xs", ",", "ys", ",", "zs", ",", "prefix", ")", ":", "\n", "    ", "'''Produce 3-dimensional plot with IRTs on graph.'''", "\n", "if", "not", "fig", ":", "\n", "        ", "return", "None", "\n", "#fig = plt.figure()", "\n", "#ax = fig.add_subplot(111, projection = '3d')", "\n", "", "ax", "=", "fig", ".", "get_axes", "(", ")", "[", "0", "]", "\n", "#points = np.array([(1,1,1), (2,2,2)])", "\n", "plotlabels", "=", "[", "]", "\n", "#xs, ys, zs = np.split(points, 3, axis=1)", "\n", "#sc = ax.scatter(xs,ys,zs)", "\n", "\n", "for", "x", ",", "y", ",", "z", "in", "zip", "(", "xs", ",", "ys", ",", "zs", ")", ":", "\n", "        ", "x2", ",", "y2", ",", "_", "=", "proj3d", ".", "proj_transform", "(", "x", ",", "y", ",", "z", ",", "ax", ".", "get_proj", "(", ")", ")", "\n", "\n", "##get image", "\n", "#fn = get_sample_data(\"grace_hopper.png\", asfileobj=False)", "\n", "\n", "png_name", "=", "'_'", ".", "join", "(", "prefix", "+", "[", "str", "(", "y", ")", ",", "'A'", "+", "str", "(", "x", ")", "]", ")", "\n", "\n", "arr_lena", "=", "read_png", "(", "'irts/'", "+", "png_name", "+", "'.png'", ")", "\n", "\n", "imagebox", "=", "OffsetImage", "(", "arr_lena", ",", "zoom", "=", "0.2", ")", "\n", "#", "\n", "#", "\n", "ab", "=", "AnnotationBbox", "(", "imagebox", ",", "xy", "=", "(", "x2", ",", "y2", ")", ",", "\n", "xybox", "=", "(", "100.", ",", "-", "60.", ")", ",", "\n", "xycoords", "=", "'data'", ",", "boxcoords", "=", "\"offset points\"", ",", "pad", "=", "0.5", ",", "arrowprops", "=", "dict", "(", "arrowstyle", "=", "\"->\"", ",", "connectionstyle", "=", "\"angle,angleA=0,angleB=90,rad=3\"", ")", ")", "\n", "ax", ".", "add_artist", "(", "ab", ")", "\n", "\n", "ab", ".", "draggable", "(", ")", "\n", "\n", "ax", ".", "set_xlim", "(", "0", ",", "1", ")", "\n", "ax", ".", "set_ylim", "(", "0", ",", "1", ")", "\n", "#get image", "\n", "\n", "label", "=", "ab", "#plt.annotate(", "\n", "#txt, xy = (x2, y2), xytext = (-20, 20),", "\n", "#textcoords = 'offset points', ha = 'right', va = 'bottom',", "\n", "#bbox = dict(boxstyle = 'round,pad=0.5', fc = 'yellow', alpha = 0.5),", "\n", "#arrowprops = dict(arrowstyle = '-', connectionstyle = 'arc3,rad=0'))", "\n", "plotlabels", ".", "append", "(", "label", ")", "\n", "", "fig", ".", "canvas", ".", "mpl_connect", "(", "'motion_notify_event'", ",", "lambda", "event", ":", "update_position", "(", "event", ",", "fig", ",", "ax", ",", "zip", "(", "plotlabels", ",", "xs", ",", "ys", ",", "zs", ")", ")", ")", "\n", "#plt.show()", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.rw.update_position": [[640, 647], ["fig.canvas.draw", "mpl_toolkits.mplot3d.proj3d.proj_transform", "label.update_positions", "ax.get_proj"], "function", ["None"], ["", "def", "update_position", "(", "e", ",", "fig", ",", "ax", ",", "labels_and_points", ")", ":", "\n", "    ", "'''Update position of labels on event e. Used by annotate_curve_IRTs.'''", "\n", "for", "label", ",", "x", ",", "y", ",", "z", "in", "labels_and_points", ":", "\n", "        ", "x2", ",", "y2", ",", "_", "=", "proj3d", ".", "proj_transform", "(", "x", ",", "y", ",", "z", ",", "ax", ".", "get_proj", "(", ")", ")", "\n", "label", ".", "xy", "=", "x2", ",", "y2", "\n", "label", ".", "update_positions", "(", "fig", ".", "canvas", ".", "renderer", ")", "\n", "", "fig", ".", "canvas", ".", "draw", "(", ")", "", "", ""]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.adj_rand.test_avg_adj_rand": [[5, 27], ["sklearn.metrics.adjusted_rand_score"], "function", ["None"], ["def", "test_avg_adj_rand", "(", "d", ")", ":", "\n", "    ", "'''Determine the adjusted rand index for a clustering. d is a list of lists representing the clustering, and the number represents their ground truth. Because adj rand is a symmetric value, the reverse could be true and the measure would be the same (i.e., the clusters could be the ground truth clusters and the number the putative clusters).'''", "\n", "g", "=", "0", "\n", "clusters", "=", "[", "]", "\n", "ground_truth", "=", "[", "]", "\n", "for", "c", "in", "d", ":", "\n", "        ", "clusters", "+=", "[", "g", "for", "cc", "in", "c", "]", "\n", "ground_truth", "+=", "c", "\n", "g", "+=", "1", "\n", "\n", "#one = adj_rand(clusters, ground_truth)", "\n", "#two = np.mean( [ adj_rand([0 for i in c],c) for c in d ] )", "\n", "", "'''\n    print d\n    print '----------------'\n    print ground_truth\n    print clusters\n    '''", "\n", "#if one != two:", "\n", "#    print 'WARNING: Adj rand index differs'", "\n", "#    print one, two", "\n", "return", "adj_rand", "(", "clusters", ",", "ground_truth", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.adj_rand.test_get_cluster_cat_labels": [[28, 67], ["all_cluster_labels.append", "names.append", "max", "labels.append", "labels.append", "cluster_categories.get", "ALL_CATEG_NAMES.index", "cluster_categories.items", "list"], "function", ["None"], ["", "def", "test_get_cluster_cat_labels", "(", "graph", ",", "clusters", ")", ":", "\n", "    ", "all_cluster_labels", "=", "[", "]", "\n", "for", "cluster", "in", "clusters", ":", "\n", "\n", "        ", "labels", "=", "[", "]", "\n", "\n", "cluster_categories", "=", "{", "}", "\n", "names", "=", "[", "]", "\n", "#if len(cluster) == 1: #uncomment this to discount singletonss", "\n", "#continue", "\n", "for", "vid", "in", "cluster", ":", "\n", "            ", "name", "=", "graph", ".", "vs", "[", "vid", "]", "[", "'label'", "]", "\n", "\n", "names", ".", "append", "(", "name", ")", "\n", "for", "s", "in", "A_NAME", "[", "name", "]", ":", "\n", "                ", "if", "cluster_categories", ".", "get", "(", "s", ")", "==", "None", ":", "\n", "                    ", "cluster_categories", "[", "s", "]", "=", "1", "\n", "", "else", ":", "\n", "                    ", "cluster_categories", "[", "s", "]", "+=", "1", "\n", "\n", "#cluster label is most frequently occurring category in the cluster", "\n", "", "", "", "cluster_category", "=", "max", "(", "[", "(", "value", ",", "key", ")", "for", "key", ",", "value", "in", "cluster_categories", ".", "items", "(", ")", "]", ")", "[", "1", "]", "\n", "\n", "#print cluster_category", "\n", "\n", "for", "vid", "in", "cluster", ":", "\n", "            ", "name", "=", "graph", ".", "vs", "[", "vid", "]", "[", "'label'", "]", "\n", "\n", "#print '    ' + name", "\n", "\n", "if", "cluster_category", "in", "A_NAME", "[", "name", "]", ":", "\n", "                ", "labels", ".", "append", "(", "ALL_CATEG_NAMES", ".", "index", "(", "cluster_category", ")", ")", "#A_NUM[ cluster_category+':N' ] )", "\n", "", "else", ":", "\n", "#just get the first category the remaining animal belongs to for now", "\n", "                ", "labels", ".", "append", "(", "list", "(", "A_NUM", "[", "name", "]", ")", "[", "0", "]", ")", "\n", "\n", "", "", "all_cluster_labels", ".", "append", "(", "labels", ")", "\n", "\n", "", "return", "all_cluster_labels", "", "", ""]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.frequency.adjacency_names": [[3, 21], ["open", "range", "f.write", "graph.vcount", "enumerate", "f.write", "graph.neighbors", "f.write", "f.write", "f.write", "len"], "function", ["None"], ["def", "adjacency_names", "(", "graph", ",", "name", "=", "''", ",", "n", "=", "'graph_names'", ")", ":", "\n", "    ", "spaces", "=", "12", "\n", "\n", "with", "open", "(", "n", "+", "'.txt'", ",", "'a'", ")", "as", "f", ":", "\n", "        ", "if", "name", ":", "\n", "            ", "f", ".", "write", "(", "'Name: {}\\n'", ".", "format", "(", "name", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "0", ",", "graph", ".", "vcount", "(", ")", ")", ":", "\n", "            ", "node_name", "=", "graph", ".", "vs", "[", "'label'", "]", "[", "i", "]", "\n", "\n", "for", "q", ",", "neighbor", "in", "enumerate", "(", "graph", ".", "neighbors", "(", "i", ")", ")", ":", "\n", "                ", "if", "q", "==", "0", ":", "\n", "                    ", "f", ".", "write", "(", "node_name", "+", "' '", "*", "(", "spaces", "-", "len", "(", "node_name", ")", ")", "+", "graph", ".", "vs", "[", "'label'", "]", "[", "neighbor", "]", ")", "\n", "f", ".", "write", "(", "'\\n'", ")", "\n", "\n", "", "else", ":", "\n", "                    ", "f", ".", "write", "(", "' '", "*", "spaces", "+", "graph", ".", "vs", "[", "neighbor", "]", "[", "'label'", "]", "+", "'\\n'", ")", "\n", "", "", "f", ".", "write", "(", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.frequency.count_occurences": [[22, 44], ["range", "g.ecount", "tuple.sort", "tuple", "open", "freq.keys"], "function", ["None"], ["", "", "", "def", "count_occurences", "(", "g", ",", "corpus", ")", ":", "\n", "    ", "freq", "=", "{", "}", "\n", "\n", "#regex=[]", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "g", ".", "ecount", "(", ")", ")", ":", "\n", "        ", "s", "=", "g", ".", "es", "[", "i", "]", ".", "source", "\n", "t", "=", "g", ".", "es", "[", "i", "]", ".", "target", "\n", "k", "=", "[", "g", ".", "vs", "[", "'label'", "]", "[", "s", "]", ",", "g", ".", "vs", "[", "'label'", "]", "[", "t", "]", "]", "\n", "k", ".", "sort", "(", ")", "\n", "#because tuples are hashable while lists are not", "\n", "k", "=", "tuple", "(", "k", ")", "\n", "\n", "freq", "[", "k", "]", "=", "0", "\n", "\n", "", "with", "open", "(", "corpus", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ":", "\n", "            ", "for", "key", "in", "freq", ".", "keys", "(", ")", ":", "\n", "                ", "if", "key", "[", "0", "]", "in", "line", "and", "key", "[", "1", "]", "in", "line", ":", "\n", "                    ", "freq", "[", "key", "]", "+=", "1", "\n", "\n", "", "", "", "", "return", "freq", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.frequency.compare_features": [[46, 62], ["open", "csv.writer", "csv.writer.writerow", "learner._learned_lexicon.meaning().sorted_features", "gold.meaning().sorted_features", "learner.acquisition_score", "range", "csv.writer.writerow", "len", "csv.writer.writerow", "learner._learned_lexicon.meaning", "gold.meaning", "len", "len"], "function", ["None"], ["", "def", "compare_features", "(", "gold", ",", "learner", ",", "n", "=", "'features.csv'", ")", ":", "\n", "    ", "with", "open", "(", "n", ",", "'ab'", ")", "as", "csvfile", ":", "\n", "        ", "writer", "=", "csv", ".", "writer", "(", "csvfile", ",", "delimiter", "=", "','", ",", "\n", "quotechar", "=", "\"\\\"\"", ",", "quoting", "=", "csv", ".", "QUOTE_MINIMAL", ")", "\n", "writer", ".", "writerow", "(", "[", "'Word'", ",", "'Gold Features'", ",", "'Score'", ",", "'Learned Features'", ",", "'Score'", ",", "'COS sim'", "]", ")", "\n", "\n", "for", "word", "in", "SHARED_HILLS_POS_CATEG_NAMED", ":", "\n", "            ", "lf", "=", "learner", ".", "_learned_lexicon", ".", "meaning", "(", "word", ")", ".", "sorted_features", "(", ")", "\n", "gf", "=", "gold", ".", "meaning", "(", "word", ")", ".", "sorted_features", "(", ")", "\n", "sim", "=", "learner", ".", "acquisition_score", "(", "word", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "gf", ")", ")", ":", "\n", "                ", "gf_f", "=", "[", "gf", "[", "i", "]", "[", "1", "]", ",", "gf", "[", "i", "]", "[", "0", "]", "]", "if", "i", "<", "len", "(", "gf", ")", "else", "[", "''", ",", "''", "]", "\n", "lf_f", "=", "[", "lf", "[", "i", "]", "[", "1", "]", ",", "lf", "[", "i", "]", "[", "0", "]", "]", "if", "i", "<", "len", "(", "lf", ")", "else", "[", "''", ",", "''", "]", "\n", "writer", ".", "writerow", "(", "[", "word", "if", "i", "==", "0", "else", "''", "]", "+", "gf_f", "+", "lf_f", "+", "[", "sim", "if", "i", "==", "0", "else", "''", "]", ")", "\n", "\n", "", "writer", ".", "writerow", "(", "[", "''", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.FilipMiscevic_random_walk.None.frequency.comparative_adjacency_csv": [[63, 152], ["open", "csv.writer", "csv.writer.writerow", "range", "gold_graph.vcount", "gold_graph.neighbors", "enumerate", "graph.neighbors", "max", "range", "len", "len", "csv.writer.writerow", "csv.writer.writerow", "graph.vs.find", "len", "len", "csv.writer.writerow", "csv.writer.writerow", "graph.get_eid", "tuple", "gold_graph.get_eid", "sorted", "graph.vs.find", "gold_graph.vs.find"], "function", ["None"], ["", "", "", "def", "comparative_adjacency_csv", "(", "graph", ",", "gold_graph", ",", "counts", ",", "name", "=", "''", ",", "n", "=", "'graph_names.csv'", ")", ":", "\n", "    ", "with", "open", "(", "n", ",", "'ab'", ")", "as", "csvfile", ":", "\n", "        ", "writer", "=", "csv", ".", "writer", "(", "csvfile", ",", "delimiter", "=", "','", ",", "\n", "quotechar", "=", "\"\\\"\"", ",", "quoting", "=", "csv", ".", "QUOTE_MINIMAL", ")", "\n", "\n", "writer", ".", "writerow", "(", "[", "'Node'", ",", "'Name'", ",", "'Dist'", ",", "name", ",", "'Name'", ",", "'Dist'", ",", "'Freq'", "]", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "gold_graph", ".", "vcount", "(", ")", ")", ":", "\n", "            ", "node_name", "=", "gold_graph", ".", "vs", "[", "'label'", "]", "[", "i", "]", "\n", "\n", "gg_nb", "=", "gold_graph", ".", "neighbors", "(", "i", ")", "\n", "\n", "if", "node_name", "not", "in", "graph", ".", "vs", "[", "'label'", "]", ":", "\n", "                ", "for", "n", ",", "d", "in", "enumerate", "(", "gg_nb", ")", ":", "\n", "                    ", "if", "n", "==", "0", ":", "\n", "                        ", "writer", ".", "writerow", "(", "[", "node_name", ",", "gold_graph", ".", "vs", "[", "'label'", "]", "[", "d", "]", "]", ")", "\n", "", "else", ":", "\n", "                        ", "writer", ".", "writerow", "(", "[", "''", ",", "gold_graph", ".", "vs", "[", "'label'", "]", "[", "d", "]", "]", ")", "\n", "", "", "", "else", ":", "\n", "                ", "g_nb", "=", "graph", ".", "neighbors", "(", "graph", ".", "vs", ".", "find", "(", "label", "=", "node_name", ")", ".", "index", ")", "\n", "\n", "size", "=", "max", "(", "len", "(", "g_nb", ")", ",", "len", "(", "gg_nb", ")", ")", "\n", "\n", "for", "s", "in", "range", "(", "0", ",", "size", ")", ":", "\n", "\n", "\n", "                    ", "g", "=", "[", "]", "\n", "if", "s", "<", "len", "(", "g_nb", ")", ":", "\n", "                        ", "g", "=", "[", "graph", ".", "vs", "[", "'label'", "]", "[", "g_nb", "[", "s", "]", "]", ",", "graph", ".", "es", "[", "'distance'", "]", "[", "graph", ".", "get_eid", "(", "g_nb", "[", "s", "]", ",", "graph", ".", "vs", ".", "find", "(", "label", "=", "node_name", ")", ".", "index", ")", "]", ",", "counts", "[", "\n", "tuple", "(", "sorted", "(", "\n", "[", "graph", ".", "vs", "[", "'label'", "]", "[", "g_nb", "[", "s", "]", "]", ",", "node_name", "]", "\n", ")", ")", "]", "]", "\n", "\n", "#gg=[]", "\n", "", "if", "s", "<", "len", "(", "gg_nb", ")", ":", "\n", "                        ", "gg", "=", "[", "gold_graph", ".", "vs", "[", "'label'", "]", "[", "gg_nb", "[", "s", "]", "]", ",", "gold_graph", ".", "es", "[", "'distance'", "]", "[", "gold_graph", ".", "get_eid", "(", "gg_nb", "[", "s", "]", ",", "gold_graph", ".", "vs", ".", "find", "(", "label", "=", "node_name", ")", ".", "index", ")", "]", ",", "''", "]", "\n", "", "else", ":", "\n", "                        ", "gg", "=", "[", "''", ",", "''", ",", "''", "]", "\n", "\n", "\n", "\n", "\n", "", "if", "s", "==", "0", ":", "\n", "                        ", "writer", ".", "writerow", "(", "[", "node_name", "]", "+", "gg", "+", "g", ")", "\n", "", "else", ":", "\n", "                        ", "writer", ".", "writerow", "(", "[", "''", "]", "+", "gg", "+", "g", ")", "\n", "\n", "", "", "", "'''\n            \n            if node_name in graph.vs['label']:\n            \n                if len(gold_graph.neighbors(i)) < len(graph.neighbors(graph.vs.find(label=node_name).index)):\n                    g=graph\n                else:\n                    g=gold_graph\n                for q in range(0,len(g.neighbors(i))):\n                    \n                    count = 0\n                    m2 = []\n\n                    if gold_graph.vs[g.neighbors(i)[q]]['label'] in graph.vs['label'] and q < len(graph.neighbors(graph.vs.find(label=node_name).index)):\n                       \n                        for line in open('data/animals.dev'):\n                            if re.findall(r'E: (?=.*{})(?=.*{})'.format(node_name,graph.vs['label'][graph.neighbors(graph.vs.find(label=node_name).index)[q]]),line) != []:\n                                if count == 0:\n                                    print re.findall(r'E: (?=.*{})(?=.*{})'.format(node_name,graph.vs['label'][graph.neighbors(graph.vs.find(label=node_name).index)[q]]),line)\n                                    print r'E: (?=.*{})(?=.*{})'.format(node_name,graph.vs['label'][graph.neighbors(graph.vs.find(label=node_name).index)[q]])\n                                count +=1\n                        m2 = [graph.vs['label'][graph.neighbors(graph.vs.find(label=node_name).index)[q]],graph.es['distance'][graph.get_eid(i,graph.neighbors(graph.vs.find(label=node_name).index)[q])], count]\n                        \n                    m1 = [gold_graph.vs['label'][gold_graph.neighbors(i)[q]],gold_graph.es['distance'][gold_graph.get_eid(i,gold_graph.neighbors(i)[q])] ] if q < len(gold_graph.neighbors(i)) else ['','']\n                    \n                    \n                    if q == 0:\n                        writer.writerow([node_name] + m1 + m2 )\n                    else:\n                        writer.writerow([''] + m1 + m2 )\n            else:\n\n                for qq,d in enumerate(gold_graph.neighbors(i)):\n                    \n                    if qq == 0:\n                        writer.writerow([node_name, gold_graph.vs['label'][d] ])\n                        #writer.writerow([''])                 \n                        #f.write('\\n')\n                        \n                    else:\n                        writer.writerow(['', gold_graph.vs['label'][d] ])\n\n        writer.writerow([''])    '''", "\n", "", "", "", ""]]}