{"home.repos.pwc.inspect_result.canbooo_duqo.proba.mc.MC.calc_fail_prob": [[24, 150], ["generic_integrator.to_safety_index", "mc.MC.mulvar.transform_mats", "numpy.mean", "numpy.var", "int", "mc.MC._gen_post_proc", "mc.MC.const_env", "numpy.ceil", "int", "numpy.empty", "numpy.empty", "numpy.zeros", "range", "numpy.sum", "numpy.append", "numpy.append", "numpy.sum", "mc.MC.margs[].rvs", "numpy.dot", "mc.MC.const_env", "numpy.var", "print", "numpy.append.sum"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.to_safety_index", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.transform_mats", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.SUSE._gen_post_proc", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var"], ["def", "calc_fail_prob", "(", "self", ",", "prob_tol", ":", "float", "=", "1e-4", ",", "mc_batch_size", ":", "typing", ".", "Union", "[", "int", ",", "float", "]", "=", "1e5", ",", "\n", "CoV", ":", "float", "=", "0.1", ",", "max_mc_samples", ":", "typing", ".", "Union", "[", "int", ",", "float", "]", "=", "None", ",", "\n", "post_proc", ":", "bool", "=", "False", ",", "doe", "=", "None", ",", "\n", "converge", ":", "bool", "=", "True", ",", "verbose", ":", "int", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Estimate the probability of failure P(F)\n        Parameters\n        ----------\n\n        prob_tol : float\n            Defines the accuracy of the estimated failure probability in terms\n            of number of total samples\n\n        mc_batch_size : int\n            the maximum number of samples to be calculated in one call.\n            If 0, the all samples are calculated at once, although note that\n            for larger number of samples, memory errors are possible. To avoid\n            this, set this to a large number, that your memory can handle.\n        CoV : float\n            Target estimation covariance i. e. E[P(F)]/STD(P(F)). Is used to\n            estimate the maximum number of samples as well as for the convergence\n            criteria is converge is True\n        \n        max_mc_samples : int or None\n            Maximum number of samples. If passed, this will override the\n            estimation using CoV\n        \n        post_proc : bool\n            If true, sampling points will be accumulated to the attributes\n            x_lsf, x_safe and x_fail and also will return mpp, conv_mu, conv_var,\n            conv_x\n        \n        doe : None or 2d numpy array\n            If passed, this will be used for the estimation instead of\n            generating random samples\n        \n        converge : bool\n            If True, a convergence check will be done after each batch. \n            Recommended for small probabilities of failure \n\n        Returns\n        -------\n        fail_prob_mu : float\n            estimation of the expected probability of failure\n\n        fail_prob_var : float\n            estimation variance of the probability of failure\n\n        Following are only retuned if post_proc = True\n\n        safety_index :\n            Safety index, also known as the sigma level. It is equal to\n            Phi_inv(1-fail_prob_mu), where Phi_inv is the inverse of the CDF\n            of standard normal distribution\n\n\n        mpp : 2-D numpy.ndarray\n            Most probable point of failure among the used samples. It may\n            slightly differ if calculated with optimization directly since\n            no additional samples are generated to find it. If you need this\n            use the mpp module\n\n        conv_mu : numpy.ndarray\n            y-axis values of the convergence plot of the estimation of expected\n            probability of failure.\n\n        conv_var :numpy.ndarray\n            y-axis values of the convergence plot of the variance of the estimation.\n\n        conv_x : numpy.ndarray\n            x-axis of the convergence plots.\n\n        Unlike other Integrators, this will generate the post processing only\n        for the last batch.\n\n        \"\"\"", "\n", "is_corr", "=", "self", ".", "mulvar", ".", "is_corr", "\n", "self", ".", "_post_proc", "=", "post_proc", "\n", "corr_mat", "=", "self", ".", "mulvar", ".", "transform_mats", "(", ")", "[", "0", "]", "\n", "if", "doe", "is", "not", "None", ":", "\n", "            ", "fails", "=", "self", ".", "const_env", "(", "doe", ")", "<", "0", "\n", "fail_prob", "=", "np", ".", "mean", "(", "fails", ")", "\n", "fail_prob_var", "=", "np", ".", "var", "(", "fails", ",", "ddof", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "sample_limit", "=", "int", "(", "np", ".", "ceil", "(", "(", "CoV", "**", "-", "2", ")", "/", "prob_tol", ")", ")", "\n", "if", "max_mc_samples", "is", "not", "None", ":", "\n", "                ", "sample_limit", "=", "max_mc_samples", "\n", "", "if", "mc_batch_size", "<", "1", "or", "mc_batch_size", ">", "sample_limit", ":", "\n", "                ", "mc_batch_size", "=", "sample_limit", "\n", "", "else", ":", "\n", "                ", "mc_batch_size", "=", "int", "(", "mc_batch_size", ")", "\n", "", "total_samples", "=", "0", "\n", "fail_prob", "=", "0", "\n", "fail_prob_var", "=", "0", "\n", "fp_vars", ",", "batch_sizes", "=", "np", ".", "empty", "(", "0", ")", ",", "np", ".", "empty", "(", "0", ")", "\n", "while", "total_samples", "<", "sample_limit", ":", "\n", "\n", "                ", "remaining_samples", "=", "sample_limit", "-", "total_samples", "\n", "if", "remaining_samples", "<", "mc_batch_size", ":", "\n", "                    ", "mc_batch_size", "=", "remaining_samples", "\n", "", "doe", "=", "np", ".", "zeros", "(", "(", "mc_batch_size", ",", "self", ".", "_n_dim", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "i_dim", "in", "range", "(", "self", ".", "_n_dim", ")", ":", "\n", "                    ", "doe", "[", ":", ",", "i_dim", "]", "=", "self", ".", "margs", "[", "i_dim", "]", ".", "rvs", "(", "mc_batch_size", ")", "\n", "# Check because multiplication takes time", "\n", "", "if", "is_corr", ":", "\n", "                    ", "doe", "=", "np", ".", "dot", "(", "doe", ",", "corr_mat", ")", "\n", "", "total_samples", "+=", "mc_batch_size", "\n", "fails", "=", "self", ".", "const_env", "(", "doe", ")", "<", "0", "\n", "# Sum now divide later", "\n", "fail_prob", "+=", "np", ".", "sum", "(", "fails", ")", "\n", "# Estimate total variance", "\n", "fp_vars", "=", "np", ".", "append", "(", "fp_vars", ",", "np", ".", "var", "(", "fails", ",", "ddof", "=", "1", ")", ")", "\n", "# ddof==1 and sum(wi)==1 so w_i = n_i - 1", "\n", "batch_sizes", "=", "np", ".", "append", "(", "batch_sizes", ",", "mc_batch_size", "-", "1", ")", "\n", "fail_prob_var", "=", "np", ".", "sum", "(", "fp_vars", "*", "mc_batch_size", "/", "batch_sizes", ".", "sum", "(", ")", ")", "\n", "if", "mc_batch_size", "<", "sample_limit", "and", "verbose", ":", "\n", "                    ", "print", "(", "f\"{total_samples:.4e}, samples computed\"", ")", "\n", "", "if", "converge", "and", "fail_prob", ">", "0", ":", "\n", "                    ", "if", "fail_prob_var", "/", "fail_prob", "<=", "CoV", ":", "\n", "                        ", "break", "\n", "", "", "", "fail_prob", "=", "fail_prob", "/", "total_samples", "\n", "", "safety_index", "=", "to_safety_index", "(", "fail_prob", ")", "\n", "mpp", "=", "None", "\n", "if", "post_proc", ":", "\n", "            ", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "=", "self", ".", "_gen_post_proc", "(", "fails", ")", "\n", "return", "fail_prob", ",", "fail_prob_var", ",", "safety_index", ",", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "", "return", "fail_prob", ",", "fail_prob_var", ",", "safety_index", ",", "mpp", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mc.MC._gen_post_proc": [[151, 182], ["numpy.array().reshape", "numpy.array", "numpy.zeros", "numpy.zeros", "range", "marg.mean", "numpy.ones_like", "numpy.sum", "numpy.argmin", "mc.MC.x_lsf[].reshape", "numpy.sum", "numpy.argmin", "numpy.mean", "numpy.var", "numpy.array", "mc.MC.x_fail[].reshape", "range"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var"], ["", "def", "_gen_post_proc", "(", "self", ",", "fails", ",", "n_conv", "=", "100", ")", ":", "\n", "        ", "\"\"\" Generate post processing. Will only process the last batch\n        Use calc_fail_prob(..., post_proc=True) instead of this.\n        \"\"\"", "\n", "means", "=", "[", "marg", ".", "mean", "(", ")", "for", "marg", "in", "self", ".", "margs", "]", "\n", "means", "=", "np", ".", "array", "(", "means", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "d_best", "=", "np", ".", "inf", "\n", "mpp", "=", "np", ".", "inf", "*", "np", ".", "ones_like", "(", "means", ")", "\n", "if", "self", ".", "x_lsf", ".", "size", ">", "0", ":", "\n", "            ", "distance", "=", "np", ".", "sum", "(", "(", "means", "-", "self", ".", "x_lsf", ")", "**", "2", ",", "axis", "=", "1", ")", "\n", "loc", "=", "np", ".", "argmin", "(", "distance", ")", "\n", "d_best", "=", "distance", "[", "loc", "]", "\n", "mpp", "=", "self", ".", "x_lsf", "[", "loc", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "self", ".", "x_fail", ".", "size", ">", "0", ":", "\n", "            ", "distance", "=", "np", ".", "sum", "(", "(", "means", "-", "self", ".", "x_fail", ")", "**", "2", ",", "axis", "=", "1", ")", "\n", "loc", "=", "np", ".", "argmin", "(", "distance", ")", "\n", "if", "distance", "[", "loc", "]", "<", "d_best", ":", "\n", "                ", "mpp", "=", "self", ".", "x_fail", "[", "loc", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "", "if", "n_conv", "<", "1", ":", "\n", "            ", "n_conv", "=", "fails", ".", "shape", "[", "0", "]", "\n", "", "n_win", "=", "fails", ".", "shape", "[", "0", "]", "//", "n_conv", "\n", "conv_x", "=", "np", ".", "array", "(", "[", "n_win", "*", "i_conv", "for", "i_conv", "in", "range", "(", "1", ",", "n_conv", "+", "1", ")", "]", ")", "\n", "conv_x", "[", "-", "1", "]", "=", "fails", ".", "shape", "[", "0", "]", "\n", "conv_mu", "=", "np", ".", "zeros", "(", "n_conv", ")", "\n", "conv_var", "=", "np", ".", "zeros", "(", "conv_mu", ".", "shape", "[", "0", "]", ")", "\n", "for", "k", "in", "range", "(", "1", ",", "n_conv", "+", "1", ")", ":", "\n", "            ", "curr_fails", "=", "fails", "[", ":", "(", "k", "+", "1", ")", "*", "n_win", "]", "\n", "conv_mu", "[", "k", "-", "1", "]", "=", "np", ".", "mean", "(", "curr_fails", ")", "\n", "conv_var", "[", "k", "-", "1", "]", "=", "np", ".", "var", "(", "curr_fails", ",", "ddof", "=", "1", ")", "\n", "", "return", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_start": [[146, 159], ["ds.DS._gr", "ds.DS._gr"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._gr", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._gr"], ["def", "_get_start", "(", "self", ")", ":", "\n", "        ", "start", "=", "0", "\n", "zero_value", "=", "self", ".", "_gr", "(", "start", ",", "0", ")", "\n", "patience", "=", "0", "\n", "while", "zero_value", "==", "0", "and", "patience", "<", "1000", ":", "\n", "            ", "patience", "+=", "1", "\n", "start", "+=", "1e-4", "\n", "zero_value", "=", "self", ".", "_gr", "(", "start", ",", "0", ")", "# just for numerical consistency", "\n", "# print(\"adjusting\", zero_value)", "\n", "", "safe_design", "=", "False", "\n", "if", "zero_value", ">", "0", ":", "\n", "            ", "safe_design", "=", "True", "\n", "", "return", "safe_design", ",", "zero_value", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._r2u": [[160, 170], ["numpy.array", "ds.DS.fekete[].reshape", "radius.reshape.reshape.reshape"], "methods", ["None"], ["", "def", "_r2u", "(", "self", ",", "radius", ",", "i_dir", ")", ":", "\n", "        ", "\"\"\"\n        Converts the radius to a point in the standard normal space\n        depending on the direction vector with the index i_dir\n        \"\"\"", "\n", "radius", "=", "np", ".", "array", "(", "radius", ")", "\n", "if", "radius", ".", "ndim", "<", "2", ":", "\n", "            ", "radius", "=", "radius", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "", "direction", "=", "self", ".", "fekete", "[", "i_dir", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "return", "(", "radius", "*", "direction", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._gr": [[171, 178], ["ds.DS._r2u", "ds.DS.const_env_stdnorm"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._r2u", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env_stdnorm"], ["", "def", "_gr", "(", "self", ",", "radius", ",", "i_dir", ")", ":", "\n", "        ", "\"\"\"\n        Transformed envelope of the constraint functions\n        to the radius (distance) space of each dimension.\n        \"\"\"", "\n", "std_norm_var", "=", "self", ".", "_r2u", "(", "radius", ",", "i_dir", ")", "\n", "return", "self", ".", "const_env_stdnorm", "(", "std_norm_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_zero_plane": [[179, 216], ["numpy.sqrt", "numpy.linspace().reshape", "numpy.empty", "range", "ds.DS.const_env_stdnorm().reshape", "numpy.array", "scipy.stats.chi2._ppf", "numpy.isfinite", "ValueError", "ds.DS._r2u", "numpy.isfinite().all", "OverflowError", "numpy.linspace", "ds.DS.const_env_stdnorm", "ds.DS._get_radius", "joblib.Parallel", "para", "numpy.isfinite", "range", "joblib.delayed", "range"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._r2u", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env_stdnorm", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_radius"], ["", "def", "_get_zero_plane", "(", "self", ",", "multi_region", ",", "pf_min", ",", "n_presearch", ")", ":", "\n", "        ", "\"\"\"\n        Get the zero plane by calculating the radii to the limit state\n        in each direction. uses joblib for parallelization\n        \"\"\"", "\n", "r_max", "=", "np", ".", "sqrt", "(", "stats", ".", "chi2", ".", "_ppf", "(", "1", "-", "pf_min", ",", "df", "=", "self", ".", "_n_dim", ")", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "r_max", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Requested probability tolerance is too high!\"", ")", "\n", "# Make presearch at once with arrays to speed up", "\n", "", "r_grid", "=", "np", ".", "linspace", "(", "r_max", "/", "n_presearch", ",", "\n", "r_max", ",", "n_presearch", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "search_points", "=", "np", ".", "empty", "(", "(", "self", ".", "fekete", ".", "shape", "[", "0", "]", "*", "n_presearch", ",", "\n", "self", ".", "_n_dim", ")", ")", "\n", "for", "i_dir", "in", "range", "(", "self", ".", "fekete", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "search_points", "[", "i_dir", "*", "n_presearch", ":", "(", "i_dir", "+", "1", ")", "*", "n_presearch", ",", ":", "]", "=", "self", ".", "_r2u", "(", "r_grid", ",", "i_dir", ")", "\n", "\n", "", "searchs", "=", "self", ".", "const_env_stdnorm", "(", "search_points", ")", ".", "reshape", "(", "(", "self", ".", "fekete", ".", "shape", "[", "0", "]", ",", "r_grid", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "if", "not", "np", ".", "isfinite", "(", "searchs", ")", ".", "all", "(", ")", ":", "\n", "            ", "msg", "=", "\"Infinity or NAN during the transformation.\"", "\n", "msg", "+=", "\"Try decreasing pf_min \"", "\n", "msg", "+=", "\"or reviewing the marginal distributions.\"", "\n", "raise", "OverflowError", "(", "msg", ")", "\n", "\n", "# Now search the directions with failed designs", "\n", "", "if", "self", ".", "_n_parallel", "==", "1", ":", "\n", "            ", "radii", "=", "[", "self", ".", "_get_radius", "(", "i_dir", ",", "r_grid", ",", "searchs", "[", "i_dir", ",", ":", "]", ",", "\n", "multi_region", ")", "\n", "for", "i_dir", "in", "range", "(", "self", ".", "fekete", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "with", "Parallel", "(", "n_jobs", "=", "self", ".", "_n_parallel", ",", "\n", "prefer", "=", "\"processes\"", ")", "as", "para", ":", "\n", "                ", "radii", "=", "para", "(", "delayed", "(", "self", ".", "_get_radius", ")", "(", "i_dir", ",", "r_grid", ",", "searchs", "[", "i_dir", ",", ":", "]", ",", "\n", "multi_region", ")", "\n", "for", "i_dir", "in", "range", "(", "self", ".", "fekete", ".", "shape", "[", "0", "]", ")", ")", "\n", "", "", "return", "np", ".", "array", "(", "radii", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._optimize1d": [[217, 227], ["scipy.optimize.brentq"], "methods", ["None"], ["", "def", "_optimize1d", "(", "self", ",", "r_start", ",", "r_stop", ",", "i_dir", ")", ":", "\n", "        ", "\"\"\"\n        Calls the brent optimizer to find the region of failure,\n        given r_start and r_stop so that gr(r_start)*gr(r_stop)<=0.\n        \"\"\"", "\n", "try", ":", "\n", "            ", "return", "brentq", "(", "self", ".", "_gr", ",", "r_start", ",", "r_stop", ",", "args", "=", "(", "i_dir", ")", ",", "\n", "full_output", "=", "True", ")", "[", "0", "]", "\n", "", "except", "ValueError", ":", "\n", "            ", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_radius": [[228, 275], ["numpy.where", "r_zeros.append", "r_zeros.append", "numpy.isfinite", "numpy.ones", "numpy.sum", "ds.DS._optimize1d", "ds.DS._gr", "r_zeros.append", "scipy.stats.chi2._cdf", "numpy.sqrt", "ds.DS._gr", "numpy.where", "ds.DS._optimize1d", "scipy.stats.chi2._ppf", "numpy.abs", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._optimize1d", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._gr", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._gr", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._optimize1d"], ["", "", "def", "_get_radius", "(", "self", ",", "i_dir", ",", "r_grid", ",", "search_results", ",", "multi_region", ")", ":", "\n", "        ", "\"\"\"\n        Get the radius or radii to the limit state (cons_env==0)\n        in a direction, given a direction index i_dir,\n        the search grid r_grid as well as the search_results\n        constraint_radi(r_grid).\n        \"\"\"", "\n", "r_zeros", "=", "[", "]", "\n", "tries_max", "=", "100", "\n", "positions", "=", "np", ".", "where", "(", "self", ".", "_g0", "*", "search_results", "<", "0", ")", "[", "0", "]", "\n", "if", "positions", ".", "size", "<", "1", ":", "\n", "            ", "r_zeros", ".", "append", "(", "np", ".", "inf", ")", "\n", "", "else", ":", "\n", "            ", "next_pos", "=", "positions", "[", "0", "]", "\n", "r_zeros", ".", "append", "(", "self", ".", "_optimize1d", "(", "0", ",", "r_grid", "[", "next_pos", "]", ",", "i_dir", ")", ")", "\n", "\n", "# safe_design assures r_zeros[-1]>0", "\n", "", "if", "multi_region", "and", "self", ".", "safe_design", "and", "np", ".", "isfinite", "(", "r_zeros", "[", "-", "1", "]", ")", ":", "\n", "            ", "while", "r_grid", "[", "-", "1", "]", ">", "r_zeros", "[", "-", "1", "]", ":", "\n", "                ", "r_start", "=", "1.0001", "*", "r_zeros", "[", "-", "1", "]", "\n", "g_start", "=", "self", ".", "_gr", "(", "r_start", ",", "i_dir", ")", "\n", "zero_tol", "=", "1e-15", "\n", "tries", "=", "0", "\n", "while", "np", ".", "abs", "(", "g_start", ")", "<", "zero_tol", "and", "r_grid", "[", "-", "1", "]", ">", "r_start", "and", "tries", "<", "tries_max", ":", "\n", "#                    print(\"infinity\",r_start)", "\n", "                    ", "r_start", "*=", "1.01", "\n", "tries", "+=", "1", "\n", "g_start", "=", "self", ".", "_gr", "(", "r_start", ",", "i_dir", ")", "\n", "", "if", "r_start", ">=", "r_grid", "[", "-", "1", "]", "or", "tries", ">=", "tries_max", ":", "\n", "                    ", "break", "\n", "\n", "", "positions", "=", "np", ".", "where", "(", "g_start", "*", "search_results", "<", "0", ")", "[", "0", "]", "\n", "next_pos", "=", "positions", "[", "positions", ">", "next_pos", "]", "\n", "if", "next_pos", ".", "size", "<", "1", ":", "\n", "                    ", "break", "\n", "", "next_pos", "=", "next_pos", "[", "0", "]", "\n", "r_zeros", ".", "append", "(", "self", ".", "_optimize1d", "(", "r_start", ",", "r_grid", "[", "next_pos", "]", ",", "\n", "i_dir", ")", ")", "\n", "\n", "# calculate the effective R", "\n", "", "directional_fail_prob", "=", "1", "-", "stats", ".", "chi2", ".", "_cdf", "(", "np", ".", "array", "(", "r_zeros", ")", "**", "2", ",", "df", "=", "self", ".", "_n_dim", ")", "\n", "signum", "=", "np", ".", "ones", "(", "directional_fail_prob", ".", "shape", ")", "\n", "signum", "[", "1", ":", ":", "2", "]", "=", "-", "1", "\n", "pfd", "=", "np", ".", "sum", "(", "directional_fail_prob", "*", "signum", ")", "\n", "r_zeros", "=", "[", "np", ".", "sqrt", "(", "stats", ".", "chi2", ".", "_ppf", "(", "1", "-", "pfd", ",", "df", "=", "self", ".", "_n_dim", ")", ")", "]", "\n", "", "return", "r_zeros", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_conv_plot": [[276, 284], ["numpy.zeros", "numpy.zeros", "range", "numpy.sort", "numpy.mean", "numpy.var", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var"], ["", "def", "_get_conv_plot", "(", "self", ",", "fail_prob", ")", ":", "\n", "        ", "conv_mu", "=", "np", ".", "zeros", "(", "self", ".", "fekete", ".", "shape", "[", "0", "]", "-", "1", ")", "\n", "conv_var", "=", "np", ".", "zeros", "(", "conv_mu", ".", "shape", "[", "0", "]", ")", "\n", "fail_prob_sort", "=", "np", ".", "sort", "(", "fail_prob", ")", "[", ":", ":", "-", "1", "]", "\n", "for", "k", "in", "range", "(", "1", ",", "self", ".", "fekete", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "conv_mu", "[", "k", "-", "1", "]", "=", "np", ".", "mean", "(", "fail_prob_sort", "[", ":", "k", "+", "1", "]", ")", "\n", "conv_var", "[", "k", "-", "1", "]", "=", "np", ".", "var", "(", "fail_prob_sort", "[", ":", "k", "+", "1", "]", ",", "ddof", "=", "1", ")", "\n", "", "return", "conv_mu", ",", "conv_var", ",", "np", ".", "arange", "(", "1", ",", "conv_mu", ".", "shape", "[", "0", "]", "+", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._gen_post_proc": [[285, 317], ["ds.DS._get_conv_plot", "numpy.sqrt", "ds.DS.u2x", "ds.DS.x_fail.copy", "numpy.argmin", "numpy.empty", "scipy.stats.chi2._ppf", "numpy.isfinite", "numpy.logical_not", "numpy.isfinite", "numpy.logical_not", "numpy.linalg.norm", "ds.DS.x2u"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_conv_plot", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.u2x", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.x2u"], ["", "def", "_gen_post_proc", "(", "self", ",", "fail_prob", ",", "radii", ",", "prob_tol", ")", ":", "\n", "        ", "\"\"\"\n        generates variables used for post processing given the\n        probability of failure array with same number of entries as\n        directions, the radii array\n        \"\"\"", "\n", "conv_mu", ",", "conv_var", ",", "conv_x", "=", "self", ".", "_get_conv_plot", "(", "fail_prob", ")", "\n", "\n", "# Now make points for plot", "\n", "if", "self", ".", "_n_parallel", ">", "1", ":", "\n", "            ", "r_max", "=", "np", ".", "sqrt", "(", "stats", ".", "chi2", ".", "_ppf", "(", "1", "-", "prob_tol", ",", "df", "=", "self", ".", "_n_dim", ")", ")", "\n", "if", "self", ".", "safe_design", ":", "\n", "                ", "fail_inds", "=", "np", ".", "isfinite", "(", "radii", ")", "\n", "safe_inds", "=", "np", ".", "logical_not", "(", "fail_inds", ")", "\n", "radii", "[", "safe_inds", "]", "=", "r_max", "\n", "", "else", ":", "\n", "                ", "safe_inds", "=", "np", ".", "isfinite", "(", "radii", ")", "\n", "fail_inds", "=", "np", ".", "logical_not", "(", "safe_inds", ")", "\n", "radii", "[", "fail_inds", "]", "=", "r_max", "\n", "", "all_points", "=", "self", ".", "fekete", "*", "radii", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "all_points", "=", "self", ".", "u2x", "(", "all_points", ")", "\n", "self", ".", "x_safe", "=", "all_points", "[", "safe_inds", ",", ":", "]", "\n", "self", ".", "x_fail", "=", "all_points", "[", "fail_inds", ",", ":", "]", "\n", "self", ".", "x_lsf", "=", "self", ".", "x_fail", ".", "copy", "(", ")", "\n", "\n", "", "if", "self", ".", "x_lsf", ".", "shape", "[", "0", "]", ">", "1", ":", "\n", "            ", "mpp_ind", "=", "np", ".", "argmin", "(", "np", ".", "linalg", ".", "norm", "(", "self", ".", "x2u", "(", "self", ".", "x_lsf", ")", ",", "axis", "=", "1", ")", ")", "\n", "mpp", "=", "self", ".", "x_lsf", "[", "[", "mpp_ind", "]", ",", ":", "]", "\n", "", "else", ":", "\n", "            ", "mpp", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "_n_dim", ")", ")", "\n", "", "return", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS.calc_fail_prob": [[318, 427], ["ds._sanity_check_calc", "numpy.array", "ds.DS._get_start", "multiprocessing.cpu_count", "ds.DS._get_zero_plane", "numpy.mean", "numpy.var", "generic_integrator.to_safety_index", "ds._sane_fekete_points", "print", "scipy.stats.chi2._cdf", "ds.DS._gen_post_proc", "print"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.ds._sanity_check_calc", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_start", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds.DS._get_zero_plane", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.to_safety_index", "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds._sane_fekete_points", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.SUSE._gen_post_proc"], ["", "def", "calc_fail_prob", "(", "self", ",", "multi_region", "=", "False", ",", "num_presearch", "=", "20", ",", "directions", "=", "None", ",", "\n", "prob_tol", "=", "1e-8", ",", "num_parallel", "=", "2", ",", "post_proc", "=", "False", ",", "\n", "verbose", ":", "int", "=", "0", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Main function to call for calculating the probability of failure.\n        As the problem is defined during the init, this only takes the\n        computation arguments. The sampling points will not be collected, \n        if num_parallel > 1 or if post_proc is not True\n\n        Parameters\n        ----------\n\n        multi_region : bool\n            continue to search for safe and unsafe domains beyond the first\n            found one. The estimation will be more accurate but will require\n            much more samples. Using this without a fast model is not recommended,\n            thus defaults to None\n\n        n_presearch : int\n            number of search points for each direction. Should be decreased for\n            simpler functions. (minimum of 6 is recommended)\n\n        directions : int or 2-D numpy.ndarray\n            if None, fekete points with a default number of directions are\n            produced. Note that this method becomes expensive for n_dim > 15\n            if this is an integer, fekete points with that number of directions\n            are computed. if this is a numpy array with the dimensions\n            n_dirs x n_vars each row will be used as a direction vector.\n            Will default to n_dim * 80 fekete points, However the relationship\n            to n_dim is non linear for most examples. The default will work up\n            to 5-6 dimensions depending on the problem. Higher dimensional problems\n            require more directions for an accurate estimation.\n\n        prob_tol : float\n            Defines the accuracy of the estimated failure probability in terms\n            of number of total samples\n\n        post_proc : bool\n            If true, sampling points will be accumulated to the attributes\n            x_lsf, x_safe and x_fail and also will return mpp, conv_mu, conv_var,\n            conv_x\n\n        num_parallel : int\n            number of parallel processes. Reduces performance for values more\n            than 1 per core. Defaults to 2.\n\n        Returns\n        -------\n        fail_prob_mu : float\n            estimation of the expected probability of failure\n\n        fail_prob_std : float\n            estimation variance of the probability of failure\n\n        Following are only retuned if post_proc = True\n\n        safety_index : float\n            Safety index, also known as the sigma level. It is equal to\n            Phi_inv(1-fail_prob_mu), where Phi_inv is the inverse of the CDF\n            of standard normal distribution\n\n        mpp : 2-D numpy.ndarray\n            Most probable point of failure among the used samples. It may\n            slightly differ if calculated with optimization directly since\n            no additional samples are generated to find it. If you need this\n            use the mpp module\n\n        conv_mu : numpy.ndarray\n            y-axis values of the convergence plot of the estimation of expected\n            probability of failure.\n\n        conv_var : numpy.ndarray\n            y-axis values of the convergence plot of the variance of the estimation.\n\n        conv_x : numpy.ndarray\n            x-axis of the convergence plots.\n        \"\"\"", "\n", "_sanity_check_calc", "(", "multi_region", ",", "num_presearch", ",", "prob_tol", ",", "\n", "num_parallel", ",", "post_proc", ")", "\n", "\n", "self", ".", "_post_proc", "=", "post_proc", "\n", "self", ".", "fekete", "=", "np", ".", "array", "(", "_sane_fekete_points", "(", "directions", ",", "self", ".", "_n_dim", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "safe_design", ",", "self", ".", "_g0", "=", "self", ".", "_get_start", "(", ")", "\n", "n_cores", "=", "mp", ".", "cpu_count", "(", ")", "# Using at least one less core", "\n", "# is usually faster", "\n", "if", "num_parallel", ">", "n_cores", "or", "num_parallel", "<", "1", ":", "\n", "            ", "if", "verbose", ">", "0", ":", "\n", "                ", "msg", "=", "\"Using more processes than cores slows down parallel \"", "\n", "msg", "+=", "f\"computation because of GIL. Setting it to {n_cores}\"", "\n", "print", "(", "msg", ")", "\n", "", "num_parallel", "=", "n_cores", "\n", "", "self", ".", "_n_parallel", "=", "num_parallel", "\n", "if", "verbose", ">", "0", ":", "\n", "            ", "print", "(", "\"Starting limit state search...\"", ")", "\n", "", "radii", "=", "self", ".", "_get_zero_plane", "(", "multi_region", ",", "prob_tol", ",", "num_presearch", ")", "\n", "# Calculate the Probability of Failure for each direction", "\n", "fail_prob", "=", "1", "-", "stats", ".", "chi2", ".", "_cdf", "(", "radii", "**", "2", ",", "df", "=", "self", ".", "_n_dim", ")", "\n", "if", "not", "self", ".", "safe_design", ":", "\n", "            ", "fail_prob", "=", "1", "-", "fail_prob", "\n", "", "fail_prob_mu", "=", "np", ".", "mean", "(", "fail_prob", ")", "\n", "fail_prob_std", "=", "np", ".", "var", "(", "fail_prob", ",", "ddof", "=", "1", ")", "# Since samples are chisquared var = std", "\n", "safety_index", "=", "to_safety_index", "(", "fail_prob_mu", ")", "\n", "\n", "mpp", "=", "None", "\n", "if", "post_proc", ":", "\n", "            ", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "=", "self", ".", "_gen_post_proc", "(", "fail_prob", ",", "radii", ",", "prob_tol", ")", "\n", "return", "fail_prob_mu", ",", "fail_prob_std", ",", "safety_index", ",", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "", "return", "fail_prob_mu", ",", "fail_prob_std", ",", "safety_index", ",", "mpp", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds._sanity_check_calc": [[20, 46], ["isinstance", "ValueError", "isinstance", "ValueError", "ValueError", "ValueError", "isinstance", "ValueError", "type", "type", "isinstance", "isinstance", "type"], "function", ["None"], ["def", "_sanity_check_calc", "(", "multi_region", ",", "num_presearch", ",", "prob_tol", ",", "num_parallel", ",", "\n", "post_proc", ")", ":", "\n", "    ", "\"\"\"\n    Input check for the arguments passed to\n    calculate_failure_probability\n    \"\"\"", "\n", "if", "not", "isinstance", "(", "multi_region", ",", "bool", ")", ":", "\n", "        ", "err_msg", "=", "\"multi_region must be of type bool \"", "\n", "err_msg", "+=", "\"got: \"", "+", "type", "(", "multi_region", ")", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "not", "isinstance", "(", "prob_tol", ",", "float", ")", ":", "\n", "        ", "err_msg", "=", "\"prob_tol must be a floating number, \"", "\n", "err_msg", "+=", "\"got: \"", "+", "type", "(", "prob_tol", ")", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "(", "not", "isinstance", "(", "num_parallel", ",", "int", ")", ")", "or", "num_parallel", "<", "1", ":", "\n", "        ", "err_msg", "=", "\"num_parallel must be a positive integer defining \"", "\n", "err_msg", "+=", "\"the number of parallel execution, got:\"", "+", "num_parallel", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "(", "not", "isinstance", "(", "num_presearch", ",", "int", ")", ")", "or", "num_presearch", "<", "1", ":", "\n", "        ", "err_msg", "=", "\"num_presearch must be a positive integer defining \"", "\n", "err_msg", "+=", "\"the number of parallel execution, got:\"", "+", "num_presearch", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "not", "isinstance", "(", "post_proc", ",", "bool", ")", ":", "\n", "        ", "err_msg", "=", "\"post_proc must be of type bool \"", "\n", "err_msg", "+=", "\"got: \"", "+", "type", "(", "post_proc", ")", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.ds._sane_fekete_points": [[48, 72], ["doe.hyperspace_division.fekete_points", "isinstance", "ValueError", "TypeError"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division.fekete_points"], ["", "", "def", "_sane_fekete_points", "(", "directions", ",", "n_dim", ")", ":", "\n", "    ", "\"\"\"\n    get fekete points for DirectionalSimulator object.\n    use get_directions function for other use cases.\n    \"\"\"", "\n", "\n", "if", "directions", "is", "None", ":", "\n", "        ", "n_dir", "=", "n_dim", "*", "80", "\n", "", "elif", "isinstance", "(", "directions", ",", "int", ")", ":", "\n", "        ", "n_dir", "=", "directions", "\n", "", "else", ":", "\n", "        ", "try", ":", "\n", "            ", "n_dir", ",", "n_dim_dir", "=", "directions", ".", "shape", "\n", "", "except", "AttributeError", ":", "\n", "            ", "err_msg", "=", "\"Only an integer or a numpy array is accepted as \"", "\n", "err_msg", "+=", "\"directions.\"", "\n", "raise", "TypeError", "(", "err_msg", ")", "\n", "\n", "", "if", "n_dim", "!=", "n_dim_dir", ":", "\n", "            ", "err_msg", "=", "\"Number of dimensions of the directions does not \"", "\n", "err_msg", "+=", "\"match the number of marginal distributions\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "return", "directions", "\n", "", "return", "fekete_points", "(", "n_dim", ",", "n_dir", ",", "max_iters", "=", "100", ",", "tolerance", "=", "1e-12", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp.FORM.calc_fail_prob": [[143, 194], ["mpp.most_probable_failure_point", "numpy.linalg.norm", "scipy.stats.norm._cdf", "numpy.isnan", "most_probable_failure_point.FORM.u2x"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp.most_probable_failure_point", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.u2x"], ["def", "calc_fail_prob", "(", "self", ",", "num_starts", ":", "int", "=", "4", ",", "num_parallel", ":", "int", "=", "2", ",", "\n", "post_proc", ":", "bool", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Calculate the failure probability based on FORM on the most\n        probable point of failure (MPP).\n        \n        Parameters\n        ----------\n        num_starts: int\n            number of multistarts for the MPP search\n        num_parallel: int\n            number of parallel starts\n        post_proc : bool\n            If true, sampling points will be accumulated to the attributes\n            x_lsf, x_safe and x_fail and also will return mpp, conv_mu, conv_var,\n            conv_x\n            \n        Note that the estimation variance is always returned as -1 but is not \n        removed for conformity with other pipeline objects\n        \n        Returns\n        -------\n        fail_prob_mu : float\n            estimation of the expected probability of failure\n\n        fail_prob_var : float\n            estimation variance of the probability of failure\n\n        Following are only retuned if post_proc = True\n\n        safety_index : float\n            Safety index, also known as the sigma level. It is equal to\n            Phi_inv(1-fail_prob_mu), where Phi_inv is the inverse of the CDF\n            of standard normal distribution\n\n        mpp : 2-D numpy.ndarray\n            Most probable point of failure among the used samples. It may\n            slightly differ if calculated with optimization directly since\n            no additional samples are generated to find it. If you need this\n            use the mpp module\n        \"\"\"", "\n", "self", ".", "_post_proc", "=", "post_proc", "\n", "self", ".", "_n_parallel", "=", "num_parallel", "\n", "mpp", "=", "most_probable_failure_point", "(", "self", ".", "const_env_stdnorm", ",", "self", ".", "_n_dim", ",", "\n", "num_starts", ",", "num_parallel", "=", "num_parallel", ")", "\n", "if", "mpp", "is", "None", ":", "\n", "            ", "return", "0.0", ",", "None", ",", "np", ".", "inf", ",", "None", "\n", "", "safety_index", "=", "np", ".", "linalg", ".", "norm", "(", "mpp", ")", "\n", "fail_prob_mu", "=", "stats", ".", "norm", ".", "_cdf", "(", "-", "safety_index", ")", "\n", "if", "np", ".", "isnan", "(", "fail_prob_mu", ")", ":", "\n", "            ", "return", "0.0", ",", "-", "1", ",", "np", ".", "inf", ",", "None", "\n", "", "return", "fail_prob_mu", ",", "-", "1", ",", "safety_index", ",", "self", ".", "u2x", "(", "mpp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp.ISPUD.calc_fail_prob": [[207, 275], ["mpp.most_probable_failure_point", "mpp.ravel.ravel.ravel", "numpy.array", "numpy.prod", "numpy.zeros", "range", "numpy.prod", "numpy.mean", "numpy.var", "generic_integrator.to_safety_index", "scipy.stats.norm", "doe.lhs.make_doe", "scipy.stats.norm._pdf", "scipy.stats.norm().pdf", "mpp.ravel.ISPUD.u2x", "mpp.ravel.ISPUD.const_env_stdnorm", "scipy.stats.norm"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp.most_probable_failure_point", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.to_safety_index", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.u2x", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env_stdnorm"], ["def", "calc_fail_prob", "(", "self", ",", "num_starts", ":", "int", "=", "12", ",", "num_samples", ":", "int", "=", "100", ",", "\n", "num_parallel", ":", "int", "=", "2", ",", "post_proc", ":", "bool", "=", "False", ",", "doe", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Calculate the failure probability based on ISPUD using MPP.\n        \n        Parameters\n        ----------\n        num_starts: int\n            number of multistarts for the MPP search\n        num_samples: int\n            number of samples for importance sampling\n        num_parallel: int\n            number of parallel starts\n        post_proc : bool\n            If true, sampling points will be accumulated to the attributes\n            x_lsf, x_safe and x_fail and also will return mpp, conv_mu, conv_var,\n            conv_x\n        doe: None or 2d numpy array\n            DoE to use for ISPUD. It must follow standard normal distribution\n            i.e. mean=0, variance=1\n        \n        \n        Returns\n        -------\n        fail_prob_mu : float\n            estimation of the expected probability of failure\n\n        fail_prob_var : float\n            estimation variance of the probability of failure\n\n        Following are only retuned if post_proc = True\n\n        safety_index : float\n            Safety index, also known as the sigma level. It is equal to\n            Phi_inv(1-fail_prob_mu), where Phi_inv is the inverse of the CDF\n            of standard normal distribution\n\n        mpp : 2-D numpy.ndarray\n            Most probable point of failure among the used samples. It may\n            slightly differ if calculated with optimization directly since\n            no additional samples are generated to find it. If you need this\n            use the mpp module\n        \n        \n        \"\"\"", "\n", "self", ".", "_post_proc", "=", "post_proc", "\n", "self", ".", "_n_parallel", "=", "num_parallel", "\n", "mpp", "=", "most_probable_failure_point", "(", "self", ".", "const_env_stdnorm", ",", "self", ".", "_n_dim", ",", "\n", "num_starts", ",", "num_parallel", "=", "num_parallel", ")", "\n", "if", "mpp", "is", "None", ":", "\n", "            ", "return", "0.0", ",", "None", ",", "np", ".", "inf", ",", "None", "\n", "", "mpp", "=", "mpp", ".", "ravel", "(", ")", "\n", "aux_margs", "=", "[", "stats", ".", "norm", "(", "x_i", ",", "1.", ")", "for", "x_i", "in", "mpp", "]", "\n", "if", "doe", "is", "None", ":", "\n", "            ", "aux_doe", "=", "make_doe", "(", "num_samples", ",", "aux_margs", ",", "num_tries", "=", "1000", ")", "\n", "", "else", ":", "\n", "            ", "aux_doe", "=", "doe", "+", "mpp", "\n", "", "fails", "=", "np", ".", "array", "(", "self", ".", "const_env_stdnorm", "(", "aux_doe", ")", "<", "0", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "weights", "=", "np", ".", "prod", "(", "stats", ".", "norm", ".", "_pdf", "(", "aux_doe", ")", ",", "axis", "=", "1", ")", "\n", "denom", "=", "np", ".", "zeros", "(", "aux_doe", ".", "shape", ")", "\n", "for", "i_dim", "in", "range", "(", "self", ".", "_n_dim", ")", ":", "\n", "            ", "denom", "[", ":", ",", "i_dim", "]", "=", "stats", ".", "norm", "(", "mpp", "[", "i_dim", "]", ",", "1.", ")", ".", "pdf", "(", "aux_doe", "[", ":", ",", "i_dim", "]", ")", "\n", "", "weights", "/=", "np", ".", "prod", "(", "denom", ",", "axis", "=", "1", ")", "\n", "fails", "*=", "weights", "\n", "fail_prob_mu", "=", "np", ".", "mean", "(", "fails", ")", "\n", "fail_prob_var", "=", "np", ".", "var", "(", "fails", ",", "ddof", "=", "1", ")", "\n", "safety_index", "=", "to_safety_index", "(", "fail_prob_mu", ")", "\n", "return", "fail_prob_mu", ",", "fail_prob_var", ",", "safety_index", ",", "self", ".", "u2x", "(", "mpp", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._mpp_obj": [[24, 27], ["numpy.sum"], "function", ["None"], ["def", "_mpp_obj", "(", "std_norm_input", ")", ":", "\n", "    ", "\"\"\"Objective for MPP search \"\"\"", "\n", "return", "np", ".", "sum", "(", "std_norm_input", "**", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._mpp_jac": [[29, 32], ["None"], "function", ["None"], ["", "def", "_mpp_jac", "(", "std_norm_input", ",", "*", "args", ")", ":", "\n", "    ", "\"\"\"Objective derivative for MPP search \"\"\"", "\n", "return", "2", "*", "std_norm_input", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._call_opt": [[34, 45], ["warnings.catch_warnings", "warnings.simplefilter", "scipy.optimize.minimize", "scipy.optimize.minimize"], "function", ["None"], ["", "def", "_call_opt", "(", "limit_state", ",", "x_start", ",", "cons", ",", "method", "=", "'SLSQP'", ",", "bounds", "=", "None", ")", ":", "\n", "    ", "\"\"\" calls scipy optimizer \"\"\"", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "if", "bounds", "is", "None", ":", "\n", "            ", "res", "=", "minimize", "(", "_mpp_obj", ",", "x_start", ",", "jac", "=", "_mpp_jac", ",", "method", "=", "method", ",", "\n", "constraints", "=", "cons", ")", "\n", "", "else", ":", "\n", "            ", "res", "=", "minimize", "(", "_mpp_obj", ",", "x_start", ",", "jac", "=", "_mpp_jac", ",", "method", "=", "method", ",", "\n", "constraints", "=", "cons", ",", "bounds", "=", "bounds", ")", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._get_mpp": [[47, 67], ["_call_opt.get", "res.get.ravel", "mpp._call_opt", "mpp._call_opt", "limit_state", "_call_opt.get", "res.get.ravel", "mpp._mpp_obj", "limit_state"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._call_opt", "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._call_opt", "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._mpp_obj"], ["", "def", "_get_mpp", "(", "limit_state", ",", "x_start", ":", "np", ".", "ndarray", ",", "bounds", "=", "None", ",", "give_vals", ":", "bool", "=", "True", ")", ":", "\n", "    ", "\"\"\" Get MPP using SLSQP and if that fails, slower cobyla\"\"\"", "\n", "\n", "def", "neg_limit_state", "(", "x", ")", ":", "\n", "        ", "return", "-", "limit_state", "(", "x", ")", "\n", "\n", "", "cons", "=", "(", "{", "'type'", ":", "'eq'", ",", "'fun'", ":", "limit_state", "}", ")", "\n", "try", ":", "\n", "        ", "res", "=", "_call_opt", "(", "limit_state", ",", "x_start", ",", "cons", ",", "bounds", "=", "bounds", ")", "\n", "success", "=", "res", ".", "success", "\n", "", "except", "ValueError", ":", "\n", "        ", "success", "=", "False", "\n", "", "if", "not", "success", "or", "res", ".", "get", "(", "\"status\"", ")", "in", "[", "5", ",", "6", "]", ":", "\n", "        ", "cons", "=", "(", "{", "'type'", ":", "'ineq'", ",", "'fun'", ":", "limit_state", "}", ",", "\n", "{", "'type'", ":", "'ineq'", ",", "'fun'", ":", "neg_limit_state", "}", ")", "\n", "res", "=", "_call_opt", "(", "limit_state", ",", "x_start", ",", "cons", ",", "method", "=", "\"COBYLA\"", ")", "\n", "", "res_input", "=", "res", ".", "get", "(", "\"x\"", ")", "\n", "if", "give_vals", ":", "\n", "        ", "return", "res_input", ".", "ravel", "(", ")", ",", "_mpp_obj", "(", "res_input", ")", ",", "limit_state", "(", "res_input", ")", "\n", "", "return", "res_input", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp.most_probable_failure_point": [[69, 130], ["numpy.zeros", "mpp._get_mpp", "numpy.append", "range", "scipy.stats.uniform", "doe.lhs.make_doe", "range", "mpp._get_mpp", "joblib.Parallel", "para", "numpy.squeeze", "numpy.copy", "print", "numpy.array", "x_all.reshape.reshape", "abs", "joblib.delayed", "range", "x.ravel", "numpy.argmin", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._get_mpp", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe", "home.repos.pwc.inspect_result.canbooo_duqo.proba.mpp._get_mpp"], ["", "def", "most_probable_failure_point", "(", "const_env_stdnorm", ",", "num_dim", ":", "int", ",", "\n", "num_starts", ":", "int", "=", "12", ",", "num_parallel", ":", "int", "=", "2", ")", ":", "\n", "    ", "\"\"\"Compute the most probable failure point MPP\n\n    Parameters:\n    ----------\n        const_env_stdnorm : instance of any class from integrate Module\n            used for computing the lower envelope of the constraints in the\n            standard normal space\n\n        num_dim : int\n            number of input dimensions in the stochastic space\n\n        num_starts : int\n            number of starts for finding MPP\n\n        num_parallel : int\n            number of parallel starts for finding MPP. Only used\n            if num_starts > 1.\n\n    Returns:\n    --------\n        mpp : numpy.ndarray\n            Most probable point of failure in the standard normal space\n    \"\"\"", "\n", "num_tolerance", "=", "1e-10", "\n", "\n", "lim", "=", "8", "# because of scipy.stats precision, even this results in errors", "\n", "\n", "bounds", "=", "[", "(", "-", "lim", ",", "lim", ")", "for", "k", "in", "range", "(", "num_dim", ")", "]", "\n", "x_starts", "=", "np", ".", "zeros", "(", "(", "1", ",", "num_dim", ")", ")", "\n", "if", "num_starts", "<=", "1", ":", "\n", "        ", "x_best", "=", "_get_mpp", "(", "const_env_stdnorm", ",", "x_starts", ",", "\n", "bounds", "=", "bounds", ",", "give_vals", "=", "False", ")", "\n", "\n", "", "else", ":", "\n", "        ", "margs", "=", "[", "stats", ".", "uniform", "(", "-", "1", ",", "2", ")", "for", "_", "in", "range", "(", "num_dim", ")", "]", "\n", "x_starts", "=", "np", ".", "append", "(", "x_starts", ",", "make_doe", "(", "num_starts", "-", "1", ",", "margs", ",", "\n", "num_tries", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "x_best", "=", "None", "\n", "obj_best", "=", "np", ".", "inf", "\n", "if", "num_parallel", "==", "1", ":", "\n", "            ", "for", "x_start", "in", "x_starts", ":", "\n", "                ", "x_cur", ",", "obj", ",", "con", "=", "_get_mpp", "(", "const_env_stdnorm", ",", "x_start", ",", "bounds", "=", "bounds", ")", "\n", "if", "obj", "<", "obj_best", "and", "abs", "(", "con", ")", "<", "num_tolerance", ":", "\n", "                    ", "x_best", "=", "np", ".", "copy", "(", "x_cur", ")", "\n", "print", "(", "x_best", ")", "\n", "obj_best", "=", "obj", "\n", "", "", "", "else", ":", "\n", "            ", "with", "Parallel", "(", "n_jobs", "=", "num_parallel", ",", "backend", "=", "\"loky\"", ")", "as", "para", ":", "\n", "                ", "x_all", "=", "para", "(", "delayed", "(", "_get_mpp", ")", "(", "const_env_stdnorm", ",", "\n", "x_starts", "[", "[", "i_st", "]", "]", ",", "bounds", "=", "bounds", ",", "\n", "give_vals", "=", "False", ")", "\n", "for", "i_st", "in", "range", "(", "x_starts", ".", "shape", "[", "0", "]", ")", ")", "\n", "x_all", "=", "np", ".", "squeeze", "(", "np", ".", "array", "(", "[", "x", ".", "ravel", "(", ")", "for", "x", "in", "x_all", "]", ")", ")", "\n", "if", "x_all", ".", "ndim", "<", "2", ":", "\n", "# must be one dimension since there were more than 1 starts", "\n", "                    ", "x_all", "=", "x_all", ".", "reshape", "(", "(", "num_starts", ",", "1", ")", ")", "\n", "", "x_best", "=", "x_all", "[", "[", "np", ".", "argmin", "(", "np", ".", "sum", "(", "x_all", "**", "2", ",", "axis", "=", "1", ")", ")", "]", ",", ":", "]", "\n", "\n", "", "", "", "return", "x_best", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.__init__": [[56, 85], ["generic_integrator._sanity_check_margs", "len", "generic_integrator._get_const_args", "numpy.empty", "numpy.empty", "numpy.empty", "isinstance", "multivariate.nataf_mats", "multivariate.nataf_mats"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator._sanity_check_margs", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator._get_const_args", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.nataf_mats", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.nataf_mats"], ["def", "__init__", "(", "self", ",", "multivariate", ",", "constraints", ",", "constraint_args", "=", "None", ",", "\n", "std_norm_to_orig", "=", "None", ",", "orig_to_std_norm", "=", "None", ")", ":", "\n", "        ", "self", ".", "mulvar", "=", "multivariate", "\n", "self", ".", "margs", "=", "multivariate", ".", "margs", "[", ":", "]", "# make copy for faster access", "\n", "self", ".", "_n_dim", "=", "_sanity_check_margs", "(", "self", ".", "mulvar", ".", "margs", ")", "\n", "if", "not", "isinstance", "(", "constraints", ",", "list", ")", ":", "\n", "            ", "constraints", "=", "[", "constraints", "]", "\n", "", "self", ".", "constraints", "=", "constraints", "\n", "self", ".", "_n_cons", "=", "len", "(", "self", ".", "constraints", ")", "\n", "self", ".", "const_args", "=", "_get_const_args", "(", "constraint_args", ",", "self", ".", "_n_cons", ")", "\n", "if", "std_norm_to_orig", "is", "None", ":", "# use our own", "\n", "            ", "self", ".", "corr_transform", ",", "self", ".", "icorr_transform", "=", "multivariate", ".", "nataf_mats", "(", ")", "\n", "self", ".", "u2x", "=", "self", ".", "_u2x", "\n", "", "else", ":", "\n", "            ", "self", ".", "u2x", "=", "std_norm_to_orig", "\n", "\n", "", "if", "orig_to_std_norm", "is", "None", ":", "# use our own", "\n", "            ", "self", ".", "corr_transform", ",", "self", ".", "icorr_transform", "=", "multivariate", ".", "nataf_mats", "(", ")", "\n", "self", ".", "x2u", "=", "self", ".", "_x2u", "\n", "", "else", ":", "\n", "            ", "self", ".", "x2u", "=", "orig_to_std_norm", "\n", "\n", "", "self", ".", "_post_proc", "=", "False", "\n", "self", ".", "_n_parallel", "=", "1", "\n", "\n", "self", ".", "x_lsf", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "_n_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "x_fail", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "_n_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "x_safe", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "_n_dim", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "self", ".", "num_eval", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env": [[86, 125], ["range", "input_points.reshape.reshape.reshape", "numpy.ones", "cur.reshape.reshape.reshape", "numpy.isclose", "numpy.isclose.any", "numpy.isclose.any", "numpy.isclose.any", "numpy.append", "numpy.append", "numpy.append"], "methods", ["None"], ["", "def", "const_env", "(", "self", ",", "input_points", ")", ":", "\n", "        ", "\"\"\"\n        Returns the lower envelope of all passed constraints i.e.\n        min([constraints[i](x) for i in range(len(consmtraints])))\n\n        Arguments\n        ---------\n\n        input_points  :  numpy array with the point coordinates. if 1-D, it\n                       will be assumed a row array (one point)\n        \"\"\"", "\n", "\n", "if", "input_points", ".", "ndim", "<", "2", ":", "\n", "            ", "input_points", "=", "input_points", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "self", ".", "num_eval", "+=", "input_points", ".", "shape", "[", "0", "]", "\n", "res", "=", "np", ".", "ones", "(", "input_points", ".", "shape", "[", "0", "]", ")", "*", "np", ".", "inf", "\n", "for", "i_con", "in", "range", "(", "self", ".", "_n_cons", ")", ":", "\n", "# if self.const_args[i_con]:", "\n", "            ", "cur", "=", "self", ".", "constraints", "[", "i_con", "]", "(", "input_points", ",", "\n", "*", "self", ".", "const_args", "[", "i_con", "]", ")", "\n", "# else:", "\n", "#     cur = self.constraints[i_con](input_points)", "\n", "cur", "=", "cur", ".", "reshape", "(", "res", ".", "shape", ")", "\n", "locs", "=", "res", ">", "cur", "\n", "res", "[", "locs", "]", "=", "cur", "[", "locs", "]", "\n", "", "if", "self", ".", "_post_proc", "and", "self", ".", "_n_parallel", "==", "1", ":", "\n", "            ", "safe_inds", "=", "np", ".", "isclose", "(", "res", ",", "0", ",", "atol", "=", "1e-5", ")", "\n", "if", "safe_inds", ".", "any", "(", ")", ":", "\n", "                ", "self", ".", "x_lsf", "=", "np", ".", "append", "(", "self", ".", "x_lsf", ",", "\n", "input_points", "[", "safe_inds", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "", "safe_inds", "=", "res", "<", "0", "\n", "if", "safe_inds", ".", "any", "(", ")", ":", "\n", "                ", "self", ".", "x_fail", "=", "np", ".", "append", "(", "self", ".", "x_fail", ",", "\n", "input_points", "[", "safe_inds", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "", "safe_inds", "=", "res", ">", "0", "\n", "if", "safe_inds", ".", "any", "(", ")", ":", "\n", "                ", "self", ".", "x_safe", "=", "np", ".", "append", "(", "self", ".", "x_safe", ",", "\n", "input_points", "[", "safe_inds", ",", ":", "]", ",", "axis", "=", "0", ")", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env_stdnorm": [[135, 138], ["generic_integrator.GenericIntegrator.const_env", "generic_integrator.GenericIntegrator.u2x"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.u2x"], ["", "def", "const_env_stdnorm", "(", "self", ",", "std_norm_input", ")", ":", "\n", "        ", "\"\"\"const_env in the standard normal space\"\"\"", "\n", "return", "self", ".", "const_env", "(", "self", ".", "u2x", "(", "std_norm_input", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator._u2x": [[139, 152], ["numpy.dot", "numpy.zeros", "range", "corr_input.reshape.reshape.reshape", "generic_integrator.GenericIntegrator.margs[].ppf", "scipy.stats.norm._cdf"], "methods", ["None"], ["", "def", "_u2x", "(", "self", ",", "std_norm_input", ")", ":", "\n", "        ", "\"\"\"\n        Transforms the standard normal variable u to the original\n        space defined by the marginal distributions of x as passed\n        in margs\n        \"\"\"", "\n", "corr_input", "=", "np", ".", "dot", "(", "std_norm_input", ",", "self", ".", "corr_transform", ")", "\n", "if", "corr_input", ".", "ndim", "<", "2", ":", "# assuming single dimensionals to be a single point", "\n", "            ", "corr_input", "=", "corr_input", ".", "reshape", "(", "(", "1", ",", "self", ".", "_n_dim", ")", ")", "\n", "", "orig_input", "=", "np", ".", "zeros", "(", "corr_input", ".", "shape", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "_n_dim", ")", ":", "\n", "            ", "orig_input", "[", ":", ",", "k", "]", "=", "self", ".", "margs", "[", "k", "]", ".", "ppf", "(", "norm", ".", "_cdf", "(", "corr_input", "[", ":", ",", "k", "]", ")", ")", "\n", "", "return", "orig_input", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator._x2u": [[153, 166], ["numpy.dot", "numpy.zeros", "range", "ucorr_input.reshape.reshape.reshape", "scipy.stats.norm._ppf", "generic_integrator.GenericIntegrator.margs[].cdf"], "methods", ["None"], ["", "def", "_x2u", "(", "self", ",", "input_points", ")", ":", "\n", "        ", "\"\"\"\n        Transforms the standard normal variable u to the original\n        space defined by the marginal distributions of x as passed\n        in margs\n        \"\"\"", "\n", "ucorr_input", "=", "np", ".", "dot", "(", "input_points", ",", "self", ".", "icorr_transform", ")", "\n", "if", "ucorr_input", ".", "ndim", "<", "2", ":", "# assuming single dimensionals to be a single point", "\n", "            ", "ucorr_input", "=", "ucorr_input", ".", "reshape", "(", "(", "1", ",", "self", ".", "_n_dim", ")", ")", "\n", "", "std_norm_input", "=", "np", ".", "zeros", "(", "ucorr_input", ".", "shape", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "_n_dim", ")", ":", "\n", "            ", "std_norm_input", "[", ":", ",", "k", "]", "=", "norm", ".", "_ppf", "(", "self", ".", "margs", "[", "k", "]", ".", "cdf", "(", "ucorr_input", "[", ":", ",", "k", "]", ")", ")", "\n", "", "return", "std_norm_input", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.to_safety_index": [[168, 170], ["scipy.stats.norm._ppf"], "function", ["None"], ["", "", "def", "to_safety_index", "(", "fail_prob", ")", ":", "\n", "    ", "return", "-", "norm", ".", "_ppf", "(", "fail_prob", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator._sanity_check_margs": [[172, 189], ["len", "iter", "ValueError", "ValueError"], "function", ["None"], ["", "def", "_sanity_check_margs", "(", "margs", ")", ":", "\n", "    ", "\"\"\"\n    Sanity check for the margs, returns number of entries in margs as n_dim\n    \"\"\"", "\n", "try", ":", "\n", "        ", "_", "=", "iter", "(", "margs", ")", "\n", "", "except", ":", "\n", "        ", "err_msg", "=", "\"margs must be an iterable with each entry \"", "\n", "err_msg", "+=", "\"corresponding a marginal distribution of an \"", "\n", "err_msg", "+=", "\"input dimension.\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "n_dim", "=", "len", "(", "margs", ")", "\n", "if", "n_dim", "<", "1", ":", "\n", "        ", "err_msg", "=", "\"Number of dimensions cannot be smaller than 1 as \"", "\n", "err_msg", "+=", "\"given in margs.\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "return", "n_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator._get_const_args": [[191, 207], ["list", "len", "ValueError", "len"], "function", ["None"], ["", "def", "_get_const_args", "(", "const_args", ",", "n_const", ")", ":", "\n", "    ", "\"\"\"\n    check and return const_args from the passed value to DirectionalSimulator\n    \"\"\"", "\n", "if", "const_args", "is", "None", ":", "\n", "        ", "const_args", "=", "[", "[", "]", "]", "*", "n_const", "\n", "", "try", ":", "\n", "        ", "const_args", "=", "list", "(", "const_args", ")", "\n", "", "except", "TypeError", ":", "\n", "        ", "const_args", "=", "[", "[", "const_args", "]", "]", "*", "n_const", "\n", "\n", "", "if", "len", "(", "const_args", ")", "!=", "n_const", ":", "\n", "        ", "err_msg", "=", "f\"Number of constraints ({n_const}) and the constraint arguments \"", "\n", "err_msg", "+=", "f\"({len(const_args)}) do not match.\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "return", "const_args", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.SUSE.calc_fail_prob": [[24, 169], ["int", "suse.SUSE.const_env_stdnorm", "int", "suse._get_worst_n", "numpy.array", "duqo.proba.generic_integrator.to_safety_index", "print", "print", "duqo.doe.lhs.make_doe", "numpy.ceil", "numpy.mean", "suse._subset_cov", "duqo.proba.generic_integrator.to_safety_index", "suse._subset_cov", "suse.parallel_adaptive_conditional_sampling", "doe_cur.reshape.reshape.reshape", "suse._get_worst_n", "fail_probs.append", "numpy.copy", "suse._corr_factor_gamma", "numpy.array.append", "outputs_next.copy", "numpy.prod", "numpy.sum", "suse.SUSE._gen_post_proc", "warnings.warn", "suse.SUSE._gen_post_proc", "outputs_next.copy.ravel", "indicators.mean", "suse._subset_cov", "numpy.prod", "scipy.stats.norm", "alphas.append", "alphas.append", "range"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.GenericIntegrator.const_env_stdnorm", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._get_worst_n", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.to_safety_index", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._subset_cov", "home.repos.pwc.inspect_result.canbooo_duqo.proba.generic_integrator.to_safety_index", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._subset_cov", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.parallel_adaptive_conditional_sampling", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._get_worst_n", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._corr_factor_gamma", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.SUSE._gen_post_proc", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.SUSE._gen_post_proc", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._subset_cov"], ["def", "calc_fail_prob", "(", "self", ",", "init_doe", "=", "None", ",", "prob_tol", "=", "1e-9", ",", "num_subset_points", ":", "int", "=", "1e3", ",", "\n", "inter_prob", ":", "float", "=", "0.1", ",", "max_subsets", "=", "50", ",", "post_proc", ":", "bool", "=", "False", ",", "\n", "init_var", "=", "1.", ",", "use_covariate", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\" Estimate the probability of failure P(F)\n        Parameters\n        ----------\n\n        prob_tol : float\n            Defines the accuracy of the estimated failure probability in terms\n            of number of total samples. Does not have an effect yet\n\n        batch_size : int\n            the maximum number of samples to be calculated in one call.\n            If 0, the all samples are calculated at once, although note that\n            for larger number of samples, memory errors are possible. To avoid\n            this, set this to a large number, that your memory can handle.\n\n        max_samples : int or None\n            Maximum number of samples. If passed, this will override the\n            estimation using CoV\n\n        post_proc : bool\n            If true, sampling points will be accumulated to the attributes\n            x_lsf, x_safe and x_fail and also will return mpp, conv_mu, conv_var,\n            conv_x\n\n\n        converge : bool\n            If True, a convergence check will be done after each batch.\n            Recommended for small probabilities of failure\n\n        Returns\n        -------\n        fail_prob_mu : float\n            estimation of the expected probability of failure\n\n        fail_prob_var : float\n            estimation variance of the probability of failure\n\n        Following are only retuned if post_proc = True\n\n        safety_index :\n            Safety index, also known as the sigma level. It is equal to\n            Phi_inv(1-fail_prob_mu), where Phi_inv is the inverse of the CDF\n            of standard normal distribution\n\n\n        mpp : 2-D numpy.ndarray\n            Most probable point of failure among the used samples. It may\n            slightly differ if calculated with optimization directly since\n            no additional samples are generated to find it. If you need this\n            use the mpp module\n\n        conv_mu : numpy.ndarray\n            y-axis values of the convergence plot of the estimation of expected\n            probability of failure.\n\n        conv_var :numpy.ndarray\n            y-axis values of the convergence plot of the variance of the estimation.\n\n        conv_x : numpy.ndarray\n            x-axis of the convergence plots.\n\n        use_covariate : bool\n        if True, following reference is used for the estimation\n            Abdollahi et.al. A refined subset simulation for the reliability analysis using the subset\n            control variate, 2020\n\n        Unlike other Integrators, this will generate the post processing only\n        for the last batch.\n\n        \"\"\"", "\n", "if", "self", ".", "_n_parallel", "!=", "1", ":", "\n", "            ", "print", "(", "\"A parallel implementation of subset simulation is missing.\"", ")", "\n", "print", "(", "\"setting num_parallel to 1\"", ")", "\n", "self", ".", "_n_parallel", "=", "1", "\n", "", "self", ".", "_post_proc", "=", "post_proc", "\n", "num_subset_points", "=", "int", "(", "num_subset_points", ")", "\n", "assert", "0", "<", "inter_prob", "<", "1", "\n", "\n", "# Generate initial population", "\n", "if", "init_doe", "is", "None", ":", "\n", "# mv_norm = stats.multivariate_normal(mean=np.zeros(self._n_dim)) # Why not an lhs", "\n", "# doe = mv_norm.rvs(num_subset_points)", "\n", "            ", "doe", "=", "make_doe", "(", "num_subset_points", ",", "[", "stats", ".", "norm", "(", ")", "for", "_", "in", "range", "(", "self", ".", "_n_dim", ")", "]", ",", "num_tries", "=", "10", ")", "\n", "", "else", ":", "\n", "            ", "doe", "=", "init_doe", "\n", "if", "doe", ".", "shape", "[", "0", "]", "!=", "num_subset_points", ":", "\n", "                ", "warnings", ".", "warn", "(", "f\"Mismatch between the passed doe shape {doe.shape} \"", "\n", "f\"and num_subset_points ({num_subset_points}).\"", ")", "\n", "\n", "", "", "outputs", "=", "self", ".", "const_env_stdnorm", "(", "doe", ")", "\n", "num_seeds", "=", "int", "(", "np", ".", "ceil", "(", "num_subset_points", "*", "inter_prob", ")", ")", "\n", "doe_cur", ",", "outputs_cur", ",", "g_cur", "=", "_get_worst_n", "(", "doe", ",", "outputs", ",", "num_seeds", ")", "\n", "if", "g_cur", "<=", "0", ":", "# Failure region has already been reached", "\n", "            ", "fails", "=", "outputs", "<", "0", "\n", "fail_prob", "=", "np", ".", "mean", "(", "fails", ")", "\n", "fail_prob_var", "=", "_subset_cov", "(", "fail_prob", ",", "doe", ".", "shape", "[", "0", "]", ")", "\n", "safety_index", "=", "to_safety_index", "(", "fail_prob", ")", "\n", "if", "post_proc", ":", "\n", "                ", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "=", "self", ".", "_gen_post_proc", "(", "fails", ")", "\n", "return", "fail_prob", ",", "fail_prob_var", ",", "safety_index", ",", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "", "return", "fail_prob", ",", "fail_prob_var", ",", "safety_index", ",", "None", "\n", "", "alphas", "=", "[", "]", "\n", "subset_counter", "=", "0", "\n", "fail_probs", "=", "[", "inter_prob", "]", "\n", "deltas", "=", "[", "_subset_cov", "(", "inter_prob", ",", "num_subset_points", ")", "]", "\n", "lamb", "=", "0.6", "# recommended initial value for lambda", "\n", "while", "g_cur", ">", "0", "and", "subset_counter", "<=", "max_subsets", ":", "\n", "# np.random.shuffle(doe_cur)", "\n", "            ", "doe_cur", ",", "outputs_cur", ",", "lamb", "=", "parallel_adaptive_conditional_sampling", "(", "doe_cur", ",", "outputs_cur", ",", "num_subset_points", ",", "\n", "self", ".", "const_env_stdnorm", ",", "g_cur", ",", "lamb", ",", "\n", "init_var", ")", "\n", "doe_cur", "=", "doe_cur", ".", "reshape", "(", "-", "1", ",", "self", ".", "_n_dim", ")", "\n", "doe_cur", ",", "outputs_next", ",", "g_next", "=", "_get_worst_n", "(", "doe_cur", ",", "outputs_cur", ".", "ravel", "(", ")", ",", "num_seeds", ")", "\n", "# print(g_cur, g_next, outputs_cur.min(), outputs_cur.std())", "\n", "indicators", "=", "outputs_cur", "<", "g_next", "\n", "fail_probs", ".", "append", "(", "indicators", ".", "mean", "(", ")", ")", "\n", "# print(fail_probs)", "\n", "if", "use_covariate", ":", "\n", "                ", "fail_probs_old", "=", "(", "outputs_cur", "<", "g_cur", ")", ".", "mean", "(", ")", "\n", "if", "fail_probs_old", "==", "fail_probs", "[", "-", "1", "]", "or", "fail_probs_old", "==", "0", ":", "\n", "                    ", "alphas", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "                    ", "alphas", ".", "append", "(", "fail_probs", "[", "-", "1", "]", "/", "fail_probs_old", ")", "\n", "", "", "g_cur", "=", "np", ".", "copy", "(", "g_next", ")", "\n", "gamma", "=", "_corr_factor_gamma", "(", "indicators", ",", "fail_probs", "[", "-", "1", "]", ")", "\n", "# print(gamma)", "\n", "deltas", ".", "append", "(", "_subset_cov", "(", "fail_probs", "[", "-", "1", "]", ",", "num_subset_points", ",", "gamma", ")", ")", "\n", "outputs_cur", "=", "outputs_next", ".", "copy", "(", ")", "\n", "subset_counter", "+=", "1", "\n", "if", "g_cur", "==", "0", ":", "\n", "                ", "break", "\n", "\n", "", "", "deltas", "=", "np", ".", "array", "(", "deltas", ")", "\n", "if", "use_covariate", ":", "\n", "            ", "fail_prob", "=", "np", ".", "prod", "(", "alphas", ")", "*", "fail_probs", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "fail_prob", "=", "np", ".", "prod", "(", "fail_probs", ")", "\n", "", "fail_prob_var", "=", "np", ".", "sum", "(", "deltas", "**", "2", ")", "*", "fail_prob", "**", "2", "\n", "safety_index", "=", "to_safety_index", "(", "fail_prob", ")", "\n", "if", "post_proc", ":", "\n", "            ", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "=", "self", ".", "_gen_post_proc", "(", ")", "\n", "return", "fail_prob", ",", "fail_prob_var", ",", "safety_index", ",", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "", "return", "fail_prob", ",", "fail_prob_var", ",", "safety_index", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.SUSE._gen_post_proc": [[178, 210], ["numpy.array().reshape", "marg.mean", "numpy.ones_like", "numpy.sum", "numpy.argmin", "suse.SUSE.x_lsf[].reshape", "numpy.sum", "numpy.argmin", "numpy.array", "suse.SUSE.x_fail[].reshape"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean"], ["", "def", "_gen_post_proc", "(", "self", ",", "n_conv", "=", "100", ")", ":", "\n", "        ", "\"\"\" Generate post processing. Will only process the last batch\n        Use calc_fail_prob(..., post_proc=True) instead of this.\n        \"\"\"", "\n", "means", "=", "[", "marg", ".", "mean", "(", ")", "for", "marg", "in", "self", ".", "margs", "]", "\n", "means", "=", "np", ".", "array", "(", "means", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "d_best", "=", "np", ".", "inf", "\n", "mpp", "=", "np", ".", "inf", "*", "np", ".", "ones_like", "(", "means", ")", "\n", "if", "self", ".", "x_lsf", ".", "size", ">", "0", ":", "\n", "            ", "distance", "=", "np", ".", "sum", "(", "(", "means", "-", "self", ".", "x_lsf", ")", "**", "2", ",", "axis", "=", "1", ")", "\n", "loc", "=", "np", ".", "argmin", "(", "distance", ")", "\n", "d_best", "=", "distance", "[", "loc", "]", "\n", "mpp", "=", "self", ".", "x_lsf", "[", "loc", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "self", ".", "x_fail", ".", "size", ">", "0", ":", "\n", "            ", "distance", "=", "np", ".", "sum", "(", "(", "means", "-", "self", ".", "x_fail", ")", "**", "2", ",", "axis", "=", "1", ")", "\n", "loc", "=", "np", ".", "argmin", "(", "distance", ")", "\n", "if", "distance", "[", "loc", "]", "<", "d_best", ":", "\n", "                ", "mpp", "=", "self", ".", "x_fail", "[", "loc", ",", ":", "]", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "# if n_conv < 1:", "\n", "#     n_conv = fails.shape[0]", "\n", "# n_win = fails.shape[0] // n_conv", "\n", "# conv_x = np.array([n_win*i_conv for i_conv in range(1, n_conv + 1)])", "\n", "# conv_x[-1] = fails.shape[0]", "\n", "# conv_mu = np.zeros(n_conv)", "\n", "# conv_var = np.zeros(conv_mu.shape[0])", "\n", "# for k in range(1, n_conv+1):", "\n", "#     curr_fails = fails[:(k + 1)*n_win]", "\n", "#     conv_mu[k-1] = np.mean(curr_fails)", "\n", "#     conv_var[k-1] = np.var(curr_fails, ddof=1)", "\n", "", "", "conv_mu", ",", "conv_var", ",", "conv_x", "=", "None", ",", "None", ",", "None", "\n", "return", "mpp", ",", "conv_mu", ",", "conv_var", ",", "conv_x", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._get_worst_n": [[212, 222], ["numpy.argsort"], "function", ["None"], ["", "", "def", "_get_worst_n", "(", "inputs", ",", "outputs", ",", "n_worst", ")", ":", "\n", "    ", "order", "=", "np", ".", "argsort", "(", "outputs", ")", "\n", "g_cur", "=", "outputs", "[", "order", "[", "n_worst", "-", "1", "]", "]", "\n", "if", "g_cur", "<=", "0", ":", "\n", "        ", "g_cur", "=", "0", "\n", "return", "inputs", "[", "order", "]", ",", "outputs", "[", "order", "]", ",", "g_cur", "\n", "", "ids", "=", "order", "[", ":", "n_worst", "]", "\n", "doe_cur", "=", "inputs", "[", "ids", "]", "\n", "outputs_cur", "=", "outputs", "[", "ids", "]", "\n", "return", "doe_cur", ",", "outputs_cur", ",", "g_cur", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._subset_cov": [[224, 228], ["numpy.sqrt"], "function", ["None"], ["", "def", "_subset_cov", "(", "fail_prob", ",", "num_samples", ",", "gamma", "=", "0", ")", ":", "\n", "    ", "if", "fail_prob", ">", "0", ":", "\n", "        ", "return", "np", ".", "sqrt", "(", "(", "1", "-", "fail_prob", ")", "*", "(", "1", "+", "gamma", ")", "/", "num_samples", "/", "fail_prob", ")", "\n", "", "return", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse._corr_factor_gamma": [[230, 247], ["numpy.zeros", "range", "numpy.sum", "numpy.maximum", "numpy.arange"], "function", ["None"], ["", "def", "_corr_factor_gamma", "(", "indicator", ",", "fail_prob", ")", ":", "\n", "    ", "\"\"\" Compute auto correlation factor of mcmc chains using the\n    regular matrix indicator=g<0\n    TODO: Check corr_factor_beta in UQpy.Reliability.py on https://github.com/SURGroup/UQpy\n    \"\"\"", "\n", "n_samples", ",", "n_chains", "=", "indicator", ".", "shape", "\n", "r", "=", "np", ".", "zeros", "(", "n_samples", ")", "\n", "pf_2", "=", "fail_prob", "**", "2", "\n", "for", "lag", "in", "range", "(", "n_samples", ")", ":", "\n", "        ", "if", "lag", ":", "\n", "            ", "r", "[", "lag", "]", "=", "(", "indicator", "[", ":", "-", "lag", "]", "*", "indicator", "[", "lag", ":", "]", ")", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "            ", "r", "[", "lag", "]", "=", "np", ".", "maximum", "(", "(", "indicator", "**", "2", ")", ".", "mean", "(", ")", ",", "1e-12", ")", "\n", "", "", "r", "-=", "pf_2", "\n", "r", "=", "r", "[", "1", ":", "]", "/", "r", "[", "0", "]", "\n", "scales", "=", "(", "1", "-", "np", ".", "arange", "(", "1", ",", "n_samples", ")", "/", "n_samples", ")", "\n", "return", "2", "*", "np", ".", "sum", "(", "scales", "*", "r", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.proba.suse.parallel_adaptive_conditional_sampling": [[249, 319], ["int", "numpy.zeros", "numpy.zeros", "performances.ravel", "numpy.copy", "numpy.zeros_like", "int", "numpy.repeat", "suse.parallel_adaptive_conditional_sampling.get_sigma_rho"], "function", ["None"], ["", "def", "parallel_adaptive_conditional_sampling", "(", "seeds", ",", "performances", ",", "num_samples", ",", "limit_state_fun", ",", "limit_state_value", ",", "\n", "lambda_prev", "=", "0.6", ",", "init_var", "=", "\"auto\"", ")", ":", "\n", "    ", "num_chains", ",", "num_dims", "=", "seeds", ".", "shape", "\n", "num_chain_samples", "=", "int", "(", "np", ".", "floor", "(", "num_samples", "/", "num_chains", ")", ")", "\n", "inputs", "=", "np", ".", "zeros", "(", "(", "num_chain_samples", "+", "1", ",", "num_chains", ",", "num_dims", ")", ")", "\n", "outputs", "=", "np", ".", "zeros", "(", "(", "num_chain_samples", "+", "1", ",", "num_chains", ")", ")", "\n", "inputs", "[", "0", "]", "=", "seeds", "\n", "outputs", "[", "0", "]", "=", "performances", ".", "ravel", "(", ")", "\n", "lambda_cur", "=", "np", ".", "copy", "(", "lambda_prev", ")", "\n", "accepts", "=", "np", ".", "zeros_like", "(", "outputs", ")", "\n", "num_adapts", "=", "int", "(", "0.1", "*", "np", ".", "ceil", "(", "num_chain_samples", ")", ")", "\n", "hat_a", "=", "[", "]", "# average acceptance rate of the chains", "\n", "\n", "star_a", "=", "0.44", "\n", "if", "init_var", "==", "\"auto\"", ":", "\n", "        ", "stds", "=", "np", ".", "std", "(", "seeds", ",", "axis", "=", "0", ",", "ddof", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "stds", "=", "np", ".", "ones", "(", "num_dims", ")", "\n", "if", "init_var", "is", "not", "None", "and", "not", "np", ".", "any", "(", "init_var", "==", "0", ")", ":", "\n", "            ", "stds", "*=", "init_var", "\n", "", "", "stds", "=", "np", ".", "repeat", "(", "stds", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ",", "num_chains", ",", "0", ")", "\n", "\n", "def", "get_sigma_rho", "(", "lamb", ")", ":", "\n", "        ", "sig", "=", "np", ".", "minimum", "(", "lamb", "*", "stds", ",", "np", ".", "ones_like", "(", "stds", ")", ")", "# Ref. 1 Eq. 23", "\n", "return", "sig", ",", "np", ".", "sqrt", "(", "1", "-", "sig", "**", "2", ")", "\n", "\n", "", "sigma", ",", "rho", "=", "get_sigma_rho", "(", "lambda_cur", ")", "\n", "i_adapt", "=", "0", "\n", "# mu_acc = 0", "\n", "# print(\"Chains\", num_chains, \"g_max\", limit_state_value, \"seeds\", seeds)", "\n", "# print(num_chain_samples, num_chains)", "\n", "for", "i_sample", "in", "range", "(", "num_chain_samples", ")", ":", "\n", "        ", "candidates", "=", "np", ".", "random", ".", "normal", "(", "loc", "=", "rho", "*", "inputs", "[", "i_sample", "]", ",", "scale", "=", "sigma", ")", "\n", "performance", "=", "limit_state_fun", "(", "candidates", ")", ".", "ravel", "(", ")", "\n", "improves", "=", "performance", "<=", "limit_state_value", "\n", "inputs", "[", "i_sample", "+", "1", ",", "improves", "]", "=", "candidates", "[", "improves", "]", "\n", "outputs", "[", "i_sample", "+", "1", ",", "improves", "]", "=", "performance", "[", "improves", "]", "\n", "accepts", "[", "i_sample", "+", "1", "]", "=", "improves", "\n", "not_improves", "=", "np", ".", "logical_not", "(", "improves", ")", "\n", "inputs", "[", "i_sample", "+", "1", ",", "not_improves", "]", "=", "inputs", "[", "i_sample", ",", "not_improves", "]", "\n", "outputs", "[", "i_sample", "+", "1", ",", "not_improves", "]", "=", "outputs", "[", "i_sample", ",", "not_improves", "]", "\n", "# print(\"rho\", rho, \"sigma\", sigma, f\"accepts = {accepts[i_sample + 1]}\")", "\n", "# print(\"cur_xs\", inputs[i_sample + 1], \"cur_gs\", outputs[i_sample + 1])", "\n", "\n", "# average of the accepted samples for each seed 'mu_acc'", "\n", "# here the warning \"Mean of empty slice\" is not an issue", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ",", "category", "=", "RuntimeWarning", ")", "\n", "mu_acc", "=", "np", ".", "minimum", "(", "1", ",", "np", ".", "mean", "(", "accepts", "[", ":", "i_sample", "+", "2", "]", ")", ")", "\n", "# print(\"mu_acc\", mu_acc)", "\n", "", "if", "i_sample", "and", "np", ".", "mod", "(", "i_sample", ",", "num_adapts", ")", "==", "0", ":", "\n", "# c. evaluate average acceptance rate", "\n", "# print(\"adapting lamb\", i_adapt, i_sample, num_adapts)", "\n", "            ", "lambda_prev", "=", "np", ".", "copy", "(", "lambda_cur", ")", "\n", "# d. compute new scaling parameter", "\n", "zeta", "=", "1", "/", "np", ".", "sqrt", "(", "i_adapt", "+", "1", ")", "\n", "lambda_cur", "=", "np", ".", "exp", "(", "np", ".", "log", "(", "lambda_prev", ")", "+", "zeta", "*", "(", "mu_acc", "-", "star_a", ")", ")", "# Ref. 1 Eq. 26", "\n", "# print(\"lambda\", lambda_cur)", "\n", "sigma", ",", "rho", "=", "get_sigma_rho", "(", "lambda_cur", ")", "\n", "# print(\"sigma\", sigma, \"rho\", rho)", "\n", "i_adapt", "+=", "1", "\n", "\n", "# compute mean acceptance rate of all chains", "\n", "# if i_adapt != 0:", "\n", "#     with warnings.catch_warnings():", "\n", "#         warnings.simplefilter(\"ignore\", category=RuntimeWarning)", "\n", "#         accept_rate = np.mean(hat_a[:i_adapt - 1])", "\n", "# else:  # no adaptation", "\n", "#     accept_rate = mu_acc", "\n", "", "", "return", "inputs", "[", "1", ":", "]", ",", "outputs", "[", "1", ":", "]", ",", "lambda_cur", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.uniform_lhs": [[24, 118], ["numpy.isscalar", "int", "scipy.stats.uniform.rvs", "range", "ValueError", "ValueError", "numpy.max", "ValueError", "ValueError", "numpy.isscalar", "ValueError", "numpy.round", "numpy.corrcoef", "numpy.sum", "enumerate", "numpy.dot", "numpy.argsort", "numpy.max", "numpy.abs", "numpy.argsort", "numpy.abs", "numpy.abs", "numpy.argsort", "numpy.zeros", "numpy.zeros", "enumerate", "numpy.std", "scipy.linalg.cholesky", "scipy.linalg.cholesky", "scipy.linalg.inv", "numpy.dot", "numpy.argsort", "numpy.eye", "numpy.ones", "numpy.mean", "scipy.linalg.eigh", "numpy.dot", "scipy.linalg.eigh", "numpy.dot", "numpy.nan_to_num", "scipy.linalg.pinv", "numpy.max", "numpy.diag", "numpy.diag", "numpy.argsort", "numpy.sqrt", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean"], ["def", "uniform_lhs", "(", "lower_bounds", ",", "upper_bounds", ",", "num_sample", ",", "corr_mat", "=", "0", ",", "\n", "num_iter", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Creates a uniformly distributed LHS with central points. Implements the method proposed in [1]\n\n    [1] D. Roos, LATIN HYPERCUBE SAMPLING BASED ON ADAPTIVE ORTHOGONAL DECOMPOSITION, ECCOMAS 2016\n\n    Input\n    -----\n    lower_bounds : np.ndarray\n        Lower bounds. Shape = (n_dim,)\n    upper_bounds : np.ndarray\n        Upper bounds. Shape = (n_dim,)\n    num_sample : int\n        Number of Samples\n    corr_mat : float or 2-D np.ndarray\n        Correlation matrix. If an array, it must be symmetrical with shape=(n_dim, n_dim). If scalar, the whole matrix\n        except the diagonal will be filled with this value. Default is 0 meaning no correlation.\n    num_iter : int\n        The number of iterations. Default is 100.\n\n    Returns\n    -------\n    fDoEPts : np.ndarray\n        Optimized design of experiments matrix with the shape=(num_sample, n_dim)\n    \"\"\"", "\n", "num_var", "=", "lower_bounds", ".", "shape", "[", "0", "]", "\n", "# Sanity checks", "\n", "if", "not", "num_var", "==", "upper_bounds", ".", "shape", "[", "0", "]", ":", "\n", "        ", "err_msg", "=", "'Lower bounds should have the same number of entries'", "\n", "err_msg", "+=", "'\\n as the upper bounds.'", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "interval", "=", "(", "upper_bounds", "-", "lower_bounds", ")", "\n", "if", "(", "interval", "<", "0", ")", ".", "any", "(", ")", ":", "\n", "        ", "err_msg", "=", "'Upper bounds should be greater than the lower bounds.'", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "np", ".", "isscalar", "(", "corr_mat", ")", ":", "\n", "        ", "corr_mat", "=", "np", ".", "eye", "(", "num_var", ")", "*", "(", "1", "-", "corr_mat", ")", "+", "np", ".", "ones", "(", "(", "num_var", ",", "num_var", ")", ")", "*", "corr_mat", "\n", "", "if", "np", ".", "max", "(", "np", ".", "abs", "(", "corr_mat", ")", ")", ">", "1", ":", "\n", "        ", "err_msg", "=", "'Correlations should be in the interval [-1,1].'", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "not", "(", "corr_mat", ".", "shape", "[", "0", "]", "==", "corr_mat", ".", "shape", "[", "1", "]", "and", "corr_mat", ".", "shape", "[", "0", "]", "==", "num_var", ")", ":", "\n", "        ", "err_msg", "=", "'Inconsistent number of correlations and bounds.'", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "not", "np", ".", "isscalar", "(", "num_iter", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'num_iter must be a scalar.'", ")", "\n", "", "if", "num_iter", "<", "1", ":", "\n", "        ", "num_iter", "=", "1", "\n", "", "num_iter", "=", "int", "(", "np", ".", "round", "(", "num_iter", ")", ")", "\n", "\n", "# Create start solution. Anything goes", "\n", "doe_curr", "=", "uniform", ".", "rvs", "(", "size", "=", "(", "num_sample", ",", "num_var", ")", ")", "\n", "doe_curr", "=", "(", "np", ".", "argsort", "(", "doe_curr", ",", "axis", "=", "0", ")", "-", "0.5", ")", "/", "num_sample", "\n", "old_score", "=", "np", ".", "inf", "\n", "#", "\n", "# array instead of switching just the first column", "\n", "for", "_", "in", "range", "(", "num_iter", ")", ":", "\n", "        ", "cur_rho", "=", "np", ".", "corrcoef", "(", "doe_curr", ",", "rowvar", "=", "False", ")", "\n", "cur_score", "=", "np", ".", "sum", "(", "np", ".", "abs", "(", "cur_rho", "-", "corr_mat", ")", ",", "axis", "=", "0", ")", "\n", "# print(iIter,np.max(fScores))", "\n", "if", "np", ".", "abs", "(", "np", ".", "max", "(", "cur_score", ")", "-", "old_score", ")", "<", "1e-16", ":", "\n", "            ", "break", "\n", "", "core_orders", "=", "np", ".", "argsort", "(", "cur_score", ")", "[", ":", ":", "-", "1", "]", "\n", "ord_rho", ",", "ord_cur_rho", "=", "(", "np", ".", "zeros", "(", "cur_rho", ".", "shape", ")", ",", "np", ".", "zeros", "(", "cur_rho", ".", "shape", ")", ")", "\n", "for", "i_row", ",", "i_row_order", "in", "enumerate", "(", "core_orders", ")", ":", "\n", "            ", "for", "i_col", ",", "i_col_order", "in", "enumerate", "(", "core_orders", ")", ":", "\n", "                ", "ord_rho", "[", "i_row", ",", "i_col", "]", "=", "corr_mat", "[", "i_row_order", ",", "i_col_order", "]", "\n", "ord_cur_rho", "[", "i_row", ",", "i_col", "]", "=", "cur_rho", "[", "i_row_order", ",", "i_col_order", "]", "\n", "", "", "doe_curr", "=", "doe_curr", "[", ":", ",", "core_orders", "]", "\n", "doe_curr", "=", "(", "doe_curr", "-", "np", ".", "mean", "(", "doe_curr", ",", "axis", "=", "0", ")", ")", "/", "np", ".", "std", "(", "doe_curr", ",", "axis", "=", "0", ")", "\n", "try", ":", "\n", "            ", "chol_mat", "=", "cholesky", "(", "ord_rho", ",", "lower", "=", "False", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "eig_val", ",", "eig_vec", "=", "eigh", "(", "ord_rho", ")", "\n", "chol_mat", "=", "np", ".", "dot", "(", "np", ".", "diag", "(", "np", ".", "sqrt", "(", "eig_val", ")", ")", ",", "eig_vec", ".", "T", ")", "\n", "\n", "", "try", ":", "\n", "            ", "chol_cur_mat", "=", "cholesky", "(", "ord_cur_rho", ",", "lower", "=", "False", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "eig_val", ",", "eig_vec", "=", "eigh", "(", "ord_cur_rho", ")", "\n", "chol_cur_mat", "=", "np", ".", "dot", "(", "np", ".", "diag", "(", "np", ".", "sqrt", "(", "eig_val", ")", ")", ",", "eig_vec", ".", "T", ")", "\n", "chol_cur_mat", "=", "np", ".", "nan_to_num", "(", "chol_cur_mat", ")", "\n", "\n", "", "try", ":", "\n", "            ", "chol_cur_mat_inv", "=", "inv", "(", "chol_cur_mat", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "chol_cur_mat_inv", "=", "pinv", "(", "chol_cur_mat", ")", "\n", "", "doe_curr", "=", "np", ".", "dot", "(", "doe_curr", ",", "np", ".", "dot", "(", "chol_cur_mat_inv", ",", "chol_mat", ")", ")", "\n", "doe_curr", "=", "np", ".", "argsort", "(", "np", ".", "argsort", "(", "doe_curr", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", "\n", "doe_curr", "=", "(", "doe_curr", "+", "0.5", ")", "/", "num_sample", "\n", "doe_curr", "=", "doe_curr", "[", ":", ",", "np", ".", "argsort", "(", "core_orders", ")", "]", "\n", "doe_curr", "=", "doe_curr", "*", "interval", "+", "lower_bounds", "\n", "old_score", "=", "np", ".", "max", "(", "cur_score", ")", "\n", "", "return", "doe_curr", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.orthogonal_sampling": [[120, 188], ["len", "numpy.isscalar", "max", "numpy.log", "int", "range", "numpy.zeros", "range", "lhs._calc_distscore", "lhs._calc_corrscore", "ValueError", "ValueError", "numpy.sqrt", "numpy.sqrt", "lhs.uniform_lhs", "float", "margs[].ppf", "len", "numpy.zeros", "numpy.ones", "lhs.orthogonal_sampling._calc_score"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs._calc_distscore", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs._calc_corrscore", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.uniform_lhs"], ["", "def", "orthogonal_sampling", "(", "margs", ",", "num_sample", ":", "int", ",", "corr_mat", "=", "0", ",", "num_iter", "=", "100", ")", ":", "\n", "    ", "\"\"\"\n    Creates an arbitrarily distributed LHS.\n\n    This function creates a uniform LHS with UniformLHS-function\n    and uses inverse transform sampling to convert the uniform LHS\n    to an arbitrarily distributed one.\n\n    Parameters\n    ----------\n    margs : list of distributions\n        List of marginal distribution objects with .ppf method each object\n        corresponds one random variable.\n\n    num_sample : int\n        Number of samples\n\n    corr_mat : float or np.ndarray\n        Correlation matrix. If an array, it must be symmetrical with shape=(n_dim, n_dim). If scalar, the whole matrix\n        except the diagonal will be filled with this value. Default is 0 meaning no correlation.\n\n    num_iter : int\n        Number of iterations to compute the uniform LHS\n\n    Returns\n    -------\n    fDoEPts : 2-D numpy.ndarray\n        Optimized design of experiments matrix with the shape\n        ```python\n        (num_sample, len(margs))\n        ```\n    \"\"\"", "\n", "\n", "def", "_calc_score", "(", "doe_curr", ",", "corrs", ",", "dist_max", ")", ":", "\n", "        ", "dist_score", "=", "_calc_distscore", "(", "doe_curr", ",", "dist_max", ")", "\n", "corr_score", "=", "_calc_corrscore", "(", "doe_curr", ",", "corrs", ")", "\n", "return", "5", "*", "dist_score", "+", "corr_score", "\n", "\n", "", "num_var", "=", "len", "(", "margs", ")", "\n", "# Sanity checks", "\n", "if", "np", ".", "isscalar", "(", "corr_mat", ")", ":", "\n", "        ", "corr_mat", "=", "np", ".", "eye", "(", "num_var", ")", "*", "(", "1", "-", "corr_mat", ")", "+", "np", ".", "ones", "(", "(", "num_var", ",", "num_var", ")", ")", "*", "corr_mat", "\n", "", "if", "not", "(", "corr_mat", ".", "shape", "[", "0", "]", "==", "corr_mat", ".", "shape", "[", "1", "]", "and", "corr_mat", ".", "shape", "[", "0", "]", "==", "num_var", ")", ":", "\n", "        ", "msg", "=", "'Inconsistent number of correlations and distibution'", "\n", "msg", "+=", "'\\n objects.'", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "if", "num_iter", "<", "0", ":", "\n", "        ", "msg", "=", "f\"num_iter must be >= 0. Passed {num_iter}.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "num_iter", "=", "max", "(", "1", ",", "num_iter", ")", "\n", "best_probs", "=", "None", "\n", "best_score", "=", "np", ".", "inf", "\n", "log_d_max", "=", "np", ".", "log", "(", "np", ".", "sqrt", "(", "len", "(", "margs", ")", ")", ")", "\n", "n_iter", "=", "int", "(", "np", ".", "sqrt", "(", "num_iter", ")", ")", "\n", "for", "n_iter", "in", "range", "(", "n_iter", ")", ":", "\n", "        ", "probs", "=", "uniform_lhs", "(", "np", ".", "zeros", "(", "num_var", ")", ",", "np", ".", "ones", "(", "num_var", ")", ",", "num_sample", ",", "\n", "corr_mat", "=", "corr_mat", ",", "num_iter", "=", "n_iter", ")", "\n", "score", "=", "float", "(", "_calc_score", "(", "probs", ",", "corr_mat", ",", "log_d_max", ")", ")", "\n", "if", "best_probs", "is", "None", "or", "score", "<", "best_score", ":", "\n", "            ", "best_probs", "=", "np", ".", "copy", "(", "probs", ")", "\n", "best_score", "=", "score", "\n", "\n", "", "", "doe", "=", "np", ".", "zeros", "(", "best_probs", ".", "shape", ")", "\n", "\n", "# Inverse transform sampling", "\n", "for", "i_var", "in", "range", "(", "num_var", ")", ":", "\n", "        ", "doe", "[", ":", ",", "i_var", "]", "=", "margs", "[", "i_var", "]", ".", "ppf", "(", "best_probs", "[", ":", ",", "i_var", "]", ")", "\n", "", "return", "doe", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs._switch_rows": [[190, 241], ["scipy.special.comb", "numpy.unique", "fulls_1[].tolist", "numpy.arange().tolist", "numpy.random.choice", "numpy.arange", "numpy.random.choice", "numpy.array", "numpy.empty", "numpy.unique", "uniques[].tolist", "numpy.random.choice", "numpy.arange", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division.comb"], ["", "def", "_switch_rows", "(", "doe_curr", ",", "column", "=", "None", ",", "col_row_pairs", "=", "(", ")", ")", ":", "\n", "    ", "\"\"\"\n    Randomly switches the values of a numpy array along the second axis\n    This is the permutation function of OptimizeLHS.\n\n    Parameters\n    -----\n    doe_curr : np.ndarray\n        shape = (num_sample, n_dim)\n    column : int\n        The number of column, along which the switching is done. If\n        not given, it will be chosen randomly.\n\n    Returns\n    -------\n    doe_perturbed : np.ndarray\n        perturbed DoE with shape (num_sample, num_dim)\n        ```python\n\n        ```\n    \"\"\"", "\n", "\n", "num_sample", ",", "num_var", "=", "doe_curr", ".", "shape", "\n", "max_combs_per_column", "=", "combine", "(", "num_sample", ",", "2", ")", "\n", "max_combs_per_row", "=", "num_sample", "-", "1", "\n", "if", "col_row_pairs", ":", "\n", "        ", "pairs", "=", "np", ".", "array", "(", "col_row_pairs", ",", "dtype", "=", "int", ")", "\n", "", "else", ":", "\n", "        ", "pairs", "=", "np", ".", "empty", "(", "(", "0", ",", "3", ")", ",", "dtype", "=", "int", ")", "\n", "", "if", "column", ":", "\n", "        ", "cur_column", "=", "column", "\n", "", "else", ":", "\n", "        ", "uniques", ",", "col_counts", "=", "np", ".", "unique", "(", "pairs", "[", ":", ",", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "uniques", "=", "uniques", "[", "col_counts", ">=", "max_combs_per_column", "]", ".", "tolist", "(", ")", "\n", "possible_cols", "=", "[", "i_col", "for", "i_col", "in", "np", ".", "arange", "(", "num_var", ")", "if", "i_col", "not", "in", "uniques", "]", "\n", "cur_column", "=", "np", ".", "random", ".", "choice", "(", "possible_cols", ")", "\n", "", "pairs", "=", "pairs", "[", "pairs", "[", ":", ",", "0", "]", "==", "cur_column", ",", "1", ":", "]", "\n", "fulls_1", ",", "row_counts", "=", "np", ".", "unique", "(", "pairs", "[", ":", ",", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "fulls_1", "=", "fulls_1", "[", "row_counts", ">=", "max_combs_per_row", "-", "fulls_1", "]", ".", "tolist", "(", ")", "\n", "row_inds", "=", "np", ".", "arange", "(", "num_sample", "-", "1", ")", ".", "tolist", "(", ")", "\n", "possible_rows", "=", "[", "i_row", "for", "i_row", "in", "row_inds", "if", "i_row", "not", "in", "fulls_1", "]", "\n", "row_1", "=", "np", ".", "random", ".", "choice", "(", "possible_rows", ")", "\n", "possible_rows", "=", "np", ".", "arange", "(", "row_1", ",", "num_sample", ")", "\n", "fulls_2", "=", "pairs", "[", "pairs", "[", ":", ",", "0", "]", "==", "row_1", ",", "1", "]", "\n", "possible_rows", "=", "[", "i_row", "for", "i_row", "in", "possible_rows", "if", "i_row", "not", "in", "fulls_2", "]", "\n", "row_2", "=", "np", ".", "random", ".", "choice", "(", "possible_rows", ")", "\n", "if", "row_1", ">", "row_2", ":", "\n", "        ", "row_1", ",", "row_2", "=", "row_2", ",", "row_1", "# always same order", "\n", "", "doe_curr", "[", "row_1", ",", "cur_column", "]", ",", "doe_curr", "[", "row_2", ",", "cur_column", "]", "=", "doe_curr", "[", "row_2", ",", "cur_column", "]", ",", "doe_curr", "[", "row_1", ",", "cur_column", "]", "\n", "return", "doe_curr", ",", "(", "cur_column", ",", "row_1", ",", "row_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.optimize_doe": [[243, 365], ["numpy.isscalar", "numpy.round", "copy.deepcopy", "numpy.log", "lhs.orthogonal_sampling._calc_score"], "function", ["None"], ["", "def", "optimize_doe", "(", "doe_start", ",", "corr_mat", "=", "0", ",", "doe_old", "=", "None", ",", "num_tries", ":", "int", "=", "10000", ",", "\n", "decay", ":", "float", "=", ".95", ",", "max_steps", ":", "int", "=", "20", ",", "sim_time", ":", "float", "=", "25.", ",", "\n", "verbose", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Optimizes a start LHS with simulated annealing to minimize\n    the maximum correlation error.\n\n    Inputs\n    ------\n    doe_start : numpy.ndarray\n        used as the started solution with shape=(num_sample, num_vars)\n\n    corr_mat : float or numpy.ndarray\n        Correlation matrix. It must be symmetrical. If scalar, the whole matrix\n        except the diagonal will be filled with this value. Default is 0 meaning\n        no correlation.\n\n    num_tries : int\n        Maximum number of tries\n\n    sim_time : float\n        Time for the annealing algorithm.\n\n    decay : float\n        Step size for fTime for the annealing algorithm. Must be smaller than 1.\n\n    max_steps : int\n        Maximum number of steps for each time step\n\n\n    Returns\n    -------\n    doe_final : numpy.ndarray\n        Optimized design of experiments matrix with the shape=(num_sample, n_dim)\n    \"\"\"", "\n", "num_var", "=", "doe_start", ".", "shape", "[", "1", "]", "\n", "\n", "def", "_calc_score", "(", "doe_curr", ",", "corr_mat", ",", "dist_max", ",", "appender", ")", ":", "\n", "        ", "dist_score", "=", "_calc_distscore", "(", "appender", "(", "doe_curr", ")", ",", "dist_max", ")", "\n", "corr_score", "=", "_calc_corrscore", "(", "appender_loc", "(", "doe_curr", ")", ",", "corr_mat", ")", "\n", "return", "5", "*", "dist_score", "+", "corr_score", "\n", "\n", "", "if", "doe_start", ".", "shape", "[", "0", "]", "==", "1", ":", "\n", "        ", "return", "doe_start", "\n", "# Sanity checks", "\n", "", "if", "np", ".", "isscalar", "(", "corr_mat", ")", ":", "\n", "        ", "corr_mat", "=", "np", ".", "eye", "(", "num_var", ")", "*", "(", "1", "-", "corr_mat", ")", "+", "np", ".", "ones", "(", "(", "num_var", ",", "num_var", ")", ")", "*", "corr_mat", "\n", "", "if", "not", "(", "corr_mat", ".", "shape", "[", "0", "]", "==", "corr_mat", ".", "shape", "[", "1", "]", "and", "corr_mat", ".", "shape", "[", "0", "]", "==", "num_var", ")", ":", "\n", "        ", "msg", "=", "'Inconsistent number of correlations and number of'", "\n", "msg", "+=", "'\\n variables in the LHS.'", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "if", "num_tries", "<", "1", ":", "\n", "        ", "num_tries", "=", "1", "\n", "", "num_tries", "=", "np", ".", "round", "(", "num_tries", ")", "\n", "if", "sim_time", "<", "1e-16", ":", "\n", "        ", "sim_time", "=", "1.", "\n", "", "if", "decay", "<=", "0", "or", "decay", ">=", "1", ":", "\n", "        ", "raise", "ValueError", "(", "'fFac lie in the interval (0,1).'", ")", "\n", "", "if", "max_steps", "<", "1", ":", "\n", "        ", "max_steps", "=", "1.", "\n", "", "if", "doe_old", "is", "None", ":", "\n", "        ", "appender", "=", "appender_loc", "=", "lambda", "x", ":", "x", "\n", "", "else", ":", "\n", "        ", "locs", "=", "[", "doe_start", ".", "min", "(", "0", ",", "keepdims", "=", "True", ")", ",", "doe_start", ".", "max", "(", "0", ",", "keepdims", "=", "True", ")", "]", "\n", "locs", "=", "np", ".", "logical_and", "(", "(", "doe_old", ">=", "locs", "[", "0", "]", ")", ".", "all", "(", "1", ")", ",", "\n", "(", "doe_old", "<=", "locs", "[", "1", "]", ")", ".", "all", "(", "1", ")", ")", "\n", "appender_loc", "=", "lambda", "x", ":", "np", ".", "append", "(", "doe_old", "[", "locs", "]", ".", "reshape", "(", "(", "-", "1", ",", "x", ".", "shape", "[", "1", "]", ")", ")", ",", "x", ",", "axis", "=", "0", ")", "\n", "appender", "=", "lambda", "x", ":", "np", ".", "append", "(", "doe_old", ",", "x", ",", "axis", "=", "0", ")", "# will be used for calculating score", "\n", "\n", "", "doe_final", "=", "deepcopy", "(", "doe_start", ")", "\n", "dist_max", "=", "np", ".", "max", "(", "appender", "(", "doe_start", ")", ",", "axis", "=", "0", ")", "-", "np", ".", "min", "(", "appender", "(", "doe_start", ")", ",", "axis", "=", "0", ")", "\n", "dist_max", "=", "np", ".", "log", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "dist_max", "**", "2", ")", ")", ")", "\n", "best_score", "=", "_calc_score", "(", "doe_final", ",", "corr_mat", ",", "dist_max", ",", "appender", ")", "\n", "start_score", "=", "best_score", "\n", "max_cr_pair", "=", "doe_start", ".", "shape", "[", "1", "]", "*", "combine", "(", "doe_start", ".", "shape", "[", "0", "]", ",", "2", ")", "\n", "i_step", "=", "0", "\n", "if", "verbose", ">", "0", ":", "\n", "        ", "dist_score", "=", "_calc_distscore", "(", "appender", "(", "doe_final", ")", ",", "dist_max", ")", "\n", "corr_score", "=", "_calc_corrscore", "(", "doe_final", ",", "corr_mat", ")", "\n", "print", "(", "f\"Start loss - total: {best_score:.4f} dist: {5 * dist_score:.4f} corr: {corr_score:.4f}\"", ")", "\n", "", "cr_pairs", "=", "[", "]", "\n", "old_cr_pairs", "=", "[", "]", "\n", "for", "i_try", "in", "range", "(", "num_tries", ")", ":", "\n", "        ", "doe_try", ",", "pair", "=", "_switch_rows", "(", "doe_start", ",", "col_row_pairs", "=", "cr_pairs", ")", "\n", "cr_pairs", ".", "append", "(", "pair", ")", "\n", "curr_score", "=", "_calc_score", "(", "doe_try", ",", "corr_mat", ",", "dist_max", ",", "appender", ")", "\n", "anneal_prob", "=", "0.", "\n", "if", "sim_time", ">", "1e-5", ":", "\n", "            ", "anneal_prob", "=", "np", ".", "exp", "(", "-", "(", "curr_score", "-", "start_score", ")", "/", "sim_time", ")", "\n", "\n", "", "if", "curr_score", "<=", "start_score", "or", "np", ".", "random", ".", "random", "(", ")", "<=", "anneal_prob", ":", "# pylint: disable=no-member", "\n", "            ", "doe_start", "=", "deepcopy", "(", "doe_try", ")", "\n", "old_cr_pairs", "=", "deepcopy", "(", "cr_pairs", ")", "\n", "cr_pairs", "=", "[", "]", "\n", "start_score", "=", "curr_score", "\n", "i_step", "=", "0", "\n", "sim_time", "*=", "decay", "\n", "if", "start_score", "<", "best_score", ":", "\n", "                ", "doe_final", "=", "deepcopy", "(", "doe_start", ")", "\n", "best_score", "=", "start_score", "\n", "if", "verbose", ">", "1", ":", "\n", "                    ", "dist_score", "=", "_calc_distscore", "(", "appender", "(", "doe_final", ")", ",", "dist_max", ")", "\n", "corr_score", "=", "_calc_corrscore", "(", "doe_final", ",", "corr_mat", ")", "\n", "print", "(", "f\"{i_try + 1} - total: {best_score:.4f} dist: {5 * dist_score:.4f} corr: {corr_score:.4f}\"", ")", "\n", "", "", "", "i_step", "+=", "1", "\n", "if", "i_step", ">=", "max_steps", ":", "\n", "            ", "sim_time", "*=", "decay", "\n", "# Bound Randomness by setting back to best result", "\n", "# This may help convergence", "\n", "doe_start", "=", "deepcopy", "(", "doe_final", ")", "\n", "cr_pairs", "=", "deepcopy", "(", "old_cr_pairs", ")", "\n", "start_score", "=", "best_score", "\n", "i_step", "=", "0", "\n", "", "if", "len", "(", "cr_pairs", ")", ">=", "max_cr_pair", ":", "\n", "# switch_twice = True", "\n", "            ", "break", "\n", "\n", "", "", "if", "verbose", ">", "0", ":", "\n", "        ", "dist_score", "=", "_calc_distscore", "(", "appender", "(", "doe_final", ")", ",", "dist_max", ")", "\n", "corr_score", "=", "_calc_corrscore", "(", "doe_final", ",", "corr_mat", ")", "\n", "print", "(", "f\"Final loss - total: {best_score:.4f} dist: {5 * dist_score:.4f} corr: {corr_score:.4f}\"", ")", "\n", "", "return", "doe_final", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs._calc_distscore": [[367, 371], ["numpy.log", "numpy.min", "scipy.spatial.distance.pdist"], "function", ["None"], ["", "def", "_calc_distscore", "(", "doe_cur", ",", "log_d_max", ")", ":", "\n", "    ", "\"\"\" Calculate quality score used for DoE optimization\"\"\"", "\n", "obj_d", "=", "log_d_max", "-", "np", ".", "log", "(", "np", ".", "min", "(", "pdist", "(", "doe_cur", ")", ")", ")", "\n", "return", "obj_d", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs._calc_corrscore": [[373, 378], ["numpy.max", "numpy.log", "numpy.abs", "numpy.corrcoef"], "function", ["None"], ["", "def", "_calc_corrscore", "(", "doe_cur", ",", "corr_mat", ")", ":", "\n", "    ", "d_cor", "=", "np", ".", "max", "(", "np", ".", "abs", "(", "np", ".", "corrcoef", "(", "doe_cur", ",", "rowvar", "=", "False", ")", "-", "corr_mat", ")", ")", "\n", "if", "d_cor", "<=", "1e-8", ":", "\n", "        ", "d_cor", "=", "1e-8", "\n", "", "return", "np", ".", "log", "(", "d_cor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.inherit_lhs": [[380, 422], ["empty_bins.sum", "numpy.empty", "range", "numpy.array", "numpy.array", "int", "numpy.arange", "numpy.random.choice", "numpy.append", "numpy.random.choice().tolist", "numpy.array", "numpy.random.permutation", "numpy.random.choice", "enumerate", "abs"], "function", ["None"], ["", "def", "inherit_lhs", "(", "num_sample", ",", "empty_bins", ",", "bounds_l", ",", "bounds_u", ")", ":", "\n", "    ", "\"\"\"\n    Add new samples to lhs\n\n    Parameters\n    ----------\n    num_sample : int\n        Number of samples\n\n    empty_bins : np.ndarray\n        Boolean mask of empty bins with shape=(n_bins, n_dims)\n\n    bounds_l : np.ndarray\n        Lower bounds with shape=(n_dims,)\n\n    bounds_u : np.ndarray\n        Upper bounds with shape=(n_dims,)\n\n    Returns\n    -------\n    candidates: np.ndarray\n        candidate new samples placed at empty bins with shape=(num_sample, n_dims)\n    \"\"\"", "\n", "num_bins", ",", "num_dims", "=", "empty_bins", ".", "shape", "\n", "v", "=", "(", "np", ".", "arange", "(", "num_bins", ")", "+", "0.5", ")", "/", "num_bins", "# get bin mids i.e. 0.5/num_sample, 1.5/num_sample...", "\n", "n_empty", "=", "empty_bins", ".", "sum", "(", "0", ")", "\n", "lb", ",", "ub", "=", "np", ".", "array", "(", "bounds_l", ")", ",", "np", ".", "array", "(", "bounds_u", ")", "\n", "frees", "=", "np", ".", "empty", "(", "(", "num_sample", ",", "num_dims", ")", ")", "\n", "for", "i_dim", "in", "range", "(", "num_dims", ")", ":", "\n", "        ", "cur_bins", "=", "v", "[", "empty_bins", "[", ":", ",", "i_dim", "]", "]", "\n", "n_diff", "=", "int", "(", "num_sample", "-", "n_empty", "[", "i_dim", "]", ")", "\n", "while", "n_diff", "!=", "0", ":", "\n", "            ", "if", "n_diff", ">", "0", ":", "\n", "                ", "extras", "=", "np", ".", "random", ".", "choice", "(", "v", ",", "size", "=", "n_diff", ",", "replace", "=", "False", ")", "\n", "cur_bins", "=", "np", ".", "append", "(", "cur_bins", ",", "extras", ")", "\n", "n_diff", "-=", "num_sample", "\n", "", "else", ":", "\n", "                ", "extras", "=", "np", ".", "random", ".", "choice", "(", "v", ",", "size", "=", "abs", "(", "n_diff", ")", ",", "replace", "=", "False", ")", ".", "tolist", "(", ")", "\n", "cur_bins", "=", "np", ".", "array", "(", "[", "c", "for", "i", ",", "c", "in", "enumerate", "(", "cur_bins", ")", "if", "i", "not", "in", "extras", "]", ")", "\n", "n_diff", "=", "0", "\n", "", "", "frees", "[", ":", ",", "i_dim", "]", "=", "cur_bins", "[", "np", ".", "random", ".", "permutation", "(", "num_sample", ")", "]", "\n", "", "return", "frees", "*", "(", "ub", "-", "lb", ")", "+", "lb", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe": [[424, 507], ["len", "numpy.isscalar", "lhs.orthogonal_sampling", "lhs.optimize_doe", "numpy.array().reshape", "ValueError", "numpy.any", "range", "range", "ValueError", "scipy.stats.uniform", "ValueError", "numpy.sum", "numpy.sum", "zip", "numpy.array", "numpy.eye", "numpy.ones", "marg.rvs"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.orthogonal_sampling", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.optimize_doe"], ["", "def", "make_doe", "(", "num_sample", ",", "margs", "=", "None", ",", "corr_mat", "=", "0", ",", "num_tries", "=", "None", ",", "\n", "lower_bound", "=", "None", ",", "upper_bound", "=", "None", ",", "verbose", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Makes an LHS with desired distributions and correlation\n\n    Parameters\n    ----------\n    num_sample : int\n        Number of samples\n\n    margs : list\n        List of marginal distribution objects with .ppf method. Each object\n        corresponds one random variable.\n    corr_mat : float or 2-D np.ndarray\n        Correlation matrix. If an array, it must be symmetrical with shape=(n_dim, n_dim). If scalar, the whole matrix\n        except the diagonal will be filled with this value. Default is 0 meaning no correlation.\n\n    lower_bound : np.ndarray\n        Lower bounds. Shape = (n_dim,)\n\n    upper_bound : np.ndarray\n        Upper bounds. Shape = (n_dim,)\n\n\n    Returns\n    -------\n    doe_final : 2-D numpy.ndarray\n        Optimized design of experiments matrix with the shape (num_sample, len(margs))\n\n    \"\"\"", "\n", "if", "margs", "is", "None", ":", "\n", "        ", "margs", "=", "[", "uniform", "(", "lb", ",", "ub", "-", "lb", ")", "\n", "for", "lb", ",", "ub", "in", "zip", "(", "lower_bound", ",", "upper_bound", ")", "]", "\n", "", "if", "num_sample", "==", "1", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "marg", ".", "rvs", "(", "1", ")", "for", "marg", "in", "margs", "]", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "num_tries", "is", "None", ":", "\n", "        ", "if", "num_sample", "<", "100", ":", "\n", "            ", "num_tries", "=", "20000", "\n", "", "else", ":", "\n", "            ", "num_tries", "=", "2000", "\n", "", "", "if", "margs", "is", "None", "and", "(", "lower_bound", "is", "None", "or", "upper_bound", "is", "None", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Either marginal distributions or bounds must be passed\"", ")", "\n", "\n", "", "if", "lower_bound", "is", "not", "None", "and", "upper_bound", "is", "not", "None", ":", "\n", "        ", "if", "np", ".", "any", "(", "lower_bound", ">=", "upper_bound", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Lower bound must be strictly smaller than the upper bound\"", ")", "\n", "", "", "num_dims", "=", "len", "(", "margs", ")", "\n", "if", "np", ".", "isscalar", "(", "corr_mat", ")", ":", "\n", "        ", "corr_mat", "=", "np", ".", "eye", "(", "num_dims", ")", "*", "(", "1", "-", "corr_mat", ")", "+", "np", ".", "ones", "(", "(", "num_dims", ",", "num_dims", ")", ")", "*", "corr_mat", "\n", "", "n_iter", "=", "num_tries", "//", "5", "\n", "doe_final", "=", "orthogonal_sampling", "(", "margs", ",", "num_sample", ",", "corr_mat", ",", "num_iter", "=", "n_iter", ")", "\n", "\n", "msg1", "=", "''", "\n", "if", "lower_bound", "is", "not", "None", ":", "\n", "        ", "for", "i_dim", "in", "range", "(", "num_dims", ")", ":", "\n", "            ", "locs", "=", "doe_final", "[", ":", ",", "i_dim", "]", "<", "lower_bound", "[", "i_dim", "]", "\n", "num_inds", "=", "np", ".", "sum", "(", "locs", ")", "\n", "if", "num_inds", ">", "0", ":", "\n", "                ", "if", "num_inds", ">", "1", ":", "\n", "                    ", "if", "not", "msg1", ":", "\n", "                        ", "msg1", "+=", "'Error in setting the lower bounds.\\n'", "\n", "", "msg1", "+=", "'Please expand the lower bound '", "+", "'for the dimension %d.\\n'", "%", "i_dim", "\n", "", "else", ":", "\n", "                    ", "doe_final", "[", "locs", ",", "i_dim", "]", "=", "lower_bound", "[", "i_dim", "]", "\n", "", "", "", "", "msg2", "=", "''", "\n", "if", "upper_bound", "is", "not", "None", ":", "\n", "        ", "for", "i_dim", "in", "range", "(", "num_dims", ")", ":", "\n", "            ", "locs", "=", "doe_final", "[", ":", ",", "i_dim", "]", ">", "upper_bound", "[", "i_dim", "]", "\n", "num_inds", "=", "np", ".", "sum", "(", "locs", ")", "\n", "if", "num_inds", ">", "0", ":", "\n", "                ", "if", "num_inds", ">", "1", ":", "\n", "                    ", "if", "not", "msg2", ":", "\n", "                        ", "msg2", "+=", "'Error in setting the upper bounds.\\n'", "\n", "", "msg2", "+=", "'Please expand the lower bound '", "+", "'for the dimension %d.\\n'", "%", "i_dim", "\n", "", "else", ":", "\n", "                    ", "doe_final", "[", "locs", ",", "i_dim", "]", "=", "upper_bound", "[", "i_dim", "]", "\n", "", "", "", "", "err_msg", "=", "msg1", "+", "msg2", "\n", "if", "err_msg", ":", "\n", "        ", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "doe_final", "=", "optimize_doe", "(", "doe_final", ",", "corr_mat", ",", "num_tries", "=", "num_tries", ",", "verbose", "=", "verbose", ")", "\n", "return", "doe_final", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.find_empty_bins": [[509, 541], ["len", "numpy.logical_and", "numpy.ones", "range", "numpy.array().ravel", "numpy.array().ravel", "numpy.arange", "numpy.logical_and", "numpy.logical_not", "doe[].reshape", "np.logical_and.any", "numpy.array", "numpy.array"], "function", ["None"], ["", "def", "find_empty_bins", "(", "doe", ",", "n_bins", ",", "lower_bound", ",", "upper_bound", ")", ":", "\n", "    ", "\"\"\"\n    Find empty bins in an LHS\n    Parameters\n    ----------\n    doe : np.ndarray\n        Array containing samples with shape=(n_samples, n_dim)\n    n_bins : in\n        The number of bins in the LHS\n    lower_bound : np.ndarray\n        Lower bounds. Shape = (n_dim,)\n\n    upper_bound : np.ndarray\n        Upper bounds. Shape = (n_dim,)\n\n    Returns\n    -------\n    empty_bins : np.ndarray\n        Boolean mask of empty bins with shape=(n_bins, n_dims)\n    \"\"\"", "\n", "n_dims", "=", "len", "(", "lower_bound", ")", "\n", "lb", ",", "ub", "=", "np", ".", "array", "(", "lower_bound", ")", ".", "ravel", "(", ")", ",", "np", ".", "array", "(", "upper_bound", ")", ".", "ravel", "(", ")", "\n", "active_mask", "=", "np", ".", "logical_and", "(", "(", "doe", ">=", "lb", ")", ".", "all", "(", "1", ")", ",", "(", "doe", "<=", "ub", ")", ".", "all", "(", "1", ")", ")", "\n", "empty_bins", "=", "np", ".", "ones", "(", "(", "n_bins", ",", "n_dims", ")", ",", "dtype", "=", "bool", ")", "\n", "probs", "=", "(", "doe", "[", "active_mask", "]", ".", "reshape", "(", "(", "-", "1", ",", "n_dims", ")", ")", "-", "lb", ")", "/", "(", "ub", "-", "lb", ")", "\n", "# probs = np.sort(probs, axis=0)", "\n", "edges", "=", "np", ".", "arange", "(", "n_bins", "+", "1", ")", "/", "n_bins", "\n", "for", "i_bin", "in", "range", "(", "n_bins", ")", ":", "\n", "        ", "condition", "=", "np", ".", "logical_and", "(", "probs", ">=", "edges", "[", "i_bin", "]", ",", "\n", "probs", "<=", "edges", "[", "i_bin", "+", "1", "]", ")", "\n", "empty_bins", "[", "i_bin", ",", ":", "]", "=", "np", ".", "logical_not", "(", "condition", ".", "any", "(", "0", ")", ")", "\n", "", "return", "empty_bins", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division.scaled_standard_normal": [[24, 27], ["scipy.stats.norm.rvs", "numpy.linalg.norm().reshape", "numpy.linalg.norm"], "function", ["None"], ["def", "scaled_standard_normal", "(", "n_dim", ",", "n_dir", ")", ":", "\n", "    ", "P", "=", "norm", ".", "rvs", "(", "size", "=", "(", "n_dir", ",", "n_dim", ")", ")", "\n", "return", "P", "/", "np", ".", "linalg", ".", "norm", "(", "P", ",", "axis", "=", "1", ")", ".", "reshape", "(", "(", "P", ".", "shape", "[", "0", "]", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division._skip_diag_strided": [[29, 34], ["strided().reshape", "strided", "A.ravel"], "function", ["None"], ["", "def", "_skip_diag_strided", "(", "A", ")", ":", "\n", "    ", "m", "=", "A", ".", "shape", "[", "0", "]", "\n", "strided", "=", "np", ".", "lib", ".", "stride_tricks", ".", "as_strided", "\n", "s0", ",", "s1", "=", "A", ".", "strides", "\n", "return", "strided", "(", "A", ".", "ravel", "(", ")", "[", "1", ":", "]", ",", "shape", "=", "(", "m", "-", "1", ",", "m", ")", ",", "strides", "=", "(", "s0", "+", "s1", ",", "s1", ")", ")", ".", "reshape", "(", "m", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division._heuristic_fekete": [[36, 98], ["hyperspace_division.scaled_standard_normal", "numpy.min", "print", "range", "print", "scipy.spatial.distance.pdist", "scipy.spatial.distance.pdist", "scipy.spatial.distance.squareform", "numpy.arange", "numpy.linalg.norm", "tmp_points.copy", "scipy.spatial.distance.squareform.sum", "numpy.min", "print", "abs", "print", "numpy.linalg.norm", "scipy.spatial.distance.pdist", "abs"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division.scaled_standard_normal"], ["", "def", "_heuristic_fekete", "(", "n_dim", ",", "n_dir", ",", "max_iterations", "=", "100", ",", "tolerance", "=", "1e-18", ")", ":", "\n", "    ", "\"\"\"\n    Calculates the fekete points heuristically using the\n    zero centered repulsive power\n\n    Parameters\n    ----------\n    n_dim : int \n        number of dimensions\n    n_dir : int\n        number of directions\n    max_iterations : int\n        maximum iterations for fekete points optimization\n    tolerance : float\n        tolerance for fekete points optimization\n\n    Returns\n    -------\n    Fekete points:  np.ndarray with each row corresponding to\n                    a point coordinate on unit sphere\n\n    \"\"\"", "\n", "alpha", ",", "alpha_cur", "=", "2.", ",", "1.", "\n", "alpha_tol", "=", "1e-12", "\n", "# base_points = adv_hs_div(n_dim, n_dir, golden=True)", "\n", "base_points", "=", "scaled_standard_normal", "(", "n_dim", ",", "n_dir", ")", "\n", "dist_min", "=", "np", ".", "min", "(", "pdist", "(", "base_points", ")", ")", "\n", "print", "(", "\"start\"", ",", "dist_min", ")", "\n", "for", "i_iter", "in", "range", "(", "max_iterations", ")", ":", "\n", "        ", "forces", "=", "pdist", "(", "base_points", ",", "\"cosine\"", ")", "\n", "forces", "[", "forces", "<", "5e-8", "]", "=", "5e-8", "\n", "forces", "=", "squareform", "(", "forces", "**", "(", "-", "i_iter", "/", "2", "-", "1", ")", ")", "\n", "forces", "=", "base_points", "[", ":", ",", "np", ".", "newaxis", ",", ":", "]", "*", "(", "forces", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "inds", "=", "np", ".", "arange", "(", "n_dir", ")", "\n", "forces", "=", "forces", ".", "sum", "(", "0", ")", "-", "forces", "[", "inds", ",", "inds", ",", ":", "]", "\n", "# subtraction removes the diagonals from the distance matrix", "\n", "# which would have infinite magnitude", "\n", "amps", "=", "np", ".", "linalg", ".", "norm", "(", "forces", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "amps", "[", "amps", "<", "5e-8", "]", "=", "5e-8", "\n", "forces", "=", "forces", "/", "amps", "\n", "dist_min_tmp", "=", "0", "\n", "alpha_cur", "=", "alpha", "*", "alpha_cur", "\n", "# above is reasonable since generally step size", "\n", "# should be decreasing  but we look for a better starting from", "\n", "# slightly larger value as the last one", "\n", "while", "dist_min_tmp", "<=", "dist_min", "and", "alpha_cur", ">", "alpha_tol", ":", "\n", "            ", "tmp_points", "=", "(", "1", "+", "alpha_cur", ")", "*", "base_points", "-", "alpha_cur", "*", "forces", "\n", "tmp_points", "=", "tmp_points", "/", "np", ".", "linalg", ".", "norm", "(", "tmp_points", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "dist_min_tmp", "=", "np", ".", "min", "(", "pdist", "(", "tmp_points", ")", ")", "\n", "alpha_cur", "=", "alpha_cur", "*", ".9", "\n", "\n", "", "if", "dist_min_tmp", "<", "dist_min", ":", "\n", "            ", "print", "(", "'No more improvement could be achieved with Fekete points after'", ",", "i_iter", ",", "\"iterations.\"", ")", "\n", "break", "\n", "\n", "", "base_points", "=", "tmp_points", ".", "copy", "(", ")", "\n", "if", "abs", "(", "dist_min_tmp", "-", "dist_min", ")", "<", "tolerance", ":", "\n", "            ", "print", "(", "'Fekete points converged.'", ",", "f\" Change in min. dist: {abs(dist_min_tmp - dist_min)}\"", ")", "\n", "break", "\n", "", "dist_min", "=", "dist_min_tmp", "\n", "", "print", "(", "\"final\"", ",", "dist_min_tmp", ")", "\n", "return", "base_points", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division.comb": [[100, 102], ["numpy.math.factorial", "numpy.math.factorial", "numpy.math.factorial"], "function", ["None"], ["", "def", "comb", "(", "N", ",", "k", ")", ":", "\n", "    ", "return", "np", ".", "math", ".", "factorial", "(", "N", ")", "/", "(", "np", ".", "math", ".", "factorial", "(", "N", "-", "k", ")", "*", "np", ".", "math", ".", "factorial", "(", "k", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division.fekete_points": [[104, 133], ["functools.lru_cache", "range", "numpy.array", "numpy.linspace", "hyperspace_division._heuristic_fekete", "numpy.min", "scipy.spatial.distance.pdist", "_heuristic_fekete.copy", "numpy.cos", "numpy.sin"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.hyperspace_division._heuristic_fekete"], ["", "@", "functools", ".", "lru_cache", "(", "maxsize", "=", "1", ")", "\n", "def", "fekete_points", "(", "n_dim", ",", "n_dir", ",", "max_iters", "=", "500", ",", "tolerance", "=", "1e-18", ",", "n_try", "=", "3", ")", ":", "\n", "    ", "\"\"\"\n    Parameters\n    ----------\n    n_dim  :  number of dimensions\n    n_dir  :  number of directions\n    max_iters  :  maximum iterations for fekete points optimization\n    tolerance  :  tolerance for fekete points optimization\n\n    Returns\n    -------\n    x - 2 -d numpy array\n        Fekete points with each row corresponding to\n        a point coordinate on unit sphere\n    \"\"\"", "\n", "if", "n_dim", "==", "1", ":", "\n", "        ", "return", "np", ".", "array", "(", "[", "-", "1", ",", "1", "]", ")", "\n", "", "if", "n_dim", "==", "2", ":", "\n", "        ", "phi", "=", "np", ".", "linspace", "(", "0", ",", "2", "*", "np", ".", "pi", ",", "n_dir", ")", "\n", "return", "np", ".", "c_", "[", "np", ".", "cos", "(", "phi", ")", ",", "np", ".", "sin", "(", "phi", ")", "]", "\n", "", "best_dist", ",", "best_dirs", "=", "0", ",", "None", "\n", "for", "_", "in", "range", "(", "n_try", ")", ":", "\n", "        ", "cur_dir", "=", "_heuristic_fekete", "(", "n_dim", ",", "n_dir", ",", "max_iters", ",", "tolerance", ")", "\n", "cur_dist", "=", "np", ".", "min", "(", "pdist", "(", "cur_dir", ")", ")", "\n", "if", "cur_dist", ">", "best_dist", ":", "\n", "            ", "best_dist", "=", "cur_dist", "\n", "best_dirs", "=", "cur_dir", ".", "copy", "(", ")", "\n", "", "", "return", "best_dirs", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.get_margs.sp_margs": [[15, 92], ["NotImplementedError", "scipy.stats.expon", "dist.name.lower", "scipy.stats.gumbel_r", "numpy.sqrt", "numpy.log", "scipy.stats.lognorm", "scipy.stats.norm", "dist.name.lower", "scipy.stats.uniform", "dist.name.lower", "scipy.stats.triang", "scipy.stats.truncnorm", "dist.name.lower", "ValueError", "dist.name.lower", "dist.name.lower", "dist.name.lower", "dist.name.lower", "numpy.log", "numpy.exp", "dist.name.lower", "dist.name.lower", "numpy.sqrt", "numpy.sqrt", "dist.name.lower", "dist.name.lower", "scipy.stats.bernoulli", "numpy.isfinite", "scipy.stats.bernoulli", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["def", "sp_margs", "(", "dist", ")", ":", "\n", "    ", "\"\"\"\n    Creates a list of scipy distribution objects from a list\n    of strings, corresponding to the distribution names in\n    scipy, vector of Means and vector of Standard Deviations.\n\n    Inputs\n    ------\n    distribution:\n        a Distribution object as defined in pyRDO.uncertainy.model\n\n    Returns\n    -------\n    oMargs:list\n        List of scipy frozen_distribution\n    \"\"\"", "\n", "\n", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'exponential'", "or", "dist", ".", "name", ".", "lower", "(", ")", "==", "'expon'", ":", "\n", "        ", "return", "stats", ".", "expon", "(", "dist", ".", "mean", "-", "dist", ".", "std", ",", "dist", ".", "std", ")", "\n", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'gumbel'", ":", "\n", "        ", "scale", "=", "dist", ".", "std", "*", "np", ".", "sqrt", "(", "6", ")", "/", "np", ".", "pi", "\n", "loc", "=", "dist", ".", "mean", "-", "scale", "*", "np", ".", "euler_gamma", "\n", "return", "stats", ".", "gumbel_r", "(", "loc", ",", "scale", ")", "\n", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'lognormal'", "or", "dist", ".", "name", ".", "lower", "(", ")", "==", "'lognorm'", ":", "\n", "        ", "sigma", "=", "np", ".", "sqrt", "(", "np", ".", "log", "(", "(", "dist", ".", "std", "/", "dist", ".", "mean", ")", "**", "2", "+", "1", ")", ")", "\n", "logmean", "=", "np", ".", "log", "(", "dist", ".", "mean", "/", "np", ".", "sqrt", "(", "(", "dist", ".", "std", "/", "dist", ".", "mean", ")", "**", "2", "+", "1", ")", ")", "\n", "return", "stats", ".", "lognorm", "(", "sigma", ",", "0", ",", "np", ".", "exp", "(", "logmean", ")", ")", "\n", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'normal'", "or", "dist", ".", "name", ".", "lower", "(", ")", "==", "'norm'", ":", "\n", "        ", "return", "stats", ".", "norm", "(", "dist", ".", "mean", ",", "dist", ".", "std", ")", "\n", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'uniform'", ":", "\n", "        ", "args", "=", "(", "dist", ".", "lower_bound", ",", "dist", ".", "upper_bound", "-", "dist", ".", "lower_bound", ")", "\n", "return", "stats", ".", "uniform", "(", "*", "args", ")", "\n", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'triangular'", ":", "\n", "        ", "if", "not", "dist", ".", "params", ":", "\n", "            ", "consta", "=", "0.5", "\n", "scale", "=", "np", ".", "sqrt", "(", "18", "*", "(", "dist", ".", "std", "**", "2", ")", "/", "(", "consta", "**", "2", "-", "consta", "+", "1", ")", ")", "\n", "loc", "=", "dist", ".", "mean", "-", "(", "consta", "+", "1", ")", "*", "scale", "/", "3", "\n", "", "else", ":", "\n", "            ", "mean_tmp", "=", "dist", ".", "mean", "\n", "mid_point", "=", "dist", ".", "params", "[", "0", "]", "\n", "aux_var", "=", "(", "-", "18", "*", "(", "dist", ".", "std", "**", "2", ")", "+", "mid_point", "*", "(", "2", "*", "mid_point", "-", "3", "*", "mean_tmp", ")", ")", "\n", "aux_var", "=", "(", "9", "*", "(", "mean_tmp", "**", "2", ")", "-", "6", "*", "mid_point", "*", "mean_tmp", "+", "\n", "(", "mid_point", "**", "2", ")", "+", "aux_var", ")", "/", "3", "\n", "aux_var", "=", "np", ".", "sqrt", "(", "(", "9", "*", "mean_tmp", "**", "2", "-", "6", "*", "mid_point", "*", "mean_tmp", "\n", "+", "mid_point", "**", "2", ")", "/", "4", "-", "aux_var", ")", "\n", "loc", "=", "(", "3", "*", "mean_tmp", "-", "mid_point", ")", "/", "2", "+", "aux_var", "\n", "scale", "=", "3", "*", "mean_tmp", "-", "2", "*", "loc", "-", "mid_point", "\n", "if", "scale", "<", "0", ":", "\n", "                ", "loc", "=", "(", "3", "*", "mean_tmp", "-", "mid_point", ")", "/", "2", "-", "aux_var", "\n", "scale", "=", "3", "*", "mean_tmp", "-", "2", "*", "loc", "-", "mid_point", "\n", "", "consta", "=", "(", "mid_point", "-", "loc", ")", "/", "scale", "\n", "", "return", "stats", ".", "triang", "(", "consta", ",", "loc", ",", "scale", ")", "\n", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'truncnormal'", "or", "dist", ".", "name", ".", "lower", "(", ")", "==", "'truncnorm'", ":", "\n", "        ", "a", "=", "(", "dist", ".", "lower_bound", "-", "dist", ".", "mean", ")", "/", "dist", ".", "std", "\n", "b", "=", "(", "dist", ".", "upper_bound", "-", "dist", ".", "mean", ")", "/", "dist", ".", "std", "\n", "args", "=", "(", "a", ",", "b", ",", "dist", ".", "mean", ",", "dist", ".", "std", ")", "\n", "return", "stats", ".", "truncnorm", "(", "*", "args", ")", "\n", "", "if", "dist", ".", "name", ".", "lower", "(", ")", "==", "'bernoulli'", ":", "\n", "        ", "if", "not", "dist", ".", "params", ":", "\n", "            ", "return", "stats", ".", "bernoulli", "(", "0.5", ")", "\n", "", "cond", "=", "np", ".", "isfinite", "(", "dist", ".", "params", "[", "0", "]", ")", "and", "dist", ".", "params", "[", "0", "]", ">", "0", "\n", "if", "cond", "and", "dist", ".", "params", "[", "0", "]", "<", "1", ":", "\n", "            ", "return", "stats", ".", "bernoulli", "(", "dist", ".", "params", "[", "0", "]", ")", "\n", "", "raise", "ValueError", "(", "\"Distribution parameters are invalid for Bernoulli.\"", ")", "\n", "\n", "#######################################", "\n", "#           FRECHET AND WEIBULL missing among others", "\n", "#########################################", "\n", "", "msg", "=", "'%s distribution is not supported yet.'", "%", "dist", ".", "name", "\n", "#        warnings.warn(sWarnMsg)", "\n", "raise", "NotImplementedError", "(", "msg", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.__init__": [[96, 118], ["len", "copula.NatafTransformation._corr_trans_nataf", "ValueError", "numpy.eye", "ValueError"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation._corr_trans_nataf"], ["def", "__init__", "(", "self", ",", "margs", ",", "rho_x", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Initialise Model and solve Nataf Copula\n        \"\"\"", "\n", "self", ".", "margs", "=", "margs", "\n", "self", ".", "n_var", "=", "len", "(", "self", ".", "margs", ")", "\n", "\n", "if", "self", ".", "n_var", "<", "2", ":", "\n", "            ", "err_msg", "=", "'If there is only one variable,'", "\n", "err_msg", "+=", "'use inverse transform sampling.'", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "rho_x", "is", "None", ":", "\n", "            ", "rho_x", "=", "np", ".", "eye", "(", "self", ".", "n_var", ")", "\n", "", "else", ":", "\n", "            ", "if", "rho_x", ".", "shape", "[", "0", "]", "==", "self", ".", "n_var", ":", "\n", "                ", "rho_x", "=", "rho_x", "\n", "", "else", ":", "\n", "                ", "err_msg", "=", "'Correlation matrix does not have the expected '", "\n", "err_msg", "+=", "'dimensions %i x %i .'", "%", "(", "self", ".", "n_var", ",", "self", ".", "n_var", ")", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "", "self", ".", "_corr_trans_nataf", "(", "rho_x", ",", "order", "=", "11", ",", "rho_tol", "=", "1e-6", ",", "\n", "max_iters", "=", "30", ",", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.x2u": [[119, 140], ["copula._force2d", "range", "std_norm_var.append", "numpy.asarray", "scipy.stats.norm.ppf", "copula.NatafTransformation.margs[].cdf"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula._force2d"], ["", "def", "x2u", "(", "self", ",", "orig_var", ")", ":", "\n", "        ", "\"\"\"\n        Converts arbitrarily distributed variable x\n        to standardnormal variable u.\n\n        Parameters\n        ----------\n        orig_var - Variable with the arbitrary initial marginal\n                   distribution (margs), numpy array\n                   [n_samples x n_vars]\n        Returns\n        -------\n        std_norm_var - Standardnormal variable, numpy\n                       array [n_samples x n_vars]\n        \"\"\"", "\n", "orig_var", "=", "_force2d", "(", "orig_var", ")", "\n", "std_norm_var", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_var", ")", ":", "\n", "            ", "std_norm_var", ".", "append", "(", "stats", ".", "norm", ".", "ppf", "(", "self", ".", "margs", "[", "i", "]", ".", "cdf", "(", "orig_var", "[", ":", ",", "\n", "i", "]", ")", ")", ")", "\n", "", "return", "np", ".", "asarray", "(", "std_norm_var", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.u2x": [[141, 162], ["copula._force2d", "range", "orig_var.append", "numpy.asarray", "copula.NatafTransformation.margs[].ppf", "scipy.stats.norm.cdf"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula._force2d"], ["", "def", "u2x", "(", "self", ",", "std_norm_var", ")", ":", "\n", "        ", "\"\"\"\n        Converts standardnormal variable u\n        to arbitrarily distributed variable x.\n\n        Parameters\n        ----------\n        std_norm_var - Standardnormal variable, numpy\n                       array [n_samples x n_vars]\n        Returns\n        -------\n        orig_var - Variable with the initial marginal\n                   distribution (Margs), numpy array\n                   [n_samples x n_vars]\n        \"\"\"", "\n", "std_norm_var", "=", "_force2d", "(", "std_norm_var", ")", "\n", "orig_var", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "n_var", ")", ":", "\n", "            ", "orig_var", ".", "append", "(", "self", ".", "margs", "[", "i", "]", ".", "ppf", "(", "stats", ".", "norm", ".", "cdf", "(", "std_norm_var", "[", ":", ",", "\n", "i", "]", ")", ")", ")", "\n", "", "return", "np", ".", "asarray", "(", "orig_var", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.x2zunc": [[163, 180], ["numpy.dot", "copula.NatafTransformation.x2u"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.x2u"], ["", "def", "x2zunc", "(", "self", ",", "orig_var", ")", ":", "\n", "        ", "\"\"\"\n        Converts correlated and arbitrarily\n        distributed variable x to independent\n        standardnormal variable zunc\n\n        Parameters\n        ----------\n        orig_var - Correlated variable with the initial\n                   marginal distribution (Margs), numpy\n                   array  [n_samples x n_vars]\n        Returns\n        -------\n        ind_std_norm_var - independent standardnormal variable,\n                           numpy array [n_samples x n_vars]\n        \"\"\"", "\n", "return", "np", ".", "dot", "(", "self", ".", "x2u", "(", "orig_var", ")", ",", "self", ".", "inv_corr_transform", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.zunc2x": [[181, 198], ["copula.NatafTransformation.u2x", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation.u2x"], ["", "def", "zunc2x", "(", "self", ",", "ind_std_norm_var", ")", ":", "\n", "        ", "\"\"\"\n        Converts independent standard normal\n        variable zunc to correlated and\n        arbitrarily distributed variable x.\n\n        Parameters\n        ----------\n        ind_std_norm_var - independent standardnormal\n                           variable, numpy array [n_samples x n_vars]\n        Returns\n        -------\n        orig_var - Variable with the initial marginal\n                   distribution (Margs) and Correlation\n            (rho_x), numpy array [n_samples x n_vars]\n        \"\"\"", "\n", "return", "self", ".", "u2x", "(", "np", ".", "dot", "(", "ind_std_norm_var", ",", "self", ".", "corr_transform", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula.NatafTransformation._corr_trans_nataf": [[199, 291], ["numpy.polynomial.hermite.hermgauss", "numpy.meshgrid", "numpy.dot", "scipy.stats.norm", "numpy.eye", "range", "ValueError", "numpy.transpose", "range", "scipy.linalg.cholesky", "numpy.linalg.inv", "str", "numpy.sqrt", "numpy.sqrt", "numpy.tril", "scipy.linalg.eigh", "numpy.linalg.pinv", "print", "print", "numpy.dot", "print", "print", "copula.NatafTransformation.margs[].std", "numpy.sqrt", "copula.NatafTransformation.margs[].ppf", "copula.NatafTransformation.margs[].ppf", "numpy.abs", "numpy.abs", "warnings.warn", "numpy.diag", "numpy.abs", "numpy.abs", "copula.NatafTransformation.margs[].std", "scipy.stats.norm.cdf", "scipy.stats.norm.cdf", "copula.NatafTransformation.margs[].mean", "copula.NatafTransformation.margs[].mean", "numpy.sum", "scipy.stats.norm.pdf", "copula.NatafTransformation.margs[].pdf", "numpy.sum", "numpy.abs", "str", "numpy.sqrt", "str", "numpy.sign"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean"], ["", "def", "_corr_trans_nataf", "(", "self", ",", "rho_x_orig", ",", "order", "=", "11", ",", "rho_tol", "=", "1e-6", ",", "\n", "max_iters", "=", "30", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        Calculates the modified correlation matrix\n        with Nataf Assumption.\n\n        sets the attributes corr_transform and inv_corr_transform and rho_u\n        \"\"\"", "\n", "# sanity checks", "\n", "if", "order", "<=", "1", ":", "\n", "            ", "err_msg", "=", "'The specified integration order '", "+", "str", "(", "order", ")", "\n", "err_msg", "+=", "'must be larer than 1!'", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "rho_x_tol", "=", "rho_z_tol", "=", "rho_tol", "# Doesn't have to be like this", "\n", "herm_coords", ",", "herm_weights", "=", "np", ".", "polynomial", ".", "hermite", ".", "hermgauss", "(", "order", ")", "\n", "u1_coords", ",", "u2_coords", "=", "np", ".", "meshgrid", "(", "herm_coords", ",", "herm_coords", ")", "\n", "u1_coords", ",", "u2_coords", "=", "np", ".", "sqrt", "(", "2", ")", "*", "u1_coords", ",", "np", ".", "sqrt", "(", "2", ")", "*", "u2_coords", "\n", "weights", "=", "np", ".", "dot", "(", "np", ".", "transpose", "(", "[", "herm_weights", "]", ")", ",", "[", "herm_weights", "]", ")", "\n", "std_norm", "=", "stats", ".", "norm", "(", "0.", ",", "1.", ")", "\n", "z_mod_rho", "=", "np", ".", "eye", "(", "self", ".", "n_var", ")", "\n", "for", "row_no", "in", "range", "(", "self", ".", "n_var", ")", ":", "\n", "            ", "for", "col_no", "in", "range", "(", "row_no", ")", ":", "\n", "                ", "rho_x", "=", "rho_x_orig", "[", "row_no", ",", "col_no", "]", "\n", "rho_z", "=", "rho_x", "\n", "if", "(", "np", ".", "abs", "(", "rho_x", ")", ">", "0.05", "and", "np", ".", "abs", "(", "rho_x", ")", "<", "0.99", ")", "and", "not", "(", "self", ".", "margs", "[", "row_no", "]", ".", "dist", ".", "name", "==", "'norm'", "and", "self", ".", "margs", "[", "col_no", "]", ".", "dist", ".", "name", "==", "'norm'", ")", ":", "\n", "                    ", "iter_counter", "=", "0", "\n", "rho_x_acc", "=", "np", ".", "inf", "\n", "rho_z_acc", "=", "np", ".", "inf", "\n", "denom", "=", "np", ".", "pi", "*", "self", ".", "margs", "[", "row_no", "]", ".", "std", "(", ")", "*", "self", ".", "margs", "[", "col_no", "]", ".", "std", "(", ")", "\n", "while", "iter_counter", "<=", "max_iters", "and", "(", "rho_x_acc", ">", "rho_x_tol", "or", "rho_z_acc", ">", "rho_z_tol", ")", ":", "\n", "                        ", "rho_z_sqr", "=", "np", ".", "sqrt", "(", "1.0", "-", "rho_z", "*", "rho_z", ")", "\n", "z1_coords", "=", "u1_coords", "\n", "z2_coords", "=", "rho_z", "*", "u1_coords", "+", "rho_z_sqr", "*", "u2_coords", "\n", "\n", "# Transform into the initial distribution space", "\n", "x1_coords", "=", "self", ".", "margs", "[", "row_no", "]", ".", "ppf", "(", "std_norm", ".", "cdf", "(", "z1_coords", ")", ")", "\n", "x2_coords", "=", "self", ".", "margs", "[", "col_no", "]", ".", "ppf", "(", "std_norm", ".", "cdf", "(", "z2_coords", ")", ")", "\n", "x1_stds", "=", "(", "x1_coords", "-", "self", ".", "margs", "[", "row_no", "]", ".", "mean", "(", ")", ")", "\n", "x2_stds", "=", "(", "x2_coords", "-", "self", ".", "margs", "[", "col_no", "]", ".", "mean", "(", ")", ")", "\n", "\n", "# Calculate the result of the integral as in C-Script", "\n", "rho_x_new", "=", "np", ".", "sum", "(", "x1_stds", "*", "x2_stds", "*", "weights", ")", "/", "denom", "\n", "\n", "# Calculate derivative", "\n", "d_rho_x", "=", "(", "u1_coords", "-", "rho_z", "*", "u2_coords", "/", "rho_z_sqr", ")", "\n", "d_rho_x", "*=", "std_norm", ".", "pdf", "(", "z2_coords", ")", "/", "self", ".", "margs", "[", "col_no", "]", ".", "pdf", "(", "x2_coords", ")", "\n", "d_rho_x", "=", "np", ".", "sum", "(", "d_rho_x", "*", "weights", "*", "x1_stds", ")", "/", "denom", "\n", "\n", "# Evaluate the new dZZCorr while making sure that", "\n", "# is stays between [-1,+1]", "\n", "rho_z_old", "=", "rho_z", "\n", "rho_z", "=", "rho_z_old", "+", "(", "rho_x", "-", "rho_x_new", ")", "/", "d_rho_x", "\n", "if", "np", ".", "abs", "(", "rho_z", ")", ">", "1.0", ":", "\n", "                            ", "rho_z", "=", "0.5", "*", "(", "rho_z_old", "+", "np", ".", "sign", "(", "rho_z", ")", ")", "\n", "\n", "# Calculate the accuracies", "\n", "", "rho_x_acc", "=", "np", ".", "abs", "(", "rho_x", "-", "rho_x_new", ")", "\n", "rho_z_acc", "=", "np", ".", "abs", "(", "rho_z", "-", "rho_z_old", ")", "\n", "iter_counter", "+=", "1", "\n", "\n", "# Should this be an Error or a Warning?", "\n", "", "if", "rho_x_acc", ">", "rho_x_tol", "or", "rho_z_acc", ">", "rho_z_tol", ":", "\n", "                        ", "err_msg", "=", "'Optimization not converged for'", "\n", "err_msg", "+=", "'variables'", "+", "str", "(", "row_no", ")", "+", "'and'", "\n", "err_msg", "+=", "str", "(", "col_no", ")", "+", "'.'", "\n", "warnings", ".", "warn", "(", "err_msg", ")", "\n", "", "", "z_mod_rho", "[", "row_no", ",", "col_no", "]", "=", "rho_z", "\n", "", "", "self", ".", "rho_u", "=", "z_mod_rho", "+", "np", ".", "tril", "(", "z_mod_rho", ",", "-", "1", ")", ".", "T", "# pylint: disable=no-member", "\n", "try", ":", "\n", "            ", "self", ".", "corr_transform", "=", "cholesky", "(", "self", ".", "rho_u", ",", "lower", "=", "False", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'Cholesky factorization failed.'", ")", "\n", "print", "(", "'Continuing with PCA.'", ")", "\n", "", "w_z", ",", "v_z", "=", "eigh", "(", "self", ".", "rho_u", ")", "\n", "self", ".", "corr_transform", "=", "np", ".", "dot", "(", "v_z", ",", "np", ".", "diag", "(", "np", ".", "sqrt", "(", "w_z", ")", ")", ")", ".", "T", "\n", "\n", "", "try", ":", "\n", "            ", "self", ".", "inv_corr_transform", "=", "np", ".", "linalg", ".", "inv", "(", "self", ".", "corr_transform", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'linalg.inv failed.'", ")", "\n", "print", "(", "'Continuing with linalg.pinv.'", ")", "\n", "", "self", ".", "inv_corr_transform", "=", "np", ".", "linalg", ".", "pinv", "(", "self", ".", "corr_transform", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.copula._force2d": [[17, 22], ["numpy.array", "np.array.reshape"], "function", ["None"], ["def", "_force2d", "(", "arr_like", ")", ":", "\n", "    ", "arr_like", "=", "np", ".", "array", "(", "arr_like", ")", "\n", "if", "arr_like", ".", "ndim", "==", "1", ":", "\n", "        ", "return", "arr_like", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "return", "arr_like", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.__init__": [[79, 123], ["name.lower", "model.UniVar._get_moments", "ValueError", "numpy.sqrt", "isinstance", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar._get_moments"], ["def", "__init__", "(", "self", ",", "name", ":", "str", "=", "\"norm\"", ",", "mean", ":", "float", "=", "0.0", ",", "std", ":", "float", "=", "1.0", ",", "\n", "lower_bound", ":", "float", "=", "None", ",", "upper_bound", ":", "float", "=", "None", ",", "\n", "CoV", ":", "typing", ".", "Union", "[", "bool", ",", "float", "]", "=", "False", ",", "params", ":", "tuple", "=", "(", ")", ",", "move_bounds", "=", "True", ",", "\n", ")", ":", "\n", "        ", "self", ".", "move_bounds", "=", "move_bounds", "\n", "self", ".", "name", "=", "name", ".", "lower", "(", ")", "\n", "self", ".", "_mu", "=", "mean", "\n", "\n", "if", "std", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Standard deviation std must be strictly positive, got {std}\"", ")", "\n", "", "self", ".", "_std", "=", "std", "\n", "if", "self", ".", "name", "==", "\"uniform\"", "and", "None", "not", "in", "[", "lower_bound", ",", "upper_bound", "]", ":", "\n", "            ", "self", ".", "_mu", "=", "(", "lower_bound", "+", "upper_bound", ")", "/", "2", "\n", "self", ".", "_std", "=", "np", ".", "sqrt", "(", "(", "upper_bound", "-", "lower_bound", ")", "**", "2", "/", "12", ")", "\n", "", "self", ".", "_var_coef", "=", "None", "\n", "if", "CoV", ":", "\n", "            ", "self", ".", "var_coef", "=", "self", ".", "_std", "/", "self", ".", "_mu", "\n", "if", "isinstance", "(", "CoV", ",", "(", "int", ",", "float", ")", ")", ":", "\n", "                ", "self", ".", "var_coef", "=", "CoV", "\n", "", "if", "self", ".", "_std", "<", "0", ":", "\n", "                ", "self", ".", "var_coef", "=", "-", "CoV", "\n", "\n", "", "", "if", "self", ".", "name", "==", "\"uniform\"", ":", "\n", "            ", "if", "lower_bound", "is", "None", ":", "\n", "# compute it from the mean and std_dev", "\n", "# sigma = ub - lb / sqrt(12), mu = (ub + lb) / 2", "\n", "# => lb = 2mu - ub => sigma = (ub - mu) / np.sqrt(3)", "\n", "# => lb, ub = mu +- np.sqrt(3) sigma", "\n", "                ", "lower_bound", "=", "mean", "-", "np", ".", "sqrt", "(", "3", ")", "*", "self", ".", "_std", "\n", "", "if", "upper_bound", "is", "None", ":", "\n", "                ", "upper_bound", "=", "mean", "+", "np", ".", "sqrt", "(", "3", ")", "*", "self", ".", "_std", "\n", "", "self", ".", "_mu", "=", "(", "lower_bound", "+", "upper_bound", ")", "/", "2", "\n", "self", ".", "_std", "=", "np", ".", "sqrt", "(", "(", "upper_bound", "-", "lower_bound", ")", "**", "2", "/", "12", ")", "\n", "\n", "# self.lower_bound, self.upper_bound = None, None", "\n", "", "if", "lower_bound", "is", "None", ":", "\n", "            ", "lower_bound", "=", "self", ".", "_mu", "-", "1e9", "*", "self", ".", "_std", "\n", "", "if", "upper_bound", "is", "None", ":", "\n", "            ", "upper_bound", "=", "self", ".", "_mu", "+", "1e9", "*", "self", ".", "_std", "\n", "", "self", ".", "lower_bound", "=", "lower_bound", "\n", "self", ".", "upper_bound", "=", "upper_bound", "\n", "self", ".", "params", "=", "params", "\n", "# to get the resulting ones", "\n", "self", ".", "_get_moments", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.var_coef": [[128, 135], ["None"], "methods", ["None"], ["", "@", "var_coef", ".", "setter", "\n", "def", "var_coef", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "value", "is", "None", ":", "\n", "            ", "self", ".", "_var_coef", "=", "None", "\n", "return", "\n", "", "self", ".", "_var_coef", "=", "value", "\n", "self", ".", "_std", "=", "self", ".", "_mu", "*", "self", ".", "var_coef", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.marg": [[136, 140], ["get_margs.sp_margs"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.get_margs.sp_margs"], ["", "@", "property", "\n", "def", "marg", "(", "self", ")", ":", "\n", "        ", "\"\"\"get a list of scipy.stats distributions\"\"\"", "\n", "return", "sp_margs", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar._get_moments": [[141, 145], ["dis.mean", "dis.std"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std"], ["", "def", "_get_moments", "(", "self", ")", ":", "\n", "        ", "dis", "=", "self", ".", "marg", "\n", "self", ".", "_mu", "=", "dis", ".", "mean", "(", ")", "\n", "self", ".", "_std", "=", "dis", ".", "std", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.mean": [[151, 159], ["None"], "methods", ["None"], ["", "@", "mean", ".", "setter", "\n", "def", "mean", "(", "self", ",", "mean_new", ")", ":", "\n", "        ", "\"\"\"set new mean\"\"\"", "\n", "mu_dist", "=", "mean_new", "-", "self", ".", "_mu", "\n", "self", ".", "_mu", "=", "mean_new", "\n", "if", "self", ".", "move_bounds", ":", "\n", "            ", "self", ".", "lower_bound", "+=", "mu_dist", "\n", "self", ".", "upper_bound", "+=", "mu_dist", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.std": [[165, 175], ["ValueError"], "methods", ["None"], ["", "@", "std", ".", "setter", "\n", "def", "std", "(", "self", ",", "std_new", ")", ":", "\n", "        ", "\"\"\"set new mean and new standard deviation\"\"\"", "\n", "if", "std_new", "<=", "0", ":", "\n", "            ", "raise", "ValueError", "(", "\"Standard deviation std must be strictly positive\"", ")", "\n", "", "sig_ratio", "=", "std_new", "/", "self", ".", "_std", "\n", "self", ".", "_std", "=", "std_new", "\n", "if", "self", ".", "move_bounds", ":", "\n", "            ", "self", ".", "lower_bound", "=", "(", "self", ".", "lower_bound", "-", "self", ".", "_mu", ")", "*", "sig_ratio", "+", "self", ".", "_mu", "\n", "self", ".", "upper_bound", "=", "(", "self", ".", "upper_bound", "-", "self", ".", "_mu", ")", "*", "sig_ratio", "+", "self", ".", "_mu", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.var": [[181, 185], ["numpy.sqrt"], "methods", ["None"], ["", "@", "var", ".", "setter", "\n", "def", "var", "(", "self", ",", "var_new", ")", ":", "\n", "        ", "\"\"\"get standard deviation of all variables\"\"\"", "\n", "self", ".", "std", "=", "np", ".", "sqrt", "(", "var_new", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.moments": [[191, 196], ["None"], "methods", ["None"], ["", "@", "moments", ".", "setter", "\n", "def", "moments", "(", "self", ",", "moments", ")", ":", "\n", "        ", "\"\"\"set new mean and new standard deviation\"\"\"", "\n", "self", ".", "std", "=", "moments", "[", "1", "]", "\n", "self", ".", "mean", "=", "moments", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.UniVar.__repr__": [[197, 203], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "name", "==", "\"uniform\"", ":", "\n", "            ", "msg", "=", "f\"UniVar: {self.name} - LB: {self.lower_bound:.2e}  \"", "\n", "msg", "+=", "f\"UB: {self.upper_bound:.2e}\"", "\n", "return", "msg", "\n", "", "return", "f\"UniVar: {self.name} - Mean: {self.mean:.2e}  Std. Dev: {self.std:.2e}\"", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.__init__": [[219, 223], ["model._get_corr_mat", "model.MultiVar._read_moments", "len"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model._get_corr_mat", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar._read_moments"], ["def", "__init__", "(", "self", ",", "univars", ":", "list", ",", "corr_mat", ":", "np", ".", "ndarray", "=", "None", ")", ":", "\n", "        ", "self", ".", "dists", "=", "univars", "\n", "self", ".", "rho", "=", "_get_corr_mat", "(", "corr_mat", ",", "len", "(", "self", ".", "dists", ")", ")", "\n", "self", ".", "_read_moments", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.names": [[232, 241], ["zip", "model.MultiVar._read_moments", "len", "len", "ValueError"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar._read_moments"], ["", "@", "names", ".", "setter", "\n", "def", "names", "(", "self", ",", "new_names", ")", ":", "\n", "        ", "\"\"\" Names of the distributions\"\"\"", "\n", "if", "len", "(", "new_names", ")", "!=", "len", "(", "self", ".", "dists", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of names does not match the number of distributions.\"", ")", "\n", "\n", "", "for", "name", ",", "dist", "in", "zip", "(", "new_names", ",", "self", ".", "dists", ")", ":", "\n", "            ", "dist", ".", "name", "=", "name", "\n", "", "self", ".", "_read_moments", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.__len__": [[229, 231], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar._read_moments": [[242, 245], ["numpy.array().ravel", "numpy.array().ravel", "numpy.array", "numpy.array"], "methods", ["None"], ["", "def", "_read_moments", "(", "self", ")", ":", "\n", "        ", "self", ".", "_mu", "=", "np", ".", "array", "(", "[", "d", ".", "mean", "for", "d", "in", "self", ".", "dists", "]", ")", ".", "ravel", "(", ")", "\n", "self", ".", "_std", "=", "np", ".", "array", "(", "[", "d", ".", "std", "for", "d", "in", "self", ".", "dists", "]", ")", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.margs": [[246, 250], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "margs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get marginal distributions\"\"\"", "\n", "return", "[", "dist", ".", "marg", "for", "dist", "in", "self", ".", "dists", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.upper_quantile": [[251, 253], ["dist.ppf"], "methods", ["None"], ["", "def", "upper_quantile", "(", "self", ",", "prob_tol", ")", ":", "\n", "        ", "return", "[", "dist", ".", "ppf", "(", "1.", "-", "prob_tol", ")", "for", "dist", "in", "self", ".", "margs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.lower_quantile": [[254, 256], ["dist.ppf"], "methods", ["None"], ["", "def", "lower_quantile", "(", "self", ",", "prob_tol", ")", ":", "\n", "        ", "return", "[", "dist", ".", "ppf", "(", "prob_tol", ")", "for", "dist", "in", "self", ".", "margs", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.quantile_bounds": [[257, 274], ["lower.append", "upper.append", "dist.ppf", "dist.ppf"], "methods", ["None"], ["", "def", "quantile_bounds", "(", "self", ",", "prob_tol", ")", ":", "\n", "        ", "\"\"\"\n        Quantile bounds of marginal distribution\n     \n        Parameters\n        ----------\n    \n        prob_tol : float\n            probability tolerance to use. For symmetric\n            alpha-level confidence bounds,\n            prob_tol == (1 - alpha) / 2\n        \"\"\"", "\n", "lower", ",", "upper", "=", "[", "]", ",", "[", "]", "\n", "for", "dist", "in", "self", ".", "margs", ":", "\n", "            ", "lower", ".", "append", "(", "dist", ".", "ppf", "(", "prob_tol", ")", ")", "\n", "upper", ".", "append", "(", "dist", ".", "ppf", "(", "1", "-", "prob_tol", ")", ")", "\n", "", "return", "lower", ",", "upper", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.cov_inds": [[275, 279], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "cov_inds", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the indexes of the random variables, that are defined over CoV\"\"\"", "\n", "return", "[", "dist", ".", "var_coef", "is", "not", "None", "for", "dist", "in", "self", ".", "dists", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var_inds": [[280, 284], ["model.MultiVar.cov_inds"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.cov_inds"], ["", "@", "property", "\n", "def", "var_inds", "(", "self", ")", ":", "\n", "        ", "\"\"\"Get the indexes of the random variables, that are defined over CoV\"\"\"", "\n", "return", "[", "not", "res", "for", "res", "in", "self", ".", "cov_inds", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean": [[290, 296], ["zip", "model.MultiVar._read_moments"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar._read_moments"], ["", "@", "mean", ".", "setter", "\n", "def", "mean", "(", "self", ",", "new_mean", ")", ":", "\n", "        ", "\"\"\"Get input means, thus the design point\"\"\"", "\n", "for", "new_mu", ",", "dist", "in", "zip", "(", "new_mean", ",", "self", ".", "dists", ")", ":", "\n", "            ", "dist", ".", "mean", "=", "new_mu", "\n", "", "self", ".", "_read_moments", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var": [[302, 307], ["zip", "model.MultiVar._read_moments"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar._read_moments"], ["", "@", "var", ".", "setter", "\n", "def", "var", "(", "self", ",", "new_var", ")", ":", "\n", "        ", "for", "sigmasq", ",", "dist", "in", "zip", "(", "new_var", ",", "self", ".", "dists", ")", ":", "\n", "            ", "dist", ".", "var", "=", "sigmasq", "\n", "", "self", ".", "_read_moments", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std": [[313, 318], ["zip", "model.MultiVar._read_moments"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar._read_moments"], ["", "@", "std", ".", "setter", "\n", "def", "std", "(", "self", ",", "new_std", ")", ":", "\n", "        ", "for", "sigma", ",", "dist", "in", "zip", "(", "new_std", ",", "self", ".", "dists", ")", ":", "\n", "            ", "dist", ".", "std", "=", "sigma", "\n", "", "self", ".", "_read_moments", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.is_corr": [[319, 323], ["numpy.array_equal", "numpy.eye"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_corr", "(", "self", ")", ":", "\n", "        ", "\"\"\"Return True if any correlation is nonzero\"\"\"", "\n", "return", "not", "np", ".", "array_equal", "(", "self", ".", "rho", ",", "np", ".", "eye", "(", "self", ".", "rho", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.transform_mats": [[324, 354], ["scipy.linalg.cholesky", "numpy.linalg.inv", "scipy.linalg.eigh", "numpy.dot", "numpy.linalg.pinv", "print", "print", "numpy.diag", "print", "print", "numpy.sqrt"], "methods", ["None"], ["", "def", "transform_mats", "(", "self", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"Matrices for the linear correlation transformation\n\n        Returns\n        -------\n\n        corr_trans : np.ndarray\n            To be used for transforming from the uncorrelated space to the\n            correlated space\n\n        inv_corr_trans : np.ndarray\n            To be used for transforming from the correlated space to the\n            uncorrelated space\n        \"\"\"", "\n", "try", ":", "\n", "            ", "corr_trans", "=", "cholesky", "(", "self", ".", "rho", ",", "lower", "=", "True", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'Cholesky factorization failed.'", ")", "\n", "print", "(", "'Continuing with PCA.'", ")", "\n", "", "eivals", ",", "eivecs", "=", "eigh", "(", "self", ".", "rho", ")", "\n", "corr_trans", "=", "np", ".", "dot", "(", "np", ".", "diag", "(", "np", ".", "sqrt", "(", "eivals", ")", ")", ",", "eivecs", ".", "T", ")", "\n", "", "try", ":", "\n", "            ", "inv_corr_trans", "=", "np", ".", "linalg", ".", "inv", "(", "corr_trans", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "            ", "if", "verbose", ":", "\n", "                ", "print", "(", "'linalg.inv failed.'", ")", "\n", "print", "(", "'Continuing with linalg.pinv.'", ")", "\n", "", "inv_corr_trans", "=", "np", ".", "linalg", ".", "pinv", "(", "corr_trans", ")", "\n", "", "return", "corr_trans", ",", "inv_corr_trans", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.nataf_mats": [[355, 371], ["copula.NatafTransformation.NatafTransformation"], "methods", ["None"], ["", "def", "nataf_mats", "(", "self", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"Matrices for the Nataf transformation\n            Returns\n            -------\n\n            corr_trans : np.ndarray\n                To be used for transforming from the uncorrelated space to the\n                correlated space\n\n            inv_corr_trans : np.ndarray\n                To be used for transforming from the correlated space to the\n                uncorrelated space\n        \"\"\"", "\n", "copula", "=", "NatafTransformation", "(", "self", ".", "margs", ",", "rho_x", "=", "self", ".", "rho", ",", "\n", "verbose", "=", "verbose", ")", "\n", "return", "copula", ".", "corr_transform", ",", "copula", ".", "inv_corr_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.opt_lhs": [[372, 396], ["doe.lhs.make_doe"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe"], ["", "def", "opt_lhs", "(", "self", ",", "num_points", ":", "int", "=", "100", ",", "lower_bounds", "=", "None", ",", "upper_bounds", "=", "None", ",", "\n", "num_iters", ":", "int", "=", "5000", ")", ":", "\n", "        ", "\"\"\" Get an orthogonal sampling design of experiments for the MultiVariate\n\n        Parameters\n        ----------\n        num_points : int\n            number of samples to be generated\n\n        lower_bounds : None or iterable\n            if passed, the points in the generated DoE will be moved so that\n            each dimension is larger than lower_bounds\n\n        lower_bounds : None or iterable\n            if passed, the points in the generated DoE will be moved so that\n            each dimension is smaller than upper_bounds\n\n        num_iters : int\n            number of iterations to optimize the DoE for distance and target\n            correlation criteria\n        \"\"\"", "\n", "return", "make_doe", "(", "num_points", ",", "self", ".", "margs", ",", "corr_mat", "=", "self", ".", "rho", ",", "\n", "num_tries", "=", "num_iters", ",", "lower_bound", "=", "lower_bounds", ",", "\n", "upper_bound", "=", "upper_bounds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.new": [[397, 418], ["copy.deepcopy", "enumerate", "model.MultiVar"], "methods", ["None"], ["", "def", "new", "(", "self", ",", "mean", ":", "typing", ".", "Union", "[", "list", ",", "np", ".", "ndarray", "]", "=", "None", ",", "std", ":", "typing", ".", "Union", "[", "list", ",", "np", ".", "ndarray", "]", "=", "None", ",", "\n", "inds", ":", "list", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Return new MultiVariate model with the original distribution families\n        with different means and standard deviations as long as these were\n        submitted\n        \"\"\"", "\n", "dists", "=", "deepcopy", "(", "self", ".", "dists", ")", "\n", "\n", "if", "inds", ":", "\n", "            ", "dists", "=", "[", "dists", "[", "ind", "]", "for", "ind", "in", "inds", "]", "\n", "rho", "=", "self", ".", "rho", "[", "inds", ",", ":", "]", "[", ":", ",", "inds", "]", "\n", "", "else", ":", "\n", "            ", "rho", "=", "self", ".", "rho", "\n", "\n", "", "for", "i_var", ",", "dist", "in", "enumerate", "(", "dists", ")", ":", "\n", "            ", "if", "std", "is", "not", "None", ":", "\n", "                ", "dist", ".", "std", "=", "std", "[", "i_var", "]", "\n", "", "if", "mean", "is", "not", "None", ":", "\n", "                ", "dist", ".", "mean", "=", "mean", "[", "i_var", "]", "\n", "", "", "return", "MultiVar", "(", "dists", ",", "rho", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.standard_lhs": [[419, 426], ["numpy.zeros", "numpy.ones", "model.MultiVar.new", "model.MultiVar.opt_lhs"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.new", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.opt_lhs"], ["", "def", "standard_lhs", "(", "self", ",", "num_points", ":", "int", "=", "100", ",", "num_iters", ":", "int", "=", "5000", ",", "\n", "lower_bounds", "=", "None", ",", "upper_bounds", "=", "None", ")", ":", "\n", "        ", "\"\"\"Returns get_lhs with mean=0 and std=1\"\"\"", "\n", "mus", "=", "np", ".", "zeros", "(", "self", ".", "_mu", ".", "shape", "[", "0", "]", ")", "\n", "sigs", "=", "np", ".", "ones", "(", "self", ".", "_std", ".", "shape", "[", "0", "]", ")", "\n", "tmp_mv", "=", "self", ".", "new", "(", "mus", ",", "sigs", ")", "\n", "return", "tmp_mv", ".", "opt_lhs", "(", "num_points", ",", "lower_bounds", ",", "upper_bounds", ",", "num_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.__repr__": [[427, 429], ["str"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "\"MultiVar: \"", "+", "\" | \"", ".", "join", "(", "[", "str", "(", "d", ")", "for", "d", "in", "self", ".", "dists", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.__str__": [[430, 437], ["len"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "n_list", "=", "[", "dist", ".", "name", "for", "dist", "in", "self", ".", "dists", "]", "\n", "names", "=", "\" | \"", ".", "join", "(", "n_list", ")", "\n", "msg", "=", "f\"{len(n_list)} dimensional multivariate random model\\n Distributions: \\n\"", "\n", "msg", "+=", "f\"{names}\\n uses nataf copula to simulate independency\\n\"", "\n", "msg", "+=", "f\"Means: {self.mean}\\n Std. Devs. {self.std} \\n\"", "\n", "return", "msg", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model._get_corr_mat": [[24, 42], ["numpy.eye", "ValueError", "ValueError", "ValueError", "ValueError", "isinstance"], "function", ["None"], ["def", "_get_corr_mat", "(", "corr_transform", ",", "n_dim", ")", ":", "\n", "    ", "\"\"\" Input check for the arguments passed to DirectionalSimulator\"\"\"", "\n", "if", "corr_transform", "is", "None", ":", "\n", "        ", "return", "np", ".", "eye", "(", "n_dim", ")", "\n", "", "if", "not", "isinstance", "(", "corr_transform", ",", "np", ".", "ndarray", ")", "or", "corr_transform", ".", "ndim", "<", "2", ":", "\n", "        ", "err_msg", "=", "\"corr_transform must be a 2-D numpy array\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "corr_transform", ".", "shape", "[", "0", "]", "!=", "n_dim", ":", "\n", "        ", "err_msg", "=", "\"Inconsistent number of marginal distributions and \"", "\n", "err_msg", "+=", "\"corr_transform shape\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "corr_transform", ".", "shape", "[", "0", "]", "!=", "corr_transform", ".", "shape", "[", "1", "]", ":", "\n", "        ", "err_msg", "=", "\"corr_transform must be square\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "if", "not", "(", "corr_transform", "==", "corr_transform", ".", "T", ")", ".", "all", "(", ")", ":", "\n", "        ", "err_msg", "=", "\"corr_transform must be symmetrical\"", "\n", "raise", "ValueError", "(", "err_msg", ")", "\n", "", "return", "corr_transform", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.__init__": [[84, 123], ["space._sane_inds", "space._sane_inds", "space._sane_inds", "space._sane_inds", "space._make_bool_d", "space._make_bool", "numpy.array", "len", "ValueError", "list", "set", "space.InputSpace._covs.append", "space.InputSpace._cov_i.append", "space.InputSpace._covs.append", "space.InputSpace._cov_i.append"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._make_bool_d", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._make_bool"], ["def", "__init__", "(", "self", ",", "mulvar", ":", "MultiVar", ",", "num_inp", ":", "int", "=", "None", ",", "opt_inps", ":", "list", "=", "None", ",", "\n", "sto_inps", ":", "list", "=", "None", ",", "sto_obj_inps", ":", "list", "=", "None", ",", "\n", "sto_con_inps", ":", "list", "=", "None", ")", ":", "\n", "        ", "self", ".", "mulvar", "=", "mulvar", "\n", "if", "num_inp", "is", "None", ":", "\n", "            ", "num_inp", "=", "len", "(", "mulvar", ".", "dists", ")", "\n", "", "self", ".", "dims", "=", "num_inp", "\n", "if", "num_inp", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"At least one input is required\"", ")", "\n", "\n", "", "opt_inps", "=", "_sane_inds", "(", "opt_inps", ",", "num_inp", ")", "\n", "num_sto_inp", "=", "mulvar", ".", "mean", ".", "shape", "[", "0", "]", "\n", "stoch_inps", "=", "_sane_inds", "(", "sto_inps", ",", "num_sto_inp", ")", "\n", "\n", "if", "sto_obj_inps", "is", "None", ":", "\n", "            ", "sto_obj_inps", "=", "stoch_inps", "\n", "", "stoch_obj_inps", "=", "_sane_inds", "(", "sto_obj_inps", ",", "num_sto_inp", ")", "\n", "\n", "if", "sto_con_inps", "is", "None", ":", "\n", "            ", "sto_con_inps", "=", "stoch_inps", "\n", "", "stoch_con_inps", "=", "_sane_inds", "(", "sto_con_inps", ",", "num_sto_inp", ")", "\n", "# Make a guide to input space", "\n", "self", ".", "inds", "=", "{", "\"opt\"", ":", "opt_inps", ",", "\n", "\"sto\"", ":", "list", "(", "set", "(", "stoch_obj_inps", "+", "stoch_con_inps", ")", ")", ",", "\n", "\"sto_obj\"", ":", "stoch_obj_inps", ",", "\n", "\"sto_con\"", ":", "stoch_con_inps", "}", "\n", "self", ".", "inds", "=", "_make_bool_d", "(", "self", ".", "inds", ",", "num_inp", ")", "\n", "\n", "self", ".", "_cov_i", ",", "self", ".", "_covs", "=", "[", "]", ",", "[", "]", "\n", "for", "dist", "in", "self", ".", "mulvar", ".", "dists", ":", "\n", "            ", "if", "dist", ".", "var_coef", "is", "not", "None", ":", "\n", "                ", "self", ".", "_covs", ".", "append", "(", "dist", ".", "var_coef", ")", "\n", "self", ".", "_cov_i", ".", "append", "(", "True", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_covs", ".", "append", "(", "0.", ")", "# So it raises an error, if one tries", "\n", "# to use it. Also makes it easier to slice", "\n", "self", ".", "_cov_i", ".", "append", "(", "False", ")", "\n", "", "", "self", ".", "_cov_i", "=", "_make_bool", "(", "self", ".", "_cov_i", ",", "num_inp", ")", "\n", "self", ".", "_covs", "=", "np", ".", "array", "(", "self", ".", "_covs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace._get_bound": [[124, 134], ["numpy.array", "space.InputSpace.opt_mulvar", "space.InputSpace.opt2full().ravel", "getattr", "numpy.isfinite().all", "ValueError", "space.InputSpace.opt2full", "numpy.isfinite"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_mulvar", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full"], ["", "def", "_get_bound", "(", "self", ",", "prob", ",", "opt_bound", ",", "quantile_fun", ")", ":", "\n", "        ", "if", "opt_bound", "is", "None", ":", "\n", "            ", "return", "opt_bound", "\n", "", "model_bound", "=", "np", ".", "array", "(", "opt_bound", ",", "dtype", "=", "float", ")", "\n", "mulvar", "=", "self", ".", "opt_mulvar", "(", "model_bound", ",", "domain", "=", "\"sto\"", ")", "\n", "model_bound", "=", "self", ".", "opt2full", "(", "model_bound", ")", ".", "ravel", "(", ")", "\n", "model_bound", "[", "self", ".", "inds", "[", "\"sto\"", "]", "]", "=", "getattr", "(", "mulvar", ",", "quantile_fun", ")", "(", "prob", ")", "\n", "if", "not", "np", ".", "isfinite", "(", "model_bound", ")", ".", "all", "(", ")", ":", "\n", "            ", "raise", "ValueError", "(", "f\"Resulting DoE bound from {quantile_fun} is not finite!\"", ")", "\n", "", "return", "model_bound", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.doe_bounds": [[135, 168], ["space.InputSpace._get_bound", "space.InputSpace._get_bound", "ValueError"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace._get_bound", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace._get_bound"], ["", "def", "doe_bounds", "(", "self", ",", "prob", ",", "lower", "=", "None", ",", "upper", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Generates bounds for SML model given the deterministic bounds\n        and a probability tolerance\n\n        Parameters\n        ----------\n        lower : np.ndarray\n            1-D array or None of lower optimization bound.\n            If None, lower bound is not returned\n        upper : np.ndarray\n            1-D array or None of lower optimization bound.\n            If None, lower bound is not returned\n        prob_tol : float\n            probability tolerance to use. For symmetric\n            alpha-level confidence bounds,\n            prob_tol == (1 - alpha) / 2\n\n        Returns\n        -------\n        if both passed, lower and upper, else only the passed bound.\n        if None passed, raises an error.\n\n        \"\"\"", "\n", "lower", "=", "self", ".", "_get_bound", "(", "prob", ",", "lower", ",", "\"lower_quantile\"", ")", "\n", "upper", "=", "self", ".", "_get_bound", "(", "prob", ",", "upper", ",", "\"upper_quantile\"", ")", "\n", "if", "lower", "is", "None", "and", "upper", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "\"Either lower or upper bound must be passed!\"", ")", "\n", "", "if", "lower", "is", "None", ":", "\n", "            ", "return", "upper", "\n", "", "if", "upper", "is", "None", ":", "\n", "            ", "return", "lower", "\n", "", "return", "lower", ",", "upper", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full": [[169, 192], ["space.check_shape", "numpy.zeros", "space.InputSpace.inds[].sum"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape"], ["", "def", "opt2full", "(", "self", ",", "x_opt", ")", ":", "\n", "        ", "\"\"\"A wrapper for stochastic assessments on user functions\n\n        converts optimization inputs to full inputs by inserting\n        the non optimization i.e. only stochastic inputs\n\n        Parameters\n        ----------\n        x_opt : np.ndarray\n            The array containing the sampling points in the optimization space with\n            shape=(n_samples, len(self.inds['opt']))\n\n        Returns\n        -------\n        x_full : np.ndarray with shape=(n_samples, n_inp)\n            Full set of input points to be passed to objectives and constraints\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\"opt2full\"", ")", "\n", "x_full", "=", "np", ".", "zeros", "(", "(", "x_opt", ".", "shape", "[", "0", "]", ",", "self", ".", "dims", ")", ")", "\n", "# to get non opt stochastics", "\n", "x_full", "[", ":", ",", "self", ".", "inds", "[", "\"sto\"", "]", "]", "=", "self", ".", "mulvar", ".", "mean", "\n", "x_full", "[", ":", ",", "self", ".", "inds", "[", "\"opt\"", "]", "]", "=", "x_opt", "\n", "return", "x_full", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2stoch": [[193, 212], ["space.check_shape", "space.InputSpace.inds[].sum", "space.InputSpace.opt2full"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full"], ["", "def", "opt2stoch", "(", "self", ",", "x_opt", ",", "domain", ":", "str", "=", "\"sto\"", ")", ":", "\n", "        ", "\"\"\"A wrapper to convert optimization to stochastic space\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization with shape=(n_samples, len(self.inds['opt'])).\n\n        domain : str\n            one of sto_con, sto_opt, sto or opt. Defines the context\n            of the transformation\n\n        Returns\n        -------\n        x_stoch : numpy.ndarray\n            Transformed points x_opt in the stochastic space\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\"opt2stoch\"", ")", "\n", "return", "self", ".", "opt2full", "(", "x_opt", ")", "[", ":", ",", "self", ".", "inds", "[", "domain", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full": [[213, 244], ["space.check_shape", "space.check_shape", "space.InputSpace.opt2full", "space.InputSpace.inds[].sum", "space.InputSpace.inds[].sum", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full"], ["", "def", "stoch2full", "(", "self", ",", "x_stoch", ",", "x_opt", ",", "domain", ":", "str", "=", "\"sto\"", ")", ":", "\n", "        ", "\"\"\"A wrapper for stochastic assessments on user functions\n\n        converts stochastic inputs to full inputs by inserting the references\n\n        Parameters\n        ----------\n        x_stoch : np.ndarray\n            The array containing the sampling points in the stochastic space with\n            shape=(n_samples, len(self.inds['sto']))\n\n        x_opt : np.ndarray\n            The array containing the reference point in the optimization space with\n            shape=(n_samples, len(self.inds['opt'])).\n\n        domain : str\n            one of sto_con, sto_opt, sto or opt. Defines the context\n            of the transformation\n\n        Returns\n        -------\n        x_full : numpy-array with n_samples x n_inp\n            Full set of input points to be passed to objectives and constraints\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\"stoch2full.x_opt\"", ")", "\n", "x_stoch", "=", "check_shape", "(", "x_stoch", ",", "self", ".", "inds", "[", "domain", "]", ".", "sum", "(", ")", ",", "\n", "\"opt_mulvar.x_stoch\"", ")", "\n", "x_full", "=", "self", ".", "opt2full", "(", "x_opt", "*", "np", ".", "ones", "(", "(", "x_stoch", ".", "shape", "[", "0", "]", ",", "x_opt", ".", "shape", "[", "1", "]", ")", ")", ")", "\n", "#        x_full = np.repeat(x_ref, x_stoch.shape[0], axis=0) ## too slow", "\n", "x_full", "[", ":", ",", "self", ".", "inds", "[", "domain", "]", "]", "=", "x_stoch", "\n", "return", "x_full", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_moms": [[245, 274], ["space.check_shape", "space.InputSpace.mv_inds", "space.InputSpace.opt2stoch().ravel", "numpy.logical_and.any", "space.InputSpace.inds[].sum", "numpy.logical_and", "numpy.absolute", "space.InputSpace.opt2stoch"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.mv_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2stoch"], ["", "def", "opt_moms", "(", "self", ",", "x_opt", ",", "domain", ":", "str", "=", "\"sto_obj\"", ")", ":", "\n", "        ", "\"\"\"Get the transformed mean and std. dev for x_opt\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization with shape=(n_samples, len(self.inds['opt'])).\n\n        domain : str\n            one of sto_con, sto_opt, sto or opt. Defines the context\n            of the transformation\n\n        Returns\n        -------\n        new_mu : float\n            Mean values of the inputs\n\n        new_sigma : float\n            Std. deviation of the inputs\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\"opt_moms\"", ")", "\n", "mv_inds", "=", "self", ".", "mv_inds", "(", "domain", "=", "domain", ")", "\n", "new_mu", "=", "self", ".", "opt2stoch", "(", "x_opt", ",", "domain", "=", "domain", ")", ".", "ravel", "(", ")", "\n", "new_sigma", "=", "self", ".", "mulvar", ".", "std", "[", "mv_inds", "]", "\n", "cur_inds", "=", "self", ".", "_cov_i", "[", "mv_inds", "]", "\n", "if", "cur_inds", ".", "any", "(", ")", ":", "\n", "            ", "cur_inds", "=", "np", ".", "logical_and", "(", "cur_inds", ",", "self", ".", "inds", "[", "domain", "]", "[", "mv_inds", "]", ")", "\n", "new_sigma", "[", "cur_inds", "]", "=", "self", ".", "_covs", "[", "mv_inds", "]", "[", "cur_inds", "]", "*", "new_mu", "[", "cur_inds", "]", "\n", "", "return", "new_mu", ",", "np", ".", "absolute", "(", "new_sigma", ")", "# in case mu changes sign", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_mulvar": [[275, 295], ["space.check_shape", "space.InputSpace.opt_moms", "space.InputSpace.mulvar.new", "space.InputSpace.inds[].sum", "space.InputSpace.mv_inds"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_moms", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.new", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.mv_inds"], ["", "def", "opt_mulvar", "(", "self", ",", "x_opt", ",", "domain", ":", "str", "=", "\"sto_con\"", ")", ":", "\n", "        ", "\"\"\"return MultiVar with transformed mean and std. dev for x_opt\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization with shape=(n_samples, len(self.inds['opt'])).\n\n        domain : str\n            one of sto_con, sto_opt, sto or opt. Defines the context\n            of the transformation\n\n        Returns\n        -------\n        multivariate : MultiVar\n            Multivariate at the optimization point x_opt\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\"opt_mulvar\"", ")", "\n", "mean", ",", "std", "=", "self", ".", "opt_moms", "(", "x_opt", ",", "domain", ")", "\n", "return", "self", ".", "mulvar", ".", "new", "(", "mean", ",", "std", ",", "self", ".", "mv_inds", "(", "domain", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.sto_obj_doe": [[296, 320], ["space.check_shape", "space.InputSpace.opt_mulvar", "space.InputSpace.opt_lhs", "space.InputSpace.inds[].sum"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_mulvar", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.opt_lhs"], ["", "def", "sto_obj_doe", "(", "self", ",", "x_opt", ",", "num_points", "=", "100", ",", "num_iters", "=", "5000", ")", ":", "\n", "        ", "\"\"\" Get a design of experiments at x_opt\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization with shape=(n_samples, len(self.inds['opt'])).\n\n        num_points : int\n            number of points in the DoE\n\n        num_iters : int\n            number of iterations for the optimization of the DoE\n\n        Returns\n        -------\n        doe - numpy.ndarray\n            an optimized LHS for the stochastic objectives. Only the\n            stochastic variables defined for the objectives i.e.\n            sto_obj_inps are varied.\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\"sto_obj_doe\"", ")", "\n", "opt_mv", "=", "self", ".", "opt_mulvar", "(", "x_opt", ",", "\"sto_obj\"", ")", "\n", "return", "opt_mv", ".", "opt_lhs", "(", "num_points", "=", "num_points", ",", "num_iters", "=", "num_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.sto_obj_base_doe": [[321, 356], ["space.InputSpace.mv_inds", "len", "numpy.zeros", "numpy.ones", "space.InputSpace.mulvar.new", "space.InputSpace.opt_lhs", "duqo.stoch.model.UniVar", "enumerate"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.mv_inds", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.new", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.opt_lhs"], ["", "def", "sto_obj_base_doe", "(", "self", ",", "num_points", "=", "100", ",", "num_iters", "=", "5000", ")", ":", "\n", "        ", "\"\"\" Get a design of experiments at x_opt\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization with shape=(n_samples, len(self.inds['opt'])).\n\n        num_points : int\n            number of points in the DoE\n\n        num_iters : int\n            number of iterations for the optimization of the DoE\n\n        Returns\n        -------\n        doe - numpy.ndarray\n            an optimized LHS for the stochastic objectives. Only the\n            stochastic variables defined for the objectives i.e.\n            sto_obj_inps are varied.\n\n        \"\"\"", "\n", "mv_inds", "=", "self", ".", "mv_inds", "(", "\"sto_obj\"", ")", "\n", "n_univar", "=", "len", "(", "mv_inds", ")", "\n", "mu", "=", "np", ".", "zeros", "(", "n_univar", ")", "\n", "sig", "=", "np", ".", "ones", "(", "n_univar", ")", "\n", "dnames", "=", "self", ".", "mulvar", ".", "names", "\n", "dnames", "=", "[", "dnames", "[", "ind", "]", "for", "ind", "in", "mv_inds", "]", "\n", "inds", "=", "[", "i", "for", "i", ",", "x", "in", "enumerate", "(", "dnames", ")", "if", "\"log\"", "in", "x", "or", "\"trunc\"", "in", "x", "]", "\n", "# Handle Lognormal as uniform to use as probabilities", "\n", "scaled_mv", "=", "self", ".", "mulvar", ".", "new", "(", "mu", ",", "sig", ",", "mv_inds", ")", "\n", "for", "ind", "in", "inds", ":", "\n", "            ", "scaled_mv", ".", "dists", "[", "ind", "]", "=", "UniVar", "(", "\"uniform\"", ",", "lower_bound", "=", "0.0", ",", "\n", "upper_bound", "=", "1.0", ")", "\n", "", "return", "scaled_mv", ".", "opt_lhs", "(", "num_points", "=", "num_points", ",", "num_iters", "=", "num_iters", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.mv_inds": [[357, 362], ["[].tolist", "[].tolist", "[].tolist.index", "numpy.where", "numpy.where"], "methods", ["None"], ["", "def", "mv_inds", "(", "self", ",", "domain", "=", "\"sto_obj\"", ")", ":", "\n", "        ", "\"\"\"Gets the mv indexes of a given domain\"\"\"", "\n", "sto_inds", "=", "np", ".", "where", "(", "self", ".", "inds", "[", "\"sto\"", "]", ")", "[", "0", "]", ".", "tolist", "(", ")", "\n", "full_inds", "=", "np", ".", "where", "(", "self", ".", "inds", "[", "domain", "]", ")", "[", "0", "]", ".", "tolist", "(", ")", "\n", "return", "[", "sto_inds", ".", "index", "(", "fui", ")", "for", "fui", "in", "full_inds", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.__init__": [[410, 439], ["isinstance", "space._sane_inds", "space._sane_inds", "ValueError", "TypeError", "TypeError", "space.InputSpace", "tuple", "tuple", "range", "range"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds"], ["def", "__init__", "(", "self", ",", "inp_space", ":", "typing", ".", "Union", "[", "MultiVar", ",", "InputSpace", "]", ",", "num_obj", ":", "int", ",", "num_con", ":", "int", ",", "\n", "obj_fun", "=", "None", ",", "obj_arg", "=", "(", ")", ",", "con_fun", "=", "None", ",", "con_arg", "=", "(", ")", ",", "\n", "sto_objs", ":", "list", "=", "None", ",", "sto_cons", ":", "list", "=", "None", ")", ":", "\n", "        ", "if", "num_obj", "+", "num_con", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"At least one function is required\"", ")", "\n", "", "if", "num_obj", ">", "0", "and", "obj_fun", "is", "None", ":", "\n", "            ", "raise", "TypeError", "(", "\"obj_fun must be defined for num_obj > 0.\"", ")", "\n", "", "if", "num_con", ">", "0", "and", "con_fun", "is", "None", ":", "\n", "            ", "raise", "TypeError", "(", "\"con_fun must be defined for num_con > 0.\"", ")", "\n", "\n", "", "self", ".", "dims", "=", "(", "num_obj", ",", "num_con", ")", "\n", "if", "isinstance", "(", "inp_space", ",", "MultiVar", ")", ":", "\n", "            ", "self", ".", "inp_space", "=", "InputSpace", "(", "inp_space", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "inp_space", "=", "inp_space", "\n", "", "self", ".", "obj", "=", "obj_fun", "\n", "self", ".", "con", "=", "con_fun", "\n", "if", "not", "obj_arg", ":", "\n", "            ", "obj_arg", "=", "tuple", "(", ")", "\n", "", "if", "not", "con_arg", ":", "\n", "            ", "con_arg", "=", "tuple", "(", ")", "\n", "", "self", ".", "obj_arg", "=", "obj_arg", "\n", "self", ".", "con_arg", "=", "con_arg", "\n", "stoch_obj_locs", "=", "_sane_inds", "(", "sto_objs", ",", "num_obj", ")", "\n", "stoch_con_locs", "=", "_sane_inds", "(", "sto_cons", ",", "num_con", ")", "\n", "self", ".", "obj_inds", "=", "{", "\"full\"", ":", "[", "i", "for", "i", "in", "range", "(", "self", ".", "dims", "[", "0", "]", ")", "]", ",", "\n", "\"sto\"", ":", "stoch_obj_locs", "}", "\n", "self", ".", "con_inds", "=", "{", "\"full\"", ":", "[", "i", "for", "i", "in", "range", "(", "self", ".", "dims", "[", "1", "]", ")", "]", ",", "\n", "\"sto\"", ":", "stoch_con_locs", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.det_obj": [[440, 460], ["space.FullSpace.obj", "space.check_shape", "TypeError", "space.FullSpace.inp_space.opt2full"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.obj", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full"], ["", "def", "det_obj", "(", "self", ",", "x_opt", ")", ":", "\n", "        ", "\"\"\" objective function for the deterministic assessment\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization with shape shape=(n_samples, len(self.inds['opt'])).\n            The non-optimization variables are parsed from the MultiVar\n\n        Returns\n        -------\n        obj_vals : numpy.ndarray\n            the values of the objective functions with the shape\n            (x_opt.shape[0], num_obj)\n        \"\"\"", "\n", "if", "self", ".", "dims", "[", "0", "]", "==", "0", ":", "\n", "            ", "raise", "TypeError", "(", "\"This space does not have an objective function\"", ")", "\n", "", "res", "=", "self", ".", "obj", "(", "self", ".", "inp_space", ".", "opt2full", "(", "x_opt", ")", ",", "*", "self", ".", "obj_arg", ",", "\n", "self", ".", "obj_inds", "[", "\"full\"", "]", ")", "\n", "return", "check_shape", "(", "res", ",", "self", ".", "dims", "[", "0", "]", ",", "parent", "=", "\"det_obj\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.det_con": [[461, 481], ["space.FullSpace.con", "space.check_shape", "TypeError", "space.FullSpace.inp_space.opt2full"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.con", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full"], ["", "def", "det_con", "(", "self", ",", "x_opt", ")", ":", "\n", "        ", "\"\"\"constraint function for the deterministic assessment\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            the coordinates of the variables used in optimization. The non\n            optimization variables are parsed from the MultiVar\n\n        Returns\n        -------\n        con_vals : numpy.ndarray\n            the values of the constraint functions with the shape\n            (x_opt.shape[0], num_con)\n        \"\"\"", "\n", "if", "self", ".", "dims", "[", "1", "]", "==", "0", ":", "\n", "            ", "raise", "TypeError", "(", "\"This space does not have a constraint function\"", ")", "\n", "", "res", "=", "self", ".", "con", "(", "self", ".", "inp_space", ".", "opt2full", "(", "x_opt", ")", ",", "*", "self", ".", "con_arg", ",", "\n", "self", ".", "con_inds", "[", "\"full\"", "]", ")", "\n", "return", "check_shape", "(", "res", ",", "self", ".", "dims", "[", "1", "]", ",", "parent", "=", "\"det_con\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.sto_obj": [[482, 505], ["space.FullSpace.inp_space.stoch2full", "space.FullSpace.obj", "space.check_shape", "TypeError", "len"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.obj", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape"], ["", "def", "sto_obj", "(", "self", ",", "x_sto", ",", "x_opt", ")", ":", "\n", "        ", "\"\"\" objective function for the stochastic assessment\n\n        Parameters\n        ----------\n        x_sto : numpy.ndarray\n            The values of the stochastic variables, as used for the objectives\n\n        x_opt : numpy.ndarray\n            the current coordinates of the variables used in optimization.\n\n        Returns\n        -------\n        obj_vals : numpy.ndarray\n            the values of the objective functions with the shape\n            (x_opt.shape[0], num_stochastic_con)\n        \"\"\"", "\n", "if", "self", ".", "dims", "[", "0", "]", "==", "0", "or", "not", "self", ".", "obj_inds", "[", "\"sto\"", "]", ":", "\n", "            ", "err", "=", "\"This space does not have a stochastic objective function\"", "\n", "raise", "TypeError", "(", "err", ")", "\n", "", "x_full", "=", "self", ".", "inp_space", ".", "stoch2full", "(", "x_sto", ",", "x_opt", ",", "domain", "=", "\"sto_obj\"", ")", "\n", "res", "=", "self", ".", "obj", "(", "x_full", ",", "*", "self", ".", "obj_arg", ",", "self", ".", "obj_inds", "[", "\"sto\"", "]", ")", "\n", "return", "check_shape", "(", "res", ",", "len", "(", "self", ".", "obj_inds", "[", "\"sto\"", "]", ")", ",", "parent", "=", "\"sto_obj\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.sto_con": [[506, 517], ["space.FullSpace.inp_space.stoch2full", "space.FullSpace.con", "space.check_shape", "TypeError", "len", "numpy.min"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.con", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape"], ["", "def", "sto_con", "(", "self", ",", "x_stoch", ",", "x_opt", ",", "envelope", "=", "True", ")", ":", "\n", "        ", "\"\"\" constraint (limit state) function for the stochastic assessment \"\"\"", "\n", "if", "self", ".", "dims", "[", "1", "]", "==", "0", "or", "not", "self", ".", "con_inds", "[", "\"sto\"", "]", ":", "\n", "            ", "err", "=", "\"This space does not have a stochastic constraint function\"", "\n", "raise", "TypeError", "(", "err", ")", "\n", "", "x_full", "=", "self", ".", "inp_space", ".", "stoch2full", "(", "x_stoch", ",", "x_opt", ",", "domain", "=", "\"sto_con\"", ")", "\n", "res", "=", "self", ".", "con", "(", "x_full", ",", "*", "self", ".", "con_arg", ",", "self", ".", "con_inds", "[", "\"sto\"", "]", ")", "\n", "res", "=", "check_shape", "(", "res", ",", "len", "(", "self", ".", "con_inds", "[", "\"sto\"", "]", ")", ",", "parent", "=", "\"sto_con\"", ")", "\n", "if", "envelope", ":", "\n", "            ", "return", "np", ".", "min", "(", "res", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._sane_inds": [[14, 26], ["numpy.max", "numpy.arange", "int", "ValueError"], "function", ["None"], ["def", "_sane_inds", "(", "ids", ",", "n_ele", ")", ":", "\n", "    ", "if", "n_ele", "==", "0", ":", "\n", "        ", "return", "[", "]", "\n", "", "if", "ids", "is", "None", ":", "\n", "        ", "ids", "=", "np", ".", "arange", "(", "n_ele", ")", "\n", "", "ids", "=", "[", "int", "(", "i", ")", "for", "i", "in", "ids", "]", "\n", "if", "not", "ids", ":", "\n", "        ", "return", "[", "]", "\n", "", "maxi", "=", "np", ".", "max", "(", "ids", ")", "\n", "if", "maxi", ">=", "n_ele", ":", "\n", "        ", "raise", "ValueError", "(", "f\"Max. index {maxi} is larger than max. dim {n_ele}\"", ")", "\n", "", "return", "ids", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._make_bool": [[28, 34], ["numpy.zeros", "isinstance"], "function", ["None"], ["", "def", "_make_bool", "(", "inds", ",", "n_ele", ")", ":", "\n", "    ", "if", "isinstance", "(", "inds", ",", "np", ".", "ndarray", ")", "and", "inds", ".", "dtype", "==", "bool", ":", "\n", "        ", "return", "inds", "\n", "", "res", "=", "np", ".", "zeros", "(", "n_ele", ",", "dtype", "=", "bool", ")", "\n", "res", "[", "inds", "]", "=", "True", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._make_bool_d": [[36, 40], ["space._make_bool"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space._make_bool"], ["", "def", "_make_bool_d", "(", "dic", ",", "n_ele", ")", ":", "\n", "    ", "for", "name", "in", "dic", ":", "\n", "        ", "dic", "[", "name", "]", "=", "_make_bool", "(", "dic", "[", "name", "]", ",", "n_ele", ")", "\n", "", "return", "dic", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape": [[519, 528], ["numpy.array", "res.reshape.reshape", "ValueError"], "function", ["None"], ["", "", "def", "check_shape", "(", "res", ",", "expected_dim", ",", "parent", "=", "\"somewhere\"", ")", ":", "\n", "    ", "res", "=", "np", ".", "array", "(", "res", ")", "\n", "if", "res", ".", "ndim", "==", "1", ":", "\n", "        ", "res", "=", "res", ".", "reshape", "(", "(", "-", "1", ",", "expected_dim", ")", ")", "\n", "", "if", "res", ".", "shape", "[", "1", "]", "!=", "expected_dim", ":", "\n", "        ", "msg", "=", "f\"Dimension mismatch ({res.shape[1]}!={expected_dim}) \"", "\n", "msg", "+=", "\"in \"", "+", "parent", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "return", "res", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.__init__": [[180, 191], ["len", "predict._check_std_inds", "predict._check_obj_wgt"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._check_std_inds", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._check_obj_wgt"], ["def", "__init__", "(", "self", ",", "full_space", ":", "FullSpace", ",", "base_doe", ":", "typing", ".", "Union", "[", "bool", ",", "np", ".", "ndarray", "]", "=", "True", ",", "\n", "doe_size", ":", "int", "=", "100", ",", "obj_wgt", ":", "typing", ".", "Optional", "[", "typing", ".", "Union", "[", "float", ",", "list", ",", "np", ".", "ndarray", "]", "]", "=", "None", ",", "\n", "use_std", ":", "typing", ".", "Union", "[", "bool", ",", "list", "]", "=", "False", ")", ":", "\n", "        ", "self", ".", "full_space", "=", "full_space", "\n", "num_obj", "=", "len", "(", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", ")", "\n", "self", ".", "_use_std", "=", "_check_std_inds", "(", "use_std", ",", "num_obj", ")", "\n", "self", ".", "_obj_wgt", "=", "_check_obj_wgt", "(", "obj_wgt", ",", "num_obj", ")", "\n", "self", ".", "_doe_size", "=", "None", "\n", "self", ".", "_base_doe", "=", "None", "\n", "self", ".", "doe_size", "=", "doe_size", "\n", "self", ".", "base_doe", "=", "base_doe", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.base_doe": [[201, 228], ["isinstance", "predict.CondMom._is_valid_base", "bool", "predict.CondMom.full_space.inp_space.sto_obj_base_doe", "new_doe.copy"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom._is_valid_base", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.sto_obj_base_doe"], ["", "@", "base_doe", ".", "setter", "\n", "def", "base_doe", "(", "self", ",", "new_doe", ")", ":", "\n", "        ", "\"\"\"Base doe to use for the moment estimation\n        \n        Don't set this to an array with truncnorm and lognormal distributions\n        in the MultiVariate if you don't know exactly what you are doing.\n        \"\"\"", "\n", "# Sanity checks for base_doe. Using parameters with multiple valid types", "\n", "# may be an antipattern but it makes configuration easier from", "\n", "# the user point of view. Tolerate this for a better user experience.", "\n", "if", "isinstance", "(", "new_doe", ",", "np", ".", "ndarray", ")", ":", "\n", "            ", "if", "self", ".", "_is_valid_base", "(", "new_doe", ")", ":", "# raises errors", "\n", "                ", "self", ".", "_base_doe", "=", "new_doe", ".", "copy", "(", ")", "# Make our copy.", "\n", "", "return", "\n", "", "try", ":", "\n", "            ", "make_base_doe", "=", "bool", "(", "new_doe", ")", "\n", "", "except", "ValueError", ":", "\n", "            ", "return", "\n", "\n", "", "if", "make_base_doe", ":", "\n", "# Prepare doe with zero mean and unit variance", "\n", "            ", "doe", "=", "self", ".", "full_space", ".", "inp_space", ".", "sto_obj_base_doe", "(", "self", ".", "doe_size", ")", "\n", "self", ".", "_base_doe", "=", "doe", "\n", "return", "\n", "# if not bool(new_doe); remake new doe so set base_doe to None", "\n", "", "self", ".", "_base_doe", "=", "None", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom._is_valid_base": [[229, 240], ["len", "TypeError", "max", "ValueError", "abs", "abs", "new_doe.mean().max", "new_doe.std().max", "new_doe.mean", "new_doe.std"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std"], ["", "def", "_is_valid_base", "(", "self", ",", "new_doe", ")", ":", "\n", "# Assume numpy array", "\n", "        ", "n_sto_obj_inps", "=", "len", "(", "self", ".", "full_space", ".", "inp_space", ".", "inds", "[", "\"sto_obj\"", "]", ")", "\n", "if", "new_doe", ".", "shape", "[", "1", "]", "!=", "n_sto_obj_inps", ":", "\n", "            ", "msg", "=", "\"base_doe must be one of None, bool or a 2d array \"", "\n", "msg", "+=", "f\"with shape (num_samples, num_stochastic_objective_variables={n_sto_obj_inps}).\"", "\n", "raise", "TypeError", "(", "msg", ")", "\n", "", "if", "max", "(", "abs", "(", "new_doe", ".", "mean", "(", "0", ")", ".", "max", "(", ")", ")", ",", "abs", "(", "1", "-", "new_doe", ".", "std", "(", "0", ")", ".", "max", "(", ")", ")", ")", ">", "0.5", ":", "\n", "            ", "msg", "=", "\"base_doe must have zero mean and unit variance.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.doe_size": [[246, 252], ["None"], "methods", ["None"], ["", "@", "doe_size", ".", "setter", "\n", "def", "doe_size", "(", "self", ",", "new_size", ")", ":", "\n", "        ", "\"\"\"Size of the base doe to use for the moment estimation\"\"\"", "\n", "self", ".", "_doe_size", "=", "new_size", "\n", "if", "self", ".", "base_doe", "is", "not", "None", ":", "\n", "            ", "self", ".", "base_doe", "=", "new_size", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.obj_wgt": [[258, 263], ["len", "predict._check_obj_wgt"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._check_obj_wgt"], ["", "@", "obj_wgt", ".", "setter", "\n", "def", "obj_wgt", "(", "self", ",", "new_obj_wgt", ")", ":", "\n", "        ", "\"\"\"Weights for the linear combination of cond. moments\"\"\"", "\n", "n_obj", "=", "len", "(", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", ")", "\n", "self", ".", "_obj_wgt", "=", "_check_obj_wgt", "(", "new_obj_wgt", ",", "n_obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.use_std": [[269, 274], ["len", "predict._check_std_inds"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._check_std_inds"], ["", "@", "use_std", ".", "setter", "\n", "def", "use_std", "(", "self", ",", "new_std", ")", ":", "\n", "        ", "\"\"\"Indexes to use std. dev. instead of variance\"\"\"", "\n", "n_obj", "=", "len", "(", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", ")", "\n", "self", ".", "_use_std", "=", "_check_std_inds", "(", "new_std", ",", "n_obj", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.gen_doe": [[275, 299], ["predict.CondMom.full_space.inp_space.opt_moms", "numpy.ones", "predict.CondMom.base_doe.copy", "predict.CondMom.full_space.inp_space.opt_mulvar", "x_opt.reshape.reshape.reshape", "predict.CondMom.full_space.inp_space.sto_obj_doe", "predict.CondMom.dists[].marg.ppf", "predict.CondMom.full_space.inp_space.mv_inds", "enumerate"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_moms", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_mulvar", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.sto_obj_doe", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.mv_inds"], ["", "def", "gen_doe", "(", "self", ",", "x_opt", ")", ":", "\n", "        ", "\"\"\"Get DoE for the Moment estimation for x_opt\"\"\"", "\n", "if", "x_opt", ".", "ndim", "==", "1", ":", "\n", "            ", "x_opt", "=", "x_opt", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "self", ".", "base_doe", "is", "None", ":", "\n", "            ", "return", "self", ".", "full_space", ".", "inp_space", ".", "sto_obj_doe", "(", "x_opt", ",", "self", ".", "_doe_size", ")", "\n", "", "mean", ",", "std", "=", "self", ".", "full_space", ".", "inp_space", ".", "opt_moms", "(", "x_opt", ")", "\n", "names", "=", "self", ".", "full_space", ".", "inp_space", ".", "mulvar", ".", "names", "\n", "names", "=", "[", "names", "[", "i", "]", "for", "i", "in", "self", ".", "full_space", ".", "inp_space", ".", "mv_inds", "(", "\"sto_obj\"", ")", "]", "\n", "# Translating is not sufficient for lognormal and truncated normal", "\n", "inds", "=", "[", "i", "for", "i", ",", "x", "in", "enumerate", "(", "names", ")", "if", "\"log\"", "in", "x", "or", "\"trunc\"", "in", "x", "]", "\n", "if", "not", "inds", ":", "\n", "            ", "return", "self", ".", "base_doe", "*", "std", "+", "mean", "\n", "# Handle Lognormal", "\n", "", "binds", "=", "np", ".", "ones", "(", "self", ".", "base_doe", ".", "shape", "[", "1", "]", ",", "dtype", "=", "bool", ")", "\n", "binds", "[", "inds", "]", "=", "False", "\n", "base_doe", "=", "self", ".", "base_doe", ".", "copy", "(", ")", "\n", "base_doe", "[", ":", ",", "binds", "]", "=", "base_doe", "[", ":", ",", "binds", "]", "*", "std", "[", "binds", "]", "+", "mean", "[", "binds", "]", "\n", "mean", "=", "mean", "[", "inds", "]", "\n", "std", "=", "std", "[", "inds", "]", "\n", "cur_mv", "=", "self", ".", "full_space", ".", "inp_space", ".", "opt_mulvar", "(", "x_opt", ",", "domain", "=", "\"sto_obj\"", ")", "\n", "for", "ind", "in", "inds", ":", "\n", "            ", "base_doe", "[", ":", ",", "ind", "]", "=", "cur_mv", ".", "dists", "[", "ind", "]", ".", "marg", ".", "ppf", "(", "base_doe", "[", ":", ",", "ind", "]", ")", "\n", "", "return", "base_doe", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.est_mom": [[300, 333], ["predict.CondMom.gen_doe", "predict.CondMom.full_space.sto_obj", "numpy.mean", "numpy.zeros", "numpy.std", "numpy.logical_not", "numpy.var", "x_opt.reshape.reshape.reshape"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.gen_doe", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.sto_obj", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.var"], ["", "def", "est_mom", "(", "self", ",", "x_opt", ")", ":", "\n", "        ", "\"\"\" Estimate conditional moments for a single optimization point x_opt\n\n            Conditional moments are E[Y | x_opt] and Var[Y | x_opt]\n\n            Parameters\n            ----------\n            x_opt : numpy.ndarray\n                the coordinates of the optimization variables to compute\n                the moments\n            Returns\n            -------\n            mus : numpy.ndarray\n                Estimated means, or if obj_wgt was not None,\n                the combined mu + obj_wgt * sigma\n\n            sigmas : numpy.ndarray\n                Estimated variances or std. dev. depending on the settings.\n                only returned if obj_wgt is None.\n        \"\"\"", "\n", "if", "x_opt", ".", "ndim", "==", "1", ":", "\n", "            ", "x_opt", "=", "x_opt", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "doe", "=", "self", ".", "gen_doe", "(", "x_opt", ")", "\n", "res", "=", "self", ".", "full_space", ".", "sto_obj", "(", "doe", ",", "x_opt", ")", "\n", "mus", "=", "np", ".", "mean", "(", "res", ",", "axis", "=", "0", ")", "\n", "sigmas", "=", "np", ".", "zeros", "(", "mus", ".", "shape", ")", "\n", "std_inds", "=", "self", ".", "use_std", "\n", "sigmas", "[", "std_inds", "]", "=", "np", ".", "std", "(", "res", "[", ":", ",", "std_inds", "]", ",", "axis", "=", "0", ",", "ddof", "=", "1", ")", "\n", "var_inds", "=", "np", ".", "logical_not", "(", "std_inds", ")", "\n", "sigmas", "[", "var_inds", "]", "=", "np", ".", "var", "(", "res", "[", ":", ",", "var_inds", "]", ",", "axis", "=", "0", ",", "ddof", "=", "1", ")", "\n", "if", "self", ".", "obj_wgt", "is", "None", ":", "\n", "            ", "return", "mus", ",", "sigmas", "\n", "", "return", "mus", "+", "self", ".", "obj_wgt", "*", "sigmas", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba.__init__": [[384, 419], ["predict._n_para_chk", "predict._make_chain", "predict.CondProba._prob_tol", "predict._default_init", "predict.CondProba.call_args.keys", "numpy.max", "numpy.max", "predict._is_worker", "ValueError", "numpy.mean", "numpy.std", "ValueError", "duqo.doe.lhs.make_doe", "abs", "abs", "scipy.stats.norm", "range"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._n_para_chk", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._make_chain", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba._prob_tol", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._default_init", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._is_worker", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean", "home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.std", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe"], ["def", "__init__", "(", "self", ",", "target_fail_prob", ":", "float", ",", "num_inputs", ":", "int", ",", "num_parallel", ":", "int", "=", "4", ",", "\n", "methods", ":", "typing", ".", "Optional", "[", "typing", ".", "Union", "[", "str", ",", "list", "]", "]", "=", "None", ",", "call_args", ":", "typing", ".", "Optional", "[", "dict", "]", "=", "None", ",", "\n", "target_tol", ":", "float", "=", "0.01", ")", ":", "\n", "        ", "self", ".", "n_inp", "=", "num_inputs", "\n", "num_para", "=", "_n_para_chk", "(", "num_parallel", ")", "\n", "cargs", "=", "{", "\"num_parallel\"", ":", "num_para", ",", "\"multi_region\"", ":", "True", "}", "\n", "if", "methods", "is", "None", ":", "\n", "            ", "methods", ",", "cargs", "=", "_default_init", "(", "target_fail_prob", ",", "target_tol", ",", "\n", "num_inputs", ",", "num_para", ")", "\n", "", "if", "call_args", "is", "None", ":", "\n", "            ", "self", ".", "call_args", "=", "{", "**", "cargs", "}", "\n", "", "else", ":", "\n", "            ", "self", ".", "call_args", "=", "{", "**", "cargs", ",", "**", "call_args", "}", "\n", "", "self", ".", "_tar_fp", "=", "target_fail_prob", "\n", "self", ".", "_tar_tol", "=", "target_tol", "\n", "self", ".", "workers", "=", "_make_chain", "(", "methods", ")", "\n", "self", ".", "_prob_tol", "(", ")", "\n", "if", "\"doe\"", "in", "self", ".", "call_args", ".", "keys", "(", ")", ":", "\n", "            ", "doe", "=", "self", ".", "call_args", "[", "\"doe\"", "]", "\n", "if", "doe", ".", "shape", "[", "1", "]", "!=", "self", ".", "n_inp", ":", "\n", "                ", "msg", "=", "f\"Shape mismatch between the number of inputs ({self.n_inp}) \"", "\n", "msg", "+=", "f\"and the DoE {doe.shape[1]}\"", "\n", "raise", "ValueError", "(", ")", "\n", "", "mu_max", "=", "np", ".", "max", "(", "np", ".", "mean", "(", "doe", ",", "axis", "=", "0", ")", ")", "\n", "sig_max", "=", "np", ".", "max", "(", "np", ".", "std", "(", "doe", ",", "axis", "=", "0", ")", ")", "\n", "if", "abs", "(", "mu_max", ")", ">", "1e-10", "or", "abs", "(", "sig_max", "-", "1", ")", ">", "1e-10", ":", "\n", "                ", "msg", "=", "\"Zero mean and unit variance is required for doe \"", "\n", "msg", "+=", "\"in call_args, found mean == {mu_max} and \"", "\n", "msg", "+=", "\"sigma == {sig_max} columns\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "", "elif", "_is_worker", "(", "self", ".", "workers", ",", "\"ISPUD\"", ")", ":", "\n", "            ", "margs", "=", "[", "stats", ".", "norm", "(", ")", "for", "k", "in", "range", "(", "self", ".", "n_inp", ")", "]", "\n", "self", ".", "call_args", "[", "\"doe\"", "]", "=", "make_doe", "(", "100", ",", "margs", ",", "num_tries", "=", "1000", ")", "\n", "", "self", ".", "call_args", "[", "\"post_proc\"", "]", "=", "False", "\n", "self", ".", "call_args", "[", "\"num_parallel\"", "]", "=", "num_para", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba.target_fail_prob": [[425, 433], ["predict.CondProba._prob_tol", "ValueError"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba._prob_tol"], ["", "@", "target_fail_prob", ".", "setter", "\n", "def", "target_fail_prob", "(", "self", ",", "new_fp", ")", ":", "\n", "        ", "\"\"\"target failure probability\"\"\"", "\n", "if", "new_fp", "<=", "0", "or", "new_fp", ">", "0.9", ":", "\n", "            ", "msg", "=", "\"Target failure probability should lie in the interval (0,0.9]\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "self", ".", "_tar_fp", "=", "new_fp", "\n", "self", ".", "_prob_tol", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba.target_tol": [[439, 447], ["predict.CondProba._prob_tol", "ValueError"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba._prob_tol"], ["", "@", "target_tol", ".", "setter", "\n", "def", "target_tol", "(", "self", ",", "new_tol", ")", ":", "\n", "        ", "\"\"\"Target accuracy for failure probability estimation\"\"\"", "\n", "if", "new_tol", "<=", "0", "or", "new_tol", ">", "0.9", ":", "\n", "            ", "msg", "=", "\"Target probability accuracy should lie in the interval (0,0.9]\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "self", ".", "_tar_tol", "=", "new_tol", "\n", "self", ".", "_prob_tol", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba._prob_tol": [[448, 455], ["predict._is_worker", "warnings.warn"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._is_worker"], ["", "def", "_prob_tol", "(", "self", ")", ":", "\n", "        ", "prob_tol", "=", "self", ".", "_tar_fp", "*", "self", ".", "_tar_tol", "\n", "if", "_is_worker", "(", "self", ".", "workers", ",", "\"MC\"", ")", "and", "prob_tol", "<", "1e-6", ":", "\n", "            ", "msg", "=", "\"Crude Monte Carlo can be very inefficient for \"", "\n", "msg", "+=", "\"such low probabilities of failure.\"", "\n", "warnings", ".", "warn", "(", "msg", ")", "\n", "", "self", ".", "call_args", "[", "\"prob_tol\"", "]", "=", "prob_tol", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondProba.calc_fail_prob": [[456, 513], ["ValueError", "worker", "predict.read_integrator_name", "print", "predict.read_integrator_name", "print", "worker.calc_fail_prob", "print", "print", "print"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.read_integrator_name", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.read_integrator_name", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.calc_fail_prob"], ["", "def", "calc_fail_prob", "(", "self", ",", "input_mv", ",", "constraints", ",", "const_args", ",", "verbose", ":", "int", "=", "0", ")", ":", "\n", "        ", "\"\"\" Calculate failure probability using the worker chain\n\n        Parameters\n        ----------\n\n        input_mv : MultiVar instance\n            Definition of the multivariate input\n\n        constraints : list\n            constraint functions to initialize the integrator\n\n        const_args : None or list\n            arguments to pass to the constraints\n\n        Returns:\n        --------\n        pof : float\n            probability of failure\n\n        feasible : bool\n            pof <= target_pf\n\n        \"\"\"", "\n", "if", "not", "self", ".", "workers", ":", "\n", "            ", "raise", "ValueError", "(", "\"No estimators defined\"", ")", "\n", "\n", "", "for", "worker", "in", "self", ".", "workers", ":", "\n", "            ", "estimator", "=", "worker", "(", "input_mv", ",", "constraints", ",", "const_args", ")", "\n", "try", ":", "\n", "                ", "pof", "=", "estimator", ".", "calc_fail_prob", "(", "**", "self", ".", "call_args", ")", "[", "0", "]", "\n", "", "except", "ValueError", ":", "\n", "                ", "if", "worker", "==", "self", ".", "workers", "[", "-", "1", "]", ":", "\n", "                    ", "print", "(", "\"Fatal error while calculating probability of failure with\"", ",", "worker", ")", "\n", "print", "(", "input_mv", ")", "\n", "print", "(", "\"Setting it to 100%.\"", ")", "\n", "pof", "=", "1.", "\n", "", "continue", "\n", "\n", "", "if", "verbose", ">", "1", ":", "\n", "                ", "name", "=", "read_integrator_name", "(", "worker", ")", "\n", "print", "(", "f\"{name} estimated the failure probability as {pof:.2e}.\"", ")", "\n", "\n", "", "if", "pof", ">", "self", ".", "_tar_fp", ":", "\n", "                ", "prob_ratio", "=", "self", ".", "_tar_fp", "/", "pof", "\n", "", "else", ":", "\n", "                ", "prob_ratio", "=", "pof", "/", "self", ".", "_tar_fp", "\n", "", "if", "prob_ratio", "<=", "self", ".", "_tar_tol", ":", "\n", "                ", "break", "\n", "\n", "", "", "if", "verbose", ">", "0", ":", "\n", "            ", "try", ":", "\n", "                ", "name", "=", "read_integrator_name", "(", "worker", ")", "\n", "print", "(", "f\"{name} estimated the failure probability as {pof:.2e}.\"", ")", "\n", "", "except", "NameError", ":", "\n", "                ", "pass", "\n", "", "", "return", "pof", ",", "pof", "<=", "self", ".", "_tar_fp", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._check_obj_wgt": [[19, 32], ["numpy.array().ravel", "len", "ValueError", "numpy.array", "numpy.ones", "len"], "function", ["None"], ["def", "_check_obj_wgt", "(", "obj_weights", ",", "num_obj", ")", ":", "\n", "    ", "\"\"\" Check obj_wgt argument passed to CondMom \"\"\"", "\n", "if", "obj_weights", "is", "None", ":", "\n", "        ", "return", "None", "\n", "", "try", ":", "\n", "        ", "_", "=", "obj_weights", "[", "0", "]", "\n", "", "except", "(", "TypeError", ",", "IndexError", ")", ":", "\n", "        ", "obj_weights", "=", "np", ".", "ones", "(", "num_obj", ")", "*", "obj_weights", "\n", "", "if", "len", "(", "obj_weights", ")", "!=", "num_obj", ":", "\n", "        ", "msg", "=", "f\"Mismatch between the number of entries ({len(obj_weights)} in \"", "\n", "msg", "+=", "f\"obj_wgt and the number of stochastic objectives ({num_obj}).\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "return", "np", ".", "array", "(", "obj_weights", ")", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._check_std_inds": [[34, 45], ["isinstance", "numpy.array", "len", "ValueError"], "function", ["None"], ["", "def", "_check_std_inds", "(", "use_std", ",", "num_obj", ")", ":", "\n", "    ", "\"\"\" Check use_std argument passed to CondMom and\n        convert it to a slice definition\n    \"\"\"", "\n", "if", "isinstance", "(", "use_std", ",", "bool", ")", ":", "\n", "        ", "inds", "=", "[", "use_std", "]", "*", "num_obj", "\n", "", "if", "len", "(", "inds", ")", "!=", "num_obj", ":", "\n", "        ", "msg", "=", "\"Mismatch between the number of entries in \"", "\n", "msg", "+=", "\"use_std and the number of stochastic objectives.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "return", "np", ".", "array", "(", "use_std", ",", "dtype", "=", "bool", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._find_integrator_cls": [[47, 66], ["integrator.upper.upper", "ValueError"], "function", ["None"], ["", "def", "_find_integrator_cls", "(", "integrator", ")", ":", "\n", "    ", "\"\"\"\n        Find the Integrator class as defined by the string integrator\n    \"\"\"", "\n", "integrator", "=", "integrator", ".", "upper", "(", ")", "\n", "if", "integrator", "==", "\"DS\"", ":", "\n", "        ", "IntCls", "=", "DS", "\n", "", "elif", "integrator", "==", "\"MC\"", ":", "\n", "        ", "IntCls", "=", "MC", "\n", "", "elif", "integrator", "==", "\"ISPUD\"", ":", "\n", "        ", "IntCls", "=", "ISPUD", "\n", "", "elif", "integrator", "==", "\"FORM\"", ":", "\n", "        ", "IntCls", "=", "FORM", "\n", "", "elif", "integrator", "==", "\"SUSE\"", ":", "\n", "        ", "IntCls", "=", "SUSE", "\n", "", "else", ":", "\n", "        ", "msg", "=", "f\"Requested integrator {integrator} is not found.\"", "\n", "raise", "ValueError", "(", "msg", ")", "\n", "", "return", "IntCls", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._make_chain": [[68, 80], ["first.upper", "predict._find_integrator_cls", "TypeError", "name.upper", "type"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._find_integrator_cls"], ["", "def", "_make_chain", "(", "methods", ":", "list", ")", ":", "\n", "    ", "\"\"\"Makes the chain given a list of method names\"\"\"", "\n", "try", ":", "\n", "        ", "first", "=", "methods", "[", "0", "]", "\n", "", "except", "TypeError", ":", "\n", "        ", "raise", "TypeError", "(", "f\"methods must be a list of strings or classes, not {type(methods)}\"", ")", "\n", "", "try", ":", "\n", "        ", "_", "=", "first", ".", "upper", "(", ")", "\n", "", "except", "AttributeError", ":", "\n", "        ", "return", "methods", "\n", "\n", "", "return", "[", "_find_integrator_cls", "(", "name", ".", "upper", "(", ")", ")", "for", "name", "in", "methods", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._n_para_chk": [[82, 89], ["max", "multiprocessing.cpu_count", "print"], "function", ["None"], ["", "def", "_n_para_chk", "(", "num_parallel", ":", "int", "=", "None", ")", ":", "\n", "    ", "\"\"\" Check the num_parallel argument as passed to CondProb \"\"\"", "\n", "n_procs", "=", "max", "(", "1", ",", "mp", ".", "cpu_count", "(", ")", ")", "# could cpu_count ever be < 1?", "\n", "if", "num_parallel", "is", "None", "or", "num_parallel", ">", "n_procs", ":", "\n", "        ", "print", "(", "f\"Number of parallel processes was set to {n_procs}\"", ")", "\n", "return", "n_procs", "\n", "", "return", "num_parallel", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._default_init": [[91, 128], ["print"], "function", ["None"], ["", "def", "_default_init", "(", "targ_prob", ":", "float", ",", "acc_max", ":", "float", ",", "num_inp", ":", "int", ",", "\n", "num_para", ":", "int", ")", ":", "\n", "    ", "\"\"\"Decide the default integrator chain methods and arguments depending\n    on the problem\n\n    Parameters\n    ----------\n    targ_prob : float\n        target failure probability\n    acc_max : float\n        target tolerance for the estimation\n    num_inp : int\n        number of stochastic inputs of the constraints\n    num_para : int\n        number of parallel processes to use\n\n    Returns\n    -------\n    integrators : list\n        Integrator classes, that are to be initiated\n    int_args : dict\n        Keyword arguments to pass to integrators\n    \"\"\"", "\n", "if", "targ_prob", "*", "acc_max", ">=", "1e-5", ":", "\n", "        ", "if", "targ_prob", "*", "acc_max", ">=", "1e-4", ":", "\n", "            ", "integrators", "=", "[", "\"MC\"", "]", "\n", "", "else", ":", "\n", "            ", "integrators", "=", "[", "\"SUSE\"", ",", "\"MC\"", "]", "\n", "", "int_args", "=", "{", "\"num_starts\"", ":", "1", ",", "\"batch_size\"", ":", "1e5", "}", "\n", "", "elif", "num_inp", "<", "15", ":", "\n", "        ", "integrators", "=", "[", "\"SUSE\"", ",", "\"DS\"", "]", "\n", "int_args", "=", "{", "\"num_starts\"", ":", "1", "}", "\n", "", "else", ":", "\n", "        ", "integrators", "=", "[", "\"SUSE\"", "]", "\n", "int_args", "=", "{", "\"num_starts\"", ":", "num_para", "}", "\n", "", "print", "(", "\"Using\"", ",", "integrators", ",", "\"as default chain.\"", ")", "\n", "return", "integrators", ",", "int_args", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict._is_worker": [[130, 137], ["predict.read_integrator_name", "name.upper", "read_integrator_name.upper"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.read_integrator_name"], ["", "def", "_is_worker", "(", "workers", ",", "name", ")", ":", "\n", "    ", "\"\"\" check if name is in workers list of classes\"\"\"", "\n", "for", "worker", "in", "workers", ":", "\n", "        ", "wname", "=", "read_integrator_name", "(", "worker", ")", "\n", "if", "name", ".", "upper", "(", ")", "in", "wname", ".", "upper", "(", ")", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.read_integrator_name": [[139, 143], ["str().split", "str", "c.isalnum"], "function", ["None"], ["", "def", "read_integrator_name", "(", "worker", ")", ":", "\n", "    ", "\"\"\" read the name of the integrator instance worker \"\"\"", "\n", "name", "=", "str", "(", "worker", ")", ".", "split", "(", "\".\"", ")", "[", "-", "1", "]", "\n", "return", "\"\"", ".", "join", "(", "[", "c", "for", "c", "in", "name", "if", "c", ".", "isalnum", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.__init__": [[50, 71], ["duqo.optimization.predict.CondMom", "hasattr", "TypeError", "int", "hasattr", "TypeError", "numpy.sum", "duqo.optimization.predict.CondProba", "type"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "full_space", ":", "FullSpace", ",", "targ_fp", ":", "float", "=", "None", ",", "\n", "co_fp", ":", "CondProba", "=", "None", ",", "co_mom", ":", "CondMom", "=", "None", ",", "opt_chk", "=", "None", ")", ":", "\n", "        ", "self", ".", "full_space", "=", "full_space", "\n", "if", "co_mom", "is", "None", ":", "\n", "            ", "co_mom", "=", "CondMom", "(", "full_space", ")", "\n", "", "if", "not", "hasattr", "(", "co_mom", ",", "\"est_mom\"", ")", ":", "\n", "            ", "raise", "TypeError", "(", "\"If passed, co_mom must be a CondMom instance.\"", ")", "\n", "", "self", ".", "co_mom", "=", "co_mom", "\n", "if", "co_fp", "is", "None", ":", "\n", "            ", "if", "targ_fp", "is", "None", ":", "\n", "                ", "targ_fp", "=", "1e-2", "\n", "", "n_sto_con_inps", "=", "int", "(", "np", ".", "sum", "(", "full_space", ".", "inp_space", ".", "inds", "[", "\"sto_con\"", "]", ")", ")", "\n", "if", "n_sto_con_inps", ">", "1", ":", "\n", "                ", "co_fp", "=", "CondProba", "(", "targ_fp", ",", "n_sto_con_inps", ")", "\n", "", "", "elif", "targ_fp", "is", "not", "None", ":", "\n", "            ", "co_fp", ".", "target_fail_prob", "=", "targ_fp", "\n", "", "if", "not", "hasattr", "(", "co_fp", ",", "\"calc_fail_prob\"", ")", ":", "\n", "            ", "raise", "TypeError", "(", "f\"If passed, co_fp must be a CondProba instance. Got  {type(co_fp)}.\"", ")", "\n", "", "self", ".", "co_fp", "=", "co_fp", "\n", "self", ".", "opt_chk", "=", "opt_chk", "\n", "self", ".", "evaluate", "=", "self", ".", "obj_con", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.obj": [[72, 111], ["duqo.optimization.space.check_shape", "rrdo.RRDO._stoch_obj", "rrdo.RRDO.full_space.inp_space.inds[].sum", "rrdo.RRDO.full_space.det_obj", "numpy.hstack"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO._stoch_obj", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.det_obj"], ["", "def", "obj", "(", "self", ",", "x_opt", ",", "det_objs", "=", "None", ")", ":", "\n", "        ", "\"\"\" Evaluates all objectives in deterministic and stochastic\n        space\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            A single point in the optimization space\n\n        det_objs : None or numpy.ndarray\n            Deterministic objective values. If None, will be computed\n            from the user supplied function obj_fun. It passed, must be\n            a 2-d array with shape (num_sample, num_objectives)\n\n        Returns\n        -------\n        objs : numpy.ndarray\n            Values of the objective functions. Columns correspond to the\n            individual objectives and rows to the individual points in\n            the same order as x_opt. If stochastic objectives are\n            defined, the shape of this will differ from the original\n            number of objectives, if AlgoSettings.objective_weights\n            is not passed.\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "full_space", ".", "inp_space", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\n", "parent", "=", "\"obj\"", ")", "\n", "rob_w", "=", "self", ".", "co_mom", ".", "obj_wgt", "\n", "if", "det_objs", "is", "None", ":", "\n", "            ", "det_objs", "=", "self", ".", "full_space", ".", "det_obj", "(", "x_opt", ")", "\n", "\n", "", "if", "not", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", ":", "\n", "# Why are you using this again?", "\n", "            ", "return", "det_objs", "\n", "\n", "", "if", "rob_w", "is", "None", ":", "\n", "            ", "objs", "=", "np", ".", "hstack", "(", "(", "det_objs", ",", "det_objs", "[", ":", ",", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", "]", ")", ")", "\n", "", "else", ":", "\n", "            ", "objs", "=", "det_objs", "\n", "", "return", "self", ".", "_stoch_obj", "(", "x_opt", ",", "objs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO._stoch_obj": [[112, 124], ["range", "rrdo.RRDO.co_mom.est_mom", "rrdo.RRDO.co_mom.est_mom"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.est_mom", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.est_mom"], ["", "def", "_stoch_obj", "(", "self", ",", "x_opt", ",", "objs", ")", ":", "\n", "        ", "rob_w", "=", "self", ".", "co_mom", ".", "obj_wgt", "\n", "for", "i_design", "in", "range", "(", "x_opt", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "x_curr", "=", "x_opt", "[", "[", "i_design", "]", ",", ":", "]", "\n", "if", "rob_w", "is", "None", ":", "\n", "                ", "mean", ",", "sigma", "=", "self", ".", "co_mom", ".", "est_mom", "(", "x_curr", ")", "\n", "objs", "[", "i_design", ",", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", "]", "=", "mean", "\n", "objs", "[", "i_design", ",", "self", ".", "full_space", ".", "dims", "[", "0", "]", ":", "]", "=", "sigma", "\n", "", "else", ":", "\n", "                ", "objs", "[", "i_design", ",", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", "]", "=", "self", ".", "co_mom", ".", "est_mom", "(", "x_curr", ")", "\n", "", "", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.con": [[125, 182], ["duqo.optimization.space.check_shape", "numpy.array().reshape", "range", "rrdo.RRDO.full_space.inp_space.inds[].sum", "rrdo.RRDO.full_space.det_con", "det_cons.reshape.reshape.reshape", "numpy.min", "rrdo.RRDO.full_space.inp_space.opt_mulvar", "rrdo.RRDO.co_fp.calc_fail_prob", "numpy.array", "numpy.logical_not"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.det_con", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_mulvar", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.calc_fail_prob"], ["", "def", "con", "(", "self", ",", "x_opt", ",", "det_cons", "=", "None", ",", "verbose", "=", "0", ")", ":", "\n", "        ", "\"\"\" Evaluates all constraints in deterministic\n        and stochastic space\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            A single point in the optimization space\n\n        det_cons : None or numpy.ndarray\n            Deterministic evaluation of the constraints for x_opt. If None, it\n            will be computed from the user supplied function con_fun\n\n        verbose : int or float\n            a number to adjust the verbosity. Currently, anything > 1\n            displays all prints.\n\n        Returns\n        -------\n        feasible : numpy.ndarray(dtype=bool)\n            A boolean array corresponding to the feasibility of each passed\n            candidate in x_opt.  It checks for deterministic and stochastic\n            constraints\n        fail_probs : numpy.ndarray\n            Calculated probabilities of failure for each candidate. Note that\n            if the evaluation is skipped due to infeasibility, the probability\n            of failure is returned as 1 (i.e. 100 %)\n        det_cons : numpy.ndarray\n            Values of the deterministic evaluation of the constraints.\n            The columns correspond to the constraints and\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "full_space", ".", "inp_space", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\n", "parent", "=", "\"con\"", ")", "\n", "if", "det_cons", "is", "None", ":", "\n", "            ", "det_cons", "=", "self", ".", "full_space", ".", "det_con", "(", "x_opt", ")", "\n", "", "if", "det_cons", ".", "ndim", "==", "1", ":", "\n", "            ", "det_cons", "=", "det_cons", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "", "feasible", "=", "np", ".", "min", "(", "det_cons", ",", "axis", "=", "1", ")", ">=", "0", "\n", "fail_probs", "=", "np", ".", "array", "(", "np", ".", "logical_not", "(", "feasible", ")", ",", "\n", "dtype", "=", "np", ".", "float64", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "if", "not", "self", ".", "full_space", ".", "con_inds", "[", "\"sto\"", "]", ":", "# Why are you using this again?", "\n", "            ", "return", "feasible", ",", "det_cons", ",", "fail_probs", "\n", "\n", "", "for", "i_design", "in", "range", "(", "x_opt", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "not", "feasible", "[", "i_design", "]", ":", "\n", "                ", "fail_probs", "[", "i_design", ",", ":", "]", "=", "1.", "\n", "", "x_curr", "=", "x_opt", "[", "[", "i_design", "]", ",", ":", "]", "\n", "curr_mv", "=", "self", ".", "full_space", ".", "inp_space", ".", "opt_mulvar", "(", "x_curr", ")", "\n", "\n", "fprob", ",", "feas", "=", "self", ".", "co_fp", ".", "calc_fail_prob", "(", "curr_mv", ",", "\n", "[", "self", ".", "full_space", ".", "sto_con", "]", ",", "\n", "[", "x_curr", "]", ",", "verbose", "=", "verbose", ")", "\n", "fail_probs", "[", "i_design", ",", ":", "]", "=", "fprob", "\n", "feasible", "[", "i_design", "]", "=", "feas", "\n", "", "return", "feasible", ",", "fail_probs", ",", "det_cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.obj_con": [[183, 268], ["duqo.optimization.space.check_shape", "rrdo.RRDO.full_space.det_obj", "numpy.ones", "range", "rrdo.RRDO.full_space.inp_space.inds[].sum", "rrdo.RRDO.full_space.det_con", "numpy.zeros", "det_cons.reshape.reshape.reshape", "numpy.min", "numpy.hstack", "print", "rrdo.RRDO._stoch_obj", "rrdo.RRDO.full_space.inp_space.opt2full", "rrdo.RRDO.opt_chk", "print", "print", "rrdo.RRDO.con"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.check_shape", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.det_obj", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.FullSpace.det_con", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO._stoch_obj", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt2full", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.con"], ["", "def", "obj_con", "(", "self", ",", "x_opt", ",", "verbose", ":", "int", "=", "0", ")", ":", "\n", "        ", "\"\"\"Evaluates the defined problem\n        Should only be called after define\n\n        Parameters\n        ----------\n        x_opt : numpy.ndarray\n            a 2-D array with rows corresponding to the individual points or\n            candidates and the columns corresponding to the individual\n            dimensions in the optimization space.\n        verbose : int or float\n            a number to adjust the verbosity. Currently, anything > 1\n            displays all prints.\n\n        Returns\n        -------\n        objs : numpy.ndarray\n            Values of the objective functions. Columns correspond to the\n            individual objectives and rows to the individual points in\n            the same order as x_opt. If stochastic objectives are\n            defined, the shape of this will differ from the original\n            number of objectives, if AlgoSettings.objective_weights\n            is not passed.\n            In that case, the estimated means are returned in the\n            same columns as the stochastic objectives. Furthermore, the matrix\n            will be extendend with the same number of columns as the number\n            of stochastic objectives. These last columns will correspond\n            the variances (or std. deviations if settings.use_objective_std\n            is True).\n        feasible : numpy.ndarray(dtype=bool)\n            A boolean array corresponding to the feasibility of each passed\n            candidate in x_opt.  It checks for deterministic and stochastic\n            constraints\n        det_cons : numpy.ndarray\n            Values of the deterministic evaluation of the constraints.\n            The columns correspond to the constraints and\n        fail_probs : numpy.ndarray\n            Calculated probabilities of failure for each candidate. Note that\n            if the evaluation is skipped due to infeasibility, the probability\n            of failure is returned as 1 (i.e. 100 %)\n\n        All returned arrays except feasible are two-dimensional\n        \"\"\"", "\n", "x_opt", "=", "check_shape", "(", "x_opt", ",", "self", ".", "full_space", ".", "inp_space", ".", "inds", "[", "\"opt\"", "]", ".", "sum", "(", ")", ",", "\n", "parent", "=", "\"obj_con\"", ")", "\n", "if", "self", ".", "full_space", ".", "dims", "[", "1", "]", ">", "0", ":", "\n", "            ", "det_cons", "=", "self", ".", "full_space", ".", "det_con", "(", "x_opt", ")", "\n", "", "else", ":", "\n", "            ", "det_cons", "=", "np", ".", "zeros", "(", "x_opt", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "", "if", "det_cons", ".", "ndim", "==", "1", ":", "\n", "            ", "det_cons", "=", "det_cons", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "objs", "=", "self", ".", "full_space", ".", "det_obj", "(", "x_opt", ")", "\n", "fail_probs", "=", "np", ".", "ones", "(", "(", "x_opt", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "feasible", "=", "np", ".", "min", "(", "det_cons", ",", "axis", "=", "1", ")", ">=", "0", "\n", "if", "not", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", "and", "not", "self", ".", "full_space", ".", "con_inds", "[", "\"sto\"", "]", ":", "\n", "# Why are you using this again?", "\n", "            ", "return", "objs", ",", "feasible", ",", "det_cons", ",", "fail_probs", "\n", "\n", "", "if", "self", ".", "co_mom", ".", "obj_wgt", "is", "None", "and", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", ":", "\n", "            ", "objs", "=", "np", ".", "hstack", "(", "(", "objs", ",", "objs", "[", ":", ",", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", "]", ")", ")", "\n", "\n", "", "for", "i_design", "in", "range", "(", "x_opt", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "not", "feasible", "[", "i_design", "]", "and", "verbose", ">", "0", ":", "\n", "                ", "print", "(", "f\"Skipping design {i_design} due to infeasibility.\"", ")", "\n", "", "if", "feasible", "[", "i_design", "]", ":", "\n", "                ", "x_curr", "=", "x_opt", "[", "[", "i_design", "]", ",", ":", "]", "\n", "if", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", ":", "\n", "                    ", "curr_obj", "=", "objs", "[", "[", "i_design", "]", ",", ":", "]", "\n", "objs", "[", "i_design", ",", ":", "]", "=", "self", ".", "_stoch_obj", "(", "x_curr", ",", "curr_obj", ")", "\n", "", "is_opt", "=", "True", "\n", "if", "self", ".", "opt_chk", "is", "not", "None", ":", "\n", "                    ", "x_f", "=", "self", ".", "full_space", ".", "inp_space", ".", "opt2full", "(", "x_curr", ")", "\n", "is_opt", "=", "self", ".", "opt_chk", "(", "x_f", ",", "objs", "[", "i_design", ",", ":", "]", ")", "\n", "if", "not", "is_opt", "and", "verbose", ">", "0", ":", "\n", "                        ", "print", "(", "f\"Skipping candidate {i_design} due to inoptimality\"", ")", "\n", "feasible", "[", "i_design", "]", "=", "False", "# To match returned failure probability", "\n", "", "", "if", "self", ".", "full_space", ".", "con_inds", "[", "\"sto\"", "]", "and", "is_opt", ":", "\n", "                    ", "if", "verbose", ">", "0", ":", "\n", "                        ", "print", "(", "f\"Candidate {i_design}:\"", ",", "end", "=", "\" \"", ")", "\n", "", "res", "=", "self", ".", "con", "(", "x_curr", ",", "det_cons", "[", "[", "i_design", "]", ",", ":", "]", ",", "\n", "verbose", "=", "verbose", ")", "[", ":", "2", "]", "\n", "fail_probs", "[", "i_design", ",", ":", "]", "=", "res", "[", "1", "]", "\n", "feasible", "[", "i_design", "]", "=", "res", "[", "0", "]", "\n", "", "", "", "return", "objs", ",", "feasible", ",", "det_cons", ",", "fail_probs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.gen_post_proc": [[269, 362], ["numpy.array", "x_cur.reshape.reshape.reshape", "ValueError", "copy.deepcopy", "rrdo.RRDO.full_space.inp_space.opt_mulvar", "rrdo.RRDO.co_mom.gen_doe", "rrdo.RRDO.full_space.inp_space.stoch2full", "rrdo.RRDO.co_mom.est_mom", "int_lib", "rrdo.RRDO.co_mom.obj_wgt.copy", "rrdo.RRDO.co_mom.est_mom", "duqo.optimization.predict.read_integrator_name", "int_lib.calc_fail_prob", "numpy.unique", "numpy.empty", "numpy.unique", "numpy.empty", "numpy.unique", "numpy.empty", "rrdo.RRDO.full_space.inp_space.stoch2full", "rrdo.RRDO.full_space.inp_space.stoch2full", "rrdo.RRDO.full_space.inp_space.stoch2full"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.opt_mulvar", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.gen_doe", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.est_mom", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.CondMom.est_mom", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.read_integrator_name", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.calc_fail_prob", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.stoch2full"], ["", "def", "gen_post_proc", "(", "self", ",", "x_opt", ",", "moment", "=", "True", ",", "proba", "=", "True", ")", ":", "\n", "        ", "\"\"\"Gather all samples used for the stochastic assessments\n        for an optimization candidate x_curr.\n\n        Parameters\n        ----------\n        x_opt : list or numpy.ndarray\n            A single point defined in the optimization space i.e. containing\n            the values of the optimization parameters. The stochastic values\n            are read from the MultiVariate model.\n\n        Returns\n        -------\n        proba_res : dict\n            results of the probabilistic assesment with the following keys for\n            each integrator:\n                *`fail_prob` -- estimated probability of failure\n                *`est_var`-- variance of the estimation\n                *`safety_index` -- Safety index, also known as the sigma level.\n                It is equal to Phi_inv(1-fail_prob_mu), where Phi_inv is the\n                inverse of the CDF of standard normal distribution\n                *`mpp` -- Most probable point of failure as found by the integrator\n                *'safe_samp` - generated samples in the safe domain (`min(c)>=0`)\n                *'fail_samp` - generated samples in the failure domain (`min(c)<0`)\n                *'limit_state` - generated samples on the limit state (`min(c)==0`)\n\n        Note that this method will recompute the post processing data, as the\n        data is not saved during the optimization.\n        \"\"\"", "\n", "\n", "x_cur", "=", "np", ".", "array", "(", "x_opt", ")", "\n", "if", "x_cur", ".", "ndim", ">", "1", "and", "x_cur", ".", "shape", "[", "0", "]", ">", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\n", "f\"x_opt must be a single point, not {x_cur.shape[0]}.\"", ")", "\n", "", "x_cur", "=", "x_cur", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "proba_res", ",", "rob_res", "=", "{", "}", ",", "{", "}", "\n", "if", "self", ".", "full_space", ".", "con_inds", "[", "\"sto\"", "]", "and", "proba", ":", "\n", "            ", "pp_int", "=", "deepcopy", "(", "self", ".", "co_fp", ")", "\n", "pp_int", ".", "call_args", "[", "\"post_proc\"", "]", "=", "True", "\n", "pp_int", ".", "call_args", "[", "\"num_parallel\"", "]", "=", "1", "\n", "cur_mv", "=", "self", ".", "full_space", ".", "inp_space", ".", "opt_mulvar", "(", "x_cur", ")", "\n", "# Hack for Diss", "\n", "workers", "=", "[", "pp_int", ".", "workers", "[", "-", "1", "]", "]", "\n", "for", "int_lib", "in", "workers", ":", "\n", "                ", "estimator", "=", "int_lib", "(", "cur_mv", ",", "[", "self", ".", "full_space", ".", "sto_con", "]", ",", "[", "x_cur", "]", ")", "\n", "try", ":", "\n", "                    ", "res", "=", "estimator", ".", "calc_fail_prob", "(", "**", "pp_int", ".", "call_args", ")", "[", ":", "4", "]", "\n", "", "except", "ValueError", ":", "\n", "                    ", "pass", "\n", "", "else", ":", "\n", "                    ", "name", "=", "read_integrator_name", "(", "int_lib", ")", "\n", "proba_res", "[", "name", "]", "=", "{", "}", "\n", "proba_res", "[", "name", "]", "[", "\"fail_prob\"", "]", "=", "res", "[", "0", "]", "\n", "proba_res", "[", "name", "]", "[", "\"est_var\"", "]", "=", "res", "[", "1", "]", "\n", "proba_res", "[", "name", "]", "[", "\"safety_index\"", "]", "=", "res", "[", "2", "]", "\n", "proba_res", "[", "name", "]", "[", "\"mpp\"", "]", "=", "res", "[", "3", "]", "\n", "if", "estimator", ".", "x_safe", ".", "size", ">", "0", ":", "\n", "                        ", "samps", "=", "np", ".", "unique", "(", "self", ".", "full_space", ".", "inp_space", ".", "stoch2full", "(", "estimator", ".", "x_safe", ",", "x_cur", ",", "\n", "domain", "=", "\"sto_con\"", ")", ",", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "                        ", "samps", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "full_space", ".", "inp_space", ".", "dims", ")", ")", "\n", "", "proba_res", "[", "name", "]", "[", "\"safe_samp\"", "]", "=", "samps", "\n", "if", "estimator", ".", "x_fail", ".", "size", ">", "0", ":", "\n", "                        ", "samps", "=", "np", ".", "unique", "(", "\n", "self", ".", "full_space", ".", "inp_space", ".", "stoch2full", "(", "estimator", ".", "x_fail", ",", "x_cur", ",", "domain", "=", "\"sto_con\"", ")", ",", "\n", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "                        ", "samps", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "full_space", ".", "inp_space", ".", "dims", ")", ")", "\n", "", "proba_res", "[", "name", "]", "[", "\"fail_samp\"", "]", "=", "samps", "\n", "if", "estimator", ".", "x_lsf", ".", "size", ">", "0", ":", "\n", "                        ", "samps", "=", "np", ".", "unique", "(", "\n", "self", ".", "full_space", ".", "inp_space", ".", "stoch2full", "(", "estimator", ".", "x_lsf", ",", "x_cur", ",", "domain", "=", "\"sto_con\"", ")", ",", "\n", "axis", "=", "0", ")", "\n", "", "else", ":", "\n", "                        ", "samps", "=", "np", ".", "empty", "(", "(", "0", ",", "self", ".", "full_space", ".", "inp_space", ".", "dims", ")", ")", "\n", "", "proba_res", "[", "name", "]", "[", "\"limit_state\"", "]", "=", "samps", "\n", "proba_res", "[", "name", "]", "[", "\"num_eval\"", "]", "=", "estimator", ".", "num_eval", "\n", "", "", "", "if", "self", ".", "full_space", ".", "obj_inds", "[", "\"sto\"", "]", "and", "moment", ":", "\n", "            ", "doe", "=", "self", ".", "co_mom", ".", "gen_doe", "(", "x_cur", ")", "\n", "rob_res", "[", "\"input\"", "]", "=", "self", ".", "full_space", ".", "inp_space", ".", "stoch2full", "(", "doe", ",", "x_cur", ",", "\n", "\"sto_obj\"", ")", "\n", "obj_wgt", "=", "None", "\n", "if", "self", ".", "co_mom", ".", "obj_wgt", "is", "not", "None", ":", "\n", "# To get individual moments", "\n", "                ", "obj_wgt", "=", "self", ".", "co_mom", ".", "obj_wgt", ".", "copy", "(", ")", "\n", "self", ".", "co_mom", ".", "obj_wgt", "=", "None", "\n", "", "mus", ",", "sigs", "=", "self", ".", "co_mom", ".", "est_mom", "(", "x_cur", ")", "\n", "obj", "=", "None", "\n", "if", "obj_wgt", "is", "not", "None", ":", "\n", "                ", "self", ".", "co_mom", ".", "obj_wgt", "=", "obj_wgt", "\n", "obj", "=", "self", ".", "co_mom", ".", "est_mom", "(", "x_cur", ")", "\n", "", "rob_res", "[", "\"output\"", "]", "=", "[", "mus", ",", "sigs", ",", "obj", "]", "\n", "", "return", "proba_res", ",", "rob_res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.dbscanner": [[20, 27], ["sklearn.cluster.DBSCAN", "sklearn.cluster.DBSCAN.fit", "max", "numpy.abs"], "function", ["None"], ["def", "dbscanner", "(", "dist_mat_or_points", ",", "eps", ",", "min_samples", ",", "sample_weight", ",", "metric", "=", "\"euclidean\"", ")", ":", "\n", "    ", "if", "min_samples", "<", "3", ":", "\n", "        ", "min_samples", "=", "3", "\n", "", "clus", "=", "DBSCAN", "(", "eps", "=", "max", "(", "1e-8", ",", "np", ".", "abs", "(", "eps", ")", ")", ",", "min_samples", "=", "min_samples", ",", "metric", "=", "metric", ",", "\n", ")", "\n", "clus", ".", "fit", "(", "dist_mat_or_points", ",", "sample_weight", "=", "sample_weight", ")", "\n", "return", "clus", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.optics": [[29, 36], ["sklearn.cluster.OPTICS", "sklearn.cluster.OPTICS.fit", "max", "numpy.abs"], "function", ["None"], ["", "def", "optics", "(", "dist_mat_or_points", ",", "eps", ",", "min_samples", ",", "metric", "=", "\"euclidean\"", ")", ":", "\n", "    ", "if", "min_samples", "<", "3", ":", "\n", "        ", "min_samples", "=", "3", "\n", "", "clus", "=", "OPTICS", "(", "max_eps", "=", "max", "(", "1e-8", ",", "np", ".", "abs", "(", "eps", ")", ")", ",", "min_samples", "=", "min_samples", ",", "metric", "=", "metric", ",", "\n", "cluster_method", "=", "\"xi\"", ",", "min_cluster_size", "=", ".1", ")", "\n", "clus", ".", "fit", "(", "dist_mat_or_points", ")", "\n", "return", "clus", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.kmeans": [[38, 44], ["sklearn.cluster.MiniBatchKMeans.fit", "sklearn.cluster.KMeans", "sklearn.cluster.MiniBatchKMeans"], "function", ["None"], ["", "def", "kmeans", "(", "x_f", ",", "n_clust", ",", "batch_size", "=", "None", ")", ":", "\n", "    ", "if", "batch_size", "is", "None", ":", "\n", "        ", "clus", "=", "KMeans", "(", "n_clusters", "=", "n_clust", ")", "\n", "", "else", ":", "\n", "        ", "clus", "=", "MiniBatchKMeans", "(", "n_clusters", "=", "n_clust", ",", "batch_size", "=", "batch_size", ")", "\n", "", "return", "clus", ".", "fit", "(", "x_f", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._reduce_to_kmeans": [[46, 64], ["clustering.kmeans", "numpy.unique", "numpy.empty", "ids.sum", "numpy.append"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.kmeans"], ["", "def", "_reduce_to_kmeans", "(", "x_f", ",", "max_points", "=", "10000", ")", ":", "\n", "    ", "if", "x_f", ".", "shape", "[", "0", "]", "<=", "2", "*", "max_points", ":", "\n", "        ", "return", "x_f", "\n", "", "n_clust", "=", "2", "*", "x_f", ".", "shape", "[", "1", "]", "\n", "clus", "=", "kmeans", "(", "x_f", ",", "n_clust", ")", "\n", "# means = clus.cluster_centers_", "\n", "# stds = clus.inertia_", "\n", "labels", "=", "np", ".", "unique", "(", "clus", ".", "labels_", ")", "\n", "res", "=", "np", ".", "empty", "(", "(", "0", ",", "x_f", ".", "shape", "[", "1", "]", ")", ")", "\n", "for", "lab", "in", "labels", ":", "\n", "        ", "ids", "=", "clus", ".", "labels_", "==", "lab", "\n", "cur_points", "=", "ids", ".", "sum", "(", ")", "\n", "cur_target_points", "=", "max_points", "*", "cur_points", "//", "x_f", ".", "shape", "[", "0", "]", "\n", "step", "=", "cur_points", "//", "cur_target_points", "\n", "res", "=", "np", ".", "append", "(", "res", ",", "x_f", "[", "ids", "]", "[", ":", ":", "step", "]", ",", "axis", "=", "0", ")", "\n", "", "return", "res", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.get_dbclusters": [[66, 115], ["clustering._get_sample_weights", "sklearn.preprocessing.StandardScaler", "sklearn.preprocessing.StandardScaler.fit_transform", "clustering._get_eps_bounds", "scipy.optimize.minimize_scalar", "clustering.get_dbclusters._eval_db"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_sample_weights", "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_eps_bounds"], ["", "def", "get_dbclusters", "(", "fails", ",", "sample_weight", "=", "True", ",", "\n", "counts", "=", "None", ",", "max_num_clusters", "=", "np", ".", "inf", ")", ":", "\n", "    ", "n_sample", ",", "n_dim", "=", "fails", ".", "shape", "\n", "if", "n_sample", "<=", "1", ":", "\n", "        ", "return", "None", ",", "None", "\n", "", "sample_weight", ",", "avg_wgt", "=", "_get_sample_weights", "(", "sample_weight", ",", "fails", ",", "counts", ")", "\n", "scaler", "=", "StandardScaler", "(", ")", "\n", "fails", "=", "scaler", ".", "fit_transform", "(", "fails", ")", "\n", "if", "fails", ".", "shape", "[", "1", "]", ">", "100", ":", "\n", "        ", "metric", "=", "\"cosine\"", "\n", "dist_max", "=", "1", "\n", "", "else", ":", "\n", "        ", "metric", "=", "\"euclidean\"", "\n", "\n", "", "min_samp", "=", "avg_wgt", "*", "min", "(", "2", "*", "n_dim", ",", "n_sample", "//", "1000", ")", "\n", "\n", "def", "_eval_db", "(", "eps", ")", ":", "\n", "        ", "epsilon", "=", "eps", "\n", "if", "not", "np", ".", "isfinite", "(", "epsilon", ")", "and", "epsilon", "==", "0", ":", "\n", "            ", "return", "[", "]", ",", "None", ",", "0", ",", "0", "\n", "", "clus", "=", "dbscanner", "(", "fails", ",", "epsilon", ",", "min_samp", ",", "sample_weight", ",", "metric", ")", "\n", "# clus = optics(fails, epsilon, min_samp, metric)", "\n", "unique_labels", ",", "cnts", "=", "np", ".", "unique", "(", "clus", ".", "labels_", ",", "return_counts", "=", "True", ")", "\n", "unique_labels", "=", "unique_labels", ".", "tolist", "(", ")", "\n", "if", "-", "1", "in", "unique_labels", ":", "\n", "            ", "unique_labels", ".", "remove", "(", "-", "1", ")", "\n", "cnts", "=", "np", ".", "array", "(", "cnts", "[", "1", ":", "]", ")", "\n", "", "if", "cnts", ".", "shape", "[", "0", "]", "<", "1", ":", "\n", "            ", "return", "[", "]", ",", "None", ",", "0", ",", "0", "\n", "", "success_rate", "=", "(", "n_sample", "-", "np", ".", "sum", "(", "clus", ".", "labels_", "==", "-", "1", ")", ")", "/", "n_sample", "\n", "size_prop", "=", "cnts", ".", "min", "(", ")", "/", "n_sample", "\n", "return", "clus", ".", "labels_", ",", "unique_labels", ",", "success_rate", ",", "size_prop", "\n", "\n", "", "def", "obj", "(", "epsilon", ")", ":", "\n", "        ", "_", ",", "unique_labels", ",", "success_rate", ",", "size_prop", "=", "_eval_db", "(", "epsilon", ")", "\n", "n_classes", "=", "len", "(", "unique_labels", ")", "if", "unique_labels", "else", "0", "\n", "ob1", "=", "epsilon", "/", "dist_max", "\n", "ob2", "=", "n_classes", "/", "max_num_clusters", "\n", "infeas", "=", "not", "n_classes", "or", "success_rate", "<", "0.9", "or", "size_prop", "<", "0.1", "or", "ob2", ">", "1", "\n", "if", "infeas", ":", "\n", "            ", "return", "-", "(", "success_rate", "+", "size_prop", ")", "\n", "", "return", "ob1", "-", "ob2", "-", "3", "\n", "\n", "\n", "", "dist_min", ",", "dist_max", "=", "_get_eps_bounds", "(", "fails", ")", "\n", "res", "=", "minimize_scalar", "(", "obj", ",", "bounds", "=", "(", "dist_min", ",", "dist_max", ")", ",", "\n", "method", "=", "\"Bounded\"", ")", "\n", "labels", ",", "uniques", ",", "sr", ",", "sp", "=", "_eval_db", "(", "res", ".", "x", ")", "\n", "return", "labels", ",", "uniques", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_eps_bounds": [[117, 124], ["sklearn.neighbors.NearestNeighbors", "sklearn.neighbors.NearestNeighbors.fit", "neigh.fit.kneighbors", "numpy.percentile", "numpy.linalg.norm", "x_f.max", "x_f.min"], "function", ["None"], ["", "def", "_get_eps_bounds", "(", "x_f", ")", ":", "\n", "    ", "neigh", "=", "NearestNeighbors", "(", "n_neighbors", "=", "1", ")", "\n", "nbrs", "=", "neigh", ".", "fit", "(", "x_f", ")", "\n", "distances", ",", "indices", "=", "nbrs", ".", "kneighbors", "(", "x_f", ")", "\n", "eps_min", "=", "np", ".", "percentile", "(", "distances", ",", "0.1", ")", "\n", "eps_max", "=", "np", ".", "linalg", ".", "norm", "(", "x_f", ".", "max", "(", "0", ")", "-", "x_f", ".", "min", "(", "0", ")", ")", "\n", "return", "eps_min", ",", "eps_max", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.filter_tiny": [[126, 135], ["locs.sum", "counts.append", "names.append"], "function", ["None"], ["", "def", "filter_tiny", "(", "class_names", ",", "labels", ")", ":", "\n", "    ", "names", ",", "counts", "=", "[", "]", ",", "[", "]", "\n", "for", "label", "in", "class_names", ":", "\n", "        ", "locs", "=", "labels", "==", "label", "\n", "count", "=", "locs", ".", "sum", "(", ")", "\n", "if", "count", ">=", "5", ":", "\n", "            ", "counts", ".", "append", "(", "count", ")", "\n", "names", ".", "append", "(", "label", ")", "\n", "", "", "return", "names", ",", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.get_clusters": [[137, 164], ["clustering.get_n_points", "print", "clustering.get_dbclusters", "print", "print", "clustering._filter_points", "numpy.ones"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.get_n_points", "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.get_dbclusters", "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._filter_points"], ["", "def", "get_clusters", "(", "fails", ",", "lsf", ",", "max_num_clusters", ",", "max_points", "=", "None", ")", ":", "\n", "    ", "if", "fails", ".", "size", "+", "lsf", ".", "size", "<", "5", ":", "\n", "        ", "print", "(", "\"No points passed to cluster\"", ")", "\n", "return", "None", ",", "None", ",", "None", "\n", "\n", "", "if", "max_points", "is", "None", ":", "\n", "        ", "n_dim", "=", "fails", ".", "shape", "[", "1", "]", "\n", "if", "n_dim", "<=", "5", ":", "\n", "            ", "max_points", "=", "25000", "\n", "", "elif", "n_dim", "<=", "10", ":", "\n", "            ", "max_points", "=", "20000", "\n", "", "elif", "n_dim", "<=", "25", ":", "\n", "            ", "max_points", "=", "10000", "\n", "", "else", ":", "\n", "            ", "max_points", "=", "5000", "\n", "\n", "", "", "x_f", ",", "counts", "=", "get_n_points", "(", "fails", ",", "lsf", ",", "max_points", ")", "\n", "try", ":", "\n", "        ", "labels", ",", "uniques", "=", "get_dbclusters", "(", "x_f", ",", "sample_weight", "=", "True", ",", "\n", "counts", "=", "counts", ",", "\n", "max_num_clusters", "=", "max_num_clusters", ")", "\n", "", "except", "(", "SystemError", ",", "MemoryError", ")", "as", "exc", ":", "\n", "        ", "print", "(", "\"Clustering failed due to error:\"", ")", "\n", "print", "(", "exc", ")", "\n", "x_f", ",", "_", "=", "_filter_points", "(", "fails", ",", "lsf", ",", "None", ")", "\n", "return", "x_f", ",", "-", "1", "*", "np", ".", "ones", "(", "x_f", ".", "shape", "[", "0", "]", ",", "dtype", "=", "int", ")", ",", "[", "-", "1", "]", "\n", "", "return", "x_f", ",", "labels", ",", "uniques", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._filter_points": [[166, 180], ["numpy.empty", "numpy.empty", "numpy.isfinite().all", "clustering._get_unique_tol", "clustering._get_unique_tol", "numpy.append", "numpy.append", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_unique_tol", "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_unique_tol"], ["", "def", "_filter_points", "(", "fails", ",", "lsf", ",", "tol", ")", ":", "\n", "    ", "x_f", "=", "np", ".", "empty", "(", "(", "0", ",", "fails", ".", "shape", "[", "1", "]", ")", ")", "\n", "counts", "=", "np", ".", "empty", "(", "0", ")", "\n", "if", "lsf", ".", "size", ">", "0", ":", "\n", "        ", "x_f", ",", "counts", "=", "_get_unique_tol", "(", "lsf", ",", "tol", ")", "\n", "", "if", "x_f", ".", "shape", "[", "0", "]", "<", "6", "and", "fails", ".", "size", ">", "0", ":", "# because 3 core points", "\n", "        ", "unique_xf", ",", "counts2", "=", "_get_unique_tol", "(", "fails", ",", "tol", ")", "\n", "x_f", "=", "np", ".", "append", "(", "x_f", ",", "unique_xf", ",", "axis", "=", "0", ")", "\n", "counts", "=", "np", ".", "append", "(", "counts", ",", "counts2", ")", "\n", "\n", "", "valid", "=", "np", ".", "isfinite", "(", "x_f", ")", ".", "all", "(", "1", ")", "\n", "x_f", "=", "x_f", "[", "valid", ",", ":", "]", "\n", "counts", "=", "counts", "[", "valid", "]", "\n", "return", "x_f", ",", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.get_n_points": [[182, 208], ["clustering._filter_points", "clustering.get_n_points.get_interval"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._filter_points"], ["", "def", "get_n_points", "(", "fails", ",", "lsf", ",", "n_points", "=", "25000", ",", "conv_tol", "=", "0.1", ")", ":", "\n", "    ", "def", "check_tol", "(", "n_points_curr", ")", ":", "\n", "        ", "return", "abs", "(", "(", "n_points", "-", "n_points_curr", ")", "/", "n_points", ")", "<=", "conv_tol", "\n", "\n", "", "def", "obj", "(", "tol", ")", ":", "\n", "        ", "x_f", "=", "_filter_points", "(", "fails", ",", "lsf", ",", "10", "**", "tol", ")", "[", "0", "]", "\n", "if", "check_tol", "(", "x_f", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "return", "0", "\n", "", "return", "n_points", "-", "x_f", ".", "shape", "[", "0", "]", "\n", "\n", "", "def", "get_interval", "(", ")", ":", "\n", "        ", "start", "=", "-", "10", "\n", "while", "obj", "(", "start", ")", ">", "0", ":", "\n", "            ", "start", "-=", "10", "\n", "", "stop", "=", "10", "\n", "while", "obj", "(", "stop", ")", "<", "0", ":", "\n", "            ", "stop", "+=", "10", "\n", "", "return", "start", ",", "stop", "\n", "\n", "", "orig", ",", "counts", "=", "_filter_points", "(", "fails", ",", "lsf", ",", "None", ")", "\n", "if", "orig", ".", "shape", "[", "0", "]", "<=", "n_points", "or", "check_tol", "(", "orig", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "return", "orig", ",", "counts", "\n", "", "del", "orig", ",", "counts", "\n", "a", ",", "b", "=", "get_interval", "(", ")", "\n", "res", "=", "brentq", "(", "obj", ",", "a", ",", "b", ")", "\n", "return", "_filter_points", "(", "fails", ",", "lsf", ",", "10", "**", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_unique_tol": [[210, 219], ["numpy.round", "pandas.DataFrame", "df.groupby.groupby", "numpy.unique", "df.groupby.agg", "df.groupby.size", "counts.ravel", "list"], "function", ["None"], ["", "def", "_get_unique_tol", "(", "points", ",", "tol", "=", "None", ")", ":", "\n", "    ", "if", "tol", "is", "None", ":", "\n", "        ", "return", "np", ".", "unique", "(", "points", ",", "axis", "=", "0", ",", "return_counts", "=", "True", ")", "\n", "", "rounded", "=", "np", ".", "round", "(", "points", "/", "tol", ")", "\n", "df", "=", "pd", ".", "DataFrame", "(", "np", ".", "c_", "[", "rounded", ",", "points", "]", ")", "\n", "df", "=", "df", ".", "groupby", "(", "list", "(", "df", ".", "columns", ")", "[", ":", "rounded", ".", "shape", "[", "1", "]", "]", ")", "\n", "final", "=", "df", ".", "agg", "(", "\"mean\"", ")", ".", "values", "\n", "counts", "=", "df", ".", "size", "(", ")", ".", "values", "\n", "return", "final", ",", "counts", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_group_stat": [[221, 223], ["agg"], "function", ["None"], ["", "def", "_get_group_stat", "(", "points", ",", "ids", ",", "agg", "=", "np", ".", "median", ")", ":", "\n", "    ", "return", "agg", "(", "points", "[", "ids", "]", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering._get_sample_weights": [[225, 231], ["sample_weight.mean", "numpy.max", "numpy.ones", "counts.min", "counts.max", "counts.min"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean"], ["", "def", "_get_sample_weights", "(", "sample_weight", ",", "fails", ",", "counts", ")", ":", "\n", "    ", "if", "not", "sample_weight", "or", "counts", "is", "None", "or", "np", ".", "max", "(", "counts", ")", "<=", "1", ":", "\n", "        ", "return", "np", ".", "ones", "(", "fails", ".", "shape", "[", "0", "]", ")", ",", "1", "\n", "", "sample_weight", "=", "(", "counts", "-", "counts", ".", "min", "(", ")", ")", "/", "(", "counts", ".", "max", "(", ")", "-", "counts", ".", "min", "(", ")", ")", "\n", "sample_weight", "[", "sample_weight", "<", "1e-8", "]", "=", "1e-8", "\n", "return", "sample_weight", ",", "sample_weight", ".", "mean", "(", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.is_pareto": [[16, 48], ["numpy.arange", "numpy.any", "numpy.zeros", "numpy.sum"], "function", ["None"], ["def", "is_pareto", "(", "costs", ",", "return_mask", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Find the pareto-efficient points.\n    Source: https://stackoverflow.com/a/40239615\n    Source preferred over older custom implementation due to its performance.\n\n    Parameters\n    ----------\n    costs : np.ndarray\n        An (n_points, n_costs) array with objective values\n    return_mask : bool\n        True to return a mask instead of indexes\n    Returns\n    -------\n        An array of indices of pareto-efficient points.\n        If return_mask is True, this will be an (n_points, ) boolean array\n        Otherwise it will be a (n_efficient_points, ) integer array of indices.\n    \"\"\"", "\n", "is_efficient", "=", "np", ".", "arange", "(", "costs", ".", "shape", "[", "0", "]", ")", "\n", "n_points", "=", "costs", ".", "shape", "[", "0", "]", "\n", "next_point_index", "=", "0", "# Next index in the is_efficient array to search for", "\n", "while", "next_point_index", "<", "costs", ".", "shape", "[", "0", "]", ":", "\n", "        ", "non_dominated_point_mask", "=", "np", ".", "any", "(", "costs", "<", "costs", "[", "next_point_index", "]", ",", "axis", "=", "1", ")", "\n", "non_dominated_point_mask", "[", "next_point_index", "]", "=", "True", "\n", "is_efficient", "=", "is_efficient", "[", "non_dominated_point_mask", "]", "# Remove dominated points", "\n", "costs", "=", "costs", "[", "non_dominated_point_mask", "]", "\n", "next_point_index", "=", "np", ".", "sum", "(", "non_dominated_point_mask", "[", ":", "next_point_index", "]", ")", "+", "1", "\n", "", "if", "return_mask", ":", "\n", "        ", "is_efficient_mask", "=", "np", ".", "zeros", "(", "n_points", ",", "dtype", "=", "bool", ")", "\n", "is_efficient_mask", "[", "is_efficient", "]", "=", "True", "\n", "return", "is_efficient_mask", "\n", "", "return", "is_efficient", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.set_obj_con_args": [[50, 65], ["list", "list"], "function", ["None"], ["", "def", "set_obj_con_args", "(", "problem", ",", "models", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "problem", ".", "full_space", ".", "obj_arg", "=", "list", "(", "problem", ".", "full_space", ".", "obj_arg", ")", "\n", "# assumption, last argument is models", "\n", "problem", ".", "full_space", ".", "obj_arg", "[", "-", "1", "]", "=", "models", "\n", "", "except", "(", "TypeError", ",", "IndexError", ")", ":", "\n", "        ", "problem", ".", "full_space", ".", "obj_arg", "=", "[", "models", "]", "\n", "\n", "", "try", ":", "\n", "        ", "problem", ".", "full_space", ".", "con_arg", "=", "list", "(", "problem", ".", "full_space", ".", "con_arg", ")", "\n", "# assumption, last argument is models", "\n", "problem", ".", "full_space", ".", "con_arg", "[", "-", "1", "]", "=", "models", "\n", "", "except", "(", "TypeError", ",", "IndexError", ")", ":", "\n", "        ", "problem", ".", "full_space", ".", "con_arg", "=", "[", "models", "]", "\n", "", "return", "problem", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_points_of_interest": [[67, 116], ["int", "numpy.append", "numpy.empty", "numpy.empty", "problem.gen_post_proc", "numpy.array", "numpy.logical_not", "numpy.array().reshape", "numpy.isfinite().all", "np.isfinite().all.any", "cons.append", "fails.append", "numpy.append", "np.array.append", "numpy.isfinite().all", "numpy.array", "numpy.array", "numpy.size", "duqo.optimization.predict.read_integrator_name", "numpy.append", "numpy.isfinite().all", "np.isfinite().all.any", "numpy.isfinite().all", "np.isfinite().all.any", "numpy.array", "numpy.array", "numpy.isfinite", "numpy.append", "numpy.append", "numpy.isfinite", "numpy.isfinite", "optimize.select_samples", "numpy.isfinite", "optimize.select_samples", "list", "res_pro.keys"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.gen_post_proc", "home.repos.pwc.inspect_result.canbooo_duqo.optimization.predict.read_integrator_name", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.select_samples", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.select_samples"], ["", "def", "get_points_of_interest", "(", "problem", ",", "pareto", ",", "return_results", "=", "False", ")", ":", "\n", "    ", "n_total_dims", "=", "int", "(", "problem", ".", "full_space", ".", "inp_space", ".", "dims", ")", "\n", "probas", ",", "moms", "=", "np", ".", "empty", "(", "(", "0", ",", "n_total_dims", ")", ")", ",", "np", ".", "empty", "(", "(", "0", ",", "n_total_dims", ")", ")", "\n", "objs", ",", "cons", ",", "fails", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "cand", "in", "pareto", ":", "\n", "        ", "res_pro", ",", "res_mom", "=", "problem", ".", "gen_post_proc", "(", "np", ".", "array", "(", "cand", ")", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", ")", "\n", "\n", "if", "res_pro", ":", "\n", "            ", "names", "=", "[", "read_integrator_name", "(", "n", ")", "\n", "for", "n", "in", "problem", ".", "co_fp", ".", "workers", "[", ":", ":", "-", "1", "]", "]", "\n", "for", "name", "in", "names", ":", "\n", "                ", "if", "name", "in", "res_pro", ":", "\n", "                    ", "res_pro", "=", "res_pro", "[", "name", "]", "\n", "break", "\n", "", "", "else", ":", "\n", "                ", "res_pro", "=", "res_pro", "[", "list", "(", "res_pro", ".", "keys", "(", ")", ")", "[", "-", "1", "]", "]", "\n", "", "inds", "=", "np", ".", "isfinite", "(", "res_pro", "[", "\"limit_state\"", "]", ")", ".", "all", "(", "1", ")", "\n", "if", "inds", ".", "any", "(", ")", ":", "\n", "                ", "probas", "=", "np", ".", "append", "(", "probas", ",", "res_pro", "[", "\"limit_state\"", "]", "[", "inds", "]", ",", "axis", "=", "0", ")", "\n", "", "if", "res_pro", "[", "\"limit_state\"", "]", ".", "shape", "[", "0", "]", "<", "10", ":", "\n", "                ", "inds", "=", "np", ".", "isfinite", "(", "res_pro", "[", "\"fail_samp\"", "]", ")", ".", "all", "(", "1", ")", "\n", "if", "inds", ".", "any", "(", ")", ":", "\n", "                    ", "probas", "=", "np", ".", "append", "(", "probas", ",", "select_samples", "(", "res_pro", "[", "\"fail_samp\"", "]", "[", "inds", "]", ",", "200", ")", ",", "\n", "axis", "=", "0", ")", "\n", "", "", "if", "not", "res_mom", ":", "\n", "                ", "inds", "=", "np", ".", "isfinite", "(", "res_pro", "[", "\"safe_samp\"", "]", ")", ".", "all", "(", "1", ")", "\n", "if", "inds", ".", "any", "(", ")", ":", "\n", "                    ", "probas", "=", "np", ".", "append", "(", "probas", ",", "\n", "select_samples", "(", "res_pro", "[", "\"safe_samp\"", "]", "[", "inds", "]", ",", "200", ")", ",", "\n", "axis", "=", "0", ")", "\n", "\n", "", "", "cons", ".", "append", "(", "res_pro", "[", "\"fail_prob\"", "]", ")", "\n", "fails", ".", "append", "(", "(", "problem", ".", "co_fp", ".", "target_fail_prob", "-", "cons", "[", "-", "1", "]", ")", "<", "0", ")", "\n", "", "if", "res_mom", ":", "\n", "            ", "moms", "=", "np", ".", "append", "(", "moms", ",", "res_mom", "[", "\"input\"", "]", ",", "axis", "=", "0", ")", "\n", "objs", ".", "append", "(", "res_mom", "[", "\"output\"", "]", ")", "\n", "", "", "x_f", "=", "np", ".", "append", "(", "moms", ",", "probas", ",", "axis", "=", "0", ")", "\n", "x_f", "=", "x_f", "[", "np", ".", "isfinite", "(", "x_f", ")", ".", "all", "(", "1", ")", "]", "\n", "if", "objs", ":", "\n", "        ", "objs", "=", "np", ".", "array", "(", "objs", ")", "\n", "", "if", "cons", ":", "\n", "        ", "cons", ",", "fails", "=", "np", ".", "array", "(", "cons", ")", ",", "np", ".", "array", "(", "fails", ")", "\n", "safe", "=", "np", ".", "logical_not", "(", "fails", ")", "\n", "pareto", ",", "cons", "=", "np", ".", "array", "(", "pareto", ")", "[", "safe", "]", ",", "cons", "[", "safe", "]", "\n", "if", "np", ".", "size", "(", "objs", ")", ">", "1", ":", "\n", "            ", "objs", "=", "objs", "[", "safe", "]", "\n", "", "", "if", "return_results", ":", "\n", "        ", "return", "x_f", ",", "pareto", ",", "objs", ",", "cons", "\n", "", "return", "x_f", ",", "pareto", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.select_samples": [[118, 123], ["min", "numpy.append", "optimize.most_distant_sample"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.most_distant_sample"], ["", "def", "select_samples", "(", "samples", ",", "max_sample", "=", "200", ")", ":", "\n", "    ", "res", "=", "samples", "[", "[", "0", "]", ",", ":", "]", "\n", "while", "res", ".", "shape", "[", "0", "]", "<", "min", "(", "samples", ".", "shape", "[", "0", "]", ",", "max_sample", ")", ":", "\n", "        ", "res", "=", "np", ".", "append", "(", "res", ",", "most_distant_sample", "(", "samples", ",", "res", ")", ",", "axis", "=", "0", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.most_distant_sample": [[125, 127], ["scipy.spatial.distance.cdist().min().argmax", "scipy.spatial.distance.cdist().min", "scipy.spatial.distance.cdist"], "function", ["None"], ["", "def", "most_distant_sample", "(", "choose_from", ",", "existing", ")", ":", "\n", "    ", "return", "choose_from", "[", "[", "cdist", "(", "choose_from", ",", "existing", ")", ".", "min", "(", "1", ")", ".", "argmax", "(", ")", "]", ",", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.square_to_condensed": [[129, 133], ["None"], "function", ["None"], ["", "def", "square_to_condensed", "(", "i", ",", "j", ",", "n", ")", ":", "\n", "    ", "if", "i", "<", "j", ":", "\n", "        ", "i", ",", "j", "=", "j", ",", "i", "\n", "", "return", "n", "*", "j", "-", "j", "*", "(", "j", "+", "1", ")", "//", "2", "+", "i", "-", "1", "-", "j", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_pdist_row": [[135, 138], ["optimize.square_to_condensed", "range"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.square_to_condensed"], ["", "def", "get_pdist_row", "(", "i_samp", ",", "n_samp", ")", ":", "\n", "    ", "return", "[", "square_to_condensed", "(", "i_samp", ",", "other", ",", "n_samp", ")", "\n", "for", "other", "in", "range", "(", "n_samp", ")", "if", "other", "!=", "i_samp", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.min_dist_from_pdists": [[140, 146], ["numpy.zeros", "range", "optimize.get_pdist_row", "numpy.min"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_pdist_row"], ["", "def", "min_dist_from_pdists", "(", "n_samp", ",", "pdists", ")", ":", "\n", "    ", "scores", "=", "np", ".", "zeros", "(", "n_samp", ")", "\n", "for", "i_samp", "in", "range", "(", "n_samp", ")", ":", "\n", "        ", "row", "=", "get_pdist_row", "(", "i_samp", ",", "n_samp", ")", "\n", "scores", "[", "i_samp", "]", "=", "np", ".", "min", "(", "pdists", "[", "row", "]", ")", "\n", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.rrdo_lolhr": [[148, 209], ["int", "set_obj_con_args.full_space.inp_space.doe_bounds", "isinstance", "duqo.doe.lhs.make_doe", "start_doe.copy", "print", "print", "optimize.set_obj_con_args", "optimizer.optimize", "print", "numpy.array", "numpy.array", "optimize.is_pareto", "print", "max", "optimize.rrdouaml_step", "numpy.append", "doe_save_path.endswith", "numpy.save", "model_trainer", "optimize.get_points_of_interest", "is_pareto.sum", "len", "min", "print", "numpy.array", "numpy.array", "open", "pickle.dump", "str"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.space.InputSpace.doe_bounds", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.set_obj_con_args", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.optimize", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.is_pareto", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.rrdouaml_step", "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn.model_trainer", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_points_of_interest"], ["", "def", "rrdo_lolhr", "(", "problem", ",", "lower", ",", "upper", ",", "optimizer", ",", "model_trainer", ",", "step_size", ",", "\n", "max_evals", ",", "start_doe", "=", "None", ",", "optimizer_kwargs", "=", "None", ",", "model_trainer_args", "=", "(", ")", ",", "model_trainer_kwargs", "=", "None", ",", "\n", "doe_save_path", "=", "\"\"", ",", "init_bound_tol", "=", "1e-3", ",", "archive_save_path", "=", "\"\"", ")", ":", "\n", "    ", "if", "optimizer_kwargs", "is", "None", ":", "\n", "        ", "optimizer_kwargs", "=", "{", "}", "\n", "", "if", "model_trainer_kwargs", "is", "None", ":", "\n", "        ", "model_trainer_kwargs", "=", "{", "}", "\n", "# After generating an initial DoE", "\n", "# 0- train models with samples", "\n", "# 1- solve problem with optimizer", "\n", "# 2- Acquire pareto frontier + relating stoch points", "\n", "# 3- cluster pareto frontier", "\n", "# 4- Adapt clusters (aka. add new samples)", "\n", "# 5- Repeat 0-4 until termination", "\n", "", "if", "doe_save_path", "and", "not", "doe_save_path", ".", "endswith", "(", "\".npy\"", ")", ":", "\n", "        ", "doe_save_path", "+=", "\".npy\"", "\n", "", "n_total_dims", "=", "int", "(", "problem", ".", "full_space", ".", "inp_space", ".", "dims", ")", "\n", "lower_doe", ",", "upper_doe", "=", "problem", ".", "full_space", ".", "inp_space", ".", "doe_bounds", "(", "init_bound_tol", ",", "\n", "lower", ",", "\n", "upper", ")", "\n", "if", "start_doe", "is", "None", ":", "\n", "        ", "start_doe", "=", "10", "*", "n_total_dims", "\n", "", "if", "isinstance", "(", "start_doe", ",", "int", ")", ":", "\n", "        ", "cur_doe", "=", "make_doe", "(", "start_doe", ",", "lower_bound", "=", "lower_doe", ",", "\n", "upper_bound", "=", "upper_doe", ")", "\n", "", "else", ":", "\n", "        ", "cur_doe", "=", "start_doe", ".", "copy", "(", ")", "\n", "\n", "", "i_iter", "=", "1", "\n", "models", "=", "None", "\n", "while", "True", ":", "\n", "        ", "if", "doe_save_path", ":", "\n", "            ", "np", ".", "save", "(", "doe_save_path", ",", "cur_doe", ")", "\n", "", "print", "(", "f\"Iter. - {i_iter}, samples={cur_doe.shape[0]}\"", ")", "\n", "try", ":", "\n", "            ", "models", "=", "model_trainer", "(", "cur_doe", ",", "*", "model_trainer_args", ",", "**", "model_trainer_kwargs", ")", "\n", "", "except", "RuntimeError", "as", "exc", ":", "\n", "            ", "print", "(", "\"TrainingError:\"", ",", "exc", ")", "\n", "if", "models", "is", "None", ":", "\n", "                ", "raise", "exc", "\n", "", "", "print", "(", "\"Training complete\"", ")", "\n", "problem", "=", "set_obj_con_args", "(", "problem", ",", "models", ")", "\n", "results", "=", "optimizer", ".", "optimize", "(", "**", "optimizer_kwargs", ")", "\n", "print", "(", "\"Optimization complete\"", ")", "\n", "pareto", "=", "np", ".", "array", "(", "[", "np", ".", "array", "(", "res", ".", "candidate", ")", "for", "res", "in", "results", "]", ")", "\n", "if", "cur_doe", ".", "shape", "[", "0", "]", ">=", "max_evals", ":", "\n", "            ", "_", ",", "pareto", ",", "objs", ",", "cons", "=", "get_points_of_interest", "(", "problem", ",", "pareto", ",", "return_results", "=", "True", ")", "\n", "break", "\n", "", "fits", "=", "np", ".", "array", "(", "[", "np", ".", "array", "(", "res", ".", "fitness", ")", "for", "res", "in", "results", "]", ")", "\n", "inds", "=", "is_pareto", "(", "fits", ")", "\n", "print", "(", "\"total\"", ",", "inds", ".", "sum", "(", ")", ",", "\"of\"", ",", "len", "(", "fits", ")", ",", "\"candidates for adaption\"", ")", "\n", "step_size", "=", "max", "(", "1", ",", "min", "(", "step_size", ",", "max_evals", "-", "cur_doe", ".", "shape", "[", "0", "]", ")", ")", "\n", "new_doe", ",", "pareto", ",", "objs", ",", "cons", "=", "rrdouaml_step", "(", "problem", ",", "pareto", "[", "inds", "]", ",", "step_size", ",", "lower_doe", ",", "\n", "upper_doe", ",", "cur_doe", ")", "\n", "if", "archive_save_path", ":", "\n", "            ", "with", "open", "(", "archive_save_path", "+", "\".\"", "+", "str", "(", "i_iter", ")", ",", "\"wb\"", ")", "as", "f", ":", "\n", "                ", "pickle", ".", "dump", "(", "{", "\"archive\"", ":", "pareto", ",", "\"objs\"", ":", "objs", ",", "\"cons\"", ":", "cons", "}", ",", "f", ")", "\n", "", "", "cur_doe", "=", "np", ".", "append", "(", "cur_doe", ",", "new_doe", ",", "axis", "=", "0", ")", "\n", "i_iter", "+=", "1", "\n", "\n", "", "return", "cur_doe", ",", "pareto", ",", "objs", ",", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.rrdouaml_step": [[211, 219], ["optimize.get_points_of_interest", "print", "optimize.adapt_doe", "print"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_points_of_interest", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.adapt_doe"], ["", "def", "rrdouaml_step", "(", "problem", ",", "pareto", ",", "step_size", ",", "lower_doe", ",", "upper_doe", ",", "cur_doe", ")", ":", "\n", "    ", "x_f", ",", "pareto", ",", "objs", ",", "cons", "=", "get_points_of_interest", "(", "problem", ",", "pareto", ",", "\n", "return_results", "=", "True", ")", "\n", "print", "(", "f\"Got {x_f.shape[0]} points of interest\"", ")", "\n", "new_doe", "=", "adapt_doe", "(", "lower_doe", ",", "upper_doe", ",", "cur_doe", ",", "x_f", ",", "num_samples", "=", "step_size", ",", "\n", "return_update_only", "=", "True", ",", "beta", "=", "2", ")", "\n", "print", "(", "f\"Got doe with {new_doe.shape[0]} samples\"", ")", "\n", "return", "new_doe", ",", "pareto", ",", "objs", ",", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.hypercube_size": [[221, 223], ["None"], "function", ["None"], ["", "def", "hypercube_size", "(", "lower", ",", "upper", ",", "n_sample", ")", ":", "\n", "    ", "return", "(", "upper", "-", "lower", ")", "/", "n_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.adapt_doe": [[225, 308], ["optimize.get_cluster_bounds", "len", "print", "doe.copy", "enumerate", "numpy.empty", "zip", "print", "duqo.doe.lhs.inherit_lhs", "duqo.doe.lhs.optimize_doe", "numpy.append", "duqo.doe.lhs.find_empty_bins", "numpy.max", "fails.min", "fails.max", "numpy.arange", "duqo.doe.lhs.find_empty_bins.sum", "len", "numpy.corrcoef", "numpy.max", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.abs", "numpy.array", "numpy.array", "len", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_cluster_bounds", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.inherit_lhs", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.optimize_doe", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.find_empty_bins"], ["", "def", "adapt_doe", "(", "lower", ",", "upper", ",", "doe", ",", "x_lsf", ",", "x_fail", "=", "None", ",", "num_samples", "=", "4", ",", "\n", "return_update_only", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Proposes new samples given the old doe\n\n    Parameters\n    ----------\n    lower : list or np.ndarray\n        lower doe bound\n    upper : list or np.ndarray\n        upper doe bound.\n    doe : np.ndarray\n        Matrix of known samples with shape=(n_old_sample, n_input_dimensions)\n    x_lsf : np.ndarray\n        Matrix of samples predicted to be on the limit state with shape=(n_lsf_sample, n_input_dimensions)\n    x_fail : np.ndarray or None\n        Matrix of samples predicted to be in the failure region with shape=(n_fail_sample, n_input_dimensions).\n        This is useful in case the number of samples in x_lsf is low. Default: None\n    num_samples : int\n         Number of new samples to include in the DoE\n    return_update_only : bool\n        If True, only the new points are returned, otherwise the points will be appended to the passed doe and the\n        result is returned\n\n    Returns\n    -------\n    x_cand : np.ndarray\n        Either the matrix of candidate samples or the matrix of the existing and the candidate samples depending on\n        the value of return_update_only. shape=(num_sample, n_dim) or (n_old_sample + num_sample, n_dim)\n\n\n    \"\"\"", "\n", "if", "x_fail", "is", "None", ":", "\n", "        ", "x_fail", "=", "np", ".", "empty", "(", "(", "0", ",", "x_lsf", ".", "shape", "[", "1", "]", ")", ")", "\n", "", "fails", ",", "all_bounds", ",", "points_per_class", "=", "get_cluster_bounds", "(", "lower", ",", "upper", ",", "x_fail", ",", "x_lsf", ",", "num_samples", ",", "\n", "doe", ".", "shape", "[", "0", "]", ")", "\n", "\n", "if", "fails", "is", "None", ":", "\n", "        ", "all_bounds", "=", "[", "{", "\"lower\"", ":", "lower", ",", "\n", "\"upper\"", ":", "upper", ",", "\n", "\"ids\"", ":", "None", "}", "]", "# just for completeness has no effect", "\n", "", "if", "not", "all_bounds", ":", "\n", "        ", "all_bounds", "=", "[", "{", "\"lower\"", ":", "fails", ".", "min", "(", "0", ")", ",", "\n", "\"upper\"", ":", "fails", ".", "max", "(", "0", ")", ",", "\n", "\"ids\"", ":", "np", ".", "arange", "(", "fails", ".", "shape", "[", "0", "]", ")", "}", "]", "# just for completeness has no effect", "\n", "", "n_clust", "=", "len", "(", "all_bounds", ")", "\n", "print", "(", "f\"{n_clust} clusters found on model with {doe.shape[0]} samples\"", ")", "\n", "\n", "new_doe", "=", "doe", ".", "copy", "(", ")", "\n", "for", "i_class", ",", "(", "bounds", ",", "samples", ")", "in", "enumerate", "(", "zip", "(", "all_bounds", ",", "points_per_class", ")", ")", ":", "\n", "        ", "if", "not", "samples", ":", "\n", "            ", "continue", "\n", "", "n_bins", "=", "samples", "\n", "n_empty", "=", "0", "\n", "while", "n_empty", "<", "samples", ":", "\n", "            ", "empty_bins", "=", "find_empty_bins", "(", "new_doe", ",", "n_bins", ",", "bounds", "[", "\"lower\"", "]", ",", "\n", "bounds", "[", "\"upper\"", "]", ")", "\n", "n_empty", "=", "np", ".", "max", "(", "empty_bins", ".", "sum", "(", "0", ")", ")", "\n", "n_bins", "+=", "1", "\n", "", "msg", "=", "f\"Adapting class {i_class + 1} with {samples} samples\"", "\n", "corr", "=", "0", "\n", "if", "bounds", "[", "\"ids\"", "]", "is", "not", "None", "and", "fails", "is", "not", "None", ":", "\n", "            ", "if", "len", "(", "bounds", "[", "\"ids\"", "]", ")", ">", "2", ":", "\n", "                ", "corr", "=", "np", ".", "corrcoef", "(", "fails", "[", "bounds", "[", "\"ids\"", "]", "]", ",", "rowvar", "=", "False", ")", "\n", "max_corr", "=", "np", ".", "max", "(", "np", ".", "abs", "(", "corr", "-", "np", ".", "eye", "(", "corr", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "msg", "+=", "f\": {len(bounds['ids'])} points with max. corr. {max_corr:.2f}\\n\"", "\n", "", "relative_size", "=", "np", ".", "array", "(", "bounds", "[", "\"upper\"", "]", ")", "-", "np", ".", "array", "(", "bounds", "[", "\"lower\"", "]", ")", "\n", "# print(\"upper, lower\", upper, lower, bounds[\"upper\"], bounds[\"lower\"])", "\n", "relative_size", "/=", "(", "np", ".", "array", "(", "upper", ")", "-", "np", ".", "array", "(", "lower", ")", ")", "\n", "mu", "=", "(", "np", ".", "array", "(", "bounds", "[", "\"upper\"", "]", ")", "+", "np", ".", "array", "(", "bounds", "[", "\"lower\"", "]", ")", ")", "/", "2", "\n", "msg", "+=", "f\"Rel. size: {relative_size}\\n\"", "\n", "msg", "+=", "f\"Center: {mu}\"", "\n", "", "print", "(", "msg", ")", "\n", "x_new", "=", "inherit_lhs", "(", "samples", ",", "empty_bins", ",", "bounds", "[", "\"lower\"", "]", ",", "\n", "bounds", "[", "\"upper\"", "]", ")", "\n", "\n", "cur_doe", "=", "optimize_doe", "(", "x_new", ",", "corr_mat", "=", "corr", ",", "doe_old", "=", "new_doe", ")", "\n", "new_doe", "=", "np", ".", "append", "(", "new_doe", ",", "\n", "cur_doe", ",", "\n", "axis", "=", "0", ")", "\n", "", "if", "return_update_only", ":", "\n", "        ", "return", "new_doe", "[", "doe", ".", "shape", "[", "0", "]", ":", "]", "\n", "", "return", "new_doe", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.get_cluster_bounds": [[310, 342], ["duqo.uml.clustering.get_clusters", "optimize.hypercube_size", "duqo.uml.clustering.filter_tiny", "optimize.assign_points_per_class", "zip", "print", "numpy.zeros", "len", "numpy.maximum", "numpy.maximum", "numpy.minimum", "cluster_bounds.append", "print", "print", "print", "cur_fails.max", "cur_fails.min", "cur_fails.max", "cur_fails.min", "numpy.where"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.get_clusters", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.hypercube_size", "home.repos.pwc.inspect_result.canbooo_duqo.uml.clustering.filter_tiny", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.assign_points_per_class"], ["", "def", "get_cluster_bounds", "(", "lower", ",", "upper", ",", "fails", ",", "lsf", ",", "n_samples", ",", "n_old_samples", ")", ":", "\n", "    ", "x_f", ",", "labels", ",", "class_names", "=", "get_clusters", "(", "fails", ",", "lsf", ",", "n_samples", ")", "\n", "if", "x_f", "is", "None", ":", "\n", "        ", "print", "(", "\"Failed to detect clusters\"", ")", "\n", "return", "None", ",", "[", "-", "1", "]", ",", "[", "n_samples", "]", "\n", "", "hc_size", "=", "hypercube_size", "(", "lower", ",", "upper", ",", "n_samples", "+", "n_old_samples", ")", "\n", "\n", "if", "class_names", "is", "None", ":", "\n", "        ", "labels", "=", "np", ".", "zeros", "(", "x_f", ".", "shape", "[", "0", "]", ")", "\n", "class_names", "=", "[", "0", "]", "\n", "", "class_names", ",", "counts", "=", "filter_tiny", "(", "class_names", ",", "labels", ")", "\n", "points_per_class", "=", "assign_points_per_class", "(", "n_samples", ",", "len", "(", "class_names", ")", ",", "counts", ")", "\n", "cluster_bounds", "=", "[", "]", "\n", "for", "label", ",", "count", ",", "sample", "in", "zip", "(", "class_names", ",", "counts", ",", "points_per_class", ")", ":", "\n", "        ", "locs", "=", "labels", "==", "label", "\n", "cur_fails", "=", "x_f", "[", "locs", "]", "\n", "mu", "=", "(", "cur_fails", ".", "max", "(", "0", ")", "+", "cur_fails", ".", "min", "(", "0", ")", ")", "/", "2", "\n", "sigma", "=", "(", "cur_fails", ".", "max", "(", "0", ")", "-", "cur_fails", ".", "min", "(", "0", ")", ")", "/", "2", "\n", "delta", "=", "np", ".", "maximum", "(", "sigma", ",", "sample", "*", "hc_size", "/", "2", ")", "\n", "cur_lower", "=", "mu", "-", "delta", "\n", "cur_upper", "=", "mu", "+", "delta", "\n", "\n", "cur_lower", "=", "np", ".", "maximum", "(", "cur_lower", ",", "lower", "-", "sample", "*", "hc_size", "/", "2", ")", "\n", "cur_upper", "=", "np", ".", "minimum", "(", "cur_upper", ",", "upper", "+", "sample", "*", "hc_size", "/", "2", ")", "\n", "\n", "cluster_bounds", ".", "append", "(", "{", "\"lower\"", ":", "cur_lower", ",", "\n", "\"upper\"", ":", "cur_upper", ",", "\n", "\"ids\"", ":", "np", ".", "where", "(", "locs", ")", "[", "0", "]", "}", ")", "\n", "print", "(", "\"Appended bounds for cluster\"", ",", "label", "+", "1", ")", "\n", "print", "(", "\"Lower\"", ",", "cluster_bounds", "[", "-", "1", "]", "[", "\"lower\"", "]", ")", "\n", "print", "(", "\"Upper\"", ",", "cluster_bounds", "[", "-", "1", "]", "[", "\"upper\"", "]", ")", "\n", "", "return", "x_f", ",", "cluster_bounds", ",", "points_per_class", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.assign_points_per_class": [[344, 353], ["numpy.argsort", "sum"], "function", ["None"], ["", "def", "assign_points_per_class", "(", "n_samples", ",", "n_clust", ",", "counts", ")", ":", "\n", "    ", "points_per_class", "=", "[", "n_samples", "//", "n_clust", "]", "*", "n_clust", "\n", "order", "=", "np", ".", "argsort", "(", "counts", ")", "[", ":", ":", "-", "1", "]", "\n", "i_order", "=", "0", "\n", "while", "sum", "(", "points_per_class", ")", "<", "n_samples", ":", "\n", "        ", "i_clus", "=", "order", "[", "i_order", "]", "\n", "points_per_class", "[", "i_clus", "]", "+=", "1", "\n", "i_order", "=", "(", "i_order", "+", "1", ")", "%", "n_clust", "\n", "", "return", "points_per_class", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.__init__": [[85, 95], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "multivariate", ":", "MultiVar", ",", "constraints", ":", "List", "[", "Callable", "]", ",", "constraint_args", ":", "Optional", "[", "Iterable", "]", "=", "None", ",", "\n", "std_norm_to_orig", ":", "Optional", "[", "Callable", "]", "=", "None", ",", "orig_to_std_norm", ":", "Optional", "[", "Callable", "]", "=", "None", ")", ":", "\n", "        ", "self", ".", "multivariate", "=", "multivariate", "\n", "\n", "self", ".", "constraints", "=", "constraints", "\n", "self", ".", "constraint_args", "=", "constraint_args", "\n", "self", ".", "model_constraints", "=", "None", "# This will be generated after sampling", "\n", "self", ".", "model_constraint_args", "=", "None", "\n", "self", ".", "std_norm_to_orig", "=", "std_norm_to_orig", "\n", "self", ".", "orig_to_std_norm", "=", "orig_to_std_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.calc_fail_prob": [[96, 195], ["isinstance", "duqo.doe.lhs.make_doe.copy", "copy.deepcopy", "max", "quantify.LoLHR4RA.multivariate.quantile_bounds", "duqo.doe.lhs.make_doe", "ValueError", "quantify._get_default_integrator", "print", "print", "model_trainer", "print", "quantify.LoLHR4RA.model_fail_prob", "numpy.sqrt", "conv_checker", "print", "pfs.append", "quantify.LoLHR4RA.multivariate.get_probability_bounds", "optimize.adapt_doe", "scipy.stats.uniform", "print", "len", "zip"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.quantile_bounds", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify._get_default_integrator", "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn.model_trainer", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.model_fail_prob", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.optimize.adapt_doe"], ["", "def", "calc_fail_prob", "(", "self", ",", "model_trainer", ":", "Callable", ",", "start_doe", ":", "Optional", "[", "Tuple", "[", "np", ".", "ndarray", ",", "np", ".", "ndarray", "]", "]", "=", "None", ",", "\n", "step_size", ":", "int", "=", "4", ",", "model_trainer_args", ":", "Optional", "[", "Iterable", "]", "=", "None", ",", "\n", "max_evals", ":", "float", "=", "np", ".", "inf", ",", "convergence_test", ":", "str", "=", "\"t-test\"", ",", "\n", "prob_tol", ":", "float", "=", "1e-6", ",", "\n", "integrator", ":", "Optional", "[", "GenericIntegrator", "]", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        Model list output from model_trainer will be passed as the last argument\n        to the passed limit state functions, which should be in form\n\n\n        Parameters\n        ----------\n        model_trainer : Callable\n            model_trainer recieves input and output coordinates as its first arguments and returns\n            a list of surrogate models, which implement a predict function i.e. y = model.predict(x).\n        start_doe : Optional[Tuple(np.ndarray, np.ndarray)],\n            If passed, the first element will be used as the inputs and the second element as the outputs\n            of the initial model. Otherwise, a start_doe will be generated automatically. The default is None.\n        step_size : int, optional\n            DESCRIPTION. The default is 4.\n        prob_tol : float, optional\n            DESCRIPTION. The default is 1e-6.\n        num_samples : int, optional\n            DESCRIPTION. The default is 4.\n        **kwargs : TYPE\n            DESCRIPTION.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "if", "start_doe", "is", "None", ":", "\n", "            ", "start_doe", "=", "max", "(", "2", "*", "len", "(", "self", ".", "multivariate", ")", ",", "10", ")", "\n", "# num_start = 4", "\n", "", "if", "isinstance", "(", "start_doe", ",", "int", ")", ":", "\n", "            ", "lower", ",", "upper", "=", "self", ".", "multivariate", ".", "quantile_bounds", "(", "prob_tol", ")", "\n", "margs", "=", "[", "stats", ".", "uniform", "(", "l", ",", "u", "-", "l", ")", "for", "l", ",", "u", "in", "zip", "(", "lower", ",", "upper", ")", "]", "\n", "start_doe", "=", "make_doe", "(", "start_doe", ",", "margs", ")", "\n", "", "if", "start_doe", ".", "shape", "[", "0", "]", "<", "2", ":", "\n", "            ", "raise", "ValueError", "(", "\"Start doe has too few samples\"", ")", "\n", "", "cur_doe", "=", "start_doe", ".", "copy", "(", ")", "\n", "if", "integrator", "is", "None", ":", "\n", "            ", "integrator", "=", "_get_default_integrator", "(", "cur_doe", ".", "shape", "[", "1", "]", ",", "prob_tol", ")", "\n", "", "n_samps", "=", "cur_doe", ".", "shape", "[", "0", "]", "\n", "pfs", "=", "[", "]", "\n", "base_args", "=", "deepcopy", "(", "self", ".", "const_args", ")", "\n", "iteration", "=", "0", "\n", "if", "convergence_test", "==", "\"t-test\"", ":", "\n", "            ", "conv_checker", "=", "_is_converged_tscore", "\n", "tol", "=", "0.95", "\n", "if", "integrator", "==", "MC", ":", "\n", "                ", "tol", "=", "0.9", "\n", "", "", "else", ":", "\n", "            ", "conv_checker", "=", "_is_converged_reldif", "\n", "tol", "=", "0.01", "\n", "if", "integrator", "==", "MC", ":", "\n", "                ", "tol", "=", "0.1", "\n", "", "", "while", "n_samps", "<=", "max_evals", ":", "\n", "            ", "print", "(", ")", "\n", "print", "(", "\"Starting model update...\"", ")", "\n", "models", "=", "model_trainer", "(", "cur_doe", ",", "*", "model_trainer_args", ")", "\n", "print", "(", "\"Model update complete\"", ")", "\n", "self", ".", "const_args", "=", "[", "args", "+", "[", "models", "]", "for", "args", "in", "base_args", "]", "\n", "(", "pf", ",", "\n", "pf_var", ",", "\n", "inter", ")", "=", "self", ".", "model_fail_prob", "(", "cur_doe", ",", "integrator", "=", "integrator", ",", "\n", "prob_tol", "=", "prob_tol", ",", "\n", "ttest", "=", "convergence_test", "==", "\"t-test\"", ",", "\n", "**", "kwargs", ")", "\n", "\n", "pf_std", "=", "np", ".", "sqrt", "(", "pf_var", ")", "\n", "n_samps", "=", "cur_doe", ".", "shape", "[", "0", "]", "\n", "isconv", ",", "score", "=", "conv_checker", "(", "tol", ",", "pf", ",", "pf_var", ",", "pfs", ",", "n_samps", ")", "\n", "\n", "msg", "=", "f\"Iter. {iteration} {n_samps} samp.- P(F): {pf:.4e} \"", "\n", "if", "pfs", "and", "pf", ">", "0", ":", "\n", "                ", "msg", "+=", "f\"rel. change: {(pfs[-1]['mu'] - pf) / pf:.4f} \"", "\n", "if", "convergence_test", "!=", "\"t-test\"", ":", "\n", "                    ", "score", "=", "-", "score", "\n", "", "msg", "+=", "f\"score: {score:.4f}\"", "\n", "", "print", "(", "msg", ")", "\n", "iteration", "+=", "1", "\n", "pfs", ".", "append", "(", "{", "\"mu\"", ":", "pf", ",", "\"sigma\"", ":", "pf_std", "}", ")", "\n", "\n", "if", "isconv", ":", "\n", "# Message printed during isconv check", "\n", "                ", "break", "\n", "", "if", "max_evals", "-", "n_samps", "<", "step_size", ":", "\n", "                ", "print", "(", "\"Maximum allowed number of iterations has been reached.\"", ")", "\n", "break", "\n", "", "lower", ",", "upper", "=", "self", ".", "multivariate", ".", "get_probability_bounds", "(", "prob_tol", ")", "\n", "cur_doe", "=", "adapt_doe", "(", "lower", ",", "upper", ",", "cur_doe", ",", "inter", ".", "x_lsf", ",", "inter", ".", "x_fail", ",", "\n", "num_samples", "=", "step_size", ",", "prob_tol", "=", "prob_tol", ",", "\n", "return_update_only", "=", "False", ",", "\n", "**", "kwargs", ")", "\n", "", "self", ".", "const_args", "=", "base_args", "\n", "return", "pf", ",", "pf_var", ",", "cur_doe", ",", "pfs", ",", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.model_fail_prob": [[196, 213], ["_get_default_integrator.", "quantify._get_default_integrator", "_get_default_integrator.calc_fail_prob", "kwargs.get"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify._get_default_integrator", "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.calc_fail_prob"], ["", "def", "model_fail_prob", "(", "self", ",", "doe", ",", "integrator", "=", "None", ",", "prob_tol", "=", "1e-6", ",", "\n", "ttest", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "integrator", "is", "None", ":", "\n", "            ", "integrator", "=", "_get_default_integrator", "(", "doe", ".", "shape", "[", "1", "]", ",", "prob_tol", ")", "\n", "", "inter", "=", "integrator", "(", "self", ".", "multivariate", ",", "self", ".", "constraints", ",", "\n", "constraint_args", "=", "self", ".", "const_args", ",", "\n", "std_norm_to_orig", "=", "self", ".", "u2x", ",", "\n", "orig_to_std_norm", "=", "self", ".", "x2u", ")", "\n", "\n", "if", "integrator", "==", "MC", ":", "\n", "            ", "prob_tol", "=", "prob_tol", "*", "kwargs", ".", "get", "(", "\"CoV\"", ",", "0.1", ")", "**", "-", "2", "\n", "", "if", "ttest", ":", "\n", "            ", "kwargs", "[", "\"converge\"", "]", "=", "False", "\n", "", "fail_prob", ",", "fail_prob_var", "=", "inter", ".", "calc_fail_prob", "(", "prob_tol", "=", "prob_tol", ",", "multi_region", "=", "True", ",", "\n", "post_proc", "=", "True", ",", "num_parallel", "=", "1", ",", "\n", "**", "kwargs", ")", "[", ":", "2", "]", "\n", "return", "fail_prob", ",", "fail_prob_var", ",", "inter", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify.LoLHR4RA.model_constraints": [[214, 216], ["None"], "methods", ["None"], ["", "def", "model_constraints", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify._get_default_integrator": [[30, 39], ["print", "print", "print"], "function", ["None"], ["def", "_get_default_integrator", "(", "num_dims", ",", "prob_tol", ")", ":", "\n", "    ", "if", "prob_tol", ">", "1e-5", ":", "\n", "        ", "print", "(", "\"Using MC\"", ")", "\n", "return", "MC", "\n", "", "if", "num_dims", "<=", "5", ":", "\n", "        ", "print", "(", "\"Using DS\"", ")", "\n", "return", "DS", "\n", "", "print", "(", "\"Using SUSE\"", ")", "\n", "return", "SUSE", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify._is_converged_tscore": [[41, 52], ["scipy.stats.ttest_ind_from_stats", "print"], "function", ["None"], ["", "def", "_is_converged_tscore", "(", "tolerance", ",", "pf", ",", "pf_std", ",", "pfs", ",", "n_samps", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "pfs", "and", "pf", ">", "0", ":", "\n", "        ", "res", "=", "stats", ".", "ttest_ind_from_stats", "(", "pfs", "[", "-", "1", "]", "[", "\"mu\"", "]", ",", "\n", "pfs", "[", "-", "1", "]", "[", "\"sigma\"", "]", ",", "\n", "n_samps", ",", "\n", "pf", ",", "pf_std", ",", "n_samps", ")", "\n", "conv", "=", "res", ".", "pvalue", ">", "tolerance", "\n", "if", "conv", ":", "\n", "            ", "print", "(", "\"Early convergence due to t-test score\"", ",", "res", ".", "pvalue", ")", "\n", "", "return", "conv", ",", "res", ".", "pvalue", "\n", "", "return", "False", ",", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.lolhr.quantify._is_converged_reldif": [[66, 74], ["numpy.abs", "print"], "function", ["None"], ["", "def", "_is_converged_reldif", "(", "tolerance", ",", "pf", ",", "pf_std", ",", "pfs", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "if", "pfs", "and", "pf", ">", "0", ":", "\n", "        ", "diff", "=", "np", ".", "abs", "(", "pf", "-", "pfs", "[", "-", "1", "]", "[", "\"mu\"", "]", ")", "/", "pf", "\n", "conv", "=", "diff", "<", "tolerance", "\n", "if", "conv", ":", "\n", "            ", "print", "(", "\"Early convergence due to relative difference\"", ",", "diff", ")", "\n", "", "return", "conv", ",", "diff", "\n", "", "return", "False", ",", "np", ".", "inf", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.__init__": [[64, 67], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pipeline", ",", "scaler", ")", ":", "\n", "        ", "self", ".", "model", "=", "pipeline", "\n", "self", ".", "scaler", "=", "scaler", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict": [[68, 70], ["svrtrainer.OutputScaledModel.scaler.inverse_transform", "svrtrainer.OutputScaledModel.model.predict().reshape", "svrtrainer.OutputScaledModel.model.predict"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "return", "self", ".", "scaler", ".", "inverse_transform", "(", "self", ".", "model", ".", "predict", "(", "X", ")", ".", "reshape", "(", "(", "X", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.skopt_svr": [[17, 44], ["skopt.utils.use_named_args", "sklearn.svm.SVR", "sklearn.pipeline.Pipeline", "skopt.gp_minimize", "pipe[].set_params", "pipeline.Pipeline.fit", "skopt.space.Real", "skopt.space.Real", "skopt.space.Real", "pipe[].set_params", "pipeline.Pipeline.fit", "Y.ravel", "Y.ravel", "numpy.mean", "sklearn.model_selection.cross_val_score", "sklearn.preprocessing.StandardScaler", "Y.ravel"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.stoch.model.MultiVar.mean"], ["def", "skopt_svr", "(", "X", ",", "Y", ")", ":", "\n", "    ", "space", "=", "[", "Real", "(", "0.9", ",", "2", ",", "name", "=", "'C'", ")", ",", "\n", "Real", "(", "10", "**", "-", "5", ",", "10", "**", "1", ",", "\"log-uniform\"", ",", "name", "=", "'epsilon'", ")", ",", "\n", "Real", "(", "10", "**", "-", "5", ",", "10", "**", "1", ",", "\"log-uniform\"", ",", "name", "=", "'gamma'", ")", ",", "\n", "]", "\n", "\n", "# # this decorator allows your objective function to receive a the parameters as", "\n", "# # keyword arguments. This is particularly convenient when you want to set", "\n", "# # scikit-learn estimator parameters", "\n", "@", "use_named_args", "(", "space", ")", "\n", "def", "objective", "(", "**", "params", ")", ":", "\n", "        ", "pipe", "[", "1", "]", ".", "set_params", "(", "**", "params", ")", "\n", "pipe", ".", "fit", "(", "X", ",", "Y", ".", "ravel", "(", ")", ")", "\n", "return", "-", "np", ".", "mean", "(", "cross_val_score", "(", "pipe", ",", "X", ",", "Y", ".", "ravel", "(", ")", ",", "cv", "=", "5", ",", "n_jobs", "=", "-", "1", ",", "\n", "scoring", "=", "\"neg_mean_squared_error\"", ")", ")", "\n", "# return -pipe.score(X, Y)", "\n", "\n", "", "model", "=", "svm", ".", "SVR", "(", "C", "=", "0.9999", ",", "cache_size", "=", "2000", ",", "# break_ties=True,", "\n", "# class_weight=cweights", "\n", "kernel", "=", "\"rbf\"", ")", "\n", "pipe", "=", "pipeline", ".", "Pipeline", "(", "[", "(", "\"input_scaler\"", ",", "StandardScaler", "(", ")", ")", ",", "\n", "(", "\"SVR\"", ",", "model", ")", "]", ")", "\n", "\n", "res_gp", "=", "gp_minimize", "(", "objective", ",", "space", ",", "n_calls", "=", "50", ",", "random_state", "=", "0", ")", "\n", "pipe", "[", "1", "]", ".", "set_params", "(", "C", "=", "res_gp", ".", "x", "[", "0", "]", ",", "epsilon", "=", "res_gp", ".", "x", "[", "1", "]", ",", "gamma", "=", "res_gp", ".", "x", "[", "2", "]", ")", "\n", "pipe", ".", "fit", "(", "X", ",", "Y", ".", "ravel", "(", ")", ")", "\n", "return", "pipe", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.model_trainer": [[46, 60], ["enumerate", "func().reshape", "print", "numpy.isfinite().all", "sklearn.preprocessing.StandardScaler", "sklearn.preprocessing.StandardScaler.fit_transform", "svrtrainer.OutputScaledModel", "models.append", "numpy.isfinite().all", "svrtrainer.skopt_svr", "func", "numpy.isfinite", "output[].ravel", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.skopt_svr"], ["", "def", "model_trainer", "(", "doe", ",", "*", "funcs", ")", ":", "\n", "    ", "models", "=", "[", "]", "\n", "doe", "=", "doe", "[", "np", ".", "isfinite", "(", "doe", ")", ".", "all", "(", "1", ")", "]", "\n", "for", "i_fun", ",", "func", "in", "enumerate", "(", "funcs", ")", ":", "\n", "        ", "output", "=", "func", "(", "doe", ")", ".", "reshape", "(", "(", "-", "1", ",", "1", ")", ")", "# Assume scalar", "\n", "print", "(", "f\"Training SVR for function {func.__name__} with {output.shape[0]} samples\"", ")", "\n", "inds", "=", "np", ".", "isfinite", "(", "output", ")", ".", "all", "(", "1", ")", "\n", "# print(np.sum(output <= 0), \"fails in DoE.\")", "\n", "# output = output >= 0", "\n", "scaler", "=", "StandardScaler", "(", ")", "\n", "output", "=", "scaler", ".", "fit_transform", "(", "output", "[", "inds", "]", ")", "\n", "model", "=", "OutputScaledModel", "(", "skopt_svr", "(", "doe", "[", "inds", "]", ",", "output", "[", "inds", "]", ".", "ravel", "(", ")", ")", ",", "scaler", ")", "\n", "models", ".", "append", "(", "model", ")", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn.model_trainer": [[20, 27], ["func().reshape", "print", "models.append", "gpsklearn.fit_gpr", "func"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn.fit_gpr"], ["def", "model_trainer", "(", "doe", ",", "*", "functions", ")", ":", "\n", "    ", "models", "=", "[", "]", "\n", "for", "func", "in", "functions", ":", "\n", "        ", "output", "=", "func", "(", "doe", ")", ".", "reshape", "(", "(", "doe", ".", "shape", "[", "0", "]", ",", "-", "1", ")", ")", "\n", "print", "(", "f\"Training GP for function {func.__name__} with {output.shape[0]} samples\"", ")", "\n", "models", ".", "append", "(", "fit_gpr", "(", "doe", ",", "output", ")", ")", "\n", "", "return", "models", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn.fit_gpr": [[29, 80], ["gpsklearn._kernelize", "gpsklearn._make_sum_pipeline", "warnings.catch_warnings", "warnings.simplefilter", "_make_sum_pipeline.fit"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn._kernelize", "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn._make_sum_pipeline"], ["", "def", "fit_gpr", "(", "X", ",", "y", ",", "noise", "=", "False", ",", "anisotropy", "=", "True", ",", "kernel_names", "=", "None", ",", "scale_output", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Fit GP to inputs X and the output y after scaling X.\n    sklearn scales y internally.\n\n    Parameters\n    ----------\n    X : np.ndarray\n        input array with shape (num_sample, num_dimensions)\n\n    y : np.ndarray\n        output array with shape (num_sample, num_outputs)\n\n    noise : bool\n        Controls whether to train with noise aka. additive white kernel\n\n    anisotropy : bool\n        Controls if the anisotropic kernels should be trained too.\n        Isotropic versions will be trained in any case\n\n    kernel_names : iterable\n        Iterable of kernel names to test. Leaving this None is\n        recommended. Possible kernels:\n            'RBF', 'Matern0.5', 'Matern1.5', 'Matern2.5', 'RationalQuadratic'\n        Notice no space after Matern kernels.Other Kernel names from sklearn as \n        strings are also allowed with limited functionality of gradients.\n    scale_output : bool\n        If True, the output is scaled. Defaults to False\n\n\n    Returns\n    -------\n    gp : sklearn.Pipeline\n        Fitted GP model with input scaling\n\n    Usage\n    ------\n    >>> gp = fit_gpr(X_train, y_train)\n    >>> y_pred = gp.predict(y_test)\n    \"\"\"", "\n", "kern_names", ",", "kernel_classes", "=", "_kernelize", "(", "kernel_names", ",", "anisotropy", ")", "\n", "n_dim", "=", "X", ".", "shape", "[", "1", "]", "\n", "restarts", "=", "50", "if", "X", ".", "shape", "[", "0", "]", "<", "256", "else", "10", "\n", "theta_start", "=", "1e-3", "\n", "\n", "pipe", "=", "_make_sum_pipeline", "(", "kern_names", ",", "kernel_classes", ",", "noise", ",", "n_dim", ",", "\n", "theta_start", ",", "scale_output", ",", "restarts", "=", "restarts", ",", "\n", ")", "\n", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "        ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ",", "category", "=", "RuntimeWarning", ")", "\n", "return", "pipe", ".", "fit", "(", "X", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn._kernelize": [[82, 92], ["globals", "str"], "function", ["None"], ["", "", "def", "_kernelize", "(", "kernel_names", ",", "anisotropy", ")", ":", "\n", "    ", "if", "kernel_names", "is", "None", ":", "\n", "        ", "kernel_names", "=", "[", "\"RBF\"", ",", "\"RationalQuadratic\"", ",", "\"Matern0.5\"", ",", "\"Matern1.5\"", ",", "\"Matern2.5\"", "]", "\n", "", "kern_names", "=", "kernel_names", "[", ":", "]", "\n", "globs", "=", "globals", "(", ")", "\n", "kernel_classes", "=", "[", "globs", "[", "k", "]", "if", "\"Matern\"", "not", "in", "k", "else", "globs", "[", "k", "[", ":", "-", "3", "]", "]", "for", "k", "in", "kern_names", "]", "\n", "if", "anisotropy", ":", "\n", "        ", "kern_names", "+=", "[", "n", "+", "\" anisotropic\"", "for", "n", "in", "kern_names", "if", "n", "!=", "\"RationalQuadratic\"", "]", "\n", "kernel_classes", "+=", "[", "k", "for", "k", "in", "kernel_classes", "if", "\"RationalQuadratic\"", "not", "in", "str", "(", "k", ")", "]", "\n", "", "return", "kern_names", ",", "kernel_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn._make_sum_pipeline": [[94, 143], ["tuple", "zip", "isotropes.items", "anisotropes.items", "itertools.chain", "sklearn.gaussian_process.GaussianProcessRegressor", "sklearn.pipeline.Pipeline", "numpy.ones", "sklearn.gaussian_process.kernels.ConstantKernel", "sklearn.gaussian_process.kernels.WhiteKernel", "isotropes.keys", "anisotropes.keys", "name.lower", "isotropes.items", "kernel_name.lower", "float", "kernel_class", "kernel_class", "kernel_name.lower", "float", "kernel_class", "kernel_class", "sklearn.preprocessing.StandardScaler", "name.split"], "function", ["None"], ["", "def", "_make_sum_pipeline", "(", "kernel_names", ",", "kernel_classes", ",", "noise", ",", "n_dim", ",", "\n", "theta", "=", "1e-3", ",", "scale_output", "=", "False", ",", "restarts", "=", "10", ",", "\n", ")", ":", "\n", "    ", "\"\"\" Create Pipline Object from inputs\"\"\"", "\n", "\n", "bounds", "=", "tuple", "(", "(", "1e-5", ",", "1e5", ")", ")", "\n", "isotropes", ",", "anisotropes", "=", "{", "}", ",", "{", "}", "\n", "for", "name", ",", "kernel_class", "in", "zip", "(", "kernel_names", ",", "kernel_classes", ")", ":", "\n", "        ", "if", "\"anisotropic\"", "in", "name", ".", "lower", "(", ")", ":", "\n", "            ", "anisotropes", "[", "name", ".", "split", "(", ")", "[", "0", "]", "]", "=", "kernel_class", "\n", "\n", "", "else", ":", "\n", "            ", "isotropes", "[", "name", "]", "=", "kernel_class", "\n", "", "", "isotropes", "=", "{", "name", ":", "val", "for", "name", ",", "val", "in", "isotropes", ".", "items", "(", ")", "if", "name", "not", "in", "anisotropes", "}", "\n", "\n", "kernel", "=", "0", "\n", "for", "kernel_name", ",", "kernel_class", "in", "isotropes", ".", "items", "(", ")", ":", "\n", "        ", "if", "\"matern\"", "in", "kernel_name", ".", "lower", "(", ")", ":", "\n", "# also this", "\n", "            ", "nu", "=", "float", "(", "kernel_name", "[", "-", "3", ":", "]", ")", "\n", "kernel", "+=", "kernel_class", "(", "length_scale", "=", "theta", ",", "nu", "=", "nu", ",", "\n", "length_scale_bounds", "=", "bounds", ")", "\n", "", "else", ":", "\n", "            ", "kernel", "+=", "kernel_class", "(", "theta", ")", "\n", "", "", "theta", "=", "theta", "*", "np", ".", "ones", "(", "n_dim", ")", "\n", "bounds", "=", "[", "bounds", "]", "*", "n_dim", "\n", "for", "kernel_name", ",", "kernel_class", "in", "anisotropes", ".", "items", "(", ")", ":", "\n", "        ", "if", "\"matern\"", "in", "kernel_name", ".", "lower", "(", ")", ":", "\n", "# also this", "\n", "            ", "nu", "=", "float", "(", "kernel_name", "[", "-", "3", ":", "]", ")", "\n", "kernel", "+=", "kernel_class", "(", "length_scale", "=", "theta", ",", "nu", "=", "nu", ",", "\n", "length_scale_bounds", "=", "bounds", ")", "\n", "", "else", ":", "\n", "            ", "kernel", "+=", "kernel_class", "(", "length_scale", "=", "theta", ",", "length_scale_bounds", "=", "bounds", ")", "\n", "\n", "", "", "kernel", "=", "kernel", "*", "ConstantKernel", "(", ")", "\n", "\n", "if", "noise", ":", "\n", "        ", "kernel", "+=", "WhiteKernel", "(", ")", "\n", "", "kernel_name", "=", "\"\"", "\n", "for", "name", "in", "itertools", ".", "chain", "(", "isotropes", ".", "keys", "(", ")", ",", "anisotropes", ".", "keys", "(", ")", ")", ":", "\n", "        ", "kernel_name", "+=", "name", "+", "\" + \"", "\n", "", "kernel_name", "=", "kernel_name", "[", ":", "-", "3", "]", "# remove last plus", "\n", "\n", "gpr", "=", "GaussianProcessRegressor", "(", "kernel", "=", "kernel", ",", "n_restarts_optimizer", "=", "restarts", ",", "# alpha=1e-10,", "\n", "normalize_y", "=", "scale_output", ",", "optimizer", "=", "_gp_optimizer", ")", "\n", "pipe", "=", "Pipeline", "(", "[", "(", "\"input_scaler\"", ",", "StandardScaler", "(", ")", ")", ",", "\n", "(", "\"GP \"", "+", "kernel_name", ",", "gpr", ")", "]", ")", "\n", "return", "pipe", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.gpsklearn._gp_optimizer": [[145, 166], ["scipy.optimize.minimize", "print", "print"], "function", ["None"], ["", "def", "_gp_optimizer", "(", "obj_func", ",", "initial_theta", ",", "bounds", ")", ":", "\n", "# * 'obj_func' is the objective function to be minimized, which", "\n", "#   takes the hyperparameters theta as parameter and an", "\n", "#   optional flag eval_gradient, which determines if the", "\n", "#   gradient is returned additionally to the function value", "\n", "# * 'initial_theta': the initial value for theta, which can be", "\n", "#   used by local optimizers", "\n", "# * 'bounds': the bounds on the values of theta", "\n", "    ", "opt_res", "=", "minimize", "(", "obj_func", ",", "initial_theta", ",", "method", "=", "\"L-BFGS-B\"", ",", "jac", "=", "True", ",", "\n", "bounds", "=", "bounds", ",", "\n", "options", "=", "{", "\"maxiter\"", ":", "1e5", ",", "\"maxfun\"", ":", "2e5", ",", "\"maxls\"", ":", "1000", ",", "\n", "\"gtol\"", ":", "2.220446049250313e-09", ",", "'disp'", ":", "0", "}", ")", "\n", "if", "not", "opt_res", ".", "success", ":", "\n", "        ", "print", "(", "\"Optimization failed\"", ")", "\n", "print", "(", "opt_res", ".", "message", ")", "\n", "", "theta_opt", ",", "func_min", "=", "opt_res", ".", "x", ",", "opt_res", ".", "fun", "\n", "\n", "# Returned are the best found hyperparameters theta and", "\n", "# the corresponding value of the target function.", "\n", "\n", "return", "theta_opt", ",", "func_min", "\n", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.__init__": [[47, 114], ["inspyred.ec.Bounder", "len", "inspyred_optimizer._get_method", "kwargs.get", "inspyred_optimizer.InspyredOptimizer.reset", "numpy.array().ravel", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer._get_method", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.reset"], ["    ", "def", "__init__", "(", "self", ",", "obj_con", ",", "lb", ",", "ub", ",", "method", "=", "None", ",", "args", "=", "(", ")", ",", "maximize", "=", "False", ",", "obj_con_path", "=", "\"\"", ",", "scale_objs", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        \n\n        Parameters\n        ----------\n        obj_con : function\n            the wrapper for the objective and constraint functions\n            must be of the following form, where inputs is a numpy\n            array with shape = (n_samples, n_dimensions)\n            def obj_con(inputs, *args, **kwargs):\n                objs, cons = [], []\n                for input in inputs\n                    objs.append([o(input) for o in objectives])\n                    cons.append([c(input) for c in constraints])\n            # np.array Not necessary as this will be done internally too\n            # it is important to return something even if n_cons = 0\n            return np.array(objs), np.array(cons) \n                \n        lb : Iterable\n            lower optimization bounds\n        ub : Iterable\n            upper optimization bounds\n\n        method : Optional[str]\n            Optimization method to use. Default: 'NSGAII'\n        maximize : bool\n            If True, maximization is assumed. Default: False\n\n        args : Iterable\n            Arguments to pass to obj_con\n\n        obj_con_path : str\n            If passed, objectives and constraints of every candidate are written as arrays to path\n            obj_con_path + \"_gen\" + str(self.nit) + \".npz\"\n            Make sure the directory exists containing the path exists! Default: \"\"\n\n        scale_objs : bool\n            If True, objectives will be scaled. Useful for problems with constraints, where constraints are enforced\n            using a punishment function\n\n\n        **kwargs: dict\n            Any keyword arguments that should be passed to obj_con\n\n\n        Returns\n        -------\n        None.\n\n        \"\"\"", "\n", "\n", "self", ".", "bounds", "=", "Bounder", "(", "lb", ",", "ub", ")", "\n", "self", ".", "n_dims", "=", "len", "(", "np", ".", "array", "(", "lb", ")", ".", "ravel", "(", ")", ")", "\n", "self", ".", "obj_con", "=", "obj_con", "\n", "self", ".", "method", ",", "self", ".", "method_", "=", "_get_method", "(", "method", ")", "\n", "self", ".", "maximize", "=", "maximize", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "self", ".", "obj_con_path", "=", "obj_con_path", "\n", "self", ".", "verbose", "=", "kwargs", ".", "get", "(", "\"verbose\"", ",", "0", ")", "\n", "self", ".", "reset", "(", ")", "\n", "self", ".", "scale_objs", "=", "scale_objs", "\n", "self", ".", "obj_scales_", "=", "None", "\n", "self", ".", "counter_start_pop", ",", "self", ".", "nfev", ",", "self", ".", "nit", "=", "-", "1", ",", "0", ",", "0", "\n", "self", ".", "start_gen", ",", "self", ".", "archive", ",", "self", ".", "punish_factor", ",", "self", ".", "pareto_size", "=", "None", ",", "None", ",", "1", ",", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.reset": [[115, 119], ["None"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "counter_start_pop", "=", "-", "1", "\n", "self", ".", "nfev", ",", "self", ".", "nit", "=", "0", ",", "0", "\n", "self", ".", "archive", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.evaluator": [[120, 151], ["numpy.array", "inspyred_optimizer.InspyredOptimizer.obj_con", "inspyred_optimizer.make_pareto", "time.time.time", "inspyred_optimizer._atleast2d", "inspyred_optimizer._atleast2d", "numpy.savez", "inspyred_optimizer.InspyredOptimizer.punish", "print", "numpy.abs", "print", "numpy.median", "str", "time.time.time", "max", "min"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.optimization.rrdo.RRDO.obj_con", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.make_pareto", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer._atleast2d", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer._atleast2d", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.punish"], ["", "def", "evaluator", "(", "self", ",", "candidates", ",", "args", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "t0", "=", "time", "(", ")", "\n", "", "candidates", "=", "np", ".", "array", "(", "candidates", ")", "\n", "self", ".", "nit", "+=", "1", "\n", "self", ".", "nfev", "+=", "candidates", ".", "shape", "[", "0", "]", "\n", "# Just call the evaluate of the problem", "\n", "objs", ",", "cons", "=", "self", ".", "obj_con", "(", "candidates", ",", "*", "self", ".", "args", ",", "**", "self", ".", "kwargs", ")", "\n", "objs", ",", "cons", "=", "_atleast2d", "(", "objs", ")", ",", "_atleast2d", "(", "cons", ")", "\n", "if", "self", ".", "scale_objs", ":", "\n", "            ", "if", "self", ".", "obj_scales_", "is", "None", ":", "\n", "                ", "self", ".", "obj_scales_", "=", "np", ".", "abs", "(", "np", ".", "median", "(", "objs", ",", "axis", "=", "0", ")", ")", "\n", "self", ".", "obj_scales_", "[", "self", ".", "obj_scales_", "<", "1e-3", "]", "=", "1e-3", "\n", "", "objs", "/=", "self", ".", "obj_scales_", "\n", "", "if", "self", ".", "obj_con_path", ":", "\n", "            ", "path", "=", "self", ".", "obj_con_path", "+", "\"_gen\"", "+", "str", "(", "self", ".", "nit", ")", "+", "\".npz\"", "\n", "np", ".", "savez", "(", "path", ",", "candidates", ",", "objs", ",", "cons", ")", "\n", "\n", "", "if", "cons", ".", "size", ">", "0", ":", "\n", "            ", "objs", "=", "self", ".", "punish", "(", "objs", ",", "cons", ")", "\n", "\n", "", "if", "self", ".", "verbose", ":", "\n", "# Don't count initial population in prints to avoid confusion", "\n", "            ", "print", "(", "\"Its.\"", ",", "self", ".", "nit", "-", "1", ",", "\" Evals.\"", ",", "self", ".", "nfev", ",", "\"-\"", ",", "time", "(", ")", "-", "t0", ",", "\"seconds.\"", ")", "\n", "if", "objs", ".", "shape", "[", "-", "1", "]", "<", "2", ":", "\n", "                ", "if", "self", ".", "maximize", ":", "\n", "                    ", "best_obj", "=", "max", "(", "objs", ")", "\n", "", "else", ":", "\n", "                    ", "best_obj", "=", "min", "(", "objs", ")", "\n", "", "print", "(", "\"Best objective\"", ",", "best_obj", ",", "end", "=", "\"\\n\\n\"", ")", "\n", "", "", "return", "make_pareto", "(", "objs", ",", "self", ".", "maximize", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.generator": [[152, 155], ["inspyred_optimizer.InspyredOptimizer.start_gen[].tolist"], "methods", ["None"], ["", "def", "generator", "(", "self", ",", "random", ",", "args", ")", ":", "\n", "        ", "self", ".", "counter_start_pop", "+=", "1", "\n", "return", "self", ".", "start_gen", "[", "self", ".", "counter_start_pop", "]", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.punish": [[156, 165], ["fails.any.any.any", "numpy.tile", "numpy.sum"], "methods", ["None"], ["", "def", "punish", "(", "self", ",", "objs", ",", "cons", ")", ":", "\n", "        ", "fails", "=", "cons", "<", "0", "\n", "factors", "=", "-", "np", ".", "sum", "(", "cons", "*", "fails", ",", "axis", "=", "1", ",", "keepdims", "=", "True", ")", "*", "self", ".", "punish_factor", "\n", "if", "self", ".", "obj_scales_", "is", "not", "None", ":", "\n", "            ", "factors", "=", "np", ".", "tile", "(", "factors", ",", "objs", ".", "shape", "[", "1", "]", ")", "\n", "factors", "/=", "self", ".", "obj_scales_", "\n", "", "fails", "=", "fails", ".", "any", "(", "1", ")", "\n", "objs", "[", "fails", "]", "+=", "factors", "[", "fails", "]", "\n", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.my_archive_backup": [[166, 181], ["sorted", "len", "inspyred_optimizer.InspyredOptimizer.archive.append", "sorted"], "methods", ["None"], ["", "def", "my_archive_backup", "(", "self", ",", "population", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "for", "best", "in", "population", ":", "\n", "            ", "if", "self", ".", "archive", "is", "None", ":", "\n", "                ", "self", ".", "archive", "=", "[", "best", "]", "\n", "", "elif", "best", "in", "self", ".", "archive", ":", "\n", "                ", "continue", "\n", "", "elif", "len", "(", "self", ".", "archive", ")", "<", "self", ".", "pareto_size", ":", "\n", "                ", "self", ".", "archive", ".", "append", "(", "best", ")", "\n", "", "elif", "best", ".", "fitness", ">", "self", ".", "archive", "[", "-", "1", "]", ".", "fitness", ":", "\n", "                ", "self", ".", "archive", "[", "-", "1", "]", "=", "best", "\n", "self", ".", "archive", "=", "sorted", "(", "self", ".", "archive", ",", "key", "=", "lambda", "x", ":", "x", ".", "fitness", ",", "reverse", "=", "False", ")", "\n", "", "elif", "best", ".", "fitness", "<", "self", ".", "archive", "[", "-", "1", "]", ".", "fitness", ":", "\n", "                ", "pass", "\n", "\n", "", "", "self", ".", "archive", "=", "sorted", "(", "self", ".", "archive", ",", "key", "=", "lambda", "x", ":", "x", ".", "fitness", ",", "reverse", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.optimize": [[182, 187], ["inspyred_optimizer.InspyredOptimizer.init_optimize", "inspyred_optimizer.InspyredOptimizer.run_optimize"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.init_optimize", "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.run_optimize"], ["", "def", "optimize", "(", "self", ",", "pop_size", "=", "100", ",", "max_gens", "=", "100", ",", "punish_factor", "=", "100", ",", "\n", "pareto_size", "=", "100", ",", "verbose", "=", "0", ",", "start_gen", "=", "None", ")", ":", "\n", "        ", "ea", "=", "self", ".", "init_optimize", "(", "pop_size", "=", "pop_size", ",", "punish_factor", "=", "punish_factor", ",", "pareto_size", "=", "pareto_size", ",", "\n", "verbose", "=", "verbose", ",", "start_gen", "=", "start_gen", ")", "\n", "return", "self", ".", "run_optimize", "(", "ea", ",", "pop_size", "=", "pop_size", ",", "max_gens", "=", "max_gens", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.run_optimize": [[188, 199], ["ea.evolve", "max", "max"], "methods", ["None"], ["", "def", "run_optimize", "(", "self", ",", "ea", ",", "pop_size", "=", "100", ",", "max_gens", "=", "100", ")", ":", "\n", "        ", "_", "=", "ea", ".", "evolve", "(", "generator", "=", "self", ".", "generator", ",", "\n", "evaluator", "=", "self", ".", "evaluator", ",", "\n", "pop_size", "=", "pop_size", ",", "\n", "maximize", "=", "True", ",", "# maximization is handled in make_pareto function...", "\n", "bounder", "=", "self", ".", "bounds", ",", "\n", "max_generations", "=", "max_gens", ",", "\n", "neighborhood_size", "=", "max", "(", "5", ",", "pop_size", "//", "20", ")", ",", "\n", "max_archive_size", "=", "max", "(", "2", "*", "pop_size", ",", "self", ".", "pareto_size", ")", ",", "\n", "num_elites", "=", "2", ")", "\n", "return", "ea", ".", "archive", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.init_optimize": [[200, 232], ["inspyred_optimizer.InspyredOptimizer.reset", "random.Random", "random.Random.seed", "inspyred_optimizer.InspyredOptimizer.method_", "scipy.stats.uniform", "print", "duqo.doe.lhs.make_doe", "print", "range"], "methods", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.InspyredOptimizer.reset", "home.repos.pwc.inspect_result.canbooo_duqo.doe.lhs.make_doe"], ["", "def", "init_optimize", "(", "self", ",", "pop_size", "=", "100", ",", "punish_factor", "=", "100", ",", "pareto_size", "=", "100", ",", "verbose", "=", "0", ",", "start_gen", "=", "None", ")", ":", "\n", "        ", "self", ".", "reset", "(", ")", "\n", "self", ".", "punish_factor", "=", "punish_factor", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "pareto_size", "=", "pareto_size", "\n", "opt_margs", "=", "[", "uniform", "(", "self", ".", "bounds", ".", "lower_bound", "[", "k", "]", ",", "self", ".", "bounds", ".", "upper_bound", "[", "k", "]", "-", "self", ".", "bounds", ".", "lower_bound", "[", "k", "]", ")", "\n", "for", "k", "in", "range", "(", "self", ".", "n_dims", ")", "]", "\n", "if", "start_gen", "is", "None", "or", "start_gen", ".", "shape", "!=", "(", "pop_size", ",", "self", ".", "n_dims", ")", ":", "\n", "            ", "print", "(", "\"Generating start generation\"", ")", "\n", "self", ".", "start_gen", "=", "make_doe", "(", "pop_size", ",", "opt_margs", ",", "num_tries", "=", "100", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Using the passed generation\"", ")", "\n", "self", ".", "start_gen", "=", "start_gen", "\n", "", "prng", "=", "Random", "(", ")", "\n", "prng", ".", "seed", "(", "7", ")", "\n", "\n", "ea", "=", "self", ".", "method_", "(", "prng", ")", "\n", "ea", ".", "terminator", "=", "[", "terminators", ".", "generation_termination", ",", "\n", "terminators", ".", "diversity_termination", ",", "\n", "]", "\n", "\n", "ea", ".", "variator", "=", "[", "variators", ".", "blend_crossover", ",", "\n", "variators", ".", "gaussian_mutation", "]", "\n", "\n", "ea", ".", "replacer", "=", "replacers", ".", "generational_replacement", "\n", "\n", "ea", ".", "observer", "=", "self", ".", "my_archive_backup", "\n", "\n", "# ea.selector = selectors.rank_selection", "\n", "if", "\"PSO\"", "in", "self", ".", "method", ":", "\n", "            ", "ea", ".", "topology", "=", "topologies", ".", "ring_topology", "\n", "", "return", "ea", "", "", "", ""]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer.make_pareto": [[19, 21], ["inspyred.ec.emo.Pareto", "obs.tolist"], "function", ["None"], ["def", "make_pareto", "(", "obs", ",", "maximize", "=", "False", ")", ":", "\n", "    ", "return", "[", "emo", ".", "Pareto", "(", "obj", ",", "maximize", "=", "maximize", ")", "for", "obj", "in", "obs", ".", "tolist", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer._get_method": [[23, 37], ["method.upper.upper"], "function", ["None"], ["", "def", "_get_method", "(", "method", ")", ":", "\n", "    ", "if", "method", "is", "None", ":", "\n", "        ", "return", "\"NSGA\"", ",", "emo", ".", "NSGA2", "\n", "", "method", "=", "method", ".", "upper", "(", ")", "\n", "if", "method", "==", "\"DEA\"", ":", "\n", "        ", "return", "method", ",", "ec", ".", "DEA", "\n", "", "if", "method", "==", "\"NSGA\"", ":", "\n", "        ", "return", "method", ",", "emo", ".", "NSGA2", "\n", "", "if", "method", "==", "\"PAES\"", ":", "\n", "        ", "return", "method", ",", "emo", ".", "PAES", "\n", "", "if", "method", "==", "\"PSO\"", ":", "\n", "        ", "return", "method", ",", "PSO", "\n", "", "if", "method", "==", "\"EC\"", ":", "\n", "        ", "return", "method", ",", "ec", ".", "EvolutionaryComputation", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.extras.inspyred_optimizer._atleast2d": [[39, 44], ["numpy.array", "x.reshape.reshape"], "function", ["None"], ["", "", "def", "_atleast2d", "(", "x", ")", ":", "\n", "    ", "x", "=", "np", ".", "array", "(", "x", ")", "\n", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.scale_styta": [[10, 14], ["x.reshape.reshape", "numpy.sum"], "function", ["None"], ["def", "scale_styta", "(", "x", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "return", "np", ".", "sum", "(", "x", "**", "4", "-", "16", "*", "x", "**", "2", "+", "5", "*", "x", ",", "axis", "=", "1", ")", "/", "180", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.scale_square": [[16, 18], ["numpy.sum"], "function", ["None"], ["", "def", "scale_square", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "sum", "(", "(", "x", "-", "2.25", ")", "**", "2", ",", "axis", "=", "1", ")", "/", "50", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.scale_tricky_cos": [[20, 23], ["numpy.sum", "numpy.cos"], "function", ["None"], ["", "def", "scale_tricky_cos", "(", "x", ")", ":", "\n", "    ", "alpha", "=", "1.475", "\n", "return", "7.", "-", "np", ".", "sum", "(", "(", "x", "/", "alpha", ")", "**", "2", "-", "5", "*", "np", ".", "cos", "(", "2", "*", "np", ".", "pi", "*", "x", "/", "alpha", ")", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.obj_fun": [[25, 35], ["numpy.zeros", "enumerate", "x.reshape.reshape", "example2.scale_styta", "numpy.array", "example2.scale_square"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.scale_styta", "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.scale_square"], ["", "def", "obj_fun", "(", "x", ",", "locs", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "objs", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "scale_styta", "(", "x", ")", "\n", "", "elif", "loc", "==", "1", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "scale_square", "(", "x", ")", "\n", "", "", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.con_fun": [[37, 45], ["numpy.zeros", "enumerate", "x.reshape.reshape", "example2.scale_tricky_cos", "numpy.array"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.scale_tricky_cos"], ["", "def", "con_fun", "(", "x", ",", "locs", "=", "(", "0", ",", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "cons", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "cons", "[", ":", ",", "i_loc", "]", "=", "scale_tricky_cos", "(", "x", ")", "\n", "", "", "return", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.model_obj": [[47, 59], ["numpy.zeros", "enumerate", "x.reshape.reshape", "numpy.isfinite().all", "print", "models[].predict().ravel", "numpy.isfinite", "numpy.array", "models[].predict().ravel", "numpy.logical_not", "models[].predict", "numpy.isfinite().any", "models[].predict", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict", "home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict"], ["", "def", "model_obj", "(", "x", ",", "models", "=", "None", ",", "locs", "=", "(", "0", ",", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "not", "np", ".", "isfinite", "(", "x", ")", ".", "all", "(", ")", ":", "\n", "        ", "print", "(", "\"model_obj\"", ",", "x", "[", "np", ".", "logical_not", "(", "np", ".", "isfinite", "(", "x", ")", ".", "any", "(", "1", ")", ")", "]", ")", "\n", "", "objs", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "models", "[", "0", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "elif", "loc", "==", "1", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "models", "[", "1", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example2.model_con": [[61, 71], ["numpy.zeros", "enumerate", "x.reshape.reshape", "numpy.isfinite().all", "print", "models[].predict().ravel", "numpy.isfinite", "numpy.array", "numpy.logical_not", "models[].predict", "numpy.isfinite().any", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict"], ["", "def", "model_con", "(", "x", ",", "models", "=", "None", ",", "locs", "=", "(", "0", ",", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "not", "np", ".", "isfinite", "(", "x", ")", ".", "all", "(", ")", ":", "\n", "        ", "print", "(", "\"model_con\"", ",", "x", "[", "np", ".", "logical_not", "(", "np", ".", "isfinite", "(", "x", ")", ".", "any", "(", "1", ")", ")", "]", ")", "\n", "", "cons", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "cons", "[", ":", ",", "i_loc", "]", "=", "models", "[", "2", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "", "return", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.scale_styta": [[10, 14], ["x.reshape.reshape", "numpy.sum"], "function", ["None"], ["def", "scale_styta", "(", "x", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "return", "np", ".", "sum", "(", "x", "**", "4", "-", "16", "*", "x", "**", "2", "+", "5", "*", "x", ",", "axis", "=", "1", ")", "/", "180", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.scale_lin": [[16, 20], ["x.reshape.reshape", "x.reshape.sum", "numpy.sqrt"], "function", ["None"], ["", "def", "scale_lin", "(", "x", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "return", "(", "5", "*", "np", ".", "sqrt", "(", "x", ".", "shape", "[", "1", "]", ")", "-", "x", ".", "sum", "(", "1", ")", ")", "/", "7", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.himmblau": [[22, 28], ["x.reshape.reshape"], "function", ["None"], ["", "def", "himmblau", "(", "x", ",", "gamma", "=", "1", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "res", "=", "(", "(", "x", "[", ":", ",", "0", "]", "**", "2", "+", "x", "[", ":", ",", "1", "]", ")", "/", "1.81", "-", "11", ")", "**", "2", "\n", "res", "+=", "(", "(", "x", "[", ":", ",", "0", "]", "+", "x", "[", ":", ",", "1", "]", "**", "2", ")", "/", "1.81", "-", "7", ")", "**", "2", "\n", "return", "res", "-", "45", "*", "gamma", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.obj_fun": [[30, 40], ["numpy.zeros", "enumerate", "x.reshape.reshape", "example1.scale_lin", "numpy.array", "example1.scale_styta"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.scale_lin", "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.scale_styta"], ["", "def", "obj_fun", "(", "x", ",", "locs", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "objs", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "scale_lin", "(", "x", ")", "\n", "", "elif", "loc", "==", "1", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "scale_styta", "(", "x", ")", "\n", "", "", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.con_fun": [[42, 50], ["numpy.zeros", "enumerate", "x.reshape.reshape", "example1.himmblau", "numpy.array"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.himmblau"], ["", "def", "con_fun", "(", "x", ",", "locs", "=", "(", "0", ",", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "cons", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "cons", "[", ":", ",", "i_loc", "]", "=", "himmblau", "(", "x", ")", "\n", "", "", "return", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.model_obj": [[52, 64], ["numpy.zeros", "enumerate", "x.reshape.reshape", "numpy.isfinite().all", "print", "models[].predict().ravel", "numpy.isfinite", "numpy.array", "models[].predict().ravel", "numpy.logical_not", "models[].predict", "numpy.isfinite().any", "models[].predict", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict", "home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict"], ["", "def", "model_obj", "(", "x", ",", "models", "=", "None", ",", "locs", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "not", "np", ".", "isfinite", "(", "x", ")", ".", "all", "(", ")", ":", "\n", "        ", "print", "(", "\"model_obj\"", ",", "x", "[", "np", ".", "logical_not", "(", "np", ".", "isfinite", "(", "x", ")", ".", "any", "(", "1", ")", ")", "]", ")", "\n", "", "objs", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "models", "[", "0", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "elif", "loc", "==", "1", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "models", "[", "1", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example1.model_con": [[66, 76], ["numpy.zeros", "enumerate", "x.reshape.reshape", "numpy.isfinite().all", "print", "models[].predict().ravel", "numpy.isfinite", "numpy.array", "numpy.logical_not", "models[].predict", "numpy.isfinite().any", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict"], ["", "def", "model_con", "(", "x", ",", "models", "=", "None", ",", "locs", "=", "(", "0", ",", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "not", "np", ".", "isfinite", "(", "x", ")", ".", "all", "(", ")", ":", "\n", "        ", "print", "(", "\"model_con\"", ",", "x", "[", "np", ".", "logical_not", "(", "np", ".", "isfinite", "(", "x", ")", ".", "any", "(", "1", ")", ")", "]", ")", "\n", "", "cons", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "cons", "[", ":", ",", "i_loc", "]", "=", "models", "[", "2", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "", "return", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.oblique_bending": [[11, 18], ["numpy.maximum", "numpy.prod", "x.reshape.reshape"], "function", ["None"], ["def", "oblique_bending", "(", "x", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "# M1 - 0 | M2 - 1 | P/F - 2 | f_y - 3 | b - 4 | h - 5", "\n", "", "x", "[", ":", ",", "3", "]", "=", "np", ".", "maximum", "(", "x", "[", ":", ",", "3", "]", ",", "1e-6", ")", "\n", "bhfy", "=", "np", ".", "prod", "(", "x", "[", ":", ",", "[", "3", ",", "4", ",", "5", "]", "]", ",", "axis", "=", "1", ")", "\n", "return", "1", "-", "(", "4", "*", "x", "[", ":", ",", "0", "]", "/", "bhfy", "/", "x", "[", ":", ",", "5", "]", ")", "-", "(", "4", "*", "x", "[", ":", ",", "1", "]", "/", "bhfy", "/", "x", "[", ":", ",", "4", "]", ")", "-", "(", "x", "[", ":", ",", "2", "]", "/", "bhfy", ")", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.obj_fun": [[20, 28], ["numpy.zeros", "enumerate", "x.reshape.reshape", "numpy.array"], "function", ["None"], ["", "def", "obj_fun", "(", "x", ",", "locs", "=", "(", "0", ",", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "objs", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "objs", "[", ":", ",", "i_loc", "]", "=", "x", "[", ":", ",", "4", "]", "*", "x", "[", ":", ",", "5", "]", "\n", "", "", "return", "objs", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.con_fun": [[30, 41], ["numpy.zeros", "enumerate", "x.reshape.reshape", "example3.oblique_bending", "numpy.array", "numpy.minimum"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.oblique_bending"], ["", "def", "con_fun", "(", "x", ",", "locs", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "cons", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "cons", "[", ":", ",", "i_loc", "]", "=", "oblique_bending", "(", "x", ")", "\n", "", "elif", "loc", "==", "1", ":", "\n", "            ", "prop", "=", "x", "[", ":", ",", "4", "]", "/", "x", "[", ":", ",", "5", "]", "\n", "cons", "[", ":", ",", "i_loc", "]", "=", "np", ".", "minimum", "(", "prop", "-", "0.5", ",", "2", "-", "prop", ")", "\n", "", "", "return", "cons", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.model_obj": [[43, 45], ["example3.obj_fun"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.obj_fun"], ["", "def", "model_obj", "(", "x", ",", "**", "kwargs", ")", ":", "\n", "    ", "return", "obj_fun", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.canbooo_duqo.submission_examples.example3.model_con": [[47, 60], ["numpy.zeros", "enumerate", "x.reshape.reshape", "numpy.isfinite().all", "print", "models[].predict().ravel", "numpy.isfinite", "numpy.array", "numpy.minimum", "numpy.logical_not", "models[].predict", "numpy.isfinite().any", "numpy.isfinite"], "function", ["home.repos.pwc.inspect_result.canbooo_duqo.extras.svrtrainer.OutputScaledModel.predict"], ["", "def", "model_con", "(", "x", ",", "models", "=", "None", ",", "locs", "=", "(", "0", ",", "1", ")", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "<", "2", ":", "\n", "        ", "x", "=", "x", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "", "if", "not", "np", ".", "isfinite", "(", "x", ")", ".", "all", "(", ")", ":", "\n", "        ", "print", "(", "\"model_con\"", ",", "x", "[", "np", ".", "logical_not", "(", "np", ".", "isfinite", "(", "x", ")", ".", "any", "(", "1", ")", ")", "]", ")", "\n", "", "cons", "=", "np", ".", "zeros", "(", "(", "x", ".", "shape", "[", "0", "]", ",", "np", ".", "array", "(", "locs", ")", ".", "size", ")", ")", "\n", "for", "i_loc", ",", "loc", "in", "enumerate", "(", "locs", ")", ":", "\n", "        ", "if", "loc", "==", "0", ":", "\n", "            ", "cons", "[", ":", ",", "i_loc", "]", "=", "models", "[", "0", "]", ".", "predict", "(", "x", ")", ".", "ravel", "(", ")", "\n", "", "elif", "loc", "==", "1", ":", "\n", "            ", "prop", "=", "x", "[", ":", ",", "4", "]", "/", "x", "[", ":", ",", "5", "]", "\n", "cons", "[", ":", ",", "i_loc", "]", "=", "np", ".", "minimum", "(", "prop", "-", "0.5", ",", "2", "-", "prop", ")", "\n", "", "", "return", "cons", "\n", "\n"]]}