{"home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.__init__": [[12, 52], ["tensorflow.nn.softmax", "tensorflow.range", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.nn.top_k", "tensorflow.where", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.equal", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.logging.info", "sys.exit", "tensorflow.shape", "tensorflow.log", "tensorflow.log"], "methods", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.softmax"], ["def", "__init__", "(", "self", ",", "model", ",", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Initalize local search helper.\n\n    Args:\n      model: TensorFlow model\n      args: arguments\n    \"\"\"", "\n", "self", ".", "block_size", "=", "args", ".", "block_size", "# int, initial block size", "\n", "self", ".", "loss_func", "=", "args", ".", "loss_func", "\n", "\n", "# Network setting", "\n", "self", ".", "x_input", "=", "model", "[", "'x_input'", "]", "\n", "self", ".", "y_input", "=", "model", "[", "'y_input'", "]", "\n", "self", ".", "logits", "=", "model", "[", "'logits'", "]", "\n", "self", ".", "preds", "=", "model", "[", "'preds'", "]", "\n", "\n", "# Network setting", "\n", "self", ".", "x_input", "=", "model", "[", "'x_input'", "]", "\n", "self", ".", "y_input", "=", "model", "[", "'y_input'", "]", "\n", "self", ".", "logits", "=", "model", "[", "'logits'", "]", "\n", "self", ".", "preds", "=", "model", "[", "'preds'", "]", "\n", "\n", "probs", "=", "tf", ".", "nn", ".", "softmax", "(", "self", ".", "logits", ")", "\n", "batch_num", "=", "tf", ".", "range", "(", "0", ",", "limit", "=", "tf", ".", "shape", "(", "probs", ")", "[", "0", "]", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "batch_num", ",", "self", ".", "y_input", "]", ",", "axis", "=", "1", ")", "\n", "ground_truth_probs", "=", "tf", ".", "gather_nd", "(", "params", "=", "probs", ",", "indices", "=", "indices", ")", "\n", "top_2", "=", "tf", ".", "nn", ".", "top_k", "(", "probs", ",", "k", "=", "2", ")", "\n", "max_indices", "=", "tf", ".", "where", "(", "tf", ".", "equal", "(", "top_2", ".", "indices", "[", ":", ",", "0", "]", ",", "self", ".", "y_input", ")", ",", "top_2", ".", "indices", "[", ":", ",", "1", "]", ",", "top_2", ".", "indices", "[", ":", ",", "0", "]", ")", "\n", "max_indices", "=", "tf", ".", "stack", "(", "[", "batch_num", ",", "max_indices", "]", ",", "axis", "=", "1", ")", "\n", "max_probs", "=", "tf", ".", "gather_nd", "(", "params", "=", "probs", ",", "indices", "=", "max_indices", ")", "\n", "\n", "# loss function", "\n", "if", "self", ".", "loss_func", "==", "'xent'", ":", "\n", "      ", "self", ".", "losses", "=", "-", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "\n", "logits", "=", "self", ".", "logits", ",", "labels", "=", "self", ".", "y_input", ")", "\n", "", "elif", "self", ".", "loss_func", "==", "'cw'", ":", "\n", "      ", "self", ".", "losses", "=", "tf", ".", "log", "(", "ground_truth_probs", "+", "1e-10", ")", "-", "tf", ".", "log", "(", "max_probs", "+", "1e-10", ")", "\n", "", "else", ":", "\n", "      ", "tf", ".", "logging", ".", "info", "(", "'Loss function must be xent or cw'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node._filter_finer_block": [[53, 72], ["enumerate", "blocks.append"], "methods", ["None"], ["", "", "def", "_filter_finer_block", "(", "self", ",", "blocks_all", ",", "coarse_block", ")", ":", "\n", "    ", "\"\"\"choose the finer blocks in the coarse_block region\n\n    Args:\n      blocks_all: list, the set of all finer blocks containing saliency mask\n      coarse_block: [upper_left, lower_right, channel, saliency_mask], one coarse block\n      Note that a block consists of [upper_left, lower_right, channel, saliency_mask]\n\n    Returns:\n      blocks: list, the set of chosen finer blocks\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "upper_left", ",", "lower_right", ",", "channel", ",", "_", "=", "coarse_block", "\n", "for", "i", ",", "block", "in", "enumerate", "(", "blocks_all", ")", ":", "\n", "      ", "ul", ",", "lr", ",", "c", ",", "_", "=", "block", "\n", "if", "c", "==", "channel", "and", "(", "ul", "[", "0", "]", ">=", "upper_left", "[", "0", "]", "and", "lr", "[", "0", "]", "<=", "lower_right", "[", "0", "]", ")", "and", "(", "ul", "[", "1", "]", ">=", "upper_left", "[", "1", "]", "and", "lr", "[", "1", "]", "<=", "lower_right", "[", "1", "]", ")", ":", "\n", "        ", "blocks", ".", "append", "(", "block", ")", "\n", "\n", "", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node._perturb_image": [[73, 88], ["numpy.clip", "cv2.resize"], "methods", ["None"], ["", "def", "_perturb_image", "(", "self", ",", "image", ",", "noise", ")", ":", "\n", "    ", "\"\"\"Given an image and a noise, generate a perturbed image.\n    First, resize the noise with the size of the image.\n    Then, add the resized noise to the image.\n\n    Args:\n      image: numpy array of size [1, 299, 299, 3], an original image\n      noise: numpy array of size [1, 256, 256, 3], a noise\n\n    Returns:\n      adv_image: numpy array of size [1, 299, 299, 3], a perturbed image\n    \"\"\"", "\n", "adv_image", "=", "image", "+", "cv2", ".", "resize", "(", "noise", "[", "0", ",", "...", "]", ",", "(", "self", ".", "width", ",", "self", ".", "height", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "adv_image", "=", "np", ".", "clip", "(", "adv_image", ",", "0.", ",", "1.", ")", "\n", "return", "adv_image", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node._filter_block": [[89, 106], ["enumerate", "numpy.sum", "blocks.append"], "methods", ["None"], ["", "def", "_filter_block", "(", "self", ",", "blocks_all", ")", ":", "\n", "    ", "\"\"\"Choose the blocks in saliency region.\n\n    Args:\n      blocks_all: list, the set of blocks containing saliency mask\n      Note that a block consists of [upper_left, lower_right, channel, saliency_mask]\n\n    Returns:\n      blocks: list, the set of blocks\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "for", "i", ",", "block", "in", "enumerate", "(", "blocks_all", ")", ":", "\n", "      ", "_", ",", "_", ",", "_", ",", "saliency_block", "=", "block", "\n", "if", "np", ".", "sum", "(", "saliency_block", "==", "1", ")", ">", "0", ":", "# at least one pixel in saliency region", "\n", "        ", "blocks", ".", "append", "(", "block", ")", "\n", "\n", "", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node._flip_noise": [[107, 120], ["numpy.copy"], "methods", ["None"], ["", "def", "_flip_noise", "(", "self", ",", "noise", ",", "block", ")", ":", "\n", "    ", "\"\"\"Flip the sign of perturbation on a block.\n    Args:\n      noise: numpy array of size [1, 256, 256, 3], a noise\n      block: [upper_left, lower_right, channel, saliency_mask], a block\n\n    Returns:\n      noise: numpy array of size [1, 256, 256, 3], an updated noise\n    \"\"\"", "\n", "noise_new", "=", "np", ".", "copy", "(", "noise", ")", "\n", "upper_left", ",", "lower_right", ",", "channel", ",", "_", "=", "block", "\n", "noise_new", "[", "0", ",", "upper_left", "[", "0", "]", ":", "lower_right", "[", "0", "]", ",", "upper_left", "[", "1", "]", ":", "lower_right", "[", "1", "]", ",", "channel", "]", "*=", "-", "1", "\n", "return", "noise_new", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_idx": [[121, 134], ["abs", "int", "math.log", "math.log"], "methods", ["None"], ["", "def", "get_idx", "(", "self", ",", "block", ")", ":", "\n", "    ", "\"\"\"\n    get the index of the next hierarchy\n\n    Args:\n      block: list, the current block\n    \"\"\"", "\n", "curr_block", "=", "block", "\n", "ul", ",", "lr", ",", "_", ",", "_", "=", "curr_block", "\n", "curr_block_size", "=", "abs", "(", "lr", "[", "0", "]", "-", "ul", "[", "0", "]", ")", "\n", "i", "=", "math", ".", "log", "(", "self", ".", "block_size", ",", "2", ")", "-", "math", ".", "log", "(", "curr_block_size", ",", "2", ")", "+", "1", "\n", "\n", "return", "int", "(", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_next_node": [[135, 154], ["SaliencyAttack_helper.Node._filter_finer_block", "heapq.heappop", "heapq.heappush", "SaliencyAttack_helper.Node.get_idx"], "methods", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._filter_finer_block", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_idx"], ["", "def", "get_next_node", "(", "self", ",", "block", ",", "priority_queue", ",", "blocks", ",", "skip", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    get the next finer block with the best loss in the priority queue\n\n    Args:\n      blocks: 2D list, the set of blocks in salient region\n      priority_queue: 2D list, the priority queue for min heap, recording the index of the best block in all hierarchies\n      block: list, the current block\n      skip: int, default 0 means do not skip any hierarchy so that just perturb the finer blocks in the next hierarchy\n    \"\"\"", "\n", "i", "=", "self", ".", "get_idx", "(", "block", ")", "+", "skip", "\n", "curr_block", "=", "block", "\n", "finer_blocks", "=", "self", ".", "_filter_finer_block", "(", "blocks", "[", "i", "]", ",", "curr_block", ")", "# filter finer blocks in current block region", "\n", "margin", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "i", "]", ")", "\n", "next_block", "=", "finer_blocks", "[", "idx", "]", "\n", "\n", "# To avoid the secondary pop-up of priority queue in perturb function", "\n", "heapq", ".", "heappush", "(", "priority_queue", "[", "i", "]", ",", "(", "margin", ",", "idx", ")", ")", "\n", "return", "next_block", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.perturb": [[155, 278], ["SaliencyAttack_helper.Node._filter_finer_block", "len", "SaliencyAttack_helper.Node.get_idx", "heapq.heappop", "SaliencyAttack_helper.Node._flip_noise", "SaliencyAttack_helper.Node._perturb_image", "sess.run", "numpy.copy", "numpy.zeros", "numpy.zeros", "int", "range", "numpy.zeros", "numpy.zeros", "numpy.tile", "range", "sess.run", "numpy.where", "range", "heapq.heappop", "heapq.heappush", "math.ceil", "numpy.zeros", "numpy.zeros", "numpy.tile", "range", "sess.run", "numpy.where", "range", "heapq.heappop", "SaliencyAttack_helper.Node._flip_noise", "SaliencyAttack_helper.Node._perturb_image", "len", "heapq.heappush", "SaliencyAttack_helper.Node._flip_noise", "SaliencyAttack_helper.Node._perturb_image", "len", "heapq.heappush", "heapq.heappush"], "methods", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._filter_finer_block", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_idx", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._flip_noise", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._flip_noise", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._flip_noise", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image"], ["", "def", "perturb", "(", "self", ",", "block", ",", "blocks", ",", "priority_queue", ",", "curr_noise", ",", "best_loss", ",", "label", ",", "image", ",", "sess", ",", "skip", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    test the finer blocks and update the priority queue\n\n    Args:\n      block: list, the current block\n      blocks: 2D list, the set of blocks in salient region\n      prioirty_queue: 2D list, the priority queue for min heap, recording the index of the best block in all hierarchies\n      curr_noise: numpy array of size [1, 256, 256, 3], current noise\n      best_loss: float, best loss\n      label: numpy array of size [1], the label of the image (or target label)\n      image: numpy array of size [1, 299, 299, 3], an original image\n      sess: TensorFlow session\n      skip: int, default 0 means do not skip any hierarchy so that just perturb the finer blocks in the next hierarchy\n    \"\"\"", "\n", "\n", "self", ".", "width", "=", "image", ".", "shape", "[", "1", "]", "\n", "self", ".", "height", "=", "image", ".", "shape", "[", "2", "]", "\n", "i", "=", "self", ".", "get_idx", "(", "block", ")", "+", "skip", "# get the index of the next hierarchy", "\n", "queries", "=", "0", "\n", "\n", "# log the Refining process", "\n", "# ul, lr, _, _ = block", "\n", "# curr_block_size = abs(lr[0] - ul[0])", "\n", "# tf.logging.info(\"block_size: {}, test on {}th hierarchy\".format(curr_block_size, i))", "\n", "\n", "# restrict perturbation only in curr_block region", "\n", "finer_blocks", "=", "self", ".", "_filter_finer_block", "(", "blocks", "[", "i", "]", ",", "block", ")", "\n", "num_blocks", "=", "len", "(", "finer_blocks", ")", "\n", "\n", "# if the priority_queue for the next hierarchy exist, we just choose the best block to test", "\n", "if", "priority_queue", "[", "i", "]", ":", "\n", "      ", "_", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "i", "]", ")", "\n", "finer_block", "=", "finer_blocks", "[", "idx", "]", "\n", "\n", "noise", "=", "self", ".", "_flip_noise", "(", "curr_noise", ",", "finer_block", ")", "\n", "image_test", "=", "self", ".", "_perturb_image", "(", "image", ",", "noise", ")", "\n", "losses", ",", "pred", "=", "sess", ".", "run", "(", "[", "self", ".", "losses", ",", "self", ".", "preds", "]", ",", "\n", "feed_dict", "=", "{", "self", ".", "x_input", ":", "image_test", ",", "self", ".", "y_input", ":", "label", "}", ")", "\n", "queries", "+=", "1", "\n", "loss", "=", "losses", "[", "0", "]", "\n", "# Early stopping", "\n", "flag", "=", "(", "pred", "!=", "label", ")", "\n", "if", "flag", ":", "\n", "        ", "return", "noise", ",", "loss", ",", "queries", ",", "True", "\n", "\n", "# when the priority_queue for the next hierarchy is empty, we test all finer blocks and update the priority_queue", "\n", "", "", "else", ":", "\n", "# test noises added in these blocks at ith hierarchy split", "\n", "      ", "if", "num_blocks", ">", "100", ":", "\n", "        ", "noise", "=", "np", ".", "copy", "(", "curr_noise", ")", "\n", "loss", "=", "1.0", "\n", "batch_size", "=", "100", "\n", "losses", "=", "np", ".", "zeros", "(", "num_blocks", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "preds", "=", "np", ".", "zeros", "(", "num_blocks", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "num_batches", "=", "int", "(", "math", ".", "ceil", "(", "num_blocks", "/", "batch_size", ")", ")", "\n", "for", "ibatch", "in", "range", "(", "num_batches", ")", ":", "\n", "          ", "bstart", "=", "ibatch", "*", "batch_size", "\n", "if", "(", "num_blocks", "-", "bstart", ")", "<", "batch_size", ":", "\n", "            ", "batch_size", "=", "num_blocks", "-", "bstart", "\n", "", "bend", "=", "bstart", "+", "batch_size", "\n", "image_batch", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "self", ".", "width", ",", "self", ".", "height", ",", "3", "]", ",", "np", ".", "float32", ")", "\n", "noise_batch", "=", "np", ".", "zeros", "(", "[", "batch_size", ",", "256", ",", "256", ",", "3", "]", ",", "np", ".", "float32", ")", "\n", "label_batch", "=", "np", ".", "tile", "(", "label", ",", "batch_size", ")", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "# flip the noise", "\n", "            ", "noise_batch", "[", "k", "]", "=", "self", ".", "_flip_noise", "(", "curr_noise", ",", "finer_blocks", "[", "k", "+", "bstart", "]", ")", "\n", "image_batch", "[", "k", "]", "=", "self", ".", "_perturb_image", "(", "image", ",", "noise_batch", "[", "k", ":", "k", "+", "1", "]", ")", "\n", "", "losses", "[", "bstart", ":", "bend", "]", ",", "preds", "[", "bstart", ":", "bend", "]", "=", "sess", ".", "run", "(", "[", "self", ".", "losses", ",", "self", ".", "preds", "]", ",", "\n", "feed_dict", "=", "{", "self", ".", "x_input", ":", "image_batch", ",", "self", ".", "y_input", ":", "label_batch", "}", ")", "\n", "\n", "# Early stopping", "\n", "success_indices", ",", "=", "np", ".", "where", "(", "preds", "[", "bstart", ":", "bend", "]", "!=", "label", ")", "\n", "if", "len", "(", "success_indices", ")", ">", "0", ":", "\n", "            ", "curr_noise", "[", "0", ",", "...", "]", "=", "noise_batch", "[", "success_indices", "[", "0", "]", ",", "...", "]", "\n", "curr_loss", "=", "losses", "[", "bstart", "+", "success_indices", "[", "0", "]", "]", "\n", "queries", "+=", "bstart", "+", "success_indices", "[", "0", "]", "+", "1", "\n", "return", "curr_noise", ",", "curr_loss", ",", "queries", ",", "True", "\n", "\n", "", "queries", "+=", "batch_size", "\n", "\n", "# Push the margin and the corresponding index into the priority queue", "\n", "for", "k", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "heapq", ".", "heappush", "(", "priority_queue", "[", "i", "]", ",", "(", "losses", "[", "bstart", "+", "k", "]", "-", "best_loss", ",", "bstart", "+", "k", ")", ")", "\n", "\n", "# choose the current best loss and update the noise", "\n", "", "margin", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "i", "]", ")", "\n", "if", "margin", "+", "best_loss", "<", "loss", ":", "\n", "            ", "noise", "=", "noise_batch", "[", "idx", "-", "bstart", ":", "idx", "-", "bstart", "+", "1", "]", "\n", "heapq", ".", "heappush", "(", "priority_queue", "[", "i", "]", ",", "(", "margin", ",", "idx", ")", ")", "\n", "loss", "=", "margin", "+", "best_loss", "\n", "", "", "", "else", ":", "\n", "        ", "image_batch", "=", "np", ".", "zeros", "(", "[", "num_blocks", ",", "self", ".", "width", ",", "self", ".", "height", ",", "3", "]", ",", "np", ".", "float32", ")", "\n", "noise_batch", "=", "np", ".", "zeros", "(", "[", "num_blocks", ",", "256", ",", "256", ",", "3", "]", ",", "np", ".", "float32", ")", "\n", "label_batch", "=", "np", ".", "tile", "(", "label", ",", "num_blocks", ")", "\n", "for", "k", "in", "range", "(", "num_blocks", ")", ":", "\n", "# flip the noise", "\n", "          ", "noise_batch", "[", "k", "]", "=", "self", ".", "_flip_noise", "(", "curr_noise", ",", "finer_blocks", "[", "k", "]", ")", "\n", "image_batch", "[", "k", "]", "=", "self", ".", "_perturb_image", "(", "image", ",", "noise_batch", "[", "k", ":", "k", "+", "1", "]", ")", "\n", "", "losses", ",", "preds", "=", "sess", ".", "run", "(", "[", "self", ".", "losses", ",", "self", ".", "preds", "]", ",", "\n", "feed_dict", "=", "{", "self", ".", "x_input", ":", "image_batch", ",", "self", ".", "y_input", ":", "label_batch", "}", ")", "\n", "\n", "# Early stopping", "\n", "success_indices", ",", "=", "np", ".", "where", "(", "preds", "!=", "label", ")", "\n", "if", "len", "(", "success_indices", ")", ">", "0", ":", "\n", "          ", "curr_noise", "[", "0", ",", "...", "]", "=", "noise_batch", "[", "success_indices", "[", "0", "]", ",", "...", "]", "\n", "curr_loss", "=", "losses", "[", "success_indices", "[", "0", "]", "]", "\n", "queries", "+=", "success_indices", "[", "0", "]", "+", "1", "\n", "return", "curr_noise", ",", "curr_loss", ",", "queries", ",", "True", "\n", "\n", "", "queries", "+=", "num_blocks", "\n", "\n", "# Push the margin and the corresponding index into the priority queue", "\n", "for", "k", "in", "range", "(", "num_blocks", ")", ":", "\n", "          ", "heapq", ".", "heappush", "(", "priority_queue", "[", "i", "]", ",", "(", "losses", "[", "k", "]", "-", "best_loss", ",", "k", ")", ")", "\n", "\n", "# choose the current best loss and update the noise", "\n", "", "margin", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "i", "]", ")", "\n", "noise", "=", "noise_batch", "[", "idx", ":", "idx", "+", "1", "]", "\n", "heapq", ".", "heappush", "(", "priority_queue", "[", "i", "]", ",", "(", "margin", ",", "idx", ")", ")", "\n", "loss", "=", "margin", "+", "best_loss", "\n", "\n", "", "", "return", "noise", ",", "loss", ",", "queries", ",", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack.__init__": [[17, 58], ["attacks.SaliencyAttack_helper.Node", "tensorflow.nn.softmax", "tensorflow.range", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.nn.top_k", "tensorflow.where", "tensorflow.stack", "tensorflow.gather_nd", "tensorflow.equal", "tensorflow.nn.sparse_softmax_cross_entropy_with_logits", "tensorflow.logging.info", "sys.exit", "tensorflow.shape", "tensorflow.log", "tensorflow.log"], "methods", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.softmax"], ["def", "__init__", "(", "self", ",", "model", ",", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Initialize attack.\n\n    Args:\n      model: TensorFlow model\n      args: arguments\n    \"\"\"", "\n", "# Hyperparameter setting", "\n", "self", ".", "min_block_size", "=", "args", ".", "min_block_size", "\n", "self", ".", "loss_func", "=", "args", ".", "loss_func", "\n", "self", ".", "max_queries", "=", "args", ".", "max_queries", "\n", "self", ".", "epsilon", "=", "args", ".", "epsilon", "\n", "self", ".", "block_size", "=", "args", ".", "block_size", "\n", "\n", "# Create helper", "\n", "self", ".", "node", "=", "Node", "(", "model", ",", "args", ")", "\n", "\n", "# Network setting", "\n", "self", ".", "x_input", "=", "model", "[", "'x_input'", "]", "\n", "self", ".", "y_input", "=", "model", "[", "'y_input'", "]", "\n", "self", ".", "logits", "=", "model", "[", "'logits'", "]", "\n", "self", ".", "preds", "=", "model", "[", "'preds'", "]", "\n", "\n", "probs", "=", "tf", ".", "nn", ".", "softmax", "(", "self", ".", "logits", ")", "\n", "batch_num", "=", "tf", ".", "range", "(", "0", ",", "limit", "=", "tf", ".", "shape", "(", "probs", ")", "[", "0", "]", ")", "\n", "indices", "=", "tf", ".", "stack", "(", "[", "batch_num", ",", "self", ".", "y_input", "]", ",", "axis", "=", "1", ")", "\n", "ground_truth_probs", "=", "tf", ".", "gather_nd", "(", "params", "=", "probs", ",", "indices", "=", "indices", ")", "\n", "top_2", "=", "tf", ".", "nn", ".", "top_k", "(", "probs", ",", "k", "=", "2", ")", "\n", "max_indices", "=", "tf", ".", "where", "(", "tf", ".", "equal", "(", "top_2", ".", "indices", "[", ":", ",", "0", "]", ",", "self", ".", "y_input", ")", ",", "top_2", ".", "indices", "[", ":", ",", "1", "]", ",", "top_2", ".", "indices", "[", ":", ",", "0", "]", ")", "\n", "max_indices", "=", "tf", ".", "stack", "(", "[", "batch_num", ",", "max_indices", "]", ",", "axis", "=", "1", ")", "\n", "max_probs", "=", "tf", ".", "gather_nd", "(", "params", "=", "probs", ",", "indices", "=", "max_indices", ")", "\n", "\n", "# loss function", "\n", "if", "self", ".", "loss_func", "==", "'xent'", ":", "\n", "      ", "self", ".", "losses", "=", "-", "tf", ".", "nn", ".", "sparse_softmax_cross_entropy_with_logits", "(", "\n", "logits", "=", "self", ".", "logits", ",", "labels", "=", "self", ".", "y_input", ")", "\n", "", "elif", "self", ".", "loss_func", "==", "'cw'", ":", "\n", "      ", "self", ".", "losses", "=", "tf", ".", "log", "(", "ground_truth_probs", "+", "1e-10", ")", "-", "tf", ".", "log", "(", "max_probs", "+", "1e-10", ")", "\n", "", "else", ":", "\n", "      ", "tf", ".", "logging", ".", "info", "(", "'Loss function must be xent or cw'", ")", "\n", "sys", ".", "exit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image": [[59, 74], ["numpy.clip", "cv2.resize"], "methods", ["None"], ["", "", "def", "_perturb_image", "(", "self", ",", "image", ",", "noise", ")", ":", "\n", "    ", "\"\"\"Given an image and a noise, generate a perturbed image.\n    First, resize the noise with the size of the image.\n    Then, add the resized noise to the image.\n\n    Args:\n      image: numpy array of size [1, 299, 299, 3], an original image\n      noise: numpy array of size [1, 256, 256, 3], a noise\n\n    Returns:\n      adv_iamge: numpy array of size [1, 299, 299, 3], an perturbed image\n    \"\"\"", "\n", "adv_image", "=", "image", "+", "cv2", ".", "resize", "(", "noise", "[", "0", ",", "...", "]", ",", "(", "self", ".", "width", ",", "self", ".", "height", ")", ",", "interpolation", "=", "cv2", ".", "INTER_NEAREST", ")", "\n", "adv_image", "=", "np", ".", "clip", "(", "adv_image", ",", "0.", ",", "1.", ")", "\n", "return", "adv_image", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._split_block": [[75, 99], ["numpy.arange", "numpy.arange", "itertools.product", "numpy.ones", "range", "blocks.append"], "methods", ["None"], ["", "def", "_split_block", "(", "self", ",", "upper_left", ",", "lower_right", ",", "block_size", ",", "sal_img", ")", ":", "\n", "    ", "\"\"\"Split an image into a set of blocks.\n    Note that a block consists of [upper_left, lower_right, channel]\n\n    Args:\n      upper_left: [x, y], the coordinate of the upper left of an image\n      lower_right: [x, y], the coordinate of the lower right of an image\n      block_size: int, the size of a block\n      sal_img: [256, 256], saliency mask, {0,1} for each pixels\n\n    Returns:\n      blocks: list, the set of blocks\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "xs", "=", "np", ".", "arange", "(", "upper_left", "[", "0", "]", ",", "lower_right", "[", "0", "]", ",", "block_size", ")", "\n", "ys", "=", "np", ".", "arange", "(", "upper_left", "[", "1", "]", ",", "lower_right", "[", "1", "]", ",", "block_size", ")", "\n", "for", "x", ",", "y", "in", "itertools", ".", "product", "(", "xs", ",", "ys", ")", ":", "\n", "\n", "      ", "block", "=", "np", ".", "ones", "(", "[", "block_size", ",", "block_size", "]", ",", "dtype", "=", "'int32'", ")", "\n", "block", "=", "block", "*", "sal_img", "[", "x", ":", "x", "+", "block_size", ",", "y", ":", "y", "+", "block_size", "]", "\n", "\n", "for", "c", "in", "range", "(", "3", ")", ":", "\n", "        ", "blocks", ".", "append", "(", "[", "[", "x", ",", "y", "]", ",", "[", "x", "+", "block_size", ",", "y", "+", "block_size", "]", ",", "c", ",", "block", "]", ")", "\n", "", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._filter_block": [[100, 117], ["enumerate", "numpy.sum", "blocks.append"], "methods", ["None"], ["", "def", "_filter_block", "(", "self", ",", "blocks_all", ")", ":", "\n", "    ", "\"\"\"Choose the blocks in saliency region.\n\n    Args:\n      blocks_all: list, the set of blocks containing saliency mask\n      Note that a block consists of [upper_left, lower_right, channel, saliency_mask]\n\n    Returns:\n      blocks: list, the set of blocks\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "for", "i", ",", "block", "in", "enumerate", "(", "blocks_all", ")", ":", "\n", "      ", "_", ",", "_", ",", "_", ",", "saliency_block", "=", "block", "\n", "if", "np", ".", "sum", "(", "saliency_block", "==", "1", ")", ">", "0", ":", "# at least one pixel in saliency region", "\n", "        ", "blocks", ".", "append", "(", "block", ")", "\n", "\n", "", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._filter_finer_block": [[118, 137], ["enumerate", "blocks.append"], "methods", ["None"], ["", "def", "_filter_finer_block", "(", "self", ",", "blocks_all", ",", "coarse_block", ")", ":", "\n", "    ", "\"\"\"choose finer blocks in the coarse_block region\n\n    Args:\n      blocks_all: list, the set of all finer blocks containing saliency mask\n      coarse_block: [upper_left, lower_right, channel, saliency_mask], one coarse block\n      Note that a block consists of [upper_left, lower_right, channel, saliency_mask]\n\n    Returns:\n      blocks: list, the set of chosen finer blocks\n    \"\"\"", "\n", "blocks", "=", "[", "]", "\n", "upper_left", ",", "lower_right", ",", "channel", ",", "_", "=", "coarse_block", "\n", "for", "i", ",", "block", "in", "enumerate", "(", "blocks_all", ")", ":", "\n", "      ", "ul", ",", "lr", ",", "c", ",", "_", "=", "block", "\n", "if", "c", "==", "channel", "and", "(", "ul", "[", "0", "]", ">=", "upper_left", "[", "0", "]", "and", "lr", "[", "0", "]", "<=", "lower_right", "[", "0", "]", ")", "and", "(", "ul", "[", "1", "]", ">=", "upper_left", "[", "1", "]", "and", "lr", "[", "1", "]", "<=", "lower_right", "[", "1", "]", ")", ":", "\n", "        ", "blocks", ".", "append", "(", "block", ")", "\n", "\n", "", "", "return", "blocks", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._add_epsilon_noise": [[138, 152], ["numpy.copy"], "methods", ["None"], ["", "def", "_add_epsilon_noise", "(", "self", ",", "noise", ",", "block", ",", "flag", ")", ":", "\n", "    ", "\"\"\"Flip the sign of perturbation on a block.\n    Args:\n      noise: numpy array of size [1, 256, 256, 3], a noise\n      block: [upper_left, lower_right, channel, saliency_mask], a block\n      flag: int, {1, -1}, add positive or negative epsilon\n\n    Returns:\n      noise: numpy array of size [1, 256, 256, 3], an updated noise\n    \"\"\"", "\n", "noise_new", "=", "np", ".", "copy", "(", "noise", ")", "\n", "upper_left", ",", "lower_right", ",", "channel", ",", "saliency_block", "=", "block", "\n", "noise_new", "[", "0", ",", "upper_left", "[", "0", "]", ":", "lower_right", "[", "0", "]", ",", "upper_left", "[", "1", "]", ":", "lower_right", "[", "1", "]", ",", "channel", "]", "=", "flag", "*", "self", ".", "epsilon", "*", "saliency_block", "\n", "return", "noise_new", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._flip_noise": [[153, 166], ["numpy.copy"], "methods", ["None"], ["", "def", "_flip_noise", "(", "self", ",", "noise", ",", "block", ")", ":", "\n", "    ", "\"\"\"Flip the sign of perturbation on a block.\n    Args:\n      noise: numpy array of size [1, 256, 256, 3], a noise\n      block: [upper_left, lower_right, channel, saliency_mask], a block\n\n    Returns:\n      noise: numpy array of size [1, 256, 256, 3], an updated noise\n    \"\"\"", "\n", "noise_new", "=", "np", ".", "copy", "(", "noise", ")", "\n", "upper_left", ",", "lower_right", ",", "channel", ",", "_", "=", "block", "\n", "noise_new", "[", "0", ",", "upper_left", "[", "0", "]", ":", "lower_right", "[", "0", "]", ",", "upper_left", "[", "1", "]", ":", "lower_right", "[", "1", "]", ",", "channel", "]", "*=", "-", "1", "\n", "return", "noise_new", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack.perturb": [[167, 417], ["numpy.random.seed", "numpy.copy", "numpy.zeros", "numpy.where", "numpy.sum", "int", "range", "numpy.zeros", "numpy.zeros", "numpy.tile", "range", "numpy.where", "range", "priority_queue[].copy", "heapq.heappop", "int", "numpy.ones", "Saliency_Attack.SaliencyAttack._split_block", "Saliency_Attack.SaliencyAttack._filter_block", "len", "Saliency_Attack.SaliencyAttack._add_epsilon_noise", "Saliency_Attack.SaliencyAttack._perturb_image", "Saliency_Attack.SaliencyAttack._add_epsilon_noise", "Saliency_Attack.SaliencyAttack._perturb_image", "numpy.zeros", "numpy.zeros", "int", "range", "sess.run", "len", "Saliency_Attack.SaliencyAttack._perturb_image", "tensorflow.logging.info", "heapq.heappush", "tensorflow.logging.info", "tensorflow.logging.info", "range", "priority_queue[].copy.copy", "tensorflow.logging.info", "range", "range", "math.ceil", "sess.run", "range", "math.log", "range", "stack.append", "Saliency_Attack.SaliencyAttack.node.perturb", "math.log", "math.log", "priority_queue[].clear", "len", "tensorflow.logging.info", "heapq.heappop", "Saliency_Attack.SaliencyAttack._add_epsilon_noise", "Saliency_Attack.SaliencyAttack._perturb_image", "sess.run", "range", "heapq.heappop", "tensorflow.logging.info", "tensorflow.logging.info", "Saliency_Attack.SaliencyAttack._perturb_image", "len", "stack.pop", "pow", "tensorflow.logging.info", "priority_queue[].clear", "tensorflow.logging.info", "Saliency_Attack.SaliencyAttack._perturb_image", "Saliency_Attack.SaliencyAttack.node.get_idx", "pow", "Saliency_Attack.SaliencyAttack.node.get_idx", "stack.append", "stack.append", "Saliency_Attack.SaliencyAttack.node.perturb", "heapq.heappop", "Saliency_Attack.SaliencyAttack.node.get_next_node", "Saliency_Attack.SaliencyAttack.node.get_next_node", "Saliency_Attack.SaliencyAttack._perturb_image", "stack.pop", "priority_queue[].clear", "heapq.heappop", "tensorflow.logging.info", "tensorflow.logging.info", "Saliency_Attack.SaliencyAttack.node.get_idx"], "methods", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._split_block", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._filter_block", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._add_epsilon_noise", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._add_epsilon_noise", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack.perturb", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._add_epsilon_noise", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_idx", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_idx", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack.perturb", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_next_node", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_next_node", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.Saliency_Attack.SaliencyAttack._perturb_image", "home.repos.pwc.inspect_result.daizy97_saliencyattack.attacks.SaliencyAttack_helper.Node.get_idx"], ["", "def", "perturb", "(", "self", ",", "image", ",", "sal_img", ",", "label", ",", "index", ",", "sess", ")", ":", "\n", "    ", "\"\"\"Perturb an image.\n\n    Args:\n      image: numpy array of size [1, 299, 299, 3], an original image\n      sal_img: saliency mask of size [256, 256]\n      label: numpy array of size [1], the label of the image (or target label)\n      index: int, the index of the image\n      sess: TensorFlow session\n\n    Returns:\n      adv_image: numpy array of size [1, 299, 299, 3], an adversarial image\n      num_queries: int, the number of queries\n      success: bool, True if attack is successful\n      flag: boo, Ture if the salient region is too small\n    \"\"\"", "\n", "# Set random seed by index for the reproducibility", "\n", "np", ".", "random", ".", "seed", "(", "index", ")", "\n", "\n", "# Class variables", "\n", "self", ".", "width", "=", "image", ".", "shape", "[", "1", "]", "\n", "self", ".", "height", "=", "image", ".", "shape", "[", "2", "]", "\n", "\n", "# Local variables", "\n", "adv_image", "=", "np", ".", "copy", "(", "image", ")", "\n", "num_queries", "=", "0", "\n", "block_size", "=", "self", ".", "block_size", "\n", "min_block_size", "=", "self", ".", "min_block_size", "\n", "upper_left", "=", "[", "0", ",", "0", "]", "\n", "lower_right", "=", "[", "256", ",", "256", "]", "\n", "\n", "# Initialize a noise with zeros", "\n", "noise", "=", "np", ".", "zeros", "(", "[", "1", ",", "256", ",", "256", ",", "3", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# Preprocess for saliency mask", "\n", "flag", "=", "0", "# record whether the saliency region is too small", "\n", "sal_img", "=", "np", ".", "where", "(", "sal_img", "==", "255", ",", "1", ",", "0", ")", "\n", "num_saliency", "=", "np", ".", "sum", "(", "sal_img", "==", "1", ")", "\n", "num_pixels", "=", "256", "*", "256", "\n", "# if the saliency region is too small in the image, we just perturb the whole image region", "\n", "if", "num_saliency", "/", "num_pixels", "<=", "0.01", ":", "\n", "      ", "sal_img", "=", "np", ".", "ones", "(", "[", "256", ",", "256", "]", ",", "dtype", "=", "'int32'", ")", "\n", "flag", "=", "1", "\n", "\n", "# # if perturb in the whole image:", "\n", "# sal_img = np.ones([256, 256], dtype='int32')", "\n", "\n", "# Initialize a 2D empty list", "\n", "# e.g assume block_size=64, min_block_size=2,", "\n", "# then we at most have log2(64)-log2(2)+1 hierarchies", "\n", "", "maximal_num_hierarchies", "=", "int", "(", "math", ".", "log", "(", "block_size", ",", "2", ")", "-", "math", ".", "log", "(", "min_block_size", ",", "2", ")", "+", "1", ")", "\n", "blocks", "=", "[", "[", "]", "for", "i", "in", "range", "(", "maximal_num_hierarchies", ")", "]", "\n", "num_blocks", "=", "[", "0", "for", "i", "in", "range", "(", "maximal_num_hierarchies", ")", "]", "\n", "\n", "# Split an image into a set of blocks at all hierarchies", "\n", "for", "i", "in", "range", "(", "maximal_num_hierarchies", ")", ":", "\n", "      ", "blocks_all", "=", "self", ".", "_split_block", "(", "upper_left", ",", "lower_right", ",", "block_size", ",", "sal_img", ")", "\n", "blocks", "[", "i", "]", "=", "self", ".", "_filter_block", "(", "blocks_all", ")", "\n", "num_blocks", "[", "i", "]", "=", "len", "(", "blocks", "[", "i", "]", ")", "\n", "block_size", "//=", "2", "\n", "\n", "# Refining on initial blocks", "\n", "", "num_initial_blocks", "=", "num_blocks", "[", "0", "]", "*", "2", "\n", "image_batch", "=", "np", ".", "zeros", "(", "[", "num_initial_blocks", ",", "self", ".", "width", ",", "self", ".", "height", ",", "3", "]", ",", "np", ".", "float32", ")", "\n", "noise_batch", "=", "np", ".", "zeros", "(", "[", "num_initial_blocks", ",", "256", ",", "256", ",", "3", "]", ",", "np", ".", "float32", ")", "\n", "label_batch", "=", "np", ".", "tile", "(", "label", ",", "num_initial_blocks", ")", "\n", "for", "i", "in", "range", "(", "0", ",", "num_initial_blocks", ",", "2", ")", ":", "\n", "# add +epsilon", "\n", "      ", "noise_batch", "[", "i", "]", "=", "self", ".", "_add_epsilon_noise", "(", "noise", ",", "blocks", "[", "0", "]", "[", "i", "//", "2", "]", ",", "1", ")", "\n", "image_batch", "[", "i", "]", "=", "self", ".", "_perturb_image", "(", "image", ",", "noise_batch", "[", "i", ":", "i", "+", "1", "]", ")", "\n", "# add -epsilon", "\n", "noise_batch", "[", "i", "+", "1", "]", "=", "self", ".", "_add_epsilon_noise", "(", "noise", ",", "blocks", "[", "0", "]", "[", "i", "//", "2", "]", ",", "-", "1", ")", "\n", "image_batch", "[", "i", "+", "1", "]", "=", "self", ".", "_perturb_image", "(", "image", ",", "noise_batch", "[", "i", "+", "1", ":", "i", "+", "2", "]", ")", "\n", "\n", "", "if", "num_initial_blocks", ">", "100", ":", "\n", "      ", "losses", "=", "np", ".", "zeros", "(", "num_initial_blocks", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "preds", "=", "np", ".", "zeros", "(", "num_initial_blocks", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "batch_size", "=", "100", "\n", "num_batches", "=", "int", "(", "math", ".", "ceil", "(", "num_initial_blocks", "/", "batch_size", ")", ")", "\n", "for", "ibatch", "in", "range", "(", "num_batches", ")", ":", "\n", "        ", "bstart", "=", "ibatch", "*", "batch_size", "\n", "if", "(", "num_initial_blocks", "-", "bstart", ")", "<", "batch_size", ":", "\n", "          ", "batch_size", "=", "num_initial_blocks", "-", "bstart", "\n", "", "bend", "=", "bstart", "+", "batch_size", "\n", "losses", "[", "bstart", ":", "bend", "]", ",", "preds", "[", "bstart", ":", "bend", "]", "=", "sess", ".", "run", "(", "[", "self", ".", "losses", ",", "self", ".", "preds", "]", ",", "\n", "feed_dict", "=", "{", "self", ".", "x_input", ":", "image_batch", "[", "bstart", ":", "bend", "]", ",", "self", ".", "y_input", ":", "label_batch", "[", "bstart", ":", "bend", "]", "}", ")", "\n", "", "", "else", ":", "\n", "      ", "losses", ",", "preds", "=", "sess", ".", "run", "(", "[", "self", ".", "losses", ",", "self", ".", "preds", "]", ",", "\n", "feed_dict", "=", "{", "self", ".", "x_input", ":", "image_batch", ",", "self", ".", "y_input", ":", "label_batch", "}", ")", "\n", "\n", "# Early stopping", "\n", "", "success_indices", ",", "=", "np", ".", "where", "(", "preds", "!=", "label", ")", "\n", "if", "len", "(", "success_indices", ")", ">", "0", ":", "\n", "      ", "noise", "[", "0", ",", "...", "]", "=", "noise_batch", "[", "success_indices", "[", "0", "]", ",", "...", "]", "\n", "curr_loss", "=", "losses", "[", "success_indices", "[", "0", "]", "]", "\n", "num_queries", "+=", "success_indices", "[", "0", "]", "+", "1", "\n", "adv_image", "=", "self", ".", "_perturb_image", "(", "image", ",", "noise", ")", "\n", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "adv_image", ",", "noise", ",", "num_queries", ",", "True", ",", "flag", "\n", "\n", "", "num_queries", "+=", "num_initial_blocks", "\n", "\n", "# Initialize a 2D empty list", "\n", "# priority_queue[0]: record (losses[idx], idx) of initial blocks", "\n", "# priority_queue[i+1] (i>0): record (margin[idx], idx) of the finer blocks extracted from the best block in priority_queue[i];", "\n", "# margin = losses[idx] - best_loss", "\n", "priority_queue", "=", "[", "[", "]", "for", "i", "in", "range", "(", "maximal_num_hierarchies", ")", "]", "\n", "\n", "# Push into the priority queue", "\n", "for", "i", "in", "range", "(", "num_initial_blocks", ")", ":", "\n", "      ", "heapq", ".", "heappush", "(", "priority_queue", "[", "0", "]", ",", "(", "losses", "[", "i", "]", ",", "i", ")", ")", "\n", "", "rec_queue", "=", "priority_queue", "[", "0", "]", ".", "copy", "(", ")", "# record the initial blocks for later runs", "\n", "\n", "# Refining on further blocks", "\n", "curr_loss", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "0", "]", ")", "\n", "best_loss", "=", "curr_loss", "\n", "curr_noise", "=", "noise_batch", "[", "idx", ":", "idx", "+", "1", "]", "\n", "best_noise", "=", "curr_noise", "\n", "curr_block", "=", "blocks", "[", "0", "]", "[", "idx", "//", "2", "]", "\n", "\n", "# loop start: iterate on those initial blocks that have been perturbed in last run", "\n", "i_run", "=", "1", "\n", "skip", "=", "0", "# No. of hierarchies to be skipped", "\n", "maximal_skip_num", "=", "int", "(", "math", ".", "log", "(", "self", ".", "block_size", ",", "2", ")", "-", "1", ")", "# at most skip to block_size = 2^1", "\n", "while", "num_queries", "<=", "self", ".", "max_queries", ":", "\n", "      ", "tf", ".", "logging", ".", "info", "(", "\"----------------------------------------------------------------\"", ")", "\n", "tf", ".", "logging", ".", "info", "(", "\"{}th run with block_size {}:\"", ".", "format", "(", "i_run", ",", "self", ".", "block_size", "/", "pow", "(", "2", ",", "skip", ")", ")", ")", "\n", "\n", "## Refining on first hierarchy", "\n", "for", "i", "in", "range", "(", "num_initial_blocks", ")", ":", "\n", "# clear the previous priority_queue except for the 1st hierarchy", "\n", "        ", "for", "id", "in", "range", "(", "1", ",", "maximal_num_hierarchies", ")", ":", "\n", "          ", "priority_queue", "[", "id", "]", ".", "clear", "(", ")", "\n", "", "if", "len", "(", "priority_queue", "[", "0", "]", ")", "==", "0", ":", "\n", "          ", "break", "\n", "", "if", "i_run", "==", "1", "and", "i", ">", "0", ":", "# skip the first best block", "\n", "          ", "tf", ".", "logging", ".", "info", "(", "\"After {} initial blocks, num queries: {}, loss: {:.4f}\"", ".", "format", "(", "i", ",", "num_queries", ",", "curr_loss", ")", ")", "\n", "_", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "0", "]", ")", "\n", "sign", "=", "[", "1", ",", "-", "1", "]", "\n", "curr_block", "=", "blocks", "[", "0", "]", "[", "idx", "//", "2", "]", "\n", "curr_noise", "=", "self", ".", "_add_epsilon_noise", "(", "curr_noise", ",", "curr_block", ",", "sign", "[", "idx", "%", "2", "]", ")", "\n", "\n", "image_test", "=", "self", ".", "_perturb_image", "(", "image", ",", "curr_noise", ")", "\n", "losses", ",", "pred", "=", "sess", ".", "run", "(", "[", "self", ".", "losses", ",", "self", ".", "preds", "]", ",", "\n", "feed_dict", "=", "{", "self", ".", "x_input", ":", "image_test", ",", "self", ".", "y_input", ":", "label", "}", ")", "\n", "num_queries", "+=", "1", "\n", "# Early stopping", "\n", "s", "=", "(", "pred", "!=", "label", ")", "\n", "if", "s", ":", "\n", "            ", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "image_test", ",", "curr_noise", ",", "num_queries", ",", "True", ",", "flag", "\n", "\n", "# tf.logging.info(\"After {} initial blocks, num queries: {}, loss: {:.4f}\".format(i, num_queries, curr_loss))", "\n", "# clear the previous priority_queue except for the 1st hierarchy", "\n", "", "for", "id", "in", "range", "(", "1", ",", "maximal_num_hierarchies", ")", ":", "\n", "            ", "priority_queue", "[", "id", "]", ".", "clear", "(", ")", "\n", "# record if better noise", "\n", "", "loss", "=", "losses", "[", "0", "]", "\n", "if", "loss", "<", "best_loss", ":", "\n", "            ", "best_noise", "=", "curr_noise", "\n", "best_loss", "=", "loss", "\n", "\n", "", "", "if", "i_run", ">", "1", ":", "\n", "          ", "_", ",", "idx", "=", "heapq", ".", "heappop", "(", "priority_queue", "[", "0", "]", ")", "\n", "curr_block", "=", "blocks", "[", "0", "]", "[", "idx", "//", "2", "]", "\n", "if", "i", ">", "0", ":", "\n", "            ", "tf", ".", "logging", ".", "info", "(", "\"After {} initial blocks, num queries: {}, loss: {:.4f}\"", ".", "format", "(", "i", ",", "num_queries", ",", "curr_loss", ")", ")", "\n", "\n", "## Refining starting from second hierarchy", "\n", "", "", "stack", "=", "[", "]", "\n", "root", "=", "curr_block", "# restart from the root node", "\n", "stack", ".", "append", "(", "root", ")", "\n", "noise", ",", "loss", ",", "queries", ",", "success", "=", "self", ".", "node", ".", "perturb", "(", "root", ",", "blocks", ",", "priority_queue", ",", "curr_noise", ",", "best_loss", ",", "label", ",", "image", ",", "sess", ",", "skip", ")", "\n", "num_queries", "+=", "queries", "\n", "\n", "if", "success", ":", "\n", "          ", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "adv_image", ",", "curr_noise", ",", "num_queries", ",", "True", ",", "flag", "\n", "# If query count exceeds the maximum queries, then return False", "\n", "", "if", "num_queries", ">", "self", ".", "max_queries", ":", "\n", "          ", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "self", ".", "_perturb_image", "(", "image", ",", "noise", ")", ",", "noise", ",", "num_queries", ",", "False", ",", "flag", "\n", "\n", "", "if", "loss", ">=", "best_loss", ":", "\n", "          ", "curr_noise", "=", "best_noise", "# restore to the previous noise", "\n", "continue", "\n", "", "else", ":", "\n", "          ", "curr_loss", "=", "loss", "\n", "curr_noise", "=", "noise", "\n", "adv_image", "=", "self", ".", "_perturb_image", "(", "image", ",", "curr_noise", ")", "\n", "best_loss", "=", "curr_loss", "\n", "best_noise", "=", "curr_noise", "\n", "\n", "", "skip_flag1", "=", "skip", "\n", "skip_flag2", "=", "skip", "\n", "while", "len", "(", "stack", ")", ">", "0", ":", "\n", "          ", "cur", "=", "stack", ".", "pop", "(", ")", "\n", "if", "skip_flag2", ":", "\n", "            ", "j", "=", "self", ".", "node", ".", "get_idx", "(", "cur", ")", "+", "skip", "\n", "skip_flag2", "=", "0", "\n", "", "else", ":", "\n", "            ", "j", "=", "self", ".", "node", ".", "get_idx", "(", "cur", ")", "\n", "", "if", "priority_queue", "[", "j", "]", "and", "priority_queue", "[", "j", "]", "[", "0", "]", "[", "0", "]", "<", "0", ":", "# if the margin is better", "\n", "            ", "if", "j", "<", "maximal_num_hierarchies", "-", "1", ":", "\n", "              ", "if", "skip_flag1", ":", "\n", "                ", "next", "=", "self", ".", "node", ".", "get_next_node", "(", "cur", ",", "priority_queue", ",", "blocks", ",", "skip", ")", "\n", "skip_flag1", "=", "0", "\n", "", "else", ":", "\n", "                ", "next", "=", "self", ".", "node", ".", "get_next_node", "(", "cur", ",", "priority_queue", ",", "blocks", ")", "\n", "# keep the depth-first order", "\n", "", "stack", ".", "append", "(", "cur", ")", "\n", "stack", ".", "append", "(", "next", ")", "\n", "\n", "# operate on the next node", "\n", "noise", ",", "loss", ",", "queries", ",", "success", "=", "self", ".", "node", ".", "perturb", "(", "next", ",", "blocks", ",", "priority_queue", ",", "curr_noise", ",", "best_loss", ",", "label", ",", "image", ",", "sess", ")", "\n", "num_queries", "+=", "queries", "\n", "if", "loss", "<", "best_loss", "or", "success", ":", "\n", "                ", "curr_loss", "=", "loss", "\n", "curr_noise", "=", "noise", "\n", "adv_image", "=", "self", ".", "_perturb_image", "(", "image", ",", "curr_noise", ")", "\n", "best_loss", "=", "curr_loss", "\n", "best_noise", "=", "curr_noise", "\n", "if", "success", ":", "\n", "                  ", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "adv_image", ",", "curr_noise", ",", "num_queries", ",", "True", ",", "flag", "\n", "# If query count exceeds the maximum queries, then return False", "\n", "", "if", "num_queries", ">", "self", ".", "max_queries", ":", "\n", "                  ", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "adv_image", ",", "curr_noise", ",", "num_queries", ",", "False", ",", "flag", "\n", "", "", "else", ":", "# if the loss isn't better, give up the remaining blocks in the priority queue", "\n", "                ", "stack", ".", "pop", "(", ")", "\n", "priority_queue", "[", "self", ".", "node", ".", "get_idx", "(", "next", ")", "]", ".", "clear", "(", ")", "\n", "heapq", ".", "heappop", "(", "priority_queue", "[", "j", "]", ")", "\n", "", "", "else", ":", "\n", "              ", "heapq", ".", "heappop", "(", "priority_queue", "[", "j", "]", ")", "\n", "\n", "", "", "", "", "priority_queue", "[", "0", "]", "=", "rec_queue", ".", "copy", "(", ")", "\n", "i_run", "+=", "1", "\n", "\n", "if", "skip", "<", "maximal_skip_num", ":", "\n", "        ", "skip", "+=", "1", "\n", "if", "self", ".", "block_size", "/", "pow", "(", "2", ",", "skip", ")", "<=", "self", ".", "min_block_size", ":", "\n", "          ", "break", "\n", "", "", "else", ":", "\n", "        ", "break", "\n", "\n", "# If Saliency Attack has exhausted, then return False", "\n", "", "", "if", "num_queries", "<=", "self", ".", "max_queries", ":", "\n", "      ", "tf", ".", "logging", ".", "info", "(", "\"num queries: {}\"", ".", "format", "(", "num_queries", ")", ")", "\n", "return", "adv_image", ",", "curr_noise", ",", "num_queries", ",", "False", ",", "flag", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.imagenet_labels.label_to_name": [[1006, 1009], ["None"], "function", ["None"], ["def", "label_to_name", "(", "label", ")", ":", "\n", "    ", "global", "_lut", "\n", "return", "_lut", "[", "label", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.inception_v3_imagenet._get_model": [[24, 34], ["tensorflow.inception.inception_v3_arg_scope", "functools.wraps", "hasattr", "tensorflow.arg_scope", "func"], "function", ["None"], ["def", "_get_model", "(", "reuse", ")", ":", "\n", "    ", "arg_scope", "=", "nets", ".", "inception", ".", "inception_v3_arg_scope", "(", "weight_decay", "=", "0.0", ")", "\n", "func", "=", "nets", ".", "inception", ".", "inception_v3", "\n", "@", "functools", ".", "wraps", "(", "func", ")", "\n", "def", "network_fn", "(", "images", ")", ":", "\n", "        ", "with", "slim", ".", "arg_scope", "(", "arg_scope", ")", ":", "\n", "            ", "return", "func", "(", "images", ",", "1001", ",", "is_training", "=", "False", ",", "reuse", "=", "reuse", ")", "\n", "", "", "if", "hasattr", "(", "func", ",", "'default_image_size'", ")", ":", "\n", "        ", "network_fn", ".", "default_image_size", "=", "func", ".", "default_image_size", "\n", "", "return", "network_fn", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.inception_v3_imagenet._preprocess": [[35, 43], ["tensorflow.name_scope", "tensorflow.image.resize_bilinear", "tensorflow.subtract", "tensorflow.multiply", "tensorflow.image.convert_image_dtype"], "function", ["None"], ["", "def", "_preprocess", "(", "image", ",", "height", ",", "width", ",", "scope", "=", "None", ")", ":", "\n", "    ", "with", "tf", ".", "name_scope", "(", "scope", ",", "'eval_image'", ",", "[", "image", ",", "height", ",", "width", "]", ")", ":", "\n", "        ", "if", "image", ".", "dtype", "!=", "tf", ".", "float32", ":", "\n", "            ", "image", "=", "tf", ".", "image", ".", "convert_image_dtype", "(", "image", ",", "dtype", "=", "tf", ".", "float32", ")", "\n", "", "image", "=", "tf", ".", "image", ".", "resize_bilinear", "(", "image", ",", "[", "height", ",", "width", "]", ",", "align_corners", "=", "False", ")", "\n", "image", "=", "tf", ".", "subtract", "(", "image", ",", "0.5", ")", "\n", "image", "=", "tf", ".", "multiply", "(", "image", ",", "2.0", ")", "\n", "return", "image", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.inception_v3_imagenet.model": [[45, 59], ["inception_v3_imagenet._get_model", "inception_v3_imagenet._preprocess", "_get_model.", "tensorflow.argmax", "tools.utils.optimistic_restore"], "function", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.inception_v3_imagenet._get_model", "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.inception_v3_imagenet._preprocess", "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.optimistic_restore"], ["def", "model", "(", "sess", ",", "image", ")", ":", "\n", "    ", "global", "_inception_initialized", "\n", "network_fn", "=", "_get_model", "(", "reuse", "=", "_inception_initialized", ")", "\n", "size", "=", "network_fn", ".", "default_image_size", "\n", "preprocessed", "=", "_preprocess", "(", "image", ",", "size", ",", "size", ")", "\n", "logits", ",", "_", "=", "network_fn", "(", "preprocessed", ")", "\n", "logits", "=", "logits", "[", ":", ",", "1", ":", "]", "# ignore background class", "\n", "predictions", "=", "tf", ".", "argmax", "(", "logits", ",", "1", ")", "\n", "\n", "if", "not", "_inception_initialized", ":", "\n", "        ", "optimistic_restore", "(", "sess", ",", "INCEPTION_CHECKPOINT_PATH", ")", "\n", "_inception_initialized", "=", "True", "\n", "\n", "", "return", "logits", ",", "predictions", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.image_of_class": [[14, 22], ["pickle.load", "[].copy", "open", "utils.get_image"], "function", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.get_image"], ["def", "image_of_class", "(", "y", ",", "imagenet_path", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Gets an image of a prespecified class. To save computation time we use a\n    presaved dictionary of an index for each class, but an attacker can also\n    randomize this, or search for the best starting images.\n    \"\"\"", "\n", "im_indices", "=", "pickle", ".", "load", "(", "open", "(", "\"tools/data/imagenet.pickle\"", ",", "\"rb\"", ")", ")", "\n", "return", "get_image", "(", "im_indices", "[", "y", "]", ",", "imagenet_path", ")", "[", "0", "]", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.pseudorandom_target": [[23, 29], ["numpy.random.RandomState", "np.random.RandomState.randint"], "function", ["None"], ["", "def", "pseudorandom_target", "(", "index", ",", "total_indices", ",", "true_class", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "index", ")", "\n", "target", "=", "true_class", "\n", "while", "target", "==", "true_class", ":", "\n", "        ", "target", "=", "rng", ".", "randint", "(", "0", ",", "total_indices", ")", "\n", "", "return", "target", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.pseudorandom_target_image": [[30, 36], ["numpy.random.RandomState", "np.random.RandomState.randint"], "function", ["None"], ["", "def", "pseudorandom_target_image", "(", "orig_index", ",", "total_indices", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "orig_index", ")", "\n", "target_img_index", "=", "orig_index", "\n", "while", "target_img_index", "==", "orig_index", ":", "\n", "        ", "target_img_index", "=", "rng", ".", "randint", "(", "0", ",", "total_indices", ")", "\n", "", "return", "target_img_index", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.load_image": [[38, 54], ["PIL.Image.open", "image.crop.resize", "int", "image.crop.crop", "numpy.asarray().astype", "numpy.repeat", "int", "image.crop.crop", "numpy.asarray"], "function", ["None"], ["", "def", "load_image", "(", "path", ")", ":", "\n", "    ", "image", "=", "PIL", ".", "Image", ".", "open", "(", "path", ")", "\n", "if", "image", ".", "height", ">", "image", ".", "width", ":", "\n", "        ", "height_off", "=", "int", "(", "(", "image", ".", "height", "-", "image", ".", "width", ")", "/", "2", ")", "\n", "image", "=", "image", ".", "crop", "(", "(", "0", ",", "height_off", ",", "image", ".", "width", ",", "height_off", "+", "image", ".", "width", ")", ")", "\n", "", "elif", "image", ".", "width", ">", "image", ".", "height", ":", "\n", "        ", "width_off", "=", "int", "(", "(", "image", ".", "width", "-", "image", ".", "height", ")", "/", "2", ")", "\n", "image", "=", "image", ".", "crop", "(", "(", "width_off", ",", "0", ",", "width_off", "+", "image", ".", "height", ",", "image", ".", "height", ")", ")", "\n", "", "image", "=", "image", ".", "resize", "(", "(", "299", ",", "299", ")", ")", "\n", "img", "=", "np", ".", "asarray", "(", "image", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.0", "\n", "if", "img", ".", "ndim", "==", "2", ":", "\n", "        ", "img", "=", "np", ".", "repeat", "(", "img", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "repeats", "=", "3", ",", "axis", "=", "2", ")", "\n", "", "if", "img", ".", "shape", "[", "2", "]", "==", "4", ":", "\n", "# alpha channel", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ",", ":", "3", "]", "\n", "", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.get_image": [[55, 69], ["os.path.join", "sorted", "os.path.join", "utils.get_image.get"], "function", ["None"], ["", "def", "get_image", "(", "index", ",", "imagenet_path", "=", "None", ")", ":", "\n", "    ", "data_path", "=", "os", ".", "path", ".", "join", "(", "imagenet_path", ",", "'val'", ")", "\n", "image_paths", "=", "sorted", "(", "[", "os", ".", "path", ".", "join", "(", "data_path", ",", "i", ")", "for", "i", "in", "os", ".", "listdir", "(", "data_path", ")", "]", ")", "\n", "assert", "len", "(", "image_paths", ")", "==", "50000", "\n", "labels_path", "=", "os", ".", "path", ".", "join", "(", "imagenet_path", ",", "'val.txt'", ")", "\n", "with", "open", "(", "labels_path", ")", "as", "labels_file", ":", "\n", "        ", "labels", "=", "[", "i", ".", "split", "(", "' '", ")", "for", "i", "in", "labels_file", ".", "read", "(", ")", ".", "strip", "(", ")", ".", "split", "(", "'\\n'", ")", "]", "\n", "labels", "=", "{", "os", ".", "path", ".", "basename", "(", "i", "[", "0", "]", ")", ":", "int", "(", "i", "[", "1", "]", ")", "for", "i", "in", "labels", "}", "\n", "", "def", "get", "(", "index", ")", ":", "\n", "        ", "path", "=", "image_paths", "[", "index", "]", "\n", "x", "=", "load_image", "(", "path", ")", "\n", "y", "=", "labels", "[", "os", ".", "path", ".", "basename", "(", "path", ")", "]", "\n", "return", "x", ",", "y", "\n", "", "return", "get", "(", "index", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.get_sal": [[70, 78], ["os.listdir", "print", "int", "str", "cv2.imread", "os.path.join"], "function", ["None"], ["", "def", "get_sal", "(", "index", ",", "sal_path", "=", "None", ")", ":", "\n", "    ", "for", "i", "in", "os", ".", "listdir", "(", "sal_path", ")", ":", "\n", "        ", "id", "=", "str", "(", "i", ")", "[", "0", ":", "5", "]", "# get first 5 bits for the index of image", "\n", "id", "=", "int", "(", "id", ")", "\n", "if", "id", "==", "index", ":", "\n", "            ", "image", "=", "cv2", ".", "imread", "(", "os", ".", "path", ".", "join", "(", "sal_path", ",", "i", ")", ",", "cv2", ".", "IMREAD_GRAYSCALE", ")", "\n", "return", "image", "\n", "", "", "print", "(", "'No matching saliency mask!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.L0_dis": [[79, 85], ["numpy.sum"], "function", ["None"], ["", "def", "L0_dis", "(", "noise", ")", ":", "\n", "  ", "img_size", "=", "noise", ".", "shape", "[", "1", "]", "*", "noise", ".", "shape", "[", "2", "]", "\n", "nb_channels", "=", "noise", ".", "shape", "[", "3", "]", "\n", "l0", "=", "np", ".", "sum", "(", "noise", "!=", "0", ")", "\n", "mean_l0", "=", "l0", "/", "(", "img_size", "*", "nb_channels", ")", "\n", "return", "mean_l0", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.one_hot": [[86, 90], ["numpy.zeros"], "function", ["None"], ["", "def", "one_hot", "(", "index", ",", "total", ")", ":", "\n", "    ", "arr", "=", "np", ".", "zeros", "(", "(", "total", ")", ")", "\n", "arr", "[", "index", "]", "=", "1.0", "\n", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.optimistic_restore": [[91, 105], ["tensorflow.train.NewCheckpointReader", "tf.train.NewCheckpointReader.get_variable_to_shape_map", "sorted", "tensorflow.train.Saver", "tf.train.Saver.restore", "tensorflow.variable_scope", "tensorflow.get_variable", "tf.get_variable.get_shape().as_list", "tensorflow.global_variables", "restore_vars.append", "var.name.split", "tf.get_variable.get_shape", "var.name.split"], "function", ["None"], ["", "def", "optimistic_restore", "(", "session", ",", "save_file", ")", ":", "\n", "    ", "reader", "=", "tf", ".", "train", ".", "NewCheckpointReader", "(", "save_file", ")", "\n", "saved_shapes", "=", "reader", ".", "get_variable_to_shape_map", "(", ")", "\n", "var_names", "=", "sorted", "(", "[", "(", "var", ".", "name", ",", "var", ".", "name", ".", "split", "(", "':'", ")", "[", "0", "]", ")", "for", "var", "in", "tf", ".", "global_variables", "(", ")", "\n", "if", "var", ".", "name", ".", "split", "(", "':'", ")", "[", "0", "]", "in", "saved_shapes", "]", ")", "\n", "restore_vars", "=", "[", "]", "\n", "with", "tf", ".", "variable_scope", "(", "''", ",", "reuse", "=", "True", ")", ":", "\n", "        ", "for", "var_name", ",", "saved_var_name", "in", "var_names", ":", "\n", "            ", "curr_var", "=", "tf", ".", "get_variable", "(", "saved_var_name", ")", "\n", "var_shape", "=", "curr_var", ".", "get_shape", "(", ")", ".", "as_list", "(", ")", "\n", "if", "var_shape", "==", "saved_shapes", "[", "saved_var_name", "]", ":", "\n", "                ", "restore_vars", ".", "append", "(", "curr_var", ")", "\n", "", "", "", "saver", "=", "tf", ".", "train", ".", "Saver", "(", "restore_vars", ")", "\n", "saver", ".", "restore", "(", "session", ",", "save_file", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.softmax": [[106, 109], ["numpy.exp", "np.exp.sum", "numpy.max"], "function", ["None"], ["", "def", "softmax", "(", "x", ")", ":", "\n", "    ", "e_x", "=", "np", ".", "exp", "(", "x", "-", "np", ".", "max", "(", "x", ")", ")", "\n", "return", "e_x", "/", "e_x", ".", "sum", "(", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.int_shape": [[110, 112], ["list", "map", "tensor.get_shape"], "function", ["None"], ["", "def", "int_shape", "(", "tensor", ")", ":", "\n", "    ", "return", "list", "(", "map", "(", "int", ",", "tensor", ".", "get_shape", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.chunks": [[113, 116], ["range", "len"], "function", ["None"], ["", "def", "chunks", "(", "l", ",", "n", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "l", ")", ",", "n", ")", ":", "\n", "        ", "yield", "l", "[", "i", ":", "i", "+", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.hms": [[117, 128], ["int"], "function", ["None"], ["", "", "def", "hms", "(", "seconds", ")", ":", "\n", "    ", "seconds", "=", "int", "(", "seconds", ")", "\n", "hours", "=", "(", "seconds", "//", "(", "60", "*", "60", ")", ")", "\n", "minutes", "=", "(", "seconds", "//", "60", ")", "%", "60", "\n", "seconds", "=", "seconds", "%", "60", "\n", "if", "hours", ">", "0", ":", "\n", "        ", "return", "'%d hrs %d min'", "%", "(", "hours", ",", "minutes", ")", "\n", "", "elif", "minutes", ">", "0", ":", "\n", "        ", "return", "'%d min %d sec'", "%", "(", "minutes", ",", "seconds", ")", "\n", "", "else", ":", "\n", "        ", "return", "'%d sec'", "%", "seconds", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.py_func": [[130, 140], ["tensorflow.get_default_graph", "tensorflow.RegisterGradient", "tf.get_default_graph.gradient_override_map", "tensorflow.py_func"], "function", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.py_func"], ["def", "py_func", "(", "func", ",", "inp", ",", "Tout", ",", "stateful", "=", "True", ",", "name", "=", "None", ",", "grad", "=", "None", ")", ":", "\n", "    ", "global", "_py_func_id", "\n", "\n", "rnd_name", "=", "'PyFuncGrad'", "+", "'%08d'", "%", "_py_func_id", "\n", "_py_func_id", "+=", "1", "\n", "\n", "tf", ".", "RegisterGradient", "(", "rnd_name", ")", "(", "grad", ")", "\n", "g", "=", "tf", ".", "get_default_graph", "(", ")", "\n", "with", "g", ".", "gradient_override_map", "(", "{", "\"PyFunc\"", ":", "rnd_name", ",", "\"PyFuncStateless\"", ":", "rnd_name", "}", ")", ":", "\n", "        ", "return", "tf", ".", "py_func", "(", "func", ",", "inp", ",", "Tout", ",", "stateful", "=", "stateful", ",", "name", "=", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.grad_clip_by_norm": [[141, 156], ["isinstance", "float", "tensorflow.python.framework.ops.name_scope", "utils.py_func", "identity.set_shape", "x.get_shape"], "function", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.py_func"], ["", "", "def", "grad_clip_by_norm", "(", "x", ",", "clip_norm", "=", "1", ",", "name", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "clip_norm", ",", "int", ")", ":", "\n", "        ", "clip_norm", "=", "float", "(", "clip_norm", ")", "\n", "", "with", "ops", ".", "name_scope", "(", "name", ",", "\"grad_clip_by_norm\"", ",", "[", "x", ",", "clip_norm", "]", ")", "as", "name", ":", "\n", "        ", "identity", ",", "=", "py_func", "(", "\n", "lambda", "t", ",", "\n", "_", ":", "t", ",", "\n", "[", "x", ",", "clip_norm", "]", ",", "\n", "[", "tf", ".", "float32", "]", ",", "\n", "name", "=", "name", ",", "\n", "grad", "=", "_grad_clip_by_norm_grad", ",", "\n", "stateful", "=", "False", "\n", ")", "\n", "identity", ".", "set_shape", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "return", "identity", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils._grad_clip_by_norm_grad": [[158, 161], ["tensorflow.clip_by_norm"], "function", ["None"], ["", "", "def", "_grad_clip_by_norm_grad", "(", "op", ",", "grad", ")", ":", "\n", "    ", "_", ",", "norm", "=", "op", ".", "inputs", "\n", "return", "(", "tf", ".", "clip_by_norm", "(", "grad", ",", "norm", ")", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.grad_clip_by_value": [[162, 177], ["isinstance", "float", "tensorflow.python.framework.ops.name_scope", "utils.py_func", "identity.set_shape", "x.get_shape"], "function", ["home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils.py_func"], ["", "def", "grad_clip_by_value", "(", "x", ",", "clip_magnitude", "=", "1", ",", "name", "=", "None", ")", ":", "\n", "    ", "if", "isinstance", "(", "clip_magnitude", ",", "int", ")", ":", "\n", "        ", "clip_magnitude", "=", "float", "(", "clip_magnitude", ")", "\n", "", "with", "ops", ".", "name_scope", "(", "name", ",", "\"grad_clip_by_value\"", ",", "[", "x", ",", "clip_magnitude", "]", ")", "as", "name", ":", "\n", "        ", "identity", ",", "=", "py_func", "(", "\n", "lambda", "t", ",", "\n", "_", ":", "t", ",", "\n", "[", "x", ",", "clip_magnitude", "]", ",", "\n", "[", "tf", ".", "float32", "]", ",", "\n", "name", "=", "name", ",", "\n", "grad", "=", "_grad_clip_by_value_grad", ",", "\n", "stateful", "=", "False", "\n", ")", "\n", "identity", ".", "set_shape", "(", "x", ".", "get_shape", "(", ")", ")", "\n", "return", "identity", "\n", "\n"]], "home.repos.pwc.inspect_result.daizy97_saliencyattack.tools.utils._grad_clip_by_value_grad": [[179, 182], ["tensorflow.clip_by_value"], "function", ["None"], ["", "", "def", "_grad_clip_by_value_grad", "(", "op", ",", "grad", ")", ":", "\n", "    ", "_", ",", "mag", "=", "op", ".", "inputs", "\n", "return", "(", "tf", ".", "clip_by_value", "(", "grad", ",", "-", "mag", ",", "mag", ")", ",", "None", ")", "\n", "", ""]]}