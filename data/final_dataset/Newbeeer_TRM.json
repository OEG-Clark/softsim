{"home.repos.pwc.inspect_result.Newbeeer_TRM.None.coco.getClassName": [[43, 48], ["range", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "getClassName", "(", "cID", ",", "cats", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "len", "(", "cats", ")", ")", ":", "\n", "        ", "if", "cats", "[", "i", "]", "[", "'id'", "]", "==", "cID", ":", "\n", "            ", "return", "cats", "[", "i", "]", "[", "'name'", "]", "\n", "", "", "return", "'None'", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.None.coco.random_different_enough_colour": [[62, 68], ["list", "numpy.random.choice", "numpy.min", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["def", "random_different_enough_colour", "(", ")", ":", "\n", "    ", "while", "True", ":", "\n", "        ", "x", "=", "np", ".", "random", ".", "choice", "(", "255", ",", "size", "=", "3", ")", "\n", "if", "np", ".", "min", "(", "np", ".", "sum", "(", "(", "x", "-", "biased_colours", ")", "**", "2", ",", "1", ")", ")", ">", "_D", ":", "\n", "            ", "break", "\n", "", "", "return", "list", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.None.coco.test_colours": [[72, 78], ["numpy.random.choice", "numpy.min", "numpy.min", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["def", "test_colours", "(", ")", ":", "\n", "    ", "while", "True", ":", "\n", "        ", "x", "=", "np", ".", "random", ".", "choice", "(", "255", ",", "size", "=", "3", ")", "\n", "if", "np", ".", "min", "(", "np", ".", "sum", "(", "(", "x", "-", "biased_colours", ")", "**", "2", ",", "1", ")", ")", ">", "_D", "and", "np", ".", "min", "(", "np", ".", "sum", "(", "(", "x", "-", "unbiased_colours", ")", "**", "2", ",", "1", ")", ")", ">", "_D", ":", "\n", "            ", "break", "\n", "", "", "return", "x", "\n", "", "test_unbiased_colours", "=", "np", ".", "array", "(", "[", "test_colours", "(", ")", "for", "_", "in", "range", "(", "10", ")", "]", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.None.coco.validation_colours": [[80, 86], ["numpy.random.choice", "numpy.min", "numpy.min", "numpy.min", "numpy.sum", "numpy.sum", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["def", "validation_colours", "(", ")", ":", "\n", "    ", "while", "True", ":", "\n", "        ", "x", "=", "np", ".", "random", ".", "choice", "(", "255", ",", "size", "=", "3", ")", "\n", "if", "np", ".", "min", "(", "np", ".", "sum", "(", "(", "x", "-", "biased_colours", ")", "**", "2", ",", "1", ")", ")", ">", "_D", "and", "np", ".", "min", "(", "np", ".", "sum", "(", "(", "x", "-", "unbiased_colours", ")", "**", "2", ",", "1", ")", ")", ">", "_D", "and", "np", ".", "min", "(", "np", ".", "sum", "(", "(", "x", "-", "test_unbiased_colours", ")", "**", "2", ",", "1", ")", ")", ">", "_D", ":", "\n", "            ", "break", "\n", "", "", "return", "x", "\n", "", "validation_unbiased_colours", "=", "np", ".", "array", "(", "[", "validation_colours", "(", ")", "for", "_", "in", "range", "(", "10", ")", "]", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.inv_hvp.sto": [[8, 46], ["v.detach.detach", "torch.chunk", "torch.chunk", "torch.chunk", "torch.chunk", "model.eval", "range", "model.train", "h_estimate.detach.detach", "len", "model", "torch.cross_entropy", "inv_hvp.hvp", "h_estimate.detach.detach", "torch.max", "torch.max", "abs"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hvp", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max"], ["def", "sto", "(", "v", ",", "model", ",", "batch", ",", "chunk", "=", "4", ")", ":", "\n", "    ", "\"\"\"s_test can be precomputed for each test point of interest, and then\n    multiplied with grad_z to get the desired value for each training point.\n    Here, strochastic estimation is used to calculate s_test. s_test is the\n    Inverse Hessian Vector Product.\n    Arguments:\n        z_test: torch tensor, test data points, such as test images\n        t_test: torch tensor, contains all test data labels\n        model: torch NN, model used to evaluate the dataset\n        z_loader: torch Dataloader, can load the training dataset\n        gpu: int, GPU id to use if >=0 and -1 means use CPU\n        damp: float, dampening factor\n        scale: float, scaling factor\n        recursion_depth: int, number of iterations aka recursion depth\n            should be enough so that the value stabilises.\n    Returns:\n        h_estimate: list of torch tensors, s_test\"\"\"", "\n", "v", "=", "v", ".", "detach", "(", ")", "\n", "h_estimate", "=", "v", "\n", "cnt", "=", "0.", "\n", "batch_x", "=", "torch", ".", "chunk", "(", "batch", "[", "0", "]", ",", "chunk", ",", "dim", "=", "0", ")", "\n", "batch_y", "=", "torch", ".", "chunk", "(", "batch", "[", "1", "]", ",", "chunk", ",", "dim", "=", "0", ")", "\n", "model", ".", "eval", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "batch_x", ")", ")", ":", "\n", "        ", "y", "=", "model", "(", "batch_x", "[", "i", "]", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "y", ",", "batch_y", "[", "i", "]", ")", "\n", "hv", "=", "hvp", "(", "loss", ",", "model", ".", "weight", ",", "h_estimate", ")", "\n", "h_estimate", "=", "v", "+", "h_estimate", "-", "hv", "\n", "h_estimate", "=", "h_estimate", ".", "detach", "(", ")", "\n", "cnt", "+=", "1", "\n", "\n", "# not converge", "\n", "if", "torch", ".", "max", "(", "abs", "(", "h_estimate", ")", ")", ">", "10", ":", "\n", "             ", "break", "\n", "\n", "\n", "", "", "model", ".", "train", "(", ")", "\n", "return", "h_estimate", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.inv_hvp.neum": [[47, 69], ["v.detach.detach", "model.eval", "range", "model.train", "h_estimate.detach.detach", "model", "torch.cross_entropy", "inv_hvp.hvp", "v.detach.detach", "h_estimate.detach.detach", "batch[].detach", "batch[].detach", "torch.max", "torch.max", "abs"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hvp", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max"], ["", "def", "neum", "(", "v", ",", "model", ",", "batch", ")", ":", "\n", "    ", "v", "=", "v", ".", "detach", "(", ")", "\n", "h_estimate", "=", "v", "\n", "cnt", "=", "0.", "\n", "model", ".", "eval", "(", ")", "\n", "iter", "=", "10", "\n", "for", "i", "in", "range", "(", "iter", ")", ":", "\n", "        ", "model", ".", "weight", ".", "grad", "*=", "0", "\n", "y", "=", "model", "(", "batch", "[", "0", "]", ".", "detach", "(", ")", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "y", ",", "batch", "[", "1", "]", ".", "detach", "(", ")", ")", "\n", "hv", "=", "hvp", "(", "loss", ",", "model", ".", "weight", ",", "v", ")", "\n", "v", "-=", "hv", "\n", "v", "=", "v", ".", "detach", "(", ")", "\n", "h_estimate", "=", "v", "+", "h_estimate", "\n", "h_estimate", "=", "h_estimate", ".", "detach", "(", ")", "\n", "# not converge", "\n", "if", "torch", ".", "max", "(", "abs", "(", "h_estimate", ")", ")", ">", "10", ":", "\n", "             ", "break", "\n", "", "cnt", "+=", "1", "\n", "\n", "", "model", ".", "train", "(", ")", "\n", "return", "h_estimate", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.inv_hvp.s_test": [[70, 102], ["v_q.detach", "t.view.view", "x.view.view", "model", "torch.cross_entropy", "inv_hvp.hvp", "h_estimate.detach.detach", "x.view.cuda", "t.view.cuda"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hvp"], ["", "def", "s_test", "(", "v_q", ",", "model", ",", "batch", ",", "damp", "=", "0.01", ",", "scale", "=", "25.0", ")", ":", "\n", "    ", "\"\"\"s_test can be precomputed for each test point of interest, and then\n    multiplied with grad_z to get the desired value for each training point.\n    Here, strochastic estimation is used to calculate s_test. s_test is the\n    Inverse Hessian Vector Product.\n    Arguments:\n        z_test: torch tensor, test data points, such as test images\n        t_test: torch tensor, contains all test data labels\n        model: torch NN, model used to evaluate the dataset\n        z_loader: torch Dataloader, can load the training dataset\n        gpu: int, GPU id to use if >=0 and -1 means use CPU\n        damp: float, dampening factor\n        scale: float, scaling factor\n        recursion_depth: int, number of iterations aka recursion depth\n            should be enough so that the value stabilises.\n    Returns:\n        h_estimate: list of torch tensors, s_test\"\"\"", "\n", "v", "=", "v_q", ".", "detach", "(", ")", "\n", "h_estimate", "=", "v", "\n", "cnt", "=", "0.", "\n", "for", "x", ",", "t", "in", "batch", ":", "\n", "        ", "t", "=", "t", ".", "view", "(", "1", ")", "\n", "x", "=", "x", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "x", ",", "t", "=", "x", ".", "cuda", "(", ")", ",", "t", ".", "cuda", "(", ")", "\n", "y", "=", "model", "(", "x", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "y", ",", "t", ")", "\n", "hv", "=", "hvp", "(", "loss", ",", "model", ".", "weight", ",", "h_estimate", ")", "\n", "h_estimate", "=", "v", "+", "h_estimate", "-", "hv", "\n", "h_estimate", "=", "h_estimate", ".", "detach", "(", ")", "\n", "cnt", "+=", "1", "\n", "break", "\n", "", "return", "h_estimate", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.inv_hvp.hvp": [[104, 130], ["torch.autograd.grad", "torch.nn.utils.parameters_to_vector", "torch.nn.utils.parameters_to_vector", "torch.autograd.grad", "torch.nn.utils.parameters_to_vector", "torch.nn.utils.parameters_to_vector"], "function", ["None"], ["", "def", "hvp", "(", "y", ",", "w", ",", "v", ")", ":", "\n", "    ", "\"\"\"Multiply the Hessians of y and w by v.\n    Uses a backprop-like approach to compute the product between the Hessian\n    and another vector efficiently, which even works for large Hessians.\n    Example: if: y = 0.5 * w^T A x then hvp(y, w, v) returns and expression\n    which evaluates to the same values as (A + A.t) v.\n    Arguments:\n        y: scalar/tensor, for example the output of the loss function\n        w: list of torch tensors, tensors over which the Hessian\n            should be constructed\n        v: list of torch tensors, same shape as w,\n            will be multiplied with the Hessian\n    Returns:\n        return_grads: list of torch tensors, contains product of Hessian and v.\n    Raises:\n        ValueError: `y` and `w` have a different length.\"\"\"", "\n", "\n", "# First backprop", "\n", "first_grads", "=", "grad", "(", "y", ",", "w", ",", "retain_graph", "=", "True", ",", "create_graph", "=", "True", ",", "allow_unused", "=", "True", ")", "\n", "first_grads", "=", "torch", ".", "nn", ".", "utils", ".", "parameters_to_vector", "(", "first_grads", ")", "\n", "# Elementwise products", "\n", "elemwise_products", "=", "first_grads", "@", "v", "\n", "# Second backprop", "\n", "return_grads", "=", "grad", "(", "elemwise_products", ",", "w", ",", "create_graph", "=", "True", ")", "\n", "return_grads", "=", "torch", ".", "nn", ".", "utils", ".", "parameters_to_vector", "(", "return_grads", ")", "\n", "return", "return_grads", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.SelectionMethod.__init__": [[15, 17], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "raise", "TypeError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.SelectionMethod.run_acc": [[18, 25], ["None"], "methods", ["None"], ["", "@", "classmethod", "\n", "def", "run_acc", "(", "self", ",", "run_records", ")", ":", "\n", "        ", "\"\"\"\n        Given records from a run, return a {val_acc, test_acc} dict representing\n        the best val-acc and corresponding test-acc for that run.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.SelectionMethod.sweep_acc": [[26, 41], ["records.group().map().filter_not_none().sorted", "len", "records.group().map().filter_not_none", "records.group().map", "records.group", "model_selection.SelectionMethod.run_acc"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter_not_none", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.map", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.group", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.LeaveOneOutSelectionMethod.run_acc"], ["", "@", "classmethod", "\n", "def", "sweep_acc", "(", "self", ",", "records", ")", ":", "\n", "        ", "\"\"\"\n        Given all records from a single (dataset, algorithm, test env) pair,\n        return the mean test acc of the k runs with the top val accs.\n        \"\"\"", "\n", "sorted_run_accs", "=", "(", "records", "\n", ".", "group", "(", "'args.hparams_seed'", ")", "\n", ".", "map", "(", "lambda", "_", ",", "run_records", ":", "self", ".", "run_acc", "(", "run_records", ")", ")", "\n", ".", "filter_not_none", "(", ")", "\n", ".", "sorted", "(", "key", "=", "lambda", "ra", ":", "ra", "[", "'val_acc'", "]", ")", ")", "\n", "if", "len", "(", "sorted_run_accs", ")", ":", "\n", "            ", "return", "sorted_run_accs", "[", "-", "1", "]", "[", "'test_acc'", "]", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.OracleSelectionMethod.run_acc": [[48, 61], ["run_records.filter.filter.filter", "len", "run_records.filter.filter.sorted", "len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["@", "classmethod", "\n", "def", "run_acc", "(", "self", ",", "run_records", ")", ":", "\n", "        ", "run_records", "=", "run_records", ".", "filter", "(", "lambda", "r", ":", "\n", "len", "(", "r", "[", "'args'", "]", "[", "'test_envs'", "]", ")", "==", "1", ")", "\n", "if", "not", "len", "(", "run_records", ")", ":", "\n", "            ", "return", "None", "\n", "", "test_env", "=", "run_records", "[", "0", "]", "[", "'args'", "]", "[", "'test_envs'", "]", "[", "0", "]", "\n", "test_out_acc_key", "=", "'env{}_out_acc'", ".", "format", "(", "test_env", ")", "\n", "test_in_acc_key", "=", "'env{}_in_acc'", ".", "format", "(", "test_env", ")", "\n", "chosen_record", "=", "run_records", ".", "sorted", "(", "lambda", "r", ":", "r", "[", "'step'", "]", ")", "[", "-", "1", "]", "\n", "return", "{", "\n", "'val_acc'", ":", "chosen_record", "[", "test_out_acc_key", "]", ",", "\n", "'test_acc'", ":", "chosen_record", "[", "test_in_acc_key", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.IIDAccuracySelectionMethod._step_acc": [[67, 81], ["itertools.count", "numpy.mean", "val_env_keys.append"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean"], ["@", "classmethod", "\n", "def", "_step_acc", "(", "self", ",", "record", ")", ":", "\n", "        ", "\"\"\"Given a single record, return a {val_acc, test_acc} dict.\"\"\"", "\n", "test_env", "=", "record", "[", "'args'", "]", "[", "'test_envs'", "]", "[", "0", "]", "\n", "val_env_keys", "=", "[", "]", "\n", "for", "i", "in", "itertools", ".", "count", "(", ")", ":", "\n", "            ", "if", "f'env{i}_out_acc'", "not", "in", "record", ":", "\n", "                ", "break", "\n", "", "if", "i", "!=", "test_env", ":", "\n", "                ", "val_env_keys", ".", "append", "(", "f'env{i}_out_acc'", ")", "\n", "", "", "test_in_acc_key", "=", "'env{}_in_acc'", ".", "format", "(", "test_env", ")", "\n", "return", "{", "\n", "'val_acc'", ":", "np", ".", "mean", "(", "[", "record", "[", "key", "]", "for", "key", "in", "val_env_keys", "]", ")", ",", "\n", "'test_acc'", ":", "record", "[", "test_in_acc_key", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.IIDAccuracySelectionMethod.run_acc": [[83, 89], ["model_selection.get_test_records", "get_test_records.map().argmax", "len", "get_test_records.map"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.get_test_records", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.argmax", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.map"], ["", "@", "classmethod", "\n", "def", "run_acc", "(", "self", ",", "run_records", ")", ":", "\n", "        ", "test_records", "=", "get_test_records", "(", "run_records", ")", "\n", "if", "not", "len", "(", "test_records", ")", ":", "\n", "            ", "return", "None", "\n", "", "return", "test_records", ".", "map", "(", "self", ".", "_step_acc", ")", ".", "argmax", "(", "'val_acc'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.LeaveOneOutSelectionMethod._step_acc": [[94, 119], ["model_selection.get_test_records", "itertools.count", "records.filter", "any", "len", "numpy.zeros", "list", "list", "numpy.sum", "len", "set", "set"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.get_test_records", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["@", "classmethod", "\n", "def", "_step_acc", "(", "self", ",", "records", ")", ":", "\n", "        ", "\"\"\"Return the {val_acc, test_acc} for a group of records corresponding\n        to a single step.\"\"\"", "\n", "test_records", "=", "get_test_records", "(", "records", ")", "\n", "if", "len", "(", "test_records", ")", "!=", "1", ":", "\n", "            ", "return", "None", "\n", "\n", "", "test_env", "=", "test_records", "[", "0", "]", "[", "'args'", "]", "[", "'test_envs'", "]", "[", "0", "]", "\n", "n_envs", "=", "0", "\n", "for", "i", "in", "itertools", ".", "count", "(", ")", ":", "\n", "            ", "if", "f'env{i}_out_acc'", "not", "in", "records", "[", "0", "]", ":", "\n", "                ", "break", "\n", "", "n_envs", "+=", "1", "\n", "", "val_accs", "=", "np", ".", "zeros", "(", "n_envs", ")", "-", "1", "\n", "for", "r", "in", "records", ".", "filter", "(", "lambda", "r", ":", "len", "(", "r", "[", "'args'", "]", "[", "'test_envs'", "]", ")", "==", "2", ")", ":", "\n", "            ", "val_env", "=", "(", "set", "(", "r", "[", "'args'", "]", "[", "'test_envs'", "]", ")", "-", "set", "(", "[", "test_env", "]", ")", ")", ".", "pop", "(", ")", "\n", "val_accs", "[", "val_env", "]", "=", "r", "[", "'env{}_in_acc'", ".", "format", "(", "val_env", ")", "]", "\n", "", "val_accs", "=", "list", "(", "val_accs", "[", ":", "test_env", "]", ")", "+", "list", "(", "val_accs", "[", "test_env", "+", "1", ":", "]", ")", "\n", "if", "any", "(", "[", "v", "==", "-", "1", "for", "v", "in", "val_accs", "]", ")", ":", "\n", "            ", "return", "None", "\n", "", "val_acc", "=", "np", ".", "sum", "(", "val_accs", ")", "/", "(", "n_envs", "-", "1", ")", "\n", "return", "{", "\n", "'val_acc'", ":", "val_acc", ",", "\n", "'test_acc'", ":", "test_records", "[", "0", "]", "[", "'env{}_in_acc'", ".", "format", "(", "test_env", ")", "]", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.LeaveOneOutSelectionMethod.run_acc": [[121, 130], ["records.group().map().filter_not_none", "len", "records.group().map().filter_not_none.argmax", "records.group().map", "records.group", "model_selection.LeaveOneOutSelectionMethod._step_acc"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter_not_none", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.argmax", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.map", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.group", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.LeaveOneOutSelectionMethod._step_acc"], ["", "@", "classmethod", "\n", "def", "run_acc", "(", "self", ",", "records", ")", ":", "\n", "        ", "step_accs", "=", "records", ".", "group", "(", "'step'", ")", ".", "map", "(", "lambda", "step", ",", "step_records", ":", "\n", "self", ".", "_step_acc", "(", "step_records", ")", "\n", ")", ".", "filter_not_none", "(", ")", "\n", "if", "len", "(", "step_accs", ")", ":", "\n", "            ", "return", "step_accs", ".", "argmax", "(", "'val_acc'", ")", "\n", "", "else", ":", "\n", "            ", "return", "None", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.model_selection.get_test_records": [[6, 10], ["records.filter", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["def", "get_test_records", "(", "records", ")", ":", "\n", "    ", "\"\"\"Given records with a common test env, get the test records (i.e. the\n    records with *only* that single test env and no other test envs)\"\"\"", "\n", "return", "records", ".", "filter", "(", "lambda", "r", ":", "len", "(", "r", "[", "'args'", "]", "[", "'test_envs'", "]", ")", "==", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Identity.__init__": [[14, 16], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "Identity", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Identity.forward": [[17, 19], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.SqueezeLastTwo.__init__": [[22, 24], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "SqueezeLastTwo", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.SqueezeLastTwo.forward": [[25, 27], ["x.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", ".", "view", "(", "x", ".", "shape", "[", "0", "]", ",", "x", ".", "shape", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.MLP.__init__": [[31, 40], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "range"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "n_inputs", ",", "n_outputs", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input", "=", "nn", ".", "Linear", "(", "n_inputs", ",", "hparams", "[", "'mlp_width'", "]", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "hparams", "[", "'mlp_dropout'", "]", ")", "\n", "self", ".", "hiddens", "=", "nn", ".", "ModuleList", "(", "[", "\n", "nn", ".", "Linear", "(", "hparams", "[", "'mlp_width'", "]", ",", "hparams", "[", "'mlp_width'", "]", ")", "\n", "for", "_", "in", "range", "(", "hparams", "[", "'mlp_depth'", "]", "-", "2", ")", "]", ")", "\n", "self", ".", "output", "=", "nn", ".", "Linear", "(", "hparams", "[", "'mlp_width'", "]", ",", "n_outputs", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.MLP.forward": [[41, 51], ["networks.MLP.input", "networks.MLP.dropout", "torch.relu", "torch.relu", "torch.relu", "networks.MLP.output", "hidden", "networks.MLP.dropout", "torch.relu", "torch.relu", "torch.relu"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "input", "(", "x", ")", "\n", "x", "=", "self", ".", "dropout", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "for", "hidden", "in", "self", ".", "hiddens", ":", "\n", "            ", "x", "=", "hidden", "(", "x", ")", "\n", "x", "=", "self", ".", "dropout", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "", "x", "=", "self", ".", "output", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ResNet.__init__": [[54, 82], ["super().__init__", "networks.Identity", "networks.ResNet.freeze_bn", "torch.Dropout", "torch.Dropout", "torch.Dropout", "domainbed.lib.resnet.resnet18", "domainbed.lib.resnet.resnet50", "networks.ResNet.network.conv1.weight.data.clone", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "range"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ResNet.freeze_bn", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet18", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet50"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "not", "hparams", "[", "'resnet50'", "]", ":", "\n", "            ", "self", ".", "network", "=", "resnet", ".", "resnet18", "(", "pretrained", "=", "True", ")", "\n", "self", ".", "n_outputs", "=", "512", "\n", "", "else", ":", "\n", "            ", "self", ".", "network", "=", "resnet", ".", "resnet50", "(", "pretrained", "=", "True", ")", "\n", "self", ".", "n_outputs", "=", "2048", "\n", "\n", "# adapt number of channels", "\n", "", "nc", "=", "input_shape", "[", "0", "]", "\n", "if", "nc", "!=", "3", ":", "\n", "            ", "tmp", "=", "self", ".", "network", ".", "conv1", ".", "weight", ".", "data", ".", "clone", "(", ")", "\n", "\n", "self", ".", "network", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "\n", "nc", ",", "64", ",", "kernel_size", "=", "(", "7", ",", "7", ")", ",", "\n", "stride", "=", "(", "2", ",", "2", ")", ",", "padding", "=", "(", "3", ",", "3", ")", ",", "bias", "=", "False", ")", "\n", "\n", "for", "i", "in", "range", "(", "nc", ")", ":", "\n", "                ", "self", ".", "network", ".", "conv1", ".", "weight", ".", "data", "[", ":", ",", "i", ",", ":", ",", ":", "]", "=", "tmp", "[", ":", ",", "i", "%", "3", ",", ":", ",", ":", "]", "\n", "\n", "# save memory", "\n", "", "", "del", "self", ".", "network", ".", "fc", "\n", "self", ".", "network", ".", "fc", "=", "Identity", "(", ")", "\n", "\n", "self", ".", "freeze_bn", "(", ")", "\n", "self", ".", "hparams", "=", "hparams", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "hparams", "[", "'resnet_dropout'", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ResNet.forward": [[83, 86], ["networks.ResNet.dropout", "networks.ResNet.network"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Encode x into a feature vector of size n_outputs.\"\"\"", "\n", "return", "self", ".", "dropout", "(", "self", ".", "network", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ResNet.train": [[87, 93], ["super().train", "networks.ResNet.freeze_bn"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ResNet.freeze_bn"], ["", "def", "train", "(", "self", ",", "mode", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Override the default train() to freeze the BN parameters\n        \"\"\"", "\n", "super", "(", ")", ".", "train", "(", "mode", ")", "\n", "self", ".", "freeze_bn", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ResNet.freeze_bn": [[94, 98], ["networks.ResNet.network.modules", "isinstance", "m.eval"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval"], ["", "def", "freeze_bn", "(", "self", ")", ":", "\n", "        ", "for", "m", "in", "self", ".", "network", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.MNIST_CNN.__init__": [[108, 123], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "networks.SqueezeLastTwo"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "MNIST_CNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "input_shape", "[", "0", "]", ",", "64", ",", "3", ",", "1", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "3", ",", "1", ",", "padding", "=", "1", ")", "\n", "#self.conv4 = nn.Conv2d(128, 128, 3, 1, padding=1)", "\n", "\n", "# I change from GroupNorm to BatchNorm", "\n", "self", ".", "bn0", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "#self.bn3 = nn.BatchNorm2d(128)", "\n", "\n", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "squeezeLastTwo", "=", "SqueezeLastTwo", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.MNIST_CNN.forward": [[124, 144], ["networks.MNIST_CNN.conv1", "torch.relu", "torch.relu", "torch.relu", "networks.MNIST_CNN.bn0", "networks.MNIST_CNN.conv2", "torch.relu", "torch.relu", "torch.relu", "networks.MNIST_CNN.bn1", "networks.MNIST_CNN.conv3", "torch.relu", "torch.relu", "torch.relu", "networks.MNIST_CNN.bn2", "networks.MNIST_CNN.avgpool", "networks.MNIST_CNN.squeezeLastTwo"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "bn0", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "bn2", "(", "x", ")", "\n", "\n", "#         x = self.conv4(x)", "\n", "#         x = F.relu(x)", "\n", "#         x = self.bn3(x)", "\n", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "self", ".", "squeezeLastTwo", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ContextNet.__init__": [[146, 159], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "super", "(", "ContextNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "# Keep same dimensions", "\n", "padding", "=", "(", "5", "-", "1", ")", "//", "2", "\n", "self", ".", "context_net", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "input_shape", "[", "0", "]", ",", "64", ",", "5", ",", "padding", "=", "padding", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "64", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "5", ",", "padding", "=", "padding", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "64", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Conv2d", "(", "64", ",", "1", ",", "5", ",", "padding", "=", "padding", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.ContextNet.forward": [[161, 163], ["networks.ContextNet.context_net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "context_net", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Featurizer": [[165, 180], ["len", "networks.MLP", "networks.MNIST_CNN", "domainbed.lib.wide_resnet.Wide_ResNet", "domainbed.lib.wide_resnet.Wide_ResNet", "networks.ResNet"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "", "def", "Featurizer", "(", "input_shape", ",", "hparams", ")", ":", "\n", "    ", "\"\"\"Auto-select an appropriate featurizer for the given input shape.\"\"\"", "\n", "if", "len", "(", "input_shape", ")", "==", "1", ":", "\n", "        ", "return", "MLP", "(", "input_shape", "[", "0", "]", ",", "128", ",", "hparams", ")", "\n", "", "elif", "input_shape", "[", "1", ":", "3", "]", "==", "(", "28", ",", "28", ")", ":", "\n", "        ", "return", "MNIST_CNN", "(", "input_shape", ")", "\n", "", "elif", "input_shape", "[", "1", ":", "3", "]", "==", "(", "32", ",", "32", ")", ":", "\n", "        ", "return", "wide_resnet", ".", "Wide_ResNet", "(", "input_shape", ",", "16", ",", "2", ",", "0.", ")", "\n", "", "elif", "input_shape", "[", "1", ":", "3", "]", "==", "(", "64", ",", "64", ")", ":", "\n", "        ", "return", "wide_resnet", ".", "Wide_ResNet", "(", "input_shape", ",", "16", ",", "2", ",", "0.", ")", "\n", "", "elif", "input_shape", "[", "1", ":", "3", "]", "==", "(", "224", ",", "224", ")", ":", "\n", "#return wide_resnet.Wide_ResNet(input_shape, 16, 2, 0.)", "\n", "        ", "return", "ResNet", "(", "input_shape", ",", "hparams", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.hparams_registry._hparams": [[5, 107], ["random_state.choice", "int", "int", "random_state.choice", "int", "int", "random_state.choice", "random_state.uniform", "int", "int", "int", "int", "int", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.choice", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "int", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "r.choice", "random_state.uniform", "random_state.uniform", "int", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "random_state.uniform", "int", "random_state.uniform", "random_state.choice", "random_state.uniform", "int", "random_state.uniform", "random_state.uniform", "int", "random_state.uniform", "random_state.uniform", "random_state.uniform"], "function", ["None"], ["def", "_hparams", "(", "algorithm", ",", "dataset", ",", "random_state", ",", "args", ")", ":", "\n", "    ", "\"\"\"\n    Global registry of hyperparams. Each entry is a (default, random) tuple.\n    New algorithms / networks / etc. should add entries here.\n    \"\"\"", "\n", "SMALL_IMAGES", "=", "[", "'Debug28'", ",", "'RotatedMNIST'", ",", "'ColoredMNIST'", "]", "\n", "\n", "hparams", "=", "{", "}", "\n", "hparams", "[", "'opt'", "]", "=", "(", "args", ".", "opt", ",", "args", ".", "opt", ")", "\n", "hparams", "[", "'data_augmentation'", "]", "=", "(", "True", ",", "True", ")", "\n", "hparams", "[", "'resnet50'", "]", "=", "(", "args", ".", "resnet50", ",", "False", ")", "\n", "hparams", "[", "'resnet_dropout'", "]", "=", "(", "0.", ",", "random_state", ".", "choice", "(", "[", "0.", ",", "0.1", ",", "0.5", "]", ")", ")", "\n", "hparams", "[", "'class_balanced'", "]", "=", "(", "args", ".", "class_balanced", ",", "False", ")", "\n", "hparams", "[", "'shift'", "]", "=", "(", "args", ".", "shift", ",", "args", ".", "shift", ")", "\n", "if", "dataset", "not", "in", "SMALL_IMAGES", ":", "\n", "        ", "hparams", "[", "'lr'", "]", "=", "(", "1e-1", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "5", ",", "-", "3.5", ")", ")", "\n", "hparams", "[", "'sch_size'", "]", "=", "(", "600", ",", "100", ")", "\n", "args", ".", "epochs", "=", "50", "\n", "if", "dataset", "==", "'DomainNet'", ":", "\n", "            ", "hparams", "[", "'batch_size'", "]", "=", "(", "32", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "3", ",", "5", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "hparams", "[", "'batch_size'", "]", "=", "(", "64", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "3", ",", "5.5", ")", ")", ")", "\n", "", "if", "algorithm", "==", "\"ARM\"", ":", "\n", "            ", "hparams", "[", "'batch_size'", "]", "=", "(", "8", ",", "8", ")", "\n", "", "if", "dataset", "==", "'PACS'", "or", "dataset", "==", "'VLCS'", "or", "dataset", "==", "'OfficeHome'", ":", "\n", "            ", "hparams", "[", "'lr'", "]", "=", "(", "1e-4", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "5", ",", "-", "3.5", ")", ")", "\n", "# no schedule", "\n", "hparams", "[", "'sch_size'", "]", "=", "(", "60000", ",", "100", ")", "\n", "hparams", "[", "'batch_size'", "]", "=", "(", "32", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "3", ",", "5", ")", ")", ")", "\n", "", "if", "dataset", "==", "'SceneCOCO'", ":", "\n", "            ", "args", ".", "epochs", "=", "100", "\n", "hparams", "[", "'batch_size'", "]", "=", "(", "128", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "3", ",", "9", ")", ")", ")", "\n", "hparams", "[", "'sch_size'", "]", "=", "(", "600", ",", "100", ")", "\n", "", "if", "dataset", "==", "'VLCS'", ":", "\n", "            ", "hparams", "[", "'batch_size'", "]", "=", "(", "16", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "3", ",", "5", ")", ")", ")", "\n", "", "", "else", ":", "\n", "# Small images", "\n", "        ", "hparams", "[", "'lr'", "]", "=", "(", "1e-1", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "4.5", ",", "-", "2.5", ")", ")", "\n", "hparams", "[", "'batch_size'", "]", "=", "(", "128", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "3", ",", "9", ")", ")", ")", "\n", "hparams", "[", "'sch_size'", "]", "=", "(", "600", ",", "100", ")", "\n", "if", "dataset", "==", "'ColoredMNIST'", ":", "\n", "            ", "args", ".", "epochs", "=", "10", "\n", "\n", "", "", "if", "dataset", "in", "SMALL_IMAGES", ":", "\n", "        ", "hparams", "[", "'weight_decay'", "]", "=", "(", "1e-4", ",", "0.", ")", "\n", "", "else", ":", "\n", "        ", "hparams", "[", "'weight_decay'", "]", "=", "(", "1e-4", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "6", ",", "-", "2", ")", ")", "\n", "", "if", "algorithm", "in", "[", "'DANN'", ",", "'CDANN'", "]", ":", "\n", "        ", "if", "dataset", "not", "in", "SMALL_IMAGES", ":", "\n", "            ", "hparams", "[", "'lr_g'", "]", "=", "(", "5e-5", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "5", ",", "-", "3.5", ")", ")", "\n", "hparams", "[", "'lr_d'", "]", "=", "(", "5e-5", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "5", ",", "-", "3.5", ")", ")", "\n", "", "else", ":", "\n", "            ", "hparams", "[", "'lr_g'", "]", "=", "(", "1e-3", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "4.5", ",", "-", "2.5", ")", ")", "\n", "hparams", "[", "'lr_d'", "]", "=", "(", "1e-3", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "4.5", ",", "-", "2.5", ")", ")", "\n", "\n", "", "if", "dataset", "in", "SMALL_IMAGES", ":", "\n", "            ", "hparams", "[", "'weight_decay_g'", "]", "=", "(", "0.", ",", "0.", ")", "\n", "", "else", ":", "\n", "            ", "hparams", "[", "'weight_decay_g'", "]", "=", "(", "0.", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "6", ",", "-", "2", ")", ")", "\n", "\n", "", "hparams", "[", "'lambda'", "]", "=", "(", "1.0", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "2", ",", "2", ")", ")", "\n", "hparams", "[", "'weight_decay_d'", "]", "=", "(", "0.", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "6", ",", "-", "2", ")", ")", "\n", "hparams", "[", "'d_steps_per_g_step'", "]", "=", "(", "1", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "0", ",", "3", ")", ")", ")", "\n", "hparams", "[", "'grad_penalty'", "]", "=", "(", "0.", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "2", ",", "1", ")", ")", "\n", "hparams", "[", "'beta1'", "]", "=", "(", "0.5", ",", "random_state", ".", "choice", "(", "[", "0.", ",", "0.5", "]", ")", ")", "\n", "hparams", "[", "'mlp_width'", "]", "=", "(", "256", ",", "int", "(", "2", "**", "random_state", ".", "uniform", "(", "6", ",", "10", ")", ")", ")", "\n", "hparams", "[", "'mlp_depth'", "]", "=", "(", "3", ",", "int", "(", "random_state", ".", "choice", "(", "[", "3", ",", "4", ",", "5", "]", ")", ")", ")", "\n", "hparams", "[", "'mlp_dropout'", "]", "=", "(", "0.", ",", "random_state", ".", "choice", "(", "[", "0.", ",", "0.1", ",", "0.5", "]", ")", ")", "\n", "", "elif", "algorithm", "==", "\"RSC\"", ":", "\n", "        ", "hparams", "[", "'rsc_f_drop_factor'", "]", "=", "(", "1", "/", "3", ",", "random_state", ".", "uniform", "(", "0", ",", "0.5", ")", ")", "# Feature drop factor", "\n", "hparams", "[", "'rsc_b_drop_factor'", "]", "=", "(", "1", "/", "3", ",", "random_state", ".", "uniform", "(", "0", ",", "0.5", ")", ")", "# Batch drop factor", "\n", "", "elif", "algorithm", "==", "'Fish'", ":", "\n", "        ", "hparams", "[", "'meta_lr'", "]", "=", "(", "args", ".", "fish_lam", ",", "lambda", "r", ":", "r", ".", "choice", "(", "[", "0.05", ",", "0.1", ",", "0.5", "]", ")", ")", "\n", "hparams", "[", "'iters'", "]", "=", "(", "200", ",", "int", "(", "10", "**", "random_state", ".", "uniform", "(", "0", ",", "4", ")", ")", ")", "\n", "", "elif", "algorithm", "==", "\"SagNet\"", ":", "\n", "        ", "hparams", "[", "'sag_w_adv'", "]", "=", "(", "0.1", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "2", ",", "1", ")", ")", "\n", "", "elif", "algorithm", "==", "\"IRM\"", ":", "\n", "        ", "hparams", "[", "'irm_lambda'", "]", "=", "(", "args", ".", "irm_lam", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "1", ",", "5", ")", ")", "\n", "hparams", "[", "'irm_penalty_anneal_iters'", "]", "=", "(", "100", ",", "int", "(", "10", "**", "random_state", ".", "uniform", "(", "0", ",", "4", ")", ")", ")", "\n", "", "elif", "algorithm", "==", "\"Mixup\"", ":", "\n", "        ", "hparams", "[", "'mixup_alpha'", "]", "=", "(", "0.2", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "1", ",", "-", "1", ")", ")", "\n", "", "elif", "algorithm", "==", "\"GroupDRO\"", ":", "\n", "        ", "hparams", "[", "'groupdro_eta'", "]", "=", "(", "args", ".", "dro_eta", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "3", ",", "-", "1", ")", ")", "\n", "hparams", "[", "'weight_decay'", "]", "=", "(", "1e-4", ",", "0.", ")", "\n", "", "elif", "algorithm", "==", "\"MMD\"", "or", "algorithm", "==", "\"CORAL\"", ":", "\n", "        ", "hparams", "[", "'mmd_gamma'", "]", "=", "(", "1.", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "1", ",", "1", ")", ")", "\n", "", "elif", "algorithm", "==", "\"MLDG\"", ":", "\n", "        ", "hparams", "[", "'mldg_beta'", "]", "=", "(", "1", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "1", ",", "1", ")", ")", "\n", "hparams", "[", "'iters'", "]", "=", "(", "200", ",", "int", "(", "10", "**", "random_state", ".", "uniform", "(", "0", ",", "4", ")", ")", ")", "\n", "", "elif", "algorithm", "==", "\"MTL\"", ":", "\n", "        ", "hparams", "[", "'mtl_ema'", "]", "=", "(", ".99", ",", "random_state", ".", "choice", "(", "[", "0.5", ",", "0.9", ",", "0.99", ",", "1.", "]", ")", ")", "\n", "", "elif", "algorithm", "==", "\"VREx\"", ":", "\n", "        ", "hparams", "[", "'vrex_lambda'", "]", "=", "(", "args", ".", "rex_lam", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "1", ",", "5", ")", ")", "\n", "hparams", "[", "'vrex_penalty_anneal_iters'", "]", "=", "(", "500", ",", "int", "(", "10", "**", "random_state", ".", "uniform", "(", "0", ",", "4", ")", ")", ")", "\n", "", "elif", "algorithm", "==", "\"ERM\"", ":", "\n", "        ", "pass", "\n", "", "elif", "algorithm", "==", "\"TRM\"", ":", "\n", "        ", "hparams", "[", "'cos_lambda'", "]", "=", "(", "args", ".", "cos_lam", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "5", ",", "0", ")", ")", "\n", "hparams", "[", "'iters'", "]", "=", "(", "200", ",", "int", "(", "10", "**", "random_state", ".", "uniform", "(", "0", ",", "4", ")", ")", ")", "\n", "hparams", "[", "'groupdro_eta'", "]", "=", "(", "args", ".", "dro_eta", ",", "10", "**", "random_state", ".", "uniform", "(", "-", "3", ",", "-", "1", ")", ")", "\n", "\n", "", "return", "hparams", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.hparams_registry.default_hparams": [[108, 112], ["numpy.random.RandomState", "_hparams().items", "hparams_registry._hparams"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.hparams_registry._hparams"], ["", "def", "default_hparams", "(", "algorithm", ",", "dataset", ",", "args", ")", ":", "\n", "    ", "dummy_random_state", "=", "np", ".", "random", ".", "RandomState", "(", "0", ")", "\n", "return", "{", "a", ":", "b", "for", "a", ",", "(", "b", ",", "c", ")", "in", "\n", "_hparams", "(", "algorithm", ",", "dataset", ",", "dummy_random_state", ",", "args", ")", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.hparams_registry.random_hparams": [[113, 116], ["numpy.random.RandomState", "_hparams().items", "hparams_registry._hparams"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.hparams_registry._hparams"], ["", "def", "random_hparams", "(", "algorithm", ",", "dataset", ",", "seed", ",", "args", ")", ":", "\n", "    ", "random_state", "=", "np", ".", "random", ".", "RandomState", "(", "seed", ")", "\n", "return", "{", "a", ":", "c", "for", "a", ",", "(", "b", ",", "c", ")", "in", "_hparams", "(", "algorithm", ",", "dataset", ",", "random_state", ",", "args", ")", ".", "items", "(", ")", "}", "\n", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Algorithm.__init__": [[56, 59], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "Algorithm", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hparams", "=", "hparams", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Algorithm.update": [[60, 66], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "        ", "\"\"\"\n        Perform one update step, given a list of (x, y) tuples for all\n        environments.\n        \"\"\"", "\n", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Algorithm.predict": [[67, 69], ["None"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.__init__": [[76, 107], ["algorithms.Algorithm.__init__", "domainbed.networks.Featurizer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "range", "algorithms.ERM.clist[].parameters", "range", "algorithms.ERM.network.parameters", "algorithms.ERM.classifier.parameters", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "algorithms.ERM.network.parameters"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Featurizer"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "ERM", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "featurizer", "=", "networks", ".", "Featurizer", "(", "input_shape", ",", "self", ".", "hparams", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "self", ".", "featurizer", ".", "n_outputs", ",", "num_classes", ")", "\n", "self", ".", "network", "=", "nn", ".", "Sequential", "(", "self", ".", "featurizer", ",", "self", ".", "classifier", ")", "\n", "self", ".", "clist", "=", "[", "nn", ".", "Linear", "(", "self", ".", "featurizer", ".", "n_outputs", ",", "num_classes", ")", ".", "cuda", "(", ")", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "self", ".", "olist", "=", "[", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "clist", "[", "i", "]", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "1e-1", ",", "\n", ")", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "if", "self", ".", "hparams", "[", "'opt'", "]", "==", "'SGD'", ":", "\n", "            ", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "self", ".", "optimizer_c", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "classifier", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "elif", "self", ".", "hparams", "[", "'opt'", "]", "==", "'Adam'", ":", "\n", "            ", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "self", ".", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "self", ".", "optimizer", ",", "step_size", "=", "self", ".", "hparams", "[", "'sch_size'", "]", ",", "gamma", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM._irm_penalty": [[108, 117], ["torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["", "@", "staticmethod", "\n", "def", "_irm_penalty", "(", "logits", ",", "y", ")", ":", "\n", "        ", "scale", "=", "torch", ".", "tensor", "(", "1.", ")", ".", "cuda", "(", ")", ".", "requires_grad_", "(", ")", "\n", "loss_1", "=", "F", ".", "cross_entropy", "(", "logits", "[", ":", ":", "2", "]", "*", "scale", ",", "y", "[", ":", ":", "2", "]", ")", "\n", "loss_2", "=", "F", ".", "cross_entropy", "(", "logits", "[", "1", ":", ":", "2", "]", "*", "scale", ",", "y", "[", "1", ":", ":", "2", "]", ")", "\n", "grad_1", "=", "autograd", ".", "grad", "(", "loss_1", ",", "[", "scale", "]", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "grad_2", "=", "autograd", ".", "grad", "(", "loss_2", ",", "[", "scale", "]", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "result", "=", "torch", ".", "sum", "(", "grad_1", "*", "grad_2", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.update": [[118, 132], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.ERM.featurizer", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.ERM.optimizer.zero_grad", "torch.cross_entropy.backward", "algorithms.ERM.optimizer.step", "algorithms.ERM.scheduler.step", "algorithms.ERM.classifier", "torch.cross_entropy.item"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "        ", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_y", "=", "torch", ".", "cat", "(", "[", "y", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "\n", "feature", "=", "self", ".", "featurizer", "(", "all_x", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "self", ".", "classifier", "(", "feature", ")", ",", "all_y", ")", "\n", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n", "return", "{", "'loss'", ":", "loss", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.predict": [[133, 135], ["algorithms.ERM.network"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "network", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.predict_feature": [[136, 138], ["algorithms.ERM.featurizer"], "methods", ["None"], ["", "def", "predict_feature", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "featurizer", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.predict_classifier": [[139, 141], ["algorithms.ERM.classifier"], "methods", ["None"], ["", "def", "predict_classifier", "(", "self", ",", "feature", ")", ":", "\n", "        ", "return", "self", ".", "classifier", "(", "feature", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.train": [[142, 144], ["algorithms.ERM.network.train"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "self", ".", "network", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ERM.eval": [[145, 147], ["algorithms.ERM.network.eval"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "self", ".", "network", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.EC.__init__": [[150, 167], ["algorithms.Algorithm.__init__", "domainbed.networks.Featurizer", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.nn.Sequential().cuda", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "range", "algorithms.EC.classifiers[].parameters", "range", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.nn.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Featurizer"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "EC", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "featurizer", "=", "networks", ".", "Featurizer", "(", "input_shape", ",", "self", ".", "hparams", ")", "\n", "self", ".", "latent_dim", "=", "64", "\n", "self", ".", "input_dim", "=", "self", ".", "featurizer", ".", "n_outputs", "\n", "self", ".", "num_domains", "=", "num_domains", "\n", "del", "self", ".", "featurizer", "\n", "\n", "self", ".", "classifiers", "=", "[", "torch", ".", "nn", ".", "Sequential", "(", "nn", ".", "Linear", "(", "self", ".", "input_dim", ",", "self", ".", "latent_dim", ")", ",", "nn", ".", "ReLU", "(", "True", ")", ",", "\n", "nn", ".", "Linear", "(", "self", ".", "latent_dim", ",", "num_classes", ")", ")", ".", "cuda", "(", ")", "for", "i", "in", "\n", "range", "(", "num_domains", ")", "]", "\n", "self", ".", "optimizer", "=", "[", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "classifiers", "[", "i", "]", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "1e-2", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "for", "i", "in", "range", "(", "num_domains", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.EC.update_ec": [[168, 178], ["feature.detach", "range", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.EC.optimizer[].zero_grad", "torch.cross_entropy.backward", "algorithms.EC.optimizer[].step", "[].size", "[].size"], "methods", ["None"], ["", "def", "update_ec", "(", "self", ",", "minibatches", ",", "feature", ")", ":", "\n", "        ", "features", "=", "feature", ".", "detach", "(", ")", "\n", "start", "=", "0", "\n", "for", "i", "in", "range", "(", "self", ".", "num_domains", ")", ":", "\n", "            ", "loss", "=", "F", ".", "cross_entropy", "(", "self", ".", "classifiers", "[", "i", "]", "(", "features", "[", "start", ":", "start", "+", "minibatches", "[", "i", "]", "[", "1", "]", ".", "size", "(", "0", ")", "]", ")", ",", "\n", "minibatches", "[", "i", "]", "[", "1", "]", ")", "\n", "self", ".", "optimizer", "[", "i", "]", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", "[", "i", "]", ".", "step", "(", ")", "\n", "start", "+=", "minibatches", "[", "i", "]", "[", "1", "]", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.EC.predict_envs": [[179, 181], ["None"], "methods", ["None"], ["", "", "def", "predict_envs", "(", "self", ",", "env", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "classifiers", "[", "env", "]", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.EC.predict": [[182, 184], ["None"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ARM.__init__": [[188, 195], ["algorithms.ERM.__init__", "domainbed.networks.ContextNet"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "original_input_shape", "=", "input_shape", "\n", "input_shape", "=", "(", "1", "+", "original_input_shape", "[", "0", "]", ",", ")", "+", "original_input_shape", "[", "1", ":", "]", "\n", "super", "(", "ARM", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "context_net", "=", "networks", ".", "ContextNet", "(", "original_input_shape", ")", "\n", "self", ".", "support_size", "=", "hparams", "[", "'batch_size'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.ARM.predict": [[196, 209], ["algorithms.ARM.context_net", "torch.repeat_interleave.reshape", "torch.repeat_interleave.reshape", "torch.repeat_interleave.reshape", "torch.repeat_interleave.reshape", "torch.repeat_interleave.reshape", "torch.repeat_interleave.mean", "torch.repeat_interleave.mean", "torch.repeat_interleave.mean", "torch.repeat_interleave.mean", "torch.repeat_interleave.mean", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.repeat_interleave", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.ARM.network"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "batch_size", ",", "c", ",", "h", ",", "w", "=", "x", ".", "shape", "\n", "if", "batch_size", "%", "self", ".", "support_size", "==", "0", ":", "\n", "            ", "meta_batch_size", "=", "batch_size", "//", "self", ".", "support_size", "\n", "support_size", "=", "self", ".", "support_size", "\n", "", "else", ":", "\n", "            ", "meta_batch_size", ",", "support_size", "=", "1", ",", "batch_size", "\n", "", "context", "=", "self", ".", "context_net", "(", "x", ")", "\n", "context", "=", "context", ".", "reshape", "(", "(", "meta_batch_size", ",", "support_size", ",", "1", ",", "h", ",", "w", ")", ")", "\n", "context", "=", "context", ".", "mean", "(", "dim", "=", "1", ")", "\n", "context", "=", "torch", ".", "repeat_interleave", "(", "context", ",", "repeats", "=", "support_size", ",", "dim", "=", "0", ")", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "context", "]", ",", "dim", "=", "1", ")", "\n", "return", "self", ".", "network", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractDANN.__init__": [[213, 260], ["algorithms.Algorithm.__init__", "algorithms.AbstractDANN.register_buffer", "domainbed.networks.Featurizer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "domainbed.networks.MLP", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "list", "list", "list", "list", "list", "list", "list", "list", "algorithms.AbstractDANN.discriminator.parameters", "algorithms.AbstractDANN.class_embeddings.parameters", "algorithms.AbstractDANN.featurizer.parameters", "algorithms.AbstractDANN.classifier.parameters", "algorithms.AbstractDANN.discriminator.parameters", "algorithms.AbstractDANN.class_embeddings.parameters", "algorithms.AbstractDANN.featurizer.parameters", "algorithms.AbstractDANN.classifier.parameters"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Featurizer"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ",", "conditional", ",", "class_balance", ")", ":", "\n", "\n", "        ", "super", "(", "AbstractDANN", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "\n", "self", ".", "register_buffer", "(", "'update_count'", ",", "torch", ".", "tensor", "(", "[", "0", "]", ")", ")", "\n", "self", ".", "conditional", "=", "conditional", "\n", "self", ".", "class_balance", "=", "class_balance", "\n", "\n", "# Algorithms", "\n", "self", ".", "featurizer", "=", "networks", ".", "Featurizer", "(", "input_shape", ",", "self", ".", "hparams", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "self", ".", "featurizer", ".", "n_outputs", ",", "num_classes", ")", "\n", "self", ".", "discriminator", "=", "networks", ".", "MLP", "(", "self", ".", "featurizer", ".", "n_outputs", ",", "\n", "num_domains", ",", "self", ".", "hparams", ")", "\n", "self", ".", "class_embeddings", "=", "nn", ".", "Embedding", "(", "num_classes", ",", "\n", "self", ".", "featurizer", ".", "n_outputs", ")", "\n", "\n", "# Optimizers", "\n", "if", "self", ".", "hparams", "[", "\"opt\"", "]", "==", "'Adam'", ":", "\n", "            ", "self", ".", "disc_opt", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "(", "list", "(", "self", ".", "discriminator", ".", "parameters", "(", ")", ")", "+", "\n", "list", "(", "self", ".", "class_embeddings", ".", "parameters", "(", ")", ")", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr_d\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay_d'", "]", ",", "\n", "betas", "=", "(", "self", ".", "hparams", "[", "'beta1'", "]", ",", "0.9", ")", ")", "\n", "\n", "self", ".", "gen_opt", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "(", "list", "(", "self", ".", "featurizer", ".", "parameters", "(", ")", ")", "+", "\n", "list", "(", "self", ".", "classifier", ".", "parameters", "(", ")", ")", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr_g\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay_g'", "]", ",", "\n", "betas", "=", "(", "self", ".", "hparams", "[", "'beta1'", "]", ",", "0.9", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "disc_opt", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "(", "list", "(", "self", ".", "discriminator", ".", "parameters", "(", ")", ")", "+", "\n", "list", "(", "self", ".", "class_embeddings", ".", "parameters", "(", ")", ")", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "self", ".", "gen_opt", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "(", "list", "(", "self", ".", "featurizer", ".", "parameters", "(", ")", ")", "+", "\n", "list", "(", "self", ".", "classifier", ".", "parameters", "(", ")", ")", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractDANN.update": [[261, 307], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.AbstractDANN.featurizer", "algorithms.AbstractDANN.discriminator", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.one_hot().sum", "torch.one_hot().sum", "torch.one_hot().sum", "torch.one_hot().sum", "torch.one_hot().sum", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "algorithms.AbstractDANN.disc_opt.zero_grad", "torch.cross_entropy.backward", "algorithms.AbstractDANN.disc_opt.step", "algorithms.AbstractDANN.classifier", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.AbstractDANN.disc_opt.zero_grad", "algorithms.AbstractDANN.gen_opt.zero_grad", "gen_loss.backward", "algorithms.AbstractDANN.gen_opt.step", "algorithms.AbstractDANN.class_embeddings", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "torch.full", "disc_softmax[].sum", "algorithms.AbstractDANN.update_count.item", "torch.cross_entropy.item", "gen_loss.item", "enumerate", "torch.one_hot", "torch.one_hot", "torch.one_hot", "torch.one_hot", "torch.one_hot"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["", "", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "        ", "self", ".", "update_count", "+=", "1", "\n", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_y", "=", "torch", ".", "cat", "(", "[", "y", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_z", "=", "self", ".", "featurizer", "(", "all_x", ")", "\n", "if", "self", ".", "conditional", ":", "\n", "            ", "disc_input", "=", "all_z", "+", "self", ".", "class_embeddings", "(", "all_y", ")", "\n", "", "else", ":", "\n", "            ", "disc_input", "=", "all_z", "\n", "", "disc_out", "=", "self", ".", "discriminator", "(", "disc_input", ")", "\n", "disc_labels", "=", "torch", ".", "cat", "(", "[", "\n", "torch", ".", "full", "(", "(", "x", ".", "shape", "[", "0", "]", ",", ")", ",", "i", ",", "dtype", "=", "torch", ".", "int64", ",", "device", "=", "'cuda'", ")", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "minibatches", ")", "\n", "]", ")", "\n", "\n", "if", "self", ".", "class_balance", ":", "\n", "            ", "y_counts", "=", "F", ".", "one_hot", "(", "all_y", ")", ".", "sum", "(", "dim", "=", "0", ")", "\n", "weights", "=", "1.", "/", "(", "y_counts", "[", "all_y", "]", "*", "y_counts", ".", "shape", "[", "0", "]", ")", ".", "float", "(", ")", "\n", "disc_loss", "=", "F", ".", "cross_entropy", "(", "disc_out", ",", "disc_labels", ",", "reduction", "=", "'none'", ")", "\n", "disc_loss", "=", "(", "weights", "*", "disc_loss", ")", ".", "sum", "(", ")", "\n", "", "else", ":", "\n", "            ", "disc_loss", "=", "F", ".", "cross_entropy", "(", "disc_out", ",", "disc_labels", ")", "\n", "\n", "", "disc_softmax", "=", "F", ".", "softmax", "(", "disc_out", ",", "dim", "=", "1", ")", "\n", "input_grad", "=", "autograd", ".", "grad", "(", "disc_softmax", "[", ":", ",", "disc_labels", "]", ".", "sum", "(", ")", ",", "\n", "[", "disc_input", "]", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "grad_penalty", "=", "(", "input_grad", "**", "2", ")", ".", "sum", "(", "dim", "=", "1", ")", ".", "mean", "(", "dim", "=", "0", ")", "\n", "disc_loss", "+=", "self", ".", "hparams", "[", "'grad_penalty'", "]", "*", "grad_penalty", "\n", "\n", "d_steps_per_g", "=", "self", ".", "hparams", "[", "'d_steps_per_g_step'", "]", "\n", "if", "(", "self", ".", "update_count", ".", "item", "(", ")", "%", "(", "1", "+", "d_steps_per_g", ")", "<", "d_steps_per_g", ")", ":", "\n", "\n", "            ", "self", ".", "disc_opt", ".", "zero_grad", "(", ")", "\n", "disc_loss", ".", "backward", "(", ")", "\n", "self", ".", "disc_opt", ".", "step", "(", ")", "\n", "return", "{", "'disc_loss'", ":", "disc_loss", ".", "item", "(", ")", "}", "\n", "", "else", ":", "\n", "            ", "all_preds", "=", "self", ".", "classifier", "(", "all_z", ")", "\n", "classifier_loss", "=", "F", ".", "cross_entropy", "(", "all_preds", ",", "all_y", ")", "\n", "gen_loss", "=", "(", "classifier_loss", "+", "\n", "(", "self", ".", "hparams", "[", "'lambda'", "]", "*", "-", "disc_loss", ")", ")", "\n", "self", ".", "disc_opt", ".", "zero_grad", "(", ")", "\n", "self", ".", "gen_opt", ".", "zero_grad", "(", ")", "\n", "gen_loss", ".", "backward", "(", ")", "\n", "self", ".", "gen_opt", ".", "step", "(", ")", "\n", "return", "{", "'gen_loss'", ":", "gen_loss", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractDANN.predict": [[308, 310], ["algorithms.AbstractDANN.classifier", "algorithms.AbstractDANN.featurizer"], "methods", ["None"], ["", "", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "classifier", "(", "self", ".", "featurizer", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.DANN.__init__": [[314, 317], ["algorithms.AbstractDANN.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "DANN", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ",", "conditional", "=", "False", ",", "class_balance", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.CDANN.__init__": [[321, 324], ["algorithms.AbstractDANN.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "CDANN", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ",", "conditional", "=", "True", ",", "class_balance", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.__init__": [[332, 339], ["algorithms.ERM.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ",", "gaussian", ")", ":", "\n", "        ", "super", "(", "AbstractMMD", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "if", "gaussian", ":", "\n", "            ", "self", ".", "kernel_type", "=", "\"gaussian\"", "\n", "", "else", ":", "\n", "            ", "self", ".", "kernel_type", "=", "\"mean_cov\"", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.my_cdist": [[340, 347], ["x1.pow().sum", "x2.pow().sum", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_", "torch.addmm().add_.clamp_min_", "torch.addmm().add_.clamp_min_", "torch.addmm().add_.clamp_min_", "torch.addmm().add_.clamp_min_", "torch.addmm().add_.clamp_min_", "x1.pow", "x2.pow", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "torch.addmm", "x2.pow().sum.transpose", "x2.transpose"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["", "", "def", "my_cdist", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "x1_norm", "=", "x1", ".", "pow", "(", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "x2_norm", "=", "x2", ".", "pow", "(", "2", ")", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "\n", "res", "=", "torch", ".", "addmm", "(", "x2_norm", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ",", "\n", "x1", ",", "\n", "x2", ".", "transpose", "(", "-", "2", ",", "-", "1", ")", ",", "alpha", "=", "-", "2", ")", ".", "add_", "(", "x1_norm", ")", "\n", "return", "res", ".", "clamp_min_", "(", "1e-30", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.gaussian_kernel": [[348, 357], ["algorithms.AbstractMMD.my_cdist", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like.add_", "torch.zeros_like.add_", "torch.zeros_like.add_", "torch.zeros_like.add_", "torch.zeros_like.add_", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "torch.exp", "algorithms.AbstractMMD.mul"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.my_cdist"], ["", "def", "gaussian_kernel", "(", "self", ",", "x", ",", "y", ",", "gamma", "=", "[", "0.001", ",", "0.01", ",", "0.1", ",", "1", ",", "10", ",", "100", ",", "\n", "1000", "]", ")", ":", "\n", "        ", "D", "=", "self", ".", "my_cdist", "(", "x", ",", "y", ")", "\n", "K", "=", "torch", ".", "zeros_like", "(", "D", ")", "\n", "\n", "for", "g", "in", "gamma", ":", "\n", "            ", "K", ".", "add_", "(", "torch", ".", "exp", "(", "D", ".", "mul", "(", "-", "g", ")", ")", ")", "\n", "\n", "", "return", "K", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.mmd": [[358, 376], ["algorithms.AbstractMMD.gaussian_kernel().mean", "algorithms.AbstractMMD.gaussian_kernel().mean", "algorithms.AbstractMMD.gaussian_kernel().mean", "x.mean", "y.mean", "algorithms.AbstractMMD.gaussian_kernel", "algorithms.AbstractMMD.gaussian_kernel", "algorithms.AbstractMMD.gaussian_kernel", "cent_x.t", "len", "cent_y.t", "len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.gaussian_kernel", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.gaussian_kernel", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.gaussian_kernel", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "mmd", "(", "self", ",", "x", ",", "y", ")", ":", "\n", "        ", "if", "self", ".", "kernel_type", "==", "\"gaussian\"", ":", "\n", "            ", "Kxx", "=", "self", ".", "gaussian_kernel", "(", "x", ",", "x", ")", ".", "mean", "(", ")", "\n", "Kyy", "=", "self", ".", "gaussian_kernel", "(", "y", ",", "y", ")", ".", "mean", "(", ")", "\n", "Kxy", "=", "self", ".", "gaussian_kernel", "(", "x", ",", "y", ")", ".", "mean", "(", ")", "\n", "return", "Kxx", "+", "Kyy", "-", "2", "*", "Kxy", "\n", "", "else", ":", "\n", "            ", "mean_x", "=", "x", ".", "mean", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "mean_y", "=", "y", ".", "mean", "(", "0", ",", "keepdim", "=", "True", ")", "\n", "cent_x", "=", "x", "-", "mean_x", "\n", "cent_y", "=", "y", "-", "mean_y", "\n", "cova_x", "=", "(", "cent_x", ".", "t", "(", ")", "@", "cent_x", ")", "/", "(", "len", "(", "x", ")", "-", "1", ")", "\n", "cova_y", "=", "(", "cent_y", ".", "t", "(", ")", "@", "cent_y", ")", "/", "(", "len", "(", "y", ")", "-", "1", ")", "\n", "\n", "mean_diff", "=", "(", "mean_x", "-", "mean_y", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "cova_diff", "=", "(", "cova_x", "-", "cova_y", ")", ".", "pow", "(", "2", ")", ".", "mean", "(", ")", "\n", "\n", "return", "mean_diff", "+", "cova_diff", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.update": [[377, 405], ["len", "range", "algorithms.AbstractMMD.optimizer.zero_grad", "algorithms.AbstractMMD.optimizer.step", "algorithms.AbstractMMD.scheduler.step", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "torch.is_tensor", "algorithms.AbstractMMD.featurizer", "algorithms.AbstractMMD.classifier", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "range", "penalty.item.item.item", "objective.item", "algorithms.AbstractMMD.mmd"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.AbstractMMD.mmd"], ["", "", "def", "update", "(", "self", ",", "minibatches", ",", "unlabeled", "=", "None", ")", ":", "\n", "        ", "objective", "=", "0", "\n", "penalty", "=", "0", "\n", "# domain number", "\n", "nmb", "=", "len", "(", "minibatches", ")", "\n", "\n", "features", "=", "[", "self", ".", "featurizer", "(", "xi", ")", "for", "xi", ",", "_", "in", "minibatches", "]", "\n", "classifs", "=", "[", "self", ".", "classifier", "(", "fi", ")", "for", "fi", "in", "features", "]", "\n", "targets", "=", "[", "yi", "for", "_", ",", "yi", "in", "minibatches", "]", "\n", "\n", "for", "i", "in", "range", "(", "nmb", ")", ":", "\n", "            ", "objective", "+=", "F", ".", "cross_entropy", "(", "classifs", "[", "i", "]", ",", "targets", "[", "i", "]", ")", "\n", "for", "j", "in", "range", "(", "i", "+", "1", ",", "nmb", ")", ":", "\n", "                ", "penalty", "+=", "self", ".", "mmd", "(", "features", "[", "i", "]", ",", "features", "[", "j", "]", ")", "\n", "\n", "", "", "objective", "/=", "nmb", "\n", "if", "nmb", ">", "1", ":", "\n", "            ", "penalty", "/=", "(", "nmb", "*", "(", "nmb", "-", "1", ")", "/", "2", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "(", "objective", "+", "(", "self", ".", "hparams", "[", "'mmd_gamma'", "]", "*", "penalty", ")", ")", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "if", "torch", ".", "is_tensor", "(", "penalty", ")", ":", "\n", "            ", "penalty", "=", "penalty", ".", "item", "(", ")", "\n", "\n", "", "return", "{", "'loss'", ":", "objective", ".", "item", "(", ")", ",", "'penalty'", ":", "penalty", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.MMD.__init__": [[412, 415], ["algorithms.AbstractMMD.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "MMD", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "\n", "num_domains", ",", "hparams", ",", "gaussian", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.CORAL.__init__": [[422, 425], ["algorithms.AbstractMMD.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "CORAL", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "\n", "num_domains", ",", "hparams", ",", "gaussian", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.IRM.__init__": [[429, 445], ["algorithms.ERM.__init__", "algorithms.IRM.register_buffer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "algorithms.IRM.featurizer.parameters", "algorithms.IRM.classifier.parameters"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "IRM", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "register_buffer", "(", "'update_count'", ",", "torch", ".", "tensor", "(", "[", "0", "]", ")", ")", "\n", "if", "self", ".", "hparams", "[", "'opt'", "]", "==", "'SGD'", ":", "\n", "            ", "self", ".", "optimizer_f", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "featurizer", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "self", ".", "optimizer_c", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "classifier", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.IRM._irm_penalty": [[447, 456], ["torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.tensor().cuda().requires_grad_", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["", "", "@", "staticmethod", "\n", "def", "_irm_penalty", "(", "logits", ",", "y", ")", ":", "\n", "        ", "scale", "=", "torch", ".", "tensor", "(", "1.", ")", ".", "cuda", "(", ")", ".", "requires_grad_", "(", ")", "\n", "loss_1", "=", "F", ".", "cross_entropy", "(", "logits", "[", ":", ":", "2", "]", "*", "scale", ",", "y", "[", ":", ":", "2", "]", ")", "\n", "loss_2", "=", "F", ".", "cross_entropy", "(", "logits", "[", "1", ":", ":", "2", "]", "*", "scale", ",", "y", "[", "1", ":", ":", "2", "]", ")", "\n", "grad_1", "=", "autograd", ".", "grad", "(", "loss_1", ",", "[", "scale", "]", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "grad_2", "=", "autograd", ".", "grad", "(", "loss_2", ",", "[", "scale", "]", ",", "create_graph", "=", "True", ")", "[", "0", "]", "\n", "result", "=", "torch", ".", "sum", "(", "grad_1", "*", "grad_2", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.IRM.update": [[457, 496], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.IRM.network.train", "algorithms.IRM.network", "enumerate", "len", "len", "algorithms.IRM.optimizer.zero_grad", "loss.backward", "algorithms.IRM.optimizer.step", "algorithms.IRM.scheduler.step", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.IRM._irm_penalty", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "loss.item", "nll.item", "penalty.item", "algorithms.IRM.network.parameters"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.IRM._irm_penalty"], ["", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "\n", "\n", "        ", "penalty_weight", "=", "(", "\n", "self", ".", "hparams", "[", "'irm_lambda'", "]", "if", "self", ".", "update_count", ">=", "self", ".", "hparams", "[", "'irm_penalty_anneal_iters'", "]", "else", "0", ")", "\n", "\n", "nll", "=", "0.", "\n", "penalty", "=", "0.", "\n", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_y", "=", "torch", ".", "cat", "(", "[", "y", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "\n", "self", ".", "network", ".", "train", "(", ")", "\n", "all_logits", "=", "self", ".", "network", "(", "all_x", ")", "\n", "all_logits_idx", "=", "0", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "minibatches", ")", ":", "\n", "            ", "logits", "=", "all_logits", "[", "all_logits_idx", ":", "all_logits_idx", "+", "x", ".", "shape", "[", "0", "]", "]", "\n", "all_logits_idx", "+=", "x", ".", "shape", "[", "0", "]", "\n", "loss_", "=", "F", ".", "cross_entropy", "(", "logits", ",", "y", ")", "\n", "nll", "+=", "loss_", "\n", "penalty", "+=", "self", ".", "_irm_penalty", "(", "logits", ",", "y", ")", "\n", "\n", "", "nll", "/=", "len", "(", "minibatches", ")", "\n", "penalty", "/=", "len", "(", "minibatches", ")", "\n", "loss", "=", "nll", "+", "(", "penalty_weight", "*", "penalty", ")", "\n", "if", "self", ".", "update_count", "==", "self", ".", "hparams", "[", "'irm_penalty_anneal_iters'", "]", "and", "self", ".", "hparams", "[", "'opt'", "]", "==", "'Adam'", "and", "self", ".", "hparams", "[", "'irm_lambda'", "]", "!=", "1", ":", "\n", "            ", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n", "self", ".", "update_count", "+=", "1", "\n", "return", "{", "'loss'", ":", "loss", ".", "item", "(", ")", ",", "'nll'", ":", "nll", ".", "item", "(", ")", ",", "\n", "'penalty'", ":", "penalty", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.VREx.__init__": [[500, 505], ["algorithms.ERM.__init__", "algorithms.VREx.register_buffer", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "VREx", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "register_buffer", "(", "'update_count'", ",", "torch", ".", "tensor", "(", "[", "0", "]", ")", ")", "\n", "self", ".", "scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "self", ".", "optimizer", ",", "step_size", "=", "self", ".", "hparams", "[", "'sch_size'", "]", ",", "gamma", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.VREx.update": [[506, 543], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.VREx.network", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "enumerate", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "torch.zeros.mean", "algorithms.VREx.optimizer.zero_grad", "loss.backward", "algorithms.VREx.optimizer.step", "algorithms.VREx.scheduler.step", "len", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "loss.item", "torch.cross_entropy.item", "penalty.item", "algorithms.VREx.network.parameters"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "        ", "if", "self", ".", "update_count", ">=", "self", ".", "hparams", "[", "\"vrex_penalty_anneal_iters\"", "]", ":", "\n", "            ", "penalty_weight", "=", "self", ".", "hparams", "[", "\"vrex_lambda\"", "]", "\n", "", "else", ":", "\n", "            ", "penalty_weight", "=", "0.", "\n", "\n", "", "nll", "=", "0.", "\n", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_logits", "=", "self", ".", "network", "(", "all_x", ")", "\n", "all_logits_idx", "=", "0", "\n", "losses", "=", "torch", ".", "zeros", "(", "len", "(", "minibatches", ")", ")", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "minibatches", ")", ":", "\n", "            ", "logits", "=", "all_logits", "[", "all_logits_idx", ":", "all_logits_idx", "+", "x", ".", "shape", "[", "0", "]", "]", "\n", "all_logits_idx", "+=", "x", ".", "shape", "[", "0", "]", "\n", "nll", "=", "F", ".", "cross_entropy", "(", "logits", ",", "y", ")", "\n", "losses", "[", "i", "]", "=", "nll", "\n", "\n", "", "mean", "=", "losses", ".", "mean", "(", ")", "\n", "penalty", "=", "(", "(", "losses", "-", "mean", ")", "**", "2", ")", ".", "mean", "(", ")", "\n", "loss", "=", "(", "mean", "+", "penalty_weight", "*", "penalty", ")", "\n", "\n", "if", "self", ".", "update_count", "==", "self", ".", "hparams", "[", "'vrex_penalty_anneal_iters'", "]", "and", "self", ".", "hparams", "[", "'opt'", "]", "==", "'Adam'", ":", "\n", "# Reset Adam (like IRM), because it doesn't like the sharp jump in", "\n", "# gradient magnitudes that happens at this step.", "\n", "            ", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", ")", "\n", "\n", "", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "self", ".", "update_count", "+=", "1", "\n", "return", "{", "'loss'", ":", "loss", ".", "item", "(", ")", ",", "'nll'", ":", "nll", ".", "item", "(", ")", ",", "\n", "'penalty'", ":", "penalty", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.GroupDRO.__init__": [[551, 555], ["algorithms.ERM.__init__", "algorithms.GroupDRO.register_buffer", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "GroupDRO", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "register_buffer", "(", "\"q\"", ",", "torch", ".", "Tensor", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.GroupDRO.update": [[556, 581], ["torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "torch.zeros().to", "range", "algorithms.GroupDRO.q.sum", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "torch.dot", "algorithms.GroupDRO.optimizer.zero_grad", "torch.dot.backward", "torch.dot.backward", "torch.dot.backward", "torch.dot.backward", "torch.dot.backward", "algorithms.GroupDRO.optimizer.step", "algorithms.GroupDRO.scheduler.step", "len", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "torch.ones().to", "len", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.dot.item", "torch.dot.item", "torch.dot.item", "torch.dot.item", "torch.dot.item", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "algorithms.GroupDRO.predict", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.predict", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "        ", "device", "=", "\"cuda\"", "if", "minibatches", "[", "0", "]", "[", "0", "]", ".", "is_cuda", "else", "\"cpu\"", "\n", "\n", "if", "not", "len", "(", "self", ".", "q", ")", ":", "\n", "            ", "self", ".", "q", "=", "torch", ".", "ones", "(", "len", "(", "minibatches", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "", "losses", "=", "torch", ".", "zeros", "(", "len", "(", "minibatches", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "for", "m", "in", "range", "(", "len", "(", "minibatches", ")", ")", ":", "\n", "            ", "x", ",", "y", "=", "minibatches", "[", "m", "]", "\n", "losses", "[", "m", "]", "=", "F", ".", "cross_entropy", "(", "self", ".", "predict", "(", "x", ")", ",", "y", ")", "\n", "self", ".", "q", "[", "m", "]", "*=", "(", "self", ".", "hparams", "[", "\"groupdro_eta\"", "]", "*", "losses", "[", "m", "]", ".", "data", ")", ".", "exp", "(", ")", "\n", "\n", "", "self", ".", "q", "/=", "self", ".", "q", ".", "sum", "(", ")", "\n", "\n", "# print(losses)", "\n", "loss", "=", "torch", ".", "dot", "(", "losses", ",", "self", ".", "q", ")", "\n", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "\n", "return", "{", "'loss'", ":", "loss", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.MLDG.__init__": [[589, 593], ["algorithms.ERM.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "MLDG", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "update_count", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.MLDG.update": [[594, 687], ["len", "algorithms.MLDG.optimizer.zero_grad", "algorithms.MLDG.network.parameters", "domainbed.lib.misc.random_pairs_of_minibatches", "len", "algorithms.MLDG.optimizer.step", "algorithms.MLDG.scheduler.step", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.MLDG.optimizer.zero_grad", "torch.cross_entropy.backward", "algorithms.MLDG.optimizer.step", "algorithms.MLDG.scheduler.step", "copy.deepcopy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.optim.SGD.zero_grad", "torch.optim.SGD.zero_grad", "torch.optim.SGD.zero_grad", "torch.optim.SGD.zero_grad", "torch.optim.SGD.zero_grad", "torch.cross_entropy.backward", "torch.optim.SGD.step", "torch.optim.SGD.step", "torch.optim.SGD.step", "torch.optim.SGD.step", "torch.optim.SGD.step", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "zip", "torch.cross_entropy.item", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "zip", "algorithms.MLDG.network", "torch.cross_entropy.item", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.zeros_like", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "copy.deepcopy.", "algorithms.MLDG.network", "algorithms.MLDG.network.parameters", "copy.deepcopy.parameters", "copy.deepcopy.", "copy.deepcopy.parameters", "algorithms.MLDG.network.parameters", "copy.deepcopy.parameters", "copy.deepcopy.parameters", "p_tgt.grad.data.add_", "p.grad.data.add_"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.random_pairs_of_minibatches", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "update", "(", "self", ",", "minibatches", ",", "unlabeled", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Terms being computed:\n            * Li = Loss(xi, yi, params)\n            * Gi = Grad(Li, params)\n            * Lj = Loss(xj, yj, Optimizer(params, grad(Li, params)))\n            * Gj = Grad(Lj, params)\n            * params = Optimizer(params, Grad(Li + beta * Lj, params))\n            *        = Optimizer(params, Gi + beta * Gj)\n        That is, when calling .step(), we want grads to be Gi + beta * Gj\n        For computational efficiency, we do not compute second derivatives.\n        \"\"\"", "\n", "if", "self", ".", "update_count", "<", "self", ".", "hparams", "[", "'iters'", "]", ":", "\n", "            ", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_y", "=", "torch", ".", "cat", "(", "[", "y", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "# updating original network", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "self", ".", "network", "(", "all_x", ")", ",", "all_y", ")", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "self", ".", "update_count", "+=", "1", "\n", "return", "{", "'loss'", ":", "loss", ".", "item", "(", ")", "}", "\n", "\n", "\n", "", "num_mb", "=", "len", "(", "minibatches", ")", "\n", "objective", "=", "0", "\n", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "for", "p", "in", "self", ".", "network", ".", "parameters", "(", ")", ":", "\n", "            ", "if", "p", ".", "grad", "is", "None", ":", "\n", "                ", "p", ".", "grad", "=", "torch", ".", "zeros_like", "(", "p", ")", "\n", "\n", "", "", "for", "(", "xi", ",", "yi", ")", ",", "(", "xj", ",", "yj", ")", "in", "random_pairs_of_minibatches", "(", "minibatches", ")", ":", "\n", "# fine tune clone-network on task \"i\"", "\n", "\n", "            ", "inner_net", "=", "copy", ".", "deepcopy", "(", "self", ".", "network", ")", "\n", "if", "self", ".", "hparams", "[", "\"opt\"", "]", "==", "'Adam'", ":", "\n", "                ", "inner_opt", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "inner_net", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "else", ":", "\n", "                ", "inner_opt", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "inner_net", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "\n", "# updating original network", "\n", "", "inner_obj", "=", "F", ".", "cross_entropy", "(", "inner_net", "(", "xi", ")", ",", "yi", ")", "\n", "inner_opt", ".", "zero_grad", "(", ")", "\n", "inner_obj", ".", "backward", "(", ")", "\n", "inner_opt", ".", "step", "(", ")", "\n", "\n", "# update bn", "\n", "F", ".", "cross_entropy", "(", "self", ".", "network", "(", "xi", ")", ",", "yi", ")", "\n", "# The network has now accumulated gradients Gi", "\n", "# The clone-network has now parameters P - lr * Gi", "\n", "for", "p_tgt", ",", "p_src", "in", "zip", "(", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "inner_net", ".", "parameters", "(", ")", ")", ":", "\n", "                ", "if", "p_src", ".", "grad", "is", "not", "None", ":", "\n", "                    ", "p_tgt", ".", "grad", ".", "data", ".", "add_", "(", "p_src", ".", "grad", ".", "data", "/", "num_mb", ")", "\n", "\n", "# `objective` is populated for reporting purposes", "\n", "", "", "objective", "+=", "inner_obj", ".", "item", "(", ")", "\n", "# self.optimizer.load_state_dict(inner_opt.state_dict())", "\n", "# # this computes Gj on the clone-network", "\n", "loss_inner_j", "=", "F", ".", "cross_entropy", "(", "inner_net", "(", "xj", ")", ",", "yj", ")", "\n", "grad_inner_j", "=", "autograd", ".", "grad", "(", "loss_inner_j", ",", "inner_net", ".", "parameters", "(", ")", ",", "\n", "allow_unused", "=", "True", ")", "\n", "\n", "# `objective` is populated for reporting purposes", "\n", "objective", "+=", "(", "self", ".", "hparams", "[", "'mldg_beta'", "]", "*", "loss_inner_j", ")", ".", "item", "(", ")", "\n", "\n", "for", "p", ",", "g_j", "in", "zip", "(", "self", ".", "network", ".", "parameters", "(", ")", ",", "grad_inner_j", ")", ":", "\n", "                ", "if", "g_j", "is", "not", "None", ":", "\n", "                    ", "p", ".", "grad", ".", "data", ".", "add_", "(", "\n", "self", ".", "hparams", "[", "'mldg_beta'", "]", "*", "g_j", ".", "data", "/", "num_mb", ")", "\n", "\n", "# The network has now accumulated gradients Gi + beta * Gj", "\n", "# Repeat for all train-test splits, do .step()", "\n", "\n", "", "", "", "objective", "/=", "len", "(", "minibatches", ")", "\n", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler", ".", "step", "(", ")", "\n", "self", ".", "update_count", "+=", "1", "\n", "return", "{", "'loss'", ":", "objective", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.WholeFish.__init__": [[690, 699], ["torch.Module.__init__", "domainbed.networks.Featurizer", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "algorithms.WholeFish.load_state_dict", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Featurizer"], ["    ", "def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "hparams", ",", "weights", "=", "None", ")", ":", "\n", "        ", "super", "(", "WholeFish", ",", "self", ")", ".", "__init__", "(", ")", "\n", "featurizer", "=", "networks", ".", "Featurizer", "(", "input_shape", ",", "hparams", ")", "\n", "classifier", "=", "nn", ".", "Linear", "(", "featurizer", ".", "n_outputs", ",", "num_classes", ")", "\n", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "\n", "featurizer", ",", "classifier", "\n", ")", "\n", "if", "weights", "is", "not", "None", ":", "\n", "            ", "self", ".", "load_state_dict", "(", "copy", ".", "deepcopy", "(", "weights", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.WholeFish.reset_weights": [[700, 702], ["algorithms.WholeFish.load_state_dict", "copy.deepcopy"], "methods", ["None"], ["", "", "def", "reset_weights", "(", "self", ",", "weights", ")", ":", "\n", "        ", "self", ".", "load_state_dict", "(", "copy", ".", "deepcopy", "(", "weights", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.WholeFish.forward": [[703, 705], ["algorithms.WholeFish.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "net", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.__init__": [[712, 733], ["algorithms.Algorithm.__init__", "algorithms.WholeFish", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "algorithms.Fish.network.parameters", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "algorithms.Fish.network.parameters"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "Fish", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n", "self", ".", "network", "=", "WholeFish", "(", "input_shape", ",", "num_classes", ",", "hparams", ")", "\n", "self", ".", "optimizer_inner_state", "=", "None", "\n", "self", ".", "step", "=", "0", "\n", "if", "self", ".", "hparams", "[", "'opt'", "]", "==", "'SGD'", ":", "\n", "            ", "self", ".", "optimizer_inner", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "elif", "self", ".", "hparams", "[", "'opt'", "]", "==", "'Adam'", ":", "\n", "            ", "self", ".", "optimizer_inner", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "network", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.create_clone": [[734, 759], ["WholeFish().to", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "algorithms.Fish.optimizer_inner.load_state_dict", "algorithms.WholeFish", "algorithms.Fish.network_inner.parameters", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "algorithms.Fish.network_inner.parameters", "algorithms.Fish.network.state_dict"], "methods", ["None"], ["", "", "def", "create_clone", "(", "self", ",", "device", ")", ":", "\n", "        ", "self", ".", "network_inner", "=", "WholeFish", "(", "self", ".", "input_shape", ",", "self", ".", "num_classes", ",", "self", ".", "hparams", ",", "\n", "weights", "=", "self", ".", "network", ".", "state_dict", "(", ")", ")", ".", "to", "(", "device", ")", "\n", "\n", "if", "self", ".", "step", ">", "0", "and", "self", ".", "step", "%", "self", ".", "hparams", "[", "'sch_size'", "]", "==", "0", ":", "\n", "            ", "self", ".", "hparams", "[", "\"lr\"", "]", "*=", "0.1", "\n", "\n", "", "if", "self", ".", "hparams", "[", "'opt'", "]", "==", "'SGD'", ":", "\n", "            ", "self", ".", "optimizer_inner", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "network_inner", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "elif", "self", ".", "hparams", "[", "'opt'", "]", "==", "'Adam'", ":", "\n", "            ", "self", ".", "optimizer_inner", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "network_inner", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "if", "self", ".", "optimizer_inner_state", "is", "not", "None", ":", "\n", "            ", "self", ".", "optimizer_inner", ".", "load_state_dict", "(", "self", ".", "optimizer_inner_state", ")", "\n", "\n", "", "for", "param_group", "in", "self", ".", "optimizer_inner", ".", "param_groups", ":", "\n", "            ", "param_group", "[", "'lr'", "]", "=", "self", ".", "hparams", "[", "\"lr\"", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.fish": [[760, 765], ["domainbed.lib.misc.ParamDict", "domainbed.lib.misc.ParamDict"], "methods", ["None"], ["", "", "def", "fish", "(", "self", ",", "meta_weights", ",", "inner_weights", ",", "lr_meta", ")", ":", "\n", "        ", "meta_weights", "=", "ParamDict", "(", "meta_weights", ")", "\n", "inner_weights", "=", "ParamDict", "(", "inner_weights", ")", "\n", "meta_weights", "+=", "lr_meta", "*", "(", "inner_weights", "-", "meta_weights", ")", "\n", "return", "meta_weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.update": [[766, 784], ["algorithms.Fish.create_clone", "algorithms.Fish.optimizer_inner.state_dict", "algorithms.Fish.fish", "algorithms.Fish.network.reset_weights", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.Fish.optimizer_inner.zero_grad", "torch.cross_entropy.backward", "algorithms.Fish.optimizer_inner.step", "torch.cross_entropy.item", "algorithms.Fish.network_inner", "algorithms.Fish.network.state_dict", "algorithms.Fish.network_inner.state_dict"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.create_clone", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.fish", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.WholeFish.reset_weights"], ["", "def", "update", "(", "self", ",", "minibatches", ",", "unlabeled", "=", "None", ")", ":", "\n", "\n", "        ", "self", ".", "create_clone", "(", "minibatches", "[", "0", "]", "[", "0", "]", ".", "device", ")", "\n", "for", "x", ",", "y", "in", "minibatches", ":", "\n", "            ", "loss", "=", "F", ".", "cross_entropy", "(", "self", ".", "network_inner", "(", "x", ")", ",", "y", ")", "\n", "self", ".", "optimizer_inner", ".", "zero_grad", "(", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_inner", ".", "step", "(", ")", "\n", "\n", "", "self", ".", "optimizer_inner_state", "=", "self", ".", "optimizer_inner", ".", "state_dict", "(", ")", "\n", "meta_weights", "=", "self", ".", "fish", "(", "\n", "meta_weights", "=", "self", ".", "network", ".", "state_dict", "(", ")", ",", "\n", "inner_weights", "=", "self", ".", "network_inner", ".", "state_dict", "(", ")", ",", "\n", "lr_meta", "=", "self", ".", "hparams", "[", "\"meta_lr\"", "]", "\n", ")", "\n", "self", ".", "network", ".", "reset_weights", "(", "meta_weights", ")", "\n", "self", ".", "step", "+=", "1", "\n", "return", "{", "'loss'", ":", "loss", ".", "item", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.Fish.predict": [[785, 787], ["algorithms.Fish.network"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "network", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.__init__": [[794, 835], ["algorithms.Algorithm.__init__", "algorithms.TRM.register_buffer", "domainbed.networks.Featurizer", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.Linear().cuda", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.ones().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.eye().cuda", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "range", "algorithms.TRM.clist[].parameters", "range", "algorithms.TRM.featurizer.parameters", "algorithms.TRM.classifier.parameters", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "algorithms.TRM.featurizer.parameters", "algorithms.TRM.classifier.parameters", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye", "torch.eye"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.networks.Featurizer"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "num_classes", ",", "num_domains", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "TRM", ",", "self", ")", ".", "__init__", "(", "input_shape", ",", "num_classes", ",", "num_domains", ",", "\n", "hparams", ")", "\n", "self", ".", "register_buffer", "(", "'update_count'", ",", "torch", ".", "tensor", "(", "[", "0", "]", ")", ")", "\n", "self", ".", "num_domains", "=", "num_domains", "\n", "self", ".", "featurizer", "=", "networks", ".", "Featurizer", "(", "input_shape", ",", "self", ".", "hparams", ")", "\n", "self", ".", "classifier", "=", "nn", ".", "Linear", "(", "self", ".", "featurizer", ".", "n_outputs", ",", "num_classes", ")", ".", "cuda", "(", ")", "\n", "self", ".", "clist", "=", "[", "nn", ".", "Linear", "(", "self", ".", "featurizer", ".", "n_outputs", ",", "num_classes", ")", ".", "cuda", "(", ")", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "self", ".", "olist", "=", "[", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "clist", "[", "i", "]", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "1e-1", ",", "\n", ")", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "\n", "if", "self", ".", "hparams", "[", "'opt'", "]", "==", "'SGD'", ":", "\n", "            ", "self", ".", "optimizer_f", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "featurizer", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "self", ".", "optimizer_c", "=", "torch", ".", "optim", ".", "SGD", "(", "\n", "self", ".", "classifier", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "momentum", "=", "0.9", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "elif", "self", ".", "hparams", "[", "'opt'", "]", "==", "'Adam'", ":", "\n", "            ", "self", ".", "optimizer_f", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "featurizer", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "self", ".", "optimizer_c", "=", "torch", ".", "optim", ".", "Adam", "(", "\n", "self", ".", "classifier", ".", "parameters", "(", ")", ",", "\n", "lr", "=", "self", ".", "hparams", "[", "\"lr\"", "]", ",", "\n", "weight_decay", "=", "self", ".", "hparams", "[", "'weight_decay'", "]", "\n", ")", "\n", "", "self", ".", "scheduler_f", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "self", ".", "optimizer_f", ",", "step_size", "=", "self", ".", "hparams", "[", "'sch_size'", "]", ",", "gamma", "=", "0.1", ")", "\n", "self", ".", "scheduler_c", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "self", ".", "optimizer_c", ",", "step_size", "=", "self", ".", "hparams", "[", "'sch_size'", "]", ",", "gamma", "=", "0.1", ")", "\n", "# initial weights", "\n", "self", ".", "alpha", "=", "torch", ".", "ones", "(", "(", "num_domains", ",", "num_domains", ")", ")", ".", "cuda", "(", ")", "-", "torch", ".", "eye", "(", "num_domains", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.update": [[837, 932], ["torch.cross_entropy.item", "algorithms.TRM.optimizer_c.zero_grad", "algorithms.TRM.optimizer_f.zero_grad", "loss_swap.backward", "algorithms.TRM.optimizer_f.step", "algorithms.TRM.optimizer_c.step", "algorithms.TRM.scheduler_f.step", "algorithms.TRM.scheduler_c.step", "algorithms.TRM.alpha.sum", "algorithms.TRM.featurizer.train", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.TRM.featurizer", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "range", "list", "list", "enumerate", "enumerate", "len", "len", "algorithms.TRM.featurizer.train", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "algorithms.TRM.featurizer", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "loss_swap.item", "copy.deepcopy", "algorithms.TRM.classifier", "enumerate", "loss_erm.backward", "list.append", "list.append", "list", "list.remove", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "sum", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.grad", "torch.utils.parameters_to_vector().detach", "torch.utils.parameters_to_vector().detach", "torch.utils.parameters_to_vector().detach", "torch.utils.parameters_to_vector().detach", "torch.utils.parameters_to_vector().detach", "domainbed.inv_hvp.neum", "algorithms.TRM.classifier", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "opt.zero_grad", "opt.step", "range", "len", "range", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "torch.utils.parameters_to_vector", "feature.detach", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "torch.cross_entropy", "algorithms.TRM.alpha[].data.detach", "len", "domainbed.inv_hvp.neum.detach"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.inv_hvp.neum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "update", "(", "self", ",", "minibatches", ")", ":", "\n", "\n", "        ", "loss_swap", "=", "0.0", "\n", "trm", "=", "0.0", "\n", "# updating featurizer", "\n", "if", "self", ".", "update_count", ">=", "self", ".", "hparams", "[", "'iters'", "]", ":", "\n", "# if self.hparams['class_balanced']:", "\n", "# for stability when facing unbalanced labels across environments", "\n", "            ", "for", "classifier", "in", "self", ".", "clist", ":", "\n", "                ", "classifier", ".", "weight", ".", "data", "=", "copy", ".", "deepcopy", "(", "self", ".", "classifier", ".", "weight", ".", "data", ")", "\n", "", "self", ".", "alpha", "/=", "self", ".", "alpha", ".", "sum", "(", "1", ",", "keepdim", "=", "True", ")", "\n", "self", ".", "featurizer", ".", "train", "(", ")", "\n", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_y", "=", "torch", ".", "cat", "(", "[", "y", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_feature", "=", "self", ".", "featurizer", "(", "all_x", ")", "\n", "# updating original network", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "self", ".", "classifier", "(", "all_feature", ")", ",", "all_y", ")", "\n", "\n", "for", "i", "in", "range", "(", "30", ")", ":", "\n", "                ", "all_logits_idx", "=", "0", "\n", "loss_erm", "=", "0.", "\n", "for", "j", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "minibatches", ")", ":", "\n", "# j-th domain", "\n", "                    ", "feature", "=", "all_feature", "[", "all_logits_idx", ":", "all_logits_idx", "+", "x", ".", "shape", "[", "0", "]", "]", "\n", "all_logits_idx", "+=", "x", ".", "shape", "[", "0", "]", "\n", "loss_erm", "+=", "F", ".", "cross_entropy", "(", "self", ".", "clist", "[", "j", "]", "(", "feature", ".", "detach", "(", ")", ")", ",", "y", ")", "\n", "", "for", "opt", "in", "self", ".", "olist", ":", "\n", "                    ", "opt", ".", "zero_grad", "(", ")", "\n", "", "loss_erm", ".", "backward", "(", ")", "\n", "for", "opt", "in", "self", ".", "olist", ":", "\n", "                    ", "opt", ".", "step", "(", ")", "\n", "\n", "# collect (feature, y)", "\n", "", "", "feature_split", "=", "list", "(", ")", "\n", "y_split", "=", "list", "(", ")", "\n", "all_logits_idx", "=", "0", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "minibatches", ")", ":", "\n", "                ", "feature", "=", "all_feature", "[", "all_logits_idx", ":", "all_logits_idx", "+", "x", ".", "shape", "[", "0", "]", "]", "\n", "all_logits_idx", "+=", "x", ".", "shape", "[", "0", "]", "\n", "feature_split", ".", "append", "(", "feature", ")", "\n", "y_split", ".", "append", "(", "y", ")", "\n", "\n", "# estimate transfer risk", "\n", "", "for", "Q", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "minibatches", ")", ":", "\n", "                ", "sample_list", "=", "list", "(", "range", "(", "len", "(", "minibatches", ")", ")", ")", "\n", "sample_list", ".", "remove", "(", "Q", ")", "\n", "\n", "loss_Q", "=", "F", ".", "cross_entropy", "(", "self", ".", "clist", "[", "Q", "]", "(", "feature_split", "[", "Q", "]", ")", ",", "y_split", "[", "Q", "]", ")", "\n", "grad_Q", "=", "autograd", ".", "grad", "(", "loss_Q", ",", "self", ".", "clist", "[", "Q", "]", ".", "weight", ",", "create_graph", "=", "True", ")", "\n", "vec_grad_Q", "=", "nn", ".", "utils", ".", "parameters_to_vector", "(", "grad_Q", ")", "\n", "\n", "loss_P", "=", "[", "F", ".", "cross_entropy", "(", "self", ".", "clist", "[", "Q", "]", "(", "feature_split", "[", "i", "]", ")", ",", "y_split", "[", "i", "]", ")", "*", "(", "self", ".", "alpha", "[", "Q", ",", "i", "]", ".", "data", ".", "detach", "(", ")", ")", "\n", "if", "i", "in", "sample_list", "else", "0.", "for", "i", "in", "range", "(", "len", "(", "minibatches", ")", ")", "]", "\n", "loss_P_sum", "=", "sum", "(", "loss_P", ")", "\n", "grad_P", "=", "autograd", ".", "grad", "(", "loss_P_sum", ",", "self", ".", "clist", "[", "Q", "]", ".", "weight", ",", "create_graph", "=", "True", ")", "\n", "vec_grad_P", "=", "nn", ".", "utils", ".", "parameters_to_vector", "(", "grad_P", ")", ".", "detach", "(", ")", "\n", "vec_grad_P", "=", "neum", "(", "vec_grad_P", ",", "self", ".", "clist", "[", "Q", "]", ",", "(", "feature_split", "[", "Q", "]", ",", "y_split", "[", "Q", "]", ")", ")", "\n", "\n", "loss_swap", "+=", "loss_P_sum", "-", "self", ".", "hparams", "[", "'cos_lambda'", "]", "*", "(", "vec_grad_P", ".", "detach", "(", ")", "@", "vec_grad_Q", ")", "\n", "\n", "for", "i", "in", "sample_list", ":", "\n", "                    ", "self", ".", "alpha", "[", "Q", ",", "i", "]", "*=", "(", "self", ".", "hparams", "[", "\"groupdro_eta\"", "]", "*", "loss_P", "[", "i", "]", ".", "data", ")", ".", "exp", "(", ")", "\n", "\n", "", "", "loss_swap", "/=", "len", "(", "minibatches", ")", "\n", "# print(loss_swap, self.hparams['cos_lambda'] * (vec_grad_P.detach() @ vec_grad_Q))", "\n", "trm", "/=", "len", "(", "minibatches", ")", "\n", "", "else", ":", "\n", "# ERM", "\n", "            ", "self", ".", "featurizer", ".", "train", "(", ")", "\n", "all_x", "=", "torch", ".", "cat", "(", "[", "x", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_y", "=", "torch", ".", "cat", "(", "[", "y", "for", "x", ",", "y", "in", "minibatches", "]", ")", "\n", "all_feature", "=", "self", ".", "featurizer", "(", "all_x", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "self", ".", "classifier", "(", "all_feature", ")", ",", "all_y", ")", "\n", "\n", "", "nll", "=", "loss", ".", "item", "(", ")", "\n", "self", ".", "optimizer_c", ".", "zero_grad", "(", ")", "\n", "self", ".", "optimizer_f", ".", "zero_grad", "(", ")", "\n", "#if self.update_count >= self.hparams['iters']:", "\n", "if", "self", ".", "update_count", ">=", "300", ":", "\n", "            ", "loss_swap", "=", "(", "loss", "+", "loss_swap", ")", "\n", "", "else", ":", "\n", "            ", "loss_swap", "=", "loss", "\n", "\n", "", "loss_swap", ".", "backward", "(", ")", "\n", "self", ".", "optimizer_f", ".", "step", "(", ")", "\n", "self", ".", "optimizer_c", ".", "step", "(", ")", "\n", "\n", "# updating scheduler (only for SceneCOCO and C-MNIST)", "\n", "self", ".", "scheduler_f", ".", "step", "(", ")", "\n", "self", ".", "scheduler_c", ".", "step", "(", ")", "\n", "\n", "loss_swap", "=", "loss_swap", ".", "item", "(", ")", "-", "nll", "\n", "self", ".", "update_count", "+=", "1", "\n", "\n", "return", "{", "'nll'", ":", "nll", ",", "'trm_loss'", ":", "loss_swap", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.predict": [[933, 935], ["algorithms.TRM.classifier", "algorithms.TRM.featurizer"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "classifier", "(", "self", ".", "featurizer", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train": [[936, 938], ["algorithms.TRM.featurizer.train"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "self", ".", "featurizer", ".", "train", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval": [[939, 941], ["algorithms.TRM.featurizer.eval"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "self", ".", "featurizer", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.get_algorithm_class": [[41, 46], ["globals", "NotImplementedError", "globals"], "function", ["None"], ["def", "get_algorithm_class", "(", "algorithm_name", ")", ":", "\n", "    ", "\"\"\"Return the algorithm class with the given name.\"\"\"", "\n", "if", "algorithm_name", "not", "in", "globals", "(", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Algorithm not found: {}\"", ".", "format", "(", "algorithm_name", ")", ")", "\n", "", "return", "globals", "(", ")", "[", "algorithm_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.Dataset.__getitem__": [[19, 21], ["None"], "methods", ["None"], ["def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.Dataset.__add__": [[22, 24], ["ConcatDataset"], "methods", ["None"], ["", "def", "__add__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "ConcatDataset", "(", "[", "self", ",", "other", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.TensorDataset.__init__": [[40, 50], ["all", "torchvision.transforms.Compose", "tensors[].size", "tensor.size", "torchvision.transforms.ToPILImage", "torchvision.transforms.RandomResizedCrop", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.ToTensor"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "test", ",", "*", "tensors", ")", ":", "\n", "        ", "assert", "all", "(", "tensors", "[", "0", "]", ".", "size", "(", "0", ")", "==", "tensor", ".", "size", "(", "0", ")", "for", "tensor", "in", "tensors", ")", "\n", "self", ".", "tensors", "=", "tensors", "\n", "self", ".", "test", "=", "test", "\n", "if", "not", "test", ":", "\n", "            ", "self", ".", "augment_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToPILImage", "(", ")", ",", "\n", "transforms", ".", "RandomResizedCrop", "(", "64", ",", "scale", "=", "(", "0.7", ",", "1.0", ")", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "]", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.TensorDataset.__getitem__": [[52, 59], ["utils.TensorDataset.augment_transform"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "if", "not", "self", ".", "test", ":", "\n", "            ", "img", "=", "self", ".", "augment_transform", "(", "self", ".", "tensors", "[", "0", "]", "[", "index", "]", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "self", ".", "tensors", "[", "0", "]", "[", "index", "]", "\n", "", "label", "=", "self", ".", "tensors", "[", "1", "]", "[", "index", "]", "\n", "return", "img", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.TensorDataset.__len__": [[60, 62], ["utils.TensorDataset.tensors[].size"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tensors", "[", "0", "]", ".", "size", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.make_grid": [[68, 145], ["isinstance", "torch.cat.size", "min", "int", "torch.cat.new().fill_", "irange", "TypeError", "torch.stack", "torch.cat.dim", "torch.cat.view", "torch.cat.dim", "torch.cat", "torch.cat.clone", "math.ceil", "int", "int", "irange", "torch.is_tensor", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat", "torch.cat.dim", "torch.cat.size", "isinstance", "img.clamp_", "img.add_().div_", "utils.make_grid.norm_range"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min"], ["def", "make_grid", "(", "tensor", ",", "nrow", "=", "8", ",", "padding", "=", "2", ",", "\n", "normalize", "=", "False", ",", "range", "=", "None", ",", "scale_each", "=", "False", ",", "pad_value", "=", "0", ")", ":", "\n", "    ", "\"\"\"Make a grid of images.\n    Args:\n        tensor (Tensor or list): 4D mini-batch Tensor of shape (B x C x H x W)\n            or a list of images all of the same size.\n        nrow (int, optional): Number of images displayed in each row of the grid.\n            The Final grid size is (B / nrow, nrow). Default is 8.\n        padding (int, optional): amount of padding. Default is 2.\n        normalize (bool, optional): If True, shift the image to the range (0, 1),\n            by subtracting the minimum and dividing by the maximum pixel value.\n        range (tuple, optional): tuple (min, max) where min and max are numbers,\n            then these numbers are used to normalize the image. By default, min and max\n            are computed from the tensor.\n        scale_each (bool, optional): If True, scale each image in the batch of\n            images separately rather than the (min, max) over all images.\n        pad_value (float, optional): Value for the padded pixels.\n\n    Example:\n        See this notebook `here <https://gist.github.com/anonymous/bf16430f7750c023141c562f3e9f2a91>`_\n\n    \"\"\"", "\n", "if", "not", "(", "torch", ".", "is_tensor", "(", "tensor", ")", "or", "\n", "(", "isinstance", "(", "tensor", ",", "list", ")", "and", "all", "(", "torch", ".", "is_tensor", "(", "t", ")", "for", "t", "in", "tensor", ")", ")", ")", ":", "\n", "        ", "raise", "TypeError", "(", "'tensor or list of tensors expected, got {}'", ".", "format", "(", "type", "(", "tensor", ")", ")", ")", "\n", "\n", "# if list of tensors, convert to a 4D mini-batch Tensor", "\n", "", "if", "isinstance", "(", "tensor", ",", "list", ")", ":", "\n", "        ", "tensor", "=", "torch", ".", "stack", "(", "tensor", ",", "dim", "=", "0", ")", "\n", "\n", "", "if", "tensor", ".", "dim", "(", ")", "==", "2", ":", "# single image H x W", "\n", "        ", "tensor", "=", "tensor", ".", "view", "(", "1", ",", "tensor", ".", "size", "(", "0", ")", ",", "tensor", ".", "size", "(", "1", ")", ")", "\n", "", "if", "tensor", ".", "dim", "(", ")", "==", "3", ":", "# single image", "\n", "        ", "if", "tensor", ".", "size", "(", "0", ")", "==", "1", ":", "# if single-channel, convert to 3-channel", "\n", "            ", "tensor", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "tensor", ",", "tensor", ")", ",", "0", ")", "\n", "", "return", "tensor", "\n", "", "if", "tensor", ".", "dim", "(", ")", "==", "4", "and", "tensor", ".", "size", "(", "1", ")", "==", "1", ":", "# single-channel images", "\n", "        ", "tensor", "=", "torch", ".", "cat", "(", "(", "tensor", ",", "tensor", ",", "tensor", ")", ",", "1", ")", "\n", "\n", "", "if", "normalize", "is", "True", ":", "\n", "        ", "tensor", "=", "tensor", ".", "clone", "(", ")", "# avoid modifying tensor in-place", "\n", "if", "range", "is", "not", "None", ":", "\n", "            ", "assert", "isinstance", "(", "range", ",", "tuple", ")", ",", "\"range has to be a tuple (min, max) if specified. min and max are numbers\"", "\n", "\n", "", "def", "norm_ip", "(", "img", ",", "min", ",", "max", ")", ":", "\n", "            ", "img", ".", "clamp_", "(", "min", "=", "min", ",", "max", "=", "max", ")", "\n", "img", ".", "add_", "(", "-", "min", ")", ".", "div_", "(", "max", "-", "min", ")", "\n", "\n", "", "def", "norm_range", "(", "t", ",", "range", ")", ":", "\n", "            ", "if", "range", "is", "not", "None", ":", "\n", "                ", "norm_ip", "(", "t", ",", "range", "[", "0", "]", ",", "range", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "                ", "norm_ip", "(", "t", ",", "t", ".", "min", "(", ")", ",", "t", ".", "max", "(", ")", ")", "\n", "\n", "", "", "if", "scale_each", "is", "True", ":", "\n", "            ", "for", "t", "in", "tensor", ":", "# loop over mini-batch dimension", "\n", "                ", "norm_range", "(", "t", ",", "range", ")", "\n", "", "", "else", ":", "\n", "            ", "norm_range", "(", "tensor", ",", "range", ")", "\n", "\n", "# make the mini-batch of images into a grid", "\n", "", "", "nmaps", "=", "tensor", ".", "size", "(", "0", ")", "\n", "xmaps", "=", "min", "(", "nrow", ",", "nmaps", ")", "\n", "ymaps", "=", "int", "(", "math", ".", "ceil", "(", "float", "(", "nmaps", ")", "/", "xmaps", ")", ")", "\n", "height", ",", "width", "=", "int", "(", "tensor", ".", "size", "(", "2", ")", "+", "padding", ")", ",", "int", "(", "tensor", ".", "size", "(", "3", ")", "+", "padding", ")", "\n", "grid", "=", "tensor", ".", "new", "(", "3", ",", "height", "*", "ymaps", "+", "padding", ",", "width", "*", "xmaps", "+", "padding", ")", ".", "fill_", "(", "pad_value", ")", "\n", "k", "=", "0", "\n", "for", "y", "in", "irange", "(", "ymaps", ")", ":", "\n", "        ", "for", "x", "in", "irange", "(", "xmaps", ")", ":", "\n", "            ", "if", "k", ">=", "nmaps", ":", "\n", "                ", "break", "\n", "", "grid", ".", "narrow", "(", "1", ",", "y", "*", "height", "+", "padding", ",", "height", "-", "padding", ")", ".", "narrow", "(", "2", ",", "x", "*", "width", "+", "padding", ",", "width", "-", "padding", ")", ".", "copy_", "(", "tensor", "[", "k", "]", ")", "\n", "k", "=", "k", "+", "1", "\n", "", "", "return", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.save_image": [[147, 163], ["tensor.cpu.cpu", "utils.make_grid", "make_grid.mul().clamp().byte().permute().numpy", "Image.fromarray", "Image.fromarray.save", "make_grid.mul().clamp().byte().permute", "make_grid.mul().clamp().byte", "make_grid.mul().clamp", "make_grid.mul"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.make_grid"], ["", "def", "save_image", "(", "tensor", ",", "filename", ",", "nrow", "=", "8", ",", "padding", "=", "2", ",", "\n", "normalize", "=", "False", ",", "range", "=", "None", ",", "scale_each", "=", "False", ",", "pad_value", "=", "0", ")", ":", "\n", "    ", "\"\"\"Save a given Tensor into an image file.\n\n    Args:\n        tensor (Tensor or list): Image to be saved. If given a mini-batch tensor,\n            saves the tensor as a grid of images by calling ``make_grid``.\n        **kwargs: Other arguments are documented in ``make_grid``.\n    \"\"\"", "\n", "from", "PIL", "import", "Image", "\n", "tensor", "=", "tensor", ".", "cpu", "(", ")", "\n", "grid", "=", "make_grid", "(", "tensor", ",", "nrow", "=", "nrow", ",", "padding", "=", "padding", ",", "pad_value", "=", "pad_value", ",", "\n", "normalize", "=", "normalize", ",", "range", "=", "range", ",", "scale_each", "=", "scale_each", ")", "\n", "ndarr", "=", "grid", ".", "mul", "(", "255", ")", ".", "clamp", "(", "0", ",", "255", ")", ".", "byte", "(", ")", ".", "permute", "(", "1", ",", "2", ",", "0", ")", ".", "numpy", "(", ")", "\n", "im", "=", "Image", ".", "fromarray", "(", "ndarr", ")", "\n", "im", ".", "save", "(", "filename", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple": [[6, 24], ["enumerate", "isinstance", "isinstance", "TypeError", "TypeError", "type", "type"], "function", ["None"], ["def", "_as_tuple", "(", "inp", ",", "arg_name", ",", "fn_name", ")", ":", "\n", "# Ensures that inp is a tuple of Tensors", "\n", "# Returns whether or not the original inp was a tuple and the tupled version of the input", "\n", "    ", "is_inp_tuple", "=", "True", "\n", "if", "not", "isinstance", "(", "inp", ",", "tuple", ")", ":", "\n", "        ", "inp", "=", "(", "inp", ",", ")", "\n", "is_inp_tuple", "=", "False", "\n", "\n", "", "for", "i", ",", "el", "in", "enumerate", "(", "inp", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "el", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "if", "is_inp_tuple", ":", "\n", "                ", "raise", "TypeError", "(", "\"The {} given to {} must be either a Tensor or a tuple of Tensors but the\"", "\n", "\" value at index {} has type {}.\"", ".", "format", "(", "arg_name", ",", "fn_name", ",", "i", ",", "type", "(", "el", ")", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "TypeError", "(", "\"The {} given to {} must be either a Tensor or a tuple of Tensors but the\"", "\n", "\" given {} has type {}.\"", ".", "format", "(", "arg_name", ",", "fn_name", ",", "arg_name", ",", "type", "(", "el", ")", ")", ")", "\n", "\n", "", "", "", "return", "is_inp_tuple", ",", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess": [[25, 41], ["isinstance", "len", "tuple", "grad_fun.vjp", "grad_fun.jvp", "grad_fun.jacobian", "grad_fun.vhp", "grad_fun.hvp"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.vjp", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jvp", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jacobian", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.vhp", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hvp"], ["", "def", "_tuple_postprocess", "(", "res", ",", "to_unpack", ")", ":", "\n", "# Unpacks a potentially nested tuple of Tensors", "\n", "# to_unpack should be a single boolean or a tuple of two booleans.", "\n", "# It is used to:", "\n", "# - invert _as_tuple when res should match the inp given to _as_tuple", "\n", "# - optionally remove nesting of two tuples created by multiple calls to _as_tuple", "\n", "    ", "if", "isinstance", "(", "to_unpack", ",", "tuple", ")", ":", "\n", "        ", "assert", "len", "(", "to_unpack", ")", "==", "2", "\n", "if", "not", "to_unpack", "[", "1", "]", ":", "\n", "            ", "res", "=", "tuple", "(", "el", "[", "0", "]", "for", "el", "in", "res", ")", "\n", "", "if", "not", "to_unpack", "[", "0", "]", ":", "\n", "            ", "res", "=", "res", "[", "0", "]", "\n", "", "", "else", ":", "\n", "        ", "if", "not", "to_unpack", ":", "\n", "            ", "res", "=", "res", "[", "0", "]", "\n", "", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess": [[42, 63], ["tuple", "res.append", "res.append", "res.append", "inp.detach().requires_grad_", "inp.view_as", "inp.clone", "inp.detach"], "function", ["None"], ["", "def", "_grad_preprocess", "(", "inputs", ",", "create_graph", ",", "need_graph", ")", ":", "\n", "# Preprocess the inputs to make sure they require gradient", "\n", "# inputs is a tuple of Tensors to preprocess", "\n", "# create_graph specifies if the user wants gradients to flow back to the Tensors in inputs", "\n", "# need_graph specifies if we internally want gradients to flow back to the Tensors in res", "\n", "# Note that we *always* create a new Tensor object to be able to see the difference between", "\n", "# inputs given as arguments and the same Tensors automatically captured by the user function.", "\n", "# Check this issue for more details on how that can happen: https://github.com/pytorch/pytorch/issues/32576", "\n", "    ", "res", "=", "[", "]", "\n", "for", "inp", "in", "inputs", ":", "\n", "        ", "if", "create_graph", "and", "inp", ".", "requires_grad", ":", "\n", "# Create at least a new Tensor object in a differentiable way", "\n", "            ", "if", "not", "inp", ".", "is_sparse", ":", "\n", "# Use .view_as() to get a shallow copy", "\n", "                ", "res", ".", "append", "(", "inp", ".", "view_as", "(", "inp", ")", ")", "\n", "", "else", ":", "\n", "# We cannot use view for sparse Tensors so we clone", "\n", "                ", "res", ".", "append", "(", "inp", ".", "clone", "(", ")", ")", "\n", "", "", "else", ":", "\n", "            ", "res", ".", "append", "(", "inp", ".", "detach", "(", ")", ".", "requires_grad_", "(", "need_graph", ")", ")", "\n", "", "", "return", "tuple", "(", "res", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess": [[65, 75], ["isinstance", "tuple", "tuple", "grad_fun._grad_postprocess", "inp.detach", "grad_fun.vjp", "grad_fun.jvp", "grad_fun.jacobian", "grad_fun.vhp", "grad_fun.hvp"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.vjp", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jvp", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jacobian", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.vhp", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hvp"], ["", "def", "_grad_postprocess", "(", "inputs", ",", "create_graph", ")", ":", "\n", "# Postprocess the generated Tensors to avoid returning Tensors with history when the user did not", "\n", "# request it.", "\n", "    ", "if", "isinstance", "(", "inputs", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "if", "not", "create_graph", ":", "\n", "            ", "return", "tuple", "(", "inp", ".", "detach", "(", ")", "for", "inp", "in", "inputs", ")", "\n", "", "else", ":", "\n", "            ", "return", "inputs", "\n", "", "", "else", ":", "\n", "        ", "return", "tuple", "(", "_grad_postprocess", "(", "inp", ",", "create_graph", ")", "for", "inp", "in", "inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._validate_v": [[76, 92], ["enumerate", "len", "len", "zip", "RuntimeError", "RuntimeError", "el_v.size", "el_other.size", "RuntimeError", "len", "len", "el_other.size", "el_v.size"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "", "def", "_validate_v", "(", "v", ",", "other", ",", "is_other_tuple", ")", ":", "\n", "# This assumes that other is the correct shape, and v should match", "\n", "# Both are assumed to be tuples of Tensors", "\n", "    ", "if", "len", "(", "other", ")", "!=", "len", "(", "v", ")", ":", "\n", "        ", "if", "is_other_tuple", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"v is a tuple of invalid length: should be {} but got {}.\"", ".", "format", "(", "len", "(", "other", ")", ",", "len", "(", "v", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The given v should contain a single Tensor.\"", ")", "\n", "\n", "", "", "for", "idx", ",", "(", "el_v", ",", "el_other", ")", "in", "enumerate", "(", "zip", "(", "v", ",", "other", ")", ")", ":", "\n", "        ", "if", "el_v", ".", "size", "(", ")", "!=", "el_other", ".", "size", "(", ")", ":", "\n", "            ", "prepend", "=", "\"\"", "\n", "if", "is_other_tuple", ":", "\n", "                ", "prepend", "=", "\"Entry {} in \"", ".", "format", "(", "idx", ")", "\n", "", "raise", "RuntimeError", "(", "\"{}v has invalid size: should be {} but got {}.\"", ".", "format", "(", "\n", "prepend", ",", "el_other", ".", "size", "(", ")", ",", "el_v", ".", "size", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad": [[94, 125], ["enumerate", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError"], "function", ["None"], ["", "", "", "def", "_check_requires_grad", "(", "inputs", ",", "input_type", ",", "strict", ")", ":", "\n", "# Used to make all the necessary checks to raise nice errors in strict mode.", "\n", "    ", "if", "not", "strict", ":", "\n", "        ", "return", "\n", "\n", "", "if", "input_type", "not", "in", "[", "\"outputs\"", ",", "\"grad_inputs\"", ",", "\"jacobian\"", ",", "\"hessian\"", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Invalid input_type to _check_requires_grad\"", ")", "\n", "", "for", "i", ",", "inp", "in", "enumerate", "(", "inputs", ")", ":", "\n", "        ", "if", "inp", "is", "None", ":", "\n", "# This can only be reached for grad_inputs.", "\n", "            ", "raise", "RuntimeError", "(", "\"The output of the user-provided function is independent of input {}.\"", "\n", "\" This is not allowed in strict mode.\"", ".", "format", "(", "i", ")", ")", "\n", "", "if", "not", "inp", ".", "requires_grad", ":", "\n", "            ", "if", "input_type", "==", "\"hessian\"", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"The hessian of the user-provided function with respect to input {}\"", "\n", "\" is independent of the input. This is not allowed in strict mode.\"", "\n", "\" You should ensure that your function is thrice differentiable and that\"", "\n", "\" the hessian depends on the inputs.\"", ".", "format", "(", "i", ")", ")", "\n", "", "elif", "input_type", "==", "\"jacobian\"", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"While computing the hessian, found that the jacobian of the user-provided\"", "\n", "\" function with respect to input {} is independent of the input. This is not\"", "\n", "\" allowed in strict mode. You should ensure that your function is twice\"", "\n", "\" differentiable and that the jacobian depends on the inputs (this would be\"", "\n", "\" violated by a linear function for example).\"", ".", "format", "(", "i", ")", ")", "\n", "", "elif", "input_type", "==", "\"grad_inputs\"", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"The gradient with respect to input {} is independent of the inputs of the\"", "\n", "\" user-provided function. This is not allowed in strict mode.\"", ".", "format", "(", "i", ")", ")", "\n", "", "else", ":", "\n", "                ", "raise", "RuntimeError", "(", "\"Output {} of the user-provided function does not require gradients.\"", "\n", "\" The outputs must be computed in a differentiable manner from the input\"", "\n", "\" when running in strict mode.\"", ".", "format", "(", "i", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad": [[126, 148], ["isinstance", "isinstance", "tuple", "tuple", "zip", "len", "len", "len", "torch.autograd.grad", "len", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "", "", "", "def", "_autograd_grad", "(", "outputs", ",", "inputs", ",", "grad_outputs", "=", "None", ",", "create_graph", "=", "False", ",", "retain_graph", "=", "None", ")", ":", "\n", "# Version of autograd.grad that accepts `None` in outputs and do not compute gradients for them.", "\n", "# This has the extra constraint that inputs has to be a tuple", "\n", "    ", "assert", "isinstance", "(", "outputs", ",", "tuple", ")", "\n", "if", "grad_outputs", "is", "None", ":", "\n", "        ", "grad_outputs", "=", "(", "None", ",", ")", "*", "len", "(", "outputs", ")", "\n", "", "assert", "isinstance", "(", "grad_outputs", ",", "tuple", ")", "\n", "assert", "len", "(", "outputs", ")", "==", "len", "(", "grad_outputs", ")", "\n", "\n", "new_outputs", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "...", "]", "=", "tuple", "(", ")", "\n", "new_grad_outputs", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "...", "]", "=", "tuple", "(", ")", "\n", "for", "out", ",", "grad_out", "in", "zip", "(", "outputs", ",", "grad_outputs", ")", ":", "\n", "        ", "if", "out", "is", "not", "None", "and", "out", ".", "requires_grad", ":", "\n", "            ", "new_outputs", "+=", "(", "out", ",", ")", "\n", "new_grad_outputs", "+=", "(", "grad_out", ",", ")", "\n", "\n", "", "", "if", "len", "(", "new_outputs", ")", "==", "0", ":", "\n", "# No differentiable output, we don't need to call the autograd engine", "\n", "        ", "return", "(", "None", ",", ")", "*", "len", "(", "inputs", ")", "\n", "", "else", ":", "\n", "        ", "return", "torch", ".", "autograd", ".", "grad", "(", "new_outputs", ",", "inputs", ",", "new_grad_outputs", ",", "allow_unused", "=", "True", ",", "\n", "create_graph", "=", "create_graph", ",", "retain_graph", "=", "retain_graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._fill_in_zeros": [[149, 190], ["tuple", "enumerate", "RuntimeError", "torch.zeros_like", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError", "RuntimeError"], "function", ["None"], ["", "", "def", "_fill_in_zeros", "(", "grads", ",", "refs", ",", "strict", ",", "create_graph", ",", "stage", ")", ":", "\n", "# Used to detect None in the grads and depending on the flags, either replace them", "\n", "# with Tensors full of 0s of the appropriate size based on the refs or raise an error.", "\n", "# strict and create graph allow us to detect when it is appropriate to raise an error", "\n", "# stage gives us information of which backward call we consider to give good error message", "\n", "    ", "if", "stage", "not", "in", "[", "\"back\"", ",", "\"back_trick\"", ",", "\"double_back\"", ",", "\"double_back_trick\"", "]", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Invalid stage argument '{}' to _fill_in_zeros\"", ".", "format", "(", "stage", ")", ")", "\n", "\n", "", "res", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "...", "]", "=", "tuple", "(", ")", "\n", "for", "i", ",", "grads_i", "in", "enumerate", "(", "grads", ")", ":", "\n", "        ", "if", "grads_i", "is", "None", ":", "\n", "            ", "if", "strict", ":", "\n", "                ", "if", "stage", "==", "\"back\"", ":", "\n", "                    ", "raise", "RuntimeError", "(", "\"The output of the user-provided function is independent of \"", "\n", "\"input {}. This is not allowed in strict mode.\"", ".", "format", "(", "i", ")", ")", "\n", "", "elif", "stage", "==", "\"back_trick\"", ":", "\n", "                    ", "raise", "RuntimeError", "(", "\"The gradient with respect to the input is independent of entry {}\"", "\n", "\" in the grad_outputs when using the double backward trick to compute\"", "\n", "\" forward mode gradients. This is not allowed in strict mode.\"", ".", "format", "(", "i", ")", ")", "\n", "", "elif", "stage", "==", "\"double_back\"", ":", "\n", "                    ", "raise", "RuntimeError", "(", "\"The jacobian of the user-provided function is independent of \"", "\n", "\"input {}. This is not allowed in strict mode.\"", ".", "format", "(", "i", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "RuntimeError", "(", "\"The hessian of the user-provided function is independent of \"", "\n", "\"entry {} in the grad_jacobian. This is not allowed in strict \"", "\n", "\"mode as it prevents from using the double backward trick to \"", "\n", "\"replace forward mode AD.\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "", "", "grads_i", "=", "torch", ".", "zeros_like", "(", "refs", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "            ", "if", "strict", "and", "create_graph", "and", "not", "grads_i", ".", "requires_grad", ":", "\n", "                ", "if", "\"double\"", "not", "in", "stage", ":", "\n", "                    ", "raise", "RuntimeError", "(", "\"The jacobian of the user-provided function is independent of \"", "\n", "\"input {}. This is not allowed in strict mode when create_graph=True.\"", ".", "format", "(", "i", ")", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "RuntimeError", "(", "\"The hessian of the user-provided function is independent of \"", "\n", "\"input {}. This is not allowed in strict mode when create_graph=True.\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "", "", "", "res", "+=", "(", "grads_i", ",", ")", "\n", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.vjp": [[193, 275], ["grad_fun._as_tuple", "grad_fun._grad_preprocess", "func", "grad_fun._as_tuple", "grad_fun._check_requires_grad", "grad_fun._autograd_grad", "grad_fun._fill_in_zeros", "grad_fun._grad_postprocess", "grad_fun._grad_postprocess", "grad_fun._as_tuple", "grad_fun._grad_preprocess", "grad_fun._validate_v", "grad_fun._tuple_postprocess", "grad_fun._tuple_postprocess", "RuntimeError", "len", "outputs[].nelement"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._fill_in_zeros", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._validate_v", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "vjp", "(", "func", ",", "inputs", ",", "v", "=", "None", ",", "create_graph", "=", "False", ",", "strict", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Function that computes the dot product between a vector ``v`` and the\n    Jacobian of the given function at the point given by the inputs.\n\n    Args:\n        func (function): a Python function that takes Tensor inputs and returns\n            a tuple of Tensors or a Tensor.\n        inputs (tuple of Tensors or Tensor): inputs to the function ``func``.\n        v (tuple of Tensors or Tensor): The vector for which the vector\n            Jacobian product is computed.  Must be the same size as the output\n            of ``func``. This argument is optional when the output of ``func``\n            contains a single element and (if it is not provided) will be set\n            as a Tensor containing a single ``1``.\n        create_graph (bool, optional): If ``True``, both the output and result\n            will be computed in a differentiable way. Note that when ``strict``\n            is ``False``, the result can not require gradients or be\n            disconnected from the inputs.  Defaults to ``False``.\n        strict (bool, optional): If ``True``, an error will be raised when we\n            detect that there exists an input such that all the outputs are\n            independent of it. If ``False``, we return a Tensor of zeros as the\n            vjp for said inputs, which is the expected mathematical value.\n            Defaults to ``False``.\n\n    Returns:\n        vjp (tuple of Tensors or Tensor): result of the dot product with\n        the same shape as the inputs.\n\n    Example:\n\n        >>> def exp_reducer(x):\n        ...   return x.exp().sum(dim=1)\n        >>> inputs = torch.rand(4, 4)\n        >>> v = torch.ones(4)\n        >>> vjp(exp_reducer, inputs, v)\n        (tensor([5.7817, 7.2458, 5.7830, 6.7782]),\n         tensor([[1.4458, 1.3962, 1.3042, 1.6354],\n                [2.1288, 1.0652, 1.5483, 2.5035],\n                [2.2046, 1.1292, 1.1432, 1.3059],\n                [1.3225, 1.6652, 1.7753, 2.0152]]))\n\n        >>> vjp(exp_reducer, inputs, v, create_graph=True)\n        (tensor([5.7817, 7.2458, 5.7830, 6.7782], grad_fn=<SumBackward1>),\n         tensor([[1.4458, 1.3962, 1.3042, 1.6354],\n                [2.1288, 1.0652, 1.5483, 2.5035],\n                [2.2046, 1.1292, 1.1432, 1.3059],\n                [1.3225, 1.6652, 1.7753, 2.0152]], grad_fn=<MulBackward0>))\n\n        >>> def adder(x, y):\n        ...   return 2 * x + 3 * y\n        >>> inputs = (torch.rand(2), torch.rand(2))\n        >>> v = torch.ones(2)\n        >>> vjp(adder, inputs, v)\n        (tensor([2.4225, 2.3340]),\n         (tensor([2., 2.]), tensor([3., 3.])))\n    \"\"\"", "\n", "\n", "is_inputs_tuple", ",", "inputs", "=", "_as_tuple", "(", "inputs", ",", "\"inputs\"", ",", "\"vjp\"", ")", "\n", "inputs", "=", "_grad_preprocess", "(", "inputs", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "True", ")", "\n", "\n", "outputs", "=", "func", "(", "*", "inputs", ")", "\n", "is_outputs_tuple", ",", "outputs", "=", "_as_tuple", "(", "outputs", ",", "\"outputs of the user-provided function\"", ",", "\"vjp\"", ")", "\n", "_check_requires_grad", "(", "outputs", ",", "\"outputs\"", ",", "strict", "=", "strict", ")", "\n", "\n", "if", "v", "is", "not", "None", ":", "\n", "        ", "_", ",", "v", "=", "_as_tuple", "(", "v", ",", "\"v\"", ",", "\"vjp\"", ")", "\n", "v", "=", "_grad_preprocess", "(", "v", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "False", ")", "\n", "_validate_v", "(", "v", ",", "outputs", ",", "is_outputs_tuple", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "outputs", ")", "!=", "1", "or", "outputs", "[", "0", "]", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The vector v can only be None if the \"", "\n", "\"user-provided function returns \"", "\n", "\"a single Tensor with a single element.\"", ")", "\n", "\n", "", "", "grad_res", "=", "_autograd_grad", "(", "outputs", ",", "inputs", ",", "v", ",", "create_graph", "=", "create_graph", ")", "\n", "\n", "vjp", "=", "_fill_in_zeros", "(", "grad_res", ",", "inputs", ",", "strict", ",", "create_graph", ",", "\"back\"", ")", "\n", "\n", "# Cleanup objects and return them to the user", "\n", "outputs", "=", "_grad_postprocess", "(", "outputs", ",", "create_graph", ")", "\n", "vjp", "=", "_grad_postprocess", "(", "vjp", ",", "create_graph", ")", "\n", "\n", "return", "_tuple_postprocess", "(", "outputs", ",", "is_outputs_tuple", ")", ",", "_tuple_postprocess", "(", "vjp", ",", "is_inputs_tuple", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jvp": [[276, 364], ["grad_fun._as_tuple", "grad_fun._grad_preprocess", "func", "grad_fun._as_tuple", "grad_fun._check_requires_grad", "tuple", "grad_fun._autograd_grad", "grad_fun._check_requires_grad", "grad_fun._autograd_grad", "grad_fun._fill_in_zeros", "grad_fun._grad_postprocess", "grad_fun._grad_postprocess", "grad_fun._as_tuple", "grad_fun._grad_preprocess", "grad_fun._validate_v", "grad_fun._tuple_postprocess", "grad_fun._tuple_postprocess", "RuntimeError", "torch.zeros_like", "len", "inputs[].nelement"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._fill_in_zeros", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._validate_v", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "jvp", "(", "func", ",", "inputs", ",", "v", "=", "None", ",", "create_graph", "=", "False", ",", "strict", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Function that computes the dot product between  the Jacobian of\n    the given function at the point given by the inputs and a vector ``v``.\n\n    Args:\n        func (function): a Python function that takes Tensor inputs and returns\n            a tuple of Tensors or a Tensor.\n        inputs (tuple of Tensors or Tensor): inputs to the function ``func``.\n        v (tuple of Tensors or Tensor): The vector for which the Jacobian\n            vector product is computed. Must be the same size as the input of\n            ``func``. This argument is optional when the input to ``func``\n            contains a single element and (if it is not provided) will be set\n            as a Tensor containing a single ``1``.\n        create_graph (bool, optional): If ``True``, both the output and result\n            will be computed in a differentiable way. Note that when ``strict``\n            is ``False``, the result can not require gradients or be\n            disconnected from the inputs.  Defaults to ``False``.\n        strict (bool, optional): If ``True``, an error will be raised when we\n            detect that there exists an input such that all the outputs are\n            independent of it. If ``False``, we return a Tensor of zeros as the\n            jvp for said inputs, which is the expected mathematical value.\n            Defaults to ``False``.\n\n    Returns:\n        jvp (tuple of Tensors or Tensor): result of the dot product with\n        the same shape as the output.\n\n    Example:\n\n        >>> def exp_reducer(x):\n        ...   return x.exp().sum(dim=1)\n        >>> inputs = torch.rand(4, 4)\n        >>> v = torch.ones(4, 4)\n        >>> jvp(exp_reducer, inputs, v)\n        (tensor([6.3090, 4.6742, 7.9114, 8.2106]),\n         tensor([6.3090, 4.6742, 7.9114, 8.2106]))\n\n        >>> jvp(exp_reducer, inputs, v, create_graph=True)\n        (tensor([6.3090, 4.6742, 7.9114, 8.2106], grad_fn=<SumBackward1>),\n         tensor([6.3090, 4.6742, 7.9114, 8.2106], grad_fn=<SqueezeBackward1>))\n\n        >>> def adder(x, y):\n        ...   return 2 * x + 3 * y\n        >>> inputs = (torch.rand(2), torch.rand(2))\n        >>> v = (torch.ones(2), torch.ones(2))\n        >>> jvp(adder, inputs, v)\n        (tensor([2.2399, 2.5005]),\n         tensor([5., 5.]))\n\n    Note:\n        The jvp is currently computed by using the backward of the backward\n        (sometimes called the double backwards trick) as we don't have support\n        for forward mode AD in PyTorch at the moment.\n    \"\"\"", "\n", "\n", "is_inputs_tuple", ",", "inputs", "=", "_as_tuple", "(", "inputs", ",", "\"inputs\"", ",", "\"jvp\"", ")", "\n", "inputs", "=", "_grad_preprocess", "(", "inputs", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "True", ")", "\n", "\n", "if", "v", "is", "not", "None", ":", "\n", "        ", "_", ",", "v", "=", "_as_tuple", "(", "v", ",", "\"v\"", ",", "\"jvp\"", ")", "\n", "v", "=", "_grad_preprocess", "(", "v", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "False", ")", "\n", "_validate_v", "(", "v", ",", "inputs", ",", "is_inputs_tuple", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "inputs", ")", "!=", "1", "or", "inputs", "[", "0", "]", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The vector v can only be None if the input to \"", "\n", "\"the user-provided function is a single Tensor \"", "\n", "\"with a single element.\"", ")", "\n", "\n", "", "", "outputs", "=", "func", "(", "*", "inputs", ")", "\n", "is_outputs_tuple", ",", "outputs", "=", "_as_tuple", "(", "outputs", ",", "\"outputs of the user-provided function\"", ",", "\"jvp\"", ")", "\n", "_check_requires_grad", "(", "outputs", ",", "\"outputs\"", ",", "strict", "=", "strict", ")", "\n", "# The backward is linear so the value of grad_outputs is not important as", "\n", "# it won't appear in the double backward graph. We only need to ensure that", "\n", "# it does not contain inf or nan.", "\n", "grad_outputs", "=", "tuple", "(", "torch", ".", "zeros_like", "(", "out", ",", "requires_grad", "=", "True", ")", "for", "out", "in", "outputs", ")", "\n", "\n", "grad_inputs", "=", "_autograd_grad", "(", "outputs", ",", "inputs", ",", "grad_outputs", ",", "create_graph", "=", "True", ")", "\n", "_check_requires_grad", "(", "grad_inputs", ",", "\"grad_inputs\"", ",", "strict", "=", "strict", ")", "\n", "\n", "grad_res", "=", "_autograd_grad", "(", "grad_inputs", ",", "grad_outputs", ",", "v", ",", "create_graph", "=", "create_graph", ")", "\n", "\n", "jvp", "=", "_fill_in_zeros", "(", "grad_res", ",", "outputs", ",", "strict", ",", "create_graph", ",", "\"back_trick\"", ")", "\n", "\n", "# Cleanup objects and return them to the user", "\n", "outputs", "=", "_grad_postprocess", "(", "outputs", ",", "create_graph", ")", "\n", "jvp", "=", "_grad_postprocess", "(", "jvp", ",", "create_graph", ")", "\n", "\n", "return", "_tuple_postprocess", "(", "outputs", ",", "is_outputs_tuple", ")", ",", "_tuple_postprocess", "(", "jvp", ",", "is_outputs_tuple", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jacobian": [[367, 462], ["grad_fun._as_tuple", "grad_fun._grad_preprocess", "func", "grad_fun._as_tuple", "grad_fun._check_requires_grad", "tuple", "enumerate", "grad_fun._grad_postprocess", "grad_fun._tuple_postprocess", "tuple", "range", "out.nelement", "grad_fun._autograd_grad", "enumerate", "tuple", "zip", "range", "jac_i_el.append", "jac_i_el.append", "torch.stack().view", "len", "out.reshape", "RuntimeError", "RuntimeError", "torch.zeros_like", "enumerate", "torch.stack", "out.size", "inputs[].size"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "jacobian", "(", "func", ",", "inputs", ",", "create_graph", "=", "False", ",", "strict", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Function that computes the Jacobian of a given function.\n\n    Args:\n        func (function): a Python function that takes Tensor inputs and returns\n            a tuple of Tensors or a Tensor.\n        inputs (tuple of Tensors or Tensor): inputs to the function ``func``.\n        create_graph (bool, optional): If ``True``, the Jacobian will be\n            computed in a differentiable manner. Note that when ``strict`` is\n            ``False``, the result can not require gradients or be disconnected\n            from the inputs.  Defaults to ``False``.\n        strict (bool, optional): If ``True``, an error will be raised when we\n            detect that there exists an input such that all the outputs are\n            independent of it. If ``False``, we return a Tensor of zeros as the\n            jacobian for said inputs, which is the expected mathematical value.\n            Defaults to ``False``.\n\n    Returns:\n        Jacobian (Tensor or nested tuple of Tensors): if there are a single\n            input and output, this will be a single Tensor containing the\n            Jacobian for the linearized inputs and output. If one of the two is\n            a tuple, then the Jacobian will be a tuple of Tensors. If both of\n            them are tuples, then the Jacobian will be a tuple of tuple of\n            Tensors where ``Jacobian[i][j]`` will contain the Jacobian of the\n            ``i``\\th output and ``j``\\th input and will have as size the\n            concatenation of the sizes of the corresponding output and the\n            corresponding input.\n\n    Example:\n\n        >>> def exp_reducer(x):\n        ...   return x.exp().sum(dim=1)\n        >>> inputs = torch.rand(2, 2)\n        >>> jacobian(exp_reducer, inputs)\n        tensor([[[1.4917, 2.4352],\n                 [0.0000, 0.0000]],\n                [[0.0000, 0.0000],\n                 [2.4369, 2.3799]]])\n\n        >>> jacobian(exp_reducer, inputs, create_graph=True)\n        tensor([[[1.4917, 2.4352],\n                 [0.0000, 0.0000]],\n                [[0.0000, 0.0000],\n                 [2.4369, 2.3799]]], grad_fn=<ViewBackward>)\n\n        >>> def exp_adder(x, y):\n        ...   return 2 * x.exp() + 3 * y\n        >>> inputs = (torch.rand(2), torch.rand(2))\n        >>> jacobian(exp_adder, inputs)\n        (tensor([[2.8052, 0.0000],\n                [0.0000, 3.3963]]),\n         tensor([[3., 0.],\n                 [0., 3.]]))\n    \"\"\"", "\n", "\n", "is_inputs_tuple", ",", "inputs", "=", "_as_tuple", "(", "inputs", ",", "\"inputs\"", ",", "\"jacobian\"", ")", "\n", "inputs", "=", "_grad_preprocess", "(", "inputs", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "True", ")", "\n", "\n", "outputs", "=", "func", "(", "*", "inputs", ")", "\n", "is_outputs_tuple", ",", "outputs", "=", "_as_tuple", "(", "outputs", ",", "\n", "\"outputs of the user-provided function\"", ",", "\n", "\"jacobian\"", ")", "\n", "_check_requires_grad", "(", "outputs", ",", "\"outputs\"", ",", "strict", "=", "strict", ")", "\n", "\n", "jacobian", ":", "Tuple", "[", "torch", ".", "Tensor", ",", "...", "]", "=", "tuple", "(", ")", "\n", "for", "i", ",", "out", "in", "enumerate", "(", "outputs", ")", ":", "\n", "\n", "# mypy complains that expression and variable have different types due to the empty list", "\n", "        ", "jac_i", ":", "Tuple", "[", "List", "[", "torch", ".", "Tensor", "]", "]", "=", "tuple", "(", "[", "]", "for", "_", "in", "range", "(", "len", "(", "inputs", ")", ")", ")", "# type: ignore", "\n", "for", "j", "in", "range", "(", "out", ".", "nelement", "(", ")", ")", ":", "\n", "            ", "vj", "=", "_autograd_grad", "(", "(", "out", ".", "reshape", "(", "-", "1", ")", "[", "j", "]", ",", ")", ",", "inputs", ",", "\n", "retain_graph", "=", "True", ",", "create_graph", "=", "create_graph", ")", "\n", "\n", "for", "el_idx", ",", "(", "jac_i_el", ",", "vj_el", ",", "inp_el", ")", "in", "enumerate", "(", "zip", "(", "jac_i", ",", "vj", ",", "inputs", ")", ")", ":", "\n", "                ", "if", "vj_el", "is", "not", "None", ":", "\n", "                    ", "if", "strict", "and", "create_graph", "and", "not", "vj_el", ".", "requires_grad", ":", "\n", "                        ", "msg", "=", "(", "\"The jacobian of the user-provided function is \"", "\n", "\"independent of input {}. This is not allowed in \"", "\n", "\"strict mode when create_graph=True.\"", ".", "format", "(", "i", ")", ")", "\n", "raise", "RuntimeError", "(", "msg", ")", "\n", "", "jac_i_el", ".", "append", "(", "vj_el", ")", "\n", "", "else", ":", "\n", "                    ", "if", "strict", ":", "\n", "                        ", "msg", "=", "(", "\"Output {} of the user-provided function is \"", "\n", "\"independent of input {}. This is not allowed in \"", "\n", "\"strict mode.\"", ".", "format", "(", "i", ",", "el_idx", ")", ")", "\n", "raise", "RuntimeError", "(", "msg", ")", "\n", "", "jac_i_el", ".", "append", "(", "torch", ".", "zeros_like", "(", "inp_el", ")", ")", "\n", "\n", "", "", "", "jacobian", "+=", "(", "tuple", "(", "torch", ".", "stack", "(", "jac_i_el", ",", "dim", "=", "0", ")", ".", "view", "(", "out", ".", "size", "(", ")", "\n", "+", "inputs", "[", "el_idx", "]", ".", "size", "(", ")", ")", "for", "(", "el_idx", ",", "jac_i_el", ")", "in", "enumerate", "(", "jac_i", ")", ")", ",", ")", "\n", "\n", "", "jacobian", "=", "_grad_postprocess", "(", "jacobian", ",", "create_graph", ")", "\n", "\n", "return", "_tuple_postprocess", "(", "jacobian", ",", "(", "is_outputs_tuple", ",", "is_inputs_tuple", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hessian": [[465, 551], ["grad_fun._as_tuple", "grad_fun.jacobian", "grad_fun._tuple_postprocess", "func", "grad_fun._as_tuple", "grad_fun._check_requires_grad", "func.squeeze", "grad_fun.jacobian", "grad_fun._check_requires_grad", "RuntimeError", "func.nelement", "RuntimeError", "isinstance"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jacobian", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.jacobian", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad"], ["", "def", "hessian", "(", "func", ",", "inputs", ",", "create_graph", "=", "False", ",", "strict", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Function that computes the Hessian of a given scalar function.\n\n    Args:\n        func (function): a Python function that takes Tensor inputs and returns\n            a Tensor with a single element.\n        inputs (tuple of Tensors or Tensor): inputs to the function ``func``.\n        create_graph (bool, optional): If ``True``, the Hessian will be computed in\n            a differentiable manner. Note that when ``strict`` is ``False``, the result can not\n            require gradients or be disconnected from the inputs.\n            Defaults to ``False``.\n        strict (bool, optional): If ``True``, an error will be raised when we detect that there exists an input\n            such that all the outputs are independent of it. If ``False``, we return a Tensor of zeros as the\n            hessian for said inputs, which is the expected mathematical value.\n            Defaults to ``False``.\n\n    Returns:\n        Hessian (Tensor or a tuple of tuple of Tensors) if there are a single input,\n            this will be a single Tensor containing the Hessian for the input.\n            If it is a tuple, then the Hessian will be a tuple of tuples where\n            ``Hessian[i][j]`` will contain the Hessian of the ``i``\\th input\n            and ``j``\\th input with size the sum of the size of the ``i``\\th input plus\n            the size of the ``j``\\th input.\n\n    Example:\n\n        >>> def pow_reducer(x):\n        ...   return x.pow(3).sum()\n        >>> inputs = torch.rand(2, 2)\n        >>> hessian(pow_reducer, inputs)\n        tensor([[[[5.2265, 0.0000],\n                  [0.0000, 0.0000]],\n                 [[0.0000, 4.8221],\n                  [0.0000, 0.0000]]],\n                [[[0.0000, 0.0000],\n                  [1.9456, 0.0000]],\n                 [[0.0000, 0.0000],\n                  [0.0000, 3.2550]]]])\n\n        >>> hessian(pow_reducer, inputs, create_graph=True)\n        tensor([[[[5.2265, 0.0000],\n                  [0.0000, 0.0000]],\n                 [[0.0000, 4.8221],\n                  [0.0000, 0.0000]]],\n                [[[0.0000, 0.0000],\n                  [1.9456, 0.0000]],\n                 [[0.0000, 0.0000],\n                  [0.0000, 3.2550]]]], grad_fn=<ViewBackward>)\n\n\n        >>> def pow_adder_reducer(x, y):\n        ...   return (2 * x.pow(2) + 3 * y.pow(2)).sum()\n        >>> inputs = (torch.rand(2), torch.rand(2))\n        >>> hessian(pow_adder_reducer, inputs)\n        ((tensor([[4., 0.],\n                  [0., 4.]]),\n          tensor([[0., 0.],\n                  [0., 0.]])),\n         (tensor([[0., 0.],\n                  [0., 0.]]),\n          tensor([[6., 0.],\n                  [0., 6.]])))\n    \"\"\"", "\n", "\n", "is_inputs_tuple", ",", "inputs", "=", "_as_tuple", "(", "inputs", ",", "\"inputs\"", ",", "\"hessian\"", ")", "\n", "\n", "def", "ensure_single_output_function", "(", "*", "inp", ")", ":", "\n", "        ", "out", "=", "func", "(", "*", "inp", ")", "\n", "is_out_tuple", ",", "t_out", "=", "_as_tuple", "(", "out", ",", "\"outputs of the user-provided function\"", ",", "\"hessian\"", ")", "\n", "_check_requires_grad", "(", "t_out", ",", "\"outputs\"", ",", "strict", "=", "strict", ")", "\n", "\n", "if", "is_out_tuple", "or", "not", "isinstance", "(", "out", ",", "torch", ".", "Tensor", ")", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The function given to hessian should return a single Tensor\"", ")", "\n", "\n", "", "if", "out", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The Tensor returned by the function given to hessian should contain a single element\"", ")", "\n", "\n", "", "return", "out", ".", "squeeze", "(", ")", "\n", "\n", "", "def", "jac_func", "(", "*", "inp", ")", ":", "\n", "        ", "jac", "=", "jacobian", "(", "ensure_single_output_function", ",", "inp", ",", "create_graph", "=", "True", ")", "\n", "_check_requires_grad", "(", "jac", ",", "\"jacobian\"", ",", "strict", "=", "strict", ")", "\n", "return", "jac", "\n", "\n", "", "res", "=", "jacobian", "(", "jac_func", ",", "inputs", ",", "create_graph", "=", "create_graph", ",", "strict", "=", "strict", ")", "\n", "return", "_tuple_postprocess", "(", "res", ",", "(", "is_inputs_tuple", ",", "is_inputs_tuple", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.vhp": [[553, 641], ["grad_fun._as_tuple", "grad_fun._grad_preprocess", "func", "grad_fun._as_tuple", "grad_fun._check_requires_grad", "grad_fun._autograd_grad", "grad_fun._check_requires_grad", "grad_fun._autograd_grad", "grad_fun._fill_in_zeros", "grad_fun._grad_postprocess", "grad_fun._grad_postprocess", "grad_fun._as_tuple", "grad_fun._grad_preprocess", "grad_fun._validate_v", "RuntimeError", "outputs[].nelement", "RuntimeError", "grad_fun._tuple_postprocess", "grad_fun._tuple_postprocess", "RuntimeError", "isinstance", "len", "inputs[].nelement"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._fill_in_zeros", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._validate_v", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "vhp", "(", "func", ",", "inputs", ",", "v", "=", "None", ",", "create_graph", "=", "False", ",", "strict", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Function that computes the dot product between a vector ``v`` and the\n    Hessian of a given scalar function at the point given by the inputs.\n\n    Args:\n        func (function): a Python function that takes Tensor inputs and returns\n            a Tensor with a single element.\n        inputs (tuple of Tensors or Tensor): inputs to the function ``func``.\n        v (tuple of Tensors or Tensor): The vector for which the vector Hessian\n            product is computed. Must be the same size as the input of\n            ``func``. This argument is optional when ``func``'s input contains\n            a single element and (if it is not provided) will be set as a\n            Tensor containing a single ``1``.\n        create_graph (bool, optional): If ``True``, both the output and result\n            will be computed in a differentiable way. Note that when ``strict``\n            is ``False``, the result can not require gradients or be\n            disconnected from the inputs.\n            Defaults to ``False``.\n        strict (bool, optional): If ``True``, an error will be raised when we\n            detect that there exists an input such that all the outputs are\n            independent of it. If ``False``, we return a Tensor of zeros as the\n            vhp for said inputs, which is the expected mathematical value.\n            Defaults to ``False``.\n\n    Returns:\n        output (tuple): tuple with:\n            func_output (tuple of Tensors or Tensor): output of ``func(inputs)``\n\n            vhp (tuple of Tensors or Tensor): result of the dot product with the\n            same shape as the inputs.\n\n    Example:\n\n        >>> def pow_reducer(x):\n        ...   return x.pow(3).sum()\n        >>> inputs = torch.rand(2, 2)\n        >>> v = torch.ones(2, 2)\n        >>> vhp(pow_reducer, inputs, v)\n        (tensor(0.5591),\n         tensor([[1.0689, 1.2431],\n                 [3.0989, 4.4456]]))\n        >>> vhp(pow_reducer, inputs, v, create_graph=True)\n        (tensor(0.5591, grad_fn=<SumBackward0>),\n         tensor([[1.0689, 1.2431],\n                 [3.0989, 4.4456]], grad_fn=<MulBackward0>))\n        >>> def pow_adder_reducer(x, y):\n        ...   return (2 * x.pow(2) + 3 * y.pow(2)).sum()\n        >>> inputs = (torch.rand(2), torch.rand(2))\n        >>> v = (torch.zeros(2), torch.ones(2))\n        >>> vhp(pow_adder_reducer, inputs, v)\n        (tensor(4.8053),\n         (tensor([0., 0.]),\n          tensor([6., 6.])))\n    \"\"\"", "\n", "\n", "is_inputs_tuple", ",", "inputs", "=", "_as_tuple", "(", "inputs", ",", "\"inputs\"", ",", "\"vhp\"", ")", "\n", "inputs", "=", "_grad_preprocess", "(", "inputs", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "True", ")", "\n", "\n", "if", "v", "is", "not", "None", ":", "\n", "        ", "_", ",", "v", "=", "_as_tuple", "(", "v", ",", "\"v\"", ",", "\"vhp\"", ")", "\n", "v", "=", "_grad_preprocess", "(", "v", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "False", ")", "\n", "_validate_v", "(", "v", ",", "inputs", ",", "is_inputs_tuple", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "inputs", ")", "!=", "1", "or", "inputs", "[", "0", "]", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The vector v can only be None if the input to the user-provided function \"", "\n", "\"is a single Tensor with a single element.\"", ")", "\n", "\n", "", "", "outputs", "=", "func", "(", "*", "inputs", ")", "\n", "is_outputs_tuple", ",", "outputs", "=", "_as_tuple", "(", "outputs", ",", "\"outputs of the user-provided function\"", ",", "\"vhp\"", ")", "\n", "_check_requires_grad", "(", "outputs", ",", "\"outputs\"", ",", "strict", "=", "strict", ")", "\n", "\n", "if", "is_outputs_tuple", "or", "not", "isinstance", "(", "outputs", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"The function given to vhp should return a single Tensor\"", ")", "\n", "\n", "", "if", "outputs", "[", "0", "]", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"The Tensor returned by the function given to vhp should contain a single element\"", ")", "\n", "\n", "", "jac", "=", "_autograd_grad", "(", "outputs", ",", "inputs", ",", "create_graph", "=", "True", ")", "\n", "_check_requires_grad", "(", "jac", ",", "\"jacobian\"", ",", "strict", "=", "strict", ")", "\n", "\n", "grad_res", "=", "_autograd_grad", "(", "jac", ",", "inputs", ",", "v", ",", "create_graph", "=", "create_graph", ")", "\n", "\n", "vhp", "=", "_fill_in_zeros", "(", "grad_res", ",", "inputs", ",", "strict", ",", "create_graph", ",", "\"double_back\"", ")", "\n", "\n", "outputs", "=", "_grad_postprocess", "(", "outputs", ",", "create_graph", ")", "\n", "vhp", "=", "_grad_postprocess", "(", "vhp", ",", "create_graph", ")", "\n", "\n", "return", "_tuple_postprocess", "(", "outputs", ",", "is_outputs_tuple", ")", ",", "_tuple_postprocess", "(", "vhp", ",", "is_inputs_tuple", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun.hvp": [[644, 744], ["grad_fun._as_tuple", "grad_fun._grad_preprocess", "func", "grad_fun._as_tuple", "grad_fun._check_requires_grad", "grad_fun._autograd_grad", "grad_fun._check_requires_grad", "tuple", "grad_fun._autograd_grad", "grad_fun._check_requires_grad", "grad_fun._autograd_grad", "grad_fun._fill_in_zeros", "grad_fun._grad_postprocess", "grad_fun._grad_postprocess", "grad_fun._as_tuple", "grad_fun._grad_preprocess", "grad_fun._validate_v", "RuntimeError", "outputs[].nelement", "RuntimeError", "grad_fun._tuple_postprocess", "grad_fun._tuple_postprocess", "RuntimeError", "isinstance", "torch.zeros_like", "len", "inputs[].nelement"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._check_requires_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._autograd_grad", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._fill_in_zeros", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._as_tuple", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._grad_preprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._validate_v", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.grad_fun._tuple_postprocess", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "hvp", "(", "func", ",", "inputs", ",", "v", "=", "None", ",", "create_graph", "=", "False", ",", "strict", "=", "False", ")", ":", "\n", "    ", "r\"\"\"Function that computes the dot product between the Hessian of a given scalar\n    function and a vector ``v`` at the point given by the inputs.\n\n    Args:\n        func (function): a Python function that takes Tensor inputs and returns\n            a Tensor with a single element.\n        inputs (tuple of Tensors or Tensor): inputs to the function ``func``.\n        v (tuple of Tensors or Tensor): The vector for which the Hessian vector\n            product is computed. Must be the same size as the input of\n            ``func``. This argument is optional when ``func``'s input contains\n            a single element and (if it is not provided) will be set as a\n            Tensor containing a single ``1``.\n        create_graph (bool, optional): If ``True``, both the output and result will be\n            computed in a differentiable way. Note that when ``strict`` is\n            ``False``, the result can not require gradients or be disconnected\n            from the inputs.  Defaults to ``False``.\n        strict (bool, optional): If ``True``, an error will be raised when we\n            detect that there exists an input such that all the outputs are\n            independent of it. If ``False``, we return a Tensor of zeros as the\n            hvp for said inputs, which is the expected mathematical value.\n            Defaults to ``False``.\n    Returns:\n        func_output (tuple of Tensors or Tensor): output of ``func(inputs)``\n            hvp (tuple of Tensors or Tensor): result of the dot product with\n            the same shape as the inputs.\n\n    Example:\n\n        >>> def pow_reducer(x):\n        ...   return x.pow(3).sum()\n        >>> inputs = torch.rand(2, 2)\n        >>> v = torch.ones(2, 2)\n        >>> hvp(pow_reducer, inputs, v)\n        (tensor(0.1448),\n         tensor([[2.0239, 1.6456],\n                 [2.4988, 1.4310]]))\n\n        >>> hvp(pow_reducer, inputs, v, create_graph=True)\n        (tensor(0.1448, grad_fn=<SumBackward0>),\n         tensor([[2.0239, 1.6456],\n                 [2.4988, 1.4310]], grad_fn=<MulBackward0>))\n\n\n        >>> def pow_adder_reducer(x, y):\n        ...   return (2 * x.pow(2) + 3 * y.pow(2)).sum()\n        >>> inputs = (torch.rand(2), torch.rand(2))\n        >>> v = (torch.zeros(2), torch.ones(2))\n        >>> hvp(pow_adder_reducer, inputs, v)\n        (tensor(2.3030),\n         (tensor([0., 0.]),\n          tensor([6., 6.])))\n\n    Note:\n\n        This function is significantly slower than `vhp` due to backward mode AD constraints.\n        If your functions is twice continuously differentiable, then hvp = vhp.t(). So if you\n        know that your function satisfies this condition, you should use vhp instead that is\n        much faster with the current implementation.\n\n    \"\"\"", "\n", "\n", "is_inputs_tuple", ",", "inputs", "=", "_as_tuple", "(", "inputs", ",", "\"inputs\"", ",", "\"hvp\"", ")", "\n", "inputs", "=", "_grad_preprocess", "(", "inputs", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "True", ")", "\n", "\n", "if", "v", "is", "not", "None", ":", "\n", "        ", "_", ",", "v", "=", "_as_tuple", "(", "v", ",", "\"v\"", ",", "\"hvp\"", ")", "\n", "v", "=", "_grad_preprocess", "(", "v", ",", "create_graph", "=", "create_graph", ",", "need_graph", "=", "False", ")", "\n", "_validate_v", "(", "v", ",", "inputs", ",", "is_inputs_tuple", ")", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "inputs", ")", "!=", "1", "or", "inputs", "[", "0", "]", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "            ", "raise", "RuntimeError", "(", "\"The vector v can only be None if the input to the user-provided function \"", "\n", "\"is a single Tensor with a single element.\"", ")", "\n", "\n", "", "", "outputs", "=", "func", "(", "*", "inputs", ")", "\n", "is_outputs_tuple", ",", "outputs", "=", "_as_tuple", "(", "outputs", ",", "\"outputs of the user-provided function\"", ",", "\"hvp\"", ")", "\n", "_check_requires_grad", "(", "outputs", ",", "\"outputs\"", ",", "strict", "=", "strict", ")", "\n", "\n", "if", "is_outputs_tuple", "or", "not", "isinstance", "(", "outputs", "[", "0", "]", ",", "torch", ".", "Tensor", ")", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"The function given to hvp should return a single Tensor\"", ")", "\n", "\n", "", "if", "outputs", "[", "0", "]", ".", "nelement", "(", ")", "!=", "1", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"The Tensor returned by the function given to hvp should contain a single element\"", ")", "\n", "\n", "", "jac", "=", "_autograd_grad", "(", "outputs", ",", "inputs", ",", "create_graph", "=", "True", ")", "\n", "_check_requires_grad", "(", "jac", ",", "\"jacobian\"", ",", "strict", "=", "strict", ")", "\n", "\n", "grad_jac", "=", "tuple", "(", "torch", ".", "zeros_like", "(", "inp", ",", "requires_grad", "=", "True", ")", "for", "inp", "in", "inputs", ")", "\n", "\n", "double_back", "=", "_autograd_grad", "(", "jac", ",", "inputs", ",", "grad_jac", ",", "create_graph", "=", "True", ")", "\n", "_check_requires_grad", "(", "jac", ",", "\"hessian\"", ",", "strict", "=", "strict", ")", "\n", "\n", "grad_res", "=", "_autograd_grad", "(", "double_back", ",", "grad_jac", ",", "v", ",", "create_graph", "=", "create_graph", ")", "\n", "\n", "hvp", "=", "_fill_in_zeros", "(", "grad_res", ",", "inputs", ",", "strict", ",", "create_graph", ",", "\"double_back_trick\"", ")", "\n", "\n", "outputs", "=", "_grad_postprocess", "(", "outputs", ",", "create_graph", ")", "\n", "hvp", "=", "_grad_postprocess", "(", "hvp", ",", "create_graph", ")", "\n", "\n", "return", "_tuple_postprocess", "(", "outputs", ",", "is_outputs_tuple", ")", ",", "_tuple_postprocess", "(", "hvp", ",", "is_inputs_tuple", ")", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.Debug.__init__": [[70, 81], ["super().__init__", "range", "len", "datasets.Debug.datasets.append", "domainbed.utils.TensorDataset", "torch.randn", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["def", "__init__", "(", "self", ",", "root", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_shape", "=", "self", ".", "INPUT_SHAPE", "\n", "self", ".", "num_classes", "=", "2", "\n", "self", ".", "environments", "=", "[", "0", ",", "1", ",", "2", "]", "\n", "self", ".", "datasets", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "len", "(", "self", ".", "environments", ")", ")", ":", "\n", "            ", "self", ".", "datasets", ".", "append", "(", "\n", "TensorDataset", "(", "\n", "torch", ".", "randn", "(", "self", ".", "DATASET_SIZE", ",", "*", "self", ".", "INPUT_SHAPE", ")", ",", "\n", "torch", ".", "randint", "(", "0", ",", "self", ".", "num_classes", ",", "(", "self", ".", "DATASET_SIZE", ",", ")", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.Debug.__getitem__": [[84, 86], ["None"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "datasets", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.Debug.__len__": [[87, 89], ["len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentMNIST.__init__": [[102, 138], ["super().__init__", "torch.FloatTensor", "torch.randint().float", "torchvision.datasets.MNIST", "torchvision.datasets.MNIST", "torch.cat", "torch.cat", "torch.randperm", "range", "ValueError", "len", "len", "datasets.MultipleEnvironmentMNIST.datasets.append", "torch.randint", "dataset_transform", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "environments", ",", "dataset_transform", ",", "input_shape", ",", "\n", "num_classes", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "root", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Data directory not specified!'", ")", "\n", "", "self", ".", "colors", "=", "torch", ".", "FloatTensor", "(", "\n", "[", "[", "0", ",", "100", ",", "0", "]", ",", "[", "188", ",", "143", ",", "143", "]", ",", "[", "255", ",", "0", ",", "0", "]", ",", "[", "255", ",", "215", ",", "0", "]", ",", "[", "0", ",", "255", ",", "0", "]", ",", "[", "65", ",", "105", ",", "225", "]", ",", "[", "0", ",", "225", ",", "225", "]", ",", "\n", "[", "0", ",", "0", ",", "255", "]", ",", "[", "255", ",", "20", ",", "147", "]", ",", "[", "180", ",", "180", ",", "180", "]", "]", ")", "\n", "self", ".", "random_colors", "=", "torch", ".", "randint", "(", "255", ",", "(", "10", ",", "3", ")", ")", ".", "float", "(", ")", "\n", "\n", "original_dataset_tr", "=", "MNIST", "(", "root", ",", "train", "=", "True", ",", "download", "=", "True", ")", "\n", "original_dataset_te", "=", "MNIST", "(", "root", ",", "train", "=", "False", ",", "download", "=", "True", ")", "\n", "\n", "original_images", "=", "torch", ".", "cat", "(", "(", "original_dataset_tr", ".", "data", ",", "\n", "original_dataset_te", ".", "data", ")", ")", "\n", "\n", "original_labels", "=", "torch", ".", "cat", "(", "(", "original_dataset_tr", ".", "targets", ",", "\n", "original_dataset_te", ".", "targets", ")", ")", "\n", "\n", "shuffle", "=", "torch", ".", "randperm", "(", "len", "(", "original_images", ")", ")", "\n", "\n", "original_images", "=", "original_images", "[", "shuffle", "]", "\n", "original_labels", "=", "original_labels", "[", "shuffle", "]", "\n", "\n", "self", ".", "datasets", "=", "[", "]", "\n", "self", ".", "environments", "=", "environments", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "environments", ")", ")", ":", "\n", "            ", "images", "=", "original_images", "[", "i", ":", ":", "len", "(", "self", ".", "environments", ")", "]", "\n", "labels", "=", "original_labels", "[", "i", ":", ":", "len", "(", "self", ".", "environments", ")", "]", "\n", "#             images = original_images", "\n", "#             labels = original_labels", "\n", "self", ".", "datasets", ".", "append", "(", "dataset_transform", "(", "images", ",", "labels", ",", "environments", "[", "i", "]", ")", ")", "\n", "\n", "", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentMNIST.__getitem__": [[139, 141], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "datasets", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentMNIST.__len__": [[142, 144], ["len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.ColoredMNIST.__init__": [[148, 178], ["int", "print", "datasets.MultipleEnvironmentMNIST.__init__", "torch.randint", "int", "int", "int", "int", "int", "int", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "bias", ",", "test_envs", ",", "hparams", ")", ":", "\n", "# config setting:", "\n", "# 0: random seed for environmental color;", "\n", "# 1: use default colors (True) or random colors;", "\n", "# 2: Bernoulli parameters for environmental color;", "\n", "# 3: designated environmental color number;", "\n", "# 4: random seed for bkgd colors", "\n", "# 5: Color digit?", "\n", "# 6: Color bkgd?", "\n", "# 7: Bernoulli parameters for bkgd colors", "\n", "#", "\n", "        ", "seed", "=", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", "\n", "if", "hparams", "[", "'shift'", "]", "==", "0", ":", "\n", "            ", "config", "=", "[", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "seed", ",", "True", ",", "False", ",", "0", "]", ",", "\n", "[", "seed", ",", "True", ",", "1", ",", "None", ",", "seed", ",", "True", ",", "False", ",", "0", "]", ",", "\n", "[", "seed", ",", "True", ",", "bias", ",", "None", ",", "seed", ",", "True", ",", "False", ",", "0", "]", "]", "\n", "", "if", "hparams", "[", "'shift'", "]", "==", "1", ":", "\n", "            ", "config", "=", "[", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "False", ",", "True", ",", "0", "]", ",", "\n", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "False", ",", "True", ",", "0", "]", ",", "\n", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "False", ",", "True", ",", "0", "]", "]", "\n", "", "if", "hparams", "[", "'shift'", "]", "==", "2", ":", "\n", "            ", "config", "=", "[", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "True", ",", "True", ",", "0", "]", ",", "\n", "[", "seed", ",", "True", ",", "1", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "True", ",", "True", ",", "0", "]", ",", "\n", "[", "seed", ",", "True", ",", "bias", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "True", ",", "True", ",", "0", "]", "]", "\n", "\n", "", "print", "(", "\"config:\"", ",", "config", ")", "\n", "self", ".", "vis", "=", "False", "\n", "self", ".", "input_shape", "=", "(", "3", ",", "28", ",", "28", ",", ")", "\n", "self", ".", "num_classes", "=", "10", "\n", "super", "(", "ColoredMNIST", ",", "self", ")", ".", "__init__", "(", "root", ",", "config", ",", "self", ".", "color_dataset", ",", "(", "3", ",", "28", ",", "28", ",", ")", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.ColoredMNIST.color_dataset": [[181, 249], ["torch.cuda.initial_seed", "torch.manual_seed", "torch.randperm", "torch.manual_seed", "datasets.ColoredMNIST.torch_bernoulli_", "torch.manual_seed", "torch.randperm", "torch.manual_seed", "datasets.ColoredMNIST.torch_bernoulli_", "torch.stack", "torch.manual_seed", "len", "range", "torch.stack.float().div_", "labels.view().long", "domainbed.utils.TensorDataset", "len", "torch.randint().float", "len", "len", "torch.randint().float", "len", "torch.empty", "domainbed.utils.save_image", "print", "exit", "torch.stack.float", "labels.view", "torch.randint", "torch.randint", "torch.randint", "datasets.ColoredMNIST.colors_[].view", "torch.randint", "datasets.ColoredMNIST.colors_[].view", "bkgd_colors[].view", "bkgd_colors[].view", "labels[].long", "labels[].long"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.torch_bernoulli_", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.torch_bernoulli_", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.save_image"], ["", "def", "color_dataset", "(", "self", ",", "images", ",", "labels", ",", "environment", ")", ":", "\n", "# set the seed", "\n", "\n", "        ", "original_seed", "=", "torch", ".", "cuda", ".", "initial_seed", "(", ")", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "0", "]", ")", "\n", "shuffle", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "colors", ")", ")", "\n", "self", ".", "colors_", "=", "self", ".", "colors", "[", "shuffle", "]", "if", "environment", "[", "1", "]", "else", "torch", ".", "randint", "(", "255", ",", "(", "10", ",", "3", ")", ")", ".", "float", "(", ")", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "0", "]", ")", "\n", "ber_digit", "=", "self", ".", "torch_bernoulli_", "(", "environment", "[", "2", "]", ",", "len", "(", "labels", ")", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "4", "]", ")", "\n", "shuffle", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "colors", ")", ")", "\n", "bkgd_colors", "=", "torch", ".", "randint", "(", "255", ",", "(", "10", ",", "3", ")", ")", ".", "float", "(", ")", "*", "0.75", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "4", "]", ")", "\n", "ber_bkgd", "=", "self", ".", "torch_bernoulli_", "(", "environment", "[", "7", "]", ",", "len", "(", "labels", ")", ")", "\n", "images", "=", "torch", ".", "stack", "(", "[", "images", ",", "images", ",", "images", "]", ",", "dim", "=", "1", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "original_seed", ")", "\n", "# binarize the images", "\n", "images", "=", "(", "images", ">", "0", ")", ".", "float", "(", ")", "\n", "masks", "=", "(", "1", "-", "images", ")", "\n", "total_len", "=", "len", "(", "images", ")", "\n", "if", "self", ".", "vis", ":", "\n", "            ", "image_collect", "=", "torch", ".", "empty", "(", "20", ",", "*", "self", ".", "input_shape", ")", "\n", "current_label", "=", "0", "\n", "current_cnt", "=", "0", "\n", "total_cnt", "=", "0", "\n", "# Apply the color to the image", "\n", "", "for", "img_idx", "in", "range", "(", "total_len", ")", ":", "\n", "# change digit colors", "\n", "            ", "if", "ber_digit", "[", "img_idx", "]", ">", "0", ":", "\n", "                ", "if", "environment", "[", "5", "]", ":", "\n", "                    ", "images", "[", "img_idx", "]", "=", "images", "[", "img_idx", "]", "*", "self", ".", "colors_", "[", "labels", "[", "img_idx", "]", ".", "long", "(", ")", "]", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "\n", "", "", "else", ":", "\n", "                ", "color", "=", "torch", ".", "randint", "(", "10", ",", "[", "1", "]", ")", "[", "0", "]", "if", "environment", "[", "3", "]", "is", "None", "else", "environment", "[", "3", "]", "\n", "if", "environment", "[", "5", "]", ":", "\n", "                    ", "images", "[", "img_idx", "]", "=", "images", "[", "img_idx", "]", "*", "self", ".", "colors_", "[", "color", "]", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "\n", "# change bkpg colors", "\n", "", "", "if", "ber_bkgd", "[", "img_idx", "]", ">", "0", ":", "\n", "                ", "if", "environment", "[", "6", "]", ":", "\n", "                    ", "images", "[", "img_idx", "]", "=", "images", "[", "img_idx", "]", "*", "(", "1", "-", "masks", "[", "img_idx", "]", ")", "+", "masks", "[", "img_idx", "]", "*", "bkgd_colors", "[", "\n", "labels", "[", "img_idx", "]", ".", "long", "(", ")", "]", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "\n", "", "", "else", ":", "\n", "                ", "color", "=", "torch", ".", "randint", "(", "5", ",", "[", "1", "]", ")", "[", "0", "]", "\n", "if", "environment", "[", "6", "]", ":", "\n", "                    ", "images", "[", "img_idx", "]", "=", "images", "[", "img_idx", "]", "*", "(", "1", "-", "masks", "[", "img_idx", "]", ")", "+", "masks", "[", "img_idx", "]", "*", "bkgd_colors", "[", "color", "]", ".", "view", "(", "\n", "-", "1", ",", "1", ",", "1", ")", "\n", "", "", "if", "self", ".", "vis", ":", "\n", "                ", "if", "labels", "[", "img_idx", "]", "!=", "current_label", ":", "\n", "                    ", "continue", "\n", "# visualize 20 images for sanity check", "\n", "", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "image_collect", "[", "total_cnt", "]", "=", "images", "[", "img_idx", "]", "/", "255.", "\n", "current_cnt", "+=", "1", "\n", "total_cnt", "+=", "1", "\n", "if", "current_cnt", "==", "2", ":", "\n", "                    ", "current_cnt", "=", "0", "\n", "current_label", "+=", "1", "\n", "", "if", "total_cnt", "==", "20", ":", "\n", "                    ", "break", "\n", "", "", "", "if", "self", ".", "vis", ":", "\n", "            ", "save_image", "(", "image_collect", ",", "'colormnist_uncorrelated_train.png'", ",", "nrow", "=", "10", ")", "\n", "print", "(", "f\"Visualization for {environment} Done\"", ")", "\n", "exit", "(", "0", ")", "\n", "", "x", "=", "images", ".", "float", "(", ")", ".", "div_", "(", "255.0", ")", "\n", "y", "=", "labels", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "\n", "\n", "return", "TensorDataset", "(", "True", ",", "x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.ColoredMNIST.torch_bernoulli_": [[250, 252], ["torch.rand"], "methods", ["None"], ["", "def", "torch_bernoulli_", "(", "self", ",", "p", ",", "size", ")", ":", "\n", "        ", "return", "(", "torch", ".", "rand", "(", "size", ")", "<", "p", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.ColoredMNIST.torch_xor_": [[253, 255], ["None"], "methods", ["None"], ["", "def", "torch_xor_", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "return", "(", "a", "-", "b", ")", ".", "abs", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.RotatedMNIST.__init__": [[259, 262], ["datasets.MultipleEnvironmentMNIST.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "super", "(", "RotatedMNIST", ",", "self", ")", ".", "__init__", "(", "root", ",", "[", "0", ",", "15", ",", "30", ",", "45", ",", "60", ",", "75", "]", ",", "\n", "self", ".", "rotate_dataset", ",", "(", "1", ",", "28", ",", "28", ",", ")", ",", "10", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.RotatedMNIST.rotate_dataset": [[263, 277], ["torchvision.transforms.Compose", "torch.zeros", "range", "labels.view", "domainbed.utils.TensorDataset", "len", "len", "torchvision.transforms.Compose.", "torchvision.transforms.ToPILImage", "torchvision.transforms.Lambda", "torchvision.transforms.ToTensor", "torchvision.transforms.functional.rotate"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "rotate_dataset", "(", "self", ",", "images", ",", "labels", ",", "angle", ")", ":", "\n", "        ", "rotation", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToPILImage", "(", ")", ",", "\n", "transforms", ".", "Lambda", "(", "lambda", "x", ":", "rotate", "(", "x", ",", "angle", ",", "fill", "=", "(", "0", ",", ")", ",", "\n", "resample", "=", "PIL", ".", "Image", ".", "BICUBIC", ")", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", "]", ")", "\n", "\n", "x", "=", "torch", ".", "zeros", "(", "len", "(", "images", ")", ",", "1", ",", "28", ",", "28", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "images", ")", ")", ":", "\n", "            ", "x", "[", "i", "]", "=", "rotation", "(", "images", "[", "i", "]", ")", "\n", "\n", "", "y", "=", "labels", ".", "view", "(", "-", "1", ")", "\n", "\n", "return", "TensorDataset", "(", "x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentImageFolder.__init__": [[279, 320], ["super().__init__", "sorted", "torchvision.transforms.Compose", "torchvision.transforms.Compose", "print", "enumerate", "len", "print", "os.path.join", "torchvision.datasets.ImageFolder", "datasets.MultipleEnvironmentImageFolder.datasets.append", "os.scandir", "f.is_dir", "torchvision.transforms.Resize", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize", "torchvision.transforms.RandomResizedCrop", "torchvision.transforms.RandomHorizontalFlip", "torchvision.transforms.ColorJitter", "torchvision.transforms.RandomGrayscale", "torchvision.transforms.ToTensor", "torchvision.transforms.Normalize"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "test_envs", ",", "augment", ",", "hparams", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "environments", "=", "[", "f", ".", "name", "for", "f", "in", "os", ".", "scandir", "(", "root", ")", "if", "f", ".", "is_dir", "(", ")", "]", "\n", "self", ".", "environments", "=", "sorted", "(", "self", ".", "environments", ")", "\n", "transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "Resize", "(", "(", "224", ",", "224", ")", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "\n", "mean", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", ",", "std", "=", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", "\n", "]", ")", "\n", "\n", "augment_transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "# transforms.Resize((224,224)),", "\n", "transforms", ".", "RandomResizedCrop", "(", "224", ",", "scale", "=", "(", "0.7", ",", "1.0", ")", ")", ",", "\n", "transforms", ".", "RandomHorizontalFlip", "(", ")", ",", "\n", "transforms", ".", "ColorJitter", "(", "0.3", ",", "0.3", ",", "0.3", ",", "0.3", ")", ",", "\n", "transforms", ".", "RandomGrayscale", "(", ")", ",", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "transforms", ".", "Normalize", "(", "\n", "mean", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", ",", "std", "=", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", ",", "\n", "]", ")", "\n", "\n", "self", ".", "datasets", "=", "[", "]", "\n", "print", "(", "\"enviroments:\"", ",", "self", ".", "environments", ")", "\n", "for", "i", ",", "environment", "in", "enumerate", "(", "self", ".", "environments", ")", ":", "\n", "\n", "            ", "if", "augment", "and", "(", "i", "not", "in", "test_envs", ")", ":", "\n", "                ", "env_transform", "=", "augment_transform", "\n", "", "else", ":", "\n", "                ", "env_transform", "=", "transform", "\n", "\n", "", "path", "=", "os", ".", "path", ".", "join", "(", "root", ",", "environment", ")", "\n", "env_dataset", "=", "ImageFolder", "(", "path", ",", "\n", "transform", "=", "env_transform", ")", "\n", "\n", "self", ".", "datasets", ".", "append", "(", "env_dataset", ")", "\n", "\n", "\n", "", "self", ".", "input_shape", "=", "(", "3", ",", "224", ",", "224", ",", ")", "\n", "self", ".", "num_classes", "=", "len", "(", "self", ".", "datasets", "[", "-", "1", "]", ".", "classes", ")", "\n", "print", "(", "\"number of classes:\"", ",", "self", ".", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentImageFolder.__getitem__": [[321, 323], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "datasets", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentImageFolder.__len__": [[324, 326], ["len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.VLCS.__init__": [[331, 334], ["os.path.join", "datasets.MultipleEnvironmentImageFolder.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "bias", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "self", ".", "dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"VLCS/\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "dir", ",", "test_envs", ",", "hparams", "[", "'data_augmentation'", "]", ",", "hparams", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.PACS.__init__": [[340, 343], ["os.path.join", "datasets.MultipleEnvironmentImageFolder.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "bias", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "self", ".", "dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"PACS/\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "dir", ",", "test_envs", ",", "hparams", "[", "'data_augmentation'", "]", ",", "hparams", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.DomainNet.__init__": [[349, 352], ["os.path.join", "datasets.MultipleEnvironmentImageFolder.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "self", ".", "dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"domain_net/\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "dir", ",", "test_envs", ",", "hparams", "[", "'data_augmentation'", "]", ",", "hparams", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.OfficeHome.__init__": [[358, 361], ["os.path.join", "datasets.MultipleEnvironmentImageFolder.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "bias", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "self", ".", "dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"officehome/\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "dir", ",", "test_envs", ",", "hparams", "[", "'data_augmentation'", "]", ",", "hparams", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.TerraIncognita.__init__": [[367, 370], ["os.path.join", "datasets.MultipleEnvironmentImageFolder.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "root", ",", "test_envs", ",", "hparams", ")", ":", "\n", "        ", "self", ".", "dir", "=", "os", ".", "path", ".", "join", "(", "root", ",", "\"terra_incognita/\"", ")", "\n", "super", "(", ")", ".", "__init__", "(", "self", ".", "dir", ",", "test_envs", ",", "hparams", "[", "'data_augmentation'", "]", ",", "hparams", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentCOCO.__init__": [[377, 433], ["super().__init__", "torch.FloatTensor", "torch.randint().float", "os.path.join", "os.path.join", "os.path.join", "h5py.File", "h5py.File", "h5py.File", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "print", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.randperm", "len", "range", "os.path.join", "h5py.File", "print", "torch.from_numpy", "len", "len", "datasets.MultipleEnvironmentCOCO.datasets.append", "torch.randint", "dataset_transform", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["    ", "def", "__init__", "(", "self", ",", "environments", ",", "dataset_transform", ",", "input_shape", ",", "\n", "num_classes", ",", "places", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "colors", "=", "torch", ".", "FloatTensor", "(", "\n", "[", "[", "0", ",", "100", ",", "0", "]", ",", "[", "188", ",", "143", ",", "143", "]", ",", "[", "255", ",", "0", ",", "0", "]", ",", "[", "255", ",", "215", ",", "0", "]", ",", "[", "0", ",", "255", ",", "0", "]", ",", "[", "65", ",", "105", ",", "225", "]", ",", "[", "0", ",", "225", ",", "225", "]", ",", "\n", "[", "0", ",", "0", ",", "255", "]", ",", "[", "255", ",", "20", ",", "147", "]", ",", "[", "180", ",", "180", ",", "180", "]", "]", ")", "\n", "self", ".", "random_colors", "=", "torch", ".", "randint", "(", "255", ",", "(", "10", ",", "3", ")", ")", ".", "float", "(", ")", "\n", "h5pyfname", "=", "'../data/coco'", "\n", "train_file", "=", "os", ".", "path", ".", "join", "(", "h5pyfname", ",", "'train.h5py'", ")", "\n", "val_file", "=", "os", ".", "path", ".", "join", "(", "h5pyfname", ",", "'validtest.h5py'", ")", "\n", "test_file", "=", "os", ".", "path", ".", "join", "(", "h5pyfname", ",", "'idtest.h5py'", ")", "\n", "train_data", "=", "h5py", ".", "File", "(", "train_file", ",", "'r'", ")", "\n", "val_data", "=", "h5py", ".", "File", "(", "val_file", ",", "'r'", ")", "\n", "test_data", "=", "h5py", ".", "File", "(", "test_file", ",", "'r'", ")", "\n", "original_images", "=", "np", ".", "concatenate", "(", "\n", "(", "train_data", "[", "'resized_images'", "]", ".", "value", ",", "test_data", "[", "'resized_images'", "]", ".", "value", ",", "val_data", "[", "'resized_images'", "]", ".", "value", ")", ",", "\n", "axis", "=", "0", ")", "\n", "original_labels", "=", "np", ".", "concatenate", "(", "(", "train_data", "[", "'y'", "]", ".", "value", ",", "test_data", "[", "'y'", "]", ".", "value", ",", "val_data", "[", "'y'", "]", ".", "value", ")", ",", "axis", "=", "0", ")", "\n", "\n", "original_masks", "=", "np", ".", "concatenate", "(", "\n", "(", "train_data", "[", "'resized_mask'", "]", ".", "value", ",", "test_data", "[", "'resized_mask'", "]", ".", "value", ",", "val_data", "[", "'resized_mask'", "]", ".", "value", ")", ",", "axis", "=", "0", ")", "\n", "\n", "print", "(", "'image size:{}, label size:{}, mask:{}'", ".", "format", "(", "original_images", ".", "shape", ",", "original_labels", ".", "shape", ",", "\n", "original_masks", ".", "shape", ")", ")", "\n", "\n", "if", "places", ":", "\n", "            ", "places_file", "=", "os", ".", "path", ".", "join", "(", "'../data/places/cocoplaces'", ",", "'places.h5py'", ")", "\n", "places_data", "=", "h5py", ".", "File", "(", "places_file", ",", "'r'", ")", "\n", "self", ".", "places", "=", "places_data", "[", "'resized_place'", "]", ".", "value", "\n", "print", "(", "'place size:{}'", ".", "format", "(", "self", ".", "places", ".", "shape", ")", ")", "\n", "self", ".", "places", "=", "torch", ".", "from_numpy", "(", "self", ".", "places", ")", "\n", "\n", "", "original_images", "=", "torch", ".", "from_numpy", "(", "original_images", ")", "\n", "original_labels", "=", "torch", ".", "from_numpy", "(", "original_labels", ")", "\n", "original_masks", "=", "torch", ".", "from_numpy", "(", "original_masks", ")", "\n", "shuffle", "=", "torch", ".", "randperm", "(", "len", "(", "original_images", ")", ")", "\n", "\n", "total_len", "=", "len", "(", "original_images", ")", "\n", "\n", "original_images", "=", "original_images", "[", "shuffle", "]", "\n", "original_labels", "=", "original_labels", "[", "shuffle", "]", "\n", "original_masks", "=", "original_masks", "[", "shuffle", "]", "\n", "self", ".", "datasets", "=", "[", "]", "\n", "self", ".", "environments", "=", "environments", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "environments", ")", ")", ":", "\n", "            ", "images", "=", "original_images", "[", "i", ":", ":", "len", "(", "self", ".", "environments", ")", "]", "\n", "labels", "=", "original_labels", "[", "i", ":", ":", "len", "(", "self", ".", "environments", ")", "]", "\n", "masks", "=", "original_masks", "[", "i", ":", ":", "len", "(", "self", ".", "environments", ")", "]", "\n", "#             images = original_images", "\n", "#             labels = original_labels", "\n", "#   masks = original_masks", "\n", "self", ".", "datasets", ".", "append", "(", "dataset_transform", "(", "images", ",", "labels", ",", "masks", ",", "environments", "[", "i", "]", ")", ")", "\n", "\n", "", "self", ".", "input_shape", "=", "input_shape", "\n", "self", ".", "num_classes", "=", "num_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentCOCO.__getitem__": [[434, 436], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "index", ")", ":", "\n", "        ", "return", "self", ".", "datasets", "[", "index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.MultipleEnvironmentCOCO.__len__": [[437, 439], ["len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "datasets", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.__init__": [[442, 471], ["int", "print", "datasets.MultipleEnvironmentCOCO.__init__", "torch.randint", "int", "int", "int", "int", "int", "int", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint", "torch.randint"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "root", ",", "bias", ",", "test_envs", ",", "hparams", ")", ":", "\n", "# config setting:", "\n", "# 0: random seed for shuffle places;", "\n", "# 1: use default places or random places (deprecated in ScencCOCO);", "\n", "# 2: Bernoulli parameters for places;", "\n", "# 3: designated places number,", "\n", "# 4: random seed for digit colors", "\n", "# 5: using places? 6: Color digit?", "\n", "# 7: Bernoulli parameters for bkgd colors", "\n", "# 8: removing data-augmentation or not", "\n", "\n", "        ", "seed", "=", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", "\n", "if", "hparams", "[", "'shift'", "]", "==", "0", ":", "\n", "            ", "config", "=", "[", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "seed", ",", "True", ",", "False", ",", "0", ",", "True", "]", ",", "\n", "[", "seed", ",", "True", ",", "0.9", ",", "None", ",", "seed", ",", "True", ",", "False", ",", "0", ",", "False", "]", ",", "\n", "[", "seed", ",", "True", ",", "bias", ",", "None", ",", "seed", ",", "True", ",", "False", ",", "0", ",", "False", "]", "]", "\n", "", "if", "hparams", "[", "'shift'", "]", "==", "1", ":", "\n", "            ", "config", "=", "[", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "False", ",", "True", ",", "0", ",", "True", "]", ",", "\n", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "False", ",", "True", ",", "0", ",", "False", "]", ",", "\n", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "False", ",", "True", ",", "0", ",", "False", "]", "]", "\n", "", "if", "hparams", "[", "'shift'", "]", "==", "2", ":", "\n", "            ", "config", "=", "[", "[", "seed", ",", "True", ",", "0", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "True", ",", "True", ",", "0", ",", "True", "]", ",", "\n", "[", "seed", ",", "True", ",", "0.9", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "True", ",", "True", ",", "0", ",", "False", "]", ",", "\n", "[", "seed", ",", "True", ",", "bias", ",", "None", ",", "int", "(", "torch", ".", "randint", "(", "100", ",", "[", "1", "]", ")", "[", "0", "]", ")", ",", "True", ",", "True", ",", "0", ",", "False", "]", "]", "\n", "", "print", "(", "\"config:\"", ",", "config", ")", "\n", "self", ".", "vis", "=", "False", "\n", "self", ".", "input_shape", "=", "(", "3", ",", "64", ",", "64", ",", ")", "\n", "self", ".", "num_classes", "=", "10", "\n", "super", "(", "SceneCOCO", ",", "self", ")", ".", "__init__", "(", "config", ",", "self", ".", "color_dataset", ",", "(", "3", ",", "64", ",", "64", ",", ")", ",", "10", ",", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.color_dataset": [[472, 546], ["torch.cuda.initial_seed", "torch.manual_seed", "range", "torch.manual_seed", "datasets.SceneCOCO.torch_bernoulli_", "print", "torch.manual_seed", "torch.randperm", "torch.manual_seed", "datasets.SceneCOCO.torch_bernoulli_", "torch.manual_seed", "len", "range", "print", "images.float", "labels.view().long", "domainbed.utils.TensorDataset", "len", "torch.randperm", "len", "len", "sum", "len", "len", "torch.empty", "domainbed.utils.save_image", "print", "exit", "len", "range", "labels.view", "torch.randint", "torch.randint", "obj_colors[].view", "obj_colors[].view", "int", "int", "labels[].long"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.torch_bernoulli_", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.torch_bernoulli_", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.utils.save_image", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "color_dataset", "(", "self", ",", "images", ",", "labels", ",", "masks", ",", "environment", ")", ":", "\n", "\n", "# shuffle the colors", "\n", "        ", "original_seed", "=", "torch", ".", "cuda", ".", "initial_seed", "(", ")", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "0", "]", ")", "\n", "# inter-class shuffleing", "\n", "for", "i", "in", "range", "(", "len", "(", "self", ".", "places", ")", ")", ":", "\n", "            ", "shuffle", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "places", "[", "i", "]", ")", ")", "\n", "self", ".", "places", "[", "i", "]", "=", "self", ".", "places", "[", "i", "]", "[", "shuffle", "]", "\n", "", "places", "=", "self", ".", "places", "[", ":", "10", "]", "\n", "# set the bernoulli r.v.", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "0", "]", ")", "\n", "ber", "=", "self", ".", "torch_bernoulli_", "(", "environment", "[", "2", "]", ",", "len", "(", "labels", ")", ")", "\n", "print", "(", "\"bernoulli:\"", ",", "len", "(", "ber", ")", ",", "sum", "(", "ber", ")", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "4", "]", ")", "\n", "shuffle", "=", "torch", ".", "randperm", "(", "len", "(", "self", ".", "colors", ")", ")", "\n", "obj_colors", "=", "self", ".", "colors", "[", "shuffle", "]", "\n", "# obj_colors = torch.randint(255, (10, 3)).float()", "\n", "torch", ".", "manual_seed", "(", "environment", "[", "4", "]", ")", "\n", "ber_obj", "=", "self", ".", "torch_bernoulli_", "(", "environment", "[", "7", "]", ",", "len", "(", "labels", ")", ")", "\n", "\n", "torch", ".", "manual_seed", "(", "original_seed", ")", "\n", "total_len", "=", "len", "(", "images", ")", "\n", "label_counter", "=", "[", "0", "for", "i", "in", "range", "(", "10", ")", "]", "\n", "if", "self", ".", "vis", ":", "\n", "            ", "image_collect", "=", "torch", ".", "empty", "(", "20", ",", "*", "self", ".", "input_shape", ")", "\n", "current_label", "=", "0", "\n", "current_cnt", "=", "0", "\n", "total_cnt", "=", "0", "\n", "\n", "# Apply the color to the image", "\n", "", "for", "img_idx", "in", "range", "(", "total_len", ")", ":", "\n", "            ", "if", "ber", "[", "img_idx", "]", ">", "0", ":", "\n", "                ", "if", "environment", "[", "5", "]", ":", "\n", "                    ", "label", "=", "labels", "[", "img_idx", "]", "\n", "place_img", "=", "places", "[", "label", ",", "int", "(", "label_counter", "[", "label", "]", ")", "]", "*", "0.75", "\n", "images", "[", "img_idx", "]", "=", "place_img", "*", "(", "1", "-", "masks", "[", "img_idx", "]", ")", "+", "images", "[", "img_idx", "]", "*", "masks", "[", "img_idx", "]", "\n", "label_counter", "[", "label", "]", "+=", "1", "\n", "", "", "else", ":", "\n", "                ", "if", "environment", "[", "5", "]", ":", "\n", "                    ", "label", "=", "torch", ".", "randint", "(", "10", ",", "[", "1", "]", ")", "[", "0", "]", "if", "environment", "[", "3", "]", "is", "None", "else", "environment", "[", "3", "]", "\n", "place_img", "=", "places", "[", "label", ",", "int", "(", "label_counter", "[", "label", "]", ")", "]", "*", "0.75", "\n", "images", "[", "img_idx", "]", "=", "place_img", "*", "(", "1", "-", "masks", "[", "img_idx", "]", ")", "+", "images", "[", "img_idx", "]", "*", "masks", "[", "img_idx", "]", "\n", "label_counter", "[", "label", "]", "+=", "1", "\n", "", "", "if", "ber_obj", "[", "img_idx", "]", ">", "0", ":", "\n", "                ", "if", "environment", "[", "6", "]", ":", "\n", "                    ", "images", "[", "img_idx", "]", "=", "images", "[", "img_idx", "]", "*", "(", "1", "-", "masks", "[", "img_idx", "]", ")", "+", "images", "[", "img_idx", "]", "*", "masks", "[", "img_idx", "]", "*", "obj_colors", "[", "labels", "[", "img_idx", "]", ".", "long", "(", ")", "]", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "/", "255.0", "\n", "", "", "else", ":", "\n", "                ", "if", "environment", "[", "6", "]", ":", "\n", "                    ", "color", "=", "torch", ".", "randint", "(", "5", ",", "[", "1", "]", ")", "[", "0", "]", "\n", "images", "[", "img_idx", "]", "=", "images", "[", "img_idx", "]", "*", "(", "1", "-", "masks", "[", "img_idx", "]", ")", "+", "images", "[", "img_idx", "]", "*", "masks", "[", "img_idx", "]", "*", "obj_colors", "[", "color", "]", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "/", "255.0", "\n", "", "", "if", "self", ".", "vis", ":", "\n", "                ", "if", "labels", "[", "img_idx", "]", "!=", "current_label", ":", "\n", "                    ", "continue", "\n", "# visualize 20 images for sanity check", "\n", "", "import", "matplotlib", ".", "pyplot", "as", "plt", "\n", "image_collect", "[", "total_cnt", "]", "=", "images", "[", "img_idx", "]", "\n", "current_cnt", "+=", "1", "\n", "total_cnt", "+=", "1", "\n", "if", "current_cnt", "==", "2", ":", "\n", "                    ", "current_cnt", "=", "0", "\n", "current_label", "+=", "1", "\n", "", "if", "total_cnt", "==", "20", ":", "\n", "                    ", "break", "\n", "", "", "", "if", "self", ".", "vis", ":", "\n", "            ", "save_image", "(", "image_collect", ",", "'scenecoco_combined_test.png'", ",", "nrow", "=", "10", ")", "\n", "print", "(", "f\"Visualization for {environment} Done\"", ")", "\n", "exit", "(", "0", ")", "\n", "", "print", "(", "\"label cnt:\"", ",", "label_counter", ")", "\n", "x", "=", "images", ".", "float", "(", ")", "\n", "y", "=", "labels", ".", "view", "(", "-", "1", ")", ".", "long", "(", ")", "\n", "\n", "return", "TensorDataset", "(", "environment", "[", "8", "]", ",", "x", ",", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.torch_bernoulli_": [[547, 549], ["torch.rand"], "methods", ["None"], ["", "def", "torch_bernoulli_", "(", "self", ",", "p", ",", "size", ")", ":", "\n", "        ", "return", "(", "torch", ".", "rand", "(", "size", ")", "<", "p", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.SceneCOCO.torch_xor_": [[550, 552], ["None"], "methods", ["None"], ["", "def", "torch_xor_", "(", "self", ",", "a", ",", "b", ")", ":", "\n", "        ", "return", "(", "a", "-", "b", ")", ".", "abs", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.datasets.get_dataset_class": [[53, 58], ["globals", "NotImplementedError", "globals"], "function", ["None"], ["def", "get_dataset_class", "(", "dataset_name", ")", ":", "\n", "    ", "\"\"\"Return the dataset class with the given name.\"\"\"", "\n", "if", "dataset_name", "not", "in", "globals", "(", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"Dataset not found: {}\"", ".", "format", "(", "dataset_name", ")", ")", "\n", "", "return", "globals", "(", ")", "[", "dataset_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms._SplitDataset.__init__": [[78, 82], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "underlying_dataset", ",", "keys", ")", ":", "\n", "        ", "super", "(", "_SplitDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "underlying_dataset", "=", "underlying_dataset", "\n", "self", ".", "keys", "=", "keys", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms._SplitDataset.__getitem__": [[83, 85], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "self", ".", "underlying_dataset", "[", "self", ".", "keys", "[", "key", "]", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms._SplitDataset.__len__": [[86, 88], ["len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.Tee.__init__": [[152, 155], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "fname", ",", "mode", "=", "\"a\"", ")", ":", "\n", "        ", "self", ".", "stdout", "=", "sys", ".", "stdout", "\n", "self", ".", "file", "=", "open", "(", "fname", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.Tee.write": [[156, 160], ["ms.Tee.stdout.write", "ms.Tee.file.write", "ms.Tee.flush"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.write", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.write", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush"], ["", "def", "write", "(", "self", ",", "message", ")", ":", "\n", "        ", "self", ".", "stdout", ".", "write", "(", "message", ")", "\n", "self", ".", "file", ".", "write", "(", "message", ")", "\n", "self", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.Tee.flush": [[161, 164], ["ms.Tee.stdout.flush", "ms.Tee.file.flush"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "self", ".", "stdout", ".", "flush", "(", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.make_weights_for_balanced_classes": [[19, 38], ["collections.Counter", "len", "torch.zeros", "torch.zeros", "enumerate", "int", "classes.append", "len", "int"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["def", "make_weights_for_balanced_classes", "(", "dataset", ")", ":", "\n", "    ", "counts", "=", "Counter", "(", ")", "\n", "classes", "=", "[", "]", "\n", "for", "_", ",", "y", "in", "dataset", ":", "\n", "        ", "y", "=", "int", "(", "y", ")", "\n", "counts", "[", "y", "]", "+=", "1", "\n", "classes", ".", "append", "(", "y", ")", "\n", "\n", "", "n_classes", "=", "len", "(", "counts", ")", "\n", "\n", "weight_per_class", "=", "{", "}", "\n", "for", "y", "in", "counts", ":", "\n", "        ", "weight_per_class", "[", "y", "]", "=", "1", "/", "(", "counts", "[", "y", "]", "*", "n_classes", ")", "\n", "\n", "", "weights", "=", "torch", ".", "zeros", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "y", "in", "enumerate", "(", "classes", ")", ":", "\n", "        ", "weights", "[", "i", "]", "=", "weight_per_class", "[", "int", "(", "y", ")", "]", "\n", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.pdb": [[40, 45], ["print", "pdb.set_trace"], "function", ["None"], ["", "def", "pdb", "(", ")", ":", "\n", "    ", "sys", ".", "stdout", "=", "sys", ".", "__stdout__", "\n", "import", "pdb", "\n", "print", "(", "\"Launching PDB, enter 'n' to step to parent function.\"", ")", "\n", "pdb", ".", "set_trace", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.seed_hash": [[47, 53], ["str", "int", "hashlib.md5().hexdigest", "hashlib.md5", "str.encode"], "function", ["None"], ["", "def", "seed_hash", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"\n    Derive an integer hash from all args, for use as a random seed.\n    \"\"\"", "\n", "args_str", "=", "str", "(", "args", ")", "\n", "return", "int", "(", "hashlib", ".", "md5", "(", "args_str", ".", "encode", "(", "\"utf-8\"", ")", ")", ".", "hexdigest", "(", ")", ",", "16", ")", "%", "(", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.print_separator": [[55, 57], ["print"], "function", ["None"], ["", "def", "print_separator", "(", ")", ":", "\n", "    ", "print", "(", "\"=\"", "*", "80", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.print_row": [[59, 73], ["print", "numpy.issubdtype", "sep.join", "type", "str().ljust", "ms.print_row.format_val"], "function", ["None"], ["", "def", "print_row", "(", "row", ",", "colwidth", "=", "10", ",", "latex", "=", "False", ")", ":", "\n", "    ", "if", "latex", ":", "\n", "        ", "sep", "=", "\" & \"", "\n", "end_", "=", "\"\\\\\\\\\"", "\n", "", "else", ":", "\n", "        ", "sep", "=", "\"  \"", "\n", "end_", "=", "\"\"", "\n", "\n", "", "def", "format_val", "(", "x", ")", ":", "\n", "        ", "if", "np", ".", "issubdtype", "(", "type", "(", "x", ")", ",", "np", ".", "floating", ")", ":", "\n", "            ", "x", "=", "\"{:.10f}\"", ".", "format", "(", "x", ")", "\n", "", "return", "str", "(", "x", ")", ".", "ljust", "(", "colwidth", ")", "[", ":", "colwidth", "]", "\n", "\n", "", "print", "(", "sep", ".", "join", "(", "[", "format_val", "(", "x", ")", "for", "x", "in", "row", "]", ")", ",", "end_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.split_dataset": [[90, 102], ["list", "numpy.random.RandomState().shuffle", "len", "range", "ms._SplitDataset", "ms._SplitDataset", "len", "numpy.random.RandomState"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "", "def", "split_dataset", "(", "dataset", ",", "n", ",", "seed", "=", "0", ")", ":", "\n", "    ", "\"\"\"\n    Return a pair of datasets corresponding to a random split of the given\n    dataset, with n datapoints in the first dataset and the rest in the last,\n    using the given random seed\n    \"\"\"", "\n", "assert", "(", "n", "<=", "len", "(", "dataset", ")", ")", "\n", "keys", "=", "list", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ".", "shuffle", "(", "keys", ")", "\n", "keys_1", "=", "keys", "[", ":", "n", "]", "\n", "keys_2", "=", "keys", "[", "n", ":", "]", "\n", "return", "_SplitDataset", "(", "dataset", ",", "keys_1", ")", ",", "_SplitDataset", "(", "dataset", ",", "keys_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.random_pairs_of_minibatches": [[104, 119], ["torch.randperm().tolist", "torch.randperm().tolist", "range", "len", "min", "pairs.append", "torch.randperm", "torch.randperm", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "random_pairs_of_minibatches", "(", "minibatches", ")", ":", "\n", "    ", "perm", "=", "torch", ".", "randperm", "(", "len", "(", "minibatches", ")", ")", ".", "tolist", "(", ")", "\n", "pairs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "minibatches", ")", ")", ":", "\n", "        ", "j", "=", "i", "+", "1", "if", "i", "<", "(", "len", "(", "minibatches", ")", "-", "1", ")", "else", "0", "\n", "\n", "xi", ",", "yi", "=", "minibatches", "[", "perm", "[", "i", "]", "]", "[", "0", "]", ",", "minibatches", "[", "perm", "[", "i", "]", "]", "[", "1", "]", "\n", "xj", ",", "yj", "=", "minibatches", "[", "perm", "[", "j", "]", "]", "[", "0", "]", ",", "minibatches", "[", "perm", "[", "j", "]", "]", "[", "1", "]", "\n", "\n", "min_n", "=", "min", "(", "len", "(", "xi", ")", ",", "len", "(", "xj", ")", ")", "\n", "\n", "pairs", ".", "append", "(", "(", "(", "xi", "[", ":", "min_n", "]", ",", "yi", "[", ":", "min_n", "]", ")", ",", "(", "xj", "[", ":", "min_n", "]", ",", "yj", "[", ":", "min_n", "]", ")", ")", ")", "\n", "\n", "", "return", "pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.ms.accuracy": [[121, 149], ["network.eval", "network.train", "torch.no_grad", "torch.no_grad", "x.to.to", "y.to.to", "torch.softmax", "range", "torch.ones.cuda", "torch.ones.sum().item", "network.predict", "torch.softmax", "torch.ones", "torch.ones", "len", "F.softmax.size", "network.predict", "len", "torch.ones.sum", "len", "F.softmax.gt().eq().float", "F.softmax.argmax().eq().float", "F.softmax.gt().eq", "F.softmax.argmax().eq", "F.softmax.gt", "F.softmax.argmax"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.predict", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.predict", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.argmax"], ["", "def", "accuracy", "(", "network", ",", "loader", ",", "weights", ",", "device", ",", "nidx", "=", "None", ",", "n_num", "=", "1", ")", ":", "\n", "    ", "correct", "=", "0", "\n", "total", "=", "0", "\n", "weights_offset", "=", "0", "\n", "\n", "network", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "x", ",", "y", "in", "loader", ":", "\n", "            ", "x", "=", "x", ".", "to", "(", "device", ")", "\n", "y", "=", "y", ".", "to", "(", "device", ")", "\n", "\n", "p", "=", "F", ".", "softmax", "(", "network", ".", "predict", "(", "x", ",", "0", ")", ",", "dim", "=", "1", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "n_num", ")", ":", "\n", "                ", "p", "*=", "F", ".", "softmax", "(", "network", ".", "predict", "(", "x", ",", "i", ")", ",", "dim", "=", "1", ")", "\n", "", "if", "weights", "is", "None", ":", "\n", "                ", "batch_weights", "=", "torch", ".", "ones", "(", "len", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "                ", "batch_weights", "=", "weights", "[", "weights_offset", ":", "weights_offset", "+", "len", "(", "x", ")", "]", "\n", "weights_offset", "+=", "len", "(", "x", ")", "\n", "", "batch_weights", "=", "batch_weights", ".", "cuda", "(", ")", "\n", "if", "p", ".", "size", "(", "1", ")", "==", "1", ":", "\n", "                ", "correct", "+=", "(", "p", ".", "gt", "(", "0", ")", ".", "eq", "(", "y", ")", ".", "float", "(", ")", "*", "batch_weights", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "                ", "correct", "+=", "(", "p", ".", "argmax", "(", "1", ")", ".", "eq", "(", "y", ")", ".", "float", "(", ")", "*", "batch_weights", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "total", "+=", "batch_weights", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", "network", ".", "train", "(", ")", "\n", "\n", "return", "correct", "/", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader._InfiniteSampler.__init__": [[7, 9], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "sampler", ")", ":", "\n", "        ", "self", ".", "sampler", "=", "sampler", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader._InfiniteSampler.__iter__": [[10, 14], ["None"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "for", "batch", "in", "self", ".", "sampler", ":", "\n", "                ", "yield", "batch", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader.InfiniteDataLoader.__init__": [[16, 39], ["super().__init__", "torch.utils.data.BatchSampler", "iter", "torch.utils.data.WeightedRandomSampler", "torch.utils.data.RandomSampler", "torch.ones", "torch.utils.data.DataLoader", "len", "fast_data_loader._InfiniteSampler"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "weights", ",", "batch_size", ",", "num_workers", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "weights", ":", "\n", "            ", "sampler", "=", "torch", ".", "utils", ".", "data", ".", "WeightedRandomSampler", "(", "weights", ",", "\n", "replacement", "=", "True", ",", "\n", "num_samples", "=", "batch_size", ")", "\n", "", "else", ":", "\n", "            ", "sampler", "=", "torch", ".", "utils", ".", "data", ".", "RandomSampler", "(", "dataset", ",", "\n", "replacement", "=", "True", ")", "\n", "\n", "", "if", "weights", "==", "None", ":", "\n", "            ", "weights", "=", "torch", ".", "ones", "(", "len", "(", "dataset", ")", ")", "\n", "\n", "", "batch_sampler", "=", "torch", ".", "utils", ".", "data", ".", "BatchSampler", "(", "\n", "sampler", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "drop_last", "=", "True", ")", "\n", "\n", "self", ".", "_infinite_iterator", "=", "iter", "(", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "batch_sampler", "=", "_InfiniteSampler", "(", "batch_sampler", ")", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader.InfiniteDataLoader.__iter__": [[41, 44], ["next"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "yield", "next", "(", "self", ".", "_infinite_iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader.InfiniteDataLoader.__len__": [[45, 47], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "raise", "ValueError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader.FastDataLoader.__init__": [[51, 67], ["super().__init__", "torch.utils.data.BatchSampler", "iter", "len", "torch.utils.data.RandomSampler", "torch.utils.data.DataLoader", "fast_data_loader._InfiniteSampler"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["def", "__init__", "(", "self", ",", "dataset", ",", "batch_size", ",", "num_workers", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "batch_sampler", "=", "torch", ".", "utils", ".", "data", ".", "BatchSampler", "(", "\n", "torch", ".", "utils", ".", "data", ".", "RandomSampler", "(", "dataset", ",", "replacement", "=", "False", ")", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "drop_last", "=", "False", "\n", ")", "\n", "\n", "self", ".", "_infinite_iterator", "=", "iter", "(", "torch", ".", "utils", ".", "data", ".", "DataLoader", "(", "\n", "dataset", ",", "\n", "num_workers", "=", "num_workers", ",", "\n", "batch_sampler", "=", "_InfiniteSampler", "(", "batch_sampler", ")", "\n", ")", ")", "\n", "\n", "self", ".", "_length", "=", "len", "(", "batch_sampler", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader.FastDataLoader.__iter__": [[68, 71], ["range", "len", "next"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "for", "_", "in", "range", "(", "len", "(", "self", ")", ")", ":", "\n", "            ", "yield", "next", "(", "self", ".", "_infinite_iterator", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.fast_data_loader.FastDataLoader.__len__": [[72, 74], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_length", "", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.__init__": [[54, 57], ["object.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "list_", ")", ":", "\n", "        ", "super", "(", "Q", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_list", "=", "list_", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.__len__": [[58, 60], ["query.Q.len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.__getitem__": [[61, 63], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "self", ".", "_list", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.__eq__": [[64, 69], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "isinstance", "(", "other", ",", "self", ".", "__class__", ")", ":", "\n", "            ", "return", "self", ".", "_list", "==", "other", ".", "_list", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_list", "==", "other", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.__str__": [[70, 72], ["str"], "methods", ["None"], ["", "", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "return", "str", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.__repr__": [[73, 75], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q._append": [[76, 79], ["query.Q._list.append"], "methods", ["None"], ["", "def", "_append", "(", "self", ",", "item", ")", ":", "\n", "        ", "\"\"\"Unsafe, be careful you know what you're doing.\"\"\"", "\n", "self", ".", "_list", ".", "append", "(", "item", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.group": [[80, 95], ["query.make_selector_fn", "query.Q", "make_selector_fn.", "query.hashable", "[]._append", "query.Q.sorted"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.hashable", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q._append", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted"], ["", "def", "group", "(", "self", ",", "selector", ")", ":", "\n", "        ", "\"\"\"\n        Group elements by selector and return a list of (group, group_records)\n        tuples.\n        \"\"\"", "\n", "selector", "=", "make_selector_fn", "(", "selector", ")", "\n", "groups", "=", "{", "}", "\n", "for", "x", "in", "self", ".", "_list", ":", "\n", "            ", "group", "=", "selector", "(", "x", ")", "\n", "group_key", "=", "hashable", "(", "group", ")", "\n", "if", "group_key", "not", "in", "groups", ":", "\n", "                ", "groups", "[", "group_key", "]", "=", "(", "group", ",", "Q", "(", "[", "]", ")", ")", "\n", "", "groups", "[", "group_key", "]", "[", "1", "]", ".", "_append", "(", "x", ")", "\n", "", "results", "=", "[", "groups", "[", "key", "]", "for", "key", "in", "sorted", "(", "groups", ".", "keys", "(", ")", ")", "]", "\n", "return", "Q", "(", "results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.group_map": [[96, 102], ["query.Q.group().map", "query.Q.group"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.map", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.group"], ["", "def", "group_map", "(", "self", ",", "selector", ",", "fn", ")", ":", "\n", "        ", "\"\"\"\n        Group elements by selector, apply fn to each group, and return a list\n        of the results.\n        \"\"\"", "\n", "return", "self", ".", "group", "(", "selector", ")", ".", "map", "(", "fn", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.map": [[103, 112], ["query.Q.len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "map", "(", "self", ",", "fn", ")", ":", "\n", "        ", "\"\"\"\n        map self onto fn. If fn takes multiple args, tuple-unpacking\n        is applied.\n        \"\"\"", "\n", "if", "len", "(", "inspect", ".", "signature", "(", "fn", ")", ".", "parameters", ")", ">", "1", ":", "\n", "            ", "return", "Q", "(", "[", "fn", "(", "*", "x", ")", "for", "x", "in", "self", ".", "_list", "]", ")", "\n", "", "else", ":", "\n", "            ", "return", "Q", "(", "[", "fn", "(", "x", ")", "for", "x", "in", "self", ".", "_list", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.select": [[113, 116], ["query.make_selector_fn", "query.Q", "make_selector_fn."], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn"], ["", "", "def", "select", "(", "self", ",", "selector", ")", ":", "\n", "        ", "selector", "=", "make_selector_fn", "(", "selector", ")", "\n", "return", "Q", "(", "[", "selector", "(", "x", ")", "for", "x", "in", "self", ".", "_list", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min": [[117, 119], ["query.Q.min"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min"], ["", "def", "min", "(", "self", ")", ":", "\n", "        ", "return", "min", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max": [[120, 122], ["query.Q.max"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max"], ["", "def", "max", "(", "self", ")", ":", "\n", "        ", "return", "max", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum": [[123, 125], ["query.Q.sum"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["", "def", "sum", "(", "self", ")", ":", "\n", "        ", "return", "sum", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len": [[126, 128], ["query.Q.len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "len", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean": [[129, 133], ["warnings.catch_warnings", "warnings.simplefilter", "float", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean"], ["", "def", "mean", "(", "self", ")", ":", "\n", "        ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "return", "float", "(", "np", ".", "mean", "(", "self", ".", "_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.std": [[134, 138], ["warnings.catch_warnings", "warnings.simplefilter", "float", "numpy.std"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.std"], ["", "", "def", "std", "(", "self", ")", ":", "\n", "        ", "with", "warnings", ".", "catch_warnings", "(", ")", ":", "\n", "            ", "warnings", ".", "simplefilter", "(", "\"ignore\"", ")", "\n", "return", "float", "(", "np", ".", "std", "(", "self", ".", "_list", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean_std": [[139, 141], ["query.Q.mean", "query.Q.std"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.std"], ["", "", "def", "mean_std", "(", "self", ")", ":", "\n", "        ", "return", "(", "self", ".", "mean", "(", ")", ",", "self", ".", "std", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.argmax": [[142, 145], ["query.make_selector_fn", "query.Q.max"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.max"], ["", "def", "argmax", "(", "self", ",", "selector", ")", ":", "\n", "        ", "selector", "=", "make_selector_fn", "(", "selector", ")", "\n", "return", "max", "(", "self", ".", "_list", ",", "key", "=", "selector", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter": [[146, 148], ["query.Q", "fn"], "methods", ["None"], ["", "def", "filter", "(", "self", ",", "fn", ")", ":", "\n", "        ", "return", "Q", "(", "[", "x", "for", "x", "in", "self", ".", "_list", "if", "fn", "(", "x", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter_equals": [[149, 153], ["query.make_selector_fn", "query.Q.filter", "make_selector_fn."], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter"], ["", "def", "filter_equals", "(", "self", ",", "selector", ",", "value", ")", ":", "\n", "        ", "\"\"\"like [x for x in y if x.selector == value]\"\"\"", "\n", "selector", "=", "make_selector_fn", "(", "selector", ")", "\n", "return", "self", ".", "filter", "(", "lambda", "r", ":", "selector", "(", "r", ")", "==", "value", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter_not_none": [[154, 156], ["query.Q.filter"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter"], ["", "def", "filter_not_none", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "filter", "(", "lambda", "r", ":", "r", "is", "not", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter_not_nan": [[157, 159], ["query.Q.filter", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.filter"], ["", "def", "filter_not_nan", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "filter", "(", "lambda", "r", ":", "not", "np", ".", "isnan", "(", "r", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.flatten": [[160, 162], ["query.Q"], "methods", ["None"], ["", "def", "flatten", "(", "self", ")", ":", "\n", "        ", "return", "Q", "(", "[", "y", "for", "x", "in", "self", ".", "_list", "for", "y", "in", "x", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.unique": [[163, 172], ["set", "query.Q", "query.hashable", "set.add", "result.append"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.hashable"], ["", "def", "unique", "(", "self", ")", ":", "\n", "        ", "result", "=", "[", "]", "\n", "result_set", "=", "set", "(", ")", "\n", "for", "x", "in", "self", ".", "_list", ":", "\n", "            ", "hashable_x", "=", "hashable", "(", "x", ")", "\n", "if", "hashable_x", "not", "in", "result_set", ":", "\n", "                ", "result_set", ".", "add", "(", "hashable_x", ")", "\n", "result", ".", "append", "(", "x", ")", "\n", "", "", "return", "Q", "(", "result", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted": [[173, 183], ["query.Q", "key", "query.Q.sorted"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted"], ["", "def", "sorted", "(", "self", ",", "key", "=", "None", ")", ":", "\n", "        ", "if", "key", "is", "None", ":", "\n", "            ", "key", "=", "lambda", "x", ":", "x", "\n", "", "def", "key2", "(", "x", ")", ":", "\n", "            ", "x", "=", "key", "(", "x", ")", "\n", "if", "isinstance", "(", "x", ",", "(", "np", ".", "floating", ",", "float", ")", ")", "and", "np", ".", "isnan", "(", "x", ")", ":", "\n", "                ", "return", "float", "(", "'-inf'", ")", "\n", "", "else", ":", "\n", "                ", "return", "x", "\n", "", "", "return", "Q", "(", "sorted", "(", "self", ".", "_list", ",", "key", "=", "key2", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn": [[16, 45], ["isinstance", "isinstance", "selector.split", "query.make_selector_fn", "tuple", "selector.split", "selector.strip", "query.make_selector_fn", "sel", "sel"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.make_selector_fn"], ["def", "make_selector_fn", "(", "selector", ")", ":", "\n", "    ", "\"\"\"\n    If selector is a function, return selector.\n    Otherwise, return a function corresponding to the selector string. Examples\n    of valid selector strings and the corresponding functions:\n        x       lambda obj: obj['x']\n        x.y     lambda obj: obj['x']['y']\n        x,y     lambda obj: (obj['x'], obj['y'])\n    \"\"\"", "\n", "if", "isinstance", "(", "selector", ",", "str", ")", ":", "\n", "        ", "if", "','", "in", "selector", ":", "\n", "            ", "parts", "=", "selector", ".", "split", "(", "','", ")", "\n", "part_selectors", "=", "[", "make_selector_fn", "(", "part", ")", "for", "part", "in", "parts", "]", "\n", "return", "lambda", "obj", ":", "tuple", "(", "sel", "(", "obj", ")", "for", "sel", "in", "part_selectors", ")", "\n", "", "elif", "'.'", "in", "selector", ":", "\n", "            ", "parts", "=", "selector", ".", "split", "(", "'.'", ")", "\n", "part_selectors", "=", "[", "make_selector_fn", "(", "part", ")", "for", "part", "in", "parts", "]", "\n", "def", "f", "(", "obj", ")", ":", "\n", "                ", "for", "sel", "in", "part_selectors", ":", "\n", "                    ", "obj", "=", "sel", "(", "obj", ")", "\n", "", "return", "obj", "\n", "", "return", "f", "\n", "", "else", ":", "\n", "            ", "key", "=", "selector", ".", "strip", "(", ")", "\n", "return", "lambda", "obj", ":", "obj", "[", "key", "]", "\n", "", "", "elif", "isinstance", "(", "selector", ",", "types", ".", "FunctionType", ")", ":", "\n", "        ", "return", "selector", "\n", "", "else", ":", "\n", "        ", "raise", "TypeError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.hashable": [[46, 52], ["hash", "json.dumps"], "function", ["None"], ["", "", "def", "hashable", "(", "obj", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "hash", "(", "obj", ")", "\n", "return", "obj", "\n", "", "except", "TypeError", ":", "\n", "        ", "return", "json", ".", "dumps", "(", "{", "'_'", ":", "obj", "}", ",", "sort_keys", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.wide_basic.__init__": [[38, 54], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "dropout_rate", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "wide_basic", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "in_planes", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout_rate", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "\n", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "True", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "\n", "bias", "=", "True", ")", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.wide_basic.forward": [[55, 61], ["wide_resnet.wide_basic.dropout", "wide_resnet.wide_basic.conv2", "wide_resnet.wide_basic.shortcut", "wide_resnet.wide_basic.conv1", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "wide_resnet.wide_basic.bn2", "wide_resnet.wide_basic.bn1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "dropout", "(", "self", ".", "conv1", "(", "F", ".", "relu", "(", "self", ".", "bn1", "(", "x", ")", ")", ")", ")", "\n", "out", "=", "self", ".", "conv2", "(", "F", ".", "relu", "(", "self", ".", "bn2", "(", "out", ")", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet.__init__": [[65, 87], ["torch.Module.__init__", "wide_resnet.conv3x3", "wide_resnet.Wide_ResNet._wide_layer", "wide_resnet.Wide_ResNet._wide_layer", "wide_resnet.Wide_ResNet._wide_layer", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "wide_resnet.Wide_ResNet._wide_layer", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.conv3x3", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet._wide_layer", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet._wide_layer", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet._wide_layer", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet._wide_layer"], ["def", "__init__", "(", "self", ",", "input_shape", ",", "depth", ",", "widen_factor", ",", "dropout_rate", ")", ":", "\n", "        ", "super", "(", "Wide_ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "16", "\n", "\n", "assert", "(", "(", "depth", "-", "4", ")", "%", "6", "==", "0", ")", ",", "'Wide-resnet depth should be 6n+4'", "\n", "n", "=", "(", "depth", "-", "4", ")", "/", "6", "\n", "k", "=", "widen_factor", "\n", "\n", "# print('| Wide-Resnet %dx%d' % (depth, k))", "\n", "nStages", "=", "[", "16", ",", "16", "*", "k", ",", "32", "*", "k", ",", "64", "*", "k", "]", "\n", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "input_shape", "[", "0", "]", ",", "nStages", "[", "0", "]", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_wide_layer", "(", "\n", "wide_basic", ",", "nStages", "[", "1", "]", ",", "n", ",", "dropout_rate", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_wide_layer", "(", "\n", "wide_basic", ",", "nStages", "[", "2", "]", ",", "n", ",", "dropout_rate", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_wide_layer", "(", "\n", "wide_basic", ",", "nStages", "[", "3", "]", ",", "n", ",", "dropout_rate", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "nStages", "[", "3", "]", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_wide_layer", "(", "wide_basic", ",", "nStages", "[", "3", "]", ",", "n", ",", "dropout_rate", ",", "stride", "=", "2", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "nStages", "[", "3", "]", ")", "\n", "self", ".", "n_outputs", "=", "nStages", "[", "3", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet._wide_layer": [[88, 97], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "block", "int"], "methods", ["None"], ["", "def", "_wide_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "dropout_rate", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "int", "(", "num_blocks", ")", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "dropout_rate", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.Wide_ResNet.forward": [[98, 106], ["wide_resnet.Wide_ResNet.conv1", "wide_resnet.Wide_ResNet.layer1", "wide_resnet.Wide_ResNet.layer2", "wide_resnet.Wide_ResNet.layer3", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d.view", "wide_resnet.Wide_ResNet.bn1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "out", ")", ")", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "16", ")", "\n", "return", "out", ".", "view", "(", "-", "1", ",", "self", ".", "n_outputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.conv3x3": [[17, 25], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "nn", ".", "Conv2d", "(", "\n", "in_planes", ",", "\n", "out_planes", ",", "\n", "kernel_size", "=", "3", ",", "\n", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "\n", "bias", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.wide_resnet.conv_init": [[27, 35], ["classname.find", "torch.xavier_uniform_", "torch.constant_", "classname.find", "torch.constant_", "torch.constant_", "numpy.sqrt"], "function", ["None"], ["", "def", "conv_init", "(", "m", ")", ":", "\n", "    ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "classname", ".", "find", "(", "'Conv'", ")", "!=", "-", "1", ":", "\n", "        ", "init", ".", "xavier_uniform_", "(", "m", ".", "weight", ",", "gain", "=", "np", ".", "sqrt", "(", "2", ")", ")", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "", "elif", "classname", ".", "find", "(", "'BatchNorm'", ")", "!=", "-", "1", ":", "\n", "        ", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.BasicBlock.__init__": [[28, 37], ["torch.Module.__init__", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.conv3x3", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.BasicBlock.forward": [[38, 55], ["resnet.BasicBlock.conv1", "resnet.BasicBlock.bn1", "resnet.BasicBlock.relu", "resnet.BasicBlock.conv2", "resnet.BasicBlock.bn2", "resnet.BasicBlock.relu", "resnet.BasicBlock.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.Bottleneck.__init__": [[60, 72], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "inplanes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", "*", "4", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "4", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.Bottleneck.forward": [[73, 94], ["resnet.Bottleneck.conv1", "resnet.Bottleneck.bn1", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv2", "resnet.Bottleneck.bn2", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv3", "resnet.Bottleneck.bn3", "resnet.Bottleneck.relu", "resnet.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "residual", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "residual", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "residual", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.ResNet.__init__": [[98, 120], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "resnet.ResNet._make_layer", "resnet.ResNet._make_layer", "resnet.ResNet._make_layer", "resnet.ResNet._make_layer", "torch.AvgPool2d", "torch.AvgPool2d", "torch.Linear", "torch.Linear", "resnet.ResNet.modules", "isinstance", "m.weight.data.normal_", "isinstance", "math.sqrt", "m.weight.data.fill_", "m.bias.data.zero_"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "num_classes", "=", "1000", ")", ":", "\n", "        ", "self", ".", "inplanes", "=", "64", "\n", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AvgPool2d", "(", "7", ",", "stride", "=", "1", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "num_classes", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "n", "=", "m", ".", "kernel_size", "[", "0", "]", "*", "m", ".", "kernel_size", "[", "1", "]", "*", "m", ".", "out_channels", "\n", "m", ".", "weight", ".", "data", ".", "normal_", "(", "0", ",", "math", ".", "sqrt", "(", "2.", "/", "n", ")", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "m", ".", "weight", ".", "data", ".", "fill_", "(", "1", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.ResNet._make_layer": [[121, 137], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "block"], "methods", ["None"], ["", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "\n", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "i", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.ResNet.forward": [[138, 152], ["resnet.ResNet.conv1", "resnet.ResNet.bn1", "resnet.ResNet.relu", "resnet.ResNet.maxpool", "resnet.ResNet.layer1", "resnet.ResNet.layer2", "resnet.ResNet.layer3", "resnet.ResNet.layer4", "resnet.ResNet.avgpool", "x.view.view.view", "x.view.view.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.conv3x3": [[19, 23], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"3x3 convolution with padding\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet18": [[153, 163], ["resnet.ResNet", "ResNet.load_state_dict", "torch.load_url"], "function", ["None"], ["", "", "def", "resnet18", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-18 model.\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "model_urls", "[", "'resnet18'", "]", ",", "model_dir", "=", "'../model'", ")", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet34": [[165, 175], ["resnet.ResNet", "ResNet.load_state_dict", "torch.load_url"], "function", ["None"], ["", "def", "resnet34", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-34 model.\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "BasicBlock", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "model_urls", "[", "'resnet34'", "]", ")", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet50": [[177, 187], ["resnet.ResNet", "ResNet.load_state_dict", "torch.load_url"], "function", ["None"], ["", "def", "resnet50", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-50 model.\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "model_urls", "[", "'resnet50'", "]", ",", "model_dir", "=", "'../model'", ")", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet101": [[189, 199], ["resnet.ResNet", "ResNet.load_state_dict", "torch.load_url"], "function", ["None"], ["", "def", "resnet101", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-101 model.\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "23", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "model_urls", "[", "'resnet101'", "]", ")", ")", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.resnet.resnet152": [[201, 211], ["resnet.ResNet", "ResNet.load_state_dict", "torch.load_url"], "function", ["None"], ["", "def", "resnet152", "(", "pretrained", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-152 model.\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "8", ",", "36", ",", "3", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "model", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "model_urls", "[", "'resnet152'", "]", ")", ")", "\n", "", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc._SplitDataset.__init__": [[73, 77], ["super().__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "underlying_dataset", ",", "keys", ")", ":", "\n", "        ", "super", "(", "_SplitDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "underlying_dataset", "=", "underlying_dataset", "\n", "self", ".", "keys", "=", "keys", "\n", "", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc._SplitDataset.__getitem__": [[77, 79], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "key", ")", ":", "\n", "        ", "return", "self", ".", "underlying_dataset", "[", "self", ".", "keys", "[", "key", "]", "]", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc._SplitDataset.__len__": [[79, 81], ["len"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "keys", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.__init__": [[151, 154], ["open"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "fname", ",", "mode", "=", "\"a\"", ")", ":", "\n", "        ", "self", ".", "stdout", "=", "sys", ".", "stdout", "\n", "self", ".", "file", "=", "open", "(", "fname", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.write": [[155, 159], ["misc.Tee.stdout.write", "misc.Tee.file.write", "misc.Tee.flush"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.write", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.write", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush"], ["", "def", "write", "(", "self", ",", "message", ")", ":", "\n", "        ", "self", ".", "stdout", ".", "write", "(", "message", ")", "\n", "self", ".", "file", ".", "write", "(", "message", ")", "\n", "self", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush": [[160, 163], ["misc.Tee.stdout.flush", "misc.Tee.file.flush"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.flush"], ["", "def", "flush", "(", "self", ")", ":", "\n", "        ", "self", ".", "stdout", ".", "flush", "(", ")", "\n", "self", ".", "file", ".", "flush", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__init__": [[192, 194], ["collections.OrderedDict.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "*", "args", ",", "*", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict._prototype": [[195, 202], ["isinstance", "misc.ParamDict", "isinstance", "misc.ParamDict", "op", "misc.ParamDict.items", "op"], "methods", ["None"], ["", "def", "_prototype", "(", "self", ",", "other", ",", "op", ")", ":", "\n", "        ", "if", "isinstance", "(", "other", ",", "Number", ")", ":", "\n", "            ", "return", "ParamDict", "(", "{", "k", ":", "op", "(", "v", ",", "other", ")", "for", "k", ",", "v", "in", "self", ".", "items", "(", ")", "}", ")", "\n", "", "elif", "isinstance", "(", "other", ",", "dict", ")", ":", "\n", "            ", "return", "ParamDict", "(", "{", "k", ":", "op", "(", "self", "[", "k", "]", ",", "other", "[", "k", "]", ")", "for", "k", "in", "self", "}", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__add__": [[203, 205], ["misc.ParamDict._prototype"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict._prototype"], ["", "", "def", "__add__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "_prototype", "(", "other", ",", "operator", ".", "add", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__rmul__": [[206, 208], ["misc.ParamDict._prototype"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict._prototype"], ["", "def", "__rmul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "_prototype", "(", "other", ",", "operator", ".", "mul", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__neg__": [[211, 213], ["misc.ParamDict", "misc.ParamDict.items"], "methods", ["None"], ["def", "__neg__", "(", "self", ")", ":", "\n", "        ", "return", "ParamDict", "(", "{", "k", ":", "-", "v", "for", "k", ",", "v", "in", "self", ".", "items", "(", ")", "}", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__rsub__": [[214, 217], ["misc.ParamDict.__add__", "other.__neg__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__add__", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__neg__"], ["", "def", "__rsub__", "(", "self", ",", "other", ")", ":", "\n", "# a- b := a + (-b)", "\n", "        ", "return", "self", ".", "__add__", "(", "other", ".", "__neg__", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict.__truediv__": [[220, 222], ["misc.ParamDict._prototype"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.ParamDict._prototype"], ["def", "__truediv__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "self", ".", "_prototype", "(", "other", ",", "operator", ".", "truediv", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.make_weights_for_balanced_classes": [[21, 40], ["collections.Counter", "len", "torch.zeros", "torch.zeros", "enumerate", "int", "classes.append", "len", "int"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["def", "make_weights_for_balanced_classes", "(", "dataset", ")", ":", "\n", "    ", "counts", "=", "Counter", "(", ")", "\n", "classes", "=", "[", "]", "\n", "for", "_", ",", "y", "in", "dataset", ":", "\n", "        ", "y", "=", "int", "(", "y", ")", "\n", "counts", "[", "y", "]", "+=", "1", "\n", "classes", ".", "append", "(", "y", ")", "\n", "\n", "", "n_classes", "=", "len", "(", "counts", ")", "\n", "\n", "weight_per_class", "=", "{", "}", "\n", "for", "y", "in", "counts", ":", "\n", "        ", "weight_per_class", "[", "y", "]", "=", "1", "/", "(", "counts", "[", "y", "]", "*", "n_classes", ")", "\n", "\n", "", "weights", "=", "torch", ".", "zeros", "(", "len", "(", "dataset", ")", ")", "\n", "for", "i", ",", "y", "in", "enumerate", "(", "classes", ")", ":", "\n", "        ", "weights", "[", "i", "]", "=", "weight_per_class", "[", "int", "(", "y", ")", "]", "\n", "\n", "", "return", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.pdb": [[41, 46], ["print", "pdb.set_trace"], "function", ["None"], ["", "def", "pdb", "(", ")", ":", "\n", "    ", "sys", ".", "stdout", "=", "sys", ".", "__stdout__", "\n", "import", "pdb", "\n", "print", "(", "\"Launching PDB, enter 'n' to step to parent function.\"", ")", "\n", "pdb", ".", "set_trace", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.seed_hash": [[47, 53], ["str", "int", "hashlib.md5().hexdigest", "hashlib.md5", "str.encode"], "function", ["None"], ["", "def", "seed_hash", "(", "*", "args", ")", ":", "\n", "    ", "\"\"\"\n    Derive an integer hash from all args, for use as a random seed.\n    \"\"\"", "\n", "args_str", "=", "str", "(", "args", ")", "\n", "return", "int", "(", "hashlib", ".", "md5", "(", "args_str", ".", "encode", "(", "\"utf-8\"", ")", ")", ".", "hexdigest", "(", ")", ",", "16", ")", "%", "(", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.print_separator": [[54, 56], ["print"], "function", ["None"], ["", "def", "print_separator", "(", ")", ":", "\n", "    ", "print", "(", "\"=\"", "*", "80", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.print_row": [[57, 70], ["print", "numpy.issubdtype", "sep.join", "type", "str().ljust", "misc.print_row.format_val"], "function", ["None"], ["", "def", "print_row", "(", "row", ",", "colwidth", "=", "10", ",", "latex", "=", "False", ")", ":", "\n", "    ", "if", "latex", ":", "\n", "        ", "sep", "=", "\" & \"", "\n", "end_", "=", "\"\\\\\\\\\"", "\n", "", "else", ":", "\n", "        ", "sep", "=", "\"  \"", "\n", "end_", "=", "\"\"", "\n", "\n", "", "def", "format_val", "(", "x", ")", ":", "\n", "        ", "if", "np", ".", "issubdtype", "(", "type", "(", "x", ")", ",", "np", ".", "floating", ")", ":", "\n", "            ", "x", "=", "\"{:.10f}\"", ".", "format", "(", "x", ")", "\n", "", "return", "str", "(", "x", ")", ".", "ljust", "(", "colwidth", ")", "[", ":", "colwidth", "]", "\n", "", "print", "(", "sep", ".", "join", "(", "[", "format_val", "(", "x", ")", "for", "x", "in", "row", "]", ")", ",", "end_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.split_dataset": [[82, 99], ["list", "numpy.random.RandomState().shuffle", "len", "range", "len", "numpy.random.RandomState", "misc._SplitDataset", "misc._SplitDataset", "misc._SplitDataset", "misc._SplitDataset", "misc._SplitDataset", "len", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "", "def", "split_dataset", "(", "dataset", ",", "n", ",", "seed", "=", "0", ",", "val_split", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Return a pair of datasets corresponding to a random split of the given\n    dataset, with n datapoints in the first dataset and the rest in the last,\n    using the given random seed\n    \"\"\"", "\n", "assert", "(", "n", "<=", "len", "(", "dataset", ")", ")", "\n", "keys", "=", "list", "(", "range", "(", "len", "(", "dataset", ")", ")", ")", "\n", "np", ".", "random", ".", "RandomState", "(", "seed", ")", ".", "shuffle", "(", "keys", ")", "\n", "keys_1", "=", "keys", "[", ":", "n", "]", "\n", "keys_2", "=", "keys", "[", "n", ":", "]", "\n", "if", "val_split", ":", "\n", "        ", "keys_3", "=", "keys_1", "[", ":", "len", "(", "keys_1", ")", "//", "2", "]", "\n", "keys_1", "=", "keys_1", "[", "len", "(", "keys_1", ")", "//", "2", ":", "]", "\n", "return", "_SplitDataset", "(", "dataset", ",", "keys_1", ")", ",", "_SplitDataset", "(", "dataset", ",", "keys_3", ")", ",", "_SplitDataset", "(", "dataset", ",", "keys_2", ")", "\n", "", "else", ":", "\n", "        ", "return", "_SplitDataset", "(", "dataset", ",", "keys_1", ")", ",", "_SplitDataset", "(", "dataset", ",", "keys_2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.random_pairs_of_minibatches": [[100, 115], ["torch.randperm().tolist", "torch.randperm().tolist", "range", "len", "min", "pairs.append", "torch.randperm", "torch.randperm", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.min", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["", "", "def", "random_pairs_of_minibatches", "(", "minibatches", ")", ":", "\n", "    ", "perm", "=", "torch", ".", "randperm", "(", "len", "(", "minibatches", ")", ")", ".", "tolist", "(", ")", "\n", "pairs", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "minibatches", ")", ")", ":", "\n", "        ", "j", "=", "i", "+", "1", "if", "i", "<", "(", "len", "(", "minibatches", ")", "-", "1", ")", "else", "0", "\n", "\n", "xi", ",", "yi", "=", "minibatches", "[", "perm", "[", "i", "]", "]", "[", "0", "]", ",", "minibatches", "[", "perm", "[", "i", "]", "]", "[", "1", "]", "\n", "xj", ",", "yj", "=", "minibatches", "[", "perm", "[", "j", "]", "]", "[", "0", "]", ",", "minibatches", "[", "perm", "[", "j", "]", "]", "[", "1", "]", "\n", "\n", "min_n", "=", "min", "(", "len", "(", "xi", ")", ",", "len", "(", "xj", ")", ")", "\n", "\n", "pairs", ".", "append", "(", "(", "(", "xi", "[", ":", "min_n", "]", ",", "yi", "[", ":", "min_n", "]", ")", ",", "(", "xj", "[", ":", "min_n", "]", ",", "yj", "[", ":", "min_n", "]", ")", ")", ")", "\n", "\n", "", "return", "pairs", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.accuracy": [[116, 149], ["network.module.eval", "network.eval", "torch.no_grad", "torch.no_grad", "network.module.train", "network.train", "x.to.to", "y.to.to", "torch.ones.cuda", "torch.ones.sum().item", "network.module.predict", "network.predict", "torch.ones", "torch.ones", "len", "network.predict.size", "len", "torch.ones.sum", "len", "network.predict.gt().eq().float", "network.predict.argmax().eq().float", "network.predict.gt().eq", "network.predict.argmax().eq", "network.predict.gt", "network.predict.argmax"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.eval", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.train", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.predict", "home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.predict", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.argmax"], ["", "def", "accuracy", "(", "network", ",", "loader", ",", "weights", ",", "device", ",", "parallel", ")", ":", "\n", "    ", "correct", "=", "0", "\n", "total", "=", "0", "\n", "weights_offset", "=", "0", "\n", "if", "parallel", ":", "\n", "        ", "network", ".", "module", ".", "eval", "(", ")", "\n", "", "else", ":", "\n", "        ", "network", ".", "eval", "(", ")", "\n", "", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "x", ",", "y", "in", "loader", ":", "\n", "            ", "x", "=", "x", ".", "to", "(", "device", ")", "\n", "y", "=", "y", ".", "to", "(", "device", ")", "\n", "if", "parallel", ":", "\n", "                ", "p", "=", "network", ".", "module", ".", "predict", "(", "x", ")", "\n", "", "else", ":", "\n", "                ", "p", "=", "network", ".", "predict", "(", "x", ")", "\n", "", "if", "weights", "is", "None", ":", "\n", "                ", "batch_weights", "=", "torch", ".", "ones", "(", "len", "(", "x", ")", ")", "\n", "", "else", ":", "\n", "                ", "batch_weights", "=", "weights", "[", "weights_offset", ":", "weights_offset", "+", "len", "(", "x", ")", "]", "\n", "weights_offset", "+=", "len", "(", "x", ")", "\n", "", "batch_weights", "=", "batch_weights", ".", "cuda", "(", ")", "\n", "if", "p", ".", "size", "(", "1", ")", "==", "1", ":", "\n", "                ", "correct", "+=", "(", "p", ".", "gt", "(", "0", ")", ".", "eq", "(", "y", ")", ".", "float", "(", ")", "*", "batch_weights", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "else", ":", "\n", "                ", "correct", "+=", "(", "p", ".", "argmax", "(", "1", ")", ".", "eq", "(", "y", ")", ".", "float", "(", ")", "*", "batch_weights", ")", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "total", "+=", "batch_weights", ".", "sum", "(", ")", ".", "item", "(", ")", "\n", "", "", "if", "parallel", ":", "\n", "        ", "network", ".", "module", ".", "train", "(", ")", "\n", "", "else", ":", "\n", "        ", "network", ".", "train", "(", ")", "\n", "\n", "", "return", "correct", "/", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.kl_loss_function": [[165, 185], ["torch.softmax", "torch.softmax", "F.softmax.size", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.log", "torch.log", "numpy.eye", "numpy.ones", "F.softmax.transpose", "torch.rand", "torch.rand", "sum", "sum"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sum"], ["def", "kl_loss_function", "(", "output1", ",", "output2", ",", "p", ")", ":", "\n", "    ", "\"\"\"\n    :param output1: left output\n    :param output2: right output\n    :param p: priori\n    :return: -MIG^f where f-divergence is KL divergence\n    \"\"\"", "\n", "output1", "=", "F", ".", "softmax", "(", "output1", ",", "dim", "=", "1", ")", "\n", "output2", "=", "F", ".", "softmax", "(", "output2", ",", "dim", "=", "1", ")", "\n", "batch_size", "=", "output1", ".", "size", "(", "0", ")", "\n", "I", "=", "torch", ".", "FloatTensor", "(", "np", ".", "eye", "(", "batch_size", ")", ")", "\n", "E", "=", "torch", ".", "FloatTensor", "(", "np", ".", "ones", "(", "(", "batch_size", ",", "batch_size", ")", ")", ")", "\n", "normalize_1", "=", "batch_size", "\n", "normalize_2", "=", "batch_size", "*", "batch_size", "-", "batch_size", "\n", "new_output", "=", "output1", "/", "p", "\n", "m", "=", "(", "new_output", "@", "output2", ".", "transpose", "(", "1", ",", "0", ")", ")", "\n", "noise", "=", "torch", ".", "rand", "(", "1", ")", "*", "0.0001", "\n", "m1", "=", "torch", ".", "log", "(", "m", "*", "I", "+", "I", "*", "noise", "+", "E", "-", "I", ")", "\n", "m2", "=", "m", "*", "(", "E", "-", "I", ")", "\n", "return", "-", "sum", "(", "m1", ")", "/", "normalize_1", "+", "sum", "(", "m2", ")", "/", "normalize_2", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.BasicBlock.__init__": [[18, 30], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.BasicBlock.forward": [[32, 38], ["torch.relu", "torch.relu", "torch.relu", "defective_resnet.BasicBlock.bn2", "defective_resnet.BasicBlock.shortcut", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.BasicBlock.bn1", "defective_resnet.BasicBlock.conv2", "defective_resnet.BasicBlock.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.Bottleneck.__init__": [[43, 57], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_planes", ",", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "planes", ",", "planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.Bottleneck.forward": [[59, 66], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.Bottleneck.bn3", "defective_resnet.Bottleneck.shortcut", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.Bottleneck.bn1", "defective_resnet.Bottleneck.bn2", "defective_resnet.Bottleneck.conv3", "defective_resnet.Bottleneck.conv1", "defective_resnet.Bottleneck.conv2"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.drop.__init__": [[69, 72], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mask", ")", ":", "\n", "        ", "super", "(", "drop", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "mask", "=", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.drop.forward": [[73, 75], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "*", "self", ".", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__": [[78, 166], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "range", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "defective_resnet.ResNet.df.append", "defective_resnet.ResNet.d0.append", "defective_resnet.ResNet.d1.append", "defective_resnet.ResNet.d2.append", "defective_resnet.ResNet.d3.append", "defective_resnet.ResNet.d4.append", "defective_resnet.ResNet.d5.append", "defective_resnet.ResNet.d6.append", "defective_resnet.ResNet.d7.append", "defective_resnet.ResNet.d8.append", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "defective_resnet.drop", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type().cuda", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy().type", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "[].astype", "[].astype", "[].astype", "[].astype", "[].astype", "[].astype", "[].astype", "[].astype", "[].astype", "[].astype", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.load"], "methods", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.__init__"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "num_blocks", ",", "num_classes", "=", "10", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "128", "\n", "self", ".", "num_networks", "=", "3", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "conv11", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv12", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv21", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv22", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn11", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "bn12", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "bn21", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "bn22", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "shortcut11", "=", "nn", ".", "Sequential", "(", ")", "\n", "self", ".", "shortcut12", "=", "nn", ".", "Sequential", "(", ")", "\n", "\n", "self", ".", "conv31", "=", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv32", "=", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv41", "=", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv42", "=", "nn", ".", "Conv2d", "(", "128", ",", "128", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn31", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "bn32", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "bn41", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "bn42", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "shortcut21", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "64", ",", "128", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "128", ")", ")", "\n", "self", ".", "shortcut22", "=", "nn", ".", "Sequential", "(", ")", "\n", "\n", "self", ".", "conv51", "=", "nn", ".", "Conv2d", "(", "128", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv52", "=", "nn", ".", "Conv2d", "(", "256", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv61", "=", "nn", ".", "Conv2d", "(", "256", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv62", "=", "nn", ".", "Conv2d", "(", "256", ",", "256", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn51", "=", "nn", ".", "BatchNorm2d", "(", "256", ")", "\n", "self", ".", "bn52", "=", "nn", ".", "BatchNorm2d", "(", "256", ")", "\n", "self", ".", "bn61", "=", "nn", ".", "BatchNorm2d", "(", "256", ")", "\n", "self", ".", "bn62", "=", "nn", ".", "BatchNorm2d", "(", "256", ")", "\n", "self", ".", "shortcut31", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "128", ",", "256", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "256", ")", ")", "\n", "self", ".", "shortcut32", "=", "nn", ".", "Sequential", "(", ")", "\n", "\n", "self", ".", "conv71", "=", "nn", ".", "Conv2d", "(", "256", ",", "512", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv72", "=", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv81", "=", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv82", "=", "nn", ".", "Conv2d", "(", "512", ",", "512", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn71", "=", "nn", ".", "BatchNorm2d", "(", "512", ")", "\n", "self", ".", "bn72", "=", "nn", ".", "BatchNorm2d", "(", "512", ")", "\n", "self", ".", "bn81", "=", "nn", ".", "BatchNorm2d", "(", "512", ")", "\n", "self", ".", "bn82", "=", "nn", ".", "BatchNorm2d", "(", "512", ")", "\n", "self", ".", "shortcut41", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "256", ",", "512", ",", "kernel_size", "=", "1", ",", "stride", "=", "2", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "512", ")", ")", "\n", "self", ".", "shortcut42", "=", "nn", ".", "Sequential", "(", ")", "\n", "# self.layer1 = self._make_layer(block, 64, num_blocks[0], stride=1)", "\n", "# self.layer2 = self._make_layer(block, 128, num_blocks[1], stride=2)", "\n", "# self.layer3 = self._make_layer(block, 256, num_blocks[2], stride=2)", "\n", "# self.layer4 = self._make_layer(block, 512, num_blocks[3], stride=2)", "\n", "self", ".", "df", "=", "[", "]", "\n", "self", ".", "d0", "=", "[", "]", "\n", "self", ".", "d1", "=", "[", "]", "\n", "self", ".", "d2", "=", "[", "]", "\n", "self", ".", "d3", "=", "[", "]", "\n", "self", ".", "d4", "=", "[", "]", "\n", "self", ".", "d5", "=", "[", "]", "\n", "self", ".", "d6", "=", "[", "]", "\n", "self", ".", "d7", "=", "[", "]", "\n", "self", ".", "d8", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "num_networks", ")", ":", "\n", "            ", "self", ".", "df", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_f.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d0", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_0.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d1", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_1.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d2", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_2.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d3", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_3.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d4", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_4.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d5", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_5.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d6", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_6.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d7", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_7.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "self", ".", "d8", ".", "append", "(", "\n", "drop", "(", "torch", ".", "from_numpy", "(", "np", ".", "load", "(", "'arr/mask_12_07_8.npy'", ")", "[", "i", "]", ".", "astype", "(", "float", ")", ")", ".", "type", "(", "torch", ".", "FloatTensor", ")", ".", "cuda", "(", ")", ")", ")", "\n", "", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "num_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet._make_layer": [[167, 174], ["torch.Sequential", "torch.Sequential", "torch.Sequential", "layers.append", "block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet.forward": [[175, 233], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.shortcut11", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.shortcut12", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.shortcut22", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.bn52", "defective_resnet.ResNet.shortcut31", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.bn62", "defective_resnet.ResNet.shortcut32", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.bn72", "defective_resnet.ResNet.shortcut41", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "defective_resnet.ResNet.bn82", "defective_resnet.ResNet.shortcut42", "torch.relu", "torch.relu", "torch.relu", "torch.avg_pool2d", "torch.avg_pool2d", "torch.avg_pool2d", "defective_resnet.ResNet.view", "defective_resnet.ResNet.linear", "defective_resnet.ResNet.bn12", "defective_resnet.ResNet.bn22", "defective_resnet.ResNet.bn32", "defective_resnet.ResNet.shortcut21", "defective_resnet.ResNet.bn42", "defective_resnet.ResNet.bn51", "defective_resnet.ResNet.conv52", "defective_resnet.ResNet.bn61", "defective_resnet.ResNet.conv62", "defective_resnet.ResNet.bn71", "defective_resnet.ResNet.conv72", "defective_resnet.ResNet.bn81", "defective_resnet.ResNet.conv82", "defective_resnet.ResNet.size", "defective_resnet.ResNet.bn1", "defective_resnet.ResNet.bn11", "defective_resnet.ResNet.conv12", "defective_resnet.ResNet.bn21", "defective_resnet.ResNet.conv22", "defective_resnet.ResNet.bn31", "defective_resnet.ResNet.conv32", "defective_resnet.ResNet.bn41", "defective_resnet.ResNet.conv42", "defective_resnet.ResNet.conv51", "defective_resnet.ResNet.conv61", "defective_resnet.ResNet.conv71", "defective_resnet.ResNet.conv81", "defective_resnet.ResNet.conv1", "defective_resnet.ResNet.conv11", "defective_resnet.ResNet.conv21", "defective_resnet.ResNet.conv31", "defective_resnet.ResNet.conv41"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "nidx", ")", ":", "\n", "        ", "out", "=", "F", ".", "relu", "(", "self", ".", "df", "[", "nidx", "]", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", ")", "\n", "# out = self.layer1(out)", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "d0", "[", "nidx", "]", "(", "self", ".", "bn11", "(", "self", ".", "conv11", "(", "out", ")", ")", ")", ")", "\n", "out", "=", "self", ".", "d1", "[", "nidx", "]", "(", "self", ".", "bn12", "(", "self", ".", "conv12", "(", "out", ")", ")", ")", "\n", "out", "+=", "self", ".", "shortcut11", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "d2", "[", "nidx", "]", "(", "self", ".", "bn21", "(", "self", ".", "conv21", "(", "out", ")", ")", ")", ")", "\n", "out", "=", "self", ".", "d3", "[", "nidx", "]", "(", "self", ".", "bn22", "(", "self", ".", "conv22", "(", "out", ")", ")", ")", "\n", "out", "+=", "self", ".", "shortcut12", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "# out = self.layer2(out)", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "d4", "[", "nidx", "]", "(", "self", ".", "bn31", "(", "self", ".", "conv31", "(", "out", ")", ")", ")", ")", "\n", "out", "=", "self", ".", "d5", "[", "nidx", "]", "(", "self", ".", "bn32", "(", "self", ".", "conv32", "(", "out", ")", ")", ")", "\n", "out", "+=", "self", ".", "d6", "[", "nidx", "]", "(", "self", ".", "shortcut21", "(", "tmp", ")", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "d7", "[", "nidx", "]", "(", "self", ".", "bn41", "(", "self", ".", "conv41", "(", "out", ")", ")", ")", ")", "\n", "out", "=", "self", ".", "d8", "[", "nidx", "]", "(", "self", ".", "bn42", "(", "self", ".", "conv42", "(", "out", ")", ")", ")", "\n", "out", "+=", "self", ".", "shortcut22", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "# out = self.layer3(out)", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn51", "(", "self", ".", "conv51", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "bn52", "(", "self", ".", "conv52", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut31", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn61", "(", "self", ".", "conv61", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "bn62", "(", "self", ".", "conv62", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut32", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "# out = self.layer4(out)", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn71", "(", "self", ".", "conv71", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "bn72", "(", "self", ".", "conv72", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut41", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "tmp", "=", "out", "\n", "out", "=", "F", ".", "relu", "(", "self", ".", "bn81", "(", "self", ".", "conv81", "(", "out", ")", ")", ")", "\n", "out", "=", "self", ".", "bn82", "(", "self", ".", "conv82", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut42", "(", "tmp", ")", "\n", "out", "=", "F", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "F", ".", "avg_pool2d", "(", "out", ",", "4", ")", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "self", ".", "linear", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet18": [[235, 237], ["defective_resnet.ResNet"], "function", ["None"], ["", "", "def", "ResNet18", "(", ")", ":", "\n", "    ", "return", "ResNet", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet34": [[239, 241], ["defective_resnet.ResNet"], "function", ["None"], ["", "def", "ResNet34", "(", ")", ":", "\n", "    ", "return", "ResNet", "(", "BasicBlock", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet50": [[243, 245], ["defective_resnet.ResNet"], "function", ["None"], ["", "def", "ResNet50", "(", ")", ":", "\n", "    ", "return", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet101": [[247, 249], ["defective_resnet.ResNet"], "function", ["None"], ["", "def", "ResNet101", "(", ")", ":", "\n", "    ", "return", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "4", ",", "23", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet152": [[251, 253], ["defective_resnet.ResNet"], "function", ["None"], ["", "def", "ResNet152", "(", ")", ":", "\n", "    ", "return", "ResNet", "(", "Bottleneck", ",", "[", "3", ",", "8", ",", "36", ",", "3", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.test": [[255, 259], ["defective_resnet.ResNet18", "ResNet18.", "print", "torch.randn", "torch.randn", "torch.randn", "net.size"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.lib.defective_resnet.ResNet18"], ["", "def", "test", "(", ")", ":", "\n", "    ", "net", "=", "ResNet18", "(", ")", "\n", "y", "=", "net", "(", "torch", ".", "randn", "(", "1", ",", "3", ",", "32", ",", "32", ")", ")", "\n", "print", "(", "y", ".", "size", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.train.main": [[176, 255], ["collections.defaultdict", "zip", "time.time", "algorithm.update", "checkpoint_vals[].append", "algorithm.update.items", "open", "f.write", "checkpoint_vals[].append", "collections.defaultdict.items", "zip", "sorted", "domainbed.lib.misc.print_row", "domainbed.lib.misc.print_row", "collect_dict[].append", "os.path.join", "x.to", "y.to", "time.time", "numpy.mean", "domainbed.lib.misc.accuracy", "results.keys", "range", "os.path.join", "print", "print", "len", "print", "torch.save", "torch.save", "torch.save", "vars", "algorithm.state_dict", "len", "len"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.domainbed.algorithms.TRM.update", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.Tee.write", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.sorted", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.print_row", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.print_row", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.mean", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.misc.accuracy", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len", "home.repos.pwc.inspect_result.Newbeeer_TRM.lib.query.Q.len"], ["def", "main", "(", "epoch", ")", ":", "\n", "    ", "global", "last_results_keys", "\n", "global", "best_acc_out", "\n", "global", "best_acc_in", "\n", "global", "collect_dict", "\n", "checkpoint_vals", "=", "collections", ".", "defaultdict", "(", "lambda", ":", "[", "]", ")", "\n", "train_minibatches_iterator", "=", "zip", "(", "*", "train_loaders", ")", "\n", "for", "batch", "in", "train_minibatches_iterator", ":", "\n", "        ", "step_start_time", "=", "time", ".", "time", "(", ")", "\n", "minibatches_device", "=", "[", "(", "x", ".", "to", "(", "device", ")", ",", "y", ".", "to", "(", "device", ")", ")", "\n", "for", "x", ",", "y", "in", "batch", "]", "\n", "\n", "step_vals", "=", "algorithm", ".", "update", "(", "minibatches_device", ")", "\n", "\n", "checkpoint_vals", "[", "'step_time'", "]", ".", "append", "(", "time", ".", "time", "(", ")", "-", "step_start_time", ")", "\n", "args", ".", "step", "+=", "1", "\n", "\n", "for", "key", ",", "val", "in", "step_vals", ".", "items", "(", ")", ":", "\n", "            ", "checkpoint_vals", "[", "key", "]", ".", "append", "(", "val", ")", "\n", "\n", "", "if", "args", ".", "step", "%", "checkpoint_freq", "==", "0", ":", "\n", "            ", "results", "=", "{", "\n", "'step'", ":", "args", ".", "step", ",", "\n", "'epoch'", ":", "epoch", ",", "\n", "}", "\n", "\n", "for", "key", ",", "val", "in", "checkpoint_vals", ".", "items", "(", ")", ":", "\n", "                ", "results", "[", "key", "]", "=", "np", ".", "mean", "(", "val", ")", "\n", "", "evals", "=", "zip", "(", "eval_loader_names", ",", "eval_loaders", ",", "eval_weights", ")", "\n", "for", "name", ",", "loader", ",", "weights", "in", "evals", ":", "\n", "                ", "acc", "=", "misc", ".", "accuracy", "(", "algorithm", ",", "loader", ",", "weights", ",", "device", ",", "args", ".", "parallel", ")", "\n", "results", "[", "name", "+", "'_acc'", "]", "=", "acc", "\n", "\n", "", "results_keys", "=", "sorted", "(", "results", ".", "keys", "(", ")", ")", "\n", "misc", ".", "print_row", "(", "results_keys", ",", "colwidth", "=", "12", ")", "\n", "misc", ".", "print_row", "(", "[", "results", "[", "key", "]", "for", "key", "in", "results_keys", "]", ",", "\n", "colwidth", "=", "12", ")", "\n", "\n", "\n", "if", "args", ".", "test_val", ":", "\n", "# test set validation", "\n", "                ", "name_in", "=", "'env{}_in_acc'", ".", "format", "(", "args", ".", "test_envs", "[", "0", "]", ")", "\n", "name_out", "=", "'env{}_out_acc'", ".", "format", "(", "args", ".", "test_envs", "[", "0", "]", ")", "\n", "val_acc", "=", "results", "[", "name_in", "]", "\n", "test_acc", "=", "results", "[", "name_out", "]", "\n", "", "else", ":", "\n", "# training set validation", "\n", "                ", "test_name_in", "=", "'env{}_in_acc'", ".", "format", "(", "args", ".", "test_envs", "[", "0", "]", ")", "\n", "test_name_out", "=", "'env{}_out_acc'", ".", "format", "(", "args", ".", "test_envs", "[", "0", "]", ")", "\n", "test_acc", "=", "(", "results", "[", "test_name_in", "]", "*", "(", "1", "-", "args", ".", "holdout_fraction", ")", "+", "results", "[", "test_name_out", "]", "*", "args", ".", "holdout_fraction", ")", "\n", "val_acc", "=", "0.", "\n", "cnt_envs", "=", "0.", "\n", "for", "i", "in", "range", "(", "len", "(", "dataset", ")", ")", ":", "\n", "                    ", "if", "i", "not", "in", "args", ".", "test_envs", ":", "\n", "                        ", "val_acc", "+=", "results", "[", "'env{}_out_acc'", ".", "format", "(", "i", ")", "]", "\n", "cnt_envs", "+=", "1", "\n", "", "", "val_acc", "=", "val_acc", "/", "cnt_envs", "\n", "\n", "", "collect_dict", "[", "'acc'", "]", ".", "append", "(", "test_acc", ")", "\n", "if", "val_acc", ">", "best_acc_in", ":", "\n", "                ", "best_acc_in", "=", "val_acc", "\n", "best_acc_out", "=", "test_acc", "\n", "path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "f\"{args.algorithm}_bias_{args.bias}_seed_{args.trial_seed}_{args.dataset}.pth\"", ")", "\n", "print", "(", "f\"epoch:{epoch}, Val acc:{best_acc_in:.4f}, Test acc:{best_acc_out:.4f} \"", ")", "\n", "print", "(", "'----------------------------------'", ")", "\n", "if", "args", ".", "model_save", ":", "\n", "                    ", "save_dict", "=", "{", "\n", "\"args\"", ":", "vars", "(", "args", ")", ",", "\n", "\"model_input_shape\"", ":", "dataset", ".", "input_shape", ",", "\n", "\"model_num_classes\"", ":", "dataset", ".", "num_classes", ",", "\n", "\"model_num_domains\"", ":", "len", "(", "dataset", ")", "-", "len", "(", "args", ".", "test_envs", ")", ",", "\n", "\"model_hparams\"", ":", "hparams", ",", "\n", "\"model_dict\"", ":", "algorithm", ".", "state_dict", "(", ")", "\n", "}", "\n", "print", "(", "\"save at...\"", ",", "path", ")", "\n", "torch", ".", "save", "(", "save_dict", ",", "path", ")", "\n", "\n", "", "", "", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "'done'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "f", ".", "write", "(", "'done'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path": [[17, 24], ["os.path.join", "os.path.exists", "os.makedirs"], "function", ["None"], ["def", "stage_path", "(", "data_dir", ",", "name", ")", ":", "\n", "    ", "full_path", "=", "os", ".", "path", ".", "join", "(", "data_dir", ",", "name", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "full_path", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "full_path", ")", "\n", "\n", "", "return", "full_path", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract": [[26, 46], ["gdown.download", "dst.endswith", "dst.endswith", "dst.endswith", "tarfile.open", "tarfile.open.extractall", "tarfile.open.close", "tarfile.open", "tarfile.open.extractall", "tarfile.open.close", "zipfile.ZipFile", "zipfile.ZipFile.extractall", "zipfile.ZipFile.close", "os.remove", "os.path.dirname", "os.path.dirname", "os.path.dirname"], "function", ["None"], ["", "def", "download_and_extract", "(", "url", ",", "dst", ",", "remove", "=", "True", ")", ":", "\n", "    ", "gdown", ".", "download", "(", "url", ",", "dst", ",", "quiet", "=", "False", ")", "\n", "\n", "if", "dst", ".", "endswith", "(", "\".tar.gz\"", ")", ":", "\n", "        ", "tar", "=", "tarfile", ".", "open", "(", "dst", ",", "\"r:gz\"", ")", "\n", "tar", ".", "extractall", "(", "os", ".", "path", ".", "dirname", "(", "dst", ")", ")", "\n", "tar", ".", "close", "(", ")", "\n", "\n", "", "if", "dst", ".", "endswith", "(", "\".tar\"", ")", ":", "\n", "        ", "tar", "=", "tarfile", ".", "open", "(", "dst", ",", "\"r:\"", ")", "\n", "tar", ".", "extractall", "(", "os", ".", "path", ".", "dirname", "(", "dst", ")", ")", "\n", "tar", ".", "close", "(", ")", "\n", "\n", "", "if", "dst", ".", "endswith", "(", "\".zip\"", ")", ":", "\n", "        ", "zf", "=", "ZipFile", "(", "dst", ",", "\"r\"", ")", "\n", "zf", ".", "extractall", "(", "os", ".", "path", ".", "dirname", "(", "dst", ")", ")", "\n", "zf", ".", "close", "(", ")", "\n", "\n", "", "if", "remove", ":", "\n", "        ", "os", ".", "remove", "(", "dst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_vlcs": [[94, 100], ["download.stage_path", "download.download_and_extract", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path", "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract"], ["", "", "def", "download_vlcs", "(", "data_dir", ")", ":", "\n", "# Original URL: http://www.eecs.qmul.ac.uk/~dl307/project_iccv2017", "\n", "    ", "full_path", "=", "stage_path", "(", "data_dir", ",", "\"VLCS\"", ")", "\n", "\n", "download_and_extract", "(", "\"https://drive.google.com/uc?id=1skwblH1_okBwxWxmRsp9_qi15hyPpxg8\"", ",", "\n", "os", ".", "path", ".", "join", "(", "data_dir", ",", "\"VLCS.tar.gz\"", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_mnist": [[104, 108], ["download.stage_path", "torchvision.datasets.MNIST"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path"], ["", "def", "download_mnist", "(", "data_dir", ")", ":", "\n", "# Original URL: http://yann.lecun.com/exdb/mnist/", "\n", "    ", "full_path", "=", "stage_path", "(", "data_dir", ",", "\"MNIST\"", ")", "\n", "MNIST", "(", "full_path", ",", "download", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_pacs": [[112, 121], ["download.stage_path", "download.download_and_extract", "os.rename", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path", "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract"], ["", "def", "download_pacs", "(", "data_dir", ")", ":", "\n", "# Original URL: http://www.eecs.qmul.ac.uk/~dl307/project_iccv2017", "\n", "    ", "full_path", "=", "stage_path", "(", "data_dir", ",", "\"PACS\"", ")", "\n", "\n", "download_and_extract", "(", "\"https://drive.google.com/uc?id=0B6x7gtvErXgfbF9CSk53UkRxVzg\"", ",", "\n", "os", ".", "path", ".", "join", "(", "data_dir", ",", "\"PACS.zip\"", ")", ")", "\n", "\n", "os", ".", "rename", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "\"kfold\"", ")", ",", "\n", "full_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_office_home": [[125, 134], ["download.stage_path", "download.download_and_extract", "os.rename", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path", "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract"], ["", "def", "download_office_home", "(", "data_dir", ")", ":", "\n", "# Original URL: http://hemanthdv.org/OfficeHome-Dataset/", "\n", "    ", "full_path", "=", "stage_path", "(", "data_dir", ",", "\"office_home\"", ")", "\n", "\n", "download_and_extract", "(", "\"https://drive.google.com/uc?id=0B81rNlvomiwed0V1YUxQdC1uOTg\"", ",", "\n", "os", ".", "path", ".", "join", "(", "data_dir", ",", "\"office_home.zip\"", ")", ")", "\n", "\n", "os", ".", "rename", "(", "os", ".", "path", ".", "join", "(", "data_dir", ",", "\"OfficeHomeDataset_10072016\"", ")", ",", "\n", "full_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_domain_net": [[138, 160], ["download.stage_path", "download.download_and_extract", "open", "f.readlines", "os.path.join", "os.remove", "url.split", "os.path.join", "line.strip"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path", "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract"], ["", "def", "download_domain_net", "(", "data_dir", ")", ":", "\n", "# Original URL: http://ai.bu.edu/M3SDA/", "\n", "    ", "full_path", "=", "stage_path", "(", "data_dir", ",", "\"domain_net\"", ")", "\n", "\n", "urls", "=", "[", "\n", "\"http://csr.bu.edu/ftp/visda/2019/multi-source/groundtruth/clipart.zip\"", ",", "\n", "\"http://csr.bu.edu/ftp/visda/2019/multi-source/infograph.zip\"", ",", "\n", "\"http://csr.bu.edu/ftp/visda/2019/multi-source/groundtruth/painting.zip\"", ",", "\n", "\"http://csr.bu.edu/ftp/visda/2019/multi-source/quickdraw.zip\"", ",", "\n", "\"http://csr.bu.edu/ftp/visda/2019/multi-source/real.zip\"", ",", "\n", "\"http://csr.bu.edu/ftp/visda/2019/multi-source/sketch.zip\"", "\n", "]", "\n", "\n", "for", "url", "in", "urls", ":", "\n", "        ", "download_and_extract", "(", "url", ",", "os", ".", "path", ".", "join", "(", "full_path", ",", "url", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", ")", ")", "\n", "\n", "", "with", "open", "(", "\"domainbed/misc/domain_net_duplicates.txt\"", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "for", "line", "in", "f", ".", "readlines", "(", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "os", ".", "remove", "(", "os", ".", "path", ".", "join", "(", "full_path", ",", "line", ".", "strip", "(", ")", ")", ")", "\n", "", "except", "OSError", ":", "\n", "                ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_terra_incognita": [[164, 241], ["download.stage_path", "download.download_and_extract", "download.download_and_extract", "os.path.join", "os.path.join", "shutil.rmtree", "os.remove", "os.path.join", "os.path.join", "os.path.exists", "os.mkdir", "open", "json.load", "os.path.join", "os.path.exists", "os.mkdir", "os.path.join", "os.path.join", "os.path.join", "shutil.copyfile", "str", "os.path.exists", "os.mkdir"], "function", ["home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.stage_path", "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract", "home.repos.pwc.inspect_result.Newbeeer_TRM.scripts.download.download_and_extract"], ["", "", "", "", "def", "download_terra_incognita", "(", "data_dir", ")", ":", "\n", "# Original URL: https://beerys.github.io/CaltechCameraTraps/", "\n", "    ", "full_path", "=", "stage_path", "(", "data_dir", ",", "\"terra_incognita\"", ")", "\n", "\n", "download_and_extract", "(", "\n", "\"http://www.vision.caltech.edu/~sbeery/datasets/caltechcameratraps18/eccv_18_all_images_sm.tar.gz\"", ",", "\n", "os", ".", "path", ".", "join", "(", "full_path", ",", "\"terra_incognita_images.tar.gz\"", ")", ")", "\n", "\n", "download_and_extract", "(", "\n", "\"http://www.vision.caltech.edu/~sbeery/datasets/caltechcameratraps18/eccv_18_all_annotations.tar.gz\"", ",", "\n", "os", ".", "path", ".", "join", "(", "full_path", ",", "\"terra_incognita_annotations.tar.gz\"", ")", ")", "\n", "\n", "include_locations", "=", "[", "38", ",", "46", ",", "100", ",", "43", "]", "\n", "\n", "include_categories", "=", "[", "\n", "\"bird\"", ",", "\"bobcat\"", ",", "\"cat\"", ",", "\"coyote\"", ",", "\"dog\"", ",", "\"empty\"", ",", "\"opossum\"", ",", "\"rabbit\"", ",", "\n", "\"raccoon\"", ",", "\"squirrel\"", "\n", "]", "\n", "\n", "images_folder", "=", "os", ".", "path", ".", "join", "(", "full_path", ",", "\"eccv_18_all_images_sm/\"", ")", "\n", "annotations_file", "=", "os", ".", "path", ".", "join", "(", "full_path", ",", "\"CaltechCameraTrapsECCV18.json\"", ")", "\n", "destination_folder", "=", "full_path", "\n", "\n", "stats", "=", "{", "}", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "destination_folder", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "destination_folder", ")", "\n", "\n", "", "with", "open", "(", "annotations_file", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "data", "=", "json", ".", "load", "(", "f", ")", "\n", "\n", "", "category_dict", "=", "{", "}", "\n", "for", "item", "in", "data", "[", "'categories'", "]", ":", "\n", "        ", "category_dict", "[", "item", "[", "'id'", "]", "]", "=", "item", "[", "'name'", "]", "\n", "\n", "", "for", "image", "in", "data", "[", "'images'", "]", ":", "\n", "        ", "image_location", "=", "image", "[", "'location'", "]", "\n", "\n", "if", "image_location", "not", "in", "include_locations", ":", "\n", "            ", "continue", "\n", "\n", "", "loc_folder", "=", "os", ".", "path", ".", "join", "(", "destination_folder", ",", "\n", "'location_'", "+", "str", "(", "image_location", ")", "+", "'/'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "loc_folder", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "loc_folder", ")", "\n", "\n", "", "image_id", "=", "image", "[", "'id'", "]", "\n", "image_fname", "=", "image", "[", "'file_name'", "]", "\n", "\n", "for", "annotation", "in", "data", "[", "'annotations'", "]", ":", "\n", "            ", "if", "annotation", "[", "'image_id'", "]", "==", "image_id", ":", "\n", "                ", "if", "image_location", "not", "in", "stats", ":", "\n", "                    ", "stats", "[", "image_location", "]", "=", "{", "}", "\n", "\n", "", "category", "=", "category_dict", "[", "annotation", "[", "'category_id'", "]", "]", "\n", "\n", "if", "category", "not", "in", "include_categories", ":", "\n", "                    ", "continue", "\n", "\n", "", "if", "category", "not", "in", "stats", "[", "image_location", "]", ":", "\n", "                    ", "stats", "[", "image_location", "]", "[", "category", "]", "=", "0", "\n", "", "else", ":", "\n", "                    ", "stats", "[", "image_location", "]", "[", "category", "]", "+=", "1", "\n", "\n", "", "loc_cat_folder", "=", "os", ".", "path", ".", "join", "(", "loc_folder", ",", "category", "+", "'/'", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "loc_cat_folder", ")", ":", "\n", "                    ", "os", ".", "mkdir", "(", "loc_cat_folder", ")", "\n", "\n", "", "dst_path", "=", "os", ".", "path", ".", "join", "(", "loc_cat_folder", ",", "image_fname", ")", "\n", "src_path", "=", "os", ".", "path", ".", "join", "(", "images_folder", ",", "image_fname", ")", "\n", "\n", "shutil", ".", "copyfile", "(", "src_path", ",", "dst_path", ")", "\n", "\n", "", "", "", "shutil", ".", "rmtree", "(", "images_folder", ")", "\n", "os", ".", "remove", "(", "annotations_file", ")", "\n", "\n"]]}