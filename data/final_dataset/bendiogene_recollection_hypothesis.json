{"home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_normalization": [[12, 27], ["img.astype.astype", "numpy.zeros().astype", "numpy.array", "numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "cuda.to_device.to_host", "int", "int", "numpy.zeros", "math.ceil", "math.ceil"], "function", ["None"], ["    ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "img_out", "=", "np", ".", "zeros", "(", "img", ".", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "img_sz", "=", "np", ".", "array", "(", "[", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n", "blockdim", "=", "(", "10", ",", "10", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "img", ".", "shape", "[", "0", "]", "/", "blockdim", "[", "0", "]", ")", ")", ",", "int", "(", "ceil", "(", "img", ".", "shape", "[", "1", "]", "/", "blockdim", "[", "1", "]", ")", ")", ")", "\n", "\n", "d_img_in", "=", "cuda", ".", "to_device", "(", "img", ")", "\n", "d_img_out", "=", "cuda", ".", "to_device", "(", "img_out", ")", "\n", "d_img_sz", "=", "cuda", ".", "to_device", "(", "img_sz", ")", "\n", "DoG_norm", "[", "griddim", ",", "blockdim", "]", "(", "d_img_out", ",", "d_img_in", ",", "d_img_sz", ",", "8", ")", "\n", "d_img_out", ".", "to_host", "(", ")", "\n", "\n", "return", "img_out", "\n", "\n", "", "def", "DoG_normalization_CPU", "(", "img", ")", ":", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_normalization_CPU": [[28, 34], ["img.astype.astype", "numpy.zeros().astype", "numpy.array", "cpu_utils.DoG_norm_CPU", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.DoG_norm_CPU"], ["    ", "img", "=", "img", ".", "astype", "(", "np", ".", "float32", ")", "\n", "img_out", "=", "np", ".", "zeros", "(", "img", ".", "shape", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "img_sz", "=", "np", ".", "array", "(", "[", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "1", "]", "]", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "img_out", "=", "DoG_norm_CPU", "(", "img_out", ",", "img", ",", "img_sz", ",", "8", ")", "\n", "return", "img_out", "\n", "\n", "", "def", "DoG_filter", "(", "path_img", ",", "filt", ",", "img_size", ",", "total_time", ",", "num_layers", ")", ":", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter": [[35, 75], ["PIL.Image.open", "np.abs.convert", "np.abs.resize", "numpy.asarray().reshape", "scipy.ndimage.correlate", "numpy.zeros", "numpy.abs", "numpy.argsort", "numpy.sort", "numpy.delete", "numpy.unravel_index", "numpy.ceil().astype", "numpy.zeros", "numpy.where", "numpy.asarray", "img_out.flatten", "img_out.flatten", "numpy.ceil", "np.abs.getdata", "numpy.arange"], "function", ["None"], ["    ", "\"\"\"\n        DoG filter implementation based on Kheradpisheh, S.R., et al. 'STDP-based spiking deep neural networks \n        for object recognition'. arXiv:1611.01421v1 (Nov, 2016)\n    \"\"\"", "\n", "\n", "# Open image, convert to grayscale and resize", "\n", "img", "=", "Image", ".", "open", "(", "path_img", ")", "\n", "img", "=", "img", ".", "convert", "(", "'L'", ")", "\n", "img", "=", "img", ".", "resize", "(", "img_size", ",", "ANTIALIAS", ")", "\n", "img", "=", "np", ".", "asarray", "(", "img", ".", "getdata", "(", ")", ",", "dtype", "=", "np", ".", "float64", ")", ".", "reshape", "(", "(", "img", ".", "size", "[", "1", "]", ",", "img", ".", "size", "[", "0", "]", ")", ")", "\n", "\n", "# Apply filter", "\n", "img", "=", "correlate", "(", "img", ",", "filt", ",", "mode", "=", "'constant'", ")", "\n", "\n", "# Border", "\n", "border", "=", "np", ".", "zeros", "(", "img", ".", "shape", ")", "\n", "border", "[", "5", ":", "-", "5", ",", "5", ":", "-", "5", "]", "=", "1.", "\n", "img", "=", "img", "*", "border", "\n", "\n", "# Threshold", "\n", "img", "=", "(", "img", ">=", "15", ")", ".", "astype", "(", "int", ")", "*", "img", "\n", "img", "=", "np", ".", "abs", "(", "img", ")", "# Convert -0. to 0.", "\n", "\n", "# DoG Normalization", "\n", "# img_out = DoG_normalization(img)", "\n", "# img_out = DoG_normalization_CPU(img)", "\n", "img_out", "=", "img", "\n", "\n", "# Convert to spike times", "\n", "I", "=", "np", ".", "argsort", "(", "1", "/", "img_out", ".", "flatten", "(", ")", ")", "# Get indices of sorted latencies", "\n", "lat", "=", "np", ".", "sort", "(", "1", "/", "img_out", ".", "flatten", "(", ")", ")", "# Get sorted latencies", "\n", "I", "=", "np", ".", "delete", "(", "I", ",", "np", ".", "where", "(", "lat", "==", "np", ".", "inf", ")", ")", "# Remove infinite latencies indexes", "\n", "II", "=", "np", ".", "unravel_index", "(", "I", ",", "img_out", ".", "shape", ")", "# Get the row, column and depth of the latencies in order", "\n", "t_step", "=", "np", ".", "ceil", "(", "np", ".", "arange", "(", "I", ".", "size", ")", "/", "(", "(", "I", ".", "size", ")", "/", "(", "total_time", "-", "num_layers", ")", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "II", "+=", "(", "t_step", ",", ")", "\n", "spike_times", "=", "np", ".", "zeros", "(", "(", "img_out", ".", "shape", "[", "0", "]", ",", "img_out", ".", "shape", "[", "1", "]", ",", "total_time", ")", ")", "\n", "spike_times", "[", "II", "]", "=", "1", "\n", "\n", "return", "spike_times", "\n", "\n", "", "def", "DoG", "(", "size", ",", "s1", ",", "s2", ")", ":", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG": [[76, 88], ["numpy.tile", "numpy.mean", "numpy.amax", "numpy.arange", "numpy.sqrt", "numpy.exp", "numpy.exp"], "function", ["None"], ["    ", "\"\"\"\n        Generates a filter window of size size x size with std of s1 and s2\n    \"\"\"", "\n", "r", "=", "np", ".", "arange", "(", "size", ")", "+", "1", "\n", "x", "=", "np", ".", "tile", "(", "r", ",", "[", "size", ",", "1", "]", ")", "\n", "y", "=", "x", ".", "T", "\n", "d2", "=", "(", "x", "-", "size", "/", "2.", "-", "0.5", ")", "**", "2", "+", "(", "y", "-", "size", "/", "2.", "-", "0.5", ")", "**", "2", "\n", "filt", "=", "1", "/", "np", ".", "sqrt", "(", "2", "*", "np", ".", "pi", ")", "*", "(", "1", "/", "s1", "*", "np", ".", "exp", "(", "-", "d2", "/", "(", "2", "*", "(", "s1", "**", "2", ")", ")", ")", "-", "1", "/", "s2", "*", "np", ".", "exp", "(", "-", "d2", "/", "(", "2", "*", "(", "s2", "**", "2", ")", ")", ")", ")", "\n", "filt", "-=", "np", ".", "mean", "(", "filt", "[", ":", "]", ")", "\n", "filt", "/=", "np", ".", "amax", "(", "filt", "[", ":", "]", ")", "\n", "return", "filt", "\n", "", ""]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.__init__": [[63, 185], ["len", "SDNN_cuda_vary_images.SDNN.init_net_struc", "SDNN_cuda_vary_images.SDNN.init_layers", "SDNN_cuda_vary_images.SDNN.init_weights", "SDNN_cuda_vary_images.SDNN.check_dimensions", "DoG_filt_cuda.DoG", "SDNN_cuda_vary_images.SDNN.gen_iter_paths", "SDNN_cuda_vary_images.SDNN.gen_iter_paths", "SDNN_cuda_vary_images.SDNN.gen_iter_paths", "itertools.tee"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_net_struc", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_weights", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.check_dimensions", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths"], ["        ", "\"\"\"\n            Initialisaition of SDNN\n\n            Input:            \n            - network_params: A list of dictionaries with the following keys:                \n                -'Type': A string specifying which kind of layer this is (either 'input', 'conv' and 'pool')\n                -'num_filters': an int specifying the depth (number of filters) of this layer\n                -'filter_size': an int specifying the height and width of the filter window for \n                                the previous layer to this layer (only on 'conv' and  'pool')\n                -'th': an np.float32 specifying the threshold of this layer (only on 'conv' and  'pool')\n                -'stride': an int specifying the stride for this layer (only on 'pool')\n                -'pad': an int specifying the pad for this layer (only on 'input')\n                -'H_layer': an int specifying the height of this layer (only on 'input')\n                -'W_layer': an int specifying the width of this layer (only on 'input') \n            - weight_params: A dictionary with the following keys:                \n                - 'mean': the mean for initialising the weights\n                - 'std': the std for initialising the weights\n            - stdp_params: A dictionary with the following keys:                                \n                - 'max_iter': an int specifyng the maximum number of iterations allowed on learning\n                - 'max_learn_iter': a list of ints specifying the maximum number of iterations allowed for training each layer (len = number of layers)\n                - 'stdp_per_layer': a list of ints specifying the maximum number of STDP updates per layer (len = number of layers)\n                - 'offset_STDP': a list of ints specifying the STDP ofset per leayer updates per layer (len = number of layers)\n                - 'a_minus': an np.float32 numpy array specifying the learning rate when no causality \n                - 'a_plus': an np.float32 numpy array specifying the learning rate when there is causality \n            - total_time: An int specifying the number of time steps per image\n            - spike_times_learn: A list of strings with a valid absolute or relative path to the folders with \n                                 the learning .jpg images OR \n                                 An uint8 array with the learning spike times of shape (N_lr, H_in, W_in, M_in). \n                                 Axis 0 is each of the images\n            - spike_times_train: A list of strings with a valid absolute or relative path to the folders with \n                                 the training .jpg images OR \n                                 An uint8 array with the training spike times of shape (N_tr, H_in, W_in, M_in). \n                                 Axis 0 is each of the images\n            - spike_times_test: A list of strings with a valid absolute or relative path to the folders with \n                                 the testing .jpg images OR \n                                 An uint8 array with the testing spike times of shape (N_ts, H_in, W_in, M_in). \n                                 Axis 0 is each of the images   \n            - DoG_params: None OR A dictionary with the following keys:\n                -'img_size': A tuple of integers with the dimensions to which the images are to be resized \n                -'DoG_size': An int with the size of the DoG filter window size\n                -'std1': A float with the standard deviation 1 for the DoG filter\n                -'std2': A float with the standard deviation 2 for the DoG filter                  \n                 \n        \"\"\"", "\n", "\n", "# --------------------------- DoG Filter Parameters -------------------#", "\n", "self", ".", "n_train_images", "=", "n_train_images", "\n", "if", "DoG_params", "is", "not", "None", ":", "\n", "            ", "self", ".", "DoG", "=", "True", "\n", "self", ".", "img_size", "=", "DoG_params", "[", "'img_size'", "]", "\n", "self", ".", "filt", "=", "DoG", "(", "DoG_params", "[", "'DoG_size'", "]", ",", "DoG_params", "[", "'std1'", "]", ",", "DoG_params", "[", "'std2'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "DoG", "=", "False", "\n", "\n", "# --------------------------- Network Initialisation -------------------#", "\n", "# Total time and number of layers", "\n", "", "self", ".", "num_layers", "=", "len", "(", "network_params", ")", "\n", "self", ".", "learnable_layers", "=", "[", "]", "\n", "self", ".", "total_time", "=", "total_time", "\n", "\n", "# Layers Initialisation", "\n", "self", ".", "network_struc", "=", "[", "]", "\n", "self", ".", "init_net_struc", "(", "network_params", ")", "\n", "self", ".", "layers", "=", "[", "]", "\n", "self", ".", "init_layers", "(", ")", "\n", "\n", "# Weights Initialisation", "\n", "self", ".", "weight_params", "=", "weight_params", "\n", "self", ".", "weights", "=", "[", "]", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n", "# Dimension Check", "\n", "self", ".", "check_dimensions", "(", ")", "\n", "\n", "# ---------------------------Learning Paramters -------------------#", "\n", "# Learning layer parameters", "\n", "self", ".", "max_iter", "=", "stdp_params", "[", "'max_iter'", "]", "\n", "self", ".", "learning_layer", "=", "self", ".", "learnable_layers", "[", "0", "]", "\n", "self", ".", "max_learn_iter", "=", "stdp_params", "[", "'max_learn_iter'", "]", "\n", "self", ".", "curr_lay_idx", "=", "0", "\n", "self", ".", "counter", "=", "0", "\n", "self", ".", "curr_img", "=", "0", "\n", "\n", "#STDP params", "\n", "self", ".", "stdp_per_layer", "=", "stdp_params", "[", "'stdp_per_layer'", "]", "\n", "self", ".", "stdp_a_minus", "=", "stdp_params", "[", "'a_minus'", "]", "\n", "self", ".", "stdp_a_plus", "=", "stdp_params", "[", "'a_plus'", "]", "\n", "self", ".", "offsetSTDP", "=", "stdp_params", "[", "'offset_STDP'", "]", "\n", "\n", "# --------------------------- CUDA Parameters -------------------#", "\n", "self", ".", "device", "=", "device", "\n", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "            ", "self", ".", "thds_per_dim", "=", "10", "# (Use 8 if doesn't work)", "\n", "\n", "# --------------------------- Input spike times -------------------#", "\n", "# Generate Iterators with the full path to the images in each set OR reference the spike times", "\n", "", "if", "self", ".", "DoG", ":", "\n", "            ", "self", ".", "spike_times_learn", ",", "self", ".", "y_learn", "=", "self", ".", "gen_iter_paths", "(", "spike_times_learn", ")", "\n", "self", ".", "spike_times_train", ",", "self", ".", "y_train", "=", "self", ".", "gen_iter_paths", "(", "spike_times_train", ",", "n_train_images", ")", "\n", "self", ".", "spike_times_test", ",", "self", ".", "y_test", "=", "self", ".", "gen_iter_paths", "(", "spike_times_test", ")", "\n", "self", ".", "num_img_learn", "=", "self", ".", "y_learn", ".", "size", "\n", "self", ".", "num_img_train", "=", "self", ".", "y_train", ".", "size", "\n", "self", ".", "num_img_test", "=", "self", ".", "y_test", ".", "size", "\n", "self", ".", "spike_times_train", ",", "self", ".", "learn_buffer", "=", "tee", "(", "self", ".", "spike_times_train", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "spike_times_learn", "=", "spike_times_learn", "\n", "self", ".", "num_img_learn", "=", "spike_times_learn", ".", "shape", "[", "0", "]", "\n", "self", ".", "spike_times_train", "=", "spike_times_train", "\n", "self", ".", "num_img_train", "=", "spike_times_train", ".", "shape", "[", "0", "]", "\n", "self", ".", "spike_times_test", "=", "spike_times_test", "\n", "self", ".", "num_img_test", "=", "spike_times_test", ".", "shape", "[", "0", "]", "\n", "self", ".", "y_train", "=", "y_train", "\n", "self", ".", "y_test", "=", "y_test", "\n", "\n", "# --------------------------- Output features -------------------#", "\n", "", "self", ".", "features_train", "=", "[", "]", "\n", "self", ".", "features_test", "=", "[", "]", "\n", "\n", "\n", "# --------------------------- Initialisation functions ------------------------#", "\n", "# Network Structure Initialization", "\n", "", "def", "init_net_struc", "(", "self", ",", "network_params", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.init_net_struc": [[189, 229], ["range", "SDNN_cuda_vary_images.SDNN.network_struc.append", "numpy.array", "math.floor", "int", "int", "SDNN_cuda_vary_images.SDNN.learnable_layers.append", "math.floor", "int", "int", "sys.exit", "int", "int", "math.floor", "math.floor", "int", "int", "math.floor", "math.floor", "math.floor", "math.floor", "math.floor", "math.floor"], "methods", ["None"], ["for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "d_tmp", "=", "{", "}", "\n", "if", "network_params", "[", "i", "]", "[", "'Type'", "]", "==", "'input'", ":", "\n", "                ", "d_tmp", "[", "'Type'", "]", "=", "network_params", "[", "i", "]", "[", "'Type'", "]", "\n", "d_tmp", "[", "'H_layer'", "]", "=", "network_params", "[", "i", "]", "[", "'H_layer'", "]", "\n", "d_tmp", "[", "'W_layer'", "]", "=", "network_params", "[", "i", "]", "[", "'W_layer'", "]", "\n", "d_tmp", "[", "'num_filters'", "]", "=", "network_params", "[", "i", "]", "[", "'num_filters'", "]", "\n", "d_tmp", "[", "'pad'", "]", "=", "network_params", "[", "i", "]", "[", "'pad'", "]", "\n", "d_tmp", "[", "'shape'", "]", "=", "(", "d_tmp", "[", "'H_layer'", "]", ",", "d_tmp", "[", "'W_layer'", "]", ",", "d_tmp", "[", "'num_filters'", "]", ")", "\n", "", "elif", "network_params", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "d_tmp", "[", "'Type'", "]", "=", "network_params", "[", "i", "]", "[", "'Type'", "]", "\n", "d_tmp", "[", "'th'", "]", "=", "network_params", "[", "i", "]", "[", "'th'", "]", "\n", "d_tmp", "[", "'filter_size'", "]", "=", "network_params", "[", "i", "]", "[", "'filter_size'", "]", "\n", "d_tmp", "[", "'num_filters'", "]", "=", "network_params", "[", "i", "]", "[", "'num_filters'", "]", "\n", "d_tmp", "[", "'pad'", "]", "=", "np", ".", "array", "(", "[", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", ",", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", "]", ")", "\n", "d_tmp", "[", "'stride'", "]", "=", "1", "\n", "d_tmp", "[", "'offset'", "]", "=", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", "\n", "d_tmp", "[", "'H_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'H_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "0", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'W_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'W_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "1", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'shape'", "]", "=", "(", "d_tmp", "[", "'H_layer'", "]", ",", "d_tmp", "[", "'W_layer'", "]", ",", "d_tmp", "[", "'num_filters'", "]", ")", "\n", "self", ".", "learnable_layers", ".", "append", "(", "i", ")", "\n", "", "elif", "network_params", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                ", "d_tmp", "[", "'Type'", "]", "=", "network_params", "[", "i", "]", "[", "'Type'", "]", "\n", "d_tmp", "[", "'th'", "]", "=", "network_params", "[", "i", "]", "[", "'th'", "]", "\n", "d_tmp", "[", "'filter_size'", "]", "=", "network_params", "[", "i", "]", "[", "'filter_size'", "]", "\n", "d_tmp", "[", "'num_filters'", "]", "=", "network_params", "[", "i", "]", "[", "'num_filters'", "]", "\n", "d_tmp", "[", "'pad'", "]", "=", "[", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", ",", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", "]", "\n", "d_tmp", "[", "'stride'", "]", "=", "network_params", "[", "i", "]", "[", "'stride'", "]", "\n", "d_tmp", "[", "'offset'", "]", "=", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", "\n", "d_tmp", "[", "'H_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'H_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "0", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'W_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'W_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "1", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'shape'", "]", "=", "(", "d_tmp", "[", "'H_layer'", "]", ",", "d_tmp", "[", "'W_layer'", "]", ",", "d_tmp", "[", "'num_filters'", "]", ")", "\n", "", "else", ":", "\n", "                ", "exit", "(", "\"unknown layer specified: use 'input', 'conv' or 'pool' \"", ")", "\n", "", "self", ".", "network_struc", ".", "append", "(", "d_tmp", ")", "\n", "\n", "# Weights Initialization", "\n", "", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Weight Initialization\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.init_weights": [[231, 252], ["range", "SDNN_cuda_vary_images.SDNN.weights.append", "weights_tmp.astype", "numpy.random.normal", "numpy.ones"], "methods", ["None"], ["std", "=", "self", ".", "weight_params", "[", "'std'", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "            ", "HH", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'filter_size'", "]", "\n", "WW", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'filter_size'", "]", "\n", "MM", "=", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'num_filters'", "]", "\n", "DD", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'num_filters'", "]", "\n", "w_shape", "=", "(", "HH", ",", "WW", ",", "MM", ",", "DD", ")", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "weights_tmp", "=", "(", "mean", "+", "std", "*", "np", ".", "random", ".", "normal", "(", "size", "=", "w_shape", ")", ")", "\n", "weights_tmp", "[", "weights_tmp", ">=", "1.", "]", "=", "0.99", "\n", "weights_tmp", "[", "weights_tmp", "<=", "0.", "]", "=", "0.01", "\n", "", "elif", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                ", "weights_tmp", "=", "np", ".", "ones", "(", "(", "HH", ",", "WW", ",", "MM", ")", ")", "/", "(", "HH", "*", "WW", ")", "\n", "", "else", ":", "\n", "                ", "continue", "\n", "", "self", ".", "weights", ".", "append", "(", "weights_tmp", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n", "# Dimension Checker", "\n", "", "", "def", "check_dimensions", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Checks the dimensions of the SDNN\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.check_dimensions": [[254, 275], ["range", "math.floor", "math.floor"], "methods", ["None"], ["            ", "H_pre", ",", "W_pre", ",", "M_pre", "=", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'shape'", "]", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "HH", ",", "WW", ",", "MM", ",", "DD", "=", "self", ".", "weights", "[", "i", "-", "1", "]", ".", "shape", "\n", "", "else", ":", "\n", "                ", "HH", ",", "WW", ",", "MM", "=", "self", ".", "weights", "[", "i", "-", "1", "]", ".", "shape", "\n", "", "H_post", ",", "W_post", ",", "D_post", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'stride'", "]", "\n", "H_pad", ",", "W_pad", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'pad'", "]", "\n", "\n", "assert", "floor", "(", "(", "H_pre", "+", "2", "*", "H_pad", "-", "HH", ")", "/", "stride", ")", "+", "1", "==", "H_post", ",", "'Error HEIGHT: layer %s to layer %s . '", "'Width does not work'", "%", "(", "i", "-", "1", ",", "i", ")", "\n", "assert", "floor", "(", "(", "W_pre", "+", "2", "*", "W_pad", "-", "WW", ")", "/", "stride", ")", "+", "1", "==", "W_post", ",", "'Error WIDTH: layer %s to layer %s . '", "'Width does not work'", "%", "(", "i", "-", "1", ",", "i", ")", "\n", "assert", "MM", "==", "M_pre", ",", "'Error in DEPTH of PREVIOUS map'", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "assert", "DD", "==", "D_post", ",", "'Error in DEPTH of CURRENT map'", "\n", "\n", "# Initialise layers", "\n", "", "", "", "def", "init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Initialise layers         \n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.init_layers": [[277, 290], ["range", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.ones().astype", "numpy.ones().astype", "SDNN_cuda_vary_images.SDNN.layers.append", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones"], "methods", ["None"], ["            ", "d_tmp", "=", "{", "}", "\n", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "d_tmp", "[", "'S'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "d_tmp", "[", "'V'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "d_tmp", "[", "'K_STDP'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ",", "D", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "d_tmp", "[", "'K_inh'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "self", ".", "layers", ".", "append", "(", "d_tmp", ")", "\n", "", "return", "\n", "\n", "# Layers reset", "\n", "", "def", "reset_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Reset layers         \n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.reset_layers": [[292, 303], ["range", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.ones().astype", "numpy.ones().astype", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones"], "methods", ["None"], ["            ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_STDP'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ",", "D", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "return", "\n", "\n", "# Weights getter", "\n", "", "def", "get_weights", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "weights", "\n", "\n", "# Weights setter", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.get_weights": [[305, 307], ["None"], "methods", ["None"], ["        "]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.set_weights": [[309, 322], ["range", "numpy.load", "SDNN_cuda_vary_images.SDNN.weights.append", "numpy.load.astype"], "methods", ["None"], ["\n", "self", ".", "weights", "=", "[", "]", "\n", "for", "id", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "            ", "weight_tmp", "=", "np", ".", "load", "(", "path_list", "[", "id", "]", ")", "\n", "self", ".", "weights", ".", "append", "(", "weight_tmp", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "", "return", "\n", "\n", "# Generates an iterator with the path to image sets", "\n", "# Zied Generate one single image from each folder", "\n", "", "def", "gen_iter_paths", "(", "self", ",", "path_list", ",", "n_images_to_consider", "=", "99999999", ")", ":", "\n", "        ", "images_per_dataset", "=", "min", "(", "len", "(", "listdir", "(", "path_list", "[", "0", "]", ")", ")", ",", "n_images_to_consider", ")", "\n", "labels", "=", "np", ".", "ones", "(", "images_per_dataset", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.gen_iter_paths": [[324, 344], ["min", "numpy.ones", "os.listdir", "random.shuffle", "iter", "range", "len", "len", "os.listdir", "random.shuffle", "numpy.append", "iter", "itertools.chain", "os.listdir", "range", "numpy.ones", "len", "range", "len"], "methods", ["None"], ["random", ".", "shuffle", "(", "list_im", ")", "\n", "#paths_iter = iter([path_list[0] + listdir(path_list[0])[i] for i in range(labels.size)])", "\n", "paths_iter", "=", "iter", "(", "[", "path_list", "[", "0", "]", "+", "list_im", "[", "i", "]", "for", "i", "in", "range", "(", "labels", ".", "size", ")", "]", ")", "\n", "for", "idir", "in", "range", "(", "1", ",", "len", "(", "path_list", ")", ")", ":", "\n", "            ", "list_im2", "=", "listdir", "(", "path_list", "[", "idir", "]", ")", "\n", "random", ".", "shuffle", "(", "list_im2", ")", "\n", "#file_names = listdir(path_list[idir])", "\n", "file_names", "=", "list_im2", "[", ":", "images_per_dataset", "]", "\n", "labels", "=", "np", ".", "append", "(", "labels", ",", "(", "idir", "+", "1", ")", "*", "np", ".", "ones", "(", "len", "(", "file_names", ")", ")", ")", "\n", "files_tmp", "=", "iter", "(", "[", "path_list", "[", "idir", "]", "+", "file_names", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "file_names", ")", ")", "]", ")", "\n", "paths_iter", "=", "chain", "(", "paths_iter", ",", "files_tmp", ")", "\n", "", "return", "paths_iter", ",", "labels", "\n", "\n", "# --------------------------- STDP Learning functions ------------------------#", "\n", "# Propagate and STDP once", "\n", "", "def", "train_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Propagates one image through the SDNN network and carries out the STDP update on the learning layer\n        \"\"\"", "\n", "\n", "# Propagate", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.train_step": [[348, 426], ["range", "range", "numpy.pad", "SDNN_cuda_vary_images.SDNN.convolution", "SDNN_cuda_vary_images.SDNN.lateral_inh", "numpy.count_nonzero", "numpy.sum", "numpy.pad", "SDNN_cuda_vary_images.SDNN.get_STDP_idxs", "SDNN_cuda_vary_images.SDNN.STDP", "int", "int", "int", "SDNN_cuda_vary_images.SDNN.pooling", "int", "math.ceil", "int", "math.ceil", "int", "math.ceil", "SDNN_cuda_vary_images.SDNN.lateral_inh", "int", "int", "int", "math.ceil", "math.ceil", "math.ceil", "int", "math.ceil", "int", "math.ceil", "int", "math.ceil", "math.ceil", "math.ceil", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.get_STDP_idxs", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.STDP", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh"], ["                ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "H_pad", ",", "W_pad", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'pad'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'stride'", "]", "\n", "th", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'th'", "]", "\n", "\n", "w", "=", "self", ".", "weights", "[", "i", "-", "1", "]", "\n", "s", "=", "self", ".", "layers", "[", "i", "-", "1", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Input spikes", "\n", "s", "=", "np", ".", "pad", "(", "s", ",", "(", "(", "H_pad", ",", "H_pad", ")", ",", "(", "W_pad", ",", "W_pad", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ")", "# Pad the input", "\n", "S", "=", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output spikes", "\n", "V", "=", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Output voltage before", "\n", "K_inh", "=", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "# Lateral inhibition matrix", "\n", "\n", "blockdim", "=", "(", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "0", "]", ")", ")", "if", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "1", "]", ")", ")", "if", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "if", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ")", "\n", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                    ", "V", ",", "S", "=", "self", ".", "convolution", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "V", "\n", "\n", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "", "elif", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                    ", "S", "=", "self", ".", "pooling", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "\n", "if", "i", "<", "3", ":", "\n", "                        ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "# STDP learning", "\n", "", "", "", "lay", "=", "self", ".", "learning_layer", "\n", "if", "self", ".", "network_struc", "[", "lay", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "\n", "# valid are neurons in the learning layer that can do STDP and that have fired in the current t", "\n", "                ", "S", "=", "self", ".", "layers", "[", "lay", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output spikes", "\n", "V", "=", "self", ".", "layers", "[", "lay", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output voltage", "\n", "K_STDP", "=", "self", ".", "layers", "[", "lay", "]", "[", "'K_STDP'", "]", "# Lateral inhibition matrix", "\n", "valid", "=", "S", "*", "V", "*", "K_STDP", "\n", "\n", "if", "np", ".", "count_nonzero", "(", "valid", ")", ">", "0", ":", "\n", "\n", "                    ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "lay", "]", "[", "'shape'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "lay", "]", "[", "'stride'", "]", "\n", "offset", "=", "self", ".", "offsetSTDP", "[", "lay", "]", "\n", "a_minus", "=", "self", ".", "stdp_a_minus", "[", "lay", "]", "\n", "a_plus", "=", "self", ".", "stdp_a_plus", "[", "lay", "]", "\n", "\n", "s", "=", "self", ".", "layers", "[", "lay", "-", "1", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", ":", "t", "]", "# Input spikes", "\n", "ssum", "=", "np", ".", "sum", "(", "s", ",", "axis", "=", "3", ")", "\n", "s", "=", "np", ".", "pad", "(", "ssum", ",", "(", "(", "H_pad", ",", "H_pad", ")", ",", "(", "W_pad", ",", "W_pad", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ")", "# Pad the input", "\n", "w", "=", "self", ".", "weights", "[", "lay", "-", "1", "]", "\n", "\n", "maxval", ",", "maxind1", ",", "maxind2", "=", "self", ".", "get_STDP_idxs", "(", "valid", ",", "H", ",", "W", ",", "D", ",", "lay", ")", "\n", "\n", "blockdim", "=", "(", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "0", "]", ")", ")", "if", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "1", "]", ")", ")", "if", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "if", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ")", "\n", "\n", "w", ",", "K_STDP", "=", "self", ".", "STDP", "(", "S", ".", "shape", ",", "s", ",", "w", ",", "K_STDP", ",", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "\n", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "weights", "[", "lay", "-", "1", "]", "=", "w", "\n", "self", ".", "layers", "[", "lay", "]", "[", "'K_STDP'", "]", "=", "K_STDP", "\n", "\n", "# Train all images in training set", "\n", "", "", "", "", "def", "train_SDNN", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Trains the SDNN with the learning set of images\n            \n            We iterate over the set of images a maximum of self.max_iter times\n        \"\"\"", "\n", "\n", "#print(\"-----------------------------------------------------------\")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.train_SDNN": [[430, 482], ["print", "print", "print", "range", "print", "print", "print", "print", "print", "SDNN_cuda_vary_images.SDNN.reset_layers", "SDNN_cuda_vary_images.SDNN.train_step", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "min", "next", "itertools.tee", "next", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter"], ["            ", "\"\"\"\n            print(\"----------------- Learning Progress  {}%----------------------\".format(str(i) + '/'\n                                                                                          + str(self.max_iter)\n                                                                                          + ' ('\n                                                                                          + str(100 * i / self.max_iter)\n                                                                                          + ')'))\n            \"\"\"", "\n", "if", "self", ".", "counter", ">", "self", ".", "max_learn_iter", "[", "self", ".", "learning_layer", "]", ":", "\n", "                ", "self", ".", "curr_lay_idx", "+=", "1", "\n", "self", ".", "learning_layer", "=", "self", ".", "learnable_layers", "[", "self", ".", "curr_lay_idx", "]", "\n", "self", ".", "counter", "=", "0", "\n", "", "self", ".", "counter", "+=", "1", "\n", "\n", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "try", ":", "\n", "                    ", "path_img", "=", "next", "(", "self", ".", "learn_buffer", ")", "\n", "", "except", ":", "\n", "                    ", "self", ".", "spike_times_train", ",", "self", ".", "learn_buffer", "=", "tee", "(", "self", ".", "spike_times_train", ")", "\n", "path_img", "=", "next", "(", "self", ".", "learn_buffer", ")", "\n", "", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_learn", "[", "self", ".", "curr_img", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "train_step", "(", ")", "\n", "\n", "if", "i", "%", "500", "==", "0", ":", "\n", "                ", "self", ".", "stdp_a_plus", "[", "self", ".", "learning_layer", "]", "=", "min", "(", "2.", "*", "self", ".", "stdp_a_plus", "[", "self", ".", "learning_layer", "]", ",", "0.15", ")", "\n", "self", ".", "stdp_a_minus", "[", "self", ".", "learning_layer", "]", "=", "0.75", "*", "self", ".", "stdp_a_plus", "[", "self", ".", "learning_layer", "]", "\n", "\n", "", "if", "self", ".", "curr_img", "+", "1", "<", "self", ".", "num_img_learn", ":", "\n", "                ", "self", ".", "curr_img", "+=", "1", "\n", "", "else", ":", "\n", "                ", "self", ".", "curr_img", "=", "0", "\n", "", "", "\"\"\"\n        print(\"----------------- Learning Progress  {}%----------------------\".format(str(self.max_iter) + '/'\n                                                                                      + str(self.max_iter)\n                                                                                      + ' ('\n                                                                                      + str(100)\n                                                                                      + ')'))\n        \"\"\"", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "#print(\"------------------- LEARNING COMPLETED --------------------\")", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "\n", "# Find STDP update indices and potentials", "\n", "", "def", "get_STDP_idxs", "(", "self", ",", "valid", ",", "H", ",", "W", ",", "D", ",", "layer_idx", ")", ":", "\n", "        ", "\"\"\"\n            Finds the indices and potentials of the post-synaptic neurons to update. \n            Only one update per map (if allowed) \n        \"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.get_STDP_idxs": [[484, 526], ["numpy.amax", "numpy.argmax", "numpy.squeeze().astype", "numpy.squeeze().astype", "numpy.squeeze().astype", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.sum", "numpy.amax", "numpy.argmax", "numpy.argmax", "numpy.sum", "numpy.squeeze", "numpy.squeeze", "numpy.squeeze", "max", "max", "min", "min"], "methods", ["None"], ["STDP_counter", "=", "1", "\n", "\n", "mxv", "=", "np", ".", "amax", "(", "valid", ",", "axis", "=", "2", ")", "\n", "mxi", "=", "np", ".", "argmax", "(", "valid", ",", "axis", "=", "2", ")", "\n", "\n", "maxind1", "=", "np", ".", "ones", "(", "(", "D", ",", "1", ")", ")", "*", "-", "1", "\n", "maxind2", "=", "np", ".", "ones", "(", "(", "D", ",", "1", ")", ")", "*", "-", "1", "\n", "maxval", "=", "np", ".", "ones", "(", "(", "D", ",", "1", ")", ")", "*", "-", "1", "\n", "\n", "while", "np", ".", "sum", "(", "np", ".", "sum", "(", "mxv", ")", ")", "!=", "0.", ":", "\n", "# for each layer a certain number of neurons can do the STDP per image", "\n", "            ", "if", "STDP_counter", ">", "self", ".", "stdp_per_layer", "[", "i", "]", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "STDP_counter", "+=", "1", "\n", "\n", "", "maximum", "=", "np", ".", "amax", "(", "mxv", ",", "axis", "=", "1", ")", "\n", "index", "=", "np", ".", "argmax", "(", "mxv", ",", "axis", "=", "1", ")", "\n", "\n", "index1", "=", "np", ".", "argmax", "(", "maximum", ")", "\n", "index2", "=", "index", "[", "index1", "]", "\n", "\n", "maxval", "[", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "mxv", "[", "index1", ",", "index2", "]", "\n", "maxind1", "[", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "index1", "\n", "maxind2", "[", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "index2", "\n", "\n", "mxv", "[", "mxi", "==", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "0", "\n", "mxv", "[", "max", "(", "index1", "-", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "0", ")", ":", "min", "(", "index1", "+", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "H", ")", "+", "1", ",", "\n", "max", "(", "index2", "-", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "0", ")", ":", "min", "(", "index2", "+", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "W", ")", "+", "1", "]", "=", "0", "\n", "\n", "", "maxval", "=", "np", ".", "squeeze", "(", "maxval", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "maxind1", "=", "np", ".", "squeeze", "(", "maxind1", ")", ".", "astype", "(", "np", ".", "int16", ")", "\n", "maxind2", "=", "np", ".", "squeeze", "(", "maxind2", ")", ".", "astype", "(", "np", ".", "int16", ")", "\n", "\n", "return", "maxval", ",", "maxind1", ",", "maxind2", "\n", "\n", "# --------------------------- Propagation functions ------------------------#", "\n", "# Propagate once", "\n", "", "def", "prop_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Propagates one image through the SDNN network. \n            This function is identical to train_step() but here  no STDP takes place and we always reach the last layer\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.prop_step": [[529, 585], ["range", "range", "numpy.pad", "int", "int", "int", "SDNN_cuda_vary_images.SDNN.convolution", "SDNN_cuda_vary_images.SDNN.convolution_CPU", "SDNN_cuda_vary_images.SDNN.lateral_inh", "SDNN_cuda_vary_images.SDNN.lateral_inh_CPU", "int", "math.ceil", "int", "math.ceil", "int", "math.ceil", "SDNN_cuda_vary_images.SDNN.pooling", "SDNN_cuda_vary_images.SDNN.pooling_CPU", "math.ceil", "math.ceil", "math.ceil", "SDNN_cuda_vary_images.SDNN.lateral_inh", "SDNN_cuda_vary_images.SDNN.lateral_inh_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution_CPU", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling_CPU", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU"], ["for", "t", "in", "range", "(", "1", ",", "self", ".", "total_time", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "\n", "                ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "H_pad", ",", "W_pad", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'pad'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'stride'", "]", "\n", "th", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'th'", "]", "\n", "\n", "w", "=", "self", ".", "weights", "[", "i", "-", "1", "]", "\n", "s", "=", "self", ".", "layers", "[", "i", "-", "1", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Input spikes", "\n", "s", "=", "np", ".", "pad", "(", "s", ",", "(", "(", "H_pad", ",", "H_pad", ")", ",", "(", "W_pad", ",", "W_pad", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ")", "# Pad the input", "\n", "S", "=", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output spikes", "\n", "V", "=", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Output voltage before", "\n", "K_inh", "=", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "# Lateral inhibition matrix", "\n", "\n", "blockdim", "=", "(", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "0", "]", ")", ")", "if", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "1", "]", ")", ")", "if", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "if", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ")", "\n", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                    ", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                        ", "V", ",", "S", "=", "self", ".", "convolution", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                        ", "V", ",", "S", "=", "self", ".", "convolution_CPU", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "V", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "\n", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                        ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                        ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "", "elif", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                    ", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                        ", "S", "=", "self", ".", "pooling", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                        ", "S", "=", "self", ".", "pooling_CPU", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "\n", "if", "i", "<", "3", ":", "\n", "                        ", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                            ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                            ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "# Get training features", "\n", "", "", "", "", "", "def", "train_features", "(", "self", ")", ":", "\n", "        "]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.train_features": [[603, 901], ["random.seed", "numpy.random.seed", "set", "list", "list", "range", "range", "range", "print", "sys.exit", "numpy.random.normal", "list", "random.shuffle", "zip", "range", "SDNN_cuda_vary_images.SDNN.reset_layers", "SDNN_cuda_vary_images.SDNN.prop_step", "range", "classes_scores_train.append", "classes_scores_train_POT.append", "SDNN_cuda_vary_images.SDNN.reset_layers", "SDNN_cuda_vary_images.SDNN.prop_step", "range", "classes_scores_test.append", "classes_scores_test_POT.append", "zip", "SDNN_cuda_vary_images.SDNN.reset_layers", "SDNN_cuda_vary_images.SDNN.prop_step", "range", "next", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.where", "tuple", "tuple", "tuple", "next", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.where", "tuple", "tuple", "tuple", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.where", "tuple", "set", "set", "SDNN_cuda_vary_images.SDNN.pool_spikes", "numpy.sum", "numpy.sum", "scores.values", "pot_scores.values", "max", "max", "float", "float", "set", "set", "SDNN_cuda_vary_images.SDNN.pool_spikes", "numpy.sum", "numpy.sum", "scores.values", "pot_scores.values", "max", "max", "float", "float", "SDNN_cuda_vary_images.SDNN.pool_spikes", "numpy.argsort", "numpy.array", "max", "max", "numpy.argsort", "numpy.array", "max", "max", "numpy.argsort", "numpy.array", "numpy.argsort", "scores.items", "pot_scores.items", "numpy.argsort", "scores.items", "pot_scores.items", "numpy.argsort", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes"], ["self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "path_img", "=", "next", "(", "self", ".", "spike_times_train", ")", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_train", "[", "i", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "# Obtain maximum potential per map in last layer", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "features", "=", "np", ".", "max", "(", "np", ".", "max", "(", "np", ".", "max", "(", "V", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", ",", "axis", "=", "1", ")", "\n", "self", ".", "features_train", ".", "append", "(", "features", ")", "\n", "\n", "\n", "dt", "=", "timer", "(", ")", "-", "start", "\n", "print", "(", "dt", ")", "\n", "\n", "# Transform features to numpy array", "\n", "", "n_features", "=", "self", ".", "features_train", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "n_train_samples", "=", "len", "(", "self", ".", "features_train", ")", "\n", "X_train", "=", "np", ".", "concatenate", "(", "self", ".", "features_train", ")", ".", "reshape", "(", "(", "n_train_samples", ",", "n_features", ")", ")", "\n", "\"\"\"\n        print(\"------------ Train features Extraction Progress  {}%----------------\".format(str(self.num_img_train)\n                                                                                            + '/'\n                                                                                            + str(self.num_img_train)\n                                                                                            + ' ('\n                                                                                            + str(100)\n                                                                                            + ')'))\n        \"\"\"", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "#print(\"------------- TRAINING FEATURES EXTRACTED -----------------\")", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "\n", "# Clear Features", "\n", "self", ".", "features_train", "=", "[", "]", "\n", "return", "X_train", ",", "self", ".", "y_train", "\n", "\n", "# Get test features", "\n", "", "def", "test_features", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Gets the test features by propagating the set of training images\n            Returns:\n                - X_test: Training features of size (N, M)\n                            where N is the number of training samples\n                            and M is the number of maps in the last layer\n        \"\"\"", "\n", "self", ".", "network_struc", "[", "3", "]", "[", "'th'", "]", "=", "50.", "\n", "self", ".", "network_struc", "[", "5", "]", "[", "'th'", "]", "=", "100000", "# Set threshold of last layer to inf", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "#print(\"---------------- EXTRACTING TEST FEATURES -----------------\")", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_img_test", ")", ":", "\n", "            ", "\"\"\"\n            print(\"------------ Test features Extraction Progress  {}%----------------\".format(str(i) + '/'\n                                                                                               + str(self.num_img_test)\n                                                                                               + ' ('\n                                                                                               + str(100 * i / self.num_img_test)\n                                                                                               + ')'))\n            \"\"\"", "\n", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "path_img", "=", "next", "(", "self", ".", "spike_times_test", ")", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_test", "[", "i", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "# Obtain maximum potential per map in last layer", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "features", "=", "np", ".", "max", "(", "np", ".", "max", "(", "np", ".", "max", "(", "V", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", ",", "axis", "=", "1", ")", "\n", "self", ".", "features_test", ".", "append", "(", "features", ")", "\n", "\n", "# Transform features to numpy array", "\n", "", "n_features", "=", "self", ".", "features_test", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "n_train_samples", "=", "len", "(", "self", ".", "features_test", ")", "\n", "X_test", "=", "np", ".", "concatenate", "(", "self", ".", "features_test", ")", ".", "reshape", "(", "(", "n_train_samples", ",", "n_features", ")", ")", "\n", "\"\"\"\n        print(\"------------ Test features Extraction Progress  {}%----------------\".format(str(self.num_img_test)\n                                                                                           + '/'\n                                                                                           + str(self.num_img_test)\n                                                                                           + ' ('\n                                                                                           + str(100)\n                                                                                           + ')'))\n        print(\"-----------------------------------------------------------\")\n        print(\"---------------- TEST FEATURES EXTRACTED ------------------\")\n        print(\"-----------------------------------------------------------\")\n        \"\"\"", "\n", "# Clear Features", "\n", "self", ".", "features_test", "=", "[", "]", "\n", "return", "X_test", ",", "self", ".", "y_test", "\n", "\n", "# --------------------------- CUDA interfacing functions ------------------------#", "\n", "", "def", "convolution", "(", "self", ",", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda Convolution Kernel call\n            Returns the updated potentials and spike times\n        \"\"\"", "\n", "d_S", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_V", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "V", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "d_s", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "s", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_w", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "w", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "V_out", "=", "np", ".", "empty", "(", "d_V", ".", "shape", ",", "dtype", "=", "d_V", ".", "dtype", ")", "\n", "S_out", "=", "np", ".", "empty", "(", "d_S", ".", "shape", ",", "dtype", "=", "d_S", ".", "dtype", ")", "\n", "conv_step", "[", "griddim", ",", "blockdim", "]", "(", "d_S", ",", "d_V", ",", "d_s", ",", "d_w", ",", "stride", ",", "th", ")", "\n", "d_V", ".", "copy_to_host", "(", "V_out", ")", "\n", "d_S", ".", "copy_to_host", "(", "S_out", ")", "\n", "return", "V_out", ",", "S_out", "\n", "\n", "", "def", "lateral_inh", "(", "self", ",", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda Lateral Inhibition Kernel call\n            Returns the updated spike times and inhibition matrix\n        \"\"\"", "\n", "d_S", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_V", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "V", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "d_K_inh", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "K_inh", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "S_out", "=", "np", ".", "empty", "(", "d_S", ".", "shape", ",", "dtype", "=", "d_S", ".", "dtype", ")", "\n", "K_inh_out", "=", "np", ".", "empty", "(", "d_K_inh", ".", "shape", ",", "dtype", "=", "d_K_inh", ".", "dtype", ")", "\n", "lateral_inh", "[", "griddim", ",", "blockdim", "]", "(", "d_S", ",", "d_V", ",", "d_K_inh", ")", "\n", "d_S", ".", "copy_to_host", "(", "S_out", ")", "\n", "d_K_inh", ".", "copy_to_host", "(", "K_inh_out", ")", "\n", "return", "S_out", ",", "K_inh_out", "\n", "\n", "", "def", "pooling", "(", "self", ",", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda Pooling Kernel call\n            Returns the updated spike times\n        \"\"\"", "\n", "d_S", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_s", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "s", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_w", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "w", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "S_out", "=", "np", ".", "empty", "(", "d_S", ".", "shape", ",", "dtype", "=", "d_S", ".", "dtype", ")", "\n", "pool", "[", "griddim", ",", "blockdim", "]", "(", "d_S", ",", "d_s", ",", "d_w", ",", "stride", ",", "th", ")", "\n", "d_S", ".", "copy_to_host", "(", "S_out", ")", "\n", "return", "S_out", "\n", "\n", "", "def", "STDP", "(", "self", ",", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "maxval", ",", "maxind1", ",", "maxind2", ",", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda STDP-Update Kernel call\n            Returns the updated weight and STDP allowed matrix\n        \"\"\"", "\n", "d_S_sz", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S_sz", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "d_s", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "s", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_w", "=", "cuda", ".", "to_device", "(", "w", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "d_K_STDP", "=", "cuda", ".", "to_device", "(", "K_STDP", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "w_out", "=", "np", ".", "empty", "(", "d_w", ".", "shape", ",", "dtype", "=", "d_w", ".", "dtype", ")", "\n", "K_STDP_out", "=", "np", ".", "empty", "(", "d_K_STDP", ".", "shape", ",", "dtype", "=", "d_K_STDP", ".", "dtype", ")", "\n", "STDP_learning", "[", "griddim", ",", "blockdim", "]", "(", "d_S_sz", ",", "d_s", ",", "d_w", ",", "d_K_STDP", ",", "# Input arrays", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "# Indices", "\n", "stride", ",", "int", "(", "offset", ")", ",", "a_minus", ",", "a_plus", ")", "# Parameters", "\n", "d_w", ".", "copy_to_host", "(", "w_out", ")", "\n", "d_K_STDP", ".", "copy_to_host", "(", "K_STDP_out", ")", "\n", "return", "w_out", ",", "K_STDP_out", "\n", "\n", "\n", "# --------------------------- CPU interfacing functions ------------------------#", "\n", "", "def", "convolution_CPU", "(", "self", ",", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "        ", "\"\"\"\n            CPU Convolution Function call\n            Returns the updated potentials and spike times\n        \"\"\"", "\n", "V_out", ",", "S_out", "=", "conv_step_CPU", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "return", "V_out", ",", "S_out", "\n", "\n", "", "def", "lateral_inh_CPU", "(", "self", ",", "S", ",", "V", ",", "K_inh", ")", ":", "\n", "        ", "\"\"\"\n            CPU Lateral Inhibition Function call\n            Returns the updated spike times and inhibition matrix\n        \"\"\"", "\n", "S_out", ",", "K_inh_out", "=", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", "\n", "return", "S_out", ",", "K_inh_out", "\n", "\n", "", "def", "pooling_CPU", "(", "self", ",", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "        ", "\"\"\"\n            CPU Pooling Function call\n            Returns the updated spike times\n        \"\"\"", "\n", "S_out", "=", "pool_CPU", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "return", "S_out", "\n", "\n", "", "def", "STDP_CPU", "(", "self", ",", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "maxval", ",", "maxind1", ",", "maxind2", ",", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ")", ":", "\n", "            ", "\"\"\"\n                CPU STDP-Update Function call\n                Returns the updated weight and STDP allowed matrix\n            \"\"\"", "\n", "w_out", ",", "K_STDP_out", "=", "STDP_learning_CPU", "(", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "# Input arrays", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "# Indices", "\n", "stride", ",", "int", "(", "offset", ")", ",", "a_minus", ",", "a_plus", ")", "# Parameters", "\n", "return", "w_out", ",", "K_STDP_out", "\n", "", "", ""]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.test_features": [[643, 697], ["range", "len", "numpy.concatenate().reshape", "SDNN_cuda_vary_images.SDNN.reset_layers", "SDNN_cuda_vary_images.SDNN.prop_step", "numpy.max", "SDNN_cuda_vary_images.SDNN.features_test.append", "next", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.max", "numpy.concatenate", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter"], ["", "def", "test_features", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Gets the test features by propagating the set of training images\n            Returns:\n                - X_test: Training features of size (N, M)\n                            where N is the number of training samples\n                            and M is the number of maps in the last layer\n        \"\"\"", "\n", "self", ".", "network_struc", "[", "3", "]", "[", "'th'", "]", "=", "50.", "\n", "self", ".", "network_struc", "[", "5", "]", "[", "'th'", "]", "=", "100000", "# Set threshold of last layer to inf", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "#print(\"---------------- EXTRACTING TEST FEATURES -----------------\")", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_img_test", ")", ":", "\n", "            ", "\"\"\"\n            print(\"------------ Test features Extraction Progress  {}%----------------\".format(str(i) + '/'\n                                                                                               + str(self.num_img_test)\n                                                                                               + ' ('\n                                                                                               + str(100 * i / self.num_img_test)\n                                                                                               + ')'))\n            \"\"\"", "\n", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "path_img", "=", "next", "(", "self", ".", "spike_times_test", ")", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_test", "[", "i", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "# Obtain maximum potential per map in last layer", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "features", "=", "np", ".", "max", "(", "np", ".", "max", "(", "np", ".", "max", "(", "V", ",", "axis", "=", "0", ")", ",", "axis", "=", "0", ")", ",", "axis", "=", "1", ")", "\n", "self", ".", "features_test", ".", "append", "(", "features", ")", "\n", "\n", "# Transform features to numpy array", "\n", "", "n_features", "=", "self", ".", "features_test", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "n_train_samples", "=", "len", "(", "self", ".", "features_test", ")", "\n", "X_test", "=", "np", ".", "concatenate", "(", "self", ".", "features_test", ")", ".", "reshape", "(", "(", "n_train_samples", ",", "n_features", ")", ")", "\n", "\"\"\"\n        print(\"------------ Test features Extraction Progress  {}%----------------\".format(str(self.num_img_test)\n                                                                                           + '/'\n                                                                                           + str(self.num_img_test)\n                                                                                           + ' ('\n                                                                                           + str(100)\n                                                                                           + ')'))\n        print(\"-----------------------------------------------------------\")\n        print(\"---------------- TEST FEATURES EXTRACTED ------------------\")\n        print(\"-----------------------------------------------------------\")\n        \"\"\"", "\n", "# Clear Features", "\n", "self", ".", "features_test", "=", "[", "]", "\n", "return", "X_test", ",", "self", ".", "y_test", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.convolution": [[1022, 1037], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.lateral_inh": [[1038, 1052], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.pooling": [[1053, 1065], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.STDP": [[1066, 1083], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "w.astype", "K_STDP.astype", "int", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.convolution_CPU": [[1086, 1093], ["cpu_utils.conv_step_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.conv_step_CPU"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.lateral_inh_CPU": [[1094, 1101], ["cpu_utils.lateral_inh_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.pooling_CPU": [[1102, 1109], ["cpu_utils.pool_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.pool_CPU"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.STDP_CPU": [[1110, 1119], ["cpu_utils.STDP_learning_CPU", "int"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.STDP_learning_CPU"], []], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.conv_step_CPU": [[8, 20], ["range", "range", "numpy.ones", "range", "numpy.sum"], "function", ["None"], ["@", "jit", "\n", "def", "conv_step_CPU", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "\n", "    ", "V", "[", "V", ">", "th", "]", "=", "0.", "\n", "for", "i", "in", "range", "(", "V", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "V", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "V", ".", "shape", "[", "2", "]", ")", ":", "\n", "                ", "V", "[", "i", ",", "j", ",", "k", "]", "+=", "np", ".", "sum", "(", "w", "[", ":", ",", ":", ",", ":", ",", "k", "]", "*", "s", "[", "i", "*", "stride", ":", "i", "*", "stride", "+", "w", ".", "shape", "[", "0", "]", ",", "j", "*", "stride", ":", "j", "*", "stride", "+", "w", ".", "shape", "[", "1", "]", ",", ":", "]", ")", "\n", "\n", "\n", "", "", "", "S", "=", "(", "V", ">", "th", ")", ".", "astype", "(", "int", ")", "*", "np", ".", "ones", "(", "S", ".", "shape", ")", "\n", "return", "V", ",", "S", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.pool_CPU": [[21, 32], ["numpy.zeros", "range", "range", "numpy.ones", "range", "numpy.sum"], "function", ["None"], ["", "@", "jit", "\n", "def", "pool_CPU", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "\n", "    ", "V_tmp", "=", "np", ".", "zeros", "(", "S", ".", "shape", ")", "\n", "for", "i", "in", "range", "(", "S", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "S", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "S", ".", "shape", "[", "2", "]", ")", ":", "\n", "                ", "V_tmp", "[", "i", ",", "j", ",", "k", "]", "+=", "np", ".", "sum", "(", "w", "[", ":", ",", ":", ",", "k", "]", "*", "s", "[", "i", "*", "stride", ":", "i", "*", "stride", "+", "w", ".", "shape", "[", "0", "]", ",", "j", "*", "stride", ":", "j", "*", "stride", "+", "w", ".", "shape", "[", "1", "]", ",", "k", "]", ")", "\n", "\n", "", "", "", "S", "=", "(", "V_tmp", ">", "th", ")", ".", "astype", "(", "int", ")", "*", "np", ".", "ones", "(", "S", ".", "shape", ")", "\n", "return", "S", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.lateral_inh_CPU": [[33, 57], ["numpy.ones", "numpy.ones", "range", "range", "range", "range"], "function", ["None"], ["", "@", "jit", "\n", "def", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", ":", "\n", "    ", "S_inh", "=", "np", ".", "ones", "(", "S", ".", "shape", ",", "dtype", "=", "S", ".", "dtype", ")", "\n", "K", "=", "np", ".", "ones", "(", "K_inh", ".", "shape", ",", "dtype", "=", "K_inh", ".", "dtype", ")", "\n", "for", "i", "in", "range", "(", "V", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "V", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "for", "k", "in", "range", "(", "V", ".", "shape", "[", "2", "]", ")", ":", "\n", "                ", "flag", "=", "False", "\n", "if", "S", "[", "i", ",", "j", ",", "k", "]", "!=", "1", ":", "\n", "                    ", "continue", "\n", "", "if", "K_inh", "[", "i", ",", "j", "]", "==", "0", ":", "\n", "                    ", "S_inh", "[", "i", ",", "j", ",", "k", "]", "=", "0", "\n", "continue", "\n", "", "for", "kz", "in", "range", "(", "V", ".", "shape", "[", "2", "]", ")", ":", "\n", "                    ", "if", "S", "[", "i", ",", "j", ",", "kz", "]", "==", "1", "and", "V", "[", "i", ",", "j", ",", "k", "]", "<", "V", "[", "i", ",", "j", ",", "kz", "]", ":", "\n", "                        ", "S_inh", "[", "i", ",", "j", ",", "k", "]", "=", "0", "\n", "flag", "=", "True", "\n", "", "", "if", "flag", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "K", "[", "i", ",", "j", "]", "=", "0", "\n", "", "", "", "", "S", "*=", "S_inh", "\n", "K_inh", "*=", "K", "\n", "return", "S", ",", "K_inh", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.STDP_learning_CPU": [[77, 131], ["range", "range", "range", "range", "numpy.zeros", "range", "range", "range"], "function", ["None"], ["", "@", "jit", "\n", "def", "STDP_learning_CPU", "(", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "# Input arrays", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "# Indices", "\n", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ")", ":", "# Parameters", "\n", "    ", "for", "idx", "in", "range", "(", "S_sz", "[", "0", "]", ")", ":", "\n", "        ", "for", "idy", "in", "range", "(", "S_sz", "[", "1", "]", ")", ":", "\n", "            ", "for", "idz", "in", "range", "(", "S_sz", "[", "2", "]", ")", ":", "\n", "\n", "                ", "if", "idx", "!=", "maxind1", "[", "idz", "]", "or", "idy", "!=", "maxind2", "[", "idz", "]", ":", "# Check if this is the neuron we have to update (correct idx, idy for map idz)", "\n", "                    ", "continue", "\n", "\n", "", "for", "i", "in", "range", "(", "w", ".", "shape", "[", "3", "]", ")", ":", "\n", "                    ", "if", "(", "idz", "!=", "i", "and", "maxind1", "[", "idz", "]", "<=", "maxind1", "[", "i", "]", "+", "offset", "\n", "and", "maxind1", "[", "idz", "]", ">=", "maxind1", "[", "i", "]", "-", "offset", "\n", "and", "maxind2", "[", "idz", "]", "<=", "maxind2", "[", "i", "]", "+", "offset", "\n", "and", "maxind2", "[", "idz", "]", ">=", "maxind2", "[", "i", "]", "-", "offset", "\n", "and", "maxval", "[", "i", "]", ">", "maxval", "[", "idz", "]", ")", ":", "\n", "                        ", "maxval", "[", "idz", "]", "=", "0.", "\n", "\n", "# Weights STDP update", "\n", "", "", "if", "maxval", "[", "idz", "]", ">", "0", ":", "\n", "# Weights STDP update", "\n", "                    ", "input", "=", "np", ".", "zeros", "(", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", ".", "shape", ")", "\n", "if", "idy", "*", "stride", ">=", "S_sz", "[", "1", "]", "-", "w", ".", "shape", "[", "1", "]", "and", "idx", "*", "stride", ">=", "S_sz", "[", "0", "]", "-", "w", ".", "shape", "[", "0", "]", ":", "\n", "                        ", "ss", "=", "s", "[", "idx", "*", "stride", ":", ",", "idy", "*", "stride", ":", ",", ":", "]", "\n", "input", "[", ":", "ss", ".", "shape", "[", "0", "]", ",", ":", "ss", ".", "shape", "[", "1", "]", ",", ":", "]", "=", "ss", "\n", "", "elif", "idy", "*", "stride", ">=", "S_sz", "[", "1", "]", "-", "w", ".", "shape", "[", "1", "]", ":", "\n", "                        ", "ss", "=", "s", "[", "idx", "*", "stride", ":", "idx", "*", "stride", "+", "w", ".", "shape", "[", "0", "]", ",", "idy", "*", "stride", ":", ",", ":", "]", "\n", "input", "[", ":", ",", ":", "ss", ".", "shape", "[", "1", "]", ",", ":", "]", "=", "ss", "\n", "", "elif", "idx", "*", "stride", ">=", "S_sz", "[", "0", "]", "-", "w", ".", "shape", "[", "0", "]", ":", "\n", "                        ", "ss", "=", "s", "[", "idx", "*", "stride", ":", ",", "idy", "*", "stride", ":", "idy", "*", "stride", "+", "w", ".", "shape", "[", "1", "]", ",", ":", "]", "\n", "input", "[", ":", "ss", ".", "shape", "[", "0", "]", ",", ":", ",", ":", "]", "=", "ss", "\n", "", "else", ":", "\n", "                        ", "input", "=", "s", "[", "idx", "*", "stride", ":", "idx", "*", "stride", "+", "w", ".", "shape", "[", "0", "]", ",", "idy", "*", "stride", ":", "idy", "*", "stride", "+", "w", ".", "shape", "[", "1", "]", ",", ":", "]", "\n", "", "dw", "=", "input", "*", "a_minus", "*", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", "*", "(", "1", "-", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", ")", "+", "input", "*", "a_plus", "*", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", "*", "(", "1", "-", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", ")", "-", "a_minus", "*", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", "*", "(", "1", "-", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", ")", "\n", "w", "[", ":", ",", ":", ",", ":", ",", "idz", "]", "+=", "dw", "\n", "\n", "# Turn off the STDP for lateral neurons of the activated neuron in all planes", "\n", "for", "k", "in", "range", "(", "S_sz", "[", "2", "]", ")", ":", "\n", "                        ", "j", "=", "0", "if", "idy", "-", "offset", "<", "0", "else", "idy", "-", "offset", "\n", "while", "j", "<=", "(", "S_sz", "[", "1", "]", "-", "1", "if", "idy", "+", "offset", ">", "S_sz", "[", "1", "]", "-", "1", "else", "idy", "+", "offset", ")", ":", "\n", "                            ", "i", "=", "0", "if", "idx", "-", "offset", "<", "0", "else", "idx", "-", "offset", "\n", "while", "i", "<=", "(", "S_sz", "[", "0", "]", "-", "1", "if", "idx", "+", "offset", ">", "S_sz", "[", "0", "]", "-", "1", "else", "idx", "+", "offset", ")", ":", "\n", "                                ", "K_STDP", "[", "i", ",", "j", ",", "k", "]", "=", "0", "\n", "i", "+=", "1", "\n", "", "j", "+=", "1", "\n", "\n", "# Turn off the STDP for all neurons in the plane of the activated neuron", "\n", "", "", "for", "j", "in", "range", "(", "S_sz", "[", "1", "]", ")", ":", "\n", "                        ", "for", "i", "in", "range", "(", "S_sz", "[", "0", "]", ")", ":", "\n", "                            ", "K_STDP", "[", "i", ",", "j", ",", "idz", "]", "=", "0", "\n", "", "", "", "", "", "", "return", "w", ",", "K_STDP", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.DoG_norm_CPU": [[132, 148], ["range", "range"], "function", ["None"], ["", "@", "jit", "\n", "def", "DoG_norm_CPU", "(", "img_out", ",", "img_in", ",", "image_size", ",", "win_size", ")", ":", "\n", "\n", "    ", "sumation", "=", ".0001", "\n", "for", "idx", "in", "range", "(", "img_in", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "idy", "in", "range", "(", "img_in", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "j", "=", "0", "if", "idy", "-", "win_size", "<", "0", "else", "idy", "-", "win_size", "\n", "while", "j", "<=", "(", "image_size", "[", "1", "]", "-", "1", "if", "idy", "+", "win_size", ">", "image_size", "[", "1", "]", "-", "1", "else", "idy", "+", "win_size", ")", ":", "\n", "                ", "i", "=", "0", "if", "idx", "-", "win_size", "<", "0", "else", "idx", "-", "win_size", "\n", "while", "i", "<=", "(", "image_size", "[", "0", "]", "-", "1", "if", "idx", "+", "win_size", ">", "image_size", "[", "0", "]", "-", "1", "else", "idx", "+", "win_size", ")", ":", "\n", "                    ", "sumation", "+=", "img_in", "[", "i", ",", "j", "]", "\n", "i", "+=", "1", "\n", "", "j", "+=", "1", "\n", "", "mean", "=", "sumation", "/", "(", "(", "2", "*", "win_size", "+", "1", ")", "**", "2", ")", "\n", "img_out", "[", "idx", ",", "idy", "]", "=", "img_in", "[", "idx", ",", "idy", "]", "/", "mean", "\n", "", "", "return", "img_out", "\n", "", ""]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.__init__": [[20, 50], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "X_train", ",", "y_train", ",", "X_test", ",", "y_test", ",", "classifier_params", ",", "classifier_type", "=", "'SVM'", ")", ":", "\n", "        ", "\"\"\"\n            Classifier initialization routine\n            \n            Inputs:\n            - X_train: A numpy array containing the training data of shape (N, D)\n                     Each row corresponds to a sample, each column to a feature\n            - y_train: A numpy array containing the labels for the training data of shape (N, 1)\n            - X_test: A numpy array containing the test data of shape (M, D)\n                    Each row corresponds to a sample, each column to a feature\n            - y_test: A numpy array containing the labels for the test data of shape (M, 1)\n            - classifier_params: A dictionary containing the parameters for the specific classifier to be used\n            - classifier_type: A string specifying the classifier type to be used (SVM by default)\n        \"\"\"", "\n", "self", ".", "X_train", "=", "X_train", "\n", "self", ".", "y_train", "=", "y_train", "\n", "self", ".", "X_test", "=", "X_test", "\n", "self", ".", "y_test", "=", "y_test", "\n", "\n", "self", ".", "classifier_type", "=", "classifier_type", "\n", "self", ".", "classifier_params", "=", "classifier_params", "\n", "\n", "self", ".", "classifier", "=", "[", "]", "\n", "self", ".", "train_score", "=", "[", "]", "\n", "self", ".", "test_score", "=", "[", "]", "\n", "\n", "self", ".", "cvs_mean", "=", "[", "]", "# Cross validation scores", "\n", "self", ".", "cvs_std", "=", "[", "]", "# Cross validation std", "\n", "self", ".", "cval_param", "=", "{", "}", "# Best cross validated parameter", "\n", "self", ".", "plots", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.train_classifier_svm": [[51, 97], ["sklearn.svm.SVC", "sklearn.svm.SVC.fit", "Classifier.Classifier.classifier.append", "Classifier.Classifier.train_score.append", "print", "sklearn.svm.SVC.score", "print", "print", "print", "print"], "methods", ["None"], ["", "def", "train_classifier_svm", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Trains a SVM classifier\n            \n            The parameters C, gamma, kernel and prob_flag specified under self.classifier_params are used.\n            \n            Each classifier instance is appended to self.classifier\n            The training error is appended to self.train_error  \n        \"\"\"", "\n", "if", "(", "self", ".", "classifier_type", "==", "'SVM'", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "C", "=", "self", ".", "classifier_params", "[", "'C'", "]", "\n", "", "except", ":", "\n", "                ", "if", "'C'", "in", "self", ".", "cval_param", ":", "\n", "                    ", "C", "=", "self", ".", "cval_param", "[", "'C'", "]", "\n", "", "else", ":", "\n", "                    ", "C", "=", "1.0", "\n", "", "print", "(", "'C was not specified'", ")", "\n", "", "try", ":", "\n", "                ", "gamma", "=", "self", ".", "classifier_params", "[", "'gamma'", "]", "\n", "", "except", ":", "\n", "                ", "if", "'gamma'", "in", "self", ".", "cval_param", ":", "\n", "                    ", "gamma", "=", "self", ".", "cval_param", "[", "'gamma'", "]", "\n", "", "else", ":", "\n", "                    ", "gamma", "=", "'auto'", "\n", "", "print", "(", "'gamma was not specified'", ")", "\n", "", "try", ":", "\n", "                ", "kernel", "=", "self", ".", "classifier_params", "[", "'kernel'", "]", "\n", "", "except", ":", "\n", "                ", "kernel", "=", "'rbf'", "\n", "print", "(", "'kernel was not specified'", ")", "\n", "", "try", ":", "\n", "                ", "prob_flag", "=", "self", ".", "classifier_params", "[", "'prob_flag'", "]", "\n", "", "except", ":", "\n", "                ", "prob_flag", "=", "False", "\n", "print", "(", "'probability_flag was not specified'", ")", "\n", "\n", "# Train SVM", "\n", "", "clf", "=", "svm", ".", "SVC", "(", "C", "=", "C", ",", "gamma", "=", "gamma", ",", "kernel", "=", "kernel", ",", "probability", "=", "prob_flag", ")", "\n", "clf", ".", "fit", "(", "self", ".", "X_train", ",", "self", ".", "y_train", ")", "\n", "self", ".", "classifier", ".", "append", "(", "clf", ")", "\n", "\n", "# Obtain the Training Error", "\n", "self", ".", "train_score", ".", "append", "(", "clf", ".", "score", "(", "self", ".", "X_train", ",", "self", ".", "y_train", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Error, SVM classifier not specified\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.test_classifier_svm": [[98, 107], ["Classifier.Classifier.test_score.append", "clf.score", "print"], "methods", ["None"], ["", "", "def", "test_classifier_svm", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Evaluates the test score using the last classifier trained and appends it to self.test_error   \n        \"\"\"", "\n", "try", ":", "\n", "            ", "clf", "=", "self", ".", "classifier", "[", "-", "1", "]", "\n", "", "except", ":", "\n", "            ", "print", "(", "'No classifier has been trained'", ")", "\n", "", "self", ".", "test_score", ".", "append", "(", "clf", ".", "score", "(", "self", ".", "X_test", ",", "self", ".", "y_test", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.run_classiffier": [[109, 120], ["Classifier.Classifier.train_classifier_svm", "Classifier.Classifier.test_classifier_svm"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.train_classifier_svm", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.test_classifier_svm"], ["", "def", "run_classiffier", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Trains the SVM with self.X_train and self.y_train data \n            and tests it with self.X_test and self.y_test data\n            \n            Returns a tuple containing two doubles for the train and test error respectively    \n        \"\"\"", "\n", "if", "(", "self", ".", "classifier_type", "==", "'SVM'", ")", ":", "\n", "            ", "self", ".", "train_classifier_svm", "(", ")", "\n", "self", ".", "test_classifier_svm", "(", ")", "\n", "return", "self", ".", "train_score", "[", "-", "1", "]", ",", "self", ".", "test_score", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.cross_val_svm": [[121, 198], ["range", "len", "print", "len", "len", "cross_val_score", "Classifier.Classifier.cvs_mean.append", "Classifier.Classifier.cvs_std.append", "type", "numpy.array", "numpy.array", "numpy.array", "pylab.plot", "pylab.fill_between", "pylab.title", "pylab.xlabel", "pylab.ylabel", "Classifier.Classifier.plots.append", "numpy.array", "numpy.array", "numpy.array", "pylab.plot", "pylab.fill_between", "pylab.title", "pylab.xlabel", "pylab.ylabel", "Classifier.Classifier.plots.append", "type", "sklearn.svm.SVC", "cross_val_score.mean", "cross_val_score.std", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "type", "sklearn.svm.SVC", "print", "numpy.argmax", "numpy.argmax", "numpy.array", "numpy.array"], "methods", ["None"], ["", "", "def", "cross_val_svm", "(", "self", ",", "cv_param", ",", "cv", ")", ":", "\n", "        ", "\"\"\"\n            This method computes the cross validation error fo a svm classifier\n             \n            Input:\n                - cv_param: A dictionary with one single key specifying the parameter \n                            to cross validate with respect to. The key must be either 'C' or 'gamma'.\n                -cv: An integer that specifies the number of k-folds\n                -plot: A flag to specify if the results will be plotted or not\n            \n            Returns a tuple of:\n                - param : An numpy array with the cross validated parameter\n                - cve_mean: An numpy array with the cross-validation error per parameter value\n                - cve_std: An numpy array with the cross-validation std per parameter value\n                - cv: An integer specifying the number of k-folds used\n        \"\"\"", "\n", "\n", "from", "sklearn", ".", "model_selection", "import", "cross_val_score", "\n", "if", "len", "(", "cv_param", ")", ">", "1", ":", "\n", "            ", "print", "(", "'Crossvalidation w.r.t one parameter only'", ")", "\n", "return", "\n", "\n", "# Check which parameter is to be cross validated", "\n", "", "try", ":", "\n", "            ", "C", "=", "cv_param", "[", "'C'", "]", "\n", "N", "=", "len", "(", "C", ")", "\n", "", "except", ":", "\n", "            ", "C", "=", "1.0", "\n", "", "try", ":", "\n", "            ", "gamma", "=", "cv_param", "[", "'gamma'", "]", "\n", "N", "=", "len", "(", "gamma", ")", "\n", "", "except", ":", "\n", "            ", "gamma", "=", "'auto'", "\n", "\n", "# Cross-validate, calculate the cross-validation score and std", "\n", "# and append it to the self.cve_mean and self.cve_std", "\n", "", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "if", "type", "(", "C", ")", "is", "list", ":", "\n", "                ", "clf", "=", "svm", ".", "SVC", "(", "C", "=", "C", "[", "i", "]", ",", "gamma", "=", "gamma", ",", "kernel", "=", "'rbf'", ")", "\n", "", "elif", "type", "(", "gamma", ")", "is", "list", ":", "\n", "                ", "clf", "=", "svm", ".", "SVC", "(", "C", "=", "C", ",", "gamma", "=", "gamma", "[", "i", "]", ",", "kernel", "=", "'rbf'", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "'Parameters should be specified as a list'", ")", "\n", "return", "\n", "", "scores", "=", "cross_val_score", "(", "clf", ",", "self", ".", "X_train", ",", "self", ".", "y_train", ",", "cv", "=", "cv", ")", "\n", "self", ".", "cvs_mean", ".", "append", "(", "scores", ".", "mean", "(", ")", ")", "\n", "self", ".", "cvs_std", ".", "append", "(", "scores", ".", "std", "(", ")", ")", "\n", "\n", "# Plot the cross validation error and save the best parameter", "\n", "", "if", "type", "(", "C", ")", "is", "list", ":", "\n", "# Save the best", "\n", "            ", "self", ".", "cval_param", "[", "'C'", "]", "=", "C", "[", "np", ".", "argmax", "(", "np", ".", "array", "(", "self", ".", "cvs_mean", ")", ")", "]", "\n", "# Plot", "\n", "x", "=", "np", ".", "array", "(", "C", ")", "\n", "y", "=", "np", ".", "array", "(", "self", ".", "cvs_mean", ")", "\n", "e", "=", "np", ".", "array", "(", "self", ".", "cvs_std", ")", "\n", "fig", "=", "plt", ".", "plot", "(", "x", ",", "y", ",", "'k-'", ")", "\n", "plt", ".", "fill_between", "(", "x", ",", "y", "-", "e", ",", "y", "+", "e", ")", "\n", "plt", ".", "title", "(", "'%s-fold Cross Validation error'", "%", "cv", ")", "\n", "plt", ".", "xlabel", "(", "'C'", ")", "\n", "plt", ".", "ylabel", "(", "'CVE'", ")", "\n", "self", ".", "plots", ".", "append", "(", "fig", ")", "\n", "return", "np", ".", "array", "(", "C", ")", ",", "np", ".", "array", "(", "self", ".", "cvs_mean", ")", ",", "np", ".", "array", "(", "self", ".", "cvs_std", ")", ",", "cv", "\n", "", "else", ":", "\n", "# Save the best", "\n", "            ", "self", ".", "cval_param", "[", "'gamma'", "]", "=", "gamma", "[", "np", ".", "argmax", "(", "np", ".", "array", "(", "self", ".", "cvs_mean", ")", ")", "]", "\n", "# Plot", "\n", "x", "=", "np", ".", "array", "(", "gamma", ")", "\n", "y", "=", "np", ".", "array", "(", "self", ".", "cvs_mean", ")", "\n", "e", "=", "np", ".", "array", "(", "self", ".", "cvs_std", ")", "\n", "fig", "=", "plt", ".", "plot", "(", "x", ",", "y", ",", "'k-'", ")", "\n", "plt", ".", "fill_between", "(", "x", ",", "y", "-", "e", ",", "y", "+", "e", ")", "\n", "plt", ".", "title", "(", "'%s-fold Cross Validation error'", "%", "cv", ")", "\n", "plt", ".", "xlabel", "(", "'gamma'", ")", "\n", "plt", ".", "ylabel", "(", "'CVE'", ")", "\n", "self", ".", "plots", ".", "append", "(", "fig", ")", "\n", "return", "np", ".", "array", "(", "gamma", ")", ",", "np", ".", "array", "(", "self", ".", "cvs_mean", ")", ",", "np", ".", "array", "(", "self", ".", "cvs_std", ")", ",", "cv", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cuda_utils.conv_step": [[10, 36], ["numba.cuda.jit", "numba.cuda.grid", "range", "range", "range"], "function", ["None"], ["@", "cuda", ".", "jit", "(", "argtypes", "=", "[", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "float32", "[", ":", ",", ":", ",", ":", "]", ",", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "float32", "[", ":", ",", ":", ",", ":", ",", ":", "]", ",", "\n", "uint32", ",", "float32", "]", ")", "\n", "def", "conv_step", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "\n", "    ", "idx", ",", "idy", ",", "idz", "=", "cuda", ".", "grid", "(", "3", ")", "\n", "if", "idx", ">", "V", ".", "shape", "[", "0", "]", "-", "1", ":", "\n", "        ", "return", "\n", "", "if", "idy", ">", "V", ".", "shape", "[", "1", "]", "-", "1", ":", "\n", "        ", "return", "\n", "", "if", "idz", ">", "V", ".", "shape", "[", "2", "]", "-", "1", ":", "\n", "        ", "return", "\n", "\n", "", "if", "V", "[", "idx", ",", "idy", ",", "idz", "]", ">", "th", ":", "\n", "        ", "V", "[", "idx", ",", "idy", ",", "idz", "]", "=", "0.", "\n", "\n", "", "result", "=", "0.", "\n", "for", "k", "in", "range", "(", "w", ".", "shape", "[", "2", "]", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "w", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "w", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "result", "+=", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", "*", "s", "[", "idx", "*", "stride", "+", "i", ",", "idy", "*", "stride", "+", "j", ",", "k", "]", "\n", "\n", "", "", "", "V", "[", "idx", ",", "idy", ",", "idz", "]", "+=", "result", "\n", "if", "V", "[", "idx", ",", "idy", ",", "idz", "]", ">", "th", ":", "\n", "        ", "S", "[", "idx", ",", "idy", ",", "idz", "]", "=", "1", "\n", "", "else", ":", "\n", "        ", "S", "[", "idx", ",", "idy", ",", "idz", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cuda_utils.pool": [[38, 59], ["numba.cuda.jit", "numba.cuda.grid", "range", "range"], "function", ["None"], ["", "", "@", "cuda", ".", "jit", "(", "argtypes", "=", "[", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "float32", "[", ":", ",", ":", ",", ":", "]", ",", "\n", "uint32", ",", "float32", "]", ")", "\n", "def", "pool", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "\n", "    ", "idx", ",", "idy", ",", "idz", "=", "cuda", ".", "grid", "(", "3", ")", "\n", "if", "idx", ">", "S", ".", "shape", "[", "0", "]", "-", "1", ":", "\n", "         ", "return", "\n", "", "if", "idy", ">", "S", ".", "shape", "[", "1", "]", "-", "1", ":", "\n", "         ", "return", "\n", "", "if", "idz", ">", "S", ".", "shape", "[", "2", "]", "-", "1", ":", "\n", "         ", "return", "\n", "\n", "", "result", "=", "0.", "\n", "for", "j", "in", "range", "(", "w", ".", "shape", "[", "1", "]", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "w", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "result", "+=", "w", "[", "i", ",", "j", ",", "idz", "]", "*", "s", "[", "idx", "*", "stride", "+", "i", ",", "idy", "*", "stride", "+", "j", ",", "idz", "]", "\n", "\n", "", "", "if", "result", ">", "th", ":", "\n", "        ", "S", "[", "idx", ",", "idy", ",", "idz", "]", "=", "1", "\n", "", "else", ":", "\n", "        ", "S", "[", "idx", ",", "idy", ",", "idz", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cuda_utils.STDP_learning": [[61, 109], ["numba.cuda.jit", "numba.cuda.grid", "range", "range", "range", "range", "range", "range", "range"], "function", ["None"], ["", "", "@", "cuda", ".", "jit", "(", "argtypes", "=", "[", "int32", "[", ":", "]", ",", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "float32", "[", ":", ",", ":", ",", ":", ",", ":", "]", ",", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "\n", "float32", "[", ":", "]", ",", "int16", "[", ":", "]", ",", "int16", "[", ":", "]", ",", "\n", "uint32", ",", "uint32", ",", "float32", ",", "float32", "]", ")", "\n", "def", "STDP_learning", "(", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "# Input arrays", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "# Indices", "\n", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ")", ":", "# Parameters", "\n", "\n", "    ", "idx", ",", "idy", ",", "idz", "=", "cuda", ".", "grid", "(", "3", ")", "\n", "if", "idx", ">", "S_sz", "[", "0", "]", "-", "1", ":", "\n", "        ", "return", "\n", "", "if", "idy", ">", "S_sz", "[", "1", "]", "-", "1", ":", "\n", "        ", "return", "\n", "", "if", "idz", ">", "S_sz", "[", "2", "]", "-", "1", ":", "\n", "        ", "return", "\n", "\n", "", "if", "idx", "!=", "maxind1", "[", "idz", "]", "or", "idy", "!=", "maxind2", "[", "idz", "]", ":", "# Check if this is the neuron we have to update (correct idx, idy for map idz)", "\n", "        ", "return", "\n", "\n", "", "for", "i", "in", "range", "(", "w", ".", "shape", "[", "3", "]", ")", ":", "\n", "        ", "if", "(", "idz", "!=", "i", "and", "maxind1", "[", "idz", "]", "<=", "maxind1", "[", "i", "]", "+", "offset", "and", "maxind1", "[", "idz", "]", ">=", "maxind1", "[", "i", "]", "-", "offset", "\n", "and", "maxind2", "[", "idz", "]", "<=", "maxind2", "[", "i", "]", "+", "offset", "and", "maxind2", "[", "idz", "]", ">=", "maxind2", "[", "i", "]", "-", "offset", "and", "maxval", "[", "i", "]", ">", "maxval", "[", "idz", "]", ")", ":", "\n", "            ", "maxval", "[", "idz", "]", "=", "0.", "\n", "\n", "", "", "if", "maxval", "[", "idz", "]", ">", "0", ":", "\n", "# Weights STDP update", "\n", "        ", "for", "k", "in", "range", "(", "w", ".", "shape", "[", "2", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "w", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "for", "i", "in", "range", "(", "w", ".", "shape", "[", "0", "]", ")", ":", "\n", "                    ", "input", "=", "s", "[", "idx", "*", "stride", "+", "i", ",", "idy", "*", "stride", "+", "j", ",", "k", "]", "\n", "dw", "=", "input", "*", "a_minus", "*", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", "*", "(", "1", "-", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", ")", "+", "input", "*", "a_plus", "*", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", "*", "(", "1", "-", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", ")", "-", "a_minus", "*", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", "*", "(", "1", "-", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", ")", "\n", "w", "[", "i", ",", "j", ",", "k", ",", "idz", "]", "+=", "dw", "\n", "\n", "# Turn off the STDP for lateral neurons of the activated neuron in all planes", "\n", "", "", "", "for", "k", "in", "range", "(", "S_sz", "[", "2", "]", ")", ":", "\n", "            ", "j", "=", "0", "if", "idy", "-", "offset", "<", "0", "else", "idy", "-", "offset", "\n", "while", "j", "<=", "(", "S_sz", "[", "1", "]", "-", "1", "if", "idy", "+", "offset", ">", "S_sz", "[", "1", "]", "-", "1", "else", "idy", "+", "offset", ")", ":", "\n", "                ", "i", "=", "0", "if", "idx", "-", "offset", "<", "0", "else", "idx", "-", "offset", "\n", "while", "i", "<=", "(", "S_sz", "[", "0", "]", "-", "1", "if", "idx", "+", "offset", ">", "S_sz", "[", "0", "]", "-", "1", "else", "idx", "+", "offset", ")", ":", "\n", "                    ", "K_STDP", "[", "i", ",", "j", ",", "k", "]", "=", "0", "\n", "i", "+=", "1", "\n", "", "j", "+=", "1", "\n", "\n", "# Turn off the STDP for all neurons in the plane of the activated neuron", "\n", "", "", "for", "j", "in", "range", "(", "S_sz", "[", "1", "]", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "S_sz", "[", "0", "]", ")", ":", "\n", "                ", "K_STDP", "[", "i", ",", "j", ",", "idz", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cuda_utils.lateral_inh": [[111, 137], ["numba.cuda.jit", "numba.cuda.grid", "range"], "function", ["None"], ["", "", "", "", "@", "cuda", ".", "jit", "(", "argtypes", "=", "[", "uint8", "[", ":", ",", ":", ",", ":", "]", ",", "float32", "[", ":", ",", ":", ",", ":", "]", ",", "uint8", "[", ":", ",", ":", "]", "]", ")", "\n", "def", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ")", ":", "\n", "\n", "    ", "idx", ",", "idy", ",", "idz", "=", "cuda", ".", "grid", "(", "3", ")", "\n", "if", "idx", ">", "V", ".", "shape", "[", "0", "]", "-", "1", ":", "\n", "        ", "return", "\n", "", "if", "idy", ">", "V", ".", "shape", "[", "1", "]", "-", "1", ":", "\n", "        ", "return", "\n", "", "if", "idz", ">", "V", ".", "shape", "[", "2", "]", "-", "1", ":", "\n", "        ", "return", "\n", "\n", "# if neuron has not fired terminate the thread", "\n", "", "if", "S", "[", "idx", ",", "idy", ",", "idz", "]", "!=", "1", ":", "\n", "        ", "return", "\n", "\n", "# if a neuron in this position has fired before do not fire again", "\n", "", "if", "K_inh", "[", "idx", ",", "idy", "]", "==", "0", ":", "\n", "        ", "S", "[", "idx", ",", "idy", ",", "idz", "]", "=", "0", "\n", "return", "\n", "\n", "# neuron at this position but in other input map", "\n", "", "for", "k", "in", "range", "(", "V", ".", "shape", "[", "2", "]", ")", ":", "\n", "        ", "if", "S", "[", "idx", ",", "idy", ",", "k", "]", "==", "1", "and", "V", "[", "idx", ",", "idy", ",", "idz", "]", "<", "V", "[", "idx", ",", "idy", ",", "k", "]", ":", "\n", "            ", "S", "[", "idx", ",", "idy", ",", "idz", "]", "=", "0", "\n", "return", "\n", "", "", "K_inh", "[", "idx", ",", "idy", "]", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cuda_utils.DoG_norm": [[139, 159], ["numba.cuda.jit", "numba.cuda.grid"], "function", ["None"], ["", "@", "cuda", ".", "jit", "(", "argtypes", "=", "[", "float32", "[", ":", ",", ":", "]", ",", "float32", "[", ":", ",", ":", "]", ",", "uint8", "[", ":", "]", ",", "uint8", "]", ")", "\n", "def", "DoG_norm", "(", "img_out", ",", "img_in", ",", "image_size", ",", "win_size", ")", ":", "\n", "\n", "    ", "idx", ",", "idy", "=", "cuda", ".", "grid", "(", "2", ")", "\n", "if", "idx", ">", "image_size", "[", "0", "]", "-", "1", ":", "\n", "         ", "return", "\n", "", "if", "idy", ">", "image_size", "[", "1", "]", "-", "1", ":", "\n", "         ", "return", "\n", "\n", "", "sumation", "=", ".0001", "\n", "j", "=", "0", "if", "idy", "-", "win_size", "<", "0", "else", "idy", "-", "win_size", "\n", "while", "j", "<=", "(", "image_size", "[", "1", "]", "-", "1", "if", "idy", "+", "win_size", ">", "image_size", "[", "1", "]", "-", "1", "else", "idy", "+", "win_size", ")", ":", "\n", "        ", "i", "=", "0", "if", "idx", "-", "win_size", "<", "0", "else", "idx", "-", "win_size", "\n", "while", "i", "<=", "(", "image_size", "[", "0", "]", "-", "1", "if", "idx", "+", "win_size", ">", "image_size", "[", "0", "]", "-", "1", "else", "idx", "+", "win_size", ")", ":", "\n", "            ", "sumation", "+=", "img_in", "[", "i", ",", "j", "]", "\n", "i", "+=", "1", "\n", "", "j", "+=", "1", "\n", "\n", "", "mean", "=", "sumation", "/", "(", "(", "2", "*", "win_size", "+", "1", ")", "**", "2", ")", "\n", "img_out", "[", "idx", ",", "idy", "]", "=", "img_in", "[", "idx", ",", "idy", "]", "/", "mean", "\n", "", ""]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.multiple-runs-oneimage.main": [[20, 119], ["os.path.dirname", "int", "SDNN_cuda_vary_images.SDNN", "SDNN_cuda_vary_images.SDNN.train_features", "SDNN_cuda_vary_images.SDNN.test_features", "numpy.mean", "numpy.std", "Classifier.Classifier", "Classifier.Classifier.run_classiffier", "print", "os.path.dirname", "sum", "numpy.array", "numpy.array", "SDNN_cuda_vary_images.SDNN.set_weights", "SDNN_cuda_vary_images.SDNN.train_SDNN", "SDNN_cuda_vary_images.SDNN.get_weights", "range", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "os.path.realpath", "math.floor", "math.floor", "math.floor", "len", "numpy.save", "str", "range", "str", "str", "str", "len"], "function", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_features", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.test_features", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.run_classiffier", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.set_weights", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_SDNN", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.get_weights"], ["def", "main", "(", ")", ":", "\n", "# Flags", "\n", "    ", "learn_SDNN", "=", "False", "# This flag toggles between Learning STDP and classify features", "\n", "# or just classify by loading pretrained weights for the face/motor dataset", "\n", "if", "learn_SDNN", ":", "\n", "        ", "set_weights", "=", "False", "# Loads the weights from a path (path_set_weigths) and prevents any SDNN learning", "\n", "save_weights", "=", "True", "# Saves the weights in a path (path_save_weigths)", "\n", "save_features", "=", "True", "# Saves the features and labels in the specified path (path_features)", "\n", "", "else", ":", "\n", "        ", "set_weights", "=", "True", "# Loads the weights from a path (path_set_weigths) and prevents any SDNN learning", "\n", "save_weights", "=", "False", "# Saves the weights in a path (path_save_weigths)", "\n", "save_features", "=", "False", "# Saves the features and labels in the specified path (path_features)", "\n", "\n", "# ------------------------------- Learn, Train and Test paths-------------------------------#", "\n", "# Image sets directories", "\n", "", "path", "=", "dirname", "(", "dirname", "(", "realpath", "(", "__file__", ")", ")", ")", "\n", "spike_times_learn", "=", "[", "path", "+", "'/datasets/LearningSet/Face/'", ",", "path", "+", "'/datasets/LearningSet/Motor/'", "]", "\n", "spike_times_train", "=", "[", "path", "+", "'/datasets/TrainingSet/Face/'", ",", "path", "+", "'/datasets/TrainingSet/Motor/'", "]", "\n", "spike_times_test", "=", "[", "path", "+", "'/datasets/TestingSet/Face/'", ",", "path", "+", "'/datasets/TestingSet/Motor/'", "]", "\n", "\n", "\n", "# Results directories", "\n", "path_set_weigths", "=", "'results/'", "\n", "path_save_weigths", "=", "'results/'", "\n", "path_features", "=", "'results/'", "\n", "\n", "# ------------------------------- SDNN -------------------------------#", "\n", "# SDNN_cuda parameters", "\n", "DoG_params", "=", "{", "'img_size'", ":", "(", "250", ",", "160", ")", ",", "'DoG_size'", ":", "7", ",", "'std1'", ":", "1.", ",", "'std2'", ":", "2.", "}", "# img_size is (col size, row size)", "\n", "total_time", "=", "15", "\n", "network_params", "=", "[", "{", "'Type'", ":", "'input'", ",", "'num_filters'", ":", "1", ",", "'pad'", ":", "(", "0", ",", "0", ")", ",", "'H_layer'", ":", "DoG_params", "[", "'img_size'", "]", "[", "1", "]", ",", "\n", "'W_layer'", ":", "DoG_params", "[", "'img_size'", "]", "[", "0", "]", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "4", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "10.", "}", ",", "\n", "{", "'Type'", ":", "'pool'", ",", "'num_filters'", ":", "4", ",", "'filter_size'", ":", "7", ",", "'th'", ":", "0.", ",", "'stride'", ":", "6", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "17", ",", "'th'", ":", "60.", "}", ",", "\n", "{", "'Type'", ":", "'pool'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "0.", ",", "'stride'", ":", "5", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "2.", "}", "]", "\n", "\n", "weight_params", "=", "{", "'mean'", ":", "0.8", ",", "'std'", ":", "0.01", "}", "\n", "\n", "#max_learn_iter = [0, 1, 0, 1, 0, 1, 0]", "\n", "max_learn_iter", "=", "[", "0", ",", "3000", ",", "0", ",", "5000", ",", "0", ",", "6000", ",", "0", "]", "\n", "stdp_params", "=", "{", "'max_learn_iter'", ":", "max_learn_iter", ",", "\n", "'stdp_per_layer'", ":", "[", "0", ",", "10", ",", "0", ",", "4", ",", "0", ",", "2", "]", ",", "\n", "'max_iter'", ":", "sum", "(", "max_learn_iter", ")", ",", "\n", "'a_minus'", ":", "np", ".", "array", "(", "[", "0", ",", ".003", ",", "0", ",", ".0003", ",", "0", ",", ".0003", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'a_plus'", ":", "np", ".", "array", "(", "[", "0", ",", ".004", ",", "0", ",", ".0004", ",", "0", ",", ".0004", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'offset_STDP'", ":", "[", "0", ",", "floor", "(", "network_params", "[", "1", "]", "[", "'filter_size'", "]", ")", ",", "\n", "0", ",", "\n", "floor", "(", "network_params", "[", "3", "]", "[", "'filter_size'", "]", "/", "8", ")", ",", "\n", "0", ",", "\n", "floor", "(", "network_params", "[", "5", "]", "[", "'filter_size'", "]", ")", "]", "}", "\n", "\n", "# Create network", "\n", "n_train_images", "=", "int", "(", "sys", ".", "argv", "[", "1", "]", ")", "\n", "first_net", "=", "SDNN", "(", "network_params", ",", "weight_params", ",", "stdp_params", ",", "total_time", ",", "\n", "DoG_params", "=", "DoG_params", ",", "spike_times_learn", "=", "spike_times_learn", ",", "\n", "spike_times_train", "=", "spike_times_train", ",", "spike_times_test", "=", "spike_times_test", ",", "device", "=", "'GPU'", ",", "n_train_images", "=", "n_train_images", ")", "\n", "\n", "# Set the weights or learn STDP", "\n", "if", "set_weights", ":", "\n", "        ", "weight_path_list", "=", "[", "path_set_weigths", "+", "'weight_'", "+", "str", "(", "i", ")", "+", "'.npy'", "for", "i", "in", "range", "(", "len", "(", "network_params", ")", "-", "1", ")", "]", "\n", "first_net", ".", "set_weights", "(", "weight_path_list", ")", "\n", "", "else", ":", "\n", "        ", "first_net", ".", "train_SDNN", "(", ")", "\n", "\n", "# Save the weights", "\n", "", "if", "save_weights", ":", "\n", "        ", "weights", "=", "first_net", ".", "get_weights", "(", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "weights", ")", ")", ":", "\n", "            ", "np", ".", "save", "(", "path_save_weigths", "+", "'weight_'", "+", "str", "(", "i", ")", ",", "weights", "[", "i", "]", ")", "\n", "\n", "# Get features", "\n", "", "", "X_train", ",", "y_train", "=", "first_net", ".", "train_features", "(", ")", "\n", "X_test", ",", "y_test", "=", "first_net", ".", "test_features", "(", ")", "\n", "\n", "# Save X_train and X_test", "\n", "if", "save_features", ":", "\n", "        ", "np", ".", "save", "(", "path_features", "+", "'X_train'", ",", "X_train", ")", "\n", "np", ".", "save", "(", "path_features", "+", "'y_train'", ",", "y_train", ")", "\n", "np", ".", "save", "(", "path_features", "+", "'X_test'", ",", "X_test", ")", "\n", "np", ".", "save", "(", "path_features", "+", "'y_test'", ",", "y_test", ")", "\n", "\n", "# ------------------------------- Classify -------------------------------#", "\n", "", "classifier_params", "=", "{", "'C'", ":", "1.0", ",", "'gamma'", ":", "'auto'", "}", "\n", "train_mean", "=", "np", ".", "mean", "(", "X_train", ",", "axis", "=", "0", ")", "\n", "train_std", "=", "np", ".", "std", "(", "X_train", ",", "axis", "=", "0", ")", "\n", "X_train", "-=", "train_mean", "\n", "X_test", "-=", "train_mean", "\n", "X_train", "/=", "(", "train_std", "+", "1e-5", ")", "\n", "X_test", "/=", "(", "train_std", "+", "1e-5", ")", "\n", "svm", "=", "Classifier", "(", "X_train", ",", "y_train", ",", "X_test", ",", "y_test", ",", "classifier_params", ",", "classifier_type", "=", "'SVM'", ")", "\n", "train_score", ",", "test_score", "=", "svm", ".", "run_classiffier", "(", ")", "\n", "\"\"\"\n    with open(\"vary-count-no-learn\"+str(count)+'.res','w') as f:\n        f.write('Train Score: ' + str(train_score)+'\\n')\n        f.write('Test Score: ' + str(test_score)+'\\n')\n    \"\"\"", "\n", "print", "(", "'Train Score: '", "+", "str", "(", "train_score", ")", "+", "'Test Score: '", "+", "str", "(", "test_score", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.main_vary_images_best_sdnn.main": [[22, 117], ["os.path.dirname", "int", "SDNN_cuda_vary_images.SDNN", "float", "float", "SDNN_cuda_vary_images.SDNN.set_weights", "SDNN_cuda_vary_images.SDNN.train_features", "os.path.dirname", "sum", "numpy.array", "numpy.array", "os.path.realpath", "math.floor", "math.floor", "math.floor", "range", "len", "str"], "function", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.set_weights", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_features"], ["def", "main", "(", ")", ":", "\n", "\n", "# Flags", "\n", "    ", "learn_SDNN", "=", "False", "# This flag toggles between Learning STDP and classify features", "\n", "# or just classify by loading pretrained weights for the face/motor dataset", "\n", "if", "learn_SDNN", ":", "\n", "        ", "set_weights", "=", "False", "# Loads the weights from a path (path_set_weigths) and prevents any SDNN learning", "\n", "save_weights", "=", "True", "# Saves the weights in a path (path_save_weigths)", "\n", "save_features", "=", "True", "# Saves the features and labels in the specified path (path_features)", "\n", "", "else", ":", "\n", "        ", "set_weights", "=", "True", "# Loads the weights from a path (path_set_weigths) and prevents any SDNN learning", "\n", "save_weights", "=", "False", "# Saves the weights in a path (path_save_weigths)", "\n", "save_features", "=", "False", "# Saves the features and labels in the specified path (path_features)", "\n", "\n", "# ------------------------------- Learn, Train and Test paths-------------------------------#", "\n", "# Image sets directories", "\n", "", "path", "=", "dirname", "(", "dirname", "(", "realpath", "(", "__file__", ")", ")", ")", "\n", "#print(path)", "\n", "spike_times_learn", "=", "[", "path", "+", "'/datasets/LearningSet/Face/'", ",", "path", "+", "'/datasets/LearningSet/Motor/'", "]", "\n", "spike_times_train", "=", "[", "path", "+", "'/datasets/TrainingSet/Face/'", ",", "path", "+", "'/datasets/TrainingSet/Motor/'", "]", "\n", "spike_times_test", "=", "[", "path", "+", "'/datasets/TestingSet/Face/'", ",", "path", "+", "'/datasets/TestingSet/Motor/'", "]", "\n", "\n", "# Results directories", "\n", "# THe following is commented to use better SDNN weights after", "\n", "\"\"\"\n    path_set_weigths = '../../../find_params/sdnn_find_params/results/'\n    path_save_weigths = '../../../find_params/sdnn_find_params/results/'\n    path_features = '../../../find_params/sdnn_find_params/results/'\n    #\n    path_set_weigths = '../../../find_params/sdnn_original/results/'\n    path_save_weigths = '../../../find_params/sdnn_original/results/'\n    path_features = '../../../find_params/sdnn_original/results/'\n    \"\"\"", "\n", "\n", "# ------------------------------- SDNN -------------------------------#", "\n", "# SDNN_cuda parameters", "\n", "DoG_params", "=", "{", "'img_size'", ":", "(", "250", ",", "160", ")", ",", "'DoG_size'", ":", "7", ",", "'std1'", ":", "1.", ",", "'std2'", ":", "2.", "}", "# img_size is (col size, row size)", "\n", "total_time", "=", "15", "\n", "network_params", "=", "[", "{", "'Type'", ":", "'input'", ",", "'num_filters'", ":", "1", ",", "'pad'", ":", "(", "0", ",", "0", ")", ",", "'H_layer'", ":", "DoG_params", "[", "'img_size'", "]", "[", "1", "]", ",", "\n", "'W_layer'", ":", "DoG_params", "[", "'img_size'", "]", "[", "0", "]", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "4", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "10.", "}", ",", "\n", "{", "'Type'", ":", "'pool'", ",", "'num_filters'", ":", "4", ",", "'filter_size'", ":", "7", ",", "'th'", ":", "0.", ",", "'stride'", ":", "6", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "17", ",", "'th'", ":", "60.", "}", ",", "\n", "{", "'Type'", ":", "'pool'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "0.", ",", "'stride'", ":", "5", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "2.", "}", "]", "\n", "\n", "weight_params", "=", "{", "'mean'", ":", "0.8", ",", "'std'", ":", "0.01", "}", "\n", "\n", "max_learn_iter", "=", "[", "0", ",", "3000", ",", "0", ",", "5000", ",", "0", ",", "6000", ",", "0", "]", "\n", "stdp_params", "=", "{", "'max_learn_iter'", ":", "max_learn_iter", ",", "\n", "'stdp_per_layer'", ":", "[", "0", ",", "10", ",", "0", ",", "4", ",", "0", ",", "2", "]", ",", "\n", "'max_iter'", ":", "sum", "(", "max_learn_iter", ")", ",", "\n", "'a_minus'", ":", "np", ".", "array", "(", "[", "0", ",", ".003", ",", "0", ",", ".0003", ",", "0", ",", ".0003", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'a_plus'", ":", "np", ".", "array", "(", "[", "0", ",", ".004", ",", "0", ",", ".0004", ",", "0", ",", ".0004", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'offset_STDP'", ":", "[", "0", ",", "floor", "(", "network_params", "[", "1", "]", "[", "'filter_size'", "]", ")", ",", "\n", "0", ",", "\n", "floor", "(", "network_params", "[", "3", "]", "[", "'filter_size'", "]", "/", "8", ")", ",", "\n", "0", ",", "\n", "floor", "(", "network_params", "[", "5", "]", "[", "'filter_size'", "]", ")", "]", "}", "\n", "\n", "n_train_images", "=", "int", "(", "sys", ".", "argv", "[", "2", "]", ")", "\n", "# Create network", "\n", "first_net", "=", "SDNN", "(", "network_params", ",", "weight_params", ",", "stdp_params", ",", "total_time", ",", "\n", "DoG_params", "=", "DoG_params", ",", "spike_times_learn", "=", "spike_times_learn", ",", "\n", "spike_times_train", "=", "spike_times_train", ",", "spike_times_test", "=", "spike_times_test", ",", "device", "=", "'GPU'", ",", "n_train_images", "=", "n_train_images", ")", "\n", "\n", "\n", "\n", "first_net", ".", "weights_ID", "=", "sys", ".", "argv", "[", "1", "]", "\n", "first_net", ".", "w_factor", "=", "float", "(", "sys", ".", "argv", "[", "3", "]", ")", "\n", "first_net", ".", "std_init", "=", "float", "(", "sys", ".", "argv", "[", "4", "]", ")", "\n", "\n", "# set parameters with parameters of the best SDNN run that gave 0.96 in train and 0.984 in test", "\n", "#ITER_TRAIN: 1, APLUS: 0.007,AMINUS: 0.003,TR_learning: 10,SPIKES_T0_CONSIDER: -1,POOLING_W: 1,RANDOM_INIT: 0.575,TR_L1: 7.0,TR_L2: 20.25,CLASS_TR: -1.0", "\n", "first_net", ".", "ITER_TRAIN", "=", "1", "\n", "first_net", ".", "APLUS", "=", "0.007", "*", "first_net", ".", "w_factor", "\n", "first_net", ".", "AMINUS", "=", "0.003", "*", "first_net", ".", "w_factor", "\n", "first_net", ".", "TR_learning", "=", "10", "\n", "first_net", ".", "SPIKES_T0_CONSIDER", "=", "-", "1", "\n", "first_net", ".", "POOLING_W", "=", "1", "\n", "first_net", ".", "RANDOM_INIT", "=", "0.575", "\n", "first_net", ".", "TR_L1", "=", "7.0", "\n", "first_net", ".", "TR_L2", "=", "20.25", "\n", "first_net", ".", "CLASS_TR", "=", "-", "1", "\n", "\n", "\n", "#print(ITER_TRAIN, APLUS, AMINUS, TR_learning, SPIKES_T0_CONSIDER, POOLING_W, RANDOM_INIT, TR_L1, TR_L2, CLASS_TR)", "\n", "\n", "# Set the weights learned through STDP", "\n", "weights_path", "=", "\"../find_params/sdnn_original/results_all/\"", "\n", "weight_path_list", "=", "[", "weights_path", "+", "'weight_'", "+", "str", "(", "i", ")", "+", "'_'", "+", "first_net", ".", "weights_ID", "+", "'.npy'", "for", "i", "in", "range", "(", "len", "(", "network_params", ")", "-", "1", ")", "]", "\n", "first_net", ".", "set_weights", "(", "weight_path_list", ")", "\n", "\n", "# Propagate n_train_images images, learn by co-occurent then test on all remaining images using Retrograde signaling", "\n", "X_train", ",", "y_train", "=", "first_net", ".", "train_features", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda_vary_images.SDNN.pool_spikes": [[586, 601], ["numba.jit", "numpy.zeros", "numpy.ndindex", "numpy.max", "int", "int"], "methods", ["None"], ["\n", "self", ".", "network_struc", "[", "3", "]", "[", "'th'", "]", "=", "50.", "\n", "self", ".", "network_struc", "[", "5", "]", "[", "'th'", "]", "=", "100000", "# Set threshold of last layer to inf", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "#print(\"----------- EXTRACTING TRAINING FEATURES ------------------\")", "\n", "#print(\"-----------------------------------------------------------\")", "\n", "for", "i", "in", "range", "(", "self", ".", "num_img_train", ")", ":", "\n", "            ", "\"\"\"\n            print(\"------------ Train features Extraction Progress  {}%----------------\".format(str(i) + '/'\n                                                                                                + str(self.num_img_train)\n                                                                                                + ' ('\n                                                                                                + str(100 * i / self.num_img_train)\n                                                                                                + ')'))\n            \"\"\"", "\n", "start", "=", "timer", "(", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.main.main": [[20, 127], ["os.path.dirname", "SDNN_cuda.SDNN", "SDNN_cuda.SDNN.set_weights", "SDNN_cuda.SDNN.train_features", "SDNN_cuda.SDNN.test_features", "numpy.mean", "numpy.std", "Classifier.Classifier", "Classifier.Classifier.run_classiffier", "print", "print", "print", "os.path.dirname", "sum", "numpy.array", "numpy.array", "numpy.save", "numpy.save", "numpy.save", "numpy.save", "os.path.realpath", "math.floor", "math.floor", "math.floor", "range", "str", "str", "len", "str"], "function", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.set_weights", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_features", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.test_features", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.Classifier.Classifier.run_classiffier"], ["import", "sys", "\n", "\n", "def", "main", "(", ")", ":", "\n", "\n", "# Flags", "\n", "    ", "learn_SDNN", "=", "False", "# This flag toggles between Learning STDP and classify features", "\n", "# or just classify by loading pretrained weights for the face/motor dataset", "\n", "if", "learn_SDNN", ":", "\n", "        ", "set_weights", "=", "False", "# Loads the weights from a path (path_set_weigths) and prevents any SDNN learning", "\n", "save_weights", "=", "True", "# Saves the weights in a path (path_save_weigths)", "\n", "save_features", "=", "True", "# Saves the features and labels in the specified path (path_features)", "\n", "", "else", ":", "\n", "        ", "set_weights", "=", "True", "# Loads the weights from a path (path_set_weigths) and prevents any SDNN learning", "\n", "save_weights", "=", "False", "# Saves the weights in a path (path_save_weigths)", "\n", "save_features", "=", "False", "# Saves the features and labels in the specified path (path_features)", "\n", "\n", "# ------------------------------- Learn, Train and Test paths-------------------------------#", "\n", "# Image sets directories", "\n", "", "path", "=", "dirname", "(", "dirname", "(", "realpath", "(", "__file__", ")", ")", ")", "\n", "spike_times_learn", "=", "[", "path", "+", "'/datasets/LearningSet/Face/'", ",", "path", "+", "'/datasets/LearningSet/Motor/'", "]", "\n", "spike_times_train", "=", "[", "path", "+", "'/datasets/TrainingSet/Face/'", ",", "path", "+", "'/datasets/TrainingSet/Motor/'", "]", "\n", "spike_times_test", "=", "[", "path", "+", "'/datasets/TestingSet/Face/'", ",", "path", "+", "'/datasets/TestingSet/Motor/'", "]", "\n", "#spike_times_test = [path + '/datasets/TrainingSet/Face/', path + '/datasets/TrainingSet/Motor/']", "\n", "#spike_times_train = [path + '/datasets/TestingSet/Face/', path + '/datasets/TestingSet/Motor/']", "\n", "\n", "# Results directories", "\n", "path_set_weigths", "=", "'../find_params/sdnn_find_params/results/'", "\n", "path_save_weigths", "=", "'../find_params/sdnn_find_params/results/'", "\n", "path_features", "=", "'../find_params/sdnn_find_params/results/'", "\n", "\n", "# ------------------------------- SDNN -------------------------------#", "\n", "# SDNN_cuda parameters", "\n", "DoG_params", "=", "{", "'img_size'", ":", "(", "250", ",", "160", ")", ",", "'DoG_size'", ":", "7", ",", "'std1'", ":", "1.", ",", "'std2'", ":", "2.", "}", "# img_size is (col size, row size)", "\n", "total_time", "=", "15", "\n", "network_params", "=", "[", "{", "'Type'", ":", "'input'", ",", "'num_filters'", ":", "1", ",", "'pad'", ":", "(", "0", ",", "0", ")", ",", "'H_layer'", ":", "DoG_params", "[", "'img_size'", "]", "[", "1", "]", ",", "\n", "'W_layer'", ":", "DoG_params", "[", "'img_size'", "]", "[", "0", "]", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "4", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "10.", "}", ",", "\n", "{", "'Type'", ":", "'pool'", ",", "'num_filters'", ":", "4", ",", "'filter_size'", ":", "7", ",", "'th'", ":", "0.", ",", "'stride'", ":", "6", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "17", ",", "'th'", ":", "60.", "}", ",", "\n", "{", "'Type'", ":", "'pool'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "0.", ",", "'stride'", ":", "5", "}", ",", "\n", "{", "'Type'", ":", "'conv'", ",", "'num_filters'", ":", "20", ",", "'filter_size'", ":", "5", ",", "'th'", ":", "2.", "}", "]", "\n", "\n", "weight_params", "=", "{", "'mean'", ":", "0.8", ",", "'std'", ":", "0.01", "}", "\n", "\n", "max_learn_iter", "=", "[", "0", ",", "3000", ",", "0", ",", "5000", ",", "0", ",", "6000", ",", "0", "]", "\n", "stdp_params", "=", "{", "'max_learn_iter'", ":", "max_learn_iter", ",", "\n", "'stdp_per_layer'", ":", "[", "0", ",", "10", ",", "0", ",", "4", ",", "0", ",", "2", "]", ",", "\n", "'max_iter'", ":", "sum", "(", "max_learn_iter", ")", ",", "\n", "'a_minus'", ":", "np", ".", "array", "(", "[", "0", ",", ".003", ",", "0", ",", ".0003", ",", "0", ",", ".0003", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'a_plus'", ":", "np", ".", "array", "(", "[", "0", ",", ".004", ",", "0", ",", ".0004", ",", "0", ",", ".0004", "]", ",", "dtype", "=", "np", ".", "float32", ")", ",", "\n", "'offset_STDP'", ":", "[", "0", ",", "floor", "(", "network_params", "[", "1", "]", "[", "'filter_size'", "]", ")", ",", "\n", "0", ",", "\n", "floor", "(", "network_params", "[", "3", "]", "[", "'filter_size'", "]", "/", "8", ")", ",", "\n", "0", ",", "\n", "floor", "(", "network_params", "[", "5", "]", "[", "'filter_size'", "]", ")", "]", "}", "\n", "\n", "n_train_images", "=", "int", "(", "sys", ".", "argv", "[", "2", "]", ")", "\n", "# Create network", "\n", "first_net", "=", "SDNN", "(", "network_params", ",", "weight_params", ",", "stdp_params", ",", "total_time", ",", "\n", "DoG_params", "=", "DoG_params", ",", "spike_times_learn", "=", "spike_times_learn", ",", "\n", "spike_times_train", "=", "spike_times_train", ",", "spike_times_test", "=", "spike_times_test", ",", "device", "=", "'GPU'", ",", "n_train_images", "=", "n_train_images", ")", "\n", "\n", "\n", "\n", "first_net", ".", "weights_ID", "=", "sys", ".", "argv", "[", "1", "]", "\n", "first_net", ".", "w_factor", "=", "float", "(", "sys", ".", "argv", "[", "3", "]", ")", "\n", "first_net", ".", "std_init", "=", "float", "(", "sys", ".", "argv", "[", "4", "]", ")", "\n", "\n", "# set parameters", "\n", "first_net", ".", "ITER_TRAIN", "=", "1", "\n", "first_net", ".", "APLUS", "=", "0.007", "*", "first_net", ".", "w_factor", "\n", "first_net", ".", "AMINUS", "=", "0.003", "*", "first_net", ".", "w_factor", "\n", "first_net", ".", "TR_learning", "=", "10", "\n", "first_net", ".", "SPIKES_T0_CONSIDER", "=", "-", "1", "\n", "first_net", ".", "POOLING_W", "=", "1", "\n", "first_net", ".", "RANDOM_INIT", "=", "0.5", "\n", "first_net", ".", "TR_L1", "=", "6.25", "\n", "first_net", ".", "TR_L2", "=", "20.75", "\n", "first_net", ".", "CLASS_TR", "=", "-", "1", "\n", "\n", "\n", "#print(ITER_TRAIN, APLUS, AMINUS, TR_learning, SPIKES_T0_CONSIDER, POOLING_W, RANDOM_INIT, TR_L1, TR_L2, CLASS_TR)", "\n", "\n", "# Set the weights or learn STDP", "\n", "weights_path", "=", "\"../find_params/sdnn_original/results/\"", "\n", "weight_path_list", "=", "[", "weights_path", "+", "'weight_'", "+", "str", "(", "i", ")", "+", "'_'", "+", "first_net", ".", "weights_ID", "+", "'.npy'", "for", "i", "in", "range", "(", "len", "(", "network_params", ")", "-", "1", ")", "]", "\n", "first_net", ".", "set_weights", "(", "weight_path_list", ")", "\n", "\n", "# Get features", "\n", "X_train", ",", "y_train", "=", "first_net", ".", "train_features", "(", ")", "\n", "\n", "\n", "", "if", "__name__", "==", "'__main__'", ":", "\n", "    ", "start", "=", "time", ".", "time", "(", ")", "\n", "main", "(", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "print", "(", "end", "-", "start", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.__init__": [[64, 185], ["len", "SDNN_cuda.SDNN.init_net_struc", "SDNN_cuda.SDNN.init_layers", "SDNN_cuda.SDNN.init_weights", "SDNN_cuda.SDNN.check_dimensions", "DoG_filt_cuda.DoG", "SDNN_cuda.SDNN.gen_iter_paths", "SDNN_cuda.SDNN.gen_iter_paths", "SDNN_cuda.SDNN.gen_iter_paths", "itertools.tee"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_net_struc", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_weights", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.check_dimensions", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths"], ["spike_times_learn", "=", "None", ",", "spike_times_train", "=", "None", ",", "spike_times_test", "=", "None", ",", "\n", "y_train", "=", "None", ",", "y_test", "=", "None", ",", "device", "=", "'GPU'", ",", "n_train_images", "=", "999999", ")", ":", "\n", "        ", "\"\"\"\n            Initialisaition of SDNN\n\n            Input:            \n            - network_params: A list of dictionaries with the following keys:                \n                -'Type': A string specifying which kind of layer this is (either 'input', 'conv' and 'pool')\n                -'num_filters': an int specifying the depth (number of filters) of this layer\n                -'filter_size': an int specifying the height and width of the filter window for \n                                the previous layer to this layer (only on 'conv' and  'pool')\n                -'th': an np.float32 specifying the threshold of this layer (only on 'conv' and  'pool')\n                -'stride': an int specifying the stride for this layer (only on 'pool')\n                -'pad': an int specifying the pad for this layer (only on 'input')\n                -'H_layer': an int specifying the height of this layer (only on 'input')\n                -'W_layer': an int specifying the width of this layer (only on 'input') \n            - weight_params: A dictionary with the following keys:                \n                - 'mean': the mean for initialising the weights\n                - 'std': the std for initialising the weights\n            - stdp_params: A dictionary with the following keys:                                \n                - 'max_iter': an int specifyng the maximum number of iterations allowed on learning\n                - 'max_learn_iter': a list of ints specifying the maximum number of iterations allowed for training each layer (len = number of layers)\n                - 'stdp_per_layer': a list of ints specifying the maximum number of STDP updates per layer (len = number of layers)\n                - 'offset_STDP': a list of ints specifying the STDP ofset per leayer updates per layer (len = number of layers)\n                - 'a_minus': an np.float32 numpy array specifying the learning rate when no causality \n                - 'a_plus': an np.float32 numpy array specifying the learning rate when there is causality \n            - total_time: An int specifying the number of time steps per image\n            - spike_times_learn: A list of strings with a valid absolute or relative path to the folders with \n                                 the learning .jpg images OR \n                                 An uint8 array with the learning spike times of shape (N_lr, H_in, W_in, M_in). \n                                 Axis 0 is each of the images\n            - spike_times_train: A list of strings with a valid absolute or relative path to the folders with \n                                 the training .jpg images OR \n                                 An uint8 array with the training spike times of shape (N_tr, H_in, W_in, M_in). \n                                 Axis 0 is each of the images\n            - spike_times_test: A list of strings with a valid absolute or relative path to the folders with \n                                 the testing .jpg images OR \n                                 An uint8 array with the testing spike times of shape (N_ts, H_in, W_in, M_in). \n                                 Axis 0 is each of the images   \n            - DoG_params: None OR A dictionary with the following keys:\n                -'img_size': A tuple of integers with the dimensions to which the images are to be resized \n                -'DoG_size': An int with the size of the DoG filter window size\n                -'std1': A float with the standard deviation 1 for the DoG filter\n                -'std2': A float with the standard deviation 2 for the DoG filter                  \n                 \n        \"\"\"", "\n", "\n", "# --------------------------- DoG Filter Parameters -------------------#", "\n", "self", ".", "n_train_images", "=", "n_train_images", "\n", "if", "DoG_params", "is", "not", "None", ":", "\n", "            ", "self", ".", "DoG", "=", "True", "\n", "self", ".", "img_size", "=", "DoG_params", "[", "'img_size'", "]", "\n", "self", ".", "filt", "=", "DoG", "(", "DoG_params", "[", "'DoG_size'", "]", ",", "DoG_params", "[", "'std1'", "]", ",", "DoG_params", "[", "'std2'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "DoG", "=", "False", "\n", "\n", "# --------------------------- Network Initialisation -------------------#", "\n", "# Total time and number of layers", "\n", "", "self", ".", "num_layers", "=", "len", "(", "network_params", ")", "\n", "self", ".", "learnable_layers", "=", "[", "]", "\n", "self", ".", "total_time", "=", "total_time", "\n", "\n", "# Layers Initialisation", "\n", "self", ".", "network_struc", "=", "[", "]", "\n", "self", ".", "init_net_struc", "(", "network_params", ")", "\n", "self", ".", "layers", "=", "[", "]", "\n", "self", ".", "init_layers", "(", ")", "\n", "\n", "# Weights Initialisation", "\n", "self", ".", "weight_params", "=", "weight_params", "\n", "self", ".", "weights", "=", "[", "]", "\n", "self", ".", "init_weights", "(", ")", "\n", "\n", "# Dimension Check", "\n", "self", ".", "check_dimensions", "(", ")", "\n", "\n", "# ---------------------------Learning Paramters -------------------#", "\n", "# Learning layer parameters", "\n", "self", ".", "max_iter", "=", "stdp_params", "[", "'max_iter'", "]", "\n", "self", ".", "learning_layer", "=", "self", ".", "learnable_layers", "[", "0", "]", "\n", "self", ".", "max_learn_iter", "=", "stdp_params", "[", "'max_learn_iter'", "]", "\n", "self", ".", "curr_lay_idx", "=", "0", "\n", "self", ".", "counter", "=", "0", "\n", "self", ".", "curr_img", "=", "0", "\n", "\n", "#STDP params", "\n", "self", ".", "stdp_per_layer", "=", "stdp_params", "[", "'stdp_per_layer'", "]", "\n", "self", ".", "stdp_a_minus", "=", "stdp_params", "[", "'a_minus'", "]", "\n", "self", ".", "stdp_a_plus", "=", "stdp_params", "[", "'a_plus'", "]", "\n", "self", ".", "offsetSTDP", "=", "stdp_params", "[", "'offset_STDP'", "]", "\n", "\n", "# --------------------------- CUDA Parameters -------------------#", "\n", "self", ".", "device", "=", "device", "\n", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "            ", "self", ".", "thds_per_dim", "=", "10", "# (Use 8 if doesn't work)", "\n", "\n", "# --------------------------- Input spike times -------------------#", "\n", "# Generate Iterators with the full path to the images in each set OR reference the spike times", "\n", "", "if", "self", ".", "DoG", ":", "\n", "            ", "self", ".", "spike_times_learn", ",", "self", ".", "y_learn", "=", "self", ".", "gen_iter_paths", "(", "spike_times_learn", ")", "\n", "self", ".", "spike_times_train", ",", "self", ".", "y_train", "=", "self", ".", "gen_iter_paths", "(", "spike_times_train", ",", "n_train_images", ")", "\n", "self", ".", "spike_times_test", ",", "self", ".", "y_test", "=", "self", ".", "gen_iter_paths", "(", "spike_times_test", ")", "\n", "self", ".", "num_img_learn", "=", "self", ".", "y_learn", ".", "size", "\n", "self", ".", "num_img_train", "=", "self", ".", "y_train", ".", "size", "\n", "self", ".", "num_img_test", "=", "self", ".", "y_test", ".", "size", "\n", "\n", "self", ".", "spike_times_train", ",", "self", ".", "learn_buffer", ",", "self", ".", "train_score_img", "=", "tee", "(", "self", ".", "spike_times_train", ",", "3", ")", "\n", "\n", "", "else", ":", "\n", "            ", "self", ".", "spike_times_learn", "=", "spike_times_learn", "\n", "self", ".", "num_img_learn", "=", "spike_times_learn", ".", "shape", "[", "0", "]", "\n", "self", ".", "spike_times_train", "=", "spike_times_train", "\n", "self", ".", "num_img_train", "=", "spike_times_train", ".", "shape", "[", "0", "]", "\n", "self", ".", "spike_times_test", "=", "spike_times_test", "\n", "self", ".", "num_img_test", "=", "spike_times_test", ".", "shape", "[", "0", "]", "\n", "self", ".", "y_train", "=", "y_train", "\n", "self", ".", "y_test", "=", "y_test", "\n", "\n", "# --------------------------- Output features -------------------#", "\n", "", "self", ".", "features_train", "=", "[", "]", "\n", "self", ".", "features_test", "=", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_net_struc": [[189, 229], ["range", "SDNN_cuda.SDNN.network_struc.append", "numpy.array", "math.floor", "int", "int", "SDNN_cuda.SDNN.learnable_layers.append", "math.floor", "int", "int", "sys.exit", "int", "int", "math.floor", "math.floor", "int", "int", "math.floor", "math.floor", "math.floor", "math.floor", "math.floor", "math.floor"], "methods", ["None"], ["", "def", "init_net_struc", "(", "self", ",", "network_params", ")", ":", "\n", "        ", "\"\"\"\n            Network structure initialisation \n        \"\"\"", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "d_tmp", "=", "{", "}", "\n", "if", "network_params", "[", "i", "]", "[", "'Type'", "]", "==", "'input'", ":", "\n", "                ", "d_tmp", "[", "'Type'", "]", "=", "network_params", "[", "i", "]", "[", "'Type'", "]", "\n", "d_tmp", "[", "'H_layer'", "]", "=", "network_params", "[", "i", "]", "[", "'H_layer'", "]", "\n", "d_tmp", "[", "'W_layer'", "]", "=", "network_params", "[", "i", "]", "[", "'W_layer'", "]", "\n", "d_tmp", "[", "'num_filters'", "]", "=", "network_params", "[", "i", "]", "[", "'num_filters'", "]", "\n", "d_tmp", "[", "'pad'", "]", "=", "network_params", "[", "i", "]", "[", "'pad'", "]", "\n", "d_tmp", "[", "'shape'", "]", "=", "(", "d_tmp", "[", "'H_layer'", "]", ",", "d_tmp", "[", "'W_layer'", "]", ",", "d_tmp", "[", "'num_filters'", "]", ")", "\n", "", "elif", "network_params", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "d_tmp", "[", "'Type'", "]", "=", "network_params", "[", "i", "]", "[", "'Type'", "]", "\n", "d_tmp", "[", "'th'", "]", "=", "network_params", "[", "i", "]", "[", "'th'", "]", "\n", "d_tmp", "[", "'filter_size'", "]", "=", "network_params", "[", "i", "]", "[", "'filter_size'", "]", "\n", "d_tmp", "[", "'num_filters'", "]", "=", "network_params", "[", "i", "]", "[", "'num_filters'", "]", "\n", "d_tmp", "[", "'pad'", "]", "=", "np", ".", "array", "(", "[", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", ",", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", "]", ")", "\n", "d_tmp", "[", "'stride'", "]", "=", "1", "\n", "d_tmp", "[", "'offset'", "]", "=", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", "\n", "d_tmp", "[", "'H_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'H_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "0", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'W_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'W_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "1", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'shape'", "]", "=", "(", "d_tmp", "[", "'H_layer'", "]", ",", "d_tmp", "[", "'W_layer'", "]", ",", "d_tmp", "[", "'num_filters'", "]", ")", "\n", "self", ".", "learnable_layers", ".", "append", "(", "i", ")", "\n", "", "elif", "network_params", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                ", "d_tmp", "[", "'Type'", "]", "=", "network_params", "[", "i", "]", "[", "'Type'", "]", "\n", "d_tmp", "[", "'th'", "]", "=", "network_params", "[", "i", "]", "[", "'th'", "]", "\n", "d_tmp", "[", "'filter_size'", "]", "=", "network_params", "[", "i", "]", "[", "'filter_size'", "]", "\n", "d_tmp", "[", "'num_filters'", "]", "=", "network_params", "[", "i", "]", "[", "'num_filters'", "]", "\n", "d_tmp", "[", "'pad'", "]", "=", "[", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", ",", "int", "(", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", ")", "]", "\n", "d_tmp", "[", "'stride'", "]", "=", "network_params", "[", "i", "]", "[", "'stride'", "]", "\n", "d_tmp", "[", "'offset'", "]", "=", "floor", "(", "d_tmp", "[", "'filter_size'", "]", "/", "2", ")", "\n", "d_tmp", "[", "'H_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'H_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "0", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'W_layer'", "]", "=", "int", "(", "1", "+", "floor", "(", "(", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'W_layer'", "]", "+", "2", "*", "d_tmp", "[", "'pad'", "]", "[", "1", "]", "-", "d_tmp", "[", "'filter_size'", "]", ")", "/", "d_tmp", "[", "'stride'", "]", ")", ")", "\n", "d_tmp", "[", "'shape'", "]", "=", "(", "d_tmp", "[", "'H_layer'", "]", ",", "d_tmp", "[", "'W_layer'", "]", ",", "d_tmp", "[", "'num_filters'", "]", ")", "\n", "", "else", ":", "\n", "                ", "exit", "(", "\"unknown layer specified: use 'input', 'conv' or 'pool' \"", ")", "\n", "", "self", ".", "network_struc", ".", "append", "(", "d_tmp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_weights": [[231, 252], ["range", "SDNN_cuda.SDNN.weights.append", "weights_tmp.astype", "numpy.random.normal", "numpy.ones"], "methods", ["None"], ["", "", "def", "init_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Weight Initialization\n        \"\"\"", "\n", "mean", "=", "self", ".", "weight_params", "[", "'mean'", "]", "\n", "std", "=", "self", ".", "weight_params", "[", "'std'", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "            ", "HH", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'filter_size'", "]", "\n", "WW", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'filter_size'", "]", "\n", "MM", "=", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'num_filters'", "]", "\n", "DD", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'num_filters'", "]", "\n", "w_shape", "=", "(", "HH", ",", "WW", ",", "MM", ",", "DD", ")", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "weights_tmp", "=", "(", "mean", "+", "std", "*", "np", ".", "random", ".", "normal", "(", "size", "=", "w_shape", ")", ")", "\n", "weights_tmp", "[", "weights_tmp", ">=", "1.", "]", "=", "0.99", "\n", "weights_tmp", "[", "weights_tmp", "<=", "0.", "]", "=", "0.01", "\n", "", "elif", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                ", "weights_tmp", "=", "np", ".", "ones", "(", "(", "HH", ",", "WW", ",", "MM", ")", ")", "/", "(", "HH", "*", "WW", ")", "\n", "", "else", ":", "\n", "                ", "continue", "\n", "", "self", ".", "weights", ".", "append", "(", "weights_tmp", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.check_dimensions": [[254, 275], ["range", "math.floor", "math.floor"], "methods", ["None"], ["", "", "def", "check_dimensions", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Checks the dimensions of the SDNN\n        \"\"\"", "\n", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "            ", "H_pre", ",", "W_pre", ",", "M_pre", "=", "self", ".", "network_struc", "[", "i", "-", "1", "]", "[", "'shape'", "]", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "HH", ",", "WW", ",", "MM", ",", "DD", "=", "self", ".", "weights", "[", "i", "-", "1", "]", ".", "shape", "\n", "", "else", ":", "\n", "                ", "HH", ",", "WW", ",", "MM", "=", "self", ".", "weights", "[", "i", "-", "1", "]", ".", "shape", "\n", "", "H_post", ",", "W_post", ",", "D_post", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'stride'", "]", "\n", "H_pad", ",", "W_pad", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'pad'", "]", "\n", "\n", "assert", "floor", "(", "(", "H_pre", "+", "2", "*", "H_pad", "-", "HH", ")", "/", "stride", ")", "+", "1", "==", "H_post", ",", "'Error HEIGHT: layer %s to layer %s . '", "'Width does not work'", "%", "(", "i", "-", "1", ",", "i", ")", "\n", "assert", "floor", "(", "(", "W_pre", "+", "2", "*", "W_pad", "-", "WW", ")", "/", "stride", ")", "+", "1", "==", "W_post", ",", "'Error WIDTH: layer %s to layer %s . '", "'Width does not work'", "%", "(", "i", "-", "1", ",", "i", ")", "\n", "assert", "MM", "==", "M_pre", ",", "'Error in DEPTH of PREVIOUS map'", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                ", "assert", "DD", "==", "D_post", ",", "'Error in DEPTH of CURRENT map'", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.init_layers": [[277, 290], ["range", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.ones().astype", "numpy.ones().astype", "SDNN_cuda.SDNN.layers.append", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones"], "methods", ["None"], ["", "", "", "def", "init_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Initialise layers         \n        \"\"\"", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "d_tmp", "=", "{", "}", "\n", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "d_tmp", "[", "'S'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "d_tmp", "[", "'V'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "d_tmp", "[", "'K_STDP'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ",", "D", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "d_tmp", "[", "'K_inh'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "self", ".", "layers", ".", "append", "(", "d_tmp", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers": [[292, 303], ["range", "numpy.zeros().astype", "numpy.zeros().astype", "numpy.ones().astype", "numpy.ones().astype", "numpy.zeros", "numpy.zeros", "numpy.ones", "numpy.ones"], "methods", ["None"], ["", "def", "reset_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Reset layers         \n        \"\"\"", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", ")", ":", "\n", "            ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "=", "np", ".", "zeros", "(", "(", "H", ",", "W", ",", "D", ",", "self", ".", "total_time", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_STDP'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ",", "D", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "np", ".", "ones", "(", "(", "H", ",", "W", ")", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.get_weights": [[305, 307], ["None"], "methods", ["None"], ["", "def", "get_weights", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "weights", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.set_weights": [[309, 322], ["range", "numpy.load", "SDNN_cuda.SDNN.weights.append", "numpy.load.astype"], "methods", ["None"], ["", "def", "set_weights", "(", "self", ",", "path_list", ")", ":", "\n", "        ", "\"\"\"\n            Sets the weights to the values specified in path_list\n\n            Input:\n            - path_list: A list of strings specifying the addresses to the weights to be set. These weights must be \n                         stored as *.npy                    \n        \"\"\"", "\n", "self", ".", "weights", "=", "[", "]", "\n", "for", "id", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "            ", "weight_tmp", "=", "np", ".", "load", "(", "path_list", "[", "id", "]", ")", "\n", "self", ".", "weights", ".", "append", "(", "weight_tmp", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.gen_iter_paths": [[323, 332], ["numpy.ones", "iter", "range", "len", "len", "os.listdir", "numpy.append", "iter", "itertools.chain", "os.listdir", "range", "numpy.ones", "os.listdir", "len", "range", "len"], "methods", ["None"], ["\n", "", "def", "gen_iter_paths", "(", "self", ",", "path_list", ",", "n_images_to_consider", "=", "99999999", ")", ":", "\n", "        ", "images_per_dataset", "=", "min", "(", "len", "(", "listdir", "(", "path_list", "[", "0", "]", ")", ")", ",", "n_images_to_consider", ")", "\n", "labels", "=", "np", ".", "ones", "(", "images_per_dataset", ")", "\n", "paths_iter", "=", "iter", "(", "[", "path_list", "[", "0", "]", "+", "listdir", "(", "path_list", "[", "0", "]", ")", "[", "i", "]", "for", "i", "in", "range", "(", "labels", ".", "size", ")", "]", ")", "\n", "for", "idir", "in", "range", "(", "1", ",", "len", "(", "path_list", ")", ")", ":", "\n", "            ", "file_names", "=", "listdir", "(", "path_list", "[", "idir", "]", ")", "[", ":", "images_per_dataset", "]", "\n", "labels", "=", "np", ".", "append", "(", "labels", ",", "(", "idir", "+", "1", ")", "*", "np", ".", "ones", "(", "len", "(", "file_names", ")", ")", ")", "\n", "files_tmp", "=", "iter", "(", "[", "path_list", "[", "idir", "]", "+", "file_names", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "file_names", ")", ")", "]", ")", "\n", "paths_iter", "=", "chain", "(", "paths_iter", ",", "files_tmp", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_step": [[335, 413], ["range", "range", "numpy.pad", "SDNN_cuda.SDNN.convolution", "SDNN_cuda.SDNN.lateral_inh", "numpy.count_nonzero", "numpy.sum", "numpy.pad", "SDNN_cuda.SDNN.get_STDP_idxs", "SDNN_cuda.SDNN.STDP", "int", "int", "int", "SDNN_cuda.SDNN.pooling", "int", "math.ceil", "int", "math.ceil", "int", "math.ceil", "SDNN_cuda.SDNN.lateral_inh", "int", "int", "int", "math.ceil", "math.ceil", "math.ceil", "int", "math.ceil", "int", "math.ceil", "int", "math.ceil", "math.ceil", "math.ceil", "math.ceil"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.get_STDP_idxs", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.STDP", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh"], ["", "return", "paths_iter", ",", "labels", "\n", "\n", "\n", "# --------------------------- STDP Learning functions ------------------------#", "\n", "# Propagate and STDP once", "\n", "", "def", "train_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Propagates one image through the SDNN network and carries out the STDP update on the learning layer\n        \"\"\"", "\n", "\n", "# Propagate", "\n", "for", "t", "in", "range", "(", "1", ",", "self", ".", "total_time", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "learning_layer", "+", "1", ")", ":", "\n", "\n", "                ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "H_pad", ",", "W_pad", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'pad'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'stride'", "]", "\n", "th", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'th'", "]", "\n", "\n", "w", "=", "self", ".", "weights", "[", "i", "-", "1", "]", "\n", "s", "=", "self", ".", "layers", "[", "i", "-", "1", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Input spikes", "\n", "s", "=", "np", ".", "pad", "(", "s", ",", "(", "(", "H_pad", ",", "H_pad", ")", ",", "(", "W_pad", ",", "W_pad", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ")", "# Pad the input", "\n", "S", "=", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output spikes", "\n", "V", "=", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Output voltage before", "\n", "K_inh", "=", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "# Lateral inhibition matrix", "\n", "\n", "blockdim", "=", "(", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "0", "]", ")", ")", "if", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "1", "]", ")", ")", "if", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "if", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ")", "\n", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                    ", "V", ",", "S", "=", "self", ".", "convolution", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "V", "\n", "\n", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "", "elif", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                    ", "S", "=", "self", ".", "pooling", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "\n", "if", "i", "<", "3", ":", "\n", "                        ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "# STDP learning", "\n", "", "", "", "lay", "=", "self", ".", "learning_layer", "\n", "if", "self", ".", "network_struc", "[", "lay", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "\n", "# valid are neurons in the learning layer that can do STDP and that have fired in the current t", "\n", "                ", "S", "=", "self", ".", "layers", "[", "lay", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output spikes", "\n", "V", "=", "self", ".", "layers", "[", "lay", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output voltage", "\n", "K_STDP", "=", "self", ".", "layers", "[", "lay", "]", "[", "'K_STDP'", "]", "# Lateral inhibition matrix", "\n", "valid", "=", "S", "*", "V", "*", "K_STDP", "\n", "\n", "if", "np", ".", "count_nonzero", "(", "valid", ")", ">", "0", ":", "\n", "\n", "                    ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "lay", "]", "[", "'shape'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "lay", "]", "[", "'stride'", "]", "\n", "offset", "=", "self", ".", "offsetSTDP", "[", "lay", "]", "\n", "a_minus", "=", "self", ".", "stdp_a_minus", "[", "lay", "]", "\n", "a_plus", "=", "self", ".", "stdp_a_plus", "[", "lay", "]", "\n", "\n", "s", "=", "self", ".", "layers", "[", "lay", "-", "1", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", ":", "t", "]", "# Input spikes", "\n", "ssum", "=", "np", ".", "sum", "(", "s", ",", "axis", "=", "3", ")", "\n", "s", "=", "np", ".", "pad", "(", "ssum", ",", "(", "(", "H_pad", ",", "H_pad", ")", ",", "(", "W_pad", ",", "W_pad", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ")", "# Pad the input", "\n", "w", "=", "self", ".", "weights", "[", "lay", "-", "1", "]", "\n", "\n", "maxval", ",", "maxind1", ",", "maxind2", "=", "self", ".", "get_STDP_idxs", "(", "valid", ",", "H", ",", "W", ",", "D", ",", "lay", ")", "\n", "\n", "blockdim", "=", "(", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "0", "]", ")", ")", "if", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "1", "]", ")", ")", "if", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "if", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ")", "\n", "\n", "w", ",", "K_STDP", "=", "self", ".", "STDP", "(", "S", ".", "shape", ",", "s", ",", "w", ",", "K_STDP", ",", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_SDNN": [[417, 469], ["print", "print", "print", "range", "print", "print", "print", "print", "print", "SDNN_cuda.SDNN.reset_layers", "SDNN_cuda.SDNN.train_step", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "min", "next", "itertools.tee", "next", "str", "str", "str", "str", "str", "str"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter"], ["self", ".", "layers", "[", "lay", "]", "[", "'K_STDP'", "]", "=", "K_STDP", "\n", "\n", "\n", "\n", "# Train all images in training set", "\n", "", "", "", "", "def", "train_SDNN", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Trains the SDNN with the learning set of images\n            \n            We iterate over the set of images a maximum of self.max_iter times\n        \"\"\"", "\n", "\n", "print", "(", "\"-----------------------------------------------------------\"", ")", "\n", "print", "(", "\"-------------------- STARTING LEARNING---------------------\"", ")", "\n", "print", "(", "\"-----------------------------------------------------------\"", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "print", "(", "\"----------------- Learning Progress  {}%----------------------\"", ".", "format", "(", "str", "(", "i", ")", "+", "'/'", "\n", "+", "str", "(", "self", ".", "max_iter", ")", "\n", "+", "' ('", "\n", "+", "str", "(", "100", "*", "i", "/", "self", ".", "max_iter", ")", "\n", "+", "')'", ")", ")", "\n", "if", "self", ".", "counter", ">", "self", ".", "max_learn_iter", "[", "self", ".", "learning_layer", "]", ":", "\n", "                ", "self", ".", "curr_lay_idx", "+=", "1", "\n", "self", ".", "learning_layer", "=", "self", ".", "learnable_layers", "[", "self", ".", "curr_lay_idx", "]", "\n", "self", ".", "counter", "=", "0", "\n", "", "self", ".", "counter", "+=", "1", "\n", "\n", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "try", ":", "\n", "                    ", "path_img", "=", "next", "(", "self", ".", "learn_buffer", ")", "\n", "", "except", ":", "\n", "                    ", "self", ".", "spike_times_test", ",", "self", ".", "learn_buffer", "=", "tee", "(", "self", ".", "spike_times_test", ")", "\n", "path_img", "=", "next", "(", "self", ".", "learn_buffer", ")", "\n", "", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_learn", "[", "self", ".", "curr_img", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "train_step", "(", ")", "\n", "\n", "if", "i", "%", "500", "==", "0", ":", "\n", "                ", "self", ".", "stdp_a_plus", "[", "self", ".", "learning_layer", "]", "=", "min", "(", "2.", "*", "self", ".", "stdp_a_plus", "[", "self", ".", "learning_layer", "]", ",", "0.15", ")", "\n", "self", ".", "stdp_a_minus", "[", "self", ".", "learning_layer", "]", "=", "0.75", "*", "self", ".", "stdp_a_plus", "[", "self", ".", "learning_layer", "]", "\n", "\n", "", "if", "self", ".", "curr_img", "+", "1", "<", "self", ".", "num_img_learn", ":", "\n", "                ", "self", ".", "curr_img", "+=", "1", "\n", "", "else", ":", "\n", "                ", "self", ".", "curr_img", "=", "0", "\n", "", "", "print", "(", "\"----------------- Learning Progress  {}%----------------------\"", ".", "format", "(", "str", "(", "self", ".", "max_iter", ")", "+", "'/'", "\n", "+", "str", "(", "self", ".", "max_iter", ")", "\n", "+", "' ('", "\n", "+", "str", "(", "100", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.get_STDP_idxs": [[471, 513], ["numpy.amax", "numpy.argmax", "numpy.squeeze().astype", "numpy.squeeze().astype", "numpy.squeeze().astype", "numpy.ones", "numpy.ones", "numpy.ones", "numpy.sum", "numpy.amax", "numpy.argmax", "numpy.argmax", "numpy.sum", "numpy.squeeze", "numpy.squeeze", "numpy.squeeze", "max", "max", "min", "min"], "methods", ["None"], ["print", "(", "\"-----------------------------------------------------------\"", ")", "\n", "print", "(", "\"------------------- LEARNING COMPLETED --------------------\"", ")", "\n", "print", "(", "\"-----------------------------------------------------------\"", ")", "\n", "\n", "# Find STDP update indices and potentials", "\n", "", "def", "get_STDP_idxs", "(", "self", ",", "valid", ",", "H", ",", "W", ",", "D", ",", "layer_idx", ")", ":", "\n", "        ", "\"\"\"\n            Finds the indices and potentials of the post-synaptic neurons to update. \n            Only one update per map (if allowed) \n        \"\"\"", "\n", "\n", "i", "=", "layer_idx", "\n", "STDP_counter", "=", "1", "\n", "\n", "mxv", "=", "np", ".", "amax", "(", "valid", ",", "axis", "=", "2", ")", "\n", "mxi", "=", "np", ".", "argmax", "(", "valid", ",", "axis", "=", "2", ")", "\n", "\n", "maxind1", "=", "np", ".", "ones", "(", "(", "D", ",", "1", ")", ")", "*", "-", "1", "\n", "maxind2", "=", "np", ".", "ones", "(", "(", "D", ",", "1", ")", ")", "*", "-", "1", "\n", "maxval", "=", "np", ".", "ones", "(", "(", "D", ",", "1", ")", ")", "*", "-", "1", "\n", "\n", "while", "np", ".", "sum", "(", "np", ".", "sum", "(", "mxv", ")", ")", "!=", "0.", ":", "\n", "# for each layer a certain number of neurons can do the STDP per image", "\n", "            ", "if", "STDP_counter", ">", "self", ".", "stdp_per_layer", "[", "i", "]", ":", "\n", "                ", "break", "\n", "", "else", ":", "\n", "                ", "STDP_counter", "+=", "1", "\n", "\n", "", "maximum", "=", "np", ".", "amax", "(", "mxv", ",", "axis", "=", "1", ")", "\n", "index", "=", "np", ".", "argmax", "(", "mxv", ",", "axis", "=", "1", ")", "\n", "\n", "index1", "=", "np", ".", "argmax", "(", "maximum", ")", "\n", "index2", "=", "index", "[", "index1", "]", "\n", "\n", "maxval", "[", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "mxv", "[", "index1", ",", "index2", "]", "\n", "maxind1", "[", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "index1", "\n", "maxind2", "[", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "index2", "\n", "\n", "mxv", "[", "mxi", "==", "mxi", "[", "index1", ",", "index2", "]", "]", "=", "0", "\n", "mxv", "[", "max", "(", "index1", "-", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "0", ")", ":", "min", "(", "index1", "+", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "H", ")", "+", "1", ",", "\n", "max", "(", "index2", "-", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "0", ")", ":", "min", "(", "index2", "+", "self", ".", "offsetSTDP", "[", "layer_idx", "]", ",", "W", ")", "+", "1", "]", "=", "0", "\n", "\n", "", "maxval", "=", "np", ".", "squeeze", "(", "maxval", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step": [[516, 572], ["range", "range", "numpy.pad", "int", "int", "int", "SDNN_cuda.SDNN.convolution", "SDNN_cuda.SDNN.convolution_CPU", "SDNN_cuda.SDNN.lateral_inh", "SDNN_cuda.SDNN.lateral_inh_CPU", "int", "math.ceil", "int", "math.ceil", "int", "math.ceil", "SDNN_cuda.SDNN.pooling", "SDNN_cuda.SDNN.pooling_CPU", "math.ceil", "math.ceil", "math.ceil", "SDNN_cuda.SDNN.lateral_inh", "SDNN_cuda.SDNN.lateral_inh_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution_CPU", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling_CPU", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU"], ["\n", "return", "maxval", ",", "maxind1", ",", "maxind2", "\n", "\n", "# --------------------------- Propagation functions ------------------------#", "\n", "# Propagate once", "\n", "", "def", "prop_step", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n            Propagates one image through the SDNN network. \n            This function is identical to train_step() but here  no STDP takes place and we always reach the last layer\n        \"\"\"", "\n", "\n", "# Propagate", "\n", "for", "t", "in", "range", "(", "1", ",", "self", ".", "total_time", ")", ":", "\n", "            ", "for", "i", "in", "range", "(", "1", ",", "self", ".", "num_layers", ")", ":", "\n", "\n", "                ", "H", ",", "W", ",", "D", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'shape'", "]", "\n", "H_pad", ",", "W_pad", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'pad'", "]", "\n", "stride", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'stride'", "]", "\n", "th", "=", "self", ".", "network_struc", "[", "i", "]", "[", "'th'", "]", "\n", "\n", "w", "=", "self", ".", "weights", "[", "i", "-", "1", "]", "\n", "s", "=", "self", ".", "layers", "[", "i", "-", "1", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Input spikes", "\n", "s", "=", "np", ".", "pad", "(", "s", ",", "(", "(", "H_pad", ",", "H_pad", ")", ",", "(", "W_pad", ",", "W_pad", ")", ",", "(", "0", ",", "0", ")", ")", ",", "mode", "=", "'constant'", ")", "# Pad the input", "\n", "S", "=", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "# Output spikes", "\n", "V", "=", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "-", "1", "]", "# Output voltage before", "\n", "K_inh", "=", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "# Lateral inhibition matrix", "\n", "\n", "blockdim", "=", "(", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ",", "self", ".", "thds_per_dim", ")", "\n", "griddim", "=", "(", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "0", "]", ")", ")", "if", "int", "(", "ceil", "(", "H", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "1", "]", ")", ")", "if", "int", "(", "ceil", "(", "W", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ",", "\n", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "if", "int", "(", "ceil", "(", "D", "/", "blockdim", "[", "2", "]", ")", ")", "!=", "0", "else", "1", ")", "\n", "\n", "if", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'conv'", ":", "\n", "                    ", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                        ", "V", ",", "S", "=", "self", ".", "convolution", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                        ", "V", ",", "S", "=", "self", ".", "convolution_CPU", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'V'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "V", "\n", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "\n", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                        ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                        ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "", "elif", "self", ".", "network_struc", "[", "i", "]", "[", "'Type'", "]", "==", "'pool'", ":", "\n", "                    ", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                        ", "S", "=", "self", ".", "pooling", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", "\n", "", "else", ":", "\n", "                        ", "S", "=", "self", ".", "pooling_CPU", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "\n", "if", "i", "<", "3", ":", "\n", "                        ", "if", "self", ".", "device", "==", "'GPU'", ":", "\n", "                            ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh", "(", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes": [[573, 588], ["numba.jit", "numpy.zeros", "numpy.ndindex", "numpy.max", "int", "int"], "methods", ["None"], ["", "else", ":", "\n", "                            ", "S", ",", "K_inh", "=", "self", ".", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", "\n", "", "self", ".", "layers", "[", "i", "]", "[", "'S'", "]", "[", ":", ",", ":", ",", ":", ",", "t", "]", "=", "S", "\n", "self", ".", "layers", "[", "i", "]", "[", "'K_inh'", "]", "=", "K_inh", "\n", "\n", "", "", "", "", "", "@", "staticmethod", "\n", "@", "nb", ".", "jit", "(", "nopython", "=", "True", ")", "\n", "def", "pool_spikes", "(", "V", ",", "wsize", ")", ":", "\n", "      ", "if", "wsize", "==", "-", "1", ":", "\n", "        ", "wsize_w", "=", "V", ".", "shape", "[", "0", "]", "\n", "wsize_h", "=", "V", ".", "shape", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "wsize_w", "=", "wsize", "\n", "wsize_h", "=", "wsize", "\n", "# input is a matrix with the voltage which is then pooled using a window of size wsize_w X wsize_h", "\n", "", "pooled_spikes", "=", "np", ".", "zeros", "(", "shape", "=", "(", "int", "(", "V", ".", "shape", "[", "0", "]", "/", "wsize_w", ")", ",", "int", "(", "V", ".", "shape", "[", "1", "]", "/", "wsize_h", ")", ",", "V", ".", "shape", "[", "2", "]", ")", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.train_features": [[590, 883], ["random.seed", "numpy.random.seed", "set", "list", "list", "range", "range", "range", "print", "sys.exit", "list", "random.shuffle", "zip", "range", "SDNN_cuda.SDNN.reset_layers", "SDNN_cuda.SDNN.prop_step", "range", "classes_scores_train.append", "classes_scores_train_POT.append", "SDNN_cuda.SDNN.reset_layers", "SDNN_cuda.SDNN.prop_step", "range", "classes_scores_test.append", "classes_scores_test_POT.append", "numpy.random.normal", "zip", "SDNN_cuda.SDNN.reset_layers", "SDNN_cuda.SDNN.prop_step", "range", "next", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.where", "tuple", "tuple", "tuple", "next", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.where", "tuple", "tuple", "tuple", "isinstance", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.where", "tuple", "set", "set", "SDNN_cuda.SDNN.pool_spikes", "numpy.sum", "numpy.sum", "scores.values", "pot_scores.values", "max", "max", "float", "float", "set", "set", "SDNN_cuda.SDNN.pool_spikes", "numpy.sum", "numpy.sum", "scores.values", "pot_scores.values", "max", "max", "float", "float", "numpy.ones", "numpy.random.normal", "SDNN_cuda.SDNN.pool_spikes", "numpy.argsort", "numpy.array", "max", "max", "numpy.argsort", "numpy.array", "max", "max", "numpy.argsort", "numpy.array", "numpy.argsort", "scores.items", "pot_scores.items", "numpy.argsort", "scores.items", "pot_scores.items", "numpy.argsort", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pool_spikes"], ["        ", "pooled_spikes", "[", "i", ",", "j", ",", "k", "]", "=", "np", ".", "max", "(", "V", "[", "i", "*", "wsize_w", ":", "(", "i", "+", "1", ")", "*", "wsize_w", ",", "j", "*", "wsize_h", ":", "(", "j", "+", "1", ")", "*", "wsize_h", ",", "k", "]", ")", "\n", "\n", "", "return", "pooled_spikes", "\n", "\n", "# Get training features", "\n", "", "def", "train_features", "(", "self", ")", ":", "\n", "        ", "random", ".", "seed", "(", "33", ")", "\n", "np", ".", "random", ".", "seed", "(", "66", ")", "\n", "#return self.train_features_STDP()", "\n", "\n", "\"\"\"\n            Gets the train features by propagating the set of training images\n            Returns:\n                - X_train: Training features of size (N, M)\n                            where N is the number of training samples\n                            and M is the number of maps in the last layer\n        \"\"\"", "\n", "last_layer_shape", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'S'", "]", ".", "shape", "[", ":", "-", "1", "]", "\n", "last_layer_th", "=", "self", ".", "network_struc", "[", "5", "]", "[", "'th'", "]", "\n", "time_slots", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'S'", "]", ".", "shape", "[", "-", "1", "]", "\n", "self", ".", "class_matrix", "=", "{", "}", "\n", "for", "i", "in", "set", "(", "self", ".", "y_train", ")", ":", "\n", "          ", "self", ".", "class_matrix", "[", "i", "]", "=", "np", ".", "random", ".", "normal", "(", "self", ".", "w_init", ",", "self", ".", "std_init", ",", "last_layer_shape", ")", "\n", "self", ".", "class_matrix", "[", "i", "]", "[", "self", ".", "class_matrix", "[", "i", "]", ">", "1", "]", "=", "1", "\n", "self", ".", "class_matrix", "[", "i", "]", "[", "self", ".", "class_matrix", "[", "i", "]", "<", "0", "]", "=", "0", "\n", "\n", "", "self", ".", "network_struc", "[", "1", "]", "[", "'th'", "]", "=", "self", ".", "TR_L1", "\n", "self", ".", "network_struc", "[", "3", "]", "[", "'th'", "]", "=", "self", ".", "TR_L2", "# was 50.", "\n", "self", ".", "network_struc", "[", "5", "]", "[", "'th'", "]", "=", "100000", "# Set threshold of last layer to inf", "\n", "\n", "#MAX_VALUE = 1", "\n", "#MIN_VALUE = 0", "\n", "TR", "=", "self", ".", "TR_learning", "\n", "SPIKES_T0_CONSIDER", "=", "self", ".", "SPIKES_T0_CONSIDER", "\n", "\n", "train_images", "=", "list", "(", "self", ".", "spike_times_train", ")", "\n", "train_labels", "=", "list", "(", "self", ".", "y_train", ")", "\n", "\n", "#print(train_images,train_labels)", "\n", "#exit(0)", "\n", "a_plus", "=", "self", ".", "APLUS", "\n", "a_minus", "=", "self", ".", "AMINUS", "\n", "\n", "for", "iter_train", "in", "range", "(", "self", ".", "ITER_TRAIN", ")", ":", "\n", "\n", "          ", "c", "=", "list", "(", "zip", "(", "train_images", ",", "train_labels", ")", ")", "\n", "random", ".", "shuffle", "(", "c", ")", "\n", "train_images", ",", "train_labels", "=", "zip", "(", "*", "c", ")", "\n", "\n", "for", "img_n", "in", "range", "(", "self", ".", "num_img_train", ")", ":", "\n", "\n", "              ", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                  ", "path_img", "=", "train_images", "[", "img_n", "]", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                  ", "st", "=", "self", ".", "spike_times_train", "[", "img", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "\n", "", "label_img", "=", "train_labels", "[", "img_n", "]", "\n", "\n", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "\n", "for", "t_slot", "in", "range", "(", "time_slots", ")", ":", "\n", "\n", "                ", "cur_voltage", "=", "V", "[", ":", ",", ":", ",", ":", ",", "t_slot", "]", "\n", "if", "self", ".", "POOLING_W", "!=", "1", ":", "\n", "                  ", "cur_voltage", "=", "self", ".", "pool_spikes", "(", "cur_voltage", ",", "wsize", "=", "self", ".", "POOLING_W", ")", "\n", "", "'''\n                spiking_indices = np.argwhere(cur_voltage > last_layer_th)[:5]\n                if spiking_indices.shape[0] == 0:\n                  order = np.argsort(-cur_voltage.ravel())[:5]\n                  spiking_indices = np.stack(np.unravel_index(order,cur_voltage.shape),axis=1)\n                i,j,k = spiking_indices[:,0],spiking_indices[:,1],spiking_indices[:,2]\n                '''", "\n", "#take SPIKES_T0_CONSIDER top values greater than TR", "\n", "nzidx", "=", "np", ".", "where", "(", "cur_voltage", ">=", "TR", ")", "\n", "if", "SPIKES_T0_CONSIDER", "==", "-", "1", ":", "\n", "                  ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "                  ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "[", ":", "SPIKES_T0_CONSIDER", "]", "\n", "", "spiking_indices", "=", "tuple", "(", "np", ".", "array", "(", "nzidx", ")", "[", ":", ",", "ranking", "]", ")", "\n", "i", ",", "j", ",", "k", "=", "spiking_indices", "[", "0", "]", ",", "spiking_indices", "[", "1", "]", ",", "spiking_indices", "[", "2", "]", "\n", "\n", "n_spikes", "=", "i", ".", "size", "\n", "if", "n_spikes", "!=", "0", ":", "\n", "                  ", "for", "class_id", "in", "self", ".", "class_matrix", ":", "\n", "                    ", "if", "class_id", "==", "label_img", ":", "\n", "                      ", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "+=", "a_plus", "*", "(", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "*", "(", "np", ".", "ones", "(", "shape", "=", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ".", "shape", ")", "-", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ")", ")", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]>MAX_VALUE]=MAX_VALUE", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]<MIN_VALUE]=MIN_VALUE", "\n", "", "else", ":", "\n", "                      ", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "-=", "a_minus", "*", "(", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "*", "(", "np", ".", "ones", "(", "shape", "=", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ".", "shape", ")", "-", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ")", ")", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]>MAX_VALUE]=MAX_VALUE", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]<MIN_VALUE]=MIN_VALUE", "\n", "\n", "\n", "#print('getting TRAIN score')", "\n", "", "", "", "", "", "", "correct", "=", "0", "\n", "wrong", "=", "0", "\n", "correct_pot", "=", "0", "\n", "wrong_pot", "=", "0", "\n", "classes_scores_train", "=", "[", "]", "\n", "classes_scores_train_POT", "=", "[", "]", "\n", "scores_time_train", "=", "{", "}", "\n", "\n", "for", "img_n", "in", "range", "(", "self", ".", "num_img_train", ")", ":", "\n", "\n", "            ", "assigned_score", "=", "assigned_pot_score", "=", "False", "\n", "\n", "scores_time_train", "[", "img_n", "]", "=", "{", "}", "\n", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "path_img", "=", "next", "(", "self", ".", "train_score_img", ")", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_train", "[", "img", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "\n", "\n", "", "label_img", "=", "self", ".", "y_train", "[", "img_n", "]", "\n", "\n", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "\n", "scores", "=", "{", "class_id", ":", "0", "for", "class_id", "in", "set", "(", "self", ".", "y_train", ")", "}", "\n", "pot_scores", "=", "{", "class_id", ":", "0", "for", "class_id", "in", "set", "(", "self", ".", "y_train", ")", "}", "\n", "\n", "for", "t_slot", "in", "range", "(", "time_slots", ")", ":", "\n", "              ", "scores_time_train", "[", "img_n", "]", "[", "t_slot", "]", "=", "{", "}", "\n", "cur_voltage", "=", "V", "[", ":", ",", ":", ",", ":", ",", "t_slot", "]", "\n", "\n", "if", "self", ".", "POOLING_W", "!=", "1", ":", "\n", "                ", "cur_voltage", "=", "self", ".", "pool_spikes", "(", "cur_voltage", ",", "wsize", "=", "self", ".", "POOLING_W", ")", "\n", "\n", "", "nzidx", "=", "np", ".", "where", "(", "cur_voltage", ">=", "TR", ")", "\n", "if", "SPIKES_T0_CONSIDER", "==", "-", "1", ":", "\n", "                ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "                ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "[", ":", "SPIKES_T0_CONSIDER", "]", "\n", "", "spiking_indices", "=", "tuple", "(", "np", ".", "array", "(", "nzidx", ")", "[", ":", ",", "ranking", "]", ")", "\n", "i", ",", "j", ",", "k", "=", "spiking_indices", "[", "0", "]", ",", "spiking_indices", "[", "1", "]", ",", "spiking_indices", "[", "2", "]", "\n", "\n", "# first sum,", "\n", "for", "class_id", "in", "scores", ":", "\n", "                ", "scores", "[", "class_id", "]", "+=", "np", ".", "sum", "(", "self", ".", "class_matrix", "[", "class_id", "]", "[", "i", ",", "j", ",", "k", "]", ")", "\n", "pot_scores", "[", "class_id", "]", "+=", "np", ".", "sum", "(", "cur_voltage", "[", "i", ",", "j", ",", "k", "]", "*", "self", ".", "class_matrix", "[", "class_id", "]", "[", "i", ",", "j", ",", "k", "]", ")", "\n", "\n", "scores_time_train", "[", "img_n", "]", "[", "t_slot", "]", "[", "class_id", "]", "=", "scores", "[", "class_id", "]", "\n", "\n", "", "if", "self", ".", "CLASS_TR", "!=", "-", "1", ":", "\n", "#then check if it reached the class threshold just summing weights, and in such a casa take the max over the threshold", "\n", "                ", "if", "not", "assigned_score", ":", "\n", "                  ", "max_k", ",", "max_v", "=", "max", "(", "scores", ".", "items", "(", ")", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "if", "max_v", ">=", "self", ".", "CLASS_TR", ":", "\n", "                    ", "if", "max_k", "==", "label_img", ":", "\n", "                      ", "correct", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "wrong", "+=", "1", "\n", "", "assigned_score", "=", "True", "\n", "\n", "# also check if it reached the class threshold  summing weighted potentials, and in such a casa take the max over the threshold", "\n", "", "", "if", "not", "assigned_pot_score", ":", "\n", "                  ", "max_k", ",", "max_v", "=", "max", "(", "pot_scores", ".", "items", "(", ")", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "if", "max_v", ">=", "self", ".", "CLASS_TR", ":", "\n", "                    ", "if", "max_k", "==", "label_img", ":", "\n", "                      ", "correct_pot", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "wrong_pot", "+=", "1", "\n", "", "assigned_pot_score", "=", "True", "\n", "", "", "if", "assigned_pot_score", "and", "assigned_score", ":", "\n", "                  ", "break", "\n", "\n", "", "", "", "scores_time_train", "[", "img_n", "]", "[", "t_slot", "]", "[", "class_id", "]", "=", "scores", "[", "class_id", "]", "\n", "classes_scores_train", ".", "append", "(", "tuple", "(", "scores", ".", "values", "(", ")", ")", ")", "\n", "classes_scores_train_POT", ".", "append", "(", "tuple", "(", "pot_scores", ".", "values", "(", ")", ")", ")", "\n", "\n", "# if there's not TR, take the max", "\n", "if", "self", ".", "CLASS_TR", "==", "-", "1", ":", "\n", "              ", "if", "max", "(", "scores", ",", "key", "=", "scores", ".", "get", ")", "==", "label_img", ":", "\n", "                ", "correct", "+=", "1", "\n", "", "else", ":", "\n", "                ", "wrong", "+=", "1", "\n", "", "if", "max", "(", "pot_scores", ",", "key", "=", "pot_scores", ".", "get", ")", "==", "label_img", ":", "\n", "                ", "correct_pot", "+=", "1", "\n", "", "else", ":", "\n", "                ", "wrong_pot", "+=", "1", "\n", "\n", "", "", "", "train_score_str", "=", "f\"train score correct: {correct}, wrong: {wrong}, p: {correct/float(self.num_img_train)}\"", "\n", "train_score_str_pot", "=", "f\"weighted potential train score correct: {correct_pot}, wrong: {wrong_pot}, p: {correct_pot/float(self.num_img_train)}\"", "\n", "\n", "#print('getting TEST score')", "\n", "correct", "=", "0", "\n", "wrong", "=", "0", "\n", "correct_pot", "=", "0", "\n", "wrong_pot", "=", "0", "\n", "classes_scores_test", "=", "[", "]", "\n", "classes_scores_test_POT", "=", "[", "]", "\n", "scores_time_test", "=", "{", "}", "\n", "\n", "for", "img_n", "in", "range", "(", "self", ".", "num_img_test", ")", ":", "\n", "            ", "assigned_pot_score", "=", "False", "\n", "assigned_score", "=", "False", "\n", "scores_time_test", "[", "img_n", "]", "=", "{", "}", "\n", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                ", "path_img", "=", "next", "(", "self", ".", "spike_times_test", ")", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "st", "=", "self", ".", "spike_times_test", "[", "img", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "\n", "", "label_img", "=", "self", ".", "y_test", "[", "img_n", "]", "\n", "\n", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "# Obtain maximum potential per map in last layer", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "#features = np.max(np.max(np.max(V, axis=0), axis=0), axis=1)", "\n", "\n", "scores", "=", "{", "class_id", ":", "0", "for", "class_id", "in", "set", "(", "self", ".", "y_train", ")", "}", "\n", "pot_scores", "=", "{", "class_id", ":", "0", "for", "class_id", "in", "set", "(", "self", ".", "y_train", ")", "}", "\n", "\n", "for", "t_slot", "in", "range", "(", "time_slots", ")", ":", "\n", "              ", "scores_time_test", "[", "img_n", "]", "[", "t_slot", "]", "=", "{", "}", "\n", "cur_voltage", "=", "V", "[", ":", ",", ":", ",", ":", ",", "t_slot", "]", "\n", "\n", "if", "self", ".", "POOLING_W", "!=", "1", ":", "\n", "                ", "cur_voltage", "=", "self", ".", "pool_spikes", "(", "cur_voltage", ",", "wsize", "=", "self", ".", "POOLING_W", ")", "\n", "\n", "", "nzidx", "=", "np", ".", "where", "(", "cur_voltage", ">=", "TR", ")", "\n", "if", "SPIKES_T0_CONSIDER", "==", "-", "1", ":", "\n", "                ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "                ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "[", ":", "SPIKES_T0_CONSIDER", "]", "\n", "", "spiking_indices", "=", "tuple", "(", "np", ".", "array", "(", "nzidx", ")", "[", ":", ",", "ranking", "]", ")", "\n", "i", ",", "j", ",", "k", "=", "spiking_indices", "[", "0", "]", ",", "spiking_indices", "[", "1", "]", ",", "spiking_indices", "[", "2", "]", "\n", "\n", "# first sum", "\n", "for", "class_id", "in", "scores", ":", "\n", "                ", "scores", "[", "class_id", "]", "+=", "np", ".", "sum", "(", "self", ".", "class_matrix", "[", "class_id", "]", "[", "i", ",", "j", ",", "k", "]", ")", "\n", "pot_scores", "[", "class_id", "]", "+=", "np", ".", "sum", "(", "cur_voltage", "[", "i", ",", "j", ",", "k", "]", "*", "self", ".", "class_matrix", "[", "class_id", "]", "[", "i", ",", "j", ",", "k", "]", ")", "\n", "scores_time_test", "[", "img_n", "]", "[", "t_slot", "]", "[", "class_id", "]", "=", "scores", "[", "class_id", "]", "\n", "\n", "", "if", "self", ".", "CLASS_TR", "!=", "-", "1", ":", "\n", "#then check if it reached the class threshold just summing weights, and in such a casa take the max over the threshold", "\n", "                ", "if", "not", "assigned_score", ":", "\n", "                  ", "max_k", ",", "max_v", "=", "max", "(", "scores", ".", "items", "(", ")", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "if", "max_v", ">=", "self", ".", "CLASS_TR", ":", "\n", "                    ", "if", "max_k", "==", "label_img", ":", "\n", "                      ", "correct", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "wrong", "+=", "1", "\n", "", "assigned_score", "=", "True", "\n", "\n", "# also check if it reached the class threshold  summing weighted potentials, and in such a casa take the max over the threshold", "\n", "", "", "if", "not", "assigned_pot_score", ":", "\n", "                  ", "max_k", ",", "max_v", "=", "max", "(", "pot_scores", ".", "items", "(", ")", ",", "key", "=", "lambda", "t", ":", "t", "[", "1", "]", ")", "\n", "if", "max_v", ">=", "self", ".", "CLASS_TR", ":", "\n", "                    ", "if", "max_k", "==", "label_img", ":", "\n", "                      ", "correct_pot", "+=", "1", "\n", "", "else", ":", "\n", "                      ", "wrong_pot", "+=", "1", "\n", "", "assigned_pot_score", "=", "True", "\n", "", "", "if", "assigned_pot_score", "and", "assigned_score", ":", "\n", "                  ", "break", "\n", "\n", "\n", "", "", "", "classes_scores_test", ".", "append", "(", "tuple", "(", "scores", ".", "values", "(", ")", ")", ")", "\n", "classes_scores_test_POT", ".", "append", "(", "tuple", "(", "pot_scores", ".", "values", "(", ")", ")", ")", "\n", "scores_time_test", "[", "img_n", "]", "[", "t_slot", "]", "[", "class_id", "]", "=", "scores", "[", "class_id", "]", "\n", "\n", "# if there's not TR, just take the max", "\n", "if", "self", ".", "CLASS_TR", "==", "-", "1", ":", "\n", "              ", "if", "max", "(", "scores", ",", "key", "=", "scores", ".", "get", ")", "==", "label_img", ":", "\n", "                ", "correct", "+=", "1", "\n", "", "else", ":", "\n", "                ", "wrong", "+=", "1", "\n", "", "if", "max", "(", "pot_scores", ",", "key", "=", "pot_scores", ".", "get", ")", "==", "label_img", ":", "\n", "                ", "correct_pot", "+=", "1", "\n", "", "else", ":", "\n", "                ", "wrong_pot", "+=", "1", "\n", "\n", "", "", "", "test_score_str", "=", "f\"test score correct: {correct}, wrong: {wrong}, p: {correct/float(self.num_img_test)}\"", "\n", "test_score_str_pot", "=", "f\"weighted potential test score correct: {correct_pot}, wrong: {wrong_pot}, p: {correct_pot/float(self.num_img_test)}\"", "\n", "\n", "print", "(", "f'w_init {self.w_init} std_init {self.std_init}\\n{train_score_str}\\n{test_score_str}\\n{train_score_str_pot}\\n{test_score_str_pot}\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution": [[1004, 1019], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], ["\n", "# --------------------------- CUDA interfacing functions ------------------------#", "\n", "def", "convolution", "(", "self", ",", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda Convolution Kernel call\n            Returns the updated potentials and spike times\n        \"\"\"", "\n", "d_S", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_V", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "V", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "d_s", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "s", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_w", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "w", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "V_out", "=", "np", ".", "empty", "(", "d_V", ".", "shape", ",", "dtype", "=", "d_V", ".", "dtype", ")", "\n", "S_out", "=", "np", ".", "empty", "(", "d_S", ".", "shape", ",", "dtype", "=", "d_S", ".", "dtype", ")", "\n", "conv_step", "[", "griddim", ",", "blockdim", "]", "(", "d_S", ",", "d_V", ",", "d_s", ",", "d_w", ",", "stride", ",", "th", ")", "\n", "d_V", ".", "copy_to_host", "(", "V_out", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh": [[1020, 1034], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], ["d_S", ".", "copy_to_host", "(", "S_out", ")", "\n", "return", "V_out", ",", "S_out", "\n", "\n", "", "def", "lateral_inh", "(", "self", ",", "S", ",", "V", ",", "K_inh", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda Lateral Inhibition Kernel call\n            Returns the updated spike times and inhibition matrix\n        \"\"\"", "\n", "d_S", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_V", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "V", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "d_K_inh", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "K_inh", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "S_out", "=", "np", ".", "empty", "(", "d_S", ".", "shape", ",", "dtype", "=", "d_S", ".", "dtype", ")", "\n", "K_inh_out", "=", "np", ".", "empty", "(", "d_K_inh", ".", "shape", ",", "dtype", "=", "d_K_inh", ".", "dtype", ")", "\n", "lateral_inh", "[", "griddim", ",", "blockdim", "]", "(", "d_S", ",", "d_V", ",", "d_K_inh", ")", "\n", "d_S", ".", "copy_to_host", "(", "S_out", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling": [[1035, 1047], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], ["d_K_inh", ".", "copy_to_host", "(", "K_inh_out", ")", "\n", "return", "S_out", ",", "K_inh_out", "\n", "\n", "", "def", "pooling", "(", "self", ",", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda Pooling Kernel call\n            Returns the updated spike times\n        \"\"\"", "\n", "d_S", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_s", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "s", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_w", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "w", ")", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "S_out", "=", "np", ".", "empty", "(", "d_S", ".", "shape", ",", "dtype", "=", "d_S", ".", "dtype", ")", "\n", "pool", "[", "griddim", ",", "blockdim", "]", "(", "d_S", ",", "d_s", ",", "d_w", ",", "stride", ",", "th", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.STDP": [[1048, 1065], ["numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numba.cuda.to_device", "numpy.empty", "numpy.empty", "numba.cuda.to_device.copy_to_host", "numba.cuda.to_device.copy_to_host", "numpy.ascontiguousarray().astype", "numpy.ascontiguousarray().astype", "w.astype", "K_STDP.astype", "int", "numpy.ascontiguousarray", "numpy.ascontiguousarray"], "methods", ["None"], ["d_S", ".", "copy_to_host", "(", "S_out", ")", "\n", "return", "S_out", "\n", "\n", "", "def", "STDP", "(", "self", ",", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "maxval", ",", "maxind1", ",", "maxind2", ",", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ",", "blockdim", ",", "griddim", ")", ":", "\n", "        ", "\"\"\"\n            Cuda STDP-Update Kernel call\n            Returns the updated weight and STDP allowed matrix\n        \"\"\"", "\n", "d_S_sz", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "S_sz", ")", ".", "astype", "(", "np", ".", "int32", ")", ")", "\n", "d_s", "=", "cuda", ".", "to_device", "(", "np", ".", "ascontiguousarray", "(", "s", ")", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "d_w", "=", "cuda", ".", "to_device", "(", "w", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "d_K_STDP", "=", "cuda", ".", "to_device", "(", "K_STDP", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "w_out", "=", "np", ".", "empty", "(", "d_w", ".", "shape", ",", "dtype", "=", "d_w", ".", "dtype", ")", "\n", "K_STDP_out", "=", "np", ".", "empty", "(", "d_K_STDP", ".", "shape", ",", "dtype", "=", "d_K_STDP", ".", "dtype", ")", "\n", "STDP_learning", "[", "griddim", ",", "blockdim", "]", "(", "d_S_sz", ",", "d_s", ",", "d_w", ",", "d_K_STDP", ",", "# Input arrays", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "# Indices", "\n", "stride", ",", "int", "(", "offset", ")", ",", "a_minus", ",", "a_plus", ")", "# Parameters", "\n", "d_w", ".", "copy_to_host", "(", "w_out", ")", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.convolution_CPU": [[1068, 1075], ["cpu_utils.conv_step_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.conv_step_CPU"], ["\n", "\n", "# --------------------------- CPU interfacing functions ------------------------#", "\n", "", "def", "convolution_CPU", "(", "self", ",", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "        ", "\"\"\"\n            CPU Convolution Function call\n            Returns the updated potentials and spike times\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU": [[1076, 1083], ["cpu_utils.lateral_inh_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.lateral_inh_CPU"], ["V_out", ",", "S_out", "=", "conv_step_CPU", "(", "S", ",", "V", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "return", "V_out", ",", "S_out", "\n", "\n", "", "def", "lateral_inh_CPU", "(", "self", ",", "S", ",", "V", ",", "K_inh", ")", ":", "\n", "        ", "\"\"\"\n            CPU Lateral Inhibition Function call\n            Returns the updated spike times and inhibition matrix\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.pooling_CPU": [[1084, 1091], ["cpu_utils.pool_CPU"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.pool_CPU"], ["S_out", ",", "K_inh_out", "=", "lateral_inh_CPU", "(", "S", ",", "V", ",", "K_inh", ")", "\n", "return", "S_out", ",", "K_inh_out", "\n", "\n", "", "def", "pooling_CPU", "(", "self", ",", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", ":", "\n", "        ", "\"\"\"\n            CPU Pooling Function call\n            Returns the updated spike times\n        \"\"\"", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.STDP_CPU": [[1092, 1101], ["cpu_utils.STDP_learning_CPU", "int"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.cpu_utils.STDP_learning_CPU"], ["S_out", "=", "pool_CPU", "(", "S", ",", "s", ",", "w", ",", "stride", ",", "th", ")", "\n", "return", "S_out", "\n", "\n", "", "def", "STDP_CPU", "(", "self", ",", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "maxval", ",", "maxind1", ",", "maxind2", ",", "stride", ",", "offset", ",", "a_minus", ",", "a_plus", ")", ":", "\n", "            ", "\"\"\"\n                CPU STDP-Update Function call\n                Returns the updated weight and STDP allowed matrix\n            \"\"\"", "\n", "w_out", ",", "K_STDP_out", "=", "STDP_learning_CPU", "(", "S_sz", ",", "s", ",", "w", ",", "K_STDP", ",", "# Input arrays", "\n", "maxval", ",", "maxind1", ",", "maxind2", ",", "# Indices", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.test_features": [[636, 693], ["range", "len", "numpy.concatenate().reshape", "SDNN_cuda.SDNN.reset_layers", "SDNN_cuda.SDNN.prop_step", "numpy.max", "SDNN_cuda.SDNN.features_test.append", "next", "DoG_filt_cuda.DoG_filter", "numpy.expand_dims", "numpy.max", "numpy.concatenate", "numpy.max"], "methods", ["home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.reset_layers", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.SDNN_cuda.SDNN.prop_step", "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.src.DoG_filt_cuda.DoG_filter"], ["random", ".", "shuffle", "(", "c", ")", "\n", "train_images", ",", "train_labels", "=", "zip", "(", "*", "c", ")", "\n", "\n", "for", "img_n", "in", "range", "(", "self", ".", "num_img_train", ")", ":", "\n", "\n", "              ", "self", ".", "reset_layers", "(", ")", "# Reset all layers for the new image", "\n", "if", "self", ".", "DoG", ":", "\n", "                  ", "path_img", "=", "train_images", "[", "img_n", "]", "\n", "st", "=", "DoG_filter", "(", "path_img", ",", "self", ".", "filt", ",", "self", ".", "img_size", ",", "self", ".", "total_time", ",", "self", ".", "num_layers", ")", "\n", "st", "=", "np", ".", "expand_dims", "(", "st", ",", "axis", "=", "2", ")", "\n", "", "else", ":", "\n", "                  ", "st", "=", "self", ".", "spike_times_train", "[", "img", ",", ":", ",", ":", ",", ":", ",", ":", "]", "# (Image_number, H, W, M, time) to (H, W, M, time)", "\n", "\n", "", "label_img", "=", "train_labels", "[", "img_n", "]", "\n", "\n", "self", ".", "layers", "[", "0", "]", "[", "'S'", "]", "=", "st", "# (H, W, M, time)", "\n", "self", ".", "prop_step", "(", ")", "\n", "\n", "V", "=", "self", ".", "layers", "[", "self", ".", "num_layers", "-", "1", "]", "[", "'V'", "]", "\n", "\n", "for", "t_slot", "in", "range", "(", "time_slots", ")", ":", "\n", "\n", "                ", "cur_voltage", "=", "V", "[", ":", ",", ":", ",", ":", ",", "t_slot", "]", "\n", "if", "self", ".", "POOLING_W", "!=", "1", ":", "\n", "                  ", "cur_voltage", "=", "self", ".", "pool_spikes", "(", "cur_voltage", ",", "wsize", "=", "self", ".", "POOLING_W", ")", "\n", "", "'''\n                spiking_indices = np.argwhere(cur_voltage > last_layer_th)[:5]\n                if spiking_indices.shape[0] == 0:\n                  order = np.argsort(-cur_voltage.ravel())[:5]\n                  spiking_indices = np.stack(np.unravel_index(order,cur_voltage.shape),axis=1)\n                i,j,k = spiking_indices[:,0],spiking_indices[:,1],spiking_indices[:,2]\n                '''", "\n", "#take SPIKES_T0_CONSIDER top values greater than TR", "\n", "nzidx", "=", "np", ".", "where", "(", "cur_voltage", ">=", "TR", ")", "\n", "if", "SPIKES_T0_CONSIDER", "==", "-", "1", ":", "\n", "                  ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "\n", "", "else", ":", "\n", "                  ", "ranking", "=", "np", ".", "argsort", "(", "cur_voltage", "[", "nzidx", "]", ")", "[", ":", ":", "-", "1", "]", "[", ":", "SPIKES_T0_CONSIDER", "]", "\n", "", "spiking_indices", "=", "tuple", "(", "np", ".", "array", "(", "nzidx", ")", "[", ":", ",", "ranking", "]", ")", "\n", "i", ",", "j", ",", "k", "=", "spiking_indices", "[", "0", "]", ",", "spiking_indices", "[", "1", "]", ",", "spiking_indices", "[", "2", "]", "\n", "\n", "n_spikes", "=", "i", ".", "size", "\n", "if", "n_spikes", "!=", "0", ":", "\n", "                  ", "for", "class_id", "in", "self", ".", "class_matrix", ":", "\n", "                    ", "if", "class_id", "==", "label_img", ":", "\n", "                      ", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "+=", "a_plus", "*", "(", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "*", "(", "np", ".", "ones", "(", "shape", "=", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ".", "shape", ")", "-", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ")", ")", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]>MAX_VALUE]=MAX_VALUE", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]<MIN_VALUE]=MIN_VALUE", "\n", "", "else", ":", "\n", "                      ", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "-=", "a_minus", "*", "(", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", "*", "(", "np", ".", "ones", "(", "shape", "=", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ".", "shape", ")", "-", "self", ".", "class_matrix", "[", "label_img", "]", "[", "i", ",", "j", ",", "k", "]", ")", ")", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]>MAX_VALUE]=MAX_VALUE", "\n", "#self.class_matrix[label_img][self.class_matrix[label_img]<MIN_VALUE]=MIN_VALUE", "\n", "\n", "\n", "#print('getting TRAIN score')", "\n", "", "", "", "", "", "", "correct", "=", "0", "\n", "wrong", "=", "0", "\n", "correct_pot", "=", "0", "\n"]], "home.repos.pwc.inspect_result.bendiogene_recollection_hypothesis.find_params.to_table.print_to_file": [[10, 27], ["sorted", "open", "out_file.write", "out_file.write", "sorted", "os.path.join", "out_file.write", "sorted", "sum"], "function", ["None"], ["def", "print_to_file", "(", "results", ",", "order_by", "=", "None", ")", ":", "\n", "    ", "if", "order_by", "==", "\"avg\"", ":", "\n", "        ", "sorted_results", "=", "sorted", "(", "results", ",", "key", "=", "lambda", "k", ":", "0.5", "*", "sum", "(", "results", "[", "k", "]", ")", ",", "reverse", "=", "True", ")", "\n", "filename", "=", "\"res_avg.tex\"", "\n", "", "elif", "order_by", "==", "\"train\"", ":", "\n", "        ", "sorted_results", "=", "sorted", "(", "results", ",", "key", "=", "lambda", "k", ":", "results", "[", "k", "]", "[", "0", "]", ",", "reverse", "=", "True", ")", "\n", "filename", "=", "\"res_train.tex\"", "\n", "", "elif", "order_by", "==", "\"test\"", ":", "\n", "        ", "sorted_results", "=", "sorted", "(", "results", ",", "key", "=", "lambda", "k", ":", "results", "[", "k", "]", "[", "1", "]", ",", "reverse", "=", "True", ")", "\n", "filename", "=", "\"res_test.tex\"", "\n", "\n", "", "with", "open", "(", "os", ".", "path", ".", "join", "(", "OUTPUT_PATH", ",", "filename", ")", ",", "\"w\"", ")", "as", "out_file", ":", "\n", "        ", "out_file", ".", "write", "(", "\n", "'\\\\documentclass{article}\\n\\\\usepackage{longtable}\\n\\\\usepackage[utf8]{inputenc}\\n\\\\begin{document}\\n\\\\section{Results}\\n\\\\begin{longtable}{|c|c|c|c|c|c|c|c|c|c|c|}\\n\\\\hline\\nN iter & $\\\\alpha^+$ & $\\\\alpha^-$ & TR\\\\_learn & n\\\\_spikes & pool\\\\_w & random\\\\_init & tr\\_l1 & tr\\_l2 & train & test \\\\\\ \\\\hline\\n'", ")", "\n", "for", "item", "in", "sorted_results", ":", "\n", "            ", "out_file", ".", "write", "(", "'{}&{}&{}&{}&{}&{}&{}&{}&{}&{}&{}\\\\\\ \\\\hline\\n'", ".", "format", "(", "*", "item", ")", ")", "\n", "", "out_file", ".", "write", "(", "'\\n\\\\end{longtable}\\n\\\\end{document}\\n'", ")", "\n", "\n"]]}