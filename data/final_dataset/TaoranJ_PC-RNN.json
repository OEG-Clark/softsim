{"home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.models.Encoder.__init__": [[27, 41], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__"], ["def", "__init__", "(", "self", ",", "num_categories", ",", "embed_dim", ",", "p_encoder_hidden_dim", ",", "\n", "o_encoder_hidden_dim", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "num_categories", ",", "embed_dim", ",", "padding_idx", "=", "0", ")", "\n", "p_encoder_input_dim", "=", "1", "+", "embed_dim", "\n", "self", ".", "p_encoder_hidden_dim", "=", "p_encoder_hidden_dim", "\n", "self", ".", "p_encoder", "=", "nn", ".", "LSTM", "(", "p_encoder_input_dim", ",", "\n", "self", ".", "p_encoder_hidden_dim", ",", "\n", "num_layers", "=", "2", ",", "bidirectional", "=", "True", ")", "\n", "self", ".", "o_encoder_hidden_dim", "=", "o_encoder_hidden_dim", "\n", "self", ".", "a_encoder", "=", "nn", ".", "LSTM", "(", "1", ",", "self", ".", "o_encoder_hidden_dim", ",", "\n", "num_layers", "=", "2", ",", "bidirectional", "=", "True", ")", "\n", "self", ".", "i_encoder", "=", "nn", ".", "LSTM", "(", "1", ",", "self", ".", "o_encoder_hidden_dim", ",", "\n", "num_layers", "=", "2", ",", "bidirectional", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.models.Encoder.forward": [[42, 91], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "models.Encoder.p_encoder", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "models.Encoder.a_encoder", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "models.Encoder.i_encoder", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "a_ts.unsqueeze", "i_ts.unsqueeze", "p_ts.unsqueeze", "models.Encoder.embed"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "patent_src", ",", "assignee", ",", "inventor", ")", ":", "\n", "        ", "\"\"\"Forward propagation.\n\n        Parameters\n        ----------\n        patent_src : dict\n            patent_src['src_pts'] is the padded patent time sequences of shape\n            (seq_len, batch). patent_src['src_pcat'] is the padded patent\n            category sequences of shape (seq_len, batch). patent_src['length']\n            is used to pack padded sequence.\n        assignee : dict\n            assignee['ts'] is the padded assignee time sequences of shape\n            (seq_len, batch). assignee['length'] is used to pack padded\n            sequence.\n        inventor : dict\n            inventor['ts'] is the padded assignee time sequences of shape\n            (seq_len, batch). inventor['length'] is used to pack padded\n            sequence.\n\n        \"\"\"", "\n", "\n", "p_ts", ",", "p_cat", "=", "patent_src", "[", "'pts'", "]", ",", "patent_src", "[", "'pcat'", "]", "\n", "length", "=", "patent_src", "[", "'length'", "]", "\n", "a_ts", ",", "a_length", ",", "=", "assignee", "[", "'ts'", "]", ",", "assignee", "[", "'length'", "]", "\n", "a_org_idx", "=", "assignee", "[", "'org_idx'", "]", "\n", "i_ts", ",", "i_length", ",", "=", "inventor", "[", "'ts'", "]", ",", "inventor", "[", "'length'", "]", "\n", "i_org_idx", "=", "inventor", "[", "'org_idx'", "]", "\n", "# Encoder 1", "\n", "p_inputs", "=", "torch", ".", "cat", "(", "(", "p_ts", ".", "unsqueeze", "(", "-", "1", ")", ",", "self", ".", "embed", "(", "p_cat", ")", ")", ",", "dim", "=", "2", ")", "\n", "p_inputs", "=", "pack_padded_sequence", "(", "p_inputs", ",", "length", ")", "\n", "p_outputs", ",", "(", "p_hn", ",", "p_hc", ")", "=", "self", ".", "p_encoder", "(", "p_inputs", ")", "\n", "p_outputs", ",", "_", "=", "pad_packed_sequence", "(", "p_outputs", ")", "\n", "p_outputs", "=", "p_outputs", "[", ":", ",", ":", ",", ":", "self", ".", "p_encoder_hidden_dim", "]", "+", "p_outputs", "[", ":", ",", ":", ",", "self", ".", "p_encoder_hidden_dim", ":", "]", "\n", "# Encoder 2", "\n", "a_inputs", "=", "pack_padded_sequence", "(", "a_ts", ".", "unsqueeze", "(", "-", "1", ")", ",", "a_length", ")", "\n", "a_outputs", ",", "_", "=", "self", ".", "a_encoder", "(", "a_inputs", ")", "\n", "a_outputs", ",", "_", "=", "pad_packed_sequence", "(", "a_outputs", ")", "\n", "a_outputs", "=", "a_outputs", "[", ":", ",", ":", ",", ":", "self", ".", "o_encoder_hidden_dim", "]", "+", "a_outputs", "[", ":", ",", ":", ",", "self", ".", "o_encoder_hidden_dim", ":", "]", "\n", "a_outputs", "=", "a_outputs", "[", ":", ",", "a_org_idx", ",", ":", "]", "\n", "# Encoder 3:", "\n", "i_inputs", "=", "pack_padded_sequence", "(", "i_ts", ".", "unsqueeze", "(", "-", "1", ")", ",", "i_length", ")", "\n", "i_outputs", ",", "_", "=", "self", ".", "i_encoder", "(", "i_inputs", ")", "\n", "i_outputs", ",", "_", "=", "pad_packed_sequence", "(", "i_outputs", ")", "\n", "i_outputs", "=", "i_outputs", "[", ":", ",", ":", ",", ":", "self", ".", "o_encoder_hidden_dim", "]", "+", "i_outputs", "[", ":", ",", ":", ",", "self", ".", "o_encoder_hidden_dim", ":", "]", "\n", "i_outputs", "=", "i_outputs", "[", ":", ",", "i_org_idx", ",", ":", "]", "\n", "return", "(", "p_outputs", ",", "p_hn", "[", ":", "2", "]", ",", "p_hc", "[", ":", "2", "]", ")", ",", "a_outputs", ",", "i_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.models.Decoder.__init__": [[114, 146], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.LSTM", "torch.LSTM", "layers.GlobalAttn", "layers.GlobalAttn", "layers.GlobalAttn", "torch.Sequential", "torch.Sequential", "layers.GlobalAttn", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU", "torch.Linear", "torch.Linear", "torch.LogSoftmax", "torch.LogSoftmax", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__"], ["def", "__init__", "(", "self", ",", "num_categories", ",", "embed_dim", ",", "p_encoder_hidden_dim", ",", "\n", "o_encoder_hidden_dim", ",", "p_decoder_hidden_dim", ",", "\n", "p_decoder_inner_dim", ")", ":", "\n", "        ", "super", "(", "Decoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "num_categories", ",", "embed_dim", ",", "padding_idx", "=", "0", ")", "\n", "p_decoder_input_dim", "=", "1", "+", "embed_dim", "\n", "self", ".", "p_decoder", "=", "nn", ".", "LSTM", "(", "p_decoder_input_dim", ",", "p_decoder_hidden_dim", ",", "\n", "num_layers", "=", "2", ")", "\n", "# 1st attention layer", "\n", "self", ".", "p_attn", "=", "GlobalAttn", "(", "p_encoder_hidden_dim", ",", "p_decoder_hidden_dim", ")", "\n", "self", ".", "a_attn", "=", "GlobalAttn", "(", "o_encoder_hidden_dim", ",", "p_decoder_hidden_dim", ")", "\n", "self", ".", "i_attn", "=", "GlobalAttn", "(", "o_encoder_hidden_dim", ",", "p_decoder_hidden_dim", ")", "\n", "# 2nd attention layer", "\n", "self", ".", "p2o", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "p_encoder_hidden_dim", ",", "o_encoder_hidden_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "attn", "=", "GlobalAttn", "(", "o_encoder_hidden_dim", ",", "p_decoder_hidden_dim", ")", "\n", "self", ".", "o2p", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "o_encoder_hidden_dim", ",", "p_decoder_hidden_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ")", "\n", "context_dim", "=", "p_decoder_hidden_dim", "\n", "# Output", "\n", "self", ".", "out", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "p_decoder_hidden_dim", "+", "context_dim", ",", "p_decoder_inner_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ",", "\n", "nn", ".", "Linear", "(", "p_decoder_inner_dim", ",", "p_decoder_hidden_dim", ")", ",", "\n", "nn", ".", "ReLU", "(", ")", ")", "\n", "self", ".", "marker_gen", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "p_decoder_hidden_dim", ",", "self", ".", "embed", ".", "num_embeddings", ")", ",", "\n", "nn", ".", "LogSoftmax", "(", "dim", "=", "2", ")", ")", "\n", "self", ".", "time_gen", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "p_decoder_hidden_dim", ",", "1", ")", ",", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.models.Decoder.forward": [[147, 169], ["torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.Decoder.p_decoder", "models.Decoder.p_attn", "models.Decoder.bmm", "models.Decoder.a_attn", "models.Decoder.bmm", "models.Decoder.i_attn", "models.Decoder.bmm", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.Decoder.attn", "models.Decoder.bmm", "models.Decoder.o2p", "models.Decoder.out", "models.Decoder.time_gen", "models.Decoder.marker_gen", "p_encoder_outputs.transpose", "a_encoder_outputs.transpose", "i_encoder_outputs.transpose", "torch.cat.transpose", "torch.cat.transpose", "models.Decoder.transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "p_ts.unsqueeze", "models.Decoder.embed", "models.Decoder.p2o", "models.Decoder.bmm.transpose", "models.Decoder.bmm.transpose", "models.Decoder.bmm.transpose"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "p_ts", ",", "p_cat", ",", "p_hn", ",", "p_hc", ",", "p_encoder_outputs", ",", "\n", "a_encoder_outputs", ",", "i_encoder_outputs", ")", ":", "\n", "        ", "\"\"\"Decoder's forward propagation.\"\"\"", "\n", "\n", "p_input", "=", "torch", ".", "cat", "(", "(", "p_ts", ".", "unsqueeze", "(", "-", "1", ")", ",", "self", ".", "embed", "(", "p_cat", ")", ")", ",", "dim", "=", "2", ")", "\n", "p_output", ",", "(", "p_hn", ",", "p_hc", ")", "=", "self", ".", "p_decoder", "(", "p_input", ",", "(", "p_hn", ",", "p_hc", ")", ")", "\n", "p_weights", "=", "self", ".", "p_attn", "(", "p_encoder_outputs", ",", "p_output", ")", "\n", "p_context", "=", "p_weights", ".", "bmm", "(", "p_encoder_outputs", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "a_weights", "=", "self", ".", "a_attn", "(", "a_encoder_outputs", ",", "p_output", ")", "\n", "a_context", "=", "a_weights", ".", "bmm", "(", "a_encoder_outputs", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "i_weights", "=", "self", ".", "i_attn", "(", "i_encoder_outputs", ",", "p_output", ")", "\n", "i_context", "=", "i_weights", ".", "bmm", "(", "i_encoder_outputs", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "encoder_combined", "=", "torch", ".", "cat", "(", "(", "self", ".", "p2o", "(", "p_context", ".", "transpose", "(", "0", ",", "1", ")", ")", ",", "\n", "a_context", ".", "transpose", "(", "0", ",", "1", ")", ",", "\n", "i_context", ".", "transpose", "(", "0", ",", "1", ")", ")", ",", "dim", "=", "0", ")", "\n", "weights", "=", "self", ".", "attn", "(", "encoder_combined", ",", "p_output", ")", "\n", "context", "=", "weights", ".", "bmm", "(", "encoder_combined", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "context", "=", "self", ".", "o2p", "(", "context", ".", "transpose", "(", "0", ",", "1", ")", ")", "\n", "output", "=", "self", ".", "out", "(", "torch", ".", "cat", "(", "(", "context", ",", "p_output", ")", ",", "dim", "=", "2", ")", ")", "\n", "ts", "=", "self", ".", "time_gen", "(", "output", ")", "\n", "cat", "=", "self", ".", "marker_gen", "(", "output", ")", "\n", "return", "ts", ",", "cat", ",", "p_hn", ",", "p_hc", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.models.PCRNN.__init__": [[174, 178], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__"], ["def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ")", ":", "\n", "        ", "super", "(", "PCRNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "decoder", "=", "decoder", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.models.PCRNN.forward": [[179, 199], ["models.PCRNN.encoder", "[].unsqueeze", "[].unsqueeze", "enumerate", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.PCRNN.decoder", "torch.cat.append", "torch.cat.append", "torch.cat.append", "torch.cat.append", "[].unsqueeze.squeeze", "[].squeeze", "[].unsqueeze.topk"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "patent_src", ",", "assignee", ",", "inventor", ",", "patent_tgt", ")", ":", "\n", "        ", "\"\"\"Forward propagation\"\"\"", "\n", "\n", "pencoder", ",", "aencoder", ",", "iencoder", "=", "self", ".", "encoder", "(", "patent_src", ",", "assignee", ",", "\n", "inventor", ")", "\n", "\n", "tgt_ts_output", ",", "tgt_cat_output", "=", "[", "]", ",", "[", "]", "\n", "ts", "=", "patent_src", "[", "'pts'", "]", "[", "-", "1", "]", ".", "unsqueeze", "(", "0", ")", "\n", "cat", "=", "patent_src", "[", "'pcat'", "]", "[", "-", "1", "]", ".", "unsqueeze", "(", "0", ")", "\n", "pencoder_outputs", ",", "phn", ",", "phc", "=", "pencoder", "\n", "for", "t", ",", "_", "in", "enumerate", "(", "patent_tgt", "[", "'pts'", "]", ")", ":", "\n", "            ", "ts", ",", "cat", ",", "phn", ",", "phc", "=", "self", ".", "decoder", "(", "ts", ",", "cat", ",", "phn", ",", "phc", ",", "\n", "pencoder_outputs", ",", "\n", "aencoder", ",", "iencoder", ")", "\n", "tgt_ts_output", ".", "append", "(", "ts", ")", "\n", "tgt_cat_output", ".", "append", "(", "cat", ")", "\n", "ts", ",", "cat", "=", "ts", ".", "squeeze", "(", "-", "1", ")", ",", "cat", ".", "topk", "(", "1", ")", "[", "1", "]", ".", "squeeze", "(", "-", "1", ")", "\n", "", "tgt_ts_output", "=", "torch", ".", "cat", "(", "tgt_ts_output", ",", "dim", "=", "0", ")", "\n", "tgt_cat_output", "=", "torch", ".", "cat", "(", "tgt_cat_output", ",", "dim", "=", "0", ")", "\n", "return", "tgt_ts_output", ",", "tgt_cat_output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.generate_checkpoint_path": [[72, 79], ["str", "str", "int"], "function", ["None"], ["def", "generate_checkpoint_path", "(", ")", ":", "\n", "    ", "\"\"\"Generate checkpoint path.\"\"\"", "\n", "\n", "cuda", "=", "'cuda'", "+", "args", ".", "use_cuda", "\n", "cat", "=", "'cat'", "if", "args", ".", "use_category", "else", "'sub-cat'", "\n", "args", ".", "checkpoint_path", "+=", "'.{}.{}.ob{}.bs{}.pth'", ".", "format", "(", "\n", "cuda", ",", "cat", ",", "str", "(", "int", "(", "args", ".", "ob_ratio", "*", "10", ")", ")", ",", "str", "(", "args", ".", "batch_size", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.unzip_minibatch": [[121, 155], ["alength.to", "ilength.to", "src_pts.to", "src_pcat.to", "length.to", "tgt_pts.to", "tgt_pcat.to", "mask.to", "ats.to", "its.to"], "function", ["None"], ["def", "unzip_minibatch", "(", "data", ")", ":", "\n", "    ", "\"\"\"Unzip minibatch and load data to device.\n\n    Parameters\n    ----------\n    data : list\n        A minibatch of data.\n\n    Returns\n    -------\n    patent_src : dict\n        Minibatch data used on source side.\n    patent_tgt : dict\n        Minibatch data used on target side.\n    assignee : dict\n        Minibatch data for assignee series.\n    inventor : dict\n        Minibatch data for inventor series.\n\n    \"\"\"", "\n", "\n", "src_pts", ",", "tgt_pts", ",", "src_pcat", ",", "tgt_pcat", ",", "length", ",", "mask", ",", "ats", ",", "aorg_idx", ",", "alength", ",", "its", ",", "iorg_idx", ",", "ilength", "=", "data", "\n", "patent_src", "=", "{", "'pts'", ":", "src_pts", ".", "to", "(", "device", ")", ",", "'pcat'", ":", "src_pcat", ".", "to", "(", "device", ")", ",", "\n", "'length'", ":", "length", ".", "to", "(", "device", ")", "}", "\n", "patent_tgt", "=", "{", "'pts'", ":", "tgt_pts", ".", "to", "(", "device", ")", ",", "'pcat'", ":", "tgt_pcat", ".", "to", "(", "device", ")", ",", "\n", "'mask'", ":", "mask", ".", "to", "(", "device", ")", "}", "\n", "assignee", "=", "{", "'ts'", ":", "None", ",", "'org_idx'", ":", "None", ",", "'length'", ":", "None", "}", "\n", "inventor", "=", "{", "'ts'", ":", "None", ",", "'org_idx'", ":", "None", ",", "'length'", ":", "None", "}", "\n", "assignee", "[", "'ts'", "]", ",", "assignee", "[", "'org_idx'", "]", "=", "ats", ".", "to", "(", "device", ")", ",", "aorg_idx", "\n", "assignee", "[", "'length'", "]", "=", "alength", ".", "to", "(", "device", ")", "\n", "inventor", "[", "'ts'", "]", ",", "inventor", "[", "'org_idx'", "]", "=", "its", ".", "to", "(", "device", ")", ",", "iorg_idx", "\n", "inventor", "[", "'length'", "]", "=", "ilength", ".", "to", "(", "device", ")", "\n", "return", "patent_src", ",", "patent_tgt", ",", "assignee", ",", "inventor", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.cal_loss": [[157, 183], ["torch.abs().masked_select().sum", "torch.abs().masked_select().sum", "sum", "tgt_ts_output.squeeze", "torch.abs().masked_select", "torch.abs().masked_select", "train.NLLLoss_mask", "zip", "torch.abs", "torch.abs"], "function", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.NLLLoss_mask"], ["", "def", "cal_loss", "(", "tgt_ts_output", ",", "tgt_cat_output", ",", "patent_tgt", ")", ":", "\n", "    ", "\"\"\"Calculate loss for the forward propagation.\n\n    Parameters\n    ----------\n    tgt_ts_output : :class:`torch.Tensor`\n        Timestamp predictions on target side.\n    tgt_cat_output : :class:`torch.Tensor`\n        Category predictions on target side.\n    patent_tgt : dict\n        Minibatch data used on target side.\n\n    Returns\n    -------\n        loss.\n\n    \"\"\"", "\n", "\n", "# loss for timestamp prediction", "\n", "ts_loss", "=", "patent_tgt", "[", "'pts'", "]", "-", "tgt_ts_output", ".", "squeeze", "(", "-", "1", ")", "\n", "ts_loss", "=", "torch", ".", "abs", "(", "ts_loss", ")", ".", "masked_select", "(", "patent_tgt", "[", "'mask'", "]", ")", ".", "sum", "(", ")", "\n", "# loss for category prediction", "\n", "cat_loss", "=", "sum", "(", "NLLLoss_mask", "(", "p", ",", "t", ",", "m", ")", "\n", "for", "p", ",", "t", ",", "m", "in", "zip", "(", "tgt_cat_output", ",", "patent_tgt", "[", "'pcat'", "]", ",", "\n", "patent_tgt", "[", "'mask'", "]", ")", ")", "\n", "return", "ts_loss", "+", "cat_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.NLLLoss_mask": [[185, 213], ["torch.gather", "torch.gather", "cross_entropy.masked_select().sum", "target.view", "torch.gather.squeeze", "cross_entropy.masked_select"], "function", ["None"], ["", "def", "NLLLoss_mask", "(", "pred", ",", "target", ",", "mask", ")", ":", "\n", "    ", "\"\"\"\n\n    Customized NLLLoss for masked sequences. Losses are only calculated on the\n    non-pad targets which are masked out by the mask.\n\n    Parameters\n    ----------\n    pred : :class:`torch.Tensor`\n        Category prediction for each element in the minibatch, tensor of shape\n        (batch, num_categories). This should be the output of a softmax layer.\n    target : :class:`torch.Tensor`\n        True categories for each element in this minibatch, tensor of shape\n        (batch)\n    mask : :class:`torch.Tensor`\n        Mask out non-pad position in the target, tensor of shape (batch).\n\n    Returns\n    -------\n    loss : float\n        Loss of this minibatch.\n\n    \"\"\"", "\n", "\n", "pred", "=", "torch", ".", "gather", "(", "pred", ",", "1", ",", "target", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "cross_entropy", "=", "-", "pred", ".", "squeeze", "(", "1", ")", "\n", "loss", "=", "cross_entropy", ".", "masked_select", "(", "mask", ")", ".", "sum", "(", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.train_step": [[215, 238], ["optim.zero_grad", "train.unzip_minibatch", "model", "train.cal_loss", "cal_loss.backward", "torch.nn.utils.clip_grad_norm_", "torch.nn.utils.clip_grad_norm_", "optim.step", "cal_loss.item", "model.parameters"], "function", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.unzip_minibatch", "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.cal_loss"], ["", "def", "train_step", "(", "model", ",", "optim", ",", "data", ")", ":", "\n", "    ", "\"\"\"One training step.\n\n    Parameters\n    ----------\n    model : :class:`torch.nn.Module`\n        PCRNN.\n    optim : :class:`torch.optim.Optimizer`\n        Optimizer for PCRNN.\n    data : list\n        A minibatch of data.\n\n    \"\"\"", "\n", "\n", "optim", ".", "zero_grad", "(", ")", "\n", "patent_src", ",", "patent_tgt", ",", "assignee", ",", "inventor", "=", "unzip_minibatch", "(", "data", ")", "\n", "tgt_ts_output", ",", "tgt_cat_output", "=", "model", "(", "patent_src", ",", "assignee", ",", "inventor", ",", "\n", "patent_tgt", ")", "\n", "loss", "=", "cal_loss", "(", "tgt_ts_output", ",", "tgt_cat_output", ",", "patent_tgt", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "args", ".", "clip", ")", "\n", "optim", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.time_since": [[240, 248], ["time.time", "math.floor", "str().zfill", "str().zfill", "str", "str", "int", "int"], "function", ["None"], ["", "def", "time_since", "(", "since", ",", "m_padding", "=", "2", ",", "s_padding", "=", "2", ")", ":", "\n", "    ", "\"\"\"Elapsed time since last record point.\"\"\"", "\n", "now", "=", "time", ".", "time", "(", ")", "\n", "s", "=", "now", "-", "since", "\n", "m", "=", "math", ".", "floor", "(", "s", "/", "60", ")", "\n", "s", "-=", "m", "*", "60", "\n", "return", "'{}m:{}s'", ".", "format", "(", "str", "(", "int", "(", "m", ")", ")", ".", "zfill", "(", "m_padding", ")", ",", "\n", "str", "(", "int", "(", "s", ")", ")", ".", "zfill", "(", "s_padding", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.train": [[250, 286], ["model.train", "range", "time.time", "print", "epoch_losses.append", "train.train_step", "optim_scheduler.step", "torch.save", "torch.save", "batch[].size", "train.time_since", "model.state_dict", "optim.state_dict"], "function", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.train", "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.train_step", "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.time_since"], ["", "def", "train", "(", "model", ",", "optim", ",", "dataloader", ",", "optim_scheduler", ")", ":", "\n", "    ", "\"\"\"Training.\n\n    Parameters\n    ----------\n    model : :class:`torch.nn.Module`\n        PCRNN.\n    optim : :class:`torch.optim.Optimizer`\n        Optimizer for the model.\n    dataloader : :class:`torch.utils.data.DataLoader`\n        Dataloader for training set.\n\n    \"\"\"", "\n", "\n", "model", ".", "train", "(", ")", "\n", "start_epoch", ",", "best_epoch_loss", ",", "epoch_loss", "=", "time", ".", "time", "(", ")", ",", "1e15", ",", "0", "\n", "epoch_losses", "=", "[", "]", "\n", "for", "epoch", "in", "range", "(", "1", ",", "args", ".", "epochs", "+", "1", ")", ":", "\n", "        ", "for", "batch", "in", "dataloader", ":", "\n", "            ", "if", "batch", "[", "0", "]", ".", "size", "(", "1", ")", "<", "args", ".", "min_batch", ":", "\n", "                ", "continue", "\n", "", "loss", "=", "train_step", "(", "model", ",", "optim", ",", "batch", ")", "\n", "epoch_loss", "+=", "loss", "\n", "", "if", "args", ".", "tune_lr", ":", "\n", "            ", "optim_scheduler", ".", "step", "(", "epoch_loss", ")", "\n", "", "print", "(", "'[Epochs: {:02d}/{:02d}], Elapsed time: {} '", "\n", "'Loss: {:.4f}'", ".", "format", "(", "epoch", ",", "args", ".", "epochs", ",", "\n", "time_since", "(", "start_epoch", ")", ",", "epoch_loss", ")", ")", "\n", "if", "epoch_loss", "<=", "best_epoch_loss", ":", "\n", "            ", "torch", ".", "save", "(", "{", "'model'", ":", "model", ".", "state_dict", "(", ")", ",", "\n", "'optimizer'", ":", "optim", ".", "state_dict", "(", ")", "}", ",", "\n", "args", ".", "checkpoint_path", "+", "'.best'", ")", "\n", "best_epoch_loss", "=", "epoch_loss", "\n", "", "epoch_losses", ".", "append", "(", "epoch_loss", ")", "\n", "epoch_loss", "=", "0", "\n", "", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.collect_results": [[291, 332], ["patent_tgt[].unsqueeze", "patent_tgt[].unsqueeze", "patent_tgt[].unsqueeze", "tgt_ts_output.masked_select", "patent_tgt[].unsqueeze.masked_select", "pred_cat.masked_select.masked_select", "patent_tgt[].unsqueeze.masked_select", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "tgt_cat_output.topk", "patent_tgt[].unsqueeze.size", "patent_tgt[].unsqueeze.size", "patent_tgt[].unsqueeze.size", "pred_cat.masked_select.size", "tgt_ts_output.size", "torch.abs().sum().item", "torch.abs().sum().item", "tgt_ts_output.masked_select.size", "torch.sum().item", "torch.sum().item", "pred_cat.masked_select.size", "torch.abs().sum", "torch.abs().sum", "torch.sum", "torch.sum", "torch.abs", "torch.abs"], "function", ["None"], ["", "def", "collect_results", "(", "tgt_ts_output", ",", "tgt_cat_output", ",", "patent_tgt", ")", ":", "\n", "    ", "\"\"\"Prepare results and ground truth for evaluation.\n\n    Parameters\n    ----------\n    tgt_ts_output : :class:`torch.Tensor`\n        Prediction for arrival time, a tensor of shape (seq_len, batch, 1).\n    tgt_cat_output: :class:`torch.Tensor`\n        Prediction for category, a tensor of shape (seq_len, batch,\n        num_categories).\n    patent_tgt : dict\n        Ground truth data for patent prediction including real timestamp,\n        category and mask.\n    Returns\n    -------\n    mae : :class:`torch.Tensor`\n        (loss, # of points)\n    acc : :class:`torch.Tensor`\n        (# of correct predictions, # of points)\n\n    \"\"\"", "\n", "\n", "# get predictions and ground ready. y'all agree on dimensions first.", "\n", "tgt_pts", "=", "patent_tgt", "[", "'pts'", "]", ".", "unsqueeze", "(", "-", "1", ")", "\n", "tgt_pcat", "=", "patent_tgt", "[", "'pcat'", "]", ".", "unsqueeze", "(", "-", "1", ")", "\n", "mask", "=", "patent_tgt", "[", "'mask'", "]", ".", "unsqueeze", "(", "-", "1", ")", "\n", "pred_cat", "=", "tgt_cat_output", ".", "topk", "(", "1", ",", "dim", "=", "2", ")", "[", "1", "]", "\n", "assert", "(", "tgt_pts", ".", "size", "(", ")", "==", "tgt_pcat", ".", "size", "(", ")", "==", "mask", ".", "size", "(", ")", "==", "pred_cat", ".", "size", "(", ")", "\n", "==", "tgt_ts_output", ".", "size", "(", ")", ")", "\n", "# timestamp predictions and ground truth", "\n", "pred_ts", "=", "tgt_ts_output", ".", "masked_select", "(", "mask", ")", "\n", "tgt_ts", "=", "tgt_pts", ".", "masked_select", "(", "mask", ")", "\n", "# category predictions and ground truth", "\n", "pred_cat", "=", "pred_cat", ".", "masked_select", "(", "mask", ")", "\n", "tgt_cat", "=", "tgt_pcat", ".", "masked_select", "(", "mask", ")", "\n", "# calculate mae and accuracy", "\n", "mae", "=", "torch", ".", "tensor", "(", "[", "torch", ".", "abs", "(", "pred_ts", "-", "tgt_ts", ")", ".", "sum", "(", ")", ".", "item", "(", ")", ",", "\n", "pred_ts", ".", "size", "(", "0", ")", "]", ")", "\n", "acc", "=", "torch", ".", "tensor", "(", "[", "torch", ".", "sum", "(", "(", "pred_cat", "==", "tgt_cat", ")", ")", ".", "item", "(", ")", ",", "\n", "pred_cat", ".", "size", "(", "0", ")", "]", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "return", "mae", ",", "acc", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.evaluate_step": [[334, 358], ["train.unzip_minibatch", "model", "train.collect_results"], "function", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.unzip_minibatch", "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.collect_results"], ["", "def", "evaluate_step", "(", "model", ",", "data", ")", ":", "\n", "    ", "\"\"\"Evaluation on one minibatch.\n\n    Parameters\n    ----------\n    model : :class:`torch.nn.Module`\n        PCRNN.\n    data : dict\n        One minibatch of data.\n\n    Returns\n    -------\n    mae : :class:`torch.Tensor`\n        (loss, # of points)\n    acc : :class:`torch.Tensor`\n        (# of correct predictions, # of points)\n\n    \"\"\"", "\n", "\n", "patent_src", ",", "patent_tgt", ",", "assignee", ",", "inventor", "=", "unzip_minibatch", "(", "data", ")", "\n", "tgt_ts_output", ",", "tgt_cat_output", "=", "model", "(", "patent_src", ",", "assignee", ",", "inventor", ",", "\n", "patent_tgt", ")", "\n", "mae", ",", "acc", "=", "collect_results", "(", "tgt_ts_output", ",", "tgt_cat_output", ",", "patent_tgt", ")", "\n", "return", "mae", ",", "acc", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.evaluate": [[360, 384], ["torch.load", "torch.load", "model.load_state_dict", "model.eval", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.no_grad", "torch.no_grad", "train.evaluate_step", "open", "print"], "function", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.train.evaluate_step"], ["", "def", "evaluate", "(", "model", ",", "dataloader", ")", ":", "\n", "    ", "\"\"\"Calculate mean absolute value and accuracy.\n\n    Parameters\n    ----------\n    model : :class:`torch.nn.Module`\n        PCRNN.\n    dataloader : :class:`torch.utils.data.DataLoader`\n        Dataloader for dataset to evaluate.\n\n    \"\"\"", "\n", "\n", "checkpoint", "=", "torch", ".", "load", "(", "args", ".", "checkpoint_path", ")", "\n", "model", ".", "load_state_dict", "(", "checkpoint", "[", "'model'", "]", ")", "\n", "model", ".", "eval", "(", ")", "\n", "mae", ",", "acc", "=", "torch", ".", "tensor", "(", "[", "0.", ",", "0.", "]", ")", ",", "torch", ".", "tensor", "(", "[", "0.", ",", "0.", "]", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "for", "batch", "in", "dataloader", ":", "\n", "            ", "mae_step", ",", "acc_step", "=", "evaluate_step", "(", "model", ",", "batch", ")", "\n", "mae", "+=", "mae_step", "\n", "acc", "+=", "acc_step", "\n", "", "with", "open", "(", "args", ".", "checkpoint_path", "[", ":", "-", "4", "]", "+", "'.eval.txt'", ",", "'a'", ")", "as", "ofp", ":", "\n", "            ", "print", "(", "'MAE: {:.4f}, ACC: {:.4f}'", ".", "format", "(", "\n", "mae", "[", "0", "]", "/", "mae", "[", "1", "]", ",", "acc", "[", "0", "]", "/", "acc", "[", "1", "]", ")", ",", "file", "=", "ofp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.PatentDataset.__init__": [[111, 116], ["torch.utils.data.Dataset.__init__"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__"], ["def", "__init__", "(", "self", ",", "dataset", ",", "ob_ratio", ",", "use_category", "=", "False", ")", ":", "\n", "        ", "super", "(", "PatentDataset", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "pts", ",", "self", ".", "pcat", ",", "self", ".", "psubcat", ",", "self", ".", "ats", ",", "self", ".", "its", "=", "dataset", "\n", "self", ".", "ob_ratio", "=", "ob_ratio", "\n", "self", ".", "use_category", "=", "use_category", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.PatentDataset.__len__": [[117, 119], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "pts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.PatentDataset.__getitem__": [[120, 145], ["max", "len", "len", "len", "int"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "ix", ")", ":", "\n", "        ", "\"\"\"Patent sequences are splited to encoder and decoder. All assignee\n        and inventor sequences are used as encoder.\n\n        Returns\n        -------\n        patent time series source side, patent time series target side, patent\n        category info source side, patent category info target side, assignee\n        time series, inventor time series.\n\n        \"\"\"", "\n", "\n", "pts", ",", "pcat", ",", "psubcat", "=", "self", ".", "pts", "[", "ix", "]", ",", "self", ".", "pcat", "[", "ix", "]", ",", "self", ".", "psubcat", "[", "ix", "]", "\n", "len1", ",", "len2", ",", "len3", "=", "len", "(", "pts", ")", ",", "len", "(", "pcat", ")", ",", "len", "(", "psubcat", ")", "\n", "assert", "(", "len1", "==", "len2", "==", "len3", ")", "\n", "ats", ",", "its", "=", "self", ".", "ats", "[", "ix", "]", ",", "self", ".", "its", "[", "ix", "]", "\n", "# mark = NBER category or NBER subcategory", "\n", "category", "=", "NBER_CATEGORY", "if", "self", ".", "use_category", "else", "NBER_SUBCATEGORY", "\n", "pcat", "=", "pcat", "if", "self", ".", "use_category", "else", "psubcat", "\n", "# Split data for encoder and decoder", "\n", "elen", "=", "max", "(", "2", ",", "int", "(", "self", ".", "ob_ratio", "*", "len1", ")", ")", "# ob window > 2, has 1 tgt", "\n", "src_pts", ",", "tgt_pts", "=", "pts", "[", ":", "elen", "]", ",", "pts", "[", "elen", ":", "]", "\n", "src_pcat", "=", "[", "category", "[", "c", "]", "for", "c", "in", "pcat", "[", ":", "elen", "]", "]", "# Renumbering", "\n", "tgt_pcat", "=", "[", "category", "[", "c", "]", "for", "c", "in", "pcat", "[", "elen", ":", "]", "]", "# Renumbering", "\n", "return", "src_pts", ",", "tgt_pts", ",", "src_pcat", ",", "tgt_pcat", ",", "ats", ",", "its", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.load_csv": [[39, 59], ["data_config.items", "csv.reader", "csv.reader", "open", "open"], "function", ["None"], ["def", "load_csv", "(", "max_len", ")", ":", "\n", "    ", "\"\"\"Load raw csv file. Read 5 csv files configured in data_config.\n\n    Returns\n    -------\n    dict\n        {'time series name': a list of time series}. Each time series is\n        a list.\n\n    \"\"\"", "\n", "\n", "rets", "=", "{", "}", "\n", "for", "key", ",", "config", "in", "data_config", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", "in", "[", "'pat_ts'", ",", "'pat_cat'", ",", "'pat_subcat'", "]", ":", "\n", "            ", "rets", "[", "key", "]", "=", "[", "[", "config", "[", "1", "]", "(", "e", ")", "for", "e", "in", "row", "[", ":", "max_len", "]", "]", "\n", "for", "row", "in", "csv", ".", "reader", "(", "open", "(", "config", "[", "0", "]", ",", "'r'", ")", ")", "]", "\n", "", "else", ":", "\n", "            ", "rets", "[", "key", "]", "=", "[", "[", "config", "[", "1", "]", "(", "e", ")", "for", "e", "in", "row", "[", "-", "max_len", ":", "]", "]", "\n", "for", "row", "in", "csv", ".", "reader", "(", "open", "(", "config", "[", "0", "]", ",", "'r'", ")", ")", "]", "\n", "", "", "return", "rets", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.timestamp_normalization": [[61, 82], ["list", "itertools.chain", "numpy.max", "numpy.min", "itertools.chain.from_iterable"], "function", ["None"], ["", "def", "timestamp_normalization", "(", "streams", ")", ":", "\n", "    ", "\"\"\"Normalize timestamp in the time series.\n\n    Parameters\n    ----------\n    streams : dict\n        Five data streams.\n\n    Returns\n    -------\n        Normalized streams.\n\n    \"\"\"", "\n", "\n", "ts", "=", "list", "(", "itertools", ".", "chain", "(", "*", "itertools", ".", "chain", ".", "from_iterable", "(", "\n", "[", "streams", "[", "key", "]", "for", "key", "in", "ts_keys", "]", ")", ")", ")", "\n", "maxt", ",", "mint", "=", "np", ".", "max", "(", "ts", ")", ",", "np", ".", "min", "(", "ts", ")", "\n", "maxr", "=", "maxt", "-", "mint", "\n", "for", "key", "in", "ts_keys", ":", "\n", "        ", "streams", "[", "key", "]", "=", "[", "[", "(", "y", "-", "mint", ")", "/", "maxr", "for", "y", "in", "s", "]", "for", "s", "in", "streams", "[", "key", "]", "]", "\n", "", "return", "streams", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.split_train_test": [[84, 104], ["numpy.arange", "numpy.random.shuffle", "int", "numpy.random.seed", "idx[].tolist", "idx[].tolist"], "function", ["None"], ["", "def", "split_train_test", "(", "total_num", ",", "tr_ratio", ",", "keep_same", "=", "True", ")", ":", "\n", "    ", "\"\"\"Get train idx and test idx.\n\n    Parameters\n    ----------\n    total_num : int\n        Total number of points in the dataset.\n    tr_ratio : float\n        Ratio of the training set vs test set.\n    keep_same : bool\n        True to keep same split every time, False otherwise.\n\n    \"\"\"", "\n", "\n", "if", "keep_same", ":", "# Keep shuffle same every time", "\n", "        ", "np", ".", "random", ".", "seed", "(", "42", ")", "\n", "", "idx", "=", "np", ".", "arange", "(", "total_num", ")", "\n", "np", ".", "random", ".", "shuffle", "(", "idx", ")", "\n", "num_train", "=", "int", "(", "total_num", "*", "tr_ratio", ")", "\n", "return", "idx", "[", ":", "num_train", "]", ".", "tolist", "(", ")", ",", "idx", "[", "num_train", ":", "]", ".", "tolist", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.load_dataset": [[147, 178], ["data.load_csv", "data.split_train_test", "data.PatentDataset", "data.PatentDataset", "data.timestamp_normalization", "len", "len", "len", "operator.itemgetter", "operator.itemgetter"], "function", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.load_csv", "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.split_train_test", "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.timestamp_normalization"], ["", "", "def", "load_dataset", "(", "args", ",", "tr_ratio", "=", ".8", ",", "norm", "=", "True", ",", "max_len", "=", "200", ")", ":", "\n", "    ", "\"\"\"Load dataset given path.\n\n    Workflow: load_scv -> timestamp_normalization -> split_train_test ->\n    PatentDataset\n\n    Parameters\n    ----------\n    args : dict\n        Arguments.\n    tr_ratio : float\n        Ratio of dataset used as training set.\n    norm : bool\n        True to normalize time, False otherwise.\n\n    \"\"\"", "\n", "\n", "streams", "=", "load_csv", "(", "max_len", ")", "\n", "if", "norm", ":", "# Normalization timestamp", "\n", "        ", "streams", "=", "timestamp_normalization", "(", "streams", ")", "\n", "# Get training and test set", "\n", "", "train_idx", ",", "test_idx", "=", "split_train_test", "(", "len", "(", "streams", "[", "keys", "[", "0", "]", "]", ")", ",", "tr_ratio", ")", "\n", "train", "=", "[", "itemgetter", "(", "*", "train_idx", ")", "(", "streams", "[", "key", "]", ")", "for", "key", "in", "keys", "]", "\n", "test", "=", "[", "itemgetter", "(", "*", "test_idx", ")", "(", "streams", "[", "key", "]", ")", "for", "key", "in", "keys", "]", "\n", "# Build Dataset object", "\n", "train_set", "=", "PatentDataset", "(", "train", ",", "args", ".", "ob_ratio", ",", "\n", "use_category", "=", "args", ".", "use_category", ")", "\n", "test_set", "=", "PatentDataset", "(", "test", ",", "args", ".", "ob_ratio", ",", "\n", "use_category", "=", "args", ".", "use_category", ")", "\n", "ncats", "=", "len", "(", "NBER_CATEGORY", ")", "if", "args", ".", "use_category", "else", "len", "(", "NBER_SUBCATEGORY", ")", "\n", "return", "train_set", ",", "test_set", ",", "ncats", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.data.collate_fn": [[184, 237], ["sorted", "list", "torch.nn.utils.rnn.pad_sequence", "torch.nn.utils.rnn.pad_sequence", "torch.tensor", "torch.nn.utils.rnn.pad_sequence", "torch.nn.utils.rnn.pad_sequence", "sorted", "list", "torch.tensor", "torch.nn.utils.rnn.pad_sequence", "sorted", "list", "torch.tensor", "torch.nn.utils.rnn.pad_sequence", "zip", "torch.max", "enumerate", "zip", "torch.max", "enumerate", "zip", "torch.max", "torch.tensor", "torch.tensor", "s.size", "len", "len", "len", "torch.tensor", "torch.tensor", "enumerate", "len", "torch.tensor", "torch.tensor", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "function", ["None"], ["", "def", "collate_fn", "(", "insts", ")", ":", "\n", "    ", "\"\"\"Handle six streams in the minibatch.\n\n    Six streams included: src_pts, tgt_pts, src_pcat, tgt_pcat, ats, its. Note\n    that the first element is the target patent.\n\n    Pytorch LSTM needs ordered source side data. longest -> shortest. Then we\n    need to sort patent series, assignee series, and inventor series,\n    respectively.\n\n    Parameters\n    ----------\n    A minibatch in which patent, assignee, and inventor series are sorted\n    respectively.\n\n    \"\"\"", "\n", "\n", "# Sorted patent stream", "\n", "insts", "=", "sorted", "(", "insts", ",", "key", "=", "lambda", "k", ":", "len", "(", "k", "[", "0", "]", ")", ",", "reverse", "=", "True", ")", "\n", "src_pts", ",", "tgt_pts", ",", "src_pcat", ",", "tgt_pcat", ",", "ats", ",", "its", "=", "list", "(", "zip", "(", "*", "insts", ")", ")", "\n", "# Category. Drop target point.", "\n", "src_pcat", "=", "pad_sequence", "(", "[", "torch", ".", "tensor", "(", "seq", "[", "1", ":", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "for", "seq", "in", "src_pcat", "]", ")", "\n", "tgt_pcat", "=", "pad_sequence", "(", "[", "torch", ".", "tensor", "(", "seq", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "for", "seq", "in", "tgt_pcat", "]", ")", "\n", "mask", "=", "(", "tgt_pcat", ">", "0", ")", "# 0 is for pad", "\n", "# Interval. Target point of sequence is dropped", "\n", "src_pts_delta", "=", "[", "\n", "torch", ".", "max", "(", "(", "torch", ".", "tensor", "(", "seq", ")", "[", "1", ":", "]", "-", "torch", ".", "tensor", "(", "seq", ")", "[", ":", "-", "1", "]", ")", ",", "eps", ")", "\n", "for", "seq", "in", "src_pts", "]", "\n", "length", "=", "torch", ".", "tensor", "(", "[", "s", ".", "size", "(", "0", ")", "for", "s", "in", "src_pts_delta", "]", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "src_pts_delta", "=", "pad_sequence", "(", "src_pts_delta", ")", "\n", "tgt_pts_delta", "=", "pad_sequence", "(", "[", "\n", "torch", ".", "tensor", "(", "seq", ")", "-", "torch", ".", "tensor", "(", "[", "src_pts", "[", "ix", "]", "[", "-", "1", "]", "]", "+", "seq", "[", ":", "-", "1", "]", ")", "\n", "for", "ix", ",", "seq", "in", "enumerate", "(", "tgt_pts", ")", "]", ")", "\n", "# Sorted assignee time series", "\n", "sort_ats", "=", "sorted", "(", "enumerate", "(", "ats", ")", ",", "key", "=", "lambda", "x", ":", "len", "(", "x", "[", "1", "]", ")", ",", "reverse", "=", "True", ")", "\n", "aorg_idx", ",", "sort_ats", "=", "list", "(", "zip", "(", "*", "sort_ats", ")", ")", "\n", "sort_ats", "=", "[", "# Delta", "\n", "torch", ".", "max", "(", "torch", ".", "tensor", "(", "seq", "[", "1", ":", "]", ")", "-", "torch", ".", "tensor", "(", "seq", "[", ":", "-", "1", "]", ")", ",", "eps", ")", "\n", "for", "seq", "in", "sort_ats", "]", "\n", "alength", "=", "torch", ".", "tensor", "(", "[", "len", "(", "e", ")", "for", "e", "in", "sort_ats", "]", ")", "\n", "sort_ats", "=", "pad_sequence", "(", "sort_ats", ")", "\n", "# Sorted inventor time series", "\n", "sort_its", "=", "sorted", "(", "enumerate", "(", "its", ")", ",", "key", "=", "lambda", "x", ":", "len", "(", "x", "[", "1", "]", ")", ",", "reverse", "=", "True", ")", "\n", "iorg_idx", ",", "sort_its", "=", "list", "(", "zip", "(", "*", "sort_its", ")", ")", "\n", "sort_its", "=", "[", "# Delta", "\n", "torch", ".", "max", "(", "torch", ".", "tensor", "(", "seq", "[", "1", ":", "]", ")", "-", "torch", ".", "tensor", "(", "seq", "[", ":", "-", "1", "]", ")", ",", "eps", ")", "\n", "for", "seq", "in", "sort_its", "]", "\n", "ilength", "=", "torch", ".", "tensor", "(", "[", "len", "(", "e", ")", "for", "e", "in", "sort_its", "]", ")", "\n", "sort_its", "=", "pad_sequence", "(", "sort_its", ")", "\n", "return", "src_pts_delta", ",", "tgt_pts_delta", ",", "src_pcat", ",", "tgt_pcat", ",", "length", ",", "mask", ",", "sort_ats", ",", "aorg_idx", ",", "alength", ",", "sort_its", ",", "iorg_idx", ",", "ilength", "\n", "", ""]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.GlobalAttn.__init__": [[20, 30], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Tanh", "torch.Tanh", "torch.Tanh", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__"], ["def", "__init__", "(", "self", ",", "encoder_hidden_dim", ",", "decoder_hidden_dim", ")", ":", "\n", "        ", "super", "(", "GlobalAttn", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "encoder_hidden_dim", "=", "encoder_hidden_dim", "\n", "self", ".", "decoder_hidden_dim", "=", "decoder_hidden_dim", "\n", "self", ".", "attn", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "decoder_hidden_dim", "+", "encoder_hidden_dim", ",", "\n", "encoder_hidden_dim", ")", ",", "\n", "nn", ".", "Tanh", "(", ")", ")", "\n", "self", ".", "v", "=", "nn", ".", "Parameter", "(", "torch", ".", "tensor", "(", "encoder_hidden_dim", ",", "\n", "dtype", "=", "torch", ".", "float", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.GlobalAttn.concat_score": [[31, 60], ["decoder_current_hidden.expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "layers.GlobalAttn.attn", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "encoder_outputs.size"], "methods", ["None"], ["", "def", "concat_score", "(", "self", ",", "encoder_outputs", ",", "decoder_current_hidden", ")", ":", "\n", "        ", "\"\"\"Concat score\n\n        Parameters\n        ----------\n        encoder_outputs : :class:`torch.tensor`\n            All outputs of the encoder, tensor of shape\n            (seq_len, batch, encoder_hidden_dim)\n        decoder_current_hidden : :class:`torch.tensor`\n            Decoder's current hidden state, tensor of shape\n            (1, batch, decoder_hidden_dim).\n\n        Returns\n        -------\n        attn_energies : `torch.tensor`\n            Attention energies, tensor of shape (seq_len, batch).\n\n        \"\"\"", "\n", "\n", "# (seq_len, batch, encoder_hidden_dim)", "\n", "decoder_output", "=", "decoder_current_hidden", ".", "expand", "(", "\n", "encoder_outputs", ".", "size", "(", "0", ")", ",", "-", "1", ",", "-", "1", ")", "\n", "# concat the encoder hidden state and decoder hidden state", "\n", "hidden_cat", "=", "torch", ".", "cat", "(", "(", "decoder_output", ",", "encoder_outputs", ")", ",", "dim", "=", "2", ")", "\n", "# 'concat' score function (seq_len, batch, encoder_hidden_dim)", "\n", "energy", "=", "self", ".", "attn", "(", "hidden_cat", ")", "\n", "# (seq_len, batch)", "\n", "attn_energies", "=", "torch", ".", "sum", "(", "self", ".", "v", "*", "energy", ",", "dim", "=", "2", ")", "\n", "return", "attn_energies", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.GlobalAttn.forward": [[61, 83], ["layers.GlobalAttn.concat_score().t", "torch.softmax().unsqueeze", "torch.softmax().unsqueeze", "torch.softmax().unsqueeze", "layers.GlobalAttn.concat_score", "torch.softmax", "torch.softmax", "torch.softmax"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.GlobalAttn.concat_score"], ["", "def", "forward", "(", "self", ",", "encoder_outputs", ",", "decoder_current_hidden", ")", ":", "\n", "        ", "\"\"\"Return attention weights.\n\n        Parameters\n        ----------\n        encoder_outputs : `torch.tensor`\n            All outputs of the encoder, tensor of shape (seq_len, batch,\n            encoder_hidden_dim).\n        decoder_current_hidden : `torch.tensor`\n            Input hidden state, tensor of shape (1, batch, decoder_hidden_dim).\n\n        Returns\n        -------\n        attn_weights : `torch.Tensor`\n            Tensor of shape (batch, 1, seq_len).\n            attn_weights[i, 0, :].sum() = 1.\n\n        \"\"\"", "\n", "\n", "attn_energies", "=", "self", ".", "concat_score", "(", "encoder_outputs", ",", "\n", "decoder_current_hidden", ")", ".", "t", "(", ")", "\n", "return", "F", ".", "softmax", "(", "attn_energies", ",", "dim", "=", "1", ")", ".", "unsqueeze", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__": [[99, 103], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d"], "methods", ["home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.__init__"], ["def", "__init__", "(", "self", ",", "d", ",", "d_inner", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "w_1", "=", "nn", ".", "Conv1d", "(", "d", ",", "d_inner", ",", "1", ")", "# position-wise", "\n", "self", ".", "w_2", "=", "nn", ".", "Conv1d", "(", "d_inner", ",", "d", ",", "1", ")", "# position-wise", "\n", "\n"]], "home.repos.pwc.inspect_result.TaoranJ_PC-RNN.None.layers.PositionwiseFeedForward.forward": [[104, 118], ["x.transpose", "layers.PositionwiseFeedForward.w_2", "output.transpose.transpose.transpose", "torch.relu", "torch.relu", "torch.relu", "layers.PositionwiseFeedForward.w_1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"\n\n        Parameters\n        ----------\n        x : `torch.Tensor`\n            Tensor of shape (batch, len, embed_dim)\n\n        \"\"\"", "\n", "\n", "output", "=", "x", ".", "transpose", "(", "1", ",", "2", ")", "# (batch, embed_dim (channel), len)", "\n", "output", "=", "self", ".", "w_2", "(", "F", ".", "relu", "(", "self", ".", "w_1", "(", "output", ")", ")", ")", "\n", "output", "=", "output", ".", "transpose", "(", "1", ",", "2", ")", "\n", "return", "output", "\n", "", "", ""]]}