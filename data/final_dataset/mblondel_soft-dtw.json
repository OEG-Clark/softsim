{"home.repos.pwc.inspect_result.mblondel_soft-dtw.None.setup.configuration": [[26, 34], ["Configuration", "Configuration.add_subpackage"], "function", ["None"], ["def", "configuration", "(", "parent_package", "=", "''", ",", "top_path", "=", "None", ")", ":", "\n", "    ", "from", "numpy", ".", "distutils", ".", "misc_util", "import", "Configuration", "\n", "\n", "config", "=", "Configuration", "(", "None", ",", "parent_package", ",", "top_path", ")", "\n", "\n", "config", ".", "add_subpackage", "(", "'sdtw'", ")", "\n", "\n", "return", "config", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.distance.SquaredEuclidean.__init__": [[9, 21], ["X.astype", "Y.astype"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        X: array, shape = [m, d]\n            First time series.\n\n        Y: array, shape = [n, d]\n            Second time series.\n        \"\"\"", "\n", "self", ".", "X", "=", "X", ".", "astype", "(", "np", ".", "float64", ")", "\n", "self", ".", "Y", "=", "Y", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.distance.SquaredEuclidean.compute": [[22, 32], ["sklearn.metrics.pairwise.euclidean_distances"], "methods", ["None"], ["", "def", "compute", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute distance matrix.\n\n        Returns\n        -------\n        D: array, shape = [m, n]\n            Distance matrix.\n        \"\"\"", "\n", "return", "euclidean_distances", "(", "self", ".", "X", ",", "self", ".", "Y", ",", "squared", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.distance.SquaredEuclidean.jacobian_product": [[33, 54], ["numpy.zeros_like", "soft_dtw_fast._jacobian_product_sq_euc"], "methods", ["None"], ["", "def", "jacobian_product", "(", "self", ",", "E", ")", ":", "\n", "        ", "\"\"\"\n        Compute the product between the Jacobian\n        (a linear map from m x d to m x n) and a matrix E.\n\n        Parameters\n        ----------\n        E: array, shape = [m, n]\n            Second time series.\n\n        Returns\n        -------\n        G: array, shape = [m, d]\n            Product with Jacobian\n            ([m x d, m x n] * [m x n] = [m x d]).\n        \"\"\"", "\n", "G", "=", "np", ".", "zeros_like", "(", "self", ".", "X", ")", "\n", "\n", "_jacobian_product_sq_euc", "(", "self", ".", "X", ",", "self", ".", "Y", ",", "E", ",", "G", ")", "\n", "\n", "return", "G", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.chainer_func.SoftDTWLoss.__init__": [[13, 15], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "gamma", ")", ":", "\n", "        ", "self", ".", "gamma", "=", "gamma", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.chainer_func.SoftDTWLoss.forward_cpu": [[16, 27], ["distance.SquaredEuclidean", "soft_dtw.SoftDTW", "chainer_func.SoftDTWLoss.sdtw_.compute", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute"], ["", "def", "forward_cpu", "(", "self", ",", "inputs", ")", ":", "\n", "# Z, X: both are arrays of shape length x n_dim", "\n", "        ", "Z", ",", "X", "=", "inputs", "\n", "\n", "assert", "Z", ".", "shape", "[", "1", "]", "==", "X", ".", "shape", "[", "1", "]", "\n", "\n", "D", "=", "SquaredEuclidean", "(", "Z", ",", "X", ")", "\n", "self", ".", "sdtw_", "=", "SoftDTW", "(", "D", ",", "gamma", "=", "self", ".", "gamma", ")", "\n", "loss", "=", "self", ".", "sdtw_", ".", "compute", "(", ")", "\n", "\n", "return", "np", ".", "array", "(", "loss", ")", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.chainer_func.SoftDTWLoss.backward_cpu": [[28, 40], ["distance.SquaredEuclidean", "chainer_func.SoftDTWLoss.sdtw_.grad", "distance.SquaredEuclidean.jacobian_product().astype", "numpy.zeros_like", "distance.SquaredEuclidean.jacobian_product"], "methods", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.grad", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.distance.SquaredEuclidean.jacobian_product"], ["", "def", "backward_cpu", "(", "self", ",", "inputs", ",", "grad_outputs", ")", ":", "\n", "        ", "Z", ",", "X", "=", "inputs", "\n", "# g has the same shape as the output of forward_cpu().", "\n", "# g should always be 1 since it's the last function (loss function)", "\n", "g", ",", "=", "grad_outputs", "\n", "\n", "D", "=", "SquaredEuclidean", "(", "Z", ",", "X", ")", "\n", "E", "=", "self", ".", "sdtw_", ".", "grad", "(", ")", "\n", "gZ", "=", "D", ".", "jacobian_product", "(", "E", ")", ".", "astype", "(", "Z", ".", "dtype", ")", "\n", "\n", "# We don't need the gradient w.r.t. the 2nd argument.", "\n", "return", "gZ", ",", "np", ".", "zeros_like", "(", "X", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.setup.configuration": [[6, 17], ["Configuration", "Configuration.add_extension", "Configuration.add_subpackage", "numpy.get_include"], "function", ["None"], ["\n", "\n", "try", ":", "\n", "    ", "import", "numpy", "\n", "", "except", "ImportError", ":", "\n", "    ", "print", "(", "'numpy is required during installation'", ")", "\n", "sys", ".", "exit", "(", "1", ")", "\n", "\n", "\n", "", "DISTNAME", "=", "'soft-dtw'", "\n", "DESCRIPTION", "=", "\"Python implementation of soft-DTW\"", "\n", "LONG_DESCRIPTION", "=", "open", "(", "'README.rst'", ")", ".", "read", "(", ")", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.dataset._parse_ucr": [[10, 22], ["open", "line.strip.strip", "line.strip.split", "int", "list", "numpy.array().reshape", "y.append", "X.append", "numpy.array", "map", "numpy.array"], "function", ["None"], ["def", "_parse_ucr", "(", "filename", ")", ":", "\n", "    ", "y", "=", "[", "]", "\n", "X", "=", "[", "]", "\n", "for", "line", "in", "open", "(", "filename", ")", ":", "\n", "        ", "line", "=", "line", ".", "strip", "(", ")", "\n", "arr", "=", "line", ".", "split", "(", "\",\"", ")", "\n", "label", "=", "int", "(", "arr", "[", "0", "]", ")", "\n", "feat", "=", "list", "(", "map", "(", "float", ",", "arr", "[", "1", ":", "]", ")", ")", "\n", "feat", "=", "np", ".", "array", "(", "feat", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "y", ".", "append", "(", "label", ")", "\n", "X", ".", "append", "(", "feat", ")", "\n", "", "return", "X", ",", "np", ".", "array", "(", "y", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.dataset.list_ucr": [[24, 26], ["sorted", "os.listdir"], "function", ["None"], ["", "def", "list_ucr", "(", ")", ":", "\n", "    ", "return", "sorted", "(", "os", ".", "listdir", "(", "ucr_dir", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.dataset.load_ucr": [[28, 46], ["os.path.join", "os.path.join", "os.path.join", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "dataset._parse_ucr", "dataset._parse_ucr", "IOError"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.dataset._parse_ucr", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.dataset._parse_ucr"], ["", "def", "load_ucr", "(", "name", ")", ":", "\n", "    ", "folder", "=", "os", ".", "path", ".", "join", "(", "ucr_dir", ",", "name", ")", "\n", "tr", "=", "os", ".", "path", ".", "join", "(", "folder", ",", "\"%s_TRAIN\"", "%", "name", ")", "\n", "te", "=", "os", ".", "path", ".", "join", "(", "folder", ",", "\"%s_TEST\"", "%", "name", ")", "\n", "\n", "try", ":", "\n", "        ", "X_tr", ",", "y_tr", "=", "_parse_ucr", "(", "tr", ")", "\n", "X_te", ",", "y_te", "=", "_parse_ucr", "(", "te", ")", "\n", "", "except", "IOError", ":", "\n", "        ", "raise", "IOError", "(", "\"Please copy UCR_TS_Archive_2015/ to $HOME/sdtw_data/. \"", "\n", "\"Download from www.cs.ucr.edu/~eamonn/time_series_data.\"", ")", "\n", "\n", "", "y_tr", "=", "np", ".", "array", "(", "y_tr", ")", "\n", "y_te", "=", "np", ".", "array", "(", "y_te", ")", "\n", "X_tr", "=", "np", ".", "array", "(", "X_tr", ")", "\n", "X_te", "=", "np", ".", "array", "(", "X_te", ")", "\n", "\n", "return", "X_tr", ",", "y_tr", ",", "X_te", ",", "y_te", "\n", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.__init__": [[12, 36], ["hasattr", "soft_dtw.SoftDTW.D.astype", "D.compute"], "methods", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute"], ["    ", "def", "__init__", "(", "self", ",", "D", ",", "gamma", "=", "1.0", ")", ":", "\n", "        ", "\"\"\"\n        Parameters\n        ----------\n        D: array, shape = [m, n] or distance object\n            Distance matrix between elements of two time series.\n\n        gamma: float\n            Regularization parameter.\n            Lower is less smoothed (closer to true DTW).\n\n        Attributes\n        ----------\n        self.R_: array, shape = [m + 2, n + 2]\n            Accumulated cost matrix (stored after calling `compute`).\n        \"\"\"", "\n", "if", "hasattr", "(", "D", ",", "\"compute\"", ")", ":", "\n", "            ", "self", ".", "D", "=", "D", ".", "compute", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "D", "=", "D", "\n", "\n", "", "self", ".", "D", "=", "self", ".", "D", ".", "astype", "(", "np", ".", "float64", ")", "\n", "\n", "self", ".", "gamma", "=", "gamma", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute": [[37, 56], ["numpy.zeros", "soft_dtw_fast._soft_dtw"], "methods", ["None"], ["", "def", "compute", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute soft-DTW by dynamic programming.\n\n        Returns\n        -------\n        sdtw: float\n            soft-DTW discrepancy.\n        \"\"\"", "\n", "m", ",", "n", "=", "self", ".", "D", ".", "shape", "\n", "\n", "# Allocate memory.", "\n", "# We need +2 because we use indices starting from 1", "\n", "# and to deal with edge cases in the backward recursion.", "\n", "self", ".", "R_", "=", "np", ".", "zeros", "(", "(", "m", "+", "2", ",", "n", "+", "2", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "_soft_dtw", "(", "self", ".", "D", ",", "self", ".", "R_", ",", "gamma", "=", "self", ".", "gamma", ")", "\n", "\n", "return", "self", ".", "R_", "[", "m", ",", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.grad": [[57, 84], ["numpy.vstack", "numpy.hstack", "numpy.zeros", "soft_dtw_fast._soft_dtw_grad", "hasattr", "ValueError", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "grad", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Compute gradient of soft-DTW w.r.t. D by dynamic programming.\n\n        Returns\n        -------\n        grad: array, shape = [m, n]\n            Gradient w.r.t. D.\n        \"\"\"", "\n", "if", "not", "hasattr", "(", "self", ",", "\"R_\"", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Needs to call compute() first.\"", ")", "\n", "\n", "", "m", ",", "n", "=", "self", ".", "D", ".", "shape", "\n", "\n", "# Add an extra row and an extra column to D.", "\n", "# Needed to deal with edge cases in the recursion.", "\n", "D", "=", "np", ".", "vstack", "(", "(", "self", ".", "D", ",", "np", ".", "zeros", "(", "n", ")", ")", ")", "\n", "D", "=", "np", ".", "hstack", "(", "(", "D", ",", "np", ".", "zeros", "(", "(", "m", "+", "1", ",", "1", ")", ")", ")", ")", "\n", "\n", "# Allocate memory.", "\n", "# We need +2 because we use indices starting from 1", "\n", "# and to deal with edge cases in the recursion.", "\n", "E", "=", "np", ".", "zeros", "(", "(", "m", "+", "2", ",", "n", "+", "2", ")", ")", "\n", "\n", "_soft_dtw_grad", "(", "D", ",", "self", ".", "R_", ",", "E", ",", "gamma", "=", "self", ".", "gamma", ")", "\n", "\n", "return", "E", "[", "1", ":", "-", "1", ",", "1", ":", "-", "1", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.delannoy_num": [[7, 43], ["numpy.zeros", "range", "range", "range", "range"], "function", ["None"], ["def", "delannoy_num", "(", "m", ",", "n", ")", ":", "\n", "    ", "\"\"\"\n    Number of paths from the southwest corner (0, 0) of a rectangular grid to\n    the northeast corner (m, n), using only single steps north, northeast, or\n    east.\n\n    Named after French army officer and amateur mathematician Henri Delannoy.\n\n    Parameters\n    ----------\n    m, n : int, int\n        Northeast corner coordinates.\n\n    Returns\n    -------\n    delannoy_num: int\n        Delannoy number.\n\n    Reference\n    ---------\n    https://en.wikipedia.org/wiki/Delannoy_number\n    \"\"\"", "\n", "a", "=", "np", ".", "zeros", "(", "[", "m", "+", "1", ",", "n", "+", "1", "]", ")", "\n", "a", "[", "0", ",", "0", "]", "=", "1", "\n", "\n", "for", "i", "in", "range", "(", "1", ",", "m", "+", "1", ")", ":", "\n", "        ", "a", "[", "i", ",", "0", "]", "=", "1", "\n", "\n", "", "for", "j", "in", "range", "(", "1", ",", "n", "+", "1", ")", ":", "\n", "        ", "a", "[", "0", ",", "j", "]", "=", "1", "\n", "\n", "", "for", "i", "in", "range", "(", "1", ",", "m", "+", "1", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "1", ",", "n", "+", "1", ")", ":", "\n", "            ", "a", "[", "i", ",", "j", "]", "=", "a", "[", "i", "-", "1", ",", "j", "]", "+", "a", "[", "i", ",", "j", "-", "1", "]", "+", "a", "[", "i", "-", "1", ",", "j", "-", "1", "]", "\n", "\n", "", "", "return", "a", "[", "m", ",", "n", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths": [[45, 77], ["numpy.zeros", "path.gen_all_paths", "path.gen_all_paths", "path.gen_all_paths", "np.zeros.copy", "np.zeros.copy", "np.zeros.copy"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths"], ["", "def", "gen_all_paths", "(", "m", ",", "n", ",", "start", "=", "None", ",", "M", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    Generator that produces all possible paths between (1, 1) and (m, n), using\n    only north, northeast, or east steps. Each path is represented as a (m, n)\n    numpy array with ones indicating the path.\n\n    Parameters\n    ----------\n    m, n : int, int\n        Northeast corner coordinates.\n    \"\"\"", "\n", "if", "start", "is", "None", ":", "\n", "        ", "start", "=", "[", "0", ",", "0", "]", "\n", "M", "=", "np", ".", "zeros", "(", "(", "m", ",", "n", ")", ")", "\n", "\n", "", "i", ",", "j", "=", "start", "\n", "M", "[", "i", ",", "j", "]", "=", "1", "\n", "ret", "=", "[", "]", "\n", "\n", "if", "i", "==", "m", "-", "1", "and", "j", "==", "n", "-", "1", ":", "\n", "        ", "yield", "M", "\n", "", "else", ":", "\n", "        ", "if", "i", "<", "m", "-", "1", ":", "\n", "# Can use yield_from starting from Python 3.3.", "\n", "            ", "for", "mat", "in", "gen_all_paths", "(", "m", ",", "n", ",", "(", "i", "+", "1", ",", "j", ")", ",", "M", ".", "copy", "(", ")", ")", ":", "\n", "                ", "yield", "mat", "\n", "", "", "if", "i", "<", "m", "-", "1", "and", "j", "<", "n", "-", "1", ":", "\n", "            ", "for", "mat", "in", "gen_all_paths", "(", "m", ",", "n", ",", "(", "i", "+", "1", ",", "j", "+", "1", ")", ",", "M", ".", "copy", "(", ")", ")", ":", "\n", "                ", "yield", "mat", "\n", "", "", "if", "j", "<", "n", "-", "1", ":", "\n", "            ", "for", "mat", "in", "gen_all_paths", "(", "m", ",", "n", ",", "(", "i", ",", "j", "+", "1", ")", ",", "M", ".", "copy", "(", ")", ")", ":", "\n", "                ", "yield", "mat", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.barycenter.sdtw_barycenter": [[12, 73], ["numpy.array", "scipy.optimize.minimize", "scipy.optimize.minimize.x.reshape", "numpy.ones", "Z.reshape.reshape", "numpy.zeros_like", "range", "barycenter_init.ravel", "len", "len", "sdtw.distance.SquaredEuclidean", "sdtw.SoftDTW", "sdtw.SoftDTW.compute", "sdtw.SoftDTW.grad", "sdtw.distance.SquaredEuclidean.jacobian_product", "np.zeros_like.ravel", "dict"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.grad", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.distance.SquaredEuclidean.jacobian_product"], ["def", "sdtw_barycenter", "(", "X", ",", "barycenter_init", ",", "gamma", "=", "1.0", ",", "weights", "=", "None", ",", "\n", "method", "=", "\"L-BFGS-B\"", ",", "tol", "=", "1e-3", ",", "max_iter", "=", "50", ")", ":", "\n", "    ", "\"\"\"\n    Compute barycenter (time series averaging) under the soft-DTW geometry.\n\n    Parameters\n    ----------\n    X: list\n        List of time series, numpy arrays of shape [len(X[i]), d].\n\n    barycenter_init: array, shape = [length, d]\n        Initialization.\n\n    gamma: float\n        Regularization parameter.\n        Lower is less smoothed (closer to true DTW).\n\n    weights: None or array\n        Weights of each X[i]. Must be the same size as len(X).\n\n    method: string\n        Optimization method, passed to `scipy.optimize.minimize`.\n        Default: L-BFGS.\n\n    tol: float\n        Tolerance of the method used.\n\n    max_iter: int\n        Maximum number of iterations.\n    \"\"\"", "\n", "if", "weights", "is", "None", ":", "\n", "        ", "weights", "=", "np", ".", "ones", "(", "len", "(", "X", ")", ")", "\n", "\n", "", "weights", "=", "np", ".", "array", "(", "weights", ")", "\n", "\n", "def", "_func", "(", "Z", ")", ":", "\n", "# Compute objective value and grad at Z.", "\n", "\n", "        ", "Z", "=", "Z", ".", "reshape", "(", "*", "barycenter_init", ".", "shape", ")", "\n", "\n", "m", "=", "Z", ".", "shape", "[", "0", "]", "\n", "G", "=", "np", ".", "zeros_like", "(", "Z", ")", "\n", "\n", "obj", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "X", ")", ")", ":", "\n", "            ", "D", "=", "SquaredEuclidean", "(", "Z", ",", "X", "[", "i", "]", ")", "\n", "sdtw", "=", "SoftDTW", "(", "D", ",", "gamma", "=", "gamma", ")", "\n", "value", "=", "sdtw", ".", "compute", "(", ")", "\n", "E", "=", "sdtw", ".", "grad", "(", ")", "\n", "G_tmp", "=", "D", ".", "jacobian_product", "(", "E", ")", "\n", "G", "+=", "weights", "[", "i", "]", "*", "G_tmp", "\n", "obj", "+=", "weights", "[", "i", "]", "*", "value", "\n", "\n", "", "return", "obj", ",", "G", ".", "ravel", "(", ")", "\n", "\n", "# The function works with vectors so we need to vectorize barycenter_init.", "\n", "", "res", "=", "minimize", "(", "_func", ",", "barycenter_init", ".", "ravel", "(", ")", ",", "method", "=", "method", ",", "jac", "=", "True", ",", "\n", "tol", "=", "tol", ",", "options", "=", "dict", "(", "maxiter", "=", "max_iter", ",", "disp", "=", "False", ")", ")", "\n", "\n", "return", "res", ".", "x", ".", "reshape", "(", "*", "barycenter_init", ".", "shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_path.test_gen_all_paths": [[8, 16], ["sklearn.utils.testing.assert_equal", "sklearn.utils.testing.assert_equal", "sklearn.utils.testing.assert_equal", "sklearn.utils.testing.assert_equal", "sklearn.utils.testing.assert_equal", "len", "len", "len", "len", "sdtw.path.delannoy_num", "len", "sdtw.path.delannoy_num", "list", "list", "list", "list", "list", "sdtw.path.gen_all_paths", "sdtw.path.gen_all_paths", "sdtw.path.gen_all_paths", "sdtw.path.gen_all_paths", "sdtw.path.gen_all_paths"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.delannoy_num", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.delannoy_num", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths"], ["def", "test_gen_all_paths", "(", ")", ":", "\n", "    ", "assert_equal", "(", "len", "(", "list", "(", "gen_all_paths", "(", "2", ",", "2", ")", ")", ")", ",", "3", ")", "\n", "assert_equal", "(", "len", "(", "list", "(", "gen_all_paths", "(", "3", ",", "2", ")", ")", ")", ",", "5", ")", "\n", "assert_equal", "(", "len", "(", "list", "(", "gen_all_paths", "(", "4", ",", "2", ")", ")", ")", ",", "7", ")", "\n", "# delannoy_num counts paths from (0,0),", "\n", "# while gen_all_paths starts from (1,1).", "\n", "assert_equal", "(", "len", "(", "list", "(", "gen_all_paths", "(", "5", ",", "7", ")", ")", ")", ",", "delannoy_num", "(", "5", "-", "1", ",", "7", "-", "1", ")", ")", "\n", "assert_equal", "(", "len", "(", "list", "(", "gen_all_paths", "(", "8", ",", "6", ")", ")", ")", ",", "delannoy_num", "(", "8", "-", "1", ",", "6", "-", "1", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw._softmax": [[20, 23], ["numpy.max", "numpy.log", "numpy.exp().sum", "numpy.exp"], "function", ["None"], ["def", "_softmax", "(", "z", ")", ":", "\n", "    ", "max_val", "=", "np", ".", "max", "(", "z", ")", "\n", "return", "max_val", "+", "np", ".", "log", "(", "np", ".", "exp", "(", "z", "-", "max_val", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw._softmin": [[25, 28], ["numpy.array", "test_soft_dtw._softmax"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw._softmax"], ["", "def", "_softmin", "(", "z", ",", "gamma", ")", ":", "\n", "    ", "z", "=", "np", ".", "array", "(", "z", ")", "\n", "return", "-", "gamma", "*", "_softmax", "(", "-", "z", "/", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw._soft_dtw_bf": [[30, 33], ["test_soft_dtw._softmin", "numpy.sum", "sdtw.path.gen_all_paths"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw._softmin", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.path.gen_all_paths"], ["", "def", "_soft_dtw_bf", "(", "D", ",", "gamma", ")", ":", "\n", "    ", "costs", "=", "[", "np", ".", "sum", "(", "A", "*", "D", ")", "for", "A", "in", "gen_all_paths", "(", "D", ".", "shape", "[", "0", "]", ",", "D", ".", "shape", "[", "1", "]", ")", "]", "\n", "return", "_softmin", "(", "costs", ",", "gamma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw.test_soft_dtw": [[35, 39], ["sklearn.utils.testing.assert_almost_equal", "sdtw.SoftDTW().compute", "test_soft_dtw._soft_dtw_bf", "sdtw.SoftDTW"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute", "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw._soft_dtw_bf"], ["", "def", "test_soft_dtw", "(", ")", ":", "\n", "    ", "for", "gamma", "in", "(", "0.001", ",", "0.01", ",", "0.1", ",", "1", ",", "10", ",", "100", ",", "1000", ")", ":", "\n", "        ", "assert_almost_equal", "(", "SoftDTW", "(", "D", ",", "gamma", ")", ".", "compute", "(", ")", ",", "\n", "_soft_dtw_bf", "(", "D", ",", "gamma", "=", "gamma", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw.test_soft_dtw_grad": [[40, 54], ["sdtw.SoftDTW", "sdtw.SoftDTW.compute", "sdtw.SoftDTW.grad", "test_soft_dtw.test_soft_dtw_grad.make_func"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.grad"], ["", "", "def", "test_soft_dtw_grad", "(", ")", ":", "\n", "    ", "def", "make_func", "(", "gamma", ")", ":", "\n", "        ", "def", "func", "(", "d", ")", ":", "\n", "            ", "D_", "=", "d", ".", "reshape", "(", "*", "D", ".", "shape", ")", "\n", "return", "SoftDTW", "(", "D_", ",", "gamma", ")", ".", "compute", "(", ")", "\n", "", "return", "func", "\n", "\n", "", "for", "gamma", "in", "(", "0.001", ",", "0.01", ",", "0.1", ",", "1", ",", "10", ",", "100", ",", "1000", ")", ":", "\n", "        ", "sdtw", "=", "SoftDTW", "(", "D", ",", "gamma", ")", "\n", "sdtw", ".", "compute", "(", ")", "\n", "E", "=", "sdtw", ".", "grad", "(", ")", "\n", "func", "=", "make_func", "(", "gamma", ")", "\n", "E_num", "=", "approx_fprime", "(", "D", ".", "ravel", "(", ")", ",", "func", ",", "1e-6", ")", ".", "reshape", "(", "*", "E", ".", "shape", ")", "\n", "assert_array_almost_equal", "(", "E", ",", "E_num", ",", "5", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_soft_dtw.test_soft_dtw_grad_X": [[56, 74], ["sdtw.distance.SquaredEuclidean", "sdtw.SoftDTW", "sdtw.SoftDTW.compute", "sdtw.SoftDTW.grad", "sdtw.distance.SquaredEuclidean.jacobian_product", "test_soft_dtw.test_soft_dtw_grad.make_func"], "function", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.compute", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.soft_dtw.SoftDTW.grad", "home.repos.pwc.inspect_result.mblondel_soft-dtw.sdtw.distance.SquaredEuclidean.jacobian_product"], ["", "", "def", "test_soft_dtw_grad_X", "(", ")", ":", "\n", "    ", "def", "make_func", "(", "gamma", ")", ":", "\n", "        ", "def", "func", "(", "x", ")", ":", "\n", "            ", "X_", "=", "x", ".", "reshape", "(", "*", "X", ".", "shape", ")", "\n", "D_", "=", "SquaredEuclidean", "(", "X_", ",", "Y", ")", "\n", "return", "SoftDTW", "(", "D_", ",", "gamma", ")", ".", "compute", "(", ")", "\n", "", "return", "func", "\n", "\n", "", "for", "gamma", "in", "(", "0.001", ",", "0.01", ",", "0.1", ",", "1", ",", "10", ",", "100", ",", "1000", ")", ":", "\n", "        ", "dist", "=", "SquaredEuclidean", "(", "X", ",", "Y", ")", "\n", "sdtw", "=", "SoftDTW", "(", "dist", ",", "gamma", ")", "\n", "sdtw", ".", "compute", "(", ")", "\n", "E", "=", "sdtw", ".", "grad", "(", ")", "\n", "G", "=", "dist", ".", "jacobian_product", "(", "E", ")", "\n", "\n", "func", "=", "make_func", "(", "gamma", ")", "\n", "G_num", "=", "approx_fprime", "(", "X", ".", "ravel", "(", ")", ",", "func", ",", "1e-6", ")", ".", "reshape", "(", "*", "G", ".", "shape", ")", "\n", "assert_array_almost_equal", "(", "G", ",", "G_num", ",", "5", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_chainer_func._func": [[9, 13], ["z.reshape", "sdtw.chainer_func.SoftDTWLoss"], "function", ["None"], ["def", "_func", "(", "z", ",", "X", ")", ":", "\n", "    ", "shape", "=", "(", "-", "1", ",", "X", ".", "shape", "[", "1", "]", ")", "\n", "Z", "=", "z", ".", "reshape", "(", "*", "shape", ")", "\n", "return", "SoftDTWLoss", "(", "gamma", "=", "0.1", ")", "(", "Z", ",", "X", ")", ".", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_chainer_func._grad": [[15, 22], ["z.reshape", "chainer.Variable", "loss.backward", "chainer.Variable.grad.ravel", "sdtw.chainer_func.SoftDTWLoss"], "function", ["None"], ["", "def", "_grad", "(", "z", ",", "X", ")", ":", "\n", "    ", "shape", "=", "(", "-", "1", ",", "X", ".", "shape", "[", "1", "]", ")", "\n", "Z", "=", "z", ".", "reshape", "(", "*", "shape", ")", "\n", "Z", "=", "Variable", "(", "Z", ")", "\n", "loss", "=", "SoftDTWLoss", "(", "gamma", "=", "0.1", ")", "(", "Z", ",", "X", ")", "\n", "loss", ".", "backward", "(", "retain_grad", "=", "True", ")", "\n", "return", "Z", ".", "grad", ".", "ravel", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.tests.test_chainer_func.test_grad": [[24, 29], ["numpy.random.RandomState", "np.random.RandomState.randn", "np.random.RandomState.randn", "print", "scipy.optimize.check_grad", "rng.randn.ravel"], "function", ["None"], ["", "def", "test_grad", "(", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "0", ")", "\n", "X", "=", "rng", ".", "randn", "(", "10", ",", "2", ")", "\n", "Z", "=", "rng", ".", "randn", "(", "8", ",", "2", ")", "\n", "print", "(", "check_grad", "(", "_func", ",", "_grad", ",", "Z", ".", "ravel", "(", ")", ",", "X", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.MLP.__init__": [[35, 41], ["chainer.Chain.__init__", "chainer.Linear", "chainer.Linear", "chainer.Linear", "chainer.Linear"], "methods", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.Objective.__init__"], ["    ", "def", "__init__", "(", "self", ",", "len_input", ",", "len_output", ",", "activation", "=", "\"tanh\"", ",", "n_units", "=", "50", ")", ":", "\n", "        ", "self", ".", "activation", "=", "activation", "\n", "\n", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", "\n", "mid", "=", "L", ".", "Linear", "(", "len_input", ",", "n_units", ")", ",", "\n", "out", "=", "L", ".", "Linear", "(", "n_units", ",", "len_output", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.MLP.__call__": [[43, 50], ["plot_chainer_MLP.MLP.mid", "getattr", "getattr.", "plot_chainer_MLP.MLP.out"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ")", ":", "\n", "# Given the current observation, predict the rest.", "\n", "        ", "xx", "=", "self", ".", "mid", "(", "x", ")", "\n", "func", "=", "getattr", "(", "F", ",", "self", ".", "activation", ")", "\n", "h", "=", "func", "(", "xx", ")", "\n", "y", "=", "self", ".", "out", "(", "h", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.Objective.__init__": [[54, 58], ["chainer.Chain.__init__"], "methods", ["home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.Objective.__init__"], ["    ", "def", "__init__", "(", "self", ",", "predictor", ",", "loss", "=", "\"euclidean\"", ",", "gamma", "=", "1.0", ")", ":", "\n", "        ", "self", ".", "loss", "=", "loss", "\n", "self", ".", "gamma", "=", "gamma", "\n", "super", "(", "Objective", ",", "self", ")", ".", "__init__", "(", "predictor", "=", "predictor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.Objective.__call__": [[59, 75], ["plot_chainer_MLP.Objective.predictor", "chainer.mean_squared_error", "chainer.mean_squared_error", "range", "ValueError", "chainer.reshape", "chainer.reshape", "chainer.reshape", "chainer.reshape", "sdtw.chainer_func.SoftDTWLoss"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "y", "=", "self", ".", "predictor", "(", "x", ")", "\n", "\n", "if", "self", ".", "loss", "==", "\"euclidean\"", ":", "\n", "            ", "return", "F", ".", "mean_squared_error", "(", "y", ",", "t", ")", "\n", "\n", "", "elif", "self", ".", "loss", "==", "\"sdtw\"", ":", "\n", "            ", "loss", "=", "0", "\n", "for", "i", "in", "range", "(", "y", ".", "shape", "[", "0", "]", ")", ":", "\n", "                ", "y_i", "=", "F", ".", "reshape", "(", "y", "[", "i", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "t_i", "=", "F", ".", "reshape", "(", "t", "[", "i", "]", ",", "(", "-", "1", ",", "1", ")", ")", "\n", "loss", "+=", "SoftDTWLoss", "(", "self", ".", "gamma", ")", "(", "y_i", ",", "t_i", ")", "\n", "", "return", "loss", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "\"Unknown loss\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.split_time_series": [[22, 31], ["int", "round", "numpy.float32", "numpy.float32", "numpy.float32", "numpy.float32"], "function", ["None"], ["def", "split_time_series", "(", "X_tr", ",", "X_te", ",", "proportion", "=", "0.6", ")", ":", "\n", "    ", "len_ts", "=", "X_tr", ".", "shape", "[", "1", "]", "\n", "len_input", "=", "int", "(", "round", "(", "len_ts", "*", "proportion", ")", ")", "\n", "len_output", "=", "len_ts", "-", "len_input", "\n", "\n", "return", "np", ".", "float32", "(", "X_tr", "[", ":", ",", ":", "len_input", ",", "0", "]", ")", ",", "np", ".", "float32", "(", "X_tr", "[", ":", ",", "len_input", ":", ",", "0", "]", ")", ",", "np", ".", "float32", "(", "X_te", "[", ":", ",", ":", "len_input", ",", "0", "]", ")", ",", "np", ".", "float32", "(", "X_te", "[", ":", ",", "len_input", ":", ",", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mblondel_soft-dtw.examples.plot_chainer_MLP.train": [[77, 94], ["plot_chainer_MLP.Objective", "chainer.optimizers.Adam", "optimizers.Adam.setup", "chainer.datasets.tuple_dataset.TupleDataset", "chainer.datasets.tuple_dataset.TupleDataset", "chainer.iterators.SerialIterator", "chainer.iterators.SerialIterator", "chainer.training.StandardUpdater", "chainer.training.Trainer", "training.Trainer.run"], "function", ["None"], ["", "", "", "def", "train", "(", "network", ",", "loss", ",", "X_tr", ",", "Y_tr", ",", "X_te", ",", "Y_te", ",", "n_epochs", "=", "30", ",", "gamma", "=", "1", ")", ":", "\n", "    ", "model", "=", "Objective", "(", "network", ",", "loss", "=", "loss", ",", "gamma", "=", "gamma", ")", "\n", "\n", "#optimizer = optimizers.SGD()", "\n", "optimizer", "=", "optimizers", ".", "Adam", "(", ")", "\n", "optimizer", ".", "setup", "(", "model", ")", "\n", "\n", "train", "=", "tuple_dataset", ".", "TupleDataset", "(", "X_tr", ",", "Y_tr", ")", "\n", "test", "=", "tuple_dataset", ".", "TupleDataset", "(", "X_te", ",", "Y_te", ")", "\n", "\n", "train_iter", "=", "iterators", ".", "SerialIterator", "(", "train", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ")", "\n", "test_iter", "=", "iterators", ".", "SerialIterator", "(", "test", ",", "batch_size", "=", "1", ",", "repeat", "=", "False", ",", "\n", "shuffle", "=", "False", ")", "\n", "updater", "=", "training", ".", "StandardUpdater", "(", "train_iter", ",", "optimizer", ")", "\n", "trainer", "=", "training", ".", "Trainer", "(", "updater", ",", "(", "n_epochs", ",", "'epoch'", ")", ")", "\n", "\n", "trainer", ".", "run", "(", ")", "\n", "\n"]]}