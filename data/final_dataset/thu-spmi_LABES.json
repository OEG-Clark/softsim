{"home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology.__init__": [[4, 10], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ontology_path", ")", ":", "\n", "        ", "self", ".", "ontology_path", "=", "ontology_path", "\n", "self", ".", "informable_slots_dict", "=", "{", "}", "\n", "self", ".", "eos_syntax", "=", "{", "'resp'", ":", "'<eos_r>'", ",", "'user'", ":", "'<eos_u>'", ",", "'resp_gen'", ":", "'<eos_r>'", "}", "\n", "self", ".", "special_tokens", "=", "[", "'<pad>'", ",", "'<go_r>'", ",", "'<unk>'", ",", "'<eos_u>'", ",", "'<eos_r>'", ",", "'<eos_b>'", ",", "\n", "'<eos_as>'", ",", "'<eos_av>'", ",", "'<go_as>'", ",", "'<go_av>'", "]", "#0-9", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._get_z_eos_map": [[11, 16], ["enumerate"], "methods", ["None"], ["", "def", "_get_z_eos_map", "(", "self", ",", "informable_slots", ")", ":", "\n", "        ", "z_eos_map", "=", "{", "}", "\n", "for", "idx", ",", "slot", "in", "enumerate", "(", "informable_slots", ")", ":", "\n", "            ", "z_eos_map", "[", "slot", "]", "=", "'<eos_b%d>'", "%", "(", "idx", "+", "1", ")", "\n", "", "return", "z_eos_map", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._slots_flatten": [[17, 23], ["slots_dict.items", "flat_slots.append"], "methods", ["None"], ["", "def", "_slots_flatten", "(", "self", ",", "slots_dict", ")", ":", "\n", "        ", "flat_slots", "=", "[", "]", "\n", "for", "domain", ",", "slots", "in", "slots_dict", ".", "items", "(", ")", ":", "\n", "            ", "for", "slot", "in", "slots", ":", "\n", "                ", "flat_slots", ".", "append", "(", "'%s-%s'", "%", "(", "domain", ",", "slot", ")", ")", "\n", "", "", "return", "flat_slots", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._get_slot_name_set": [[24, 31], ["s.split", "unique_list.append"], "methods", ["None"], ["", "def", "_get_slot_name_set", "(", "flat_slot_list", ")", ":", "\n", "        ", "unique_list", "=", "[", "]", "\n", "for", "s", "in", "flat_slot_list", ":", "\n", "            ", "s", "=", "s", ".", "split", "(", "'-'", ")", "[", "1", "]", "\n", "if", "s", "not", "in", "unique_list", ":", "\n", "                ", "unique_list", ".", "append", "(", "s", ")", "\n", "", "", "return", "unique_list", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology.covert_mask_words_to_idx": [[32, 39], ["ontologies.Ontology.slot_value_mask.items", "slot_value_mask_idx[].append", "vocab.encode"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode"], ["", "def", "covert_mask_words_to_idx", "(", "self", ",", "vocab", ")", ":", "\n", "        ", "slot_value_mask_idx", "=", "{", "}", "\n", "for", "s", ",", "values", "in", "self", ".", "slot_value_mask", ".", "items", "(", ")", ":", "\n", "            ", "slot_value_mask_idx", "[", "s", "]", "=", "[", "]", "\n", "for", "v", "in", "values", ":", "\n", "                ", "slot_value_mask_idx", "[", "s", "]", ".", "append", "(", "vocab", ".", "encode", "(", "v", ")", ")", "\n", "", "", "return", "slot_value_mask_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.CamRest676Ontology.__init__": [[42, 53], ["ontologies.Ontology.__init__", "ontologies.CamRest676Ontology._slots_flatten", "ontologies.CamRest676Ontology._get_z_eos_map", "ontologies.CamRest676Ontology._get_ontology_index_mask", "ontologies.CamRest676Ontology.special_tokens.extend", "ontologies.CamRest676Ontology.special_tokens.extend", "ontologies.CamRest676Ontology.special_tokens.extend", "list", "ontologies.CamRest676Ontology.z_eos_map.values"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._slots_flatten", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._get_z_eos_map", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.CamRest676Ontology._get_ontology_index_mask"], ["    ", "def", "__init__", "(", "self", ",", "ontology_path", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "ontology_path", ")", "\n", "self", ".", "informable_slots_dict", "=", "{", "'restaurant'", ":", "[", "'food'", ",", "'pricerange'", ",", "'area'", "]", "}", "\n", "# self.informable_slots_dict = {'restaurant': ['food', 'area', 'pricerange']}", "\n", "self", ".", "informable_slots", "=", "self", ".", "_slots_flatten", "(", "self", ".", "informable_slots_dict", ")", "\n", "self", ".", "requestable_slots", "=", "[", "'address'", ",", "'name'", ",", "'phone'", ",", "'postcode'", ",", "'food'", ",", "'area'", ",", "'pricerange'", "]", "\n", "self", ".", "z_eos_map", "=", "self", ".", "_get_z_eos_map", "(", "self", ".", "informable_slots", ")", "\n", "self", ".", "slot_value_mask", "=", "self", ".", "_get_ontology_index_mask", "(", "self", ".", "ontology_path", ")", "\n", "self", ".", "special_tokens", ".", "extend", "(", "list", "(", "self", ".", "z_eos_map", ".", "values", "(", ")", ")", ")", "\n", "self", ".", "special_tokens", ".", "extend", "(", "[", "'[value_%s]'", "%", "w", "for", "w", "in", "self", ".", "requestable_slots", "]", ")", "\n", "self", ".", "special_tokens", ".", "extend", "(", "[", "'food'", ",", "'price'", ",", "'area'", ",", "'dontcare'", "]", ")", "\n", "# print(self.informable_slots )", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.CamRest676Ontology._get_ontology_index_mask": [[58, 81], ["json.loads", "raw_entities[].items", "open().read().lower", "set", "list", "v.split", "open().read", "entity_idx[].add", "open"], "methods", ["None"], ["", "def", "_get_ontology_index_mask", "(", "self", ",", "ontology_path", ")", ":", "\n", "# Return the indexes of all words in the values of each slots", "\n", "# To be used as probability masks  while decoding z", "\n", "        ", "entity_idx", "=", "{", "}", "\n", "raw_entities", "=", "json", ".", "loads", "(", "open", "(", "ontology_path", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "for", "slot", ",", "values", "in", "raw_entities", "[", "'informable'", "]", ".", "items", "(", ")", ":", "\n", "            ", "slot", "=", "'restaurant-'", "+", "slot", "\n", "entity_idx", "[", "slot", "]", "=", "set", "(", "[", "'<pad>'", ",", "'dontcare'", ",", "self", ".", "z_eos_map", "[", "slot", "]", "]", ")", "\n", "for", "v", "in", "values", ":", "\n", "                ", "w_list", "=", "v", ".", "split", "(", ")", "\n", "for", "w", "in", "w_list", ":", "\n", "                    ", "entity_idx", "[", "slot", "]", ".", "add", "(", "w", ")", "\n", "# if 'the' in entity_idx[slot]:", "\n", "#     print('delete the')", "\n", "#     entity_idx[slot].discard('the')", "\n", "# #     entity_idx[slot].add('restrauant')", "\n", "# #     entity_idx[slot].add('toward')", "\n", "# if 'moderate' in entity_idx[slot]:", "\n", "#     print('add moderately')", "\n", "#     entity_idx[slot].add('moderately')", "\n", "# entity_idx[slot].discard('dontcare')", "\n", "", "", "entity_idx", "[", "slot", "]", "=", "list", "(", "entity_idx", "[", "slot", "]", ")", "\n", "", "return", "entity_idx", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.KvretOntology.__init__": [[84, 113], ["ontologies.Ontology.__init__", "ontologies.KvretOntology._slots_flatten", "ontologies.KvretOntology._slots_flatten", "ontologies.KvretOntology._get_z_eos_map", "ontologies.KvretOntology.special_tokens.extend", "ontologies.KvretOntology.special_tokens.extend", "list", "d_s.split", "d_s.split", "ontologies.KvretOntology.z_eos_map.values", "ontologies.KvretOntology.special_tokens.append", "ontologies.KvretOntology.special_tokens.append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._slots_flatten", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._slots_flatten", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._get_z_eos_map"], ["    ", "def", "__init__", "(", "self", ",", "ontology_path", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "ontology_path", ")", "\n", "self", ".", "all_domains", "=", "[", "'weather'", ",", "'navigate'", ",", "'schedule'", "]", "\n", "self", ".", "informable_slots_dict", "=", "{", "\n", "'weather'", ":", "[", "'date'", ",", "'location'", ",", "'weather_attribute'", "]", ",", "\n", "'navigate'", ":", "[", "'poi_type'", ",", "'distance'", "]", ",", "\n", "'schedule'", ":", "[", "'event'", ",", "'date'", ",", "'time'", ",", "'agenda'", ",", "'party'", ",", "'room'", "]", "\n", "}", "\n", "# self.informable_slots_dict = {'restaurant': ['food', 'area', 'pricerange']}", "\n", "self", ".", "informable_slots", "=", "self", ".", "_slots_flatten", "(", "self", ".", "informable_slots_dict", ")", "\n", "self", ".", "requestable_slots_dict", "=", "{", "\n", "'weather'", ":", "[", "'weather_attribute'", "]", ",", "\n", "'navigate'", ":", "[", "'poi'", ",", "'traffic_info'", ",", "'address'", ",", "'distance'", "]", ",", "\n", "'schedule'", ":", "[", "'event'", ",", "'date'", ",", "'time'", ",", "'party'", ",", "'agenda'", ",", "'room'", "]", "\n", "}", "\n", "self", ".", "requestable_slots", "=", "self", ".", "_slots_flatten", "(", "self", ".", "requestable_slots_dict", ")", "\n", "self", ".", "z_eos_map", "=", "self", ".", "_get_z_eos_map", "(", "self", ".", "informable_slots", ")", "\n", "# self.slot_value_mask = self._get_ontology_index_mask(self.ontology_path)", "\n", "\n", "self", ".", "special_tokens", ".", "extend", "(", "list", "(", "self", ".", "z_eos_map", ".", "values", "(", ")", ")", ")", "\n", "for", "d_s", "in", "self", ".", "requestable_slots", ":", "\n", "            ", "d", ",", "s", "=", "d_s", ".", "split", "(", "'-'", ")", "\n", "if", "'[value_%s]'", "%", "s", "not", "in", "self", ".", "special_tokens", ":", "\n", "                ", "self", ".", "special_tokens", ".", "append", "(", "'[value_%s]'", "%", "s", ")", "\n", "", "", "for", "d_s", "in", "self", ".", "informable_slots", ":", "\n", "            ", "d", ",", "s", "=", "d_s", ".", "split", "(", "'-'", ")", "\n", "if", "s", "not", "in", "self", ".", "special_tokens", ":", "\n", "                ", "self", ".", "special_tokens", ".", "append", "(", "s", ")", "\n", "", "", "self", ".", "special_tokens", ".", "extend", "(", "[", "'dontcare'", "]", ")", "\n", "# print(self.informable_slots )", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.MultiwozOntology.__init__": [[119, 175], ["ontologies.Ontology.__init__", "ontologies.MultiwozOntology._slots_flatten", "ontologies.MultiwozOntology._slots_flatten", "ontologies.MultiwozOntology._get_z_eos_map", "ontologies.MultiwozOntology.special_tokens.extend", "ontologies.MultiwozOntology.special_tokens.extend", "list", "d_s.split", "d_s.split", "ontologies.MultiwozOntology.z_eos_map.values", "ontologies.MultiwozOntology.special_tokens.append", "ontologies.MultiwozOntology.special_tokens.append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._slots_flatten", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._slots_flatten", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology._get_z_eos_map"], ["    ", "def", "__init__", "(", "self", ",", "ontology_path", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "ontology_path", ")", "\n", "self", ".", "all_domains", "=", "[", "'restaurant'", ",", "'hotel'", ",", "'attraction'", ",", "'train'", ",", "'taxi'", ",", "'police'", ",", "'hospital'", "]", "\n", "self", ".", "db_domains", "=", "[", "'restaurant'", ",", "'hotel'", ",", "'attraction'", ",", "'train'", ",", "'hospital'", "]", "\n", "self", ".", "slot_normlize", "=", "{", "\n", "\"car type\"", ":", "\"car\"", ",", "\n", "\"entrance fee\"", ":", "\"price\"", ",", "\n", "\"leaveat\"", ":", "'leave'", ",", "\n", "'arriveby'", ":", "'arrive'", ",", "\n", "'trainid'", ":", "'id'", ",", "\n", "'addr'", ":", "\"address\"", ",", "\n", "'post'", ":", "\"postcode\"", ",", "\n", "'ref'", ":", "'reference'", ",", "\n", "'fee'", ":", "\"price\"", ",", "\n", "'ticket'", ":", "'price'", ",", "\n", "'price range'", ":", "'pricerange'", ",", "\n", "'price'", ":", "'pricerange'", ",", "\n", "'depart'", ":", "\"departure\"", ",", "\n", "'dest'", ":", "\"destination\"", ",", "\n", "}", "\n", "self", ".", "informable_slots_dict", "=", "{", "\n", "\"restaurant\"", ":", "[", "\"food\"", ",", "\"pricerange\"", ",", "\"area\"", ",", "\"name\"", ",", "\"time\"", ",", "\"day\"", ",", "\"people\"", "]", ",", "\n", "\"hotel\"", ":", "[", "\"type\"", ",", "\"parking\"", ",", "\"pricerange\"", ",", "\"internet\"", ",", "\"stay\"", ",", "\"day\"", ",", "\"people\"", ",", "\"area\"", ",", "\"stars\"", ",", "\"name\"", "]", ",", "\n", "\"attraction\"", ":", "[", "\"area\"", ",", "\"type\"", ",", "\"name\"", "]", ",", "\n", "\"train\"", ":", "[", "\"destination\"", ",", "\"day\"", ",", "\"arrive\"", ",", "\"departure\"", ",", "\"people\"", ",", "\"leave\"", "]", ",", "\n", "\"taxi\"", ":", "[", "\"leave\"", ",", "\"destination\"", ",", "\"departure\"", ",", "\"arrive\"", "]", ",", "\n", "\"police\"", ":", "[", "]", ",", "\n", "\"hospital\"", ":", "[", "\"department\"", "]", ",", "\n", "}", "\n", "self", ".", "informable_slots", "=", "self", ".", "_slots_flatten", "(", "self", ".", "informable_slots_dict", ")", "\n", "self", ".", "requestable_slots_dict", "=", "{", "\n", "\"restaurant\"", ":", "[", "\"phone\"", ",", "\"postcode\"", ",", "\"address\"", ",", "\"pricerange\"", ",", "\"food\"", ",", "\"area\"", ",", "\"reference\"", "]", ",", "\n", "\"hotel\"", ":", "[", "\"address\"", ",", "\"postcode\"", ",", "\"internet\"", ",", "\"phone\"", ",", "\"parking\"", ",", "\"type\"", ",", "\"pricerange\"", ",", "\"stars\"", ",", "\"area\"", ",", "\"reference\"", "]", ",", "\n", "\"attraction\"", ":", "[", "\"price\"", ",", "\"type\"", ",", "\"address\"", ",", "\"postcode\"", ",", "\"phone\"", ",", "\"area\"", ",", "\"reference\"", "]", ",", "\n", "\"train\"", ":", "[", "\"duration\"", ",", "\"leave\"", ",", "\"price\"", ",", "\"arrive\"", ",", "\"id\"", ",", "\"reference\"", "]", ",", "\n", "\"taxi\"", ":", "[", "\"car\"", ",", "\"phone\"", "]", ",", "\n", "\"police\"", ":", "[", "\"postcode\"", ",", "\"address\"", ",", "\"phone\"", "]", ",", "\n", "\"hospital\"", ":", "[", "\"address\"", ",", "\"phone\"", ",", "\"postcode\"", "]", "\n", "}", "\n", "self", ".", "requestable_slots", "=", "self", ".", "_slots_flatten", "(", "self", ".", "requestable_slots_dict", ")", "\n", "self", ".", "z_eos_map", "=", "self", ".", "_get_z_eos_map", "(", "self", ".", "informable_slots", ")", "\n", "# self.slot_value_mask = self._get_ontology_index_mask(self.ontology_path)", "\n", "# print(self.informable_slots )", "\n", "# print(self.z_eos_map)", "\n", "# print(self.slot_value_mask)", "\n", "\n", "self", ".", "special_tokens", ".", "extend", "(", "list", "(", "self", ".", "z_eos_map", ".", "values", "(", ")", ")", ")", "\n", "for", "d_s", "in", "self", ".", "requestable_slots", ":", "\n", "            ", "d", ",", "s", "=", "d_s", ".", "split", "(", "'-'", ")", "\n", "if", "'[value_%s]'", "%", "s", "not", "in", "self", ".", "special_tokens", ":", "\n", "                ", "self", ".", "special_tokens", ".", "append", "(", "'[value_%s]'", "%", "s", ")", "\n", "", "", "for", "d_s", "in", "self", ".", "informable_slots", ":", "\n", "            ", "d", ",", "s", "=", "d_s", ".", "split", "(", "'-'", ")", "\n", "if", "s", "not", "in", "self", ".", "special_tokens", ":", "\n", "                ", "self", ".", "special_tokens", ".", "append", "(", "s", ")", "\n", "", "", "self", ".", "special_tokens", ".", "extend", "(", "[", "'dontcare'", "]", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PriorDecoder_Pz.__init__": [[17, 37], ["torch.nn.Module.__init__", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "modules.Attn", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed_size", ",", "hidden_size", ",", "vocab_size", ",", "dropout_rate", ",", "enable_selc_read", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "state_size", "=", "hidden_size", "+", "embed_size", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "enable_selc_read", "=", "enable_selc_read", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", "+", "hidden_size", ",", "hidden_size", ",", "dropout", "=", "dropout_rate", ",", "\n", "batch_first", "=", "True", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "\n", "# weights", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "self", ".", "Win", "=", "nn", ".", "Linear", "(", "embed_size", "+", "hidden_size", "*", "2", ",", "embed_size", ")", "\n", "", "self", ".", "Wctx", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "2", ",", "hidden_size", ")", "\n", "# self.Wst = nn.Linear(self.state_size, hidden_size)", "\n", "self", ".", "Wgen", "=", "nn", ".", "Linear", "(", "self", ".", "state_size", ",", "vocab_size", ")", "# generate mode", "\n", "self", ".", "Wcp_u", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "self", ".", "Wcp_pz", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "\n", "self", ".", "attn", "=", "Attn", "(", "hidden_size", ")", "\n", "# self.mu = nn.Linear(vocab_size, embed_size, bias=False)", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PriorDecoder_Pz.forward": [[39, 107], ["u_input_1hot.size", "u_input.size", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PriorDecoder_Pz.dropout", "copy_modules.PriorDecoder_Pz.gru", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PriorDecoder_Pz.Wgen().squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "copy_modules.PriorDecoder_Pz.Win", "copy_modules.PriorDecoder_Pz.attn", "copy_modules.PriorDecoder_Pz.attn", "copy_modules.PriorDecoder_Pz.dropout", "copy_modules.PriorDecoder_Pz.Wcp_u", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "modules.cuda_", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "copy_modules.get_selective_read", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PriorDecoder_Pz.Wgen", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "copy_modules.PriorDecoder_Pz.Wcp_pz", "copy_modules.get_selective_read", "copy_modules.PriorDecoder_Pz.transpose", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "u_input.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "prob_c_u.unsqueeze", "copy_modules.PriorDecoder_Pz.transpose", "prob_c_u.unsqueeze", "prob_c_pz.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read"], ["", "def", "forward", "(", "self", ",", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "pv_z_prob", ",", "pv_z_hidden", ",", "pv_z_idx", ",", "\n", "emb_zt", ",", "last_hidden", ",", "selc_read_u", "=", "None", ",", "selc_read_pv_z", "=", "None", ")", ":", "\n", "        ", "\"\"\"[summary]\n        :param u_input: [B,Tu]\n        :param u_input_1hot: [B,Tu,V]\n        :param u_hiddens: [B,Tu,H]\n        :param pv_pz_prob: [B,Tz,V]\n        :param pv_z_hidden: [B,Tz,H]\n        :param emb_zt: [B,1,He]\n        :param selc_read_u: [B,1,H]\n        :param selc_read_pv_z: [B,1,H]\n        :param last_hidden: [1,B,H]\n        \"\"\"", "\n", "V", "=", "u_input_1hot", ".", "size", "(", "2", ")", "\n", "Tu", "=", "u_input", ".", "size", "(", "1", ")", "\n", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "t_input", "=", "self", ".", "Win", "(", "torch", ".", "cat", "(", "[", "emb_zt", ",", "selc_read_u", ",", "selc_read_pv_z", "]", ",", "dim", "=", "2", ")", ")", "# [B,1,H]", "\n", "", "else", ":", "\n", "            ", "t_input", "=", "emb_zt", "\n", "\n", "", "if", "pv_z_hidden", "is", "not", "None", ":", "\n", "            ", "context", "=", "self", ".", "attn", "(", "last_hidden", ",", "torch", ".", "cat", "(", "[", "u_hiddens", ",", "pv_z_hidden", "]", ",", "dim", "=", "1", ")", ")", "\n", "", "else", ":", "\n", "            ", "context", "=", "self", ".", "attn", "(", "last_hidden", ",", "u_hiddens", ")", "\n", "", "gru_input", "=", "torch", ".", "cat", "(", "[", "t_input", ",", "context", "]", ",", "dim", "=", "2", ")", "\n", "gru_input", "=", "self", ".", "dropout", "(", "gru_input", ")", "\n", "\n", "gru_out", ",", "last_hidden", "=", "self", ".", "gru", "(", "gru_input", ",", "last_hidden", ")", "# gru_out: [B,1,H]", "\n", "\n", "st", "=", "torch", ".", "cat", "(", "[", "gru_out", ",", "t_input", "]", ",", "dim", "=", "2", ")", "# depends more on slot name", "\n", "if", "cfg", ".", "dropout_st", ":", "\n", "            ", "st", "=", "self", ".", "dropout", "(", "st", ")", "\n", "", "score_g", "=", "self", ".", "Wgen", "(", "st", ")", ".", "squeeze", "(", "1", ")", "# [B,V]", "\n", "\n", "score_c_u", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_u", "(", "u_hiddens", ")", ")", "# [B,Tu,H]", "\n", "score_c_u", "=", "torch", ".", "bmm", "(", "score_c_u", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tu]", "\n", "\n", "if", "pv_z_prob", "is", "None", ":", "\n", "# copy from only user input", "\n", "            ", "score", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_u", "]", ",", "1", ")", "# [B, V+Tu]", "\n", "probs", "=", "F", ".", "softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_u", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_u_to_g", "\n", "selc_read_pz", "=", "cuda_", "(", "torch", ".", "zeros", "(", "u_input", ".", "size", "(", "0", ")", ",", "1", ",", "self", ".", "hidden_size", ")", ")", "\n", "", "else", ":", "\n", "# copy from only user input and previous z decoded", "\n", "            ", "score_c_pz", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_pz", "(", "pv_z_hidden", ")", ")", "# [B,Tz,H]", "\n", "score_c_pz", "=", "torch", ".", "bmm", "(", "score_c_pz", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tz]", "\n", "score", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_u", ",", "score_c_pz", "]", ",", "1", ")", "# [B, V+Tu+Tz]", "\n", "probs", "=", "F", ".", "softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_u", ",", "prob_c_pz", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_pz_to_g", "=", "torch", ".", "bmm", "(", "prob_c_pz", ".", "unsqueeze", "(", "1", ")", ",", "pv_z_prob", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_pz_to_g", "# [B,V]", "\n", "\n", "# compute selcive read from pv_z for the next step", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "                ", "selc_read_pz", "=", "get_selective_read", "(", "pv_z_idx", ",", "zt", ",", "pv_z_hidden", ",", "prob_c_pz", ")", "\n", "\n", "# compute selcive read from u and m for the next step", "\n", "", "", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "selc_read_u", "=", "get_selective_read", "(", "u_input", ",", "zt", ",", "u_hiddens", ",", "prob_c_u", ")", "\n", "", "else", ":", "\n", "            ", "selc_read_u", ",", "selc_read_pz", "=", "None", ",", "None", "\n", "\n", "", "return", "prob_out", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_pz", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PosteriorDecoder_Qz.__init__": [[110, 131], ["torch.nn.Module.__init__", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "modules.Attn", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed_size", ",", "hidden_size", ",", "vocab_size", ",", "dropout_rate", ",", "\n", "enable_selc_read", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "state_size", "=", "embed_size", "+", "hidden_size", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "enable_selc_read", "=", "enable_selc_read", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", "+", "hidden_size", ",", "hidden_size", ",", "dropout", "=", "dropout_rate", ",", "\n", "batch_first", "=", "True", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "\n", "# weights", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "self", ".", "Win", "=", "nn", ".", "Linear", "(", "embed_size", "+", "hidden_size", "*", "3", ",", "embed_size", ")", "\n", "# self.Wst = nn.Linear(self.state_size, hidden_size)", "\n", "", "self", ".", "Wgen", "=", "nn", ".", "Linear", "(", "self", ".", "state_size", ",", "vocab_size", ")", "# generate mode", "\n", "self", ".", "Wcp_u", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "self", ".", "Wcp_m", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "self", ".", "Wcp_pz", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "\n", "self", ".", "attn", "=", "Attn", "(", "hidden_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PosteriorDecoder_Qz.forward": [[132, 232], ["u_input_1hot.size", "copy_modules.PosteriorDecoder_Qz.attn", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qz.dropout", "copy_modules.PosteriorDecoder_Qz.gru", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qz.Wgen().squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "u_input.size", "m_input.size", "copy_modules.PosteriorDecoder_Qz.Win", "hiddens.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qz.dropout", "copy_modules.PosteriorDecoder_Qz.Wcp_u", "copy_modules.PosteriorDecoder_Qz.Wcp_m", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "modules.cuda_", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "copy_modules.get_selective_read", "copy_modules.get_selective_read", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qz.Wgen", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "copy_modules.PosteriorDecoder_Qz.Wcp_pz", "copy_modules.get_selective_read", "modules.gumbel_softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "modules.gumbel_softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "modules.ST_gumbel_softmax_sample", "copy_modules.PosteriorDecoder_Qz.transpose", "copy_modules.PosteriorDecoder_Qz.transpose", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "u_input.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "prob_c_u.unsqueeze", "prob_c_m.unsqueeze", "copy_modules.PosteriorDecoder_Qz.transpose", "prob_c_u.unsqueeze", "prob_c_m.unsqueeze", "prob_c_pz.unsqueeze", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "prob_c_u.unsqueeze", "prob_c_m.unsqueeze", "prob_c_u.unsqueeze", "prob_c_m.unsqueeze", "prob_c_pz.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.gumbel_softmax", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.gumbel_softmax", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.ST_gumbel_softmax_sample"], ["", "def", "forward", "(", "self", ",", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "m_input", ",", "m_input_1hot", ",", "m_hiddens", ",", "\n", "pv_z_prob", ",", "pv_z_hidden", ",", "pv_z_idx", ",", "emb_zt", ",", "last_hidden", ",", "selc_read_u", "=", "None", ",", "\n", "selc_read_m", "=", "None", ",", "selc_read_pv_z", "=", "None", ",", "temp", "=", "0.1", ",", "return_gmb", "=", "False", ")", ":", "\n", "        ", "\"\"\"[summary]\n        :param u_input: [B,Tu]\n        :param u_input_1hot: [B,Tu,V]\n        :param u_hiddens: [B,Tu,H]\n        :param m_input: [B,Tm]\n        :param m_input_1hot: [B,Tm,V]\n        :param m_hiddens: [B,Tm,H]\n        :param pv_pz_prob: [B,Tz,V]\n        :param pv_z_hidden: [B,Tz,H]\n        :param emb_zt: [B,1,H]\n        :param selc_read_u: [B,1,H]\n        :param selc_read_pv_z: [B,1,H]\n        :param last_hidden: [1,B,H]\n        :param temp: gumbel softmax temperature\n        :param return_gmb: return gumbel softmax samples\n        \"\"\"", "\n", "V", "=", "u_input_1hot", ".", "size", "(", "2", ")", "\n", "Tu", ",", "Tm", "=", "u_input", ".", "size", "(", "1", ")", ",", "m_input", ".", "size", "(", "1", ")", "\n", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "t_input", "=", "self", ".", "Win", "(", "torch", ".", "cat", "(", "[", "emb_zt", ",", "selc_read_u", ",", "selc_read_m", ",", "selc_read_pv_z", "]", ",", "dim", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "t_input", "=", "emb_zt", "# [B,1,H]", "\n", "\n", "", "hiddens", "=", "[", "u_hiddens", ",", "m_hiddens", "]", "\n", "if", "pv_z_hidden", "is", "not", "None", ":", "hiddens", ".", "append", "(", "pv_z_hidden", ")", "\n", "context", "=", "self", ".", "attn", "(", "last_hidden", ",", "torch", ".", "cat", "(", "hiddens", ",", "dim", "=", "1", ")", ")", "\n", "gru_input", "=", "torch", ".", "cat", "(", "[", "t_input", ",", "context", "]", ",", "dim", "=", "2", ")", "\n", "gru_input", "=", "self", ".", "dropout", "(", "gru_input", ")", "\n", "gru_out", ",", "last_hidden", "=", "self", ".", "gru", "(", "gru_input", ",", "last_hidden", ")", "# gru_out: [B,1,H]", "\n", "st", "=", "torch", ".", "cat", "(", "[", "gru_out", ",", "t_input", "]", ",", "dim", "=", "2", ")", "\n", "if", "cfg", ".", "dropout_st", ":", "st", "=", "self", ".", "dropout", "(", "st", ")", "\n", "\n", "score_g", "=", "self", ".", "Wgen", "(", "st", ")", ".", "squeeze", "(", "1", ")", "# [B,V]", "\n", "score_c_u", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_u", "(", "u_hiddens", ")", ")", "# [B,Tu,H]", "\n", "score_c_u", "=", "torch", ".", "bmm", "(", "score_c_u", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tu]", "\n", "score_c_m", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_m", "(", "m_hiddens", ")", ")", "# [B,Tu,H]", "\n", "score_c_m", "=", "torch", ".", "bmm", "(", "score_c_m", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tu]", "\n", "\n", "if", "pv_z_prob", "is", "None", ":", "\n", "# copy from only user input and system response", "\n", "            ", "score_no_pv", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_u", ",", "score_c_m", "]", ",", "1", ")", "# [B, V+Tu+Tm]", "\n", "probs", "=", "F", ".", "softmax", "(", "score_no_pv", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_u", ",", "prob_c_m", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_m_to_g", "=", "torch", ".", "bmm", "(", "prob_c_m", ".", "unsqueeze", "(", "1", ")", ",", "m_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_m_to_g", "\n", "selc_read_pz", "=", "cuda_", "(", "torch", ".", "zeros", "(", "u_input", ".", "size", "(", "0", ")", ",", "1", ",", "self", ".", "hidden_size", ")", ")", "\n", "", "else", ":", "\n", "# copy from only user input, system response and previous z decoded", "\n", "            ", "score_c_pz", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_pz", "(", "pv_z_hidden", ")", ")", "# [B,Tz,H]", "\n", "score_c_pz", "=", "torch", ".", "bmm", "(", "score_c_pz", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tz]", "\n", "score_has_pv", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_u", ",", "score_c_m", ",", "score_c_pz", "]", ",", "1", ")", "# [B, V+Tu+Tz]", "\n", "probs", "=", "F", ".", "softmax", "(", "score_has_pv", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_u", ",", "prob_c_m", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", ":", "V", "+", "Tu", "+", "Tm", "]", "\n", "prob_c_pz", "=", "probs", "[", ":", ",", "V", "+", "Tu", "+", "Tm", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_m_to_g", "=", "torch", ".", "bmm", "(", "prob_c_m", ".", "unsqueeze", "(", "1", ")", ",", "m_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_pz_to_g", "=", "torch", ".", "bmm", "(", "prob_c_pz", ".", "unsqueeze", "(", "1", ")", ",", "pv_z_prob", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_m_to_g", "+", "prob_c_pz_to_g", "# [B,V]", "\n", "# compute selcive read from pv_z for the next step", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "                ", "selc_read_pz", "=", "get_selective_read", "(", "pv_z_idx", ",", "zt", ",", "pv_z_hidden", ",", "prob_c_pz", ")", "\n", "\n", "# compute selcive read from u and m for the next step", "\n", "", "", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "selc_read_u", "=", "get_selective_read", "(", "u_input", ",", "zt", ",", "u_hiddens", ",", "prob_c_u", ")", "\n", "selc_read_m", "=", "get_selective_read", "(", "m_input", ",", "zt", ",", "m_hiddens", ",", "prob_c_m", ")", "\n", "", "else", ":", "\n", "            ", "selc_read_u", ",", "selc_read_m", ",", "selc_read_pz", "=", "None", ",", "None", ",", "None", "\n", "\n", "", "if", "not", "return_gmb", ":", "\n", "            ", "return", "prob_out", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_m", ",", "selc_read_pz", ",", "None", "\n", "", "else", ":", "\n", "            ", "if", "pv_z_prob", "is", "None", ":", "\n", "# copy from only user input and system response", "\n", "                ", "probs", "=", "gumbel_softmax", "(", "score_no_pv", ",", "temp", ")", "# [B, V+Tu+Tm]", "\n", "prob_g", ",", "prob_c_u", ",", "prob_c_m", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_m_to_g", "=", "torch", ".", "bmm", "(", "prob_c_m", ".", "unsqueeze", "(", "1", ")", ",", "m_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out_gumbel", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_m_to_g", "\n", "", "else", ":", "\n", "# copy from only user input, system response and previous z decoded", "\n", "                ", "probs", "=", "gumbel_softmax", "(", "score_has_pv", ",", "temp", ")", "\n", "prob_g", ",", "prob_c_u", ",", "prob_c_m", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", ":", "V", "+", "Tu", "+", "Tm", "]", "\n", "prob_c_pz", "=", "probs", "[", ":", ",", "V", "+", "Tu", "+", "Tm", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_m_to_g", "=", "torch", ".", "bmm", "(", "prob_c_m", ".", "unsqueeze", "(", "1", ")", ",", "m_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_pz_to_g", "=", "torch", ".", "bmm", "(", "prob_c_pz", ".", "unsqueeze", "(", "1", ")", ",", "pv_z_prob", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out_gumbel", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_m_to_g", "+", "prob_c_pz_to_g", "# [B,V]", "\n", "", "if", "cfg", ".", "sample_type", "==", "'ST_gumbel'", ":", "\n", "                ", "z_sample", "=", "ST_gumbel_softmax_sample", "(", "prob_out_gumbel", ")", "\n", "", "elif", "cfg", ".", "sample_type", "==", "'gumbel'", ":", "\n", "                ", "z_sample", "=", "prob_out_gumbel", "\n", "", "else", ":", "\n", "                ", "z_sample", "=", "None", "\n", "", "return", "prob_out", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_m", ",", "selc_read_pz", ",", "z_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PriorDecoder_Pa.__init__": [[236, 249], ["torch.nn.Module.__init__", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "modules.Attn"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed_size", ",", "hidden_size", ",", "vocab_size", ",", "db_vec_size", ",", "slot_num", ",", "\n", "dropout_rate", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "state_size", "=", "2", "*", "hidden_size", "+", "db_vec_size", "+", "slot_num", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", "+", "hidden_size", "+", "db_vec_size", "+", "slot_num", ",", "\n", "hidden_size", ",", "dropout", "=", "dropout_rate", ",", "batch_first", "=", "True", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "\n", "# weights", "\n", "self", ".", "Wgen", "=", "nn", ".", "Linear", "(", "self", ".", "state_size", ",", "vocab_size", ")", "# generate mode", "\n", "self", ".", "attn", "=", "Attn", "(", "hidden_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PriorDecoder_Pa.forward": [[250, 270], ["copy_modules.PriorDecoder_Pa.attn", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PriorDecoder_Pa.dropout", "copy_modules.PriorDecoder_Pa.gru", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PriorDecoder_Pa.Wgen().squeeze", "torch.softmax", "torch.softmax", "copy_modules.PriorDecoder_Pa.dropout", "vec_input.unsqueeze", "vec_input.unsqueeze", "copy_modules.PriorDecoder_Pa.Wgen"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "u_hiddens", ",", "emb_at", ",", "vec_input", ",", "last_hidden", ")", ":", "\n", "        ", "\"\"\"[summary]\n        :param u_input: [B,Tu]\n        :param u_input_1hot: [B,Tu,V]\n        :param u_hiddens: [B,Tu,H]\n        :param emb_at: [B,1,He]\n        :param last_hidden: [1,B,H]\n        \"\"\"", "\n", "\n", "context", "=", "self", ".", "attn", "(", "last_hidden", ",", "u_hiddens", ")", "\n", "gru_input", "=", "torch", ".", "cat", "(", "[", "emb_at", ",", "context", ",", "vec_input", ".", "unsqueeze", "(", "1", ")", "]", ",", "dim", "=", "2", ")", "\n", "gru_input", "=", "self", ".", "dropout", "(", "gru_input", ")", "\n", "gru_out", ",", "last_hidden", "=", "self", ".", "gru", "(", "gru_input", ",", "last_hidden", ")", "# gru_out: [B,1,H]", "\n", "st", "=", "torch", ".", "cat", "(", "[", "gru_out", ",", "context", ",", "vec_input", ".", "unsqueeze", "(", "1", ")", "]", ",", "dim", "=", "2", ")", "\n", "if", "cfg", ".", "dropout_st", ":", "\n", "            ", "st", "=", "self", ".", "dropout", "(", "st", ")", "\n", "", "score", "=", "self", ".", "Wgen", "(", "st", ")", ".", "squeeze", "(", "1", ")", "# [B,V]", "\n", "prob_out", "=", "F", ".", "softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "\n", "return", "prob_out", ",", "last_hidden", ",", "gru_out", "#, selc_read_z", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PosteriorDecoder_Qa.__init__": [[274, 295], ["torch.nn.Module.__init__", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "modules.Attn", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed_size", ",", "hidden_size", ",", "vocab_size", ",", "db_vec_size", ",", "\n", "slot_num", ",", "dropout_rate", ",", "enable_selc_read", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "state_size", "=", "2", "*", "hidden_size", "+", "db_vec_size", "+", "slot_num", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "enable_selc_read", "=", "enable_selc_read", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", "+", "hidden_size", "+", "db_vec_size", "+", "slot_num", ",", "hidden_size", ",", "dropout", "=", "dropout_rate", ",", "\n", "batch_first", "=", "True", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "\n", "# weights", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "self", ".", "Win", "=", "nn", ".", "Linear", "(", "embed_size", "+", "hidden_size", "*", "3", ",", "embed_size", ")", "\n", "# self.Wst = nn.Linear(self.state_size, hidden_size)", "\n", "", "self", ".", "Wgen", "=", "nn", ".", "Linear", "(", "self", ".", "state_size", ",", "vocab_size", ")", "# generate mode", "\n", "self", ".", "Wcp_m", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "# self.Wcp_z = nn.Linear(hidden_size, self.state_size) # copy mode", "\n", "\n", "# self.attn_z = Attn(hidden_size)", "\n", "self", ".", "attn", "=", "Attn", "(", "hidden_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.PosteriorDecoder_Qa.forward": [[296, 348], ["m_input_1hot.size", "copy_modules.PosteriorDecoder_Qa.attn", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qa.dropout", "copy_modules.PosteriorDecoder_Qa.gru", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qa.Wgen().squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "copy_modules.PosteriorDecoder_Qa.Win", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.PosteriorDecoder_Qa.dropout", "copy_modules.PosteriorDecoder_Qa.Wcp_m", "copy_modules.get_selective_read", "modules.gumbel_softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "vec_input.unsqueeze", "vec_input.unsqueeze", "copy_modules.PosteriorDecoder_Qa.Wgen", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "modules.ST_gumbel_softmax_sample", "copy_modules.PosteriorDecoder_Qa.transpose", "prob_c_m.unsqueeze", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "prob_c_m.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.gumbel_softmax", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.ST_gumbel_softmax_sample"], ["", "def", "forward", "(", "self", ",", "u_hiddens", ",", "m_input", ",", "m_input_1hot", ",", "m_hiddens", ",", "\n", "emb_at", ",", "vec_input", ",", "last_hidden", ",", "selc_read_m", "=", "None", ",", "\n", "temp", "=", "0.1", ",", "return_gmb", "=", "False", ")", ":", "\n", "        ", "V", "=", "m_input_1hot", ".", "size", "(", "2", ")", "\n", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "t_input", "=", "self", ".", "Win", "(", "torch", ".", "cat", "(", "[", "emb_at", ",", "selc_read_u", ",", "selc_read_m", "]", ",", "dim", "=", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "t_input", "=", "emb_at", "# [B,1,H]", "\n", "\n", "", "context", "=", "self", ".", "attn", "(", "last_hidden", ",", "torch", ".", "cat", "(", "[", "u_hiddens", ",", "m_hiddens", "]", ",", "dim", "=", "1", ")", ")", "\n", "gru_input", "=", "torch", ".", "cat", "(", "[", "t_input", ",", "context", ",", "vec_input", ".", "unsqueeze", "(", "1", ")", "]", ",", "dim", "=", "2", ")", "\n", "gru_input", "=", "self", ".", "dropout", "(", "gru_input", ")", "\n", "\n", "gru_out", ",", "last_hidden", "=", "self", ".", "gru", "(", "gru_input", ",", "last_hidden", ")", "# gru_out: [B,1,H]", "\n", "st", "=", "torch", ".", "cat", "(", "[", "gru_out", ",", "context", ",", "vec_input", ".", "unsqueeze", "(", "1", ")", "]", ",", "dim", "=", "2", ")", "\n", "if", "cfg", ".", "dropout_st", ":", "\n", "            ", "st", "=", "self", ".", "dropout", "(", "st", ")", "\n", "\n", "", "score_g", "=", "self", ".", "Wgen", "(", "st", ")", ".", "squeeze", "(", "1", ")", "# [B,V]", "\n", "score_c_m", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_m", "(", "m_hiddens", ")", ")", "# [B,Tu,H]", "\n", "score_c_m", "=", "torch", ".", "bmm", "(", "score_c_m", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tu]", "\n", "\n", "# copy from only user input and system response", "\n", "score", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_m", "]", ",", "1", ")", "# [B, V+Tu+Tm]", "\n", "probs", "=", "F", ".", "softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_m", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "]", "\n", "prob_c_m_to_g", "=", "torch", ".", "bmm", "(", "prob_c_m", ".", "unsqueeze", "(", "1", ")", ",", "m_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_m_to_g", "\n", "\n", "# compute selcive read from u and m for the next step", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "selc_read_m", "=", "get_selective_read", "(", "m_input", ",", "zt", ",", "m_hiddens", ",", "prob_c_m", ")", "\n", "", "else", ":", "\n", "            ", "selc_read_m", "=", "None", "\n", "\n", "", "if", "not", "return_gmb", ":", "\n", "            ", "return", "prob_out", ",", "last_hidden", ",", "gru_out", ",", "selc_read_m", ",", "None", "\n", "", "else", ":", "\n", "# copy from only user input and system response", "\n", "            ", "probs", "=", "gumbel_softmax", "(", "score", ",", "temp", ")", "# [B, V+Tu+Tm]", "\n", "prob_g", ",", "prob_c_m", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "]", "\n", "prob_c_m_to_g", "=", "torch", ".", "bmm", "(", "prob_c_m", ".", "unsqueeze", "(", "1", ")", ",", "m_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out_gumbel", "=", "prob_g", "+", "prob_c_m_to_g", "\n", "\n", "if", "cfg", ".", "sample_type", "==", "'ST_gumbel'", ":", "\n", "                ", "z_sample", "=", "ST_gumbel_softmax_sample", "(", "prob_out_gumbel", ")", "\n", "", "elif", "cfg", ".", "sample_type", "==", "'gumbel'", ":", "\n", "                ", "z_sample", "=", "prob_out_gumbel", "\n", "", "else", ":", "\n", "                ", "z_sample", "=", "None", "\n", "", "return", "prob_out", ",", "last_hidden", ",", "gru_out", ",", "selc_read_m", ",", "z_sample", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.ResponseDecoder_Pm.__init__": [[351, 379], ["torch.nn.Module.__init__", "torch.nn.GRU", "torch.nn.GRU", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "modules.Attn", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embed", ",", "embed_size", ",", "hidden_size", ",", "vocab_size", ",", "db_vec_size", ",", "dropout_rate", ",", "\n", "enable_selc_read", "=", "False", ",", "model_act", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embed", "=", "embed", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "model_act", "=", "model_act", "\n", "self", ".", "state_size", "=", "hidden_size", "*", "2", "+", "db_vec_size", "\n", "self", ".", "enable_selc_read", "=", "enable_selc_read", "\n", "self", ".", "dropout_rate", "=", "dropout_rate", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", "+", "hidden_size", "+", "db_vec_size", ",", "hidden_size", ",", "\n", "dropout", "=", "dropout_rate", ",", "batch_first", "=", "True", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "\n", "# weights", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "input_size", "=", "embed_size", "+", "hidden_size", "*", "2", "\n", "if", "self", ".", "model_act", ":", "\n", "                ", "input_size", "+=", "hidden_size", "\n", "", "self", ".", "Win", "=", "nn", ".", "Linear", "(", "input_size", ",", "hidden_size", ")", "\n", "# self.Wctx = nn.Linear(hidden_size*2, hidden_size)", "\n", "# self.Wst = nn.Linear(self.state_size, hidden_size)", "\n", "", "self", ".", "Wgen", "=", "nn", ".", "Linear", "(", "self", ".", "state_size", ",", "vocab_size", ")", "# generate mode", "\n", "self", ".", "Wcp_u", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "self", ".", "Wcp_z", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "self", ".", "Wcp_a", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "self", ".", "state_size", ")", "# copy mode", "\n", "\n", "", "self", ".", "attn", "=", "Attn", "(", "hidden_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.ResponseDecoder_Pm.forward": [[380, 459], ["u_input_1hot.size", "u_input.size", "db_vec.unsqueeze.unsqueeze.unsqueeze", "copy_modules.ResponseDecoder_Pm.attn", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.ResponseDecoder_Pm.gru", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.ResponseDecoder_Pm.Wgen().squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.ResponseDecoder_Pm.Win", "copy_modules.ResponseDecoder_Pm.embed", "hiddens.append", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.ResponseDecoder_Pm.dropout", "copy_modules.ResponseDecoder_Pm.dropout", "copy_modules.ResponseDecoder_Pm.Wcp_u", "copy_modules.ResponseDecoder_Pm.Wcp_z", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "z_input.size", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "copy_modules.get_selective_read", "copy_modules.get_selective_read", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "copy_modules.ResponseDecoder_Pm.Wgen", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "copy_modules.ResponseDecoder_Pm.Wcp_a", "copy_modules.get_selective_read", "copy_modules.ResponseDecoder_Pm.embed", "copy_modules.ResponseDecoder_Pm.transpose", "copy_modules.ResponseDecoder_Pm.transpose", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "prob_c_u.unsqueeze", "prob_c_z.unsqueeze", "copy_modules.ResponseDecoder_Pm.transpose", "prob_c_u.unsqueeze", "prob_c_z.unsqueeze", "prob_c_a.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read"], ["", "def", "forward", "(", "self", ",", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "z_input", ",", "pz_prob", ",", "z_hiddens", ",", "mt", ",", "\n", "db_vec", ",", "last_hidden", ",", "a_input", "=", "None", ",", "pa_prob", "=", "None", ",", "a_hiddens", "=", "None", ",", "\n", "selc_read_u", "=", "None", ",", "selc_read_z", "=", "None", ",", "selc_read_a", "=", "None", ")", ":", "\n", "        ", "\"\"\"[summary]\n        :param u_input: [B,Tu]\n        :param u_input_1hot: [B,Tu,V]\n        :param u_hiddens: [B,Tu,H]\n        :param z_input: [B, Tz]\n        :param pz_prob: [B,Tz,V]\n        :param z_hiddens: [B,Tz,H]\n        :param mt: [B]\n        :param selc_read_u: [B,1,H]\n        :param selc_read_z: [B,1,H]\n        :param db_vec: [B, db_vec_size]\n        :param last_hidden: [1,B,H]\n        \"\"\"", "\n", "V", "=", "u_input_1hot", ".", "size", "(", "2", ")", "\n", "Tu", "=", "u_input", ".", "size", "(", "1", ")", "\n", "db_vec", "=", "db_vec", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "t_input", "=", "torch", ".", "cat", "(", "[", "self", ".", "embed", "(", "mt", ")", ",", "selc_read_u", ",", "selc_read_z", "]", ",", "dim", "=", "2", ")", "\n", "if", "self", ".", "model_act", ":", "\n", "                ", "t_input", "=", "torch", ".", "cat", "(", "[", "t_input", ",", "selc_read_a", "]", ",", "dim", "=", "2", ")", "\n", "", "t_input", "=", "self", ".", "Win", "(", "t_input", ")", "\n", "", "else", ":", "\n", "            ", "t_input", "=", "self", ".", "embed", "(", "mt", ")", "# [B,1,H]", "\n", "\n", "", "hiddens", "=", "[", "u_hiddens", ",", "z_hiddens", "]", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "hiddens", ".", "append", "(", "a_hiddens", ")", "\n", "", "context", "=", "self", ".", "attn", "(", "last_hidden", ",", "torch", ".", "cat", "(", "hiddens", ",", "dim", "=", "1", ")", ")", "\n", "gru_input", "=", "torch", ".", "cat", "(", "[", "t_input", ",", "context", ",", "db_vec", "]", ",", "dim", "=", "2", ")", "\n", "if", "cfg", ".", "use_resp_dpout", ":", "\n", "            ", "gru_input", "=", "self", ".", "dropout", "(", "gru_input", ")", "\n", "\n", "", "gru_out", ",", "last_hidden", "=", "self", ".", "gru", "(", "gru_input", ",", "last_hidden", ")", "\n", "\n", "st", "=", "torch", ".", "cat", "(", "[", "gru_out", ",", "context", ",", "db_vec", "]", ",", "dim", "=", "2", ")", "\n", "if", "cfg", ".", "dropout_st", "and", "cfg", ".", "use_resp_dpout", ":", "\n", "            ", "st", "=", "self", ".", "dropout", "(", "st", ")", "\n", "", "score_g", "=", "self", ".", "Wgen", "(", "st", ")", ".", "squeeze", "(", "1", ")", "# [B,V]", "\n", "# score_g = self.Wgen(gru_out).squeeze(1)     # [B,V]", "\n", "\n", "# copy from user input and z decoded", "\n", "score_c_u", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_u", "(", "u_hiddens", ")", ")", "# [B,Tu,H]", "\n", "score_c_u", "=", "torch", ".", "bmm", "(", "score_c_u", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tu]", "\n", "score_c_z", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_z", "(", "z_hiddens", ")", ")", "# [B,Tz,H]", "\n", "score_c_z", "=", "torch", ".", "bmm", "(", "score_c_z", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tz]", "\n", "if", "not", "self", ".", "model_act", ":", "\n", "            ", "score", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_u", ",", "score_c_z", "]", ",", "1", ")", "# [B, V+Tu+Tz]", "\n", "probs", "=", "F", ".", "softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_u", ",", "prob_c_z", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_z_to_g", "=", "torch", ".", "bmm", "(", "prob_c_z", ".", "unsqueeze", "(", "1", ")", ",", "pz_prob", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_z_to_g", "# [B,V]", "\n", "", "else", ":", "\n", "            ", "Tz", "=", "z_input", ".", "size", "(", "1", ")", "\n", "score_c_a", "=", "torch", ".", "tanh", "(", "self", ".", "Wcp_a", "(", "a_hiddens", ")", ")", "# [B,Tu,H]", "\n", "score_c_a", "=", "torch", ".", "bmm", "(", "score_c_a", ",", "st", ".", "transpose", "(", "1", ",", "2", ")", ")", ".", "squeeze", "(", "2", ")", "# [B,Tu]", "\n", "score", "=", "torch", ".", "cat", "(", "[", "score_g", ",", "score_c_u", ",", "score_c_z", ",", "score_c_a", "]", ",", "1", ")", "# [B, V+Tu+Tz]", "\n", "probs", "=", "F", ".", "softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "prob_g", ",", "prob_c_u", "=", "probs", "[", ":", ",", ":", "V", "]", ",", "probs", "[", ":", ",", "V", ":", "V", "+", "Tu", "]", "\n", "prob_c_z", ",", "prob_c_a", "=", "probs", "[", ":", ",", "V", "+", "Tu", ":", "V", "+", "Tu", "+", "Tz", "]", ",", "probs", "[", ":", ",", "V", "+", "Tu", "+", "Tz", ":", "]", "\n", "prob_c_u_to_g", "=", "torch", ".", "bmm", "(", "prob_c_u", ".", "unsqueeze", "(", "1", ")", ",", "u_input_1hot", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_z_to_g", "=", "torch", ".", "bmm", "(", "prob_c_z", ".", "unsqueeze", "(", "1", ")", ",", "pz_prob", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_c_a_to_g", "=", "torch", ".", "bmm", "(", "prob_c_a", ".", "unsqueeze", "(", "1", ")", ",", "pa_prob", ")", ".", "squeeze", "(", "1", ")", "\n", "prob_out", "=", "prob_g", "+", "prob_c_u_to_g", "+", "prob_c_z_to_g", "+", "prob_c_a_to_g", "# [B,V]", "\n", "\n", "# compute selcive read from u and z for the next step", "\n", "", "if", "self", ".", "enable_selc_read", ":", "\n", "            ", "selc_read_u", "=", "get_selective_read", "(", "u_input", ",", "mt", ",", "u_hiddens", ",", "prob_c_u", ")", "\n", "selc_read_z", "=", "get_selective_read", "(", "z_input", ",", "mt", ",", "z_hiddens", ",", "prob_c_z", ")", "\n", "if", "self", ".", "model_act", ":", "\n", "                ", "selc_read_a", "=", "get_selective_read", "(", "a_input", ",", "mt", ",", "a_hiddens", ",", "prob_c_a", ")", "\n", "", "", "else", ":", "\n", "            ", "selc_read_u", ",", "selc_read_z", ",", "selc_read_a", "=", "None", ",", "None", ",", "None", "\n", "\n", "", "return", "prob_out", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_z", ",", "selc_read_a", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.DomainClassifier.__init__": [[463, 467], ["torch.nn.Module.__init__", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", ",", "domain_num", ",", "dropout_rate", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout_rate", ")", "\n", "self", ".", "W", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "domain_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.DomainClassifier.forward": [[468, 478], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "copy_modules.DomainClassifier.dropout", "copy_modules.DomainClassifier.W", "torch.log_softmax", "torch.log_softmax"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "u_hiddens", ")", ":", "\n", "        ", "\"\"\"[summary]\n        :param u_hiddens: [B,Tu,H]\n        \"\"\"", "\n", "context", "=", "torch", ".", "mean", "(", "u_hiddens", ",", "dim", "=", "1", ")", "\n", "context", "=", "self", ".", "dropout", "(", "context", ")", "\n", "score", "=", "self", ".", "W", "(", "context", ")", "\n", "log_prob", "=", "F", ".", "log_softmax", "(", "score", ",", "dim", "=", "1", ")", "\n", "\n", "return", "log_prob", "", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.copy_modules.get_selective_read": [[7, 14], ["torch.stack", "torch.stack", "F.softmax.masked_fill_", "torch.softmax", "torch.bmm", "torch.bmm", "torch.stack.float", "F.softmax.unsqueeze", "enumerate"], "function", ["None"], ["def", "get_selective_read", "(", "source", ",", "target", ",", "hiddens", ",", "copy_probs", ")", ":", "\n", "        ", "cp_pos", "=", "torch", ".", "stack", "(", "[", "sb", "==", "target", "[", "b", "]", "for", "b", ",", "sb", "in", "enumerate", "(", "source", ")", "]", ",", "dim", "=", "0", ")", "# [B,T]", "\n", "weight", "=", "copy_probs", "*", "cp_pos", ".", "float", "(", ")", "# [B,Tu]", "\n", "weight", ".", "masked_fill_", "(", "weight", "==", "0", ",", "-", "1e10", ")", "\n", "weight", "=", "F", ".", "softmax", "(", "weight", ",", "dim", "=", "1", ")", "\n", "selective_read", "=", "torch", ".", "bmm", "(", "weight", ".", "unsqueeze", "(", "1", ")", ",", "hiddens", ")", "# [B,1,H]", "\n", "return", "selective_read", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.smc_model.SemiBootstrapSMC.__init__": [[14, 18], ["base_model.BaseModel.__init__", "torch.nn.Softmax"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "has_qnet", "=", "False", ",", "**", "kwargs", ")", "\n", "self", ".", "weight_normalize", "=", "nn", ".", "Softmax", "(", "dim", "=", "0", ")", "\n", "self", ".", "particle_num", "=", "cfg", ".", "particle_num", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.smc_model.SemiBootstrapSMC.forward": [[19, 58], ["smc_model.SemiBootstrapSMC.forward_turn", "torch.cat", "index.update", "smc_model.SemiBootstrapSMC.supervised_loss", "index.update", "smc_model.SemiBootstrapSMC.forward_turn", "torch.cat", "torch.cat", "list", "torch.cat", "losses.update", "smc_model.SemiBootstrapSMC.unsupervised_loss", "smc_model.SemiBootstrapSMC.supervised_loss", "torch.cat.values", "list", "losses.update", "a_input.values"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.forward_turn", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.supervised_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.forward_turn", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.unsupervised_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.supervised_loss"], ["", "def", "forward", "(", "self", ",", "u_input", ",", "m_input", ",", "z_input", ",", "a_input", ",", "turn_states", ",", "z_supervised", ",", "mode", ",", "\n", "db_vec", "=", "None", ",", "filling_vec", "=", "None", ",", "no_label_train", "=", "False", ")", ":", "\n", "        ", "if", "mode", "==", "'train'", "or", "mode", "==", "'loss_eval'", ":", "\n", "            ", "debug", "=", "{", "'true_z'", ":", "z_input", ",", "'true_db'", ":", "db_vec", ",", "'true_a'", ":", "a_input", "}", "\n", "if", "not", "z_supervised", ":", "\n", "                ", "z_input", "=", "None", "\n", "if", "not", "no_label_train", ":", "\n", "                    ", "u_input", "=", "torch", ".", "cat", "(", "[", "u_input", "]", "*", "self", ".", "particle_num", ",", "dim", "=", "0", ")", "\n", "m_input", "=", "torch", ".", "cat", "(", "[", "m_input", "]", "*", "self", ".", "particle_num", ",", "dim", "=", "0", ")", "\n", "", "", "probs", ",", "index", ",", "turn_states", "=", "self", ".", "forward_turn", "(", "u_input", ",", "m_input", "=", "m_input", ",", "z_input", "=", "z_input", ",", "is_train", "=", "True", ",", "\n", "turn_states", "=", "turn_states", ",", "db_vec", "=", "db_vec", ",", "debug", "=", "debug", ",", "mode", "=", "mode", ",", "\n", "a_input", "=", "a_input", ",", "filling_vec", "=", "filling_vec", ",", "no_label_train", "=", "no_label_train", ")", "\n", "if", "z_supervised", ":", "\n", "                ", "z_input", "=", "torch", ".", "cat", "(", "list", "(", "z_input", ".", "values", "(", ")", ")", ",", "dim", "=", "1", ")", "\n", "a_input", "=", "torch", ".", "cat", "(", "list", "(", "a_input", ".", "values", "(", ")", ")", ",", "dim", "=", "1", ")", "if", "cfg", ".", "model_act", "else", "None", "\n", "index", ".", "update", "(", "{", "'z_input'", ":", "z_input", ",", "'a_input'", ":", "a_input", ",", "'m_input'", ":", "m_input", "}", ")", "\n", "loss", ",", "pz_loss", ",", "pa_loss", ",", "m_loss", "=", "self", ".", "supervised_loss", "(", "probs", ",", "index", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'pz_loss'", ":", "pz_loss", ",", "'m_loss'", ":", "m_loss", "}", "\n", "if", "cfg", ".", "model_act", ":", "\n", "                    ", "losses", ".", "update", "(", "{", "'pa_loss'", ":", "pa_loss", "}", ")", "\n", "", "return", "losses", ",", "turn_states", "\n", "", "else", ":", "\n", "                ", "index", ".", "update", "(", "{", "'m_input'", ":", "m_input", "}", ")", "\n", "if", "not", "no_label_train", ":", "\n", "                    ", "loss", ",", "pz_loss", ",", "pa_loss", ",", "m_loss", "=", "self", ".", "unsupervised_loss", "(", "probs", ",", "index", ",", "turn_states", "[", "'norm_W'", "]", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'pz_loss'", ":", "pz_loss", ",", "'m_loss'", ":", "m_loss", "}", "\n", "if", "cfg", ".", "model_act", ":", "\n", "                        ", "losses", ".", "update", "(", "{", "'pa_loss'", ":", "pa_loss", "}", ")", "\n", "", "", "else", ":", "\n", "                    ", "loss", ",", "pz_loss", ",", "pa_loss", ",", "m_loss", "=", "self", ".", "supervised_loss", "(", "probs", ",", "index", ",", "no_label_train", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'m_loss'", ":", "m_loss", "}", "\n", "\n", "", "return", "losses", ",", "turn_states", "\n", "\n", "", "", "elif", "mode", "==", "'test'", ":", "\n", "            ", "index", ",", "db", ",", "turn_states", "=", "self", ".", "forward_turn", "(", "u_input", ",", "is_train", "=", "False", ",", "a_input", "=", "a_input", ",", "\n", "turn_states", "=", "turn_states", ",", "db_vec", "=", "db_vec", ")", "\n", "return", "index", ",", "db", ",", "turn_states", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.smc_model.SemiBootstrapSMC.forward_turn": [[60, 177], ["u_input.size", "smc_model.SemiBootstrapSMC.u_encoder", "modules.get_one_hot_input", "smc_model.SemiBootstrapSMC.decode_z", "smc_model.SemiBootstrapSMC.reader.cons_tensors_to_indicator", "modules.cuda_", "smc_model.SemiBootstrapSMC.db_op.get_db_degree", "modules.cuda_", "torch.from_numpy().float", "smc_model.SemiBootstrapSMC.decode_a", "smc_model.SemiBootstrapSMC.decode_m", "smc_model.SemiBootstrapSMC.beam_search_decode", "log_w.view.view.view", "smc_model.SemiBootstrapSMC.weight_normalize().transpose", "smc_model.SemiBootstrapSMC.max_sampling", "int", "turn_states.get", "torch.from_numpy().float", "smc_model.SemiBootstrapSMC.db_op.get_db_degree", "modules.cuda_", "smc_model.SemiBootstrapSMC.max_sampling", "torch.distributions.Categorical", "torch.distributions.Categorical.sample", "numpy.tile", "torch.from_numpy().float", "torch.from_numpy", "smc_model.SemiBootstrapSMC.weight_normalize", "u_input.size", "torch.cat", "numpy.arange", "torch.from_numpy", "torch.distributions.Categorical.sample.cpu().numpy", "torch.from_numpy", "torch.distributions.Categorical.sample.cpu"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.get_one_hot_input", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_tensors_to_indicator", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_a", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_m", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.beam_search_decode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.max_sampling", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.max_sampling"], ["", "", "def", "forward_turn", "(", "self", ",", "u_input", ",", "turn_states", ",", "is_train", ",", "m_input", "=", "None", ",", "z_input", "=", "None", ",", "\n", "a_input", "=", "None", ",", "db_vec", "=", "None", ",", "filling_vec", "=", "None", ",", "debug", "=", "None", ",", "mode", "=", "None", ",", "\n", "no_label_train", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        compute required outputs for a single dialogue turn. Turn state{Dict} will be updated in each call.\n        :param u_len:\n        :param turn_states:\n        :param is_train:\n        :param u_input: [B,T]\n        :param m_input: [B,T]\n        :param z_input: [B,T]\n        :param: norm_W: [B, K]\n\n        pv_pz_pr: K * [B,T,V]\n        pv_pz_h: K * [B,T,H]\n        :return:\n        \"\"\"", "\n", "batch_size", "=", "u_input", ".", "size", "(", "0", ")", "\n", "u_hiddens", ",", "u_last_hidden", "=", "self", ".", "u_encoder", "(", "u_input", ")", "\n", "u_input_1hot", "=", "get_one_hot_input", "(", "u_input", ",", "self", ".", "vocab_size", ")", "\n", "\n", "\n", "if", "is_train", "and", "z_input", "is", "None", ":", "# unsupervised training", "\n", "            ", "if", "not", "no_label_train", ":", "\n", "                ", "ori_batch_size", "=", "int", "(", "u_input", ".", "size", "(", "0", ")", "/", "self", ".", "particle_num", ")", "\n", "norm_W", "=", "turn_states", ".", "get", "(", "'norm_W'", ",", "None", ")", "\n", "if", "norm_W", "is", "not", "None", "and", "cfg", ".", "resampling", ":", "# Resampling", "\n", "                    ", "dis", "=", "Categorical", "(", "torch", ".", "cat", "(", "[", "norm_W", "]", "*", "self", ".", "particle_num", ",", "dim", "=", "0", ")", ")", "# [B*K, K]", "\n", "Ak", "=", "dis", ".", "sample", "(", ")", "#[B*K]", "\n", "# print('Ak:', Ak.contiguous().view(self.particle_num,-1))", "\n", "bias", "=", "np", ".", "tile", "(", "np", ".", "arange", "(", "0", ",", "ori_batch_size", ")", ",", "self", ".", "particle_num", ")", "\n", "idx", "=", "bias", "+", "Ak", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "*", "ori_batch_size", "\n", "turn_states", "[", "'pv_pz_h'", "]", "=", "turn_states", "[", "'pv_pz_h'", "]", "[", "idx", "]", "# [T, B*K, V]", "\n", "turn_states", "[", "'pv_pz_pr'", "]", "=", "turn_states", "[", "'pv_pz_pr'", "]", "[", "idx", "]", "# [T, B*K, H]", "\n", "turn_states", "[", "'pv_pz_id'", "]", "=", "turn_states", "[", "'pv_pz_id'", "]", "[", "idx", "]", "\n", "\n", "", "", "sample_type", "=", "'topk'", "\n", "", "elif", "is_train", "and", "z_input", "is", "not", "None", "and", "mode", "!=", "'loss_eval'", ":", "# supervised training", "\n", "            ", "sample_type", "=", "'supervised'", "\n", "", "else", ":", "#testing", "\n", "            ", "sample_type", "=", "'top1'", "\n", "\n", "# P(z|pv_z, u)", "\n", "", "pz_prob", ",", "pz_samples", ",", "z_hiddens", ",", "turn_states", ",", "log_pz", "=", "self", ".", "decode_z", "(", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "z_input", ",", "\n", "turn_states", ",", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'pz'", ")", "\n", "\n", "# DB indicator and slot filling indicator", "\n", "if", "cfg", ".", "dataset", "==", "'camrest'", ":", "\n", "            ", "db_vec_np", ",", "match", "=", "self", ".", "db_op", ".", "get_db_degree", "(", "pz_samples", ",", "self", ".", "vocab", ")", "\n", "db_vec", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "db_vec_np", ")", ".", "float", "(", ")", ")", "\n", "", "elif", "cfg", ".", "dataset", "==", "'multiwoz'", ":", "\n", "            ", "db_vec_np", ",", "match", "=", "self", ".", "db_op", ".", "get_db_degree", "(", "pz_samples", ",", "turn_states", "[", "'dom'", "]", ",", "self", ".", "vocab", ")", "\n", "db_vec_new", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "db_vec_np", ")", ".", "float", "(", ")", ")", "\n", "db_vec", "[", ":", ",", ":", "4", "]", "=", "db_vec_new", "\n", "", "else", ":", "\n", "            ", "match", "=", "[", "0", "]", "*", "batch_size", "\n", "", "filling_vec", "=", "self", ".", "reader", ".", "cons_tensors_to_indicator", "(", "pz_samples", ")", "\n", "filling_vec", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "filling_vec", ")", ".", "float", "(", ")", ")", "\n", "\n", "# P(a|u, db, slot_filling_indicator)", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "pa_prob", ",", "pa_samples", ",", "a_hiddens", ",", "log_pa", "=", "self", ".", "decode_a", "(", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "a_input", ",", "\n", "db_vec", ",", "filling_vec", ",", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'pa'", ")", "\n", "", "else", ":", "\n", "            ", "pa_prob", ",", "pa_samples", ",", "a_hiddens", "=", "None", ",", "None", ",", "None", "\n", "\n", "# P(m|u, z, a ,db)", "\n", "", "if", "is_train", "or", "not", "self", ".", "beam_search", ":", "\n", "            ", "pm_prob", ",", "m_idx", ",", "log_pm", "=", "self", ".", "decode_m", "(", "batch_size", ",", "u_last_hidden", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "\n", "pz_samples", ",", "pz_prob", ",", "z_hiddens", ",", "pa_samples", ",", "pa_prob", ",", "a_hiddens", ",", "\n", "db_vec", ",", "m_input", ",", "is_train", "=", "is_train", ")", "\n", "", "else", ":", "\n", "            ", "m_idx", "=", "self", ".", "beam_search_decode", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "pz_samples", ",", "\n", "pz_prob", ",", "z_hiddens", ",", "db_vec", ",", "u_last_hidden", "[", ":", "-", "1", "]", ",", "\n", "pa_samples", ",", "pa_prob", ",", "a_hiddens", ")", "\n", "\n", "# compute normalized weights W for unsupervised training", "\n", "", "if", "is_train", "and", "z_input", "is", "None", "and", "not", "no_label_train", ":", "\n", "            ", "log_w", "=", "log_pm", "\n", "log_w", "=", "log_w", ".", "view", "(", "self", ".", "particle_num", ",", "-", "1", ")", "\n", "norm_W", "=", "self", ".", "weight_normalize", "(", "log_w", ")", ".", "transpose", "(", "1", ",", "0", ")", "#[B,K]", "\n", "turn_states", "[", "'norm_W'", "]", "=", "norm_W", "\n", "\n", "# output", "\n", "", "if", "is_train", ":", "\n", "            ", "probs", "=", "{", "'pz_prob'", ":", "pz_prob", ",", "'pm_prob'", ":", "pm_prob", ",", "'pa_prob'", ":", "pa_prob", "}", "\n", "index", "=", "{", "'z_input'", ":", "pz_samples", ",", "'a_input'", ":", "pa_samples", "}", "\n", "return", "probs", ",", "index", ",", "turn_states", "\n", "", "else", ":", "\n", "            ", "z_idx", "=", "self", ".", "max_sampling", "(", "pz_prob", ")", "\n", "a_idx", "=", "self", ".", "max_sampling", "(", "pa_prob", ")", "if", "self", ".", "model_act", "else", "None", "\n", "index", "=", "{", "'m_idx'", ":", "m_idx", ",", "'z_idx'", ":", "z_idx", ",", "'a_idx'", ":", "a_idx", "}", "\n", "return", "index", ",", "match", ",", "turn_states", "\n", "\n", "# z_gt = debug['true_z']", "\n", "# print('u true:', self.vocab.sentence_decode(u_input[0], eos='<eos_u>'))", "\n", "# print('m true:', self.vocab.sentence_decode(m_input[0], eos='<eos_r>'))", "\n", "# # print('z true:', self.vocab.sentence_decode(z_gt['food'][0]),self.vocab.sentence_decode(z_gt['pricerange'][0]),self.vocab.sentence_decode(z_gt['area'][0]))", "\n", "# print('z samples:')", "\n", "# print(self.vocab.sentence_decode(pz_samples[0]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size*2]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size*3]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size*4]))", "\n", "# if pv_pz_pr is not None:", "\n", "#     print('Ak:', Ak[0].item(), Ak[batch_size].item(), Ak[batch_size*2].item(), Ak[batch_size*3].item(), Ak[batch_size*4].item())", "\n", "# print('W:', norm_W[0])", "\n", "# print(self.vocab.sentence_decode(pz_samples[1]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size+1]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size*2+1]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size*3+1]))", "\n", "# print(self.vocab.sentence_decode(pz_samples[batch_size*4+1]))", "\n", "# print('W:', norm_W[1])", "\n", "", "return", "probs", ",", "index", ",", "turn_states", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.smc_model.SemiBootstrapSMC.supervised_loss": [[179, 195], ["smc_model.SemiBootstrapSMC.nll_loss", "smc_model.SemiBootstrapSMC.nll_loss", "torch.log", "torch.log", "pz_prob.view", "z_input.view", "pm_prob.view", "m_input.view", "torch.log", "smc_model.SemiBootstrapSMC.nll_loss", "torch.zeros", "pz_prob.size", "pm_prob.size", "torch.log.view", "a_input.view", "torch.log.size"], "methods", ["None"], ["", "def", "supervised_loss", "(", "self", ",", "probs", ",", "index", ",", "no_label_train", "=", "False", ")", ":", "\n", "        ", "pz_prob", ",", "pm_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pz_prob'", "]", ")", ",", "torch", ".", "log", "(", "probs", "[", "'pm_prob'", "]", ")", "\n", "z_input", ",", "m_input", "=", "index", "[", "'z_input'", "]", ",", "index", "[", "'m_input'", "]", "\n", "pz_loss", "=", "self", ".", "nll_loss", "(", "pz_prob", ".", "view", "(", "-", "1", ",", "pz_prob", ".", "size", "(", "2", ")", ")", ",", "z_input", ".", "view", "(", "-", "1", ")", ")", "\n", "m_loss", "=", "self", ".", "nll_loss", "(", "pm_prob", ".", "view", "(", "-", "1", ",", "pm_prob", ".", "size", "(", "2", ")", ")", ",", "m_input", ".", "view", "(", "-", "1", ")", ")", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "pa_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pa_prob'", "]", ")", "\n", "a_input", "=", "index", "[", "'a_input'", "]", "\n", "pa_loss", "=", "self", ".", "nll_loss", "(", "pa_prob", ".", "view", "(", "-", "1", ",", "pa_prob", ".", "size", "(", "2", ")", ")", ",", "a_input", ".", "view", "(", "-", "1", ")", ")", "\n", "loss", "=", "cfg", ".", "pz_loss_weight", "*", "pz_loss", "+", "m_loss", "+", "pa_loss", "\n", "", "else", ":", "\n", "            ", "pa_loss", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "loss", "=", "cfg", ".", "pz_loss_weight", "*", "pz_loss", "+", "m_loss", "\n", "", "if", "no_label_train", ":", "\n", "            ", "loss", "=", "m_loss", "\n", "", "return", "loss", ",", "pz_loss", ",", "pa_loss", ",", "m_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.smc_model.SemiBootstrapSMC.unsupervised_loss": [[196, 221], ["smc_model.SemiBootstrapSMC.nll_loss", "smc_model.SemiBootstrapSMC.nll_loss", "torch.log", "torch.log", "torch.clamp", "torch.clamp.transpose().contiguous().view().detach", "pz_prob.view", "z_input.view", "pm_prob.view", "m_input.view", "smc_model.SemiBootstrapSMC.nll_loss", "torch.zeros", "torch.log", "pz_prob.transpose().contiguous", "pm_prob.transpose().contiguous", "pa_prob.transpose().contiguous.transpose().contiguous.transpose().contiguous", "pz_prob.size", "pm_prob.size", "pa_prob.transpose().contiguous.transpose().contiguous.view", "a_input.view", "torch.clamp.transpose().contiguous().view", "pz_prob.transpose", "pm_prob.transpose", "pa_prob.transpose().contiguous.transpose().contiguous.size", "pz_prob.transpose", "pm_prob.transpose", "pa_prob.transpose().contiguous.transpose().contiguous.transpose", "pa_prob.transpose().contiguous.transpose().contiguous.transpose", "torch.clamp.transpose().contiguous", "torch.clamp.transpose"], "methods", ["None"], ["", "def", "unsupervised_loss", "(", "self", ",", "probs", ",", "index", ",", "norm_W", ")", ":", "\n", "# pz_prob: [B*K, T, V]", "\n", "        ", "pz_prob", ",", "pm_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pz_prob'", "]", ")", ",", "torch", ".", "log", "(", "probs", "[", "'pm_prob'", "]", ")", "\n", "z_input", ",", "m_input", "=", "index", "[", "'z_input'", "]", ",", "index", "[", "'m_input'", "]", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "pa_prob", ",", "a_input", "=", "torch", ".", "log", "(", "probs", "[", "'pa_prob'", "]", ")", ",", "index", "[", "'a_input'", "]", "\n", "", "if", "cfg", ".", "weighted_grad", ":", "\n", "            ", "cliped_norm_W", "=", "torch", ".", "clamp", "(", "norm_W", ",", "min", "=", "1e-10", ",", "max", "=", "1", ")", "\n", "W", "=", "cliped_norm_W", ".", "transpose", "(", "1", ",", "0", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ".", "detach", "(", ")", "\n", "pz_prob", "=", "pz_prob", ".", "transpose", "(", "2", ",", "0", ")", "*", "W", "*", "cfg", ".", "particle_num", "\n", "pm_prob", "=", "pm_prob", ".", "transpose", "(", "2", ",", "0", ")", "*", "W", "*", "cfg", ".", "particle_num", "\n", "pz_prob", ",", "pm_prob", "=", "pz_prob", ".", "transpose", "(", "2", ",", "0", ")", ".", "contiguous", "(", ")", ",", "pm_prob", ".", "transpose", "(", "2", ",", "0", ")", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "model_act", ":", "\n", "                ", "pa_prob", "=", "pa_prob", ".", "transpose", "(", "2", ",", "0", ")", "*", "W", "*", "cfg", ".", "particle_num", "\n", "pa_prob", "=", "pa_prob", ".", "transpose", "(", "2", ",", "0", ")", ".", "contiguous", "(", ")", "\n", "\n", "", "", "pz_loss", "=", "self", ".", "nll_loss", "(", "pz_prob", ".", "view", "(", "-", "1", ",", "pz_prob", ".", "size", "(", "2", ")", ")", ",", "z_input", ".", "view", "(", "-", "1", ")", ")", "\n", "m_loss", "=", "self", ".", "nll_loss", "(", "pm_prob", ".", "view", "(", "-", "1", ",", "pm_prob", ".", "size", "(", "2", ")", ")", ",", "m_input", ".", "view", "(", "-", "1", ")", ")", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "pa_loss", "=", "self", ".", "nll_loss", "(", "pa_prob", ".", "view", "(", "-", "1", ",", "pa_prob", ".", "size", "(", "2", ")", ")", ",", "a_input", ".", "view", "(", "-", "1", ")", ")", "\n", "loss", "=", "cfg", ".", "pz_loss_weight", "*", "pz_loss", "+", "m_loss", "+", "pa_loss", "\n", "", "else", ":", "\n", "            ", "pa_loss", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "loss", "=", "cfg", ".", "pz_loss_weight", "*", "pz_loss", "+", "m_loss", "\n", "", "return", "loss", ",", "pz_loss", ",", "pa_loss", ",", "m_loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config.__init__": [[5, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Important hyperparameters\n        \"\"\"", "\n", "# self._multiwoz_init()", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config.init_handler": [[12, 19], ["None"], "methods", ["None"], ["", "def", "init_handler", "(", "self", ",", "m", ")", ":", "\n", "        ", "init_method", "=", "{", "\n", "'camrest'", ":", "self", ".", "_camrest_init", ",", "\n", "'kvret'", ":", "self", ".", "_kvret_init", ",", "\n", "'multiwoz'", ":", "self", ".", "_multiwoz_init", ",", "\n", "}", "\n", "init_method", "[", "m", "]", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config.init_logging_handler": [[20, 42], ["logging.StreamHandler", "logging.getLogger", "logging.getLogger.setLevel", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "logging.FileHandler", "logging.FileHandler", "logging.basicConfig", "os.path.join", "os.path.join", "logging.FileHandler", "logging.basicConfig", "logging.basicConfig"], "methods", ["None"], ["", "def", "init_logging_handler", "(", "self", ",", "mode", ")", ":", "\n", "        ", "stderr_handler", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'./log'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./log'", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'./log/'", "+", "self", ".", "dataset", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./log/'", "+", "self", ".", "dataset", ")", "\n", "\n", "", "if", "self", ".", "save_log", "and", "self", ".", "mode", "==", "'train'", "or", "self", ".", "mode", "==", "'adjust'", ":", "\n", "            ", "file_handler", "=", "logging", ".", "FileHandler", "(", "'./log/{}/log_{}_{}_{}_sd{}.txt'", ".", "format", "(", "self", ".", "dataset", ",", "self", ".", "log_time", ",", "mode", ",", "self", ".", "exp_no", ",", "self", ".", "seed", ")", ")", "\n", "file_handler2", "=", "logging", ".", "FileHandler", "(", "os", ".", "path", ".", "join", "(", "self", ".", "exp_path", ",", "'log_{}_{}.txt'", ".", "format", "(", "self", ".", "mode", ",", "self", ".", "log_time", ")", ")", ")", "\n", "logging", ".", "basicConfig", "(", "handlers", "=", "[", "stderr_handler", ",", "file_handler", ",", "file_handler2", "]", ")", "\n", "\n", "", "elif", "self", ".", "mode", "==", "'test'", ":", "\n", "            ", "eval_log_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "eval_load_path", ",", "'eval_log.json'", ")", "\n", "# if os.path.exists(eval_log_path):", "\n", "#     os.remove(eval_log_path)", "\n", "file_handler", "=", "logging", ".", "FileHandler", "(", "eval_log_path", ")", "\n", "logging", ".", "basicConfig", "(", "handlers", "=", "[", "stderr_handler", ",", "file_handler", "]", ")", "\n", "", "else", ":", "\n", "            ", "logging", ".", "basicConfig", "(", "handlers", "=", "[", "stderr_handler", "]", ")", "\n", "", "logger", "=", "logging", ".", "getLogger", "(", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "INFO", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config._camrest_init": [[44, 131], ["time.strftime", "time.localtime"], "methods", ["None"], ["", "def", "_camrest_init", "(", "self", ")", ":", "\n", "# experimental settings", "\n", "        ", "self", ".", "seed", "=", "0", "\n", "self", ".", "cuda", "=", "True", "\n", "self", ".", "cuda_device", "=", "0", "\n", "self", ".", "split", "=", "(", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "exp_no", "=", "'test'", "\n", "self", ".", "exp_path", "=", "'to be generated'", "\n", "self", ".", "model_path", "=", "'to be generated'", "\n", "self", ".", "result_path", "=", "'to be generated'", "\n", "self", ".", "global_record_path", "=", "'./camrest_results.csv'", "\n", "self", ".", "eval_load_path", "=", "'to be generated'", "\n", "self", ".", "vocab_path", "=", "'./data/CamRest676/vocab'", "\n", "self", ".", "dataset_path", "=", "'./data/CamRest676/'", "\n", "self", ".", "raw_data", "=", "self", ".", "dataset_path", "+", "'CamRest676.json'", "\n", "self", ".", "ontology_path", "=", "self", ".", "dataset_path", "+", "'CamRestOTGY.json'", "\n", "self", ".", "db", "=", "self", ".", "dataset_path", "+", "'CamRestDB.db'", "\n", "self", ".", "glove_path", "=", "'./data/glove/glove.6B.50d.txt'", "\n", "# self.glove_path = './data/paragram_300_sl999_v14294.pkl'", "\n", "self", ".", "save_log", "=", "True", "\n", "self", ".", "log_time", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d-%H-%M-%S\"", ",", "time", ".", "localtime", "(", ")", ")", "\n", "\n", "# trainning settings", "\n", "self", ".", "lr", "=", "0.003", "\n", "self", ".", "lr_decay", "=", "0.5", "\n", "self", ".", "early_stop_count", "=", "4", "\n", "self", ".", "weight_decay_count", "=", "2", "\n", "self", ".", "valid_type", "=", "'loss'", "\n", "self", ".", "batch_size", "=", "32", "\n", "self", ".", "dropout_rate", "=", "0.35", "\n", "self", ".", "max_epoch", "=", "100", "\n", "self", ".", "min_epoch", "=", "0", "\n", "self", ".", "teacher_force", "=", "100", "\n", "self", ".", "spv_proportion", "=", "100", "\n", "self", ".", "no_label_train", "=", "False", "\n", "self", ".", "skip_unsup", "=", "False", "\n", "self", ".", "sup_pretrain", "=", "50", "\n", "self", ".", "mask_ontology", "=", "False", "\n", "self", ".", "parallel_z", "=", "False", "\n", "\n", "# evaluation settings", "\n", "self", ".", "beam_search", "=", "False", "\n", "self", ".", "beam_params", "=", "{", "'size'", ":", "10", ",", "'len_bonus'", ":", "0.5", "}", "\n", "self", ".", "eval_z_method", "=", "'prior'", "\n", "\n", "# model settings", "\n", "self", ".", "vocab_size", "=", "850", "\n", "self", ".", "embed_size", "=", "50", "\n", "self", ".", "hidden_size", "=", "50", "\n", "self", ".", "layer_num", "=", "1", "\n", "self", ".", "db_vec_size", "=", "5", "\n", "self", ".", "z_length", "=", "3", "\n", "self", ".", "a_length", "=", "4", "\n", "self", ".", "u_max_len", "=", "100", "\n", "self", ".", "m_max_len", "=", "40", "\n", "self", ".", "prev_z_continuous", "=", "True", "\n", "self", ".", "m_copy_u", "=", "True", "\n", "self", ".", "multi_domain", "=", "False", "\n", "self", ".", "freeze_emb", "=", "False", "\n", "self", ".", "share_q_encoder", "=", "False", "\n", "self", ".", "model_act", "=", "False", "\n", "self", ".", "share_act_decoder", "=", "True", "\n", "self", ".", "use_act_slot_decoder", "=", "True", "\n", "self", ".", "dropout_st", "=", "True", "\n", "self", ".", "use_resp_dpout", "=", "True", "\n", "self", ".", "glove_init", "=", "True", "\n", "self", ".", "changedp", "=", "True", "\n", "\n", "# SMC params", "\n", "self", ".", "particle_num", "=", "5", "\n", "self", ".", "topk_num", "=", "5", "\n", "self", ".", "resampling", "=", "True", "\n", "self", ".", "weighted_grad", "=", "True", "\n", "self", ".", "pz_loss_weight", "=", "1", "\n", "\n", "# JSA params", "\n", "self", ".", "use_pimh", "=", "False", "\n", "self", ".", "pimh_iter_num", "=", "1", "\n", "if", "not", "self", ".", "use_pimh", ":", "\n", "            ", "self", ".", "pimh_iter_num", "=", "1", "\n", "\n", "# VAE params", "\n", "", "self", ".", "sample_type", "=", "'topk'", "\n", "self", ".", "gumbel_temp", "=", "1.0", "\n", "self", ".", "kl_loss_weight", "=", "0.5", "\n", "\n", "self", ".", "rl_coef", "=", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config._kvret_init": [[133, 219], ["time.strftime", "time.localtime"], "methods", ["None"], ["", "def", "_kvret_init", "(", "self", ")", ":", "\n", "# experimental settings", "\n", "        ", "self", ".", "seed", "=", "0", "\n", "self", ".", "cuda", "=", "True", "\n", "self", ".", "cuda_device", "=", "0", "\n", "self", ".", "exp_no", "=", "'test'", "\n", "self", ".", "exp_path", "=", "'to be generated'", "\n", "self", ".", "model_path", "=", "'to be generated'", "\n", "self", ".", "result_path", "=", "'to be generated'", "\n", "self", ".", "global_record_path", "=", "'./kvret_results.csv'", "\n", "self", ".", "eval_load_path", "=", "'to be generated'", "\n", "self", ".", "vocab_path", "=", "'./data/kvret/vocab'", "\n", "self", ".", "dataset_path", "=", "'./data/kvret/'", "\n", "self", ".", "raw_train_data", "=", "self", ".", "dataset_path", "+", "'kvret_train_public.json'", "\n", "self", ".", "raw_dev_data", "=", "self", ".", "dataset_path", "+", "'kvret_dev_public.json'", "\n", "self", ".", "raw_test_data", "=", "self", ".", "dataset_path", "+", "'kvret_test_public.json'", "\n", "self", ".", "ontology_path", "=", "self", ".", "dataset_path", "+", "'kvret_entities.json'", "\n", "self", ".", "glove_path", "=", "'./data/glove/glove_kvret.6B.50d.txt'", "\n", "# self.glove_path = './data/paragram_300_sl999_v14294.pkl'", "\n", "self", ".", "save_log", "=", "True", "\n", "self", ".", "log_time", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d-%H-%M-%S\"", ",", "time", ".", "localtime", "(", ")", ")", "\n", "\n", "# trainning settings", "\n", "self", ".", "domain", "=", "'all'", "\n", "self", ".", "lr", "=", "0.001", "\n", "self", ".", "lr_decay", "=", "0.5", "\n", "self", ".", "early_stop_count", "=", "4", "\n", "self", ".", "weight_decay_count", "=", "2", "\n", "self", ".", "valid_type", "=", "'loss'", "\n", "self", ".", "batch_size", "=", "64", "\n", "self", ".", "dropout_rate", "=", "0.35", "\n", "self", ".", "max_epoch", "=", "100", "\n", "self", ".", "min_epoch", "=", "0", "\n", "self", ".", "teacher_force", "=", "100", "\n", "self", ".", "spv_proportion", "=", "100", "\n", "self", ".", "no_label_train", "=", "False", "\n", "self", ".", "skip_unsup", "=", "False", "\n", "self", ".", "sup_pretrain", "=", "40", "\n", "self", ".", "mask_ontology", "=", "False", "\n", "self", ".", "parallel_z", "=", "False", "\n", "\n", "# evaluation settings", "\n", "self", ".", "beam_search", "=", "False", "\n", "self", ".", "beam_params", "=", "{", "'size'", ":", "10", ",", "'len_bonus'", ":", "0.5", "}", "\n", "self", ".", "eval_z_method", "=", "'prior'", "\n", "\n", "# model settings", "\n", "self", ".", "vocab_size", "=", "1100", "\n", "self", ".", "embed_size", "=", "50", "\n", "self", ".", "hidden_size", "=", "100", "\n", "self", ".", "layer_num", "=", "1", "\n", "self", ".", "db_vec_size", "=", "1", "\n", "self", ".", "z_length", "=", "4", "\n", "self", ".", "a_length", "=", "4", "\n", "self", ".", "u_max_len", "=", "100", "\n", "self", ".", "m_max_len", "=", "40", "\n", "self", ".", "prev_z_continuous", "=", "True", "\n", "self", ".", "m_copy_u", "=", "True", "\n", "self", ".", "multi_domain", "=", "False", "\n", "self", ".", "freeze_emb", "=", "False", "\n", "self", ".", "share_q_encoder", "=", "False", "\n", "self", ".", "model_act", "=", "False", "\n", "self", ".", "share_act_decoder", "=", "True", "\n", "self", ".", "use_act_slot_decoder", "=", "True", "\n", "self", ".", "dropout_st", "=", "True", "\n", "self", ".", "use_resp_dpout", "=", "False", "\n", "self", ".", "glove_init", "=", "True", "\n", "self", ".", "changedp", "=", "False", "\n", "\n", "# SMC params", "\n", "self", ".", "particle_num", "=", "5", "\n", "self", ".", "topk_num", "=", "5", "\n", "self", ".", "resampling", "=", "True", "\n", "self", ".", "weighted_grad", "=", "True", "\n", "self", ".", "pz_loss_weight", "=", "1", "\n", "\n", "# JSA params", "\n", "self", ".", "use_pimh", "=", "False", "\n", "self", ".", "pimh_iter_num", "=", "1", "\n", "if", "not", "self", ".", "use_pimh", ":", "\n", "            ", "self", ".", "pimh_iter_num", "=", "1", "\n", "\n", "# VAE params", "\n", "", "self", ".", "sample_type", "=", "'topk'", "\n", "self", ".", "gumbel_temp", "=", "1.0", "\n", "self", ".", "kl_loss_weight", "=", "0.1", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config._multiwoz_init": [[221, 312], ["os.path.join", "time.strftime", "time.localtime"], "methods", ["None"], ["", "def", "_multiwoz_init", "(", "self", ")", ":", "\n", "# experimental settings", "\n", "        ", "self", ".", "seed", "=", "0", "\n", "self", ".", "cuda", "=", "True", "\n", "self", ".", "cuda_device", "=", "0", "\n", "self", ".", "exp_no", "=", "'test'", "\n", "self", ".", "exp_path", "=", "'to be generated'", "\n", "self", ".", "model_path", "=", "'to be generated'", "\n", "self", ".", "result_path", "=", "'to be generated'", "\n", "self", ".", "global_record_path", "=", "'./multiwoz_results.csv'", "\n", "self", ".", "eval_load_path", "=", "'to be generated'", "\n", "self", ".", "vocab_path", "=", "'./data/MultiWOZ/processed/vocab'", "\n", "self", ".", "data_path", "=", "'./data/MultiWOZ/processed/'", "\n", "self", ".", "data_file", "=", "os", ".", "path", ".", "join", "(", "self", ".", "data_path", ",", "'data_processed.json'", ")", "\n", "\n", "self", ".", "raw_data", "=", "'data/MultiWOZ/MULTIWOZ2.1/data.json'", "\n", "self", ".", "dev_list", "=", "'data/MultiWOZ/MULTIWOZ2.1/valListFile.json'", "\n", "self", ".", "test_list", "=", "'data/MultiWOZ/MULTIWOZ2.1/testListFile.json'", "\n", "self", ".", "db_paths", "=", "'data/MultiWOZ/processed/db_processed.json'", "\n", "self", ".", "dial_goals", "=", "'data/MultiWOZ/processed/goal_of_each_dials.json'", "\n", "self", ".", "domain_file_path", "=", "'data/MultiWOZ/processed/domain_files.json'", "\n", "self", ".", "slot_value_set_path", "=", "'db/value_set_processed.json'", "\n", "\n", "self", ".", "save_log", "=", "True", "\n", "self", ".", "log_time", "=", "time", ".", "strftime", "(", "\"%Y-%m-%d-%H-%M-%S\"", ",", "time", ".", "localtime", "(", ")", ")", "\n", "\n", "# trainning settings", "\n", "self", ".", "lr", "=", "0.0005", "\n", "self", ".", "lr_decay", "=", "0.5", "\n", "self", ".", "early_stop_count", "=", "4", "\n", "self", ".", "weight_decay_count", "=", "2", "\n", "self", ".", "valid_type", "=", "'combined'", "\n", "self", ".", "batch_size", "=", "80", "\n", "self", ".", "dropout_rate", "=", "0.35", "\n", "self", ".", "max_epoch", "=", "100", "\n", "self", ".", "min_epoch", "=", "0", "\n", "self", ".", "teacher_force", "=", "100", "\n", "self", ".", "spv_proportion", "=", "100", "\n", "self", ".", "no_label_train", "=", "False", "\n", "self", ".", "skip_unsup", "=", "False", "\n", "self", ".", "sup_pretrain", "=", "40", "\n", "self", ".", "mask_ontology", "=", "False", "\n", "self", ".", "parallel_z", "=", "False", "\n", "\n", "# evaluation settings", "\n", "self", ".", "beam_search", "=", "False", "\n", "self", ".", "beam_params", "=", "{", "'size'", ":", "10", ",", "'len_bonus'", ":", "0.5", "}", "\n", "self", ".", "eval_z_method", "=", "'prior'", "\n", "self", ".", "use_true_domain_for_ctr_eval", "=", "True", "\n", "self", ".", "use_true_bspn_for_ctr_eval", "=", "False", "\n", "\n", "# model settings", "\n", "self", ".", "vocab_size", "=", "3000", "\n", "self", ".", "embed_size", "=", "50", "\n", "self", ".", "hidden_size", "=", "200", "\n", "self", ".", "layer_num", "=", "1", "\n", "self", ".", "db_vec_size", "=", "6", "# unchangeable", "\n", "self", ".", "z_length", "=", "5", "\n", "self", ".", "a_length", "=", "5", "\n", "self", ".", "u_max_len", "=", "100", "\n", "self", ".", "m_max_len", "=", "40", "\n", "self", ".", "prev_z_continuous", "=", "False", "\n", "self", ".", "m_copy_u", "=", "True", "\n", "self", ".", "multi_domain", "=", "True", "\n", "self", ".", "freeze_emb", "=", "False", "\n", "self", ".", "share_q_encoder", "=", "False", "\n", "self", ".", "model_act", "=", "False", "\n", "self", ".", "share_act_decoder", "=", "True", "\n", "self", ".", "use_act_slot_decoder", "=", "False", "\n", "self", ".", "dropout_st", "=", "True", "\n", "self", ".", "use_resp_dpout", "=", "False", "\n", "self", ".", "glove_init", "=", "True", "\n", "self", ".", "changedp", "=", "False", "\n", "\n", "# SMC params", "\n", "self", ".", "particle_num", "=", "5", "\n", "self", ".", "topk_num", "=", "5", "\n", "self", ".", "resampling", "=", "True", "\n", "self", ".", "weighted_grad", "=", "True", "\n", "self", ".", "pz_loss_weight", "=", "1", "\n", "\n", "# JSA params", "\n", "self", ".", "use_pimh", "=", "False", "\n", "self", ".", "pimh_iter_num", "=", "1", "\n", "if", "not", "self", ".", "use_pimh", ":", "\n", "            ", "self", ".", "pimh_iter_num", "=", "1", "\n", "\n", "# VAE params", "\n", "", "self", ".", "sample_type", "=", "'topk'", "\n", "self", ".", "gumbel_temp", "=", "1.0", "\n", "self", ".", "kl_loss_weight", "=", "0.5", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config.__str__": [[314, 319], ["config._Config.__dict__.items"], "methods", ["None"], ["", "def", "__str__", "(", "self", ")", ":", "\n", "        ", "s", "=", "''", "\n", "for", "k", ",", "v", "in", "self", ".", "__dict__", ".", "items", "(", ")", ":", "\n", "            ", "s", "+=", "'{} : {}\\n'", ".", "format", "(", "k", ",", "v", ")", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.Attn.__init__": [[82, 87], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "attn", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_size", "*", "2", ",", "hidden_size", ")", "\n", "self", ".", "v", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.Attn.forward": [[88, 102], ["modules.Attn.score", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.softmax", "torch.softmax", "modules.Attn.masked_fill_", "torch.softmax", "torch.softmax"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.BLEUScorer.score"], ["", "def", "forward", "(", "self", ",", "hidden", ",", "encoder_outputs", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param hidden: tensor of size [n_layer, B, H]\n        :param encoder_outputs: tensor of size [B,T, H]\n        \"\"\"", "\n", "attn_energies", "=", "self", ".", "score", "(", "hidden", ",", "encoder_outputs", ")", "# [B,T,H]", "\n", "if", "mask", "is", "None", ":", "\n", "            ", "normalized_energy", "=", "F", ".", "softmax", "(", "attn_energies", ",", "dim", "=", "2", ")", "# [B,1,T]", "\n", "", "else", ":", "\n", "            ", "attn_energies", ".", "masked_fill_", "(", "mask", ",", "-", "1e20", ")", "\n", "normalized_energy", "=", "F", ".", "softmax", "(", "attn_energies", ",", "dim", "=", "2", ")", "# [B,1,T]", "\n", "\n", "", "context", "=", "torch", ".", "bmm", "(", "normalized_energy", ",", "encoder_outputs", ")", "# [B,1,H]", "\n", "return", "context", "# [B,1, H]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.Attn.score": [[103, 109], ["encoder_outputs.size", "hidden.repeat().transpose", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "modules.Attn.v().transpose", "modules.Attn.attn", "hidden.repeat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "modules.Attn.v"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "hidden", ",", "encoder_outputs", ")", ":", "\n", "        ", "max_len", "=", "encoder_outputs", ".", "size", "(", "1", ")", "\n", "H", "=", "hidden", ".", "repeat", "(", "max_len", ",", "1", ",", "1", ")", ".", "transpose", "(", "0", ",", "1", ")", "# [B,T,H]", "\n", "energy", "=", "torch", ".", "tanh", "(", "self", ".", "attn", "(", "torch", ".", "cat", "(", "[", "H", ",", "encoder_outputs", "]", ",", "2", ")", ")", ")", "# [B,T,2H]->[B,T,H]", "\n", "energy", "=", "self", ".", "v", "(", "energy", ")", ".", "transpose", "(", "1", ",", "2", ")", "# [B,1,T]", "\n", "return", "energy", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.Encoder.__init__": [[112, 122], ["torch.nn.Module.__init__", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.GRU", "torch.nn.GRU"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embedding", ",", "input_size", ",", "embed_size", ",", "hidden_size", ",", "n_layers", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "Encoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embed_size", "=", "embed_size", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "dropout_rate", "=", "dropout", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "self", ".", "embedding", "=", "embedding", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", ",", "hidden_size", ",", "n_layers", ",", "dropout", "=", "self", ".", "dropout_rate", ",", "bidirectional", "=", "True", ",", "batch_first", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.Encoder.forward": [[123, 131], ["modules.Encoder.gru", "modules.Encoder.embedding"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input_seqs", ",", "hidden", "=", "None", ",", "input_type", "=", "'index'", ")", ":", "\n", "        ", "if", "input_type", "==", "'index'", ":", "\n", "            ", "embedded", "=", "self", ".", "embedding", "(", "input_seqs", ")", "\n", "", "elif", "input_type", "==", "'embedding'", ":", "\n", "            ", "embedded", "=", "input_seqs", "\n", "", "outputs", ",", "hidden", "=", "self", ".", "gru", "(", "embedded", ",", "hidden", ")", "\n", "outputs", "=", "outputs", "[", ":", ",", ":", ",", ":", "self", ".", "hidden_size", "]", "+", "outputs", "[", ":", ",", ":", ",", "self", ".", "hidden_size", ":", "]", "# Sum bidirectional outputs", "\n", "return", "outputs", ",", "hidden", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.DynamicEncoder.__init__": [[134, 144], ["torch.nn.Module.__init__", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.GRU", "torch.nn.GRU"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "embedding", ",", "input_size", ",", "embed_size", ",", "hidden_size", ",", "n_layers", ",", "dropout", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embed_size", "=", "embed_size", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "dropout_rate", "=", "dropout", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "self", ".", "dropout_rate", ")", "\n", "self", ".", "embedding", "=", "embedding", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", ",", "hidden_size", ",", "n_layers", ",", "dropout", "=", "self", ".", "dropout_rate", ",", "bidirectional", "=", "True", ",", "batch_first", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.DynamicEncoder.forward": [[145, 174], ["input_seqs.size", "numpy.argsort", "modules.cuda_", "modules.cuda_", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "modules.DynamicEncoder.gru", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "outputs[].contiguous", "hidden[].contiguous", "modules.DynamicEncoder.embedding", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "numpy.argsort"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "def", "forward", "(", "self", ",", "input_seqs", ",", "input_lens", ",", "hidden", "=", "None", ",", "input_type", "=", "'index'", ")", ":", "\n", "        ", "\"\"\"\n        forward procedure. No need for inputs to be sorted\n        :param input_seqs: Variable of [B, T] (input_type=index) or\n                                                          [B,T,E] (input_type=embedding)\n        :param hidden:\n        :param input_lens: *numpy array* of len for each input sequence\n        :return:\n        \"\"\"", "\n", "batch_size", "=", "input_seqs", ".", "size", "(", "0", ")", "\n", "if", "input_type", "==", "'index'", ":", "\n", "            ", "embedded", "=", "self", ".", "embedding", "(", "input_seqs", ")", "\n", "", "elif", "input_type", "==", "'embedding'", ":", "\n", "            ", "embedded", "=", "input_seqs", "\n", "\n", "", "sort_idx", "=", "np", ".", "argsort", "(", "-", "input_lens", ")", "\n", "# print(sort_idx)", "\n", "# print('tensor:', torch.LongTensor(np.argsort(sort_idx)))", "\n", "unsort_idx", "=", "cuda_", "(", "torch", ".", "LongTensor", "(", "np", ".", "argsort", "(", "sort_idx", ")", ")", ")", "\n", "input_lens", "=", "input_lens", "[", "sort_idx", "]", "\n", "sort_idx", "=", "cuda_", "(", "torch", ".", "LongTensor", "(", "sort_idx", ")", ")", "\n", "embedded", "=", "embedded", "[", "sort_idx", "]", "\n", "packed", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pack_padded_sequence", "(", "embedded", ",", "input_lens", ",", "batch_first", "=", "True", ")", "\n", "outputs", ",", "hidden", "=", "self", ".", "gru", "(", "packed", ",", "hidden", ")", "\n", "outputs", ",", "_", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pad_packed_sequence", "(", "outputs", ",", "batch_first", "=", "True", ")", "\n", "outputs", "=", "outputs", "[", ":", ",", ":", ",", ":", "self", ".", "hidden_size", "]", "+", "outputs", "[", ":", ",", ":", ",", "self", ".", "hidden_size", ":", "]", "\n", "outputs", "=", "outputs", "[", "unsort_idx", "]", ".", "contiguous", "(", ")", "\n", "hidden", "=", "hidden", "[", "unsort_idx", "]", ".", "contiguous", "(", ")", "\n", "return", "outputs", ",", "hidden", "", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.cuda_": [[9, 11], ["var.cuda"], "function", ["None"], ["def", "cuda_", "(", "var", ")", ":", "\n", "    ", "return", "var", ".", "cuda", "(", ")", "if", "cfg", ".", "cuda", "else", "var", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.get_one_hot_input": [[13, 33], ["modules.get_one_hot_input.to_one_hot"], "function", ["None"], ["", "def", "get_one_hot_input", "(", "input_t", ",", "v_dim", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    word index sequence -> one hot sparse input\n    :param x_input_np: [B, Tenc]\n    :return: tensor: [B,Tenc, V]\n    \"\"\"", "\n", "def", "to_one_hot", "(", "y", ",", "n_dims", "=", "None", ")", ":", "\n", "        ", "\"\"\" Take integer y (tensor or variable) with n dims and convert it to 1-hot representation with n+1 dims. \"\"\"", "\n", "y_tensor", "=", "y", ".", "data", "if", "isinstance", "(", "y", ",", "Variable", ")", "else", "y", "\n", "y_tensor", "=", "y_tensor", ".", "type", "(", "torch", ".", "LongTensor", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "n_dims", "=", "n_dims", "if", "n_dims", "is", "not", "None", "else", "int", "(", "torch", ".", "max", "(", "y_tensor", ")", ")", "+", "1", "\n", "y_one_hot", "=", "torch", ".", "zeros", "(", "y_tensor", ".", "size", "(", ")", "[", "0", "]", ",", "n_dims", ")", ".", "fill_", "(", "1e-10", ")", ".", "scatter_", "(", "1", ",", "y_tensor", ",", "1", ")", "#1e-10", "\n", "return", "y_one_hot", ".", "view", "(", "*", "y", ".", "shape", ",", "-", "1", ")", "\n", "\n", "# input_t = torch.from_numpy(x_input_np).long()   #[B, T]", "\n", "", "input_t_onehot", "=", "to_one_hot", "(", "input_t", ",", "n_dims", "=", "v_dim", ")", "#[B,T,V]", "\n", "input_t_onehot", "[", ":", ",", ":", ",", "0", "]", "=", "1e-10", "#<pad> to zero", "\n", "# input_t_onehot = [cuda_(t.to_sparse()) for t in input_t_onehot]", "\n", "# return input_t_onehot", "\n", "return", "cuda_", "(", "input_t_onehot", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.get_sparse_input_efficient": [[35, 45], ["numpy.zeros", "torch.from_numpy().float.fill", "range", "torch.from_numpy().float", "torch.from_numpy().float", "range", "torch.from_numpy", "torch.from_numpy"], "function", ["None"], ["", "def", "get_sparse_input_efficient", "(", "x_input_np", ")", ":", "\n", "    ", "ignore_index", "=", "[", "0", "]", "\n", "result", "=", "np", ".", "zeros", "(", "(", "x_input_np", ".", "shape", "[", "0", "]", ",", "x_input_np", ".", "shape", "[", "1", "]", ",", "cfg", ".", "vocab_size", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "result", ".", "fill", "(", "1e-10", ")", "\n", "for", "b", "in", "range", "(", "x_input_np", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "for", "t", "in", "range", "(", "x_input_np", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "if", "x_input_np", "[", "b", "]", "[", "t", "]", "not", "in", "ignore_index", ":", "\n", "                ", "result", "[", "b", "]", "[", "t", "]", "[", "x_input_np", "[", "b", "]", "[", "t", "]", "]", "=", "1.0", "\n", "", "", "", "result", "=", "torch", ".", "from_numpy", "(", "result", ")", ".", "float", "(", ")", "\n", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.shift": [[47, 55], ["cuda_().fill_", "torch.cat", "torch.cat", "pz_proba[].detach", "modules.cuda_", "torch.zeros", "torch.zeros", "torch.cat.size", "torch.cat.size"], "function", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "def", "shift", "(", "pz_proba", ")", ":", "\n", "    ", "\"\"\"[summary]\n    :param pz_proba: [B,T,V]\n    :returns: shifted pz_proba\n    \"\"\"", "\n", "first_input", "=", "cuda_", "(", "torch", ".", "zeros", "(", "(", "pz_proba", ".", "size", "(", "0", ")", ",", "1", ",", "pz_proba", ".", "size", "(", "2", ")", ")", ")", ")", ".", "fill_", "(", "1e-12", ")", "\n", "pz_proba", "=", "torch", ".", "cat", "(", "[", "first_input", ",", "pz_proba", "]", ",", "dim", "=", "1", ")", "\n", "return", "pz_proba", "[", ":", ",", ":", "-", "1", "]", ".", "detach", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.gumbel_softmax": [[58, 64], ["torch.softmax", "torch.rand().cuda", "torch.rand().cuda", "modules.gumbel_softmax.sample_gumbel"], "function", ["None"], ["", "def", "gumbel_softmax", "(", "logits", ",", "temperature", ")", ":", "\n", "    ", "def", "sample_gumbel", "(", "shape", ",", "eps", "=", "1e-20", ")", ":", "\n", "        ", "U", "=", "torch", ".", "rand", "(", "shape", ")", ".", "cuda", "(", ")", "\n", "return", "-", "Variable", "(", "torch", ".", "log", "(", "-", "torch", ".", "log", "(", "U", "+", "eps", ")", "+", "eps", ")", ")", "\n", "", "y", "=", "logits", "+", "sample_gumbel", "(", "logits", ".", "size", "(", ")", ")", "\n", "return", "F", ".", "softmax", "(", "y", "/", "temperature", ",", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.ST_gumbel_softmax_sample": [[66, 79], ["y.size", "y.max", "torch.zeros_like().view", "torch.zeros_like().view", "y_hard.view.scatter_", "y_hard.view.view", "ind.view", "torch.zeros_like", "torch.zeros_like"], "function", ["None"], ["", "def", "ST_gumbel_softmax_sample", "(", "y", ")", ":", "\n", "    ", "\"\"\"\n    ST-gumbel-softmax\n    input: [*, n_class]\n    return: flatten --> [*, n_class] an one-hot vector\n    \"\"\"", "\n", "shape", "=", "y", ".", "size", "(", ")", "\n", "_", ",", "ind", "=", "y", ".", "max", "(", "dim", "=", "-", "1", ")", "\n", "y_hard", "=", "torch", ".", "zeros_like", "(", "y", ")", ".", "view", "(", "-", "1", ",", "shape", "[", "-", "1", "]", ")", "\n", "y_hard", ".", "scatter_", "(", "1", ",", "ind", ".", "view", "(", "-", "1", ",", "1", ")", ",", "1", ")", "\n", "y_hard", "=", "y_hard", ".", "view", "(", "*", "shape", ")", "\n", "y_hard", "=", "(", "y_hard", "-", "y", ")", ".", "detach", "(", ")", "+", "y", "\n", "return", "y_hard", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.__init__": [[76, 114], ["ontologies.MultiwozOntology", "json.loads", "json.loads", "datasets.MultiwozDB", "json.loads", "json.loads", "json.loads", "json.loads", "json.loads", "json.loads", "vocab.Vocab", "multiwoz_preprocess.DataPreprocessor.preprocess_main", "multiwoz_preprocess.DataPreprocessor.analysis", "multiwoz_preprocess.DataPreprocessor.normalize_multiwoz21_name", "open().read().lower", "open().read().lower", "os.path.exists", "multiwoz_preprocess.DataPreprocessor.preprocess_db", "open().read", "open().read", "open().read", "open().read", "open().read", "open().read", "open().read", "open().read", "open", "open", "open", "open", "open", "open", "open", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.preprocess_main", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.analysis", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.normalize_multiwoz21_name", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.preprocess_db"], ["    ", "def", "__init__", "(", "self", ",", "do_analysis", "=", "True", ")", ":", "\n", "        ", "self", ".", "otlg", "=", "MultiwozOntology", "(", ")", "\n", "\n", "self", ".", "data_path", "=", "'data/MultiWOZ/MULTIWOZ2.1/data.json'", "\n", "self", ".", "save_path", "=", "'data/MultiWOZ/processed/'", "\n", "self", ".", "original_db_paths", "=", "{", "\n", "'attraction'", ":", "'data/MultiWOZ/MULTIWOZ2.1/attraction_db.json'", ",", "\n", "'hospital'", ":", "'data/MultiWOZ/MULTIWOZ2.1/hospital_db.json'", ",", "\n", "'hotel'", ":", "'data/MultiWOZ/MULTIWOZ2.1/hotel_db.json'", ",", "\n", "'police'", ":", "'data/MultiWOZ/MULTIWOZ2.1/police_db.json'", ",", "\n", "'restaurant'", ":", "'data/MultiWOZ/MULTIWOZ2.1/restaurant_db.json'", ",", "\n", "'taxi'", ":", "'data/MultiWOZ/MULTIWOZ2.1/taxi_db.json'", ",", "\n", "'train'", ":", "'data/MultiWOZ/MULTIWOZ2.1/train_db.json'", ",", "\n", "}", "\n", "\n", "if", "do_analysis", ":", "\n", "            ", "self", ".", "analysis", "(", ")", "\n", "self", ".", "normalize_multiwoz21_name", "(", ")", "\n", "\n", "", "self", ".", "original_data", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "data_path", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "self", ".", "dialog_acts", "=", "json", ".", "loads", "(", "open", "(", "'data/MultiWOZ/MULTIWOZ2.1/dialogue_acts.json'", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "\n", "self", ".", "db_path", "=", "self", ".", "save_path", "+", "'db_processed.json'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "db_path", ")", ":", "\n", "            ", "self", ".", "preprocess_db", "(", "self", ".", "original_db_paths", ",", "self", ".", "otlg", ")", "\n", "", "self", ".", "db", "=", "MultiwozDB", "(", "self", ".", "db_path", ",", "self", ".", "otlg", ")", "\n", "\n", "self", ".", "delex_sg_valdict", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "save_path", "+", "'single_token_values.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "delex_mt_valdict", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "save_path", "+", "'multi_token_values.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "ambiguous_vals", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "save_path", "+", "'ambiguous_values.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "reference_nos", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "save_path", "+", "'reference_no.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "name_map", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "save_path", "+", "'name_map.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "otlg_values", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "save_path", "+", "'db_values.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "\n", "\n", "self", ".", "vocab", "=", "Vocab", "(", "cfg", ".", "vocab_size", ",", "self", ".", "otlg", ".", "special_tokens", ")", "\n", "\n", "self", ".", "preprocess_main", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.analysis": [[115, 245], ["set", "open().read().lower", "json.loads", "list", "json.loads.items", "set", "goals.items", "os.path.exists", "os.mkdir", "open", "json.dump", "open", "json.dump", "open", "json.dump", "open", "json.dump", "open", "json.dump", "open", "collections.OrderedDict", "json.dump", "open", "json.dump", "open", "json.dump", "open().read", "re.findall", "list", "[].append", "meta.items", "[].append", "goals[].get", "goals[].get", "goals[].get", "dom_count.items", "dom_count.items", "dom_count.items", "open", "book.items", "semi.items", "dom_count.get", "dom_fnlist.get", "dom_count.get", "dom_fnlist.get", "set.add", "copy.deepcopy().items", "dom_fnlist[].append", "dom_fnlist[].append", "set.add", "turn_dict[].get", "copy.deepcopy"], "methods", ["None"], ["", "def", "analysis", "(", "self", ")", ":", "\n", "        ", "compressed_raw_data", "=", "{", "}", "\n", "goal_of_dials", "=", "{", "}", "\n", "req_slots", "=", "{", "}", "\n", "info_slots", "=", "{", "}", "\n", "dom_count", "=", "{", "}", "\n", "dom_fnlist", "=", "{", "}", "\n", "all_domain_specific_slots", "=", "set", "(", ")", "\n", "for", "domain", "in", "self", ".", "otlg", ".", "all_domains", ":", "\n", "            ", "req_slots", "[", "domain", "]", "=", "[", "]", "\n", "info_slots", "[", "domain", "]", "=", "[", "]", "\n", "\n", "", "data_jsonstr", "=", "open", "(", "self", ".", "data_path", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", "\n", "data", "=", "json", ".", "loads", "(", "data_jsonstr", ")", "\n", "ref_nos", "=", "list", "(", "set", "(", "re", ".", "findall", "(", "r'\\\"reference\\\"\\: \\\"(\\w+)\\\"'", ",", "data_jsonstr", ")", ")", ")", "\n", "\n", "\n", "for", "fn", ",", "dial", "in", "data", ".", "items", "(", ")", ":", "\n", "            ", "goals", "=", "dial", "[", "'goal'", "]", "\n", "logs", "=", "dial", "[", "'log'", "]", "\n", "\n", "# get compressed_raw_data and goal_of_dials", "\n", "compressed_raw_data", "[", "fn", "]", "=", "{", "'goal'", ":", "{", "}", ",", "'log'", ":", "[", "]", "}", "\n", "goal_of_dials", "[", "fn", "]", "=", "{", "}", "\n", "for", "dom", ",", "goal", "in", "goals", ".", "items", "(", ")", ":", "\n", "                ", "if", "dom", "!=", "'topic'", "and", "dom", "!=", "'message'", "and", "goal", ":", "\n", "                    ", "compressed_raw_data", "[", "fn", "]", "[", "'goal'", "]", "[", "dom", "]", "=", "goal", "\n", "goal_of_dials", "[", "fn", "]", "[", "dom", "]", "=", "goal", "\n", "\n", "", "", "for", "turn", "in", "logs", ":", "\n", "                ", "if", "not", "turn", "[", "'metadata'", "]", ":", "\n", "                    ", "compressed_raw_data", "[", "fn", "]", "[", "'log'", "]", ".", "append", "(", "{", "'text'", ":", "turn", "[", "'text'", "]", "}", ")", "\n", "", "else", ":", "\n", "                    ", "meta", "=", "turn", "[", "'metadata'", "]", "\n", "turn_dict", "=", "{", "'text'", ":", "turn", "[", "'text'", "]", ",", "'metadata'", ":", "{", "}", "}", "\n", "for", "dom", ",", "book_semi", "in", "meta", ".", "items", "(", ")", ":", "\n", "                        ", "book", ",", "semi", "=", "book_semi", "[", "'book'", "]", ",", "book_semi", "[", "'semi'", "]", "\n", "record", "=", "False", "\n", "for", "slot", ",", "value", "in", "book", ".", "items", "(", ")", ":", "\n", "                            ", "if", "value", "not", "in", "[", "''", ",", "[", "]", "]", ":", "\n", "                                ", "record", "=", "True", "\n", "", "", "if", "record", ":", "\n", "                            ", "turn_dict", "[", "'metadata'", "]", "[", "dom", "]", "=", "{", "}", "\n", "turn_dict", "[", "'metadata'", "]", "[", "dom", "]", "[", "'book'", "]", "=", "book", "\n", "", "record", "=", "False", "\n", "for", "slot", ",", "value", "in", "semi", ".", "items", "(", ")", ":", "\n", "                            ", "if", "value", "not", "in", "[", "''", ",", "[", "]", "]", ":", "\n", "                                ", "record", "=", "True", "\n", "break", "\n", "", "", "if", "record", ":", "\n", "                            ", "for", "s", ",", "v", "in", "copy", ".", "deepcopy", "(", "semi", ")", ".", "items", "(", ")", ":", "\n", "                                ", "if", "v", "==", "'not mentioned'", ":", "\n", "                                    ", "del", "semi", "[", "s", "]", "\n", "", "", "if", "not", "turn_dict", "[", "'metadata'", "]", ".", "get", "(", "dom", ")", ":", "\n", "                                ", "turn_dict", "[", "'metadata'", "]", "[", "dom", "]", "=", "{", "}", "\n", "", "turn_dict", "[", "'metadata'", "]", "[", "dom", "]", "[", "'semi'", "]", "=", "semi", "\n", "", "", "compressed_raw_data", "[", "fn", "]", "[", "'log'", "]", ".", "append", "(", "turn_dict", ")", "\n", "\n", "\n", "# get domain statistics", "\n", "", "dial_type", "=", "'multi'", "if", "'mul'", "in", "fn", "or", "'MUL'", "in", "fn", "else", "'single'", "\n", "if", "fn", "in", "[", "'pmul2756.json'", ",", "'pmul4958.json'", ",", "'pmul3599.json'", "]", ":", "\n", "                    ", "dial_type", "=", "'single'", "\n", "", "dial_domains", "=", "[", "dom", "for", "dom", "in", "self", ".", "otlg", ".", "all_domains", "if", "goals", "[", "dom", "]", "]", "\n", "dom_str", "=", "''", "\n", "for", "dom", "in", "dial_domains", ":", "\n", "                    ", "if", "not", "dom_count", ".", "get", "(", "dom", "+", "'_'", "+", "dial_type", ")", ":", "\n", "                        ", "dom_count", "[", "dom", "+", "'_'", "+", "dial_type", "]", "=", "1", "\n", "", "else", ":", "\n", "                        ", "dom_count", "[", "dom", "+", "'_'", "+", "dial_type", "]", "+=", "1", "\n", "", "if", "not", "dom_fnlist", ".", "get", "(", "dom", "+", "'_'", "+", "dial_type", ")", ":", "\n", "                        ", "dom_fnlist", "[", "dom", "+", "'_'", "+", "dial_type", "]", "=", "[", "fn", "]", "\n", "", "elif", "fn", "not", "in", "dom_fnlist", "[", "dom", "+", "'_'", "+", "dial_type", "]", ":", "\n", "                        ", "dom_fnlist", "[", "dom", "+", "'_'", "+", "dial_type", "]", ".", "append", "(", "fn", ")", "\n", "", "dom_str", "+=", "'%s_'", "%", "dom", "\n", "", "dom_str", "=", "dom_str", "[", ":", "-", "1", "]", "\n", "if", "dial_type", "==", "'multi'", ":", "\n", "                    ", "if", "not", "dom_count", ".", "get", "(", "dom_str", ")", ":", "\n", "                        ", "dom_count", "[", "dom_str", "]", "=", "1", "\n", "", "else", ":", "\n", "                        ", "dom_count", "[", "dom_str", "]", "+=", "1", "\n", "", "if", "not", "dom_fnlist", ".", "get", "(", "dom_str", ")", ":", "\n", "                        ", "dom_fnlist", "[", "dom_str", "]", "=", "[", "fn", "]", "\n", "", "elif", "fn", "not", "in", "dom_fnlist", "[", "dom_str", "]", ":", "\n", "                        ", "dom_fnlist", "[", "dom_str", "]", ".", "append", "(", "fn", ")", "\n", "######", "\n", "\n", "# get informable and requestable slots statistics", "\n", "", "", "for", "domain", "in", "self", ".", "otlg", ".", "all_domains", ":", "\n", "                    ", "info_ss", "=", "goals", "[", "domain", "]", ".", "get", "(", "'info'", ",", "{", "}", ")", "\n", "book_ss", "=", "goals", "[", "domain", "]", ".", "get", "(", "'book'", ",", "{", "}", ")", "\n", "req_ss", "=", "goals", "[", "domain", "]", ".", "get", "(", "'reqt'", ",", "{", "}", ")", "\n", "for", "info_s", "in", "info_ss", ":", "\n", "                        ", "all_domain_specific_slots", ".", "add", "(", "domain", "+", "'-'", "+", "info_s", ")", "\n", "if", "info_s", "not", "in", "info_slots", "[", "domain", "]", ":", "\n", "                            ", "info_slots", "[", "domain", "]", "+=", "[", "info_s", "]", "\n", "", "", "for", "book_s", "in", "book_ss", ":", "\n", "                        ", "if", "'book_'", "+", "book_s", "not", "in", "info_slots", "[", "domain", "]", "and", "book_s", "not", "in", "[", "'invalid'", ",", "'pre_invalid'", "]", ":", "\n", "                            ", "all_domain_specific_slots", ".", "add", "(", "domain", "+", "'-'", "+", "book_s", ")", "\n", "info_slots", "[", "domain", "]", "+=", "[", "'book_'", "+", "book_s", "]", "\n", "", "", "for", "req_s", "in", "req_ss", ":", "\n", "                        ", "if", "req_s", "not", "in", "req_slots", "[", "domain", "]", ":", "\n", "                            ", "req_slots", "[", "domain", "]", "+=", "[", "req_s", "]", "\n", "\n", "\n", "\n", "# result statistics", "\n", "", "", "", "", "", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "save_path", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "self", ".", "save_path", ")", "\n", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'req_slots.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "req_slots", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'info_slots.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "info_slots", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'all_domain_specific_info_slots.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "list", "(", "all_domain_specific_slots", ")", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'goal_of_each_dials.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "goal_of_dials", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'compressed_data.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "compressed_raw_data", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'domain_count.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "single_count", "=", "[", "d", "for", "d", "in", "dom_count", ".", "items", "(", ")", "if", "'single'", "in", "d", "[", "0", "]", "]", "\n", "multi_count", "=", "[", "d", "for", "d", "in", "dom_count", ".", "items", "(", ")", "if", "'multi'", "in", "d", "[", "0", "]", "]", "\n", "other_count", "=", "[", "d", "for", "d", "in", "dom_count", ".", "items", "(", ")", "if", "'multi'", "not", "in", "d", "[", "0", "]", "and", "'single'", "not", "in", "d", "[", "0", "]", "]", "\n", "dom_count_od", "=", "OrderedDict", "(", "single_count", "+", "multi_count", "+", "other_count", ")", "\n", "json", ".", "dump", "(", "dom_count_od", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'reference_no.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "ref_nos", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'domain_files.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "dom_fnlist", ",", "sf", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.normalize_multiwoz21_name": [[247, 291], ["json.loads", "json.loads", "multiwoz_preprocess.DataPreprocessor.original_db_paths.items", "json.loads.items", "print", "open().read().lower", "open().read().lower", "enumerate", "open", "json.dump", "open", "json.loads", "open().read", "open().read", "f.read().lower", "meta21.items", "open", "open", "f.read", "semi21[].split", "db.items", "ent.get"], "methods", ["None"], ["", "", "def", "normalize_multiwoz21_name", "(", "self", ")", ":", "\n", "        ", "data20", "=", "'data/MultiWOZ/compressed_data_2.0.json'", "\n", "data21", "=", "self", ".", "save_path", "+", "'compressed_data.json'", "\n", "data20", "=", "json", ".", "loads", "(", "open", "(", "data20", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "data21", "=", "json", ".", "loads", "(", "open", "(", "data21", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "\n", "name_map", "=", "{", "}", "\n", "\n", "db", "=", "{", "}", "\n", "for", "dom", ",", "db_path", "in", "self", ".", "original_db_paths", ".", "items", "(", ")", ":", "\n", "            ", "if", "dom", "not", "in", "self", ".", "otlg", ".", "db_domains", ":", "\n", "                ", "continue", "\n", "", "with", "open", "(", "db_path", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "db", "[", "dom", "]", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "\n", "", "", "for", "fn", ",", "dial", "in", "data21", ".", "items", "(", ")", ":", "\n", "            ", "logs", "=", "dial", "[", "'log'", "]", "\n", "\n", "for", "tidx", ",", "turn", "in", "enumerate", "(", "logs", ")", ":", "\n", "                ", "if", "'metadata'", "in", "turn", ":", "\n", "                    ", "meta20", "=", "data20", "[", "fn", "]", "[", "'log'", "]", "[", "tidx", "]", "[", "'metadata'", "]", "\n", "meta21", "=", "turn", "[", "'metadata'", "]", "\n", "for", "dom", ",", "book_semi", "in", "meta21", ".", "items", "(", ")", ":", "\n", "                        ", "if", "'semi'", "in", "book_semi", ":", "\n", "                            ", "semi21", "=", "book_semi", "[", "'semi'", "]", "\n", "if", "'name'", "in", "semi21", "and", "'|'", "in", "semi21", "[", "'name'", "]", ":", "\n", "                                ", "semi21", "[", "'name'", "]", "=", "semi21", "[", "'name'", "]", ".", "split", "(", "'|'", ")", "[", "0", "]", "\n", "", "if", "dom", "in", "meta20", "and", "'semi'", "in", "meta20", "[", "dom", "]", ":", "\n", "                                ", "semi20", "=", "meta20", "[", "dom", "]", "[", "'semi'", "]", "\n", "user20", "=", "data20", "[", "fn", "]", "[", "'log'", "]", "[", "tidx", "-", "1", "]", "[", "'text'", "]", "\n", "if", "'name'", "in", "semi20", "and", "'name'", "in", "semi21", "and", "semi21", "[", "'name'", "]", "!=", "semi20", "[", "'name'", "]", "and", "semi20", "[", "'name'", "]", "in", "user20", ":", "\n", "                                    ", "flag", "=", "False", "\n", "for", "d", ",", "entities", "in", "db", ".", "items", "(", ")", ":", "\n", "                                        ", "for", "ent", "in", "entities", ":", "\n", "                                            ", "if", "ent", ".", "get", "(", "'name'", ")", "and", "semi20", "[", "'name'", "]", "==", "ent", "[", "'name'", "]", ":", "\n", "                                                ", "flag", "=", "True", "\n", "break", "\n", "", "", "", "if", "flag", ":", "\n", "                                        ", "name_map", "[", "semi21", "[", "'name'", "]", "]", "=", "semi20", "[", "'name'", "]", "\n", "", "", "", "", "", "", "", "", "del", "name_map", "[", "'none'", "]", "\n", "del", "name_map", "[", "'taj tandoori'", "]", "\n", "with", "open", "(", "self", ".", "save_path", "+", "'name_map.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "sf", ":", "\n", "            ", "json", ".", "dump", "(", "name_map", ",", "sf", ",", "indent", "=", "2", ")", "\n", "", "print", "(", "'name mapping saved!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.preprocess_db": [[293, 386], ["list", "list.remove", "value_to_slot_map.items", "print", "print", "set", "value_to_slot_map.pop", "open", "json.dump", "open", "json.dump", "open", "collections.OrderedDict", "json.dump", "open", "collections.OrderedDict", "json.dump", "open", "json.dump", "open", "json.loads", "enumerate", "len", "sorted", "sorted", "f.read().lower", "copy.deepcopy", "entry.items", "val.split", "collections.OrderedDict.items", "collections.OrderedDict.items", "value.replace().replace.replace().replace.replace().replace", "f.read", "type", "len", "len", "value.replace().replace.replace().replace.replace", "list.append", "nltk.tokenize.word_tokenize", "db_values[].append"], "methods", ["None"], ["", "def", "preprocess_db", "(", "self", ",", "db_paths", ",", "otlg", ")", ":", "\n", "# ensure the same value tokenization and slot normalization process as data", "\n", "        ", "db_values", "=", "{", "}", "\n", "value_to_slot_map", "=", "{", "}", "\n", "ambiguous_values", "=", "[", "]", "\n", "\n", "dbs", "=", "{", "}", "\n", "for", "domain", "in", "otlg", ".", "db_domains", ":", "\n", "            ", "with", "open", "(", "db_paths", "[", "domain", "]", ",", "'r'", ")", "as", "f", ":", "\n", "                ", "dbs", "[", "domain", "]", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "for", "idx", ",", "entry", "in", "enumerate", "(", "dbs", "[", "domain", "]", ")", ":", "\n", "                    ", "new_entry", "=", "copy", ".", "deepcopy", "(", "entry", ")", "\n", "for", "slot", ",", "value", "in", "entry", ".", "items", "(", ")", ":", "\n", "# normalize entry", "\n", "                        ", "if", "type", "(", "value", ")", "is", "not", "str", ":", "\n", "                            ", "continue", "\n", "", "del", "new_entry", "[", "slot", "]", "\n", "value", "=", "value", ".", "replace", "(", "'swimmingpool'", ",", "'swimming pool'", ")", ".", "replace", "(", "'mutliple'", ",", "'multiple'", ")", "\n", "if", "slot", "in", "otlg", ".", "slot_normlize", ":", "\n", "                            ", "slot", "=", "otlg", ".", "slot_normlize", "[", "slot", "]", "\n", "", "value_tknz_and_back", "=", "' '", ".", "join", "(", "tknz", "(", "value", ")", ")", ".", "strip", "(", ")", "\n", "\n", "new_entry", "[", "slot", "]", "=", "value_tknz_and_back", "\n", "dbs", "[", "domain", "]", "[", "idx", "]", "=", "new_entry", "\n", "\n", "# extract informable slot values", "\n", "v", "=", "value_tknz_and_back", "\n", "if", "slot", "in", "otlg", ".", "informable_slots_dict", "[", "domain", "]", ":", "\n", "                            ", "if", "domain", "+", "'-'", "+", "slot", "not", "in", "db_values", ":", "\n", "                                ", "db_values", "[", "domain", "+", "'-'", "+", "slot", "]", "=", "[", "v", "]", "\n", "", "elif", "v", "not", "in", "db_values", "[", "domain", "+", "'-'", "+", "slot", "]", ":", "\n", "                                ", "db_values", "[", "domain", "+", "'-'", "+", "slot", "]", ".", "append", "(", "v", ")", "\n", "\n", "# extract all values for delexicalization", "\n", "", "", "if", "slot", "in", "otlg", ".", "informable_slots_dict", "[", "domain", "]", "+", "otlg", ".", "requestable_slots_dict", "[", "domain", "]", ":", "\n", "                            ", "if", "slot", "in", "[", "'parking'", ",", "'internet'", ",", "'phone'", ",", "'postcode'", ",", "'id'", ",", "'stars'", ",", "'price'", "]", ":", "\n", "                                ", "continue", "\n", "", "if", "v", "in", "value_to_slot_map", "and", "value_to_slot_map", "[", "v", "]", "!=", "slot", ":", "\n", "# print(value, \": \",value_to_slot_map[value], slot)", "\n", "                                ", "ambiguous_values", ".", "append", "(", "v", ")", "\n", "", "value_to_slot_map", "[", "v", "]", "=", "slot", "\n", "\n", "", "", "", "", "print", "(", "'[%s] DB processed! '", "%", "domain", ")", "\n", "\n", "", "ambiguous_values", "=", "list", "(", "set", "(", "ambiguous_values", ")", ")", "\n", "for", "amb_v", "in", "ambiguous_values", ":", "# departure or destination? arrive time or leave time?", "\n", "            ", "value_to_slot_map", ".", "pop", "(", "amb_v", ")", "\n", "", "value_to_slot_map", "[", "'parkside'", "]", "=", "'address'", "\n", "value_to_slot_map", "[", "'parkside , cambridge'", "]", "=", "'address'", "\n", "value_to_slot_map", "[", "'hills road'", "]", "=", "'address'", "\n", "value_to_slot_map", "[", "'hills rd'", "]", "=", "'address'", "\n", "value_to_slot_map", "[", "'cambridge belfry'", "]", "=", "'name'", "\n", "value_to_slot_map", "[", "'parkside police station'", "]", "=", "'name'", "\n", "del", "value_to_slot_map", "[", "'hotel'", "]", "\n", "for", "v", "in", "[", "\"toyota\"", ",", "\"skoda\"", ",", "\"bmw\"", ",", "\"honda\"", ",", "\"ford\"", ",", "\"audi\"", ",", "\"lexus\"", ",", "\"volvo\"", ",", "\"volkswagen\"", ",", "\"tesla\"", "]", "+", "[", "\"black\"", ",", "\"white\"", ",", "\"red\"", ",", "\"yellow\"", ",", "\"blue\"", ",", "\"grey\"", "]", ":", "\n", "            ", "value_to_slot_map", "[", "v", "]", "=", "'car'", "\n", "", "ambiguous_values", ".", "remove", "(", "'cambridge'", ")", "\n", "\n", "single_token_values", "=", "{", "}", "\n", "multi_token_values", "=", "{", "}", "\n", "for", "val", ",", "slt", "in", "value_to_slot_map", ".", "items", "(", ")", ":", "\n", "            ", "if", "len", "(", "val", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "                ", "multi_token_values", "[", "val", "]", "=", "slt", "\n", "", "else", ":", "\n", "                ", "single_token_values", "[", "val", "]", "=", "slt", "\n", "if", "slt", "==", "'type'", ":", "\n", "                    ", "single_token_values", "[", "val", "+", "'s'", "]", "=", "slt", "\n", "", "", "", "single_token_values", "[", "'1000'", "]", "=", "'choice'", "\n", "single_token_values", "[", "'1029'", "]", "=", "'choice'", "\n", "single_token_values", "[", "'2828'", "]", "=", "'choice'", "\n", "single_token_values", "[", "'cb259aq'", "]", "=", "'postcode'", "\n", "single_token_values", "[", "'churches'", "]", "=", "'type'", "\n", "multi_token_values", "[", "'guest house'", "]", "=", "'type'", "\n", "multi_token_values", "[", "'arbury lodge guesthouse'", "]", "=", "'name'", "\n", "multi_token_values", "[", "'st . johns street'", "]", "=", "'address'", "\n", "multi_token_values", "[", "\"st . john 's st.\"", "]", "=", "'address'", "\n", "multi_token_values", "[", "\"st . johns\"", "]", "=", "'name'", "\n", "\n", "\n", "with", "open", "(", "self", ".", "save_path", "+", "'db_processed.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "dbs", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'db_values.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "db_values", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'single_token_values.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "            ", "single_token_values", "=", "OrderedDict", "(", "sorted", "(", "single_token_values", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "len", "(", "kv", "[", "0", "]", ")", ",", "reverse", "=", "True", ")", ")", "\n", "json", ".", "dump", "(", "single_token_values", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'multi_token_values.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "            ", "multi_token_values", "=", "OrderedDict", "(", "sorted", "(", "multi_token_values", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "len", "(", "kv", "[", "0", "]", ")", ",", "reverse", "=", "True", ")", ")", "\n", "json", ".", "dump", "(", "multi_token_values", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'ambiguous_values.json'", ",", "'w'", ",", "encoding", "=", "'utf-8'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "ambiguous_values", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "print", "(", "'value dict saved!'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.delexicalization": [[388, 454], ["multiwoz_preprocess.DataPreprocessor.delex_mt_valdict.items", "multiwoz_preprocess.DataPreprocessor.delex_sg_valdict.items", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub.replace", "re.sub.replace", "re.sub.replace", "re.sub.replace", "re.sub.replace", "re.sub.replace", "dialog_act.items", "sorted", "re.sub.strip", "re.sub.split", "enumerate", "re.sub.find", "text[].split", "re.sub.replace", "re.sub.replace", "re.sub", "sorted.append", "number_to_text.get", "len", "re.sub", "sorted.append"], "methods", ["None"], ["", "def", "delexicalization", "(", "self", ",", "text", ",", "dialog_act", "=", "None", ",", "keep_list", "=", "[", "]", ")", ":", "\n", "        ", "for", "value", "in", "self", ".", "reference_nos", ":", "\n", "            ", "text", "=", "text", ".", "replace", "(", "value", ",", "'[value_reference]'", ")", "\n", "\n", "# delex by dialog act annotation", "\n", "", "if", "dialog_act", "is", "not", "None", ":", "\n", "            ", "text", "=", "' '", "+", "text", "+", "' '", "\n", "delex_list", "=", "[", "]", "\n", "for", "act", ",", "params", "in", "dialog_act", ".", "items", "(", ")", ":", "\n", "                ", "if", "'request'", "in", "act", "or", "'general'", "in", "act", ":", "\n", "                    ", "continue", "\n", "", "for", "s_v", "in", "params", ":", "\n", "                    ", "slot", ",", "value", "=", "s_v", "[", "0", "]", ",", "s_v", "[", "1", "]", "\n", "if", "slot", "!=", "'none'", "and", "value", "!=", "'none'", "and", "value", "not", "in", "keep_list", ":", "\n", "                        ", "delex_list", ".", "append", "(", "[", "value", ",", "slot", "]", ")", "\n", "if", "number_to_text", ".", "get", "(", "value", ")", ":", "\n", "                            ", "delex_list", ".", "append", "(", "[", "number_to_text", "[", "value", "]", ",", "slot", "]", ")", "\n", "\n", "", "", "", "", "delex_list", "=", "sorted", "(", "delex_list", ",", "key", "=", "lambda", "x", ":", "len", "(", "x", "[", "0", "]", ")", ",", "reverse", "=", "True", ")", "\n", "for", "s_v", "in", "delex_list", ":", "\n", "                ", "text", "=", "text", ".", "replace", "(", "' %s '", "%", "s_v", "[", "0", "]", ",", "' [value_%s] '", "%", "s_v", "[", "1", "]", ",", "1", ")", "\n", "", "text", "=", "text", ".", "strip", "(", ")", "\n", "\n", "# delex by value dict: name, address, type, food etc", "\n", "", "for", "value", ",", "slot", "in", "self", ".", "delex_mt_valdict", ".", "items", "(", ")", ":", "\n", "            ", "if", "value", "not", "in", "keep_list", ":", "\n", "                ", "text", "=", "text", ".", "replace", "(", "value", ",", "'[value_%s]'", "%", "slot", ")", "\n", "", "", "for", "value", ",", "slot", "in", "self", ".", "delex_sg_valdict", ".", "items", "(", ")", ":", "\n", "            ", "tokens", "=", "text", ".", "split", "(", ")", "\n", "for", "idx", ",", "tk", "in", "enumerate", "(", "tokens", ")", ":", "\n", "                ", "if", "tk", "==", "value", "and", "value", "not", "in", "keep_list", ":", "\n", "                    ", "tokens", "[", "idx", "]", "=", "'[value_%s]'", "%", "slot", "\n", "", "", "text", "=", "' '", ".", "join", "(", "tokens", ")", "\n", "\n", "# delex by rules: phone, stars, price, trainID, postcode", "\n", "", "text", "=", "re", ".", "sub", "(", "r'\\d{5}\\s?\\d{5,7}'", ",", "'[value_phone]'", ",", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r'\\d[\\s-]stars?'", ",", "'[value_stars]'", ",", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r'\\$\\d+|\\$?\\d+.?(\\d+)?\\s(pounds?|gbps?)'", ",", "'[value_price]'", ",", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r'tr[\\d]{4}'", ",", "'[value_id]'", ",", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r'there are (\\d+|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)'", ",", "'there are [value_choice]'", ",", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r'([a-z]{1}[\\. ]?[a-z]{1}[\\. ]?\\d{1,2}[, ]+\\d{1}[\\. ]?[a-z]{1}[\\. ]?[a-z]{1}|[a-z]{2}\\d{2}[a-z]{2})'", ",", "'[value_postcode]'", ",", "text", ")", "\n", "\n", "# delex ambiguous values: arrive/leave time, departure/destination", "\n", "for", "ambg_ent", "in", "self", ".", "ambiguous_vals", ":", "\n", "            ", "start_idx", "=", "text", ".", "find", "(", "' '", "+", "ambg_ent", ")", "# ely is a place, but appears in words like moderately", "\n", "if", "start_idx", "==", "-", "1", "or", "ambg_ent", "in", "keep_list", ":", "\n", "                ", "continue", "\n", "", "front_words", "=", "text", "[", ":", "start_idx", "]", ".", "split", "(", ")", "\n", "ent_type", "=", "'time'", "if", "':'", "in", "ambg_ent", "else", "'place'", "\n", "\n", "for", "fw", "in", "front_words", "[", ":", ":", "-", "1", "]", ":", "\n", "                ", "if", "fw", "in", "[", "'arrive'", ",", "'arrives'", ",", "'arrived'", ",", "'arriving'", ",", "'arrival'", ",", "'destination'", ",", "'there'", ",", "'reach'", ",", "'to'", ",", "'by'", ",", "'before'", "]", ":", "\n", "                    ", "slot", "=", "'[value_arrive]'", "if", "ent_type", "==", "'time'", "else", "'[value_destination]'", "\n", "text", "=", "re", ".", "sub", "(", "' '", "+", "ambg_ent", ",", "' '", "+", "slot", ",", "text", ")", "\n", "", "elif", "fw", "in", "[", "'leave'", ",", "'leaves'", ",", "'leaving'", ",", "'depart'", ",", "'departs'", ",", "'departing'", ",", "'departure'", ",", "\n", "'from'", ",", "'after'", ",", "'pulls'", "]", ":", "\n", "                    ", "slot", "=", "'[value_leave]'", "if", "ent_type", "==", "'time'", "else", "'[value_departure]'", "\n", "text", "=", "re", ".", "sub", "(", "' '", "+", "ambg_ent", ",", "' '", "+", "slot", ",", "text", ")", "\n", "\n", "# clean", "\n", "", "", "", "text", "=", "text", ".", "replace", "(", "'[value_car] [value_car]'", ",", "'[value_car]'", ")", "\n", "text", "=", "text", ".", "replace", "(", "'[value_address] , [value_address] , [value_address]'", ",", "'[value_address]'", ")", "\n", "text", "=", "text", ".", "replace", "(", "'[value_address] , [value_address]'", ",", "'[value_address]'", ")", "\n", "text", "=", "text", ".", "replace", "(", "'[value_name] [value_name]'", ",", "'[value_name]'", ")", "\n", "text", "=", "text", ".", "replace", "(", "'[value_name]([value_phone] )'", ",", "'[value_name] ( [value_phone] )'", ")", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.preprocess_main": [[456, 666], ["tqdm.tqdm.tqdm", "multiwoz_preprocess.DataPreprocessor.vocab.construct", "multiwoz_preprocess.DataPreprocessor.vocab.save_vocab", "list", "raw_dial[].items", "list", "enumerate", "open", "json.dump", "open", "json.dump", "multiwoz_preprocess.DataPreprocessor.original_data.items", "set", "g.get", "dial_state.items", "isinstance", "multiwoz_preprocess.DataPreprocessor.delexicalization", "sorted", "dial_state.items", "set", "list", "multiwoz_preprocess.DataPreprocessor.db.get_match_num", "multiwoz_preprocess.DataPreprocessor.db.addDBPointer", "multiwoz_preprocess.DataPreprocessor.db.addBookingPointer", "str", "len", "copy.deepcopy", "copy.deepcopy", "enumerate", "dial_domains.append", "nltk.tokenize.word_tokenize", "info_sv.items", "book_sv.items", "original_dialog_act.items", "nltk.tokenize.word_tokenize", "multiwoz_preprocess.DataPreprocessor.find", "sorted.items", "act.split", "list.add", "list.remove", "list.remove", "turn_domain.remove", "len", "json.dumps", "copy.deepcopy", "dial[].append", "multiwoz_preprocess.DataPreprocessor.otlg.slot_normlize.get", "list.append", "multiwoz_preprocess.clean_text", "dial_state.get", "multiwoz_preprocess.DataPreprocessor.otlg.slot_normlize.get", "multiwoz_preprocess.DataPreprocessor.strip", "multiwoz_preprocess.DataPreprocessor.otlg.slot_normlize.get", "multiwoz_preprocess.DataPreprocessor.strip", "dial_state_flat.append", "info_slots.items", "multiwoz_preprocess.clean_text", "len", "len", "turn_domain.append", "len", "len", "str", "single_turn[].split", "single_turn[].split", "multiwoz_preprocess.DataPreprocessor.vocab.add_word", "len", "multiwoz_preprocess.DataPreprocessor.name_map.get", "len", "multiwoz_preprocess.DataPreprocessor.name_map.get", "dial_state_flat.append", "dial_state_flat.extend", "str", "multiwoz_preprocess.DataPreprocessor.otlg.slot_normlize.get", "dialog_act[].append", "turn_dom_bs.append", "len", "multiwoz_preprocess.DataPreprocessor.split", "nltk.tokenize.word_tokenize", "multiwoz_preprocess.DataPreprocessor.replace().split", "multiwoz_preprocess.DataPreprocessor.split", "nltk.tokenize.word_tokenize", "multiwoz_preprocess.DataPreprocessor.replace().split", "clean_time.split", "int", "multiwoz_preprocess.clean_time", "request.append", "multiwoz_preprocess.DataPreprocessor.otlg_values[].append", "multiwoz_preprocess.DataPreprocessor.otlg_values[].append", "request.append", "multiwoz_preprocess.DataPreprocessor.replace", "multiwoz_preprocess.DataPreprocessor.replace", "nltk.tokenize.word_tokenize", "inform.append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.construct", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.save_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.DataPreprocessor.delexicalization", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.get_match_num", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.addDBPointer", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.addBookingPointer", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.clean_text", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.clean_text", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.add_word", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.clean_time"], ["", "def", "preprocess_main", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "data", "=", "{", "}", "\n", "count", "=", "0", "\n", "self", ".", "unique_da", "=", "{", "}", "\n", "for", "fn", ",", "raw_dial", "in", "tqdm", "(", "list", "(", "self", ".", "original_data", ".", "items", "(", ")", ")", ")", ":", "\n", "            ", "count", "+=", "1", "\n", "# if count == 100:", "\n", "#     break", "\n", "compressed_goal", "=", "{", "}", "\n", "dial_domains", ",", "dial_reqs", "=", "[", "]", ",", "[", "]", "\n", "for", "dom", ",", "g", "in", "raw_dial", "[", "'goal'", "]", ".", "items", "(", ")", ":", "\n", "                ", "if", "dom", "!=", "'topic'", "and", "dom", "!=", "'message'", "and", "g", ":", "\n", "                    ", "compressed_goal", "[", "dom", "]", "=", "g", "\n", "if", "g", ".", "get", "(", "'reqt'", ")", ":", "\n", "                        ", "for", "i", ",", "req_slot", "in", "enumerate", "(", "g", "[", "'reqt'", "]", ")", ":", "\n", "                            ", "req_slot", "=", "self", ".", "otlg", ".", "slot_normlize", ".", "get", "(", "req_slot", ",", "req_slot", ")", "\n", "dial_reqs", ".", "append", "(", "req_slot", ")", "\n", "", "", "if", "dom", "in", "self", ".", "otlg", ".", "all_domains", ":", "\n", "                        ", "dial_domains", ".", "append", "(", "dom", ")", "\n", "\n", "", "", "", "dial_reqs", "=", "list", "(", "set", "(", "dial_reqs", ")", ")", "\n", "\n", "dial", "=", "{", "'goal'", ":", "compressed_goal", ",", "'log'", ":", "[", "]", "}", "\n", "dial_state", "=", "{", "}", "\n", "prev_dial_state", "=", "{", "}", "\n", "prev_turn_domain", "=", "[", "'general'", "]", "\n", "prev_user", "=", "''", "\n", "single_turn", "=", "{", "}", "\n", "\n", "for", "turn_num", ",", "dial_turn", "in", "enumerate", "(", "raw_dial", "[", "'log'", "]", ")", ":", "\n", "                ", "metadata", "=", "dial_turn", "[", "'metadata'", "]", "\n", "if", "not", "metadata", ":", "# user", "\n", "                    ", "single_turn", "[", "'user'", "]", "=", "' '", ".", "join", "(", "tknz", "(", "clean_text", "(", "dial_turn", "[", "'text'", "]", ")", ")", ")", "\n", "", "else", ":", "#system", "\n", "# get dialog state", "\n", "                    ", "keep_list", "=", "{", "}", "\n", "name_from_db", "=", "''", "\n", "for", "domain", "in", "dial_domains", ":", "\n", "                        ", "if", "not", "dial_state", ".", "get", "(", "domain", ")", ":", "\n", "                            ", "dial_state", "[", "domain", "]", "=", "{", "}", "\n", "", "info_sv", "=", "metadata", "[", "domain", "]", "[", "'semi'", "]", "\n", "for", "s", ",", "v", "in", "info_sv", ".", "items", "(", ")", ":", "\n", "                            ", "s", "=", "self", ".", "otlg", ".", "slot_normlize", ".", "get", "(", "s", ",", "s", ")", "\n", "if", "len", "(", "v", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "                                ", "v", "=", "self", ".", "name_map", ".", "get", "(", "v", ",", "v", ")", "\n", "v", "=", "' '", ".", "join", "(", "tknz", "(", "v", ")", ")", "\n", "", "if", "'|'", "in", "v", ":", "# do not consider multiple names", "\n", "                                ", "v", "=", "v", ".", "replace", "(", "'|'", ",", "' | '", ")", ".", "split", "(", "'|'", ")", "[", "0", "]", "\n", "", "v", "=", "v", ".", "strip", "(", ")", "\n", "if", "v", "!=", "''", "and", "v", "!=", "'none'", "and", "v", "!=", "'not mentioned'", ":", "\n", "                                ", "dial_state", "[", "domain", "]", "[", "s", "]", "=", "v", "\n", "keep_list", "[", "v", "]", "=", "1", "\n", "if", "domain", "+", "'-'", "+", "s", "not", "in", "self", ".", "otlg_values", ":", "\n", "                                    ", "self", ".", "otlg_values", "[", "domain", "+", "'-'", "+", "s", "]", "=", "[", "v", "]", "\n", "", "elif", "v", "not", "in", "self", ".", "otlg_values", "[", "domain", "+", "'-'", "+", "s", "]", ":", "\n", "                                    ", "self", ".", "otlg_values", "[", "domain", "+", "'-'", "+", "s", "]", ".", "append", "(", "v", ")", "\n", "", "if", "s", "==", "'name'", "and", "domain", "in", "prev_dial_state", ":", "\n", "                                    ", "if", "s", "not", "in", "prev_dial_state", "[", "domain", "]", "and", "v", "not", "in", "prev_user", "+", "single_turn", "[", "'user'", "]", ":", "\n", "                                        ", "name_from_db", "=", "v", "\n", "", "", "", "", "book_sv", "=", "metadata", "[", "domain", "]", "[", "'book'", "]", "\n", "for", "s", ",", "v", "in", "book_sv", ".", "items", "(", ")", ":", "\n", "                            ", "if", "s", "==", "'booked'", ":", "\n", "                                ", "continue", "\n", "", "s", "=", "self", ".", "otlg", ".", "slot_normlize", ".", "get", "(", "s", ",", "s", ")", "\n", "if", "len", "(", "v", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "                                ", "v", "=", "self", ".", "name_map", ".", "get", "(", "v", ",", "v", ")", "\n", "v", "=", "' '", ".", "join", "(", "tknz", "(", "v", ")", ")", "\n", "", "if", "'|'", "in", "v", ":", "# do not consider multiple names", "\n", "                                ", "v", "=", "v", ".", "replace", "(", "'|'", ",", "' | '", ")", ".", "split", "(", "'|'", ")", "[", "0", "]", "\n", "", "v", "=", "v", ".", "strip", "(", ")", "\n", "if", "v", "!=", "''", "and", "v", "!=", "'none'", "and", "v", "!=", "'not mentioned'", ":", "\n", "                                ", "dial_state", "[", "domain", "]", "[", "s", "]", "=", "v", "\n", "keep_list", "[", "v", "]", "=", "1", "\n", "if", "domain", "+", "'-'", "+", "s", "not", "in", "self", ".", "otlg_values", ":", "\n", "                                    ", "self", ".", "otlg_values", "[", "domain", "+", "'-'", "+", "s", "]", "=", "[", "v", "]", "\n", "", "elif", "v", "not", "in", "self", ".", "otlg_values", "[", "domain", "+", "'-'", "+", "s", "]", ":", "\n", "                                    ", "self", ".", "otlg_values", "[", "domain", "+", "'-'", "+", "s", "]", ".", "append", "(", "v", ")", "\n", "# print(dial_state)", "\n", "\n", "", "", "", "", "dial_state_flat", "=", "[", "]", "\n", "for", "domain", ",", "info_slots", "in", "dial_state", ".", "items", "(", ")", ":", "\n", "                        ", "if", "info_slots", ":", "\n", "                            ", "dial_state_flat", ".", "append", "(", "'['", "+", "domain", "+", "']'", ")", "\n", "for", "slot", ",", "value", "in", "info_slots", ".", "items", "(", ")", ":", "\n", "                                ", "dial_state_flat", ".", "append", "(", "slot", ")", "\n", "dial_state_flat", ".", "extend", "(", "value", ".", "split", "(", ")", ")", "\n", "\n", "\n", "# get system dialog act and normalize", "\n", "", "", "", "dialog_act", "=", "{", "}", "\n", "inform", ",", "request", "=", "[", "]", ",", "[", "]", "\n", "try", ":", "\n", "                        ", "original_dialog_act", "=", "self", ".", "dialog_acts", "[", "fn", "[", ":", "-", "5", "]", "]", "[", "str", "(", "int", "(", "(", "turn_num", "+", "1", ")", "/", "2", ")", ")", "]", "\n", "", "except", ":", "\n", "# print(fn, turn_num)", "\n", "                        ", "original_dialog_act", "=", "None", "\n", "", "if", "isinstance", "(", "original_dialog_act", ",", "dict", ")", ":", "\n", "                        ", "for", "act", ",", "params", "in", "original_dialog_act", ".", "items", "(", ")", ":", "\n", "                            ", "dialog_act", "[", "act", "]", "=", "[", "]", "\n", "for", "s_v", "in", "params", ":", "\n", "                                ", "slot", "=", "self", ".", "otlg", ".", "slot_normlize", ".", "get", "(", "s_v", "[", "0", "]", ",", "s_v", "[", "0", "]", ")", "\n", "value", "=", "' '", ".", "join", "(", "tknz", "(", "s_v", "[", "1", "]", ")", ")", ".", "strip", "(", ")", "\n", "if", "slot", "in", "[", "'leave'", ",", "'arrive'", ",", "'time'", "]", ":", "\n", "                                    ", "value", "=", "clean_time", "(", "value", ")", "\n", "", "if", "'minute'", "in", "value", ":", "\n", "                                    ", "slot", "=", "'duration'", "\n", "", "dialog_act", "[", "act", "]", ".", "append", "(", "[", "slot", ",", "value", "]", ")", "\n", "if", "'request'", "in", "act", "and", "slot", "not", "in", "request", ":", "\n", "                                    ", "request", ".", "append", "(", "slot", ")", "\n", "", "elif", "'offerbook'", "in", "act", "and", "'book'", "not", "in", "request", ":", "\n", "                                    ", "request", ".", "append", "(", "'book'", ")", "\n", "", "elif", "slot", "!=", "'none'", "and", "slot", "not", "in", "inform", "and", "slot", "not", "in", "[", "'parking'", ",", "'internet'", "]", ":", "\n", "                                    ", "inform", ".", "append", "(", "'[value_%s]'", "%", "slot", ")", "\n", "\n", "", "", "", "", "resp", "=", "' '", ".", "join", "(", "tknz", "(", "clean_text", "(", "dial_turn", "[", "'text'", "]", ")", ")", ")", "\n", "resp_delex_all", "=", "self", ".", "delexicalization", "(", "resp", ",", "dialog_act", ")", "\n", "single_turn", "[", "'resp'", "]", "=", "resp_delex_all", "\n", "single_turn", "[", "'resp_ori'", "]", "=", "resp", "#self.delexicalization(resp, dialog_act, keep_list)", "\n", "single_turn", "[", "'name_from_db'", "]", "=", "name_from_db", "\n", "\n", "\n", "# ordered system act", "\n", "# request_ordered = {}", "\n", "# for slot in request:", "\n", "#     request_ordered[slot] = resp_delex_all.find(slot)", "\n", "#     if resp_delex_all.find(slot) == -1:", "\n", "#         print(fn, turn_num)", "\n", "#         print(resp_delex_all)", "\n", "#         print(slot)", "\n", "# request_ordered = sorted(request_ordered.items(), key=lambda x:x[1])", "\n", "request_ordered", "=", "request", "\n", "inform_ordered", "=", "{", "}", "\n", "for", "slot", "in", "inform", ":", "\n", "                        ", "inform_ordered", "[", "slot", "]", "=", "resp_delex_all", ".", "find", "(", "slot", ")", "\n", "# if resp_delex_all.find(slot) == -1:", "\n", "#     print(fn, turn_num)", "\n", "#     print(resp_delex_all)", "\n", "#     print(slot)", "\n", "", "inform_ordered", "=", "sorted", "(", "inform_ordered", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ")", "\n", "inform_ordered", "=", "[", "s", "[", "0", "]", "for", "s", "in", "inform_ordered", "]", "\n", "\n", "# get turn domain", "\n", "turn_dom_bs", "=", "[", "]", "\n", "for", "dom", ",", "info_slots", "in", "dial_state", ".", "items", "(", ")", ":", "\n", "                        ", "if", "info_slots", ":", "\n", "                            ", "if", "dom", "not", "in", "prev_dial_state", "or", "prev_dial_state", "[", "dom", "]", "!=", "dial_state", "[", "dom", "]", ":", "\n", "                                ", "turn_dom_bs", ".", "append", "(", "dom", ")", "\n", "\n", "", "", "", "turn_dom_da", "=", "set", "(", ")", "\n", "for", "act", "in", "dialog_act", ":", "\n", "                        ", "d", ",", "a", "=", "act", ".", "split", "(", "'-'", ")", "\n", "turn_dom_da", ".", "add", "(", "d", ")", "\n", "", "turn_dom_da", "=", "list", "(", "turn_dom_da", ")", "\n", "if", "len", "(", "turn_dom_da", ")", "!=", "1", "and", "'general'", "in", "turn_dom_da", ":", "\n", "                        ", "turn_dom_da", ".", "remove", "(", "'general'", ")", "\n", "", "if", "len", "(", "turn_dom_da", ")", "!=", "1", "and", "'booking'", "in", "turn_dom_da", ":", "\n", "                        ", "turn_dom_da", ".", "remove", "(", "'booking'", ")", "\n", "\n", "", "turn_domain", "=", "turn_dom_bs", "\n", "for", "dom", "in", "turn_dom_da", ":", "\n", "                        ", "if", "dom", "!=", "'booking'", "and", "dom", "not", "in", "turn_domain", ":", "\n", "                            ", "turn_domain", ".", "append", "(", "dom", ")", "\n", "", "", "if", "not", "turn_domain", ":", "\n", "                        ", "turn_domain", "=", "prev_turn_domain", "\n", "", "if", "len", "(", "turn_domain", ")", "==", "2", "and", "'general'", "in", "turn_domain", ":", "\n", "                        ", "turn_domain", ".", "remove", "(", "'general'", ")", "\n", "", "if", "len", "(", "turn_domain", ")", "==", "2", ":", "\n", "                        ", "if", "len", "(", "prev_turn_domain", ")", "==", "1", "and", "prev_turn_domain", "[", "0", "]", "==", "turn_domain", "[", "1", "]", ":", "\n", "                            ", "turn_domain", "=", "turn_domain", "[", ":", ":", "-", "1", "]", "\n", "\n", "# get db pointers", "\n", "", "", "matnums", "=", "self", ".", "db", ".", "get_match_num", "(", "dial_state", ")", "\n", "match_dom", "=", "turn_domain", "[", "0", "]", "if", "len", "(", "turn_domain", ")", "==", "1", "else", "turn_domain", "[", "1", "]", "\n", "match", "=", "matnums", "[", "match_dom", "]", "\n", "dbvec", "=", "self", ".", "db", ".", "addDBPointer", "(", "match_dom", ",", "match", ")", "\n", "bkvec", "=", "self", ".", "db", ".", "addBookingPointer", "(", "dialog_act", ")", "\n", "\n", "single_turn", "[", "'pointer'", "]", "=", "','", ".", "join", "(", "[", "str", "(", "d", ")", "for", "d", "in", "dbvec", "+", "bkvec", "]", ")", "\n", "single_turn", "[", "'match'", "]", "=", "str", "(", "match", ")", "\n", "single_turn", "[", "'constraint'", "]", "=", "json", ".", "dumps", "(", "dial_state", ")", ",", "\n", "single_turn", "[", "'sys_inform'", "]", "=", "' '", ".", "join", "(", "inform_ordered", ")", "\n", "single_turn", "[", "'sys_request'", "]", "=", "' '", ".", "join", "(", "request_ordered", ")", "\n", "single_turn", "[", "'turn_num'", "]", "=", "len", "(", "dial", "[", "'log'", "]", ")", "\n", "single_turn", "[", "'turn_domain'", "]", "=", "' '", ".", "join", "(", "turn_domain", ")", "\n", "\n", "\n", "prev_turn_domain", "=", "copy", ".", "deepcopy", "(", "turn_domain", ")", "\n", "prev_dial_state", "=", "copy", ".", "deepcopy", "(", "dial_state", ")", "\n", "if", "'user'", "in", "single_turn", ":", "\n", "                        ", "prev_user", "=", "copy", ".", "deepcopy", "(", "single_turn", "[", "'user'", "]", ")", "\n", "dial", "[", "'log'", "]", ".", "append", "(", "single_turn", ")", "\n", "for", "t", "in", "single_turn", "[", "'user'", "]", ".", "split", "(", ")", "+", "single_turn", "[", "'resp'", "]", ".", "split", "(", ")", ":", "\n", "                            ", "self", ".", "vocab", ".", "add_word", "(", "t", ")", "\n", "\n", "", "", "single_turn", "=", "{", "}", "\n", "\n", "", "", "data", "[", "fn", "]", "=", "dial", "\n", "# pprint(dial)", "\n", "# if count == 20:", "\n", "#     break", "\n", "", "self", ".", "vocab", ".", "construct", "(", ")", "\n", "self", ".", "vocab", ".", "save_vocab", "(", "self", ".", "save_path", "+", "'vocab'", ")", "\n", "with", "open", "(", "self", ".", "save_path", "+", "'data_processed.json'", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "data", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "with", "open", "(", "self", ".", "save_path", "+", "'ontology_values.json'", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "self", ".", "otlg_values", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.clean_time": [[17, 25], ["re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "re.sub", "x.group", "x.group", "str", "str", "x.group", "int", "int", "x.group", "x.group"], "function", ["None"], ["def", "clean_time", "(", "utter", ")", ":", "\n", "        ", "utter", "=", "re", ".", "sub", "(", "r'(\\d+) ([ap]\\.?m)'", ",", "lambda", "x", ":", "x", ".", "group", "(", "1", ")", "+", "x", ".", "group", "(", "2", ")", ",", "utter", ")", "# 9 am -> 9am", "\n", "utter", "=", "re", ".", "sub", "(", "r'((?<!\\d)\\d:\\d+)(am)?'", ",", "r'0\\1'", ",", "utter", ")", "\n", "utter", "=", "re", ".", "sub", "(", "r'((?<!\\d)\\d)am'", ",", "r'0\\1:00'", ",", "utter", ")", "\n", "utter", "=", "re", ".", "sub", "(", "r'((?<!\\d)\\d)pm'", ",", "lambda", "x", ":", "str", "(", "int", "(", "x", ".", "group", "(", "1", ")", ")", "+", "12", ")", "+", "':00'", ",", "utter", ")", "\n", "utter", "=", "re", ".", "sub", "(", "r'(\\d+)(:\\d+)pm'", ",", "lambda", "x", ":", "str", "(", "int", "(", "x", ".", "group", "(", "1", ")", ")", "+", "12", ")", "+", "x", ".", "group", "(", "2", ")", ",", "utter", ")", "\n", "utter", "=", "re", ".", "sub", "(", "r'(\\d+)a\\.?m'", ",", "r'\\1'", ",", "utter", ")", "\n", "return", "utter", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.clean_text": [[26, 73], ["re.sub.strip", "re.sub.lower", "re.sub.replace", "re.sub.replace", "re.sub.replace", "re.sub.replace", "re.sub.replace", "re.sub.replace", "multiwoz_preprocess.clean_time", "baddata.items", "re.sub", "re.sub", "re.sub"], "function", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.multiwoz_preprocess.clean_time"], ["", "def", "clean_text", "(", "text", ")", ":", "\n", "\n", "    ", "text", "=", "text", ".", "strip", "(", ")", "\n", "text", "=", "text", ".", "lower", "(", ")", "\n", "text", "=", "text", ".", "replace", "(", "u\"\u2019\"", ",", "\"'\"", ")", "\n", "text", "=", "text", ".", "replace", "(", "u\"\u2018\"", ",", "\"'\"", ")", "\n", "text", "=", "text", ".", "replace", "(", "';'", ",", "','", ")", "\n", "text", "=", "text", ".", "replace", "(", "'\"'", ",", "' '", ")", "\n", "text", "=", "text", ".", "replace", "(", "'/'", ",", "' and '", ")", "\n", "text", "=", "text", ".", "replace", "(", "\"don't\"", ",", "\"do n't\"", ")", "\n", "text", "=", "clean_time", "(", "text", ")", "\n", "baddata", "=", "{", "r'c\\.b (\\d), (\\d) ([a-z])\\.([a-z])'", ":", "r'cb\\1\\2\\3\\4'", ",", "\n", "'c.b. 1 7 d.y'", ":", "'cb17dy'", ",", "\n", "'c.b.1 7 d.y'", ":", "'cb17dy'", ",", "\n", "'c.b 25, 9 a.q'", ":", "'cb259aq'", ",", "\n", "'isc.b 25, 9 a.q'", ":", "'is cb259aq'", ",", "\n", "'c.b2, 1 u.f'", ":", "'cb21uf'", ",", "\n", "'c.b 1,2 q.a'", ":", "'cb12qa'", ",", "\n", "'0-122-336-5664'", ":", "'01223365664'", ",", "\n", "'postcodecb21rs'", ":", "'postcode cb21rs'", ",", "\n", "r'i\\.d'", ":", "'id'", ",", "\n", "' i d '", ":", "'id'", ",", "\n", "'Telephone:01223358966'", ":", "'Telephone: 01223358966'", ",", "\n", "'depature'", ":", "'departure'", ",", "\n", "'depearting'", ":", "'departing'", ",", "\n", "'-type'", ":", "' type'", ",", "\n", "# r\"b[\\s]?&[\\s]?b\": \"bed and breakfast\",", "\n", "# \"b and b\": \"bed and breakfast\",", "\n", "# r\"guesthouse[s]?\": \"guest house\",", "\n", "# r\"swimmingpool[s]?\": \"swimming pool\",", "\n", "# \"wo n\\'t\": \"will not\",", "\n", "# \" \\'d \": \" would \",", "\n", "# \" \\'m \": \" am \",", "\n", "# \" \\'re' \": \" are \",", "\n", "# \" \\'ll' \": \" will \",", "\n", "# \" \\'ve \": \" have \",", "\n", "r'(\\d+),(\\d+)'", ":", "r'\\1\\2'", ",", "\n", "r'^\\''", ":", "''", ",", "\n", "r'\\'$'", ":", "''", ",", "\n", "}", "\n", "for", "tmpl", ",", "good", "in", "baddata", ".", "items", "(", ")", ":", "\n", "        ", "text", "=", "re", ".", "sub", "(", "tmpl", ",", "good", ",", "text", ")", "\n", "\n", "", "text", "=", "re", ".", "sub", "(", "r'([a-zT]+)\\.([a-z])'", ",", "r'\\1 . \\2'", ",", "text", ")", "# 'abc.xyz' -> 'abc . xyz'", "\n", "text", "=", "re", ".", "sub", "(", "r'(\\d+)\\.\\.? '", ",", "r'\\1 . '", ",", "text", ")", "# if 'abc. ' -> 'abc . '", "\n", "\n", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.__init__": [[22, 45], ["model_mapping.get", "train.Model.model_fun", "reader.CamRest676Reader", "metric.CamRestEvaluator", "ValueError", "train.Model.model.cuda", "reader.MultiwozReader", "metric.MultiwozEvaluator", "reader.KvretReader", "metric.KvretEvaluator", "NotImplementedError"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dataset", ",", "method", ")", ":", "\n", "        ", "self", ".", "dataset", "=", "dataset", "\n", "if", "dataset", "==", "'camrest'", ":", "\n", "            ", "self", ".", "reader", "=", "CamRest676Reader", "(", ")", "\n", "self", ".", "evaluator", "=", "CamRestEvaluator", "(", "self", ".", "reader", ")", "\n", "", "elif", "dataset", "==", "'multiwoz'", ":", "\n", "            ", "self", ".", "reader", "=", "MultiwozReader", "(", ")", "\n", "self", ".", "evaluator", "=", "MultiwozEvaluator", "(", "self", ".", "reader", ")", "\n", "", "elif", "dataset", "==", "'kvret'", ":", "\n", "            ", "self", ".", "reader", "=", "KvretReader", "(", ")", "\n", "self", ".", "evaluator", "=", "KvretEvaluator", "(", "self", ".", "reader", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Other datasets to be implemented !'", ")", "\n", "\n", "", "self", ".", "method", "=", "method", "\n", "self", ".", "model_fun", "=", "model_mapping", ".", "get", "(", "self", ".", "method", ",", "None", ")", "\n", "if", "self", ".", "model_fun", "is", "None", ":", "\n", "            ", "raise", "ValueError", "(", "'Unimplemented method'", ")", "\n", "", "self", ".", "model", "=", "self", ".", "model_fun", "(", "cfg", "=", "cfg", ",", "reader", "=", "self", ".", "reader", ")", "\n", "if", "cfg", ".", "cuda", ":", "self", ".", "model", "=", "self", ".", "model", ".", "cuda", "(", ")", "\n", "\n", "self", ".", "unsup_prop", "=", "0", "if", "cfg", ".", "skip_unsup", "else", "100", "-", "cfg", ".", "spv_proportion", "\n", "self", ".", "final_epoch", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model._convert_batch": [[46, 78], ["utils.padSeqs", "utils.padSeqs", "torch.from_numpy().float", "torch.from_numpy().float", "torch.from_numpy().long", "torch.from_numpy().long", "filling_vec.cuda.cuda.cuda", "utils.padSeqs", "torch.from_numpy().long", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy().long.cuda", "torch.from_numpy().long.cuda", "torch.from_numpy().float.cuda", "z_input[].cuda", "utils.padSeqs", "torch.from_numpy().long", "numpy.array", "numpy.array", "torch.from_numpy", "a_input[].cuda", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.padSeqs", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.padSeqs", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.padSeqs", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.padSeqs"], ["", "def", "_convert_batch", "(", "self", ",", "py_batch", ")", ":", "\n", "        ", "u_input_np", "=", "utils", ".", "padSeqs", "(", "py_batch", "[", "'user'", "]", ",", "cfg", ".", "u_max_len", ",", "truncated", "=", "True", ")", "\n", "m_input_np", "=", "utils", ".", "padSeqs", "(", "py_batch", "[", "'resp'", "]", ",", "cfg", ".", "m_max_len", ",", "truncated", "=", "True", ")", "\n", "db_vec", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "py_batch", "[", "'db_vec'", "]", ")", ")", ".", "float", "(", ")", "\n", "filling_vec", "=", "torch", ".", "from_numpy", "(", "np", ".", "array", "(", "py_batch", "[", "'filling_vec'", "]", ")", ")", ".", "float", "(", ")", "\n", "u_input", "=", "torch", ".", "from_numpy", "(", "u_input_np", ")", ".", "long", "(", ")", "\n", "m_input", "=", "torch", ".", "from_numpy", "(", "m_input_np", ")", ".", "long", "(", ")", "\n", "if", "cfg", ".", "cuda", ":", "\n", "            ", "u_input", ",", "m_input", ",", "db_vec", "=", "u_input", ".", "cuda", "(", ")", ",", "m_input", ".", "cuda", "(", ")", ",", "db_vec", ".", "cuda", "(", ")", "\n", "filling_vec", "=", "filling_vec", ".", "cuda", "(", ")", "\n", "", "z_input", "=", "{", "}", "\n", "for", "sn", "in", "self", ".", "reader", ".", "otlg", ".", "informable_slots", ":", "\n", "# eos_idx = self.reader.vocab.encode(sn)", "\n", "            ", "z_input_py", "=", "[", "state", "[", "sn", "]", "for", "state", "in", "py_batch", "[", "'bspn'", "]", "]", "\n", "z_input_np", "=", "utils", ".", "padSeqs", "(", "z_input_py", ",", "maxlen", "=", "cfg", ".", "z_length", ",", "fixed_length", "=", "True", ")", "#,  value=eos_idx)", "\n", "# z_input_np = utils.padSeqs(z_input_py, maxlen=cfg.z_length)#,  value=eos_idx)", "\n", "z_input", "[", "sn", "]", "=", "torch", ".", "from_numpy", "(", "z_input_np", ")", ".", "long", "(", ")", "\n", "if", "cfg", ".", "cuda", ":", "\n", "                ", "z_input", "[", "sn", "]", "=", "z_input", "[", "sn", "]", ".", "cuda", "(", ")", "\n", "", "", "if", "cfg", ".", "model_act", ":", "\n", "            ", "a_input", "=", "{", "}", "\n", "for", "sn", "in", "self", ".", "reader", ".", "act_order", ":", "\n", "                ", "a_input_py", "=", "[", "act", "[", "sn", "]", "for", "act", "in", "py_batch", "[", "'aspn'", "]", "]", "\n", "a_input_np", "=", "utils", ".", "padSeqs", "(", "a_input_py", ",", "maxlen", "=", "cfg", ".", "a_length", ",", "fixed_length", "=", "True", ")", "#,  value=eos_idx)", "\n", "# a_input_np = utils.padSeqs(a_input_py, maxlen=cfg.a_length)#,  value=eos_idx)", "\n", "a_input", "[", "sn", "]", "=", "torch", ".", "from_numpy", "(", "a_input_np", ")", ".", "long", "(", ")", "\n", "if", "cfg", ".", "cuda", ":", "\n", "                    ", "a_input", "[", "sn", "]", "=", "a_input", "[", "sn", "]", ".", "cuda", "(", ")", "\n", "", "", "", "else", ":", "\n", "            ", "a_input", "=", "{", "}", "\n", "", "supervised", "=", "py_batch", "[", "'supervised'", "]", "[", "0", "]", "\n", "return", "u_input", ",", "z_input", ",", "a_input", ",", "m_input", ",", "db_vec", ",", "filling_vec", ",", "supervised", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train": [[80, 247], ["time.time", "torch.optim.Adam", "range", "logging.info", "train.Model.model.self_adjust", "random.shuffle", "enumerate", "logging.info", "train.Model.validate", "train_loss_col.append", "valid_loss_col.append", "valid_score_col.append", "logging.info", "train.Model.validate", "train.Model.load_model", "logging.info", "train.Model.reader.save_result_report", "filter", "enumerate", "event_col.append", "logging.info", "train.Model.save_model", "os.path.join", "train.Model.eval", "train.Model.reader.save_loss", "logging.FileHandler", "logging.getLogger().addHandler", "logging.info", "train.Model.eval", "train.Model.reader.save_loss", "train.Model.model.parameters", "torch.optim.Adam.zero_grad", "train.Model._convert_batch", "train.Model.save_model", "event_col.append", "logging.info", "event_col.append", "event_col.append", "os.path.join", "str", "train.Model.model", "torch.optim.Adam.step", "losses.items", "train.Model.model", "torch.optim.Adam.step", "losses.items", "logging.info", "train.Model.validate", "os.path.join", "logging.getLogger", "total_loss.backward", "total_loss.backward", "logging.info", "total_loss.backward", "total_loss.backward", "logging.info", "v.item", "v.item", "time.time", "v.item", "v.item", "losses[].item", "total_loss.item", "losses[].item", "losses[].item", "total_loss.item", "len", "len"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.self_adjust", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.validate", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.validate", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_model", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader.save_result_report", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.save_model", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.eval", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.save_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.eval", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.save_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model._convert_batch", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.save_model", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.validate"], ["", "def", "train", "(", "self", ",", "pretrain", "=", "False", ",", "skip_sup", "=", "False", ")", ":", "\n", "        ", "self", ".", "final_epoch", "=", "0", "\n", "prev_min_loss", ",", "early_stop_count", "=", "1e9", ",", "cfg", ".", "early_stop_count", "\n", "weight_decay_count", "=", "cfg", ".", "weight_decay_count", "\n", "st", "=", "time", ".", "time", "(", ")", "\n", "lr", "=", "cfg", ".", "lr", "\n", "optim", "=", "torch", ".", "optim", ".", "Adam", "(", "lr", "=", "cfg", ".", "lr", ",", "params", "=", "filter", "(", "lambda", "x", ":", "x", ".", "requires_grad", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", ")", "\n", "# optim = torch.optim.SGD(lr=cfg.lr, params=filter(lambda x: x.requires_grad, self.model.parameters()))", "\n", "train_loss_col", ",", "valid_loss_col", ",", "valid_score_col", ",", "event_col", "=", "[", "]", ",", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "max_epoch", "=", "cfg", ".", "sup_pretrain", "if", "pretrain", "else", "cfg", ".", "max_epoch", "\n", "mode", "=", "'train'", "if", "cfg", ".", "mode", "!=", "'rl_tune'", "else", "'rl_tune'", "\n", "for", "epoch", "in", "range", "(", "max_epoch", ")", ":", "\n", "            ", "logging", ".", "info", "(", "'************ epoch: %d ************'", "%", "(", "epoch", ")", ")", "\n", "self", ".", "model", ".", "self_adjust", "(", "epoch", ")", "\n", "epoch_sup_loss", ",", "epoch_unsup_loss", "=", "{", "'loss'", ":", "0", "}", ",", "{", "'loss'", ":", "0", "}", "\n", "sup_cnt", ",", "unsup_cnt", "=", "0", ",", "0", "\n", "random", ".", "shuffle", "(", "self", ".", "reader", ".", "batches", "[", "'train'", "]", ")", "\n", "for", "iter_num", ",", "dial_batch", "in", "enumerate", "(", "self", ".", "reader", ".", "batches", "[", "'train'", "]", ")", ":", "\n", "                ", "turn_states", "=", "{", "}", "\n", "for", "turn_num", ",", "turn_batch", "in", "enumerate", "(", "dial_batch", ")", ":", "\n", "# print('epoch:', epoch, 'dial:', iter_num,'turn:', turn_num)", "\n", "                    ", "optim", ".", "zero_grad", "(", ")", "\n", "u_input", ",", "z_input", ",", "a_input", ",", "m_input", ",", "db_vec", ",", "filling_vec", ",", "supervised", "=", "self", ".", "_convert_batch", "(", "turn_batch", ")", "\n", "if", "cfg", ".", "multi_domain", ":", "\n", "                        ", "turn_states", "[", "'dom'", "]", "=", "turn_batch", "[", "'dom'", "]", "\n", "", "if", "supervised", ":", "\n", "                        ", "if", "skip_sup", ":", "\n", "                            ", "continue", "\n", "", "losses", ",", "turn_states", "=", "self", ".", "model", "(", "u_input", "=", "u_input", ",", "z_input", "=", "z_input", ",", "m_input", "=", "m_input", ",", "\n", "db_vec", "=", "db_vec", ",", "filling_vec", "=", "filling_vec", ",", "\n", "z_supervised", "=", "True", ",", "turn_states", "=", "turn_states", ",", "mode", "=", "mode", ",", "\n", "a_input", "=", "a_input", ")", "\n", "total_loss", "=", "losses", "[", "'loss'", "]", "\n", "if", "cfg", ".", "prev_z_continuous", ":", "\n", "                            ", "total_loss", ".", "backward", "(", "retain_graph", "=", "turn_num", "!=", "len", "(", "dial_batch", ")", "-", "1", ")", "\n", "", "else", ":", "\n", "                            ", "total_loss", ".", "backward", "(", "retain_graph", "=", "False", ")", "\n", "# grad = torch.nn.utils.clip_grad_norm_(self.model.parameters(),5.0)", "\n", "", "optim", ".", "step", "(", ")", "\n", "# torch.cuda.empty_cache()", "\n", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", ":", "\n", "                            ", "if", "k", "==", "'reward'", ":", "continue", "\n", "epoch_sup_loss", "[", "k", "]", "=", "v", ".", "item", "(", ")", "if", "k", "not", "in", "epoch_sup_loss", "else", "epoch_sup_loss", "[", "k", "]", "+", "v", ".", "item", "(", ")", "\n", "", "sup_cnt", "+=", "1", "\n", "\n", "loss_log", "=", "''", "\n", "for", "k", "in", "[", "'pz'", ",", "'qz'", ",", "'pa'", ",", "'qa'", ",", "'m'", ",", "'kl'", ",", "'kl_a'", "]", ":", "\n", "                            ", "if", "k", "+", "'_loss'", "in", "losses", ":", "\n", "                                ", "loss_log", "+=", "'|%s: %.3f'", "%", "(", "k", ",", "losses", "[", "k", "+", "'_loss'", "]", ".", "item", "(", ")", ")", "\n", "", "", "if", "'reward'", "in", "losses", ":", "\n", "                            ", "loss_log", "+=", "'|reward: %.5f'", "%", "(", "losses", "[", "'reward'", "]", ")", "\n", "", "if", "cfg", ".", "dataset", "!=", "'multiwoz'", "or", "iter_num", "%", "5", "==", "0", ":", "\n", "                            ", "logging", ".", "info", "(", "'%d super loss: %.3f%s'", "%", "(", "iter_num", ",", "total_loss", ".", "item", "(", ")", ",", "loss_log", ")", ")", "\n", "\n", "", "", "else", ":", "\n", "                        ", "if", "cfg", ".", "skip_unsup", "or", "pretrain", ":", "\n", "#logging.info('skipping unsupervised batch')", "\n", "                            ", "continue", "\n", "", "losses", ",", "turn_states", "=", "self", ".", "model", "(", "u_input", "=", "u_input", ",", "z_input", "=", "z_input", ",", "m_input", "=", "m_input", ",", "\n", "z_supervised", "=", "False", ",", "turn_states", "=", "turn_states", ",", "mode", "=", "mode", ",", "\n", "a_input", "=", "a_input", ",", "db_vec", "=", "db_vec", ",", "filling_vec", "=", "filling_vec", ",", "\n", "no_label_train", "=", "cfg", ".", "no_label_train", ")", "\n", "total_loss", "=", "losses", "[", "'loss'", "]", "\n", "if", "cfg", ".", "prev_z_continuous", ":", "\n", "                            ", "total_loss", ".", "backward", "(", "retain_graph", "=", "turn_num", "!=", "len", "(", "dial_batch", ")", "-", "1", ")", "\n", "", "else", ":", "\n", "                            ", "total_loss", ".", "backward", "(", "retain_graph", "=", "False", ")", "\n", "# grad = torch.nn.utils.clip_grad_norm_(self.model.parameters(),4.0)", "\n", "", "optim", ".", "step", "(", ")", "\n", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", ":", "\n", "                            ", "if", "k", "==", "'reward'", ":", "continue", "\n", "epoch_unsup_loss", "[", "k", "]", "=", "v", ".", "item", "(", ")", "if", "k", "not", "in", "epoch_unsup_loss", "else", "epoch_unsup_loss", "[", "k", "]", "+", "v", ".", "item", "(", ")", "\n", "", "unsup_cnt", "+=", "1", "\n", "loss_log", "=", "''", "\n", "for", "k", "in", "[", "'pz'", ",", "'qz'", ",", "'pa'", ",", "'qa'", ",", "'m'", "]", ":", "\n", "                            ", "if", "k", "+", "'_loss'", "in", "losses", ":", "\n", "                                ", "loss_log", "+=", "'|%s: %.3f'", "%", "(", "k", ",", "losses", "[", "k", "+", "'_loss'", "]", ".", "item", "(", ")", ")", "\n", "", "", "for", "k", "in", "[", "'kl'", ",", "'kl_a'", "]", ":", "\n", "                            ", "if", "k", "+", "'_loss'", "in", "losses", ":", "\n", "                                ", "loss_log", "+=", "'|%s: %.5f'", "%", "(", "k", ",", "losses", "[", "k", "+", "'_loss'", "]", ".", "item", "(", ")", ")", "\n", "", "", "if", "'reward'", "in", "losses", ":", "\n", "                            ", "loss_log", "+=", "'|reward: %.5f'", "%", "(", "losses", "[", "'reward'", "]", ")", "\n", "", "if", "cfg", ".", "dataset", "!=", "'multiwoz'", "or", "iter_num", "%", "5", "==", "0", ":", "\n", "                            ", "logging", ".", "info", "(", "'%d unsup loss: %.3f%s'", "%", "(", "iter_num", ",", "total_loss", ".", "item", "(", ")", ",", "loss_log", ")", ")", "\n", "\n", "# if epoch>5:", "\n", "# print(turn_states['norm_W'])", "\n", "", "", "", "", "train_loss", "=", "{", "}", "\n", "for", "k", "in", "epoch_sup_loss", ":", "\n", "                ", "train_loss", "[", "'sup_'", "+", "k", "]", "=", "epoch_sup_loss", "[", "k", "]", "/", "(", "sup_cnt", "+", "1e-8", ")", "\n", "", "if", "'m_loss'", "in", "epoch_sup_loss", "and", "'pz_loss'", "in", "epoch_sup_loss", ":", "\n", "                ", "train_loss", "[", "'sup_p_joint_nll'", "]", "=", "train_loss", "[", "'sup_m_loss'", "]", "+", "train_loss", "[", "'sup_pz_loss'", "]", "\n", "", "for", "k", "in", "epoch_unsup_loss", ":", "\n", "                ", "train_loss", "[", "'unsup_'", "+", "k", "]", "=", "epoch_unsup_loss", "[", "k", "]", "/", "(", "unsup_cnt", "+", "1e-8", ")", "\n", "", "if", "'m_loss'", "in", "epoch_unsup_loss", "and", "'pz_loss'", "in", "epoch_unsup_loss", ":", "\n", "                ", "train_loss", "[", "'unsup_p_joint_nll'", "]", "=", "train_loss", "[", "'unsup_m_loss'", "]", "+", "train_loss", "[", "'unsup_pz_loss'", "]", "\n", "\n", "", "logging", ".", "info", "(", "'epoch: %d  train loss sup: %.3f  unsup: %.3f  total time: %.1fmin'", "%", "(", "\n", "epoch", "+", "1", ",", "train_loss", "[", "'sup_loss'", "]", ",", "train_loss", "[", "'unsup_loss'", "]", ",", "(", "time", ".", "time", "(", ")", "-", "st", ")", "/", "60", ")", ")", "\n", "\n", "# do validation", "\n", "valid_loss", ",", "valid_score", "=", "self", ".", "validate", "(", ")", "\n", "train_loss_col", ".", "append", "(", "train_loss", ")", "\n", "valid_loss_col", ".", "append", "(", "valid_loss", ")", "\n", "valid_score_col", ".", "append", "(", "valid_score", ")", "\n", "\n", "logging", ".", "info", "(", "'*************** RUNNING TEST ***************'", ")", "\n", "_", ",", "_", "=", "self", ".", "validate", "(", "data", "=", "'test'", ")", "\n", "\n", "if", "'loss'", "in", "cfg", ".", "valid_type", ":", "\n", "                ", "valid_loss_check", "=", "valid_loss", "[", "cfg", ".", "valid_type", "]", "\n", "if", "cfg", ".", "model_act", "and", "cfg", ".", "valid_type", "==", "'loss'", ":", "\n", "                    ", "valid_loss_check", "-=", "valid_loss", "[", "'pa_loss'", "]", "\n", "", "", "else", ":", "\n", "                ", "valid_loss_check", "=", "-", "valid_score", "[", "cfg", ".", "valid_type", "]", "#scores are the higher the better", "\n", "\n", "", "if", "valid_loss_check", "<", "prev_min_loss", ":", "\n", "                ", "early_stop_count", "=", "cfg", ".", "early_stop_count", "\n", "weight_decay_count", "=", "cfg", ".", "weight_decay_count", "\n", "if", "epoch", ">=", "cfg", ".", "min_epoch", ":", "\n", "                    ", "prev_min_loss", "=", "valid_loss_check", "\n", "best_valid_loss", "=", "valid_loss", "\n", "self", ".", "save_model", "(", "epoch", ")", "\n", "if", "epoch", ">", "10", "and", "not", "cfg", ".", "save_log", ":", "#only for debug", "\n", "                        ", "logging", ".", "info", "(", "'*************** RUNNING TEST ***************'", ")", "\n", "_", ",", "_", "=", "self", ".", "validate", "(", "data", "=", "'test'", ")", "\n", "", "", "event_col", ".", "append", "(", "''", ")", "\n", "", "else", ":", "\n", "                ", "early_stop_count", "-=", "1", "\n", "weight_decay_count", "-=", "1", "\n", "logging", ".", "info", "(", "'epoch: %d early stop countdown %d'", "%", "(", "epoch", "+", "1", ",", "early_stop_count", ")", ")", "\n", "if", "not", "early_stop_count", ":", "\n", "                    ", "event_col", ".", "append", "(", "'early stop'", ")", "\n", "self", ".", "final_epoch", "=", "epoch", "+", "1", "\n", "break", "\n", "", "if", "not", "weight_decay_count", ":", "\n", "                    ", "lr", "*=", "cfg", ".", "lr_decay", "\n", "for", "group", "in", "optim", ".", "param_groups", ":", "\n", "                        ", "group", "[", "'lr'", "]", "=", "lr", "\n", "", "weight_decay_count", "=", "cfg", ".", "weight_decay_count", "\n", "logging", ".", "info", "(", "'learning rate decay, learning rate: %f'", "%", "(", "lr", ")", ")", "\n", "event_col", ".", "append", "(", "'lr decay: %.6f'", "%", "lr", ")", "\n", "", "else", ":", "\n", "                    ", "event_col", ".", "append", "(", "''", ")", "\n", "\n", "", "", "", "if", "cfg", ".", "save_log", "and", "max_epoch", "!=", "0", ":", "# Do evaluation and save result report", "\n", "            ", "self", ".", "load_model", "(", ")", "\n", "self", ".", "final_epoch", "=", "epoch", "+", "1", "\n", "logging", ".", "info", "(", "'Total training epoch number: %d'", "%", "(", "self", ".", "final_epoch", ")", ")", "\n", "if", "pretrain", ":", "\n", "                ", "self", ".", "save_model", "(", "epoch", ",", "path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "'pretrained_model.pkl'", ")", ")", "\n", "pretrain_result_save", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "eval_load_path", ",", "'sup_pretrained_results.csv'", ")", "\n", "metric_results", "=", "self", ".", "eval", "(", "result_save_path", "=", "pretrain_result_save", ")", "\n", "report_path", "=", "cfg", ".", "global_record_path", "[", ":", "-", "4", "]", "+", "'_pretrain.csv'", "\n", "self", ".", "reader", ".", "save_loss", "(", "train_loss_col", ",", "valid_loss_col", ",", "event_col", ",", "file_name", "=", "'loss_pretrain.csv'", ")", "\n", "", "else", ":", "\n", "                ", "file_handler", "=", "logging", ".", "FileHandler", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "'eval_log.json'", ")", ")", "\n", "logging", ".", "getLogger", "(", "''", ")", ".", "addHandler", "(", "file_handler", ")", "\n", "logging", ".", "info", "(", "str", "(", "cfg", ")", ")", "\n", "metric_results", "=", "self", ".", "eval", "(", "result_save_path", "=", "cfg", ".", "result_path", ")", "\n", "report_path", "=", "cfg", ".", "global_record_path", "\n", "self", ".", "reader", ".", "save_loss", "(", "train_loss_col", ",", "valid_loss_col", ",", "event_col", ",", "file_name", "=", "'loss.csv'", ")", "\n", "", "metric_results", "[", "'final_train_loss'", "]", "=", "train_loss", "\n", "metric_results", "[", "'best_valid_loss'", "]", "=", "best_valid_loss", "\n", "\n", "self", ".", "reader", ".", "save_result_report", "(", "metric_results", ",", "report_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.validate": [[249, 309], ["train.Model.model.eval", "train.Model.model.train", "torch.no_grad", "logging.info", "logging.info", "logging.info", "train.Model.reader.wrap_result", "train.Model.evaluator.run_metrics", "enumerate", "result_collection.update", "train.Model._convert_batch", "train.Model.model", "losses.items", "train.Model.model", "train.Model.reader.inverse_transpose_batch", "v.item", "v.item"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.eval", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.wrap_result", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.run_metrics", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model._convert_batch", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.inverse_transpose_batch"], ["", "", "def", "validate", "(", "self", ",", "data", "=", "'dev'", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "result_collection", "=", "{", "}", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "loss_col", ",", "count", "=", "{", "}", ",", "0", "\n", "logging", ".", "info", "(", "'begin validation'", ")", "\n", "for", "dial_batch", "in", "self", ".", "reader", ".", "batches", "[", "data", "]", ":", "\n", "                ", "turn_states", ",", "turn_states_loss", "=", "{", "}", ",", "{", "}", "\n", "for", "turn_num", ",", "turn_batch", "in", "enumerate", "(", "dial_batch", ")", ":", "\n", "                    ", "u_input", ",", "z_input", ",", "a_input", ",", "m_input", ",", "db_vec", ",", "filling_vec", ",", "supervised", "=", "self", ".", "_convert_batch", "(", "turn_batch", ")", "\n", "if", "cfg", ".", "multi_domain", ":", "\n", "                        ", "turn_states_loss", "[", "'dom'", "]", "=", "turn_batch", "[", "'dom'", "]", "\n", "turn_states", "[", "'dom'", "]", "=", "turn_batch", "[", "'dom'", "]", "\n", "# print('turn_num:', turn_num)", "\n", "", "losses", ",", "turn_states_loss", "=", "self", ".", "model", "(", "u_input", "=", "u_input", ",", "z_input", "=", "z_input", ",", "m_input", "=", "m_input", ",", "\n", "z_supervised", "=", "True", ",", "turn_states", "=", "turn_states_loss", ",", "mode", "=", "'loss_eval'", ",", "\n", "a_input", "=", "a_input", ",", "db_vec", "=", "db_vec", ",", "filling_vec", "=", "filling_vec", ")", "\n", "\n", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", ":", "\n", "                        ", "if", "k", "==", "'reward'", ":", "continue", "\n", "loss_col", "[", "k", "]", "=", "v", ".", "item", "(", ")", "if", "k", "not", "in", "loss_col", "else", "loss_col", "[", "k", "]", "+", "v", ".", "item", "(", ")", "\n", "", "count", "+=", "1", "\n", "index", ",", "db", ",", "turn_states", "=", "self", ".", "model", "(", "mode", "=", "'test'", ",", "u_input", "=", "u_input", ",", "z_input", "=", "z_input", ",", "\n", "m_input", "=", "m_input", ",", "z_supervised", "=", "None", ",", "turn_states", "=", "turn_states", ",", "\n", "a_input", "=", "a_input", ",", "db_vec", "=", "db_vec", ",", "filling_vec", "=", "filling_vec", ",", ")", "\n", "turn_batch", "[", "'resp_gen'", "]", ",", "turn_batch", "[", "'bspn_gen'", "]", ",", "turn_batch", "[", "'db_gen'", "]", "=", "index", "[", "'m_idx'", "]", ",", "index", "[", "'z_idx'", "]", ",", "db", "\n", "if", "cfg", ".", "model_act", ":", "\n", "                        ", "turn_batch", "[", "'aspn_gen'", "]", "=", "index", "[", "'a_idx'", "]", "\n", "#     print(self.reader.vocab.sentence_decode(z_input['food'][0]),self.reader.vocab.sentence_decode(z_input['pricerange'][0]),self.reader.vocab.sentence_decode(z_input['area'][0]))", "\n", "#     print(self.reader.vocab.sentence_decode(z_idx[0]))", "\n", "#     print('')", "\n", "#     print(self.reader.vocab.sentence_decode(z_input['food'][1]),self.reader.vocab.sentence_decode(z_input['pricerange'][1]),self.reader.vocab.sentence_decode(z_input['area'][1]))", "\n", "#     print(self.reader.vocab.sentence_decode(z_idx[1]))", "\n", "# print('')", "\n", "", "", "result_collection", ".", "update", "(", "self", ".", "reader", ".", "inverse_transpose_batch", "(", "dial_batch", ")", ")", "\n", "\n", "", "for", "k", "in", "loss_col", ":", "\n", "                ", "loss_col", "[", "k", "]", "/=", "(", "count", "+", "1e-8", ")", "\n", "", "loss_log", "=", "''", "\n", "for", "k", "in", "[", "'pz'", ",", "'qz'", ",", "'pa'", ",", "'qa'", ",", "'m'", ",", "'kl'", ",", "'kl_a'", "]", ":", "\n", "                ", "if", "k", "+", "'_loss'", "in", "losses", ":", "loss_log", "+=", "'|%s: %.3f'", "%", "(", "k", ",", "loss_col", "[", "k", "+", "'_loss'", "]", ")", "\n", "", "logging", ".", "info", "(", "'valid loss: %.3f%s'", "%", "(", "loss_col", "[", "'loss'", "]", ",", "loss_log", ")", ")", "\n", "\n", "logging", ".", "info", "(", "'validation metric scores:'", ")", "\n", "results", ",", "field", "=", "self", ".", "reader", ".", "wrap_result", "(", "result_collection", ")", "\n", "metrics", "=", "self", ".", "evaluator", ".", "run_metrics", "(", "results", ")", "\n", "combined", "=", "metrics", "[", "'bleu'", "]", "+", "metrics", "[", "'match'", "]", "/", "3", "+", "metrics", "[", "'joint_goal'", "]", "\n", "score", "=", "{", "'bleu'", ":", "metrics", "[", "'bleu'", "]", ",", "'match'", ":", "metrics", "[", "'match'", "]", ",", "'joint_goal'", ":", "metrics", "[", "'joint_goal'", "]", ",", "\n", "'combined'", ":", "combined", "}", "\n", "# metrics['epoch_num'] = self.final_epoch", "\n", "# metrics['test_loss'] = loss_col", "\n", "# metric_field = list(metrics.keys())", "\n", "# self.reader.save_result('w', [metrics], metric_field, write_title='EVALUATION RESULTS:',", "\n", "#                                     result_save_path=cfg.result_path)", "\n", "# self.reader.save_result('a', results, field, write_title='DECODED RESULTS:',", "\n", "#                                     result_save_path=cfg.result_path)", "\n", "# self.eval()", "\n", "", "self", ".", "model", ".", "train", "(", ")", "\n", "return", "loss_col", ",", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.eval": [[311, 352], ["train.Model.reader.wrap_result", "train.Model.evaluator.run_metrics", "list", "train.Model.reader.save_result", "train.Model.reader.save_result", "train.Model.model.train", "torch.no_grad", "train.Model.model.eval", "logging.info", "enumerate", "train.Model.keys", "result_collection.update", "train.Model._convert_batch", "train.Model.model", "losses.items", "train.Model.model", "train.Model.reader.inverse_transpose_batch", "v.item", "v.item"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.wrap_result", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.run_metrics", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.save_result", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.save_result", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.eval", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model._convert_batch", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.inverse_transpose_batch"], ["", "def", "eval", "(", "self", ",", "data", "=", "'test'", ",", "result_save_path", "=", "None", ")", ":", "\n", "        ", "result_collection", "=", "{", "}", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "self", ".", "model", ".", "eval", "(", ")", "\n", "logging", ".", "info", "(", "'begin testing'", ")", "\n", "loss_col", ",", "count", "=", "{", "}", ",", "0", "\n", "for", "batch_num", ",", "dial_batch", "in", "enumerate", "(", "self", ".", "reader", ".", "batches", "[", "data", "]", ")", ":", "\n", "                ", "turn_states", ",", "turn_states_loss", "=", "{", "}", ",", "{", "}", "\n", "for", "turn_batch", "in", "dial_batch", ":", "\n", "                    ", "u_input", ",", "z_input", ",", "a_input", ",", "m_input", ",", "db_vec", ",", "filling_vec", ",", "supervised", "=", "self", ".", "_convert_batch", "(", "turn_batch", ")", "\n", "if", "cfg", ".", "multi_domain", ":", "\n", "                        ", "turn_states_loss", "[", "'dom'", "]", "=", "turn_batch", "[", "'dom'", "]", "\n", "turn_states", "[", "'dom'", "]", "=", "turn_batch", "[", "'dom'", "]", "\n", "", "losses", ",", "turn_states_loss", "=", "self", ".", "model", "(", "u_input", "=", "u_input", ",", "z_input", "=", "z_input", ",", "m_input", "=", "m_input", ",", "\n", "z_supervised", "=", "True", ",", "turn_states", "=", "turn_states_loss", ",", "mode", "=", "'loss_eval'", ",", "\n", "a_input", "=", "a_input", ",", "db_vec", "=", "db_vec", ",", "filling_vec", "=", "filling_vec", ")", "\n", "for", "k", ",", "v", "in", "losses", ".", "items", "(", ")", ":", "\n", "                        ", "loss_col", "[", "k", "]", "=", "v", ".", "item", "(", ")", "if", "k", "not", "in", "loss_col", "else", "loss_col", "[", "k", "]", "+", "v", ".", "item", "(", ")", "\n", "", "count", "+=", "1", "\n", "index", ",", "db", ",", "turn_states", "=", "self", ".", "model", "(", "mode", "=", "'test'", ",", "u_input", "=", "u_input", ",", "z_input", "=", "z_input", ",", "\n", "m_input", "=", "m_input", ",", "z_supervised", "=", "None", ",", "turn_states", "=", "turn_states", ",", "\n", "a_input", "=", "a_input", ",", "db_vec", "=", "db_vec", ",", "filling_vec", "=", "filling_vec", ")", "\n", "turn_batch", "[", "'resp_gen'", "]", ",", "turn_batch", "[", "'bspn_gen'", "]", ",", "turn_batch", "[", "'db_gen'", "]", "=", "index", "[", "'m_idx'", "]", ",", "index", "[", "'z_idx'", "]", ",", "db", "\n", "if", "cfg", ".", "model_act", ":", "\n", "                        ", "turn_batch", "[", "'aspn_gen'", "]", "=", "index", "[", "'a_idx'", "]", "\n", "# print('{}\\r'.format(batch_num))", "\n", "", "", "result_collection", ".", "update", "(", "self", ".", "reader", ".", "inverse_transpose_batch", "(", "dial_batch", ")", ")", "\n", "", "", "for", "k", "in", "loss_col", ":", "\n", "            ", "loss_col", "[", "k", "]", "/=", "(", "count", "+", "1e-8", ")", "\n", "", "results", ",", "field", "=", "self", ".", "reader", ".", "wrap_result", "(", "result_collection", ")", "\n", "metric_results", "=", "self", ".", "evaluator", ".", "run_metrics", "(", "results", ")", "\n", "metric_results", "[", "'epoch_num'", "]", "=", "self", ".", "final_epoch", "\n", "metric_results", "[", "'test_loss'", "]", "=", "loss_col", "\n", "metric_field", "=", "list", "(", "metric_results", ".", "keys", "(", ")", ")", "\n", "self", ".", "reader", ".", "save_result", "(", "'w'", ",", "[", "metric_results", "]", ",", "metric_field", ",", "write_title", "=", "'EVALUATION RESULTS:'", ",", "\n", "result_save_path", "=", "result_save_path", ")", "\n", "self", ".", "reader", ".", "save_result", "(", "'a'", ",", "results", ",", "field", ",", "write_title", "=", "'DECODED RESULTS:'", ",", "\n", "result_save_path", "=", "result_save_path", ")", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "return", "metric_results", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.save_model": [[355, 363], ["train.Model.model.state_dict", "torch.save", "logging.info"], "methods", ["None"], ["", "def", "save_model", "(", "self", ",", "epoch", ",", "path", "=", "None", ")", ":", "\n", "        ", "if", "not", "cfg", ".", "save_log", ":", "\n", "            ", "return", "\n", "", "if", "not", "path", ":", "\n", "            ", "path", "=", "cfg", ".", "model_path", "\n", "", "all_state", "=", "self", ".", "model", ".", "state_dict", "(", ")", "\n", "torch", ".", "save", "(", "all_state", ",", "path", ")", "\n", "logging", ".", "info", "(", "'Model saved'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_model": [[364, 370], ["torch.load", "train.Model.model.load_state_dict", "logging.info", "config.global_config", "config.global_config", "config.global_config"], "methods", ["None"], ["", "def", "load_model", "(", "self", ",", "path", "=", "None", ")", ":", "\n", "        ", "if", "not", "path", ":", "\n", "            ", "path", "=", "cfg", ".", "model_path", "\n", "", "all_state", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "self", ".", "model", ".", "load_state_dict", "(", "all_state", ")", "\n", "logging", ".", "info", "(", "'Model loaded'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.freeze_module": [[371, 374], ["module.parameters"], "methods", ["None"], ["", "def", "freeze_module", "(", "self", ",", "module", ")", ":", "\n", "        ", "for", "param", "in", "module", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.unfreeze_module": [[375, 378], ["module.parameters"], "methods", ["None"], ["", "", "def", "unfreeze_module", "(", "self", ",", "module", ")", ":", "\n", "        ", "for", "param", "in", "module", ".", "parameters", "(", ")", ":", "\n", "            ", "param", ".", "requires_grad", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_glove_embedding": [[379, 392], ["train.Model.model.u_encoder.embedding.weight.data.cpu().numpy", "train.Model.reader.get_glove_matrix", "torch.from_numpy", "train.Model.model.embedding.weight.data.copy_", "train.Model.freeze_module", "train.Model.model.u_encoder.embedding.weight.data.cpu"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.get_glove_matrix", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.freeze_module"], ["", "", "def", "load_glove_embedding", "(", "self", ",", "freeze", "=", "False", ")", ":", "\n", "        ", "initial_arr", "=", "self", ".", "model", ".", "u_encoder", ".", "embedding", ".", "weight", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "cfg", ".", "embed_size", "==", "50", ":", "\n", "            ", "glove_path", "=", "'./data/glove/glove_multiwoz.6B.50d.txt'", "\n", "", "elif", "cfg", ".", "embed_size", "==", "300", ":", "\n", "            ", "glove_path", "=", "'./data/glove/glove_multiwoz.840B.300d.txt'", "\n", "", "else", ":", "\n", "            ", "return", "\n", "", "embedding_arr", "=", "self", ".", "reader", ".", "get_glove_matrix", "(", "glove_path", ",", "initial_arr", ")", "\n", "embedding_arr", "=", "torch", ".", "from_numpy", "(", "embedding_arr", ")", "\n", "self", ".", "model", ".", "embedding", ".", "weight", ".", "data", ".", "copy_", "(", "embedding_arr", ")", "\n", "if", "freeze", ":", "\n", "            ", "self", ".", "freeze_module", "(", "self", ".", "model", ".", "embedding", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.count_params": [[393, 398], ["filter", "int", "logging.info", "train.Model.model.parameters", "sum", "numpy.prod", "p.size"], "methods", ["None"], ["", "", "def", "count_params", "(", "self", ")", ":", "\n", "        ", "module_parameters", "=", "filter", "(", "lambda", "p", ":", "p", ".", "requires_grad", ",", "self", ".", "model", ".", "parameters", "(", ")", ")", "\n", "param_cnt", "=", "int", "(", "sum", "(", "[", "np", ".", "prod", "(", "p", ".", "size", "(", ")", ")", "for", "p", "in", "module_parameters", "]", ")", ")", "\n", "logging", ".", "info", "(", "'total trainable params: %d'", "%", "param_cnt", ")", "\n", "return", "param_cnt", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.parse_arg_cfg": [[399, 416], ["tuple", "type", "setattr", "pair.split", "getattr", "type", "ValueError", "dtype.split", "type.", "int"], "function", ["None"], ["", "", "def", "parse_arg_cfg", "(", "args", ")", ":", "\n", "    ", "if", "args", ".", "cfg", ":", "\n", "        ", "for", "pair", "in", "args", ".", "cfg", ":", "\n", "            ", "k", ",", "v", "=", "tuple", "(", "pair", ".", "split", "(", "'='", ")", ")", "\n", "dtype", "=", "type", "(", "getattr", "(", "cfg", ",", "k", ")", ")", "\n", "if", "dtype", "==", "type", "(", "None", ")", ":", "\n", "                ", "raise", "ValueError", "(", ")", "\n", "", "if", "dtype", "is", "bool", ":", "\n", "                ", "v", "=", "False", "if", "v", "==", "'False'", "else", "True", "\n", "", "elif", "dtype", "is", "list", ":", "\n", "                ", "v", "=", "v", ".", "split", "(", "','", ")", "\n", "if", "k", "==", "'cuda_device'", ":", "\n", "                    ", "v", "=", "[", "int", "(", "no", ")", "for", "no", "in", "v", "]", "\n", "", "", "else", ":", "\n", "                ", "v", "=", "dtype", "(", "v", ")", "\n", "", "setattr", "(", "cfg", ",", "k", ",", "v", ")", "\n", "", "", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.main": [[418, 512], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "config.global_config.init_handler", "config.global_config.init_logging_handler", "torch.manual_seed", "torch.cuda.manual_seed", "random.seed", "numpy.random.seed", "train.Model", "logging.info", "train.Model.count_params", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "train.parse_arg_cfg", "json.loads", "json.loads.items", "train.parse_arg_cfg", "torch.cuda.set_device", "logging.info", "str", "open().read", "setattr", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "Model.reader.vocab.save_vocab", "train.Model.load_glove_embedding", "Model.train", "logging.info", "Model.train", "Model.train", "train.Model.load_model", "Model.train", "os.mkdir", "torch.cuda.current_device", "os.path.join", "open", "json.dump", "train.Model.load_model", "config.global_config.model_path.replace", "os.path.join", "Model.train", "open", "os.path.join", "train.Model.freeze_module", "train.Model.load_model", "train.Model.eval", "Model.reader.save_result_report", "os.path.join"], "function", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config.init_handler", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.config._Config.init_logging_handler", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.count_params", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.parse_arg_cfg", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.parse_arg_cfg", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.save_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_glove_embedding", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_model", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_model", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.train", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.freeze_module", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.load_model", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.train.Model.eval", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader.save_result_report"], ["", "def", "main", "(", ")", ":", "\n", "    ", "if", "not", "os", ".", "path", ".", "exists", "(", "'./experiments'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'./experiments'", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'./log'", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'./log'", ")", "\n", "\n", "", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-mode'", ")", "\n", "parser", ".", "add_argument", "(", "'-method'", ")", "\n", "parser", ".", "add_argument", "(", "'-dataset'", ")", "\n", "parser", ".", "add_argument", "(", "'-cfg'", ",", "nargs", "=", "'*'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "'experiments/'", "+", "args", ".", "dataset", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'experiments/'", "+", "args", ".", "dataset", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "'log/'", "+", "args", ".", "dataset", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "'log/'", "+", "args", ".", "dataset", ")", "\n", "\n", "", "cfg", ".", "mode", ",", "cfg", ".", "dataset", ",", "cfg", ".", "method", "=", "args", ".", "mode", ",", "args", ".", "dataset", ",", "args", ".", "method", "\n", "cfg", ".", "init_handler", "(", "cfg", ".", "dataset", ")", "\n", "if", "args", ".", "mode", "in", "[", "'test'", ",", "'adjust'", ",", "'rl_tune'", "]", ":", "\n", "        ", "parse_arg_cfg", "(", "args", ")", "\n", "cfg_load", "=", "json", ".", "loads", "(", "open", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "eval_load_path", ",", "'config.json'", ")", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "for", "k", ",", "v", "in", "cfg_load", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "in", "[", "'mode'", ",", "'cuda'", ",", "'cuda_device'", ",", "'eval_load_path'", ",", "'log_time'", ",", "'model_path'", ",", "\n", "'result_path'", ",", "'model_parameters'", ",", "'beam_search'", ",", "'skip_unsup'", ",", "'sup_pretrain'", ",", "\n", "'lr'", ",", "'valid_type'", ",", "'seed'", ",", "'max_epoch'", "]", ":", "\n", "                ", "continue", "\n", "", "setattr", "(", "cfg", ",", "k", ",", "v", ")", "\n", "cfg", ".", "model_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "eval_load_path", ",", "'model.pkl'", ")", "\n", "result_file", "=", "'result_beam.csv'", "if", "cfg", ".", "beam_search", "else", "'result_greedy.csv'", "\n", "# cfg.model_path = os.path.join(cfg.eval_load_path, 'model_rl.pkl')", "\n", "# result_file = 'result_beam_rl.csv' if cfg.beam_search else 'result_greedy_rl.csv'", "\n", "cfg", ".", "result_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "eval_load_path", ",", "result_file", ")", "\n", "cfg", ".", "vocab_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "eval_load_path", ",", "'vocab'", ")", "\n", "", "", "else", ":", "\n", "        ", "parse_arg_cfg", "(", "args", ")", "\n", "if", "cfg", ".", "exp_path", "in", "[", "''", ",", "'to be generated'", "]", ":", "\n", "            ", "unsup_prop", "=", "0", "if", "cfg", ".", "skip_unsup", "else", "100", "-", "cfg", ".", "spv_proportion", "\n", "cfg", ".", "exp_path", "=", "'experiments/{}/{}_{}_sd{}_sup{}un{}_zl{}_lr{}_dp{}/'", ".", "format", "(", "\n", "cfg", ".", "dataset", ",", "cfg", ".", "method", ",", "cfg", ".", "exp_no", ",", "cfg", ".", "seed", ",", "cfg", ".", "spv_proportion", ",", "unsup_prop", ",", "\n", "cfg", ".", "z_length", ",", "cfg", ".", "lr", ",", "cfg", ".", "dropout_rate", ")", "\n", "if", "cfg", ".", "save_log", ":", "\n", "                ", "os", ".", "mkdir", "(", "cfg", ".", "exp_path", ")", "\n", "", "cfg", ".", "model_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "'model.pkl'", ")", "\n", "cfg", ".", "result_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "'result.csv'", ")", "\n", "cfg", ".", "eval_load_path", "=", "cfg", ".", "exp_path", "\n", "\n", "", "", "cfg", ".", "init_logging_handler", "(", "args", ".", "mode", ")", "\n", "if", "cfg", ".", "cuda", ":", "\n", "        ", "torch", ".", "cuda", ".", "set_device", "(", "cfg", ".", "cuda_device", ")", "\n", "logging", ".", "info", "(", "'Device: {}'", ".", "format", "(", "torch", ".", "cuda", ".", "current_device", "(", ")", ")", ")", "\n", "\n", "", "torch", ".", "manual_seed", "(", "cfg", ".", "seed", ")", "\n", "torch", ".", "cuda", ".", "manual_seed", "(", "cfg", ".", "seed", ")", "\n", "random", ".", "seed", "(", "cfg", ".", "seed", ")", "\n", "np", ".", "random", ".", "seed", "(", "cfg", ".", "seed", ")", "\n", "torch", ".", "backends", ".", "cudnn", ".", "benchmark", "=", "False", "\n", "torch", ".", "backends", ".", "cudnn", ".", "deterministic", "=", "True", "\n", "\n", "m", "=", "Model", "(", "args", ".", "dataset", ",", "args", ".", "method", ")", "\n", "logging", ".", "info", "(", "str", "(", "cfg", ")", ")", "\n", "m", ".", "count_params", "(", ")", "\n", "\n", "if", "args", ".", "mode", "==", "'train'", ":", "\n", "        ", "if", "cfg", ".", "save_log", ":", "\n", "            ", "m", ".", "reader", ".", "vocab", ".", "save_vocab", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "'vocab'", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "'config.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "cfg", ".", "__dict__", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "", "if", "cfg", ".", "glove_init", ":", "\n", "            ", "m", ".", "load_glove_embedding", "(", "freeze", "=", "cfg", ".", "freeze_emb", ")", "\n", "", "if", "unsup_prop", ">", "0", ":", "\n", "            ", "m", ".", "train", "(", "pretrain", "=", "True", ")", "\n", "logging", ".", "info", "(", "'Start semi-supervised training'", ")", "\n", "if", "cfg", ".", "changedp", "and", "not", "cfg", ".", "use_resp_dpout", ":", "\n", "                ", "cfg", ".", "use_resp_dpout", "=", "True", "\n", "", "m", ".", "train", "(", ")", "\n", "", "else", ":", "\n", "            ", "m", ".", "train", "(", ")", "\n", "", "", "elif", "args", ".", "mode", "==", "'adjust'", ":", "\n", "        ", "m", ".", "load_model", "(", "cfg", ".", "model_path", ")", "\n", "m", ".", "train", "(", ")", "\n", "", "elif", "args", ".", "mode", "==", "'rl_tune'", ":", "\n", "        ", "m", ".", "load_model", "(", "cfg", ".", "model_path", ")", "\n", "cfg", ".", "model_path", "=", "cfg", ".", "model_path", ".", "replace", "(", "'.pkl'", ",", "'_rl.pkl'", ")", "\n", "cfg", ".", "result_path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "eval_load_path", ",", "'result_rl.csv'", ")", "\n", "for", "mod", "in", "[", "m", ".", "model", ".", "embedding", ",", "m", ".", "model", ".", "u_encoder", ",", "m", ".", "model", ".", "z_encoder", ",", "m", ".", "model", ".", "pz_decoder", ",", "m", ".", "model", ".", "u_encoder_q", "]", ":", "\n", "            ", "m", ".", "freeze_module", "(", "mod", ")", "\n", "\n", "", "m", ".", "train", "(", ")", "\n", "", "elif", "args", ".", "mode", "==", "'test'", ":", "\n", "        ", "m", ".", "load_model", "(", "cfg", ".", "model_path", ")", "\n", "metric_results", "=", "m", ".", "eval", "(", "result_save_path", "=", "cfg", ".", "result_path", ")", "\n", "m", ".", "reader", ".", "save_result_report", "(", "metric_results", ",", "cfg", ".", "global_record_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.DynamicEncoder.__init__": [[27, 38], ["torch.nn.Module.__init__", "torch.nn.Embedding", "torch.nn.Embedding", "torch.nn.GRU", "torch.nn.GRU", "rnn_net.orth_gru"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.orth_gru"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "embed_size", ",", "hidden_size", ",", "n_layers", ",", "dropout", ",", "bidir", "=", "True", ",", "extra_size", "=", "0", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "embed_size", "=", "embed_size", "\n", "self", ".", "n_layers", "=", "n_layers", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "input_size", ",", "embed_size", ")", "\n", "self", ".", "gru", "=", "nn", ".", "GRU", "(", "embed_size", "+", "extra_size", ",", "hidden_size", ",", "n_layers", ",", "bidirectional", "=", "bidir", ")", "\n", "self", ".", "gru", "=", "orth_gru", "(", "self", ".", "gru", ")", "\n", "self", ".", "bidir", "=", "bidir", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.DynamicEncoder.forward": [[39, 80], ["input_seqs.size", "rnn_net.DynamicEncoder.embedding", "rnn_net.DynamicEncoder.transpose", "numpy.argsort", "rnn_net.cuda_", "rnn_net.cuda_", "embedded[].transpose", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "rnn_net.DynamicEncoder.gru", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "[].transpose().contiguous", "[].transpose().contiguous", "extra_input[].transpose.transpose", "hidden[].transpose.transpose", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "extra_input[].transpose", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "hidden[].transpose", "numpy.argsort", "[].transpose", "[].transpose", "[].transpose().contiguous.transpose", "hidden[].transpose.transpose"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "def", "forward", "(", "self", ",", "input_seqs", ",", "input_lens", ",", "hidden", "=", "None", ",", "seperate", "=", "False", ",", "return_emb", "=", "False", ",", "extra_input", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        forward procedure. No need for inputs to be sorted\n        :param extra_input: [T, B, E]\n        :param return_emb:\n        :param seperate:\n        :param input_seqs: Variable of [T,B]\n        :param hidden:\n        :param input_lens: *numpy array* of len for each input sequence\n        :return:\n        \"\"\"", "\n", "batch_size", "=", "input_seqs", ".", "size", "(", "1", ")", "\n", "embedded_origin", "=", "self", ".", "embedding", "(", "input_seqs", ")", "\n", "embedded", "=", "embedded_origin", ".", "transpose", "(", "0", ",", "1", ")", "# [B,T,E]", "\n", "if", "extra_input", "is", "not", "None", ":", "\n", "            ", "extra_input", "=", "extra_input", ".", "transpose", "(", "0", ",", "1", ")", "# [B,T,E]", "\n", "", "if", "hidden", "is", "not", "None", ":", "\n", "            ", "hidden", "=", "hidden", ".", "transpose", "(", "0", ",", "1", ")", "# [B,L,H]", "\n", "", "sort_idx", "=", "np", ".", "argsort", "(", "-", "input_lens", ")", "\n", "unsort_idx", "=", "cuda_", "(", "torch", ".", "LongTensor", "(", "np", ".", "argsort", "(", "sort_idx", ")", ")", ")", "\n", "input_lens", "=", "input_lens", "[", "sort_idx", "]", "\n", "sort_idx", "=", "cuda_", "(", "torch", ".", "LongTensor", "(", "sort_idx", ")", ")", "\n", "embedded", "=", "embedded", "[", "sort_idx", "]", ".", "transpose", "(", "0", ",", "1", ")", "# [T,B,E]", "\n", "if", "extra_input", "is", "not", "None", ":", "\n", "            ", "extra_input", "=", "extra_input", "[", "sort_idx", "]", ".", "transpose", "(", "0", ",", "1", ")", "# [T,B,E]", "\n", "inp", "=", "torch", ".", "cat", "(", "[", "embedded", ",", "extra_input", "]", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "inp", "=", "embedded", "\n", "", "if", "hidden", "is", "not", "None", ":", "\n", "            ", "hidden", "=", "hidden", "[", "sort_idx", "]", ".", "transpose", "(", "0", ",", "1", ")", "# [L,B,H]", "\n", "", "packed", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pack_padded_sequence", "(", "inp", ",", "input_lens", ")", "\n", "outputs", ",", "hidden", "=", "self", ".", "gru", "(", "packed", ",", "hidden", ")", "\n", "outputs", ",", "_", "=", "torch", ".", "nn", ".", "utils", ".", "rnn", ".", "pad_packed_sequence", "(", "outputs", ")", "\n", "outputs", "=", "outputs", ".", "transpose", "(", "0", ",", "1", ")", "[", "unsort_idx", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "if", "self", ".", "bidir", "and", "not", "seperate", ":", "\n", "            ", "outputs", "=", "outputs", "[", ":", ",", ":", ",", ":", "self", ".", "hidden_size", "]", "+", "outputs", "[", ":", ",", ":", ",", "self", ".", "hidden_size", ":", "]", "\n", "", "hidden", "=", "hidden", ".", "transpose", "(", "0", ",", "1", ")", "[", "unsort_idx", "]", ".", "transpose", "(", "0", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "if", "not", "return_emb", ":", "\n", "            ", "return", "outputs", ",", "hidden", "\n", "", "else", ":", "\n", "            ", "return", "outputs", ",", "hidden", ",", "embedded_origin", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.LayerNormalization.__init__": [[84, 89], ["torch.nn.Module.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.ones", "torch.ones", "torch.ones", "torch.ones", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["def", "__init__", "(", "self", ",", "d_hid", ",", "eps", "=", "1e-3", ")", ":", "\n", "        ", "super", "(", "LayerNormalization", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "eps", "=", "eps", "\n", "self", ".", "a_2", "=", "nn", ".", "Parameter", "(", "torch", ".", "ones", "(", "d_hid", ")", ",", "requires_grad", "=", "True", ")", "\n", "self", ".", "b_2", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "d_hid", ")", ",", "requires_grad", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.LayerNormalization.forward": [[90, 98], ["torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.std", "torch.std", "torch.std", "torch.std", "z.size", "rnn_net.LayerNormalization.b_2.expand_as", "torch.mean.expand_as", "torch.mean.expand_as", "torch.std.expand_as", "torch.std.expand_as", "rnn_net.LayerNormalization.a_2.expand_as"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "z", ")", ":", "\n", "        ", "if", "z", ".", "size", "(", "1", ")", "==", "1", ":", "\n", "            ", "return", "z", "\n", "", "mu", "=", "torch", ".", "mean", "(", "z", ",", "keepdim", "=", "True", ",", "dim", "=", "-", "1", ")", "\n", "sigma", "=", "torch", ".", "std", "(", "z", ",", "keepdim", "=", "True", ",", "dim", "=", "-", "1", ")", "\n", "ln_out", "=", "(", "z", "-", "mu", ".", "expand_as", "(", "z", ")", ")", "/", "(", "sigma", ".", "expand_as", "(", "z", ")", "+", "self", ".", "eps", ")", "\n", "ln_out", "=", "ln_out", "*", "self", ".", "a_2", ".", "expand_as", "(", "ln_out", ")", "+", "self", ".", "b_2", ".", "expand_as", "(", "ln_out", ")", "\n", "return", "ln_out", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.Attn.__init__": [[105, 112], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Parameter", "torch.nn.Parameter", "rnn_net.Attn.v.data.normal_", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "math.sqrt", "rnn_net.Attn.v.size"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["def", "__init__", "(", "self", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "Attn", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "attn", "=", "nn", ".", "Linear", "(", "self", ".", "hidden_size", "*", "2", ",", "hidden_size", ")", "\n", "self", ".", "v", "=", "nn", ".", "Parameter", "(", "torch", ".", "zeros", "(", "hidden_size", ")", ")", "\n", "stdv", "=", "1.", "/", "math", ".", "sqrt", "(", "self", ".", "v", ".", "size", "(", "0", ")", ")", "\n", "self", ".", "v", ".", "data", ".", "normal_", "(", "mean", "=", "0", ",", "std", "=", "stdv", ")", "\n", "# self.ln1 = LayerNormalization(hidden_size)", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.Attn.forward": [[114, 121], ["encoder_outputs.transpose.transpose.transpose", "rnn_net.Attn.score", "torch.softmax", "torch.softmax", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm().transpose", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.BLEUScorer.score"], ["", "def", "forward", "(", "self", ",", "hidden", ",", "encoder_outputs", ",", "normalize", "=", "True", ")", ":", "\n", "        ", "encoder_outputs", "=", "encoder_outputs", ".", "transpose", "(", "0", ",", "1", ")", "# [B,T,H]", "\n", "attn_energies", "=", "self", ".", "score", "(", "hidden", ",", "encoder_outputs", ")", "\n", "normalized_energy", "=", "F", ".", "softmax", "(", "attn_energies", ",", "dim", "=", "2", ")", "# [B,1,T]", "\n", "context", "=", "torch", ".", "bmm", "(", "normalized_energy", ",", "encoder_outputs", ")", ".", "transpose", "(", "0", ",", "1", ")", "# [1,B,H]", "\n", "# context = self.ln1(context)", "\n", "return", "context", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.Attn.score": [[122, 131], ["encoder_outputs.size", "hidden.expand().transpose", "torch.tanh", "torch.tanh", "torch.bmm.transpose", "torch.bmm.transpose", "rnn_net.Attn.v.repeat().unsqueeze", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "hidden.size", "rnn_net.Attn.attn", "hidden.expand", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "rnn_net.Attn.v.repeat", "encoder_outputs.size"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "hidden", ",", "encoder_outputs", ")", ":", "\n", "        ", "max_len", "=", "encoder_outputs", ".", "size", "(", "1", ")", "\n", "assert", "hidden", ".", "size", "(", "0", ")", "==", "1", "\n", "H", "=", "hidden", ".", "expand", "(", "max_len", ",", "-", "1", ",", "-", "1", ")", ".", "transpose", "(", "0", ",", "1", ")", "\n", "energy", "=", "F", ".", "tanh", "(", "self", ".", "attn", "(", "torch", ".", "cat", "(", "[", "H", ",", "encoder_outputs", "]", ",", "2", ")", ")", ")", "# [B,T,2H]->[B,T,H]", "\n", "energy", "=", "energy", ".", "transpose", "(", "2", ",", "1", ")", "# [B,H,T]", "\n", "v", "=", "self", ".", "v", ".", "repeat", "(", "encoder_outputs", ".", "size", "(", "0", ")", ",", "1", ")", ".", "unsqueeze", "(", "1", ")", "# [B,1,H]", "\n", "energy", "=", "torch", ".", "bmm", "(", "v", ",", "energy", ")", "# [B,1,T]", "\n", "return", "energy", "", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_": [[9, 16], ["var.cuda", "var.cuda", "var.cpu"], "function", ["None"], ["def", "cuda_", "(", "var", ",", "aux", "=", "None", ")", ":", "\n", "    ", "if", "not", "aux", ":", "\n", "        ", "return", "var", ".", "cuda", "(", ")", "if", "cfg", ".", "cuda", "else", "var", "\n", "", "elif", "aux", "!=", "'cpu'", "and", "aux", ">=", "0", "and", "cfg", ".", "cuda", ":", "\n", "        ", "return", "var", ".", "cuda", "(", "aux", ")", "\n", "", "else", ":", "\n", "        ", "return", "var", ".", "cpu", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.orth_gru": [[18, 24], ["gru.reset_parameters", "range", "hh.size", "torch.nn.init.orthogonal_", "torch.nn.init.orthogonal_"], "function", ["None"], ["", "", "def", "orth_gru", "(", "gru", ")", ":", "\n", "    ", "gru", ".", "reset_parameters", "(", ")", "\n", "for", "_", ",", "hh", ",", "_", ",", "_", "in", "gru", ".", "all_weights", ":", "\n", "        ", "for", "i", "in", "range", "(", "0", ",", "hh", ".", "size", "(", "0", ")", ",", "gru", ".", "hidden_size", ")", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "orthogonal_", "(", "hh", "[", "i", ":", "i", "+", "gru", ".", "hidden_size", "]", ",", "gain", "=", "1", ")", "\n", "", "", "return", "gru", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.BLEUScorer.__init__": [[49, 51], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.BLEUScorer.score": [[52, 101], ["math.fsum", "math.exp", "math.exp", "hyp.split", "ref.split", "range", "len", "range", "collections.Counter", "sum", "dict", "sum", "abs", "float", "float", "math.log", "zip", "nltk.util.ngrams", "collections.Counter.values", "collections.Counter", "dict.values", "len", "float", "nltk.util.ngrams", "max", "len", "len", "float", "max_counts.get", "min", "collections.Counter.items"], "methods", ["None"], ["", "def", "score", "(", "self", ",", "parallel_corpus", ")", ":", "\n", "# containers", "\n", "        ", "count", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "clip_count", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "r", "=", "0", "\n", "c", "=", "0", "\n", "weights", "=", "[", "0.25", ",", "0.25", ",", "0.25", ",", "0.25", "]", "\n", "\n", "# accumulate ngram statistics", "\n", "for", "hyps", ",", "refs", "in", "parallel_corpus", ":", "\n", "            ", "hyps", "=", "[", "hyp", ".", "split", "(", ")", "for", "hyp", "in", "hyps", "]", "\n", "refs", "=", "[", "ref", ".", "split", "(", ")", "for", "ref", "in", "refs", "]", "\n", "for", "hyp", "in", "hyps", ":", "\n", "                ", "for", "i", "in", "range", "(", "4", ")", ":", "\n", "# accumulate ngram counts", "\n", "                    ", "hypcnts", "=", "Counter", "(", "ngrams", "(", "hyp", ",", "i", "+", "1", ")", ")", "\n", "cnt", "=", "sum", "(", "hypcnts", ".", "values", "(", ")", ")", "\n", "count", "[", "i", "]", "+=", "cnt", "\n", "\n", "# compute clipped counts", "\n", "max_counts", "=", "{", "}", "\n", "for", "ref", "in", "refs", ":", "\n", "                        ", "refcnts", "=", "Counter", "(", "ngrams", "(", "ref", ",", "i", "+", "1", ")", ")", "\n", "for", "ng", "in", "hypcnts", ":", "\n", "                            ", "max_counts", "[", "ng", "]", "=", "max", "(", "max_counts", ".", "get", "(", "ng", ",", "0", ")", ",", "refcnts", "[", "ng", "]", ")", "\n", "", "", "clipcnt", "=", "dict", "(", "(", "ng", ",", "min", "(", "count", ",", "max_counts", "[", "ng", "]", ")", ")", "for", "ng", ",", "count", "in", "hypcnts", ".", "items", "(", ")", ")", "\n", "clip_count", "[", "i", "]", "+=", "sum", "(", "clipcnt", ".", "values", "(", ")", ")", "\n", "\n", "# accumulate r & c", "\n", "", "bestmatch", "=", "[", "1000", ",", "1000", "]", "\n", "for", "ref", "in", "refs", ":", "\n", "                    ", "if", "bestmatch", "[", "0", "]", "==", "0", ":", "break", "\n", "diff", "=", "abs", "(", "len", "(", "ref", ")", "-", "len", "(", "hyp", ")", ")", "\n", "if", "diff", "<", "bestmatch", "[", "0", "]", ":", "\n", "                        ", "bestmatch", "[", "0", "]", "=", "diff", "\n", "bestmatch", "[", "1", "]", "=", "len", "(", "ref", ")", "\n", "", "", "r", "+=", "bestmatch", "[", "1", "]", "\n", "c", "+=", "len", "(", "hyp", ")", "\n", "\n", "# computing bleu score", "\n", "", "", "p0", "=", "1e-10", "\n", "bp", "=", "1", "if", "c", ">", "r", "else", "math", ".", "exp", "(", "1", "-", "float", "(", "r", ")", "/", "(", "float", "(", "c", ")", "+", "p0", ")", ")", "\n", "p_ns", "=", "[", "float", "(", "clip_count", "[", "i", "]", ")", "/", "float", "(", "count", "[", "i", "]", "+", "p0", ")", "+", "p0", "for", "i", "in", "range", "(", "4", ")", "]", "\n", "s", "=", "math", ".", "fsum", "(", "w", "*", "math", ".", "log", "(", "p_n", ")", "for", "w", ",", "p_n", "in", "zip", "(", "weights", ",", "p_ns", ")", "if", "p_n", ")", "\n", "bleu", "=", "bp", "*", "math", ".", "exp", "(", "s", ")", "\n", "return", "bleu", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.__init__": [[104, 107], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "reader", ")", ":", "\n", "        ", "self", ".", "reader", "=", "reader", "\n", "self", ".", "metric_dict", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.pack_dial": [[108, 116], ["dials[].append"], "methods", ["None"], ["", "def", "pack_dial", "(", "self", ",", "data", ")", ":", "\n", "        ", "dials", "=", "{", "}", "\n", "for", "turn", "in", "data", ":", "\n", "            ", "dial_id", "=", "turn", "[", "'dial_id'", "]", "\n", "if", "dial_id", "not", "in", "dials", ":", "\n", "                ", "dials", "[", "dial_id", "]", "=", "[", "]", "\n", "", "dials", "[", "dial_id", "]", ".", "append", "(", "turn", ")", "\n", "", "return", "dials", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.run_metrics": [[117, 119], ["ValueError"], "methods", ["None"], ["", "def", "run_metrics", "(", "self", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'Please specify the evaluator first'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.bleu_metric": [[121, 136], ["metric.BLEUScorer.score", "gen.append", "truth.append", "zip", "metric.GenericEvaluator.clean", "metric.GenericEvaluator.clean", "metric.BLEUScorer"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.BLEUScorer.score", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.clean", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.clean"], ["", "def", "bleu_metric", "(", "self", ",", "data", ",", "type", "=", "'bleu'", ")", ":", "\n", "# def clean(s):", "\n", "#     s = s.replace('<go_r> ', '')", "\n", "#     s = '<GO> ' + s", "\n", "#     return s", "\n", "\n", "        ", "gen", ",", "truth", "=", "[", "]", ",", "[", "]", "\n", "for", "row", "in", "data", ":", "\n", "            ", "gen", ".", "append", "(", "self", ".", "clean", "(", "row", "[", "'resp_gen'", "]", ")", ")", "\n", "# gen.append(self.clean(row['resp']))", "\n", "truth", ".", "append", "(", "self", ".", "clean", "(", "row", "[", "'resp'", "]", ")", ")", "\n", "", "wrap_generated", "=", "[", "[", "_", "]", "for", "_", "in", "gen", "]", "\n", "wrap_truth", "=", "[", "[", "_", "]", "for", "_", "in", "truth", "]", "\n", "sc", "=", "BLEUScorer", "(", ")", ".", "score", "(", "zip", "(", "wrap_generated", ",", "wrap_truth", ")", ")", "\n", "return", "sc", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator._normalize_constraint": [[138, 157], ["constraint.items"], "methods", ["None"], ["", "def", "_normalize_constraint", "(", "self", ",", "constraint", ",", "ignore_dontcare", "=", "False", ",", "intersection", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Normalize belief span, e.g. delete repeated words\n        :param constraint - {'food': 'asian oritental', 'pricerange': 'cheap'}\n        :param intersection: if true, only keeps the words that appear in th ontology\n                                        we set intersection=True as in previous works\n        :returns: normalized constraint dict\n                      e.g. - {'food': 'asian oritental', 'pricerange': 'cheap', 'area': ''}\n        \"\"\"", "\n", "normalized", "=", "{", "}", "\n", "for", "s", "in", "self", ".", "informable_slots", ":", "\n", "            ", "normalized", "[", "s", "]", "=", "''", "\n", "", "for", "s", ",", "v", "in", "constraint", ".", "items", "(", ")", ":", "\n", "            ", "if", "ignore_dontcare", "and", "v", "==", "'dontcare'", ":", "\n", "                ", "continue", "\n", "", "if", "intersection", "and", "v", "!=", "'dontcare'", "and", "v", "not", "in", "self", ".", "entities_flat", ":", "\n", "                ", "continue", "\n", "", "normalized", "[", "s", "]", "=", "v", "\n", "", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator._normalize_act": [[159, 177], ["aspn.split", "enumerate", "v.strip", "set", "v.strip.split", "set.add", "set.add", "set.add"], "methods", ["None"], ["", "def", "_normalize_act", "(", "self", ",", "aspn", ",", "intersection", "=", "False", ")", ":", "\n", "        ", "aspn_list", "=", "aspn", ".", "split", "(", "'|'", ")", "\n", "normalized", "=", "{", "}", "\n", "for", "i", ",", "v", "in", "enumerate", "(", "aspn_list", ")", ":", "\n", "            ", "seq", "=", "v", ".", "strip", "(", ")", "\n", "word_set", "=", "set", "(", ")", "\n", "for", "w", "in", "seq", ".", "split", "(", ")", ":", "\n", "                ", "if", "intersection", ":", "\n", "                    ", "if", "self", ".", "reader", ".", "act_order", "[", "i", "]", "==", "'av'", ":", "\n", "                        ", "if", "'[value'", "in", "w", ":", "\n", "                            ", "word_set", ".", "add", "(", "w", ")", "\n", "", "", "else", ":", "\n", "                        ", "if", "w", "in", "self", ".", "requestable_slots", ":", "\n", "                            ", "word_set", ".", "add", "(", "w", ")", "\n", "", "", "", "else", ":", "\n", "                    ", "word_set", ".", "add", "(", "w", ")", "\n", "", "", "normalized", "[", "self", ".", "reader", ".", "act_order", "[", "i", "]", "]", "=", "word_set", "\n", "", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.tracker_metric": [[179, 220], ["metric.GenericEvaluator._normalize_constraint", "metric.GenericEvaluator._normalize_constraint", "metric.GenericEvaluator._normalize_constraint", "metric.GenericEvaluator._normalize_constraint", "metric.GenericEvaluator.items", "metric.GenericEvaluator.items"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint"], ["", "def", "tracker_metric", "(", "self", ",", "data", ",", "normalize", "=", "True", ")", ":", "\n", "# turn level metric", "\n", "        ", "tp", ",", "fp", ",", "fn", ",", "db_correct", "=", "0", ",", "0", ",", "0", ",", "0", "\n", "goal_accr", ",", "slot_accr", ",", "total", "=", "0", ",", "{", "}", ",", "1e-8", "\n", "for", "s", "in", "self", ".", "informable_slots", ":", "\n", "            ", "slot_accr", "[", "s", "]", "=", "0", "\n", "\n", "", "for", "row", "in", "data", ":", "\n", "            ", "if", "normalize", ":", "\n", "                ", "gen", "=", "self", ".", "_normalize_constraint", "(", "row", "[", "'bspn_gen'", "]", ")", "\n", "truth", "=", "self", ".", "_normalize_constraint", "(", "row", "[", "'bspn'", "]", ")", "\n", "", "else", ":", "\n", "                ", "gen", "=", "self", ".", "_normalize_constraint", "(", "row", "[", "'bspn_gen'", "]", ",", "intersection", "=", "False", ")", "\n", "truth", "=", "self", ".", "_normalize_constraint", "(", "row", "[", "'bspn'", "]", ",", "intersection", "=", "False", ")", "\n", "", "valid", "=", "'thank'", "not", "in", "row", "[", "'user'", "]", "and", "'bye'", "not", "in", "row", "[", "'user'", "]", "\n", "if", "valid", ":", "\n", "                ", "for", "slot", ",", "value", "in", "gen", ".", "items", "(", ")", ":", "\n", "                    ", "if", "value", "in", "truth", "[", "slot", "]", ":", "\n", "                        ", "tp", "+=", "1", "\n", "", "else", ":", "\n", "                        ", "fp", "+=", "1", "\n", "", "", "for", "slot", ",", "value", "in", "truth", ".", "items", "(", ")", ":", "\n", "                    ", "if", "value", "not", "in", "gen", "[", "slot", "]", ":", "\n", "                        ", "fn", "+=", "1", "\n", "\n", "", "", "", "if", "truth", "and", "valid", ":", "\n", "                ", "total", "+=", "1", "\n", "for", "s", "in", "self", ".", "informable_slots", ":", "\n", "                    ", "if", "gen", "[", "s", "]", "==", "truth", "[", "s", "]", ":", "\n", "                        ", "slot_accr", "[", "s", "]", "+=", "1", "\n", "", "", "if", "gen", "==", "truth", ":", "\n", "                    ", "goal_accr", "+=", "1", "\n", "", "if", "row", "[", "'db_gen'", "]", "==", "row", "[", "'db_match'", "]", ":", "\n", "                    ", "db_correct", "+=", "1", "\n", "", "", "", "precision", ",", "recall", "=", "tp", "/", "(", "tp", "+", "fp", "+", "1e-8", ")", ",", "tp", "/", "(", "tp", "+", "fn", "+", "1e-8", ")", "\n", "f1", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", "+", "1e-8", ")", "\n", "goal_accr", "/=", "total", "\n", "db_correct", "/=", "total", "\n", "for", "s", "in", "slot_accr", ":", "\n", "            ", "slot_accr", "[", "s", "]", "/=", "total", "\n", "", "return", "precision", ",", "recall", ",", "f1", ",", "goal_accr", ",", "slot_accr", ",", "db_correct", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.request_metric": [[222, 254], ["metric.GenericEvaluator.pack_dial", "enumerate", "set", "set", "metric.GenericEvaluator.clean().split", "metric.GenericEvaluator.clean().split", "metric.GenericEvaluator.clean", "metric.GenericEvaluator.clean", "w.endswith", "gen_req.add", "w.endswith", "truth_req.add", "w[].split", "w[].split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.pack_dial", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.clean", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.clean"], ["", "def", "request_metric", "(", "self", ",", "data", ")", ":", "\n", "# dialog level metric", "\n", "        ", "dials", "=", "self", ".", "pack_dial", "(", "data", ")", "\n", "tp", ",", "fp", ",", "fn", "=", "0", ",", "0", ",", "0", "\n", "for", "dial_id", "in", "dials", ":", "\n", "            ", "truth_req", ",", "gen_req", "=", "set", "(", ")", ",", "set", "(", ")", "\n", "dial", "=", "dials", "[", "dial_id", "]", "\n", "for", "turn_num", ",", "turn", "in", "enumerate", "(", "dial", ")", ":", "\n", "                ", "resp_gen_token", "=", "self", ".", "clean", "(", "turn", "[", "'resp_gen'", "]", ")", ".", "split", "(", ")", "\n", "resp_token", "=", "self", ".", "clean", "(", "turn", "[", "'resp'", "]", ")", ".", "split", "(", ")", "\n", "for", "w", "in", "resp_gen_token", ":", "\n", "                    ", "if", "'[value_'", "in", "w", "and", "w", ".", "endswith", "(", "']'", ")", "and", "w", "!=", "'[value_name]'", ":", "\n", "                        ", "gen_req", ".", "add", "(", "w", "[", "1", ":", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "\n", "", "", "for", "w", "in", "resp_token", ":", "\n", "                    ", "if", "'[value_'", "in", "w", "and", "w", ".", "endswith", "(", "']'", ")", "and", "w", "!=", "'[value_name]'", ":", "\n", "                        ", "truth_req", ".", "add", "(", "w", "[", "1", ":", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "\n", "# print(dial_id)", "\n", "# print('gen_req:', gen_req)", "\n", "# print('truth_req:', truth_req)", "\n", "# print('')", "\n", "", "", "", "for", "req", "in", "gen_req", ":", "\n", "                ", "if", "req", "in", "truth_req", ":", "\n", "                    ", "tp", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "fp", "+=", "1", "\n", "", "", "for", "req", "in", "truth_req", ":", "\n", "                ", "if", "req", "not", "in", "gen_req", ":", "\n", "                    ", "fn", "+=", "1", "\n", "", "", "", "precision", ",", "recall", "=", "tp", "/", "(", "tp", "+", "fp", "+", "1e-8", ")", ",", "tp", "/", "(", "tp", "+", "fn", "+", "1e-8", ")", "\n", "# print('precision:', precision, 'recall:', recall)", "\n", "f1", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", "+", "1e-8", ")", "\n", "return", "f1", ",", "precision", ",", "recall", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.act_metric": [[256, 308], ["tp.items", "metric.GenericEvaluator._normalize_act", "metric.GenericEvaluator._normalize_act", "tp.get", "fp.get", "fn.get", "tp.get", "fp.get", "fn.get"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator._normalize_act", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator._normalize_act"], ["", "def", "act_metric", "(", "self", ",", "data", ")", ":", "\n", "# turn level metric", "\n", "        ", "tp", ",", "fp", ",", "fn", "=", "{", "'all_s'", ":", "0", ",", "'all_v'", ":", "0", "}", ",", "{", "'all_s'", ":", "0", ",", "'all_v'", ":", "0", "}", ",", "{", "'all_s'", ":", "0", ",", "'all_v'", ":", "0", "}", "\n", "for", "s", "in", "self", ".", "requestable_slots", ":", "\n", "            ", "tp", "[", "s", "]", ",", "fp", "[", "s", "]", ",", "fn", "[", "s", "]", "=", "0", ",", "0", ",", "0", "\n", "tp", "[", "'[value_%s]'", "%", "s", "]", ",", "fp", "[", "'[value_%s]'", "%", "s", "]", ",", "fn", "[", "'[value_%s]'", "%", "s", "]", "=", "0", ",", "0", ",", "0", "\n", "\n", "", "for", "row", "in", "data", ":", "\n", "            ", "gen", "=", "self", ".", "_normalize_act", "(", "row", "[", "'aspn_gen'", "]", ")", "\n", "truth", "=", "self", ".", "_normalize_act", "(", "row", "[", "'aspn'", "]", ")", "\n", "valid", "=", "'thank'", "not", "in", "row", "[", "'user'", "]", "and", "'bye'", "not", "in", "row", "[", "'user'", "]", "\n", "if", "valid", ":", "\n", "# how well the act decoder captures user's requests", "\n", "                ", "for", "value", "in", "gen", "[", "'av'", "]", ":", "\n", "                    ", "if", "value", "in", "truth", "[", "'av'", "]", ":", "\n", "                        ", "tp", "[", "'all_v'", "]", "+=", "1", "\n", "if", "tp", ".", "get", "(", "value", ")", ":", "\n", "                            ", "tp", "[", "value", "]", "+=", "1", "\n", "", "", "else", ":", "\n", "                        ", "fp", "[", "'all_v'", "]", "+=", "1", "\n", "if", "fp", ".", "get", "(", "value", ")", ":", "\n", "                            ", "fp", "[", "value", "]", "+=", "1", "\n", "", "", "", "for", "value", "in", "truth", "[", "'av'", "]", ":", "\n", "                    ", "if", "value", "not", "in", "gen", "[", "'av'", "]", ":", "\n", "                        ", "fn", "[", "'all_v'", "]", "+=", "1", "\n", "if", "fn", ".", "get", "(", "value", ")", ":", "\n", "                            ", "fn", "[", "value", "]", "+=", "1", "\n", "\n", "# how accurately the act decoder predicts system's question", "\n", "", "", "", "if", "'as'", "not", "in", "gen", ":", "\n", "                    ", "continue", "\n", "", "for", "slot", "in", "gen", "[", "'as'", "]", ":", "\n", "                    ", "if", "slot", "in", "truth", "[", "'as'", "]", ":", "\n", "                        ", "tp", "[", "'all_s'", "]", "+=", "1", "\n", "if", "tp", ".", "get", "(", "slot", ")", ":", "\n", "                            ", "tp", "[", "slot", "]", "+=", "1", "\n", "", "", "else", ":", "\n", "                        ", "fp", "[", "'all_s'", "]", "+=", "1", "\n", "if", "fp", ".", "get", "(", "slot", ")", ":", "\n", "                            ", "fp", "[", "slot", "]", "+=", "1", "\n", "", "", "", "for", "slot", "in", "truth", "[", "'as'", "]", ":", "\n", "                    ", "if", "slot", "not", "in", "gen", "[", "'as'", "]", ":", "\n", "                        ", "fn", "[", "'all_s'", "]", "+=", "1", "\n", "if", "fn", ".", "get", "(", "slot", ")", ":", "\n", "                            ", "fn", "[", "slot", "]", "+=", "1", "\n", "\n", "", "", "", "", "", "result", "=", "{", "}", "\n", "for", "k", ",", "v", "in", "tp", ".", "items", "(", ")", ":", "\n", "            ", "precision", ",", "recall", "=", "tp", "[", "k", "]", "/", "(", "tp", "[", "k", "]", "+", "fp", "[", "k", "]", "+", "1e-8", ")", ",", "tp", "[", "k", "]", "/", "(", "tp", "[", "k", "]", "+", "fn", "[", "k", "]", "+", "1e-8", ")", "\n", "f1", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", "+", "1e-8", ")", "\n", "result", "[", "k", "]", "=", "[", "f1", ",", "precision", ",", "recall", "]", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.CamRestEvaluator.__init__": [[311, 316], ["metric.GenericEvaluator.__init__", "metric.CamRestEvaluator.get_entities"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.get_entities"], ["    ", "def", "__init__", "(", "self", ",", "reader", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "reader", ")", "\n", "self", ".", "entities_flat", ",", "self", ".", "entitiy_to_slot_dict", "=", "self", ".", "get_entities", "(", "cfg", ".", "ontology_path", ")", "\n", "self", ".", "informable_slots", "=", "self", ".", "reader", ".", "otlg", ".", "informable_slots", "\n", "self", ".", "requestable_slots", "=", "self", ".", "reader", ".", "otlg", ".", "requestable_slots", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.CamRestEvaluator.run_metrics": [[318, 350], ["metric.CamRestEvaluator.bleu_metric", "metric.CamRestEvaluator.tracker_metric", "metric.CamRestEvaluator.match_metric", "metric.CamRestEvaluator.request_metric", "logging.info", "slot_acc.items", "logging.info", "metric.CamRestEvaluator.act_metric", "logging.info", "slot.split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.bleu_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.tracker_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.match_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.request_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.act_metric"], ["", "def", "run_metrics", "(", "self", ",", "results", ")", ":", "\n", "        ", "metrics", "=", "{", "}", "\n", "bleu", "=", "self", ".", "bleu_metric", "(", "results", ")", "\n", "p", ",", "r", ",", "f1", ",", "goal_acc", ",", "slot_acc", ",", "db_acc", "=", "self", ".", "tracker_metric", "(", "results", ")", "\n", "match", "=", "self", ".", "match_metric", "(", "results", ")", "\n", "req_f1", ",", "req_p", ",", "req_r", "=", "self", ".", "request_metric", "(", "results", ")", "\n", "\n", "logging", ".", "info", "(", "'[RES] bleu: %.3f  match: %.3f  req_f1: %.3f  db_acc: %.3f'", "%", "(", "bleu", ",", "match", ",", "req_f1", ",", "db_acc", ")", ")", "\n", "# logging.info('[DST] joint goal: %.3f  slot p: %.3f  r: %.3f  f1: %.3f'%(goal_acc, p, r, f1))", "\n", "slot_accu_str", "=", "''", "\n", "for", "slot", ",", "accu", "in", "slot_acc", ".", "items", "(", ")", ":", "\n", "            ", "slot_accu_str", "+=", "'%s: %.3f '", "%", "(", "slot", ".", "split", "(", "'-'", ")", "[", "1", "]", ",", "accu", ")", "\n", "", "logging", ".", "info", "(", "'[DST] joint goal: %.3f  '", "%", "(", "goal_acc", ")", "+", "slot_accu_str", ")", "\n", "\n", "metrics", "[", "'bleu'", "]", "=", "bleu", "\n", "metrics", "[", "'match'", "]", "=", "match", "\n", "metrics", "[", "'req_f1'", "]", "=", "req_f1", "\n", "metrics", "[", "'joint_goal'", "]", "=", "goal_acc", "\n", "metrics", "[", "'slot_accu'", "]", "=", "slot_acc", "\n", "metrics", "[", "'slot-p/r/f1'", "]", "=", "(", "p", ",", "r", ",", "f1", ")", "\n", "metrics", "[", "'db_acc'", "]", "=", "db_acc", "\n", "\n", "if", "cfg", ".", "model_act", ":", "\n", "            ", "act_metric", "=", "self", ".", "act_metric", "(", "results", ")", "\n", "logging", ".", "info", "(", "'[ACT] value f1: %.3f  slot f1: %.3f'", "%", "(", "act_metric", "[", "'all_v'", "]", "[", "0", "]", ",", "act_metric", "[", "'all_s'", "]", "[", "0", "]", ")", ")", "\n", "metrics", "[", "'value_pred_f1'", "]", "=", "act_metric", "[", "'all_v'", "]", "[", "0", "]", "\n", "metrics", "[", "'slot_pred_f1'", "]", "=", "act_metric", "[", "'all_s'", "]", "[", "0", "]", "\n", "metrics", "[", "'act_verbose'", "]", "=", "act_metric", "\n", "", "else", ":", "\n", "            ", "metrics", "[", "'value_pred_f1'", "]", ",", "metrics", "[", "'slot_pred_f1'", "]", ",", "metrics", "[", "'act_verbose'", "]", "=", "''", ",", "''", ",", "''", "\n", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.CamRestEvaluator.get_entities": [[352, 362], ["json.loads", "open().read().lower", "entities_flat.extend", "open().read", "open"], "methods", ["None"], ["", "def", "get_entities", "(", "self", ",", "entity_path", ")", ":", "\n", "        ", "entities_flat", "=", "[", "]", "\n", "entitiy_to_slot_dict", "=", "{", "}", "\n", "raw_entities", "=", "json", ".", "loads", "(", "open", "(", "entity_path", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "for", "s", "in", "raw_entities", "[", "'informable'", "]", ":", "\n", "            ", "entities_flat", ".", "extend", "(", "raw_entities", "[", "'informable'", "]", "[", "s", "]", ")", "\n", "for", "v", "in", "raw_entities", "[", "'informable'", "]", "[", "s", "]", ":", "\n", "                ", "entitiy_to_slot_dict", "[", "v", "]", "=", "s", "\n", "# print(entitiy_to_slot_dict)", "\n", "", "", "return", "entities_flat", ",", "entitiy_to_slot_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.CamRestEvaluator.match_metric": [[363, 384], ["metric.CamRestEvaluator.pack_dial", "enumerate", "metric.CamRestEvaluator._normalize_constraint", "list", "metric.CamRestEvaluator._normalize_constraint", "metric.CamRestEvaluator._normalize_constraint", "metric.CamRestEvaluator.values"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.pack_dial", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint"], ["", "def", "match_metric", "(", "self", ",", "data", ")", ":", "\n", "        ", "dials", "=", "self", ".", "pack_dial", "(", "data", ")", "\n", "match", ",", "total", "=", "0", ",", "1e-8", "\n", "for", "dial_id", "in", "dials", ":", "\n", "            ", "dial", "=", "dials", "[", "dial_id", "]", "\n", "truth_cons", ",", "gen_cons", "=", "{", "'1'", ":", "''", ",", "'2'", ":", "''", ",", "'3'", ":", "''", "}", ",", "None", "\n", "for", "turn_num", ",", "turn", "in", "enumerate", "(", "dial", ")", ":", "\n", "# find the last turn which the system provide an entity", "\n", "                ", "if", "'[value'", "in", "turn", "[", "'resp_gen'", "]", ":", "\n", "                    ", "gen_cons", "=", "self", ".", "_normalize_constraint", "(", "turn", "[", "'bspn_gen'", "]", ",", "ignore_dontcare", "=", "True", ")", "\n", "", "if", "'[value'", "in", "turn", "[", "'resp'", "]", ":", "\n", "                    ", "truth_cons", "=", "self", ".", "_normalize_constraint", "(", "turn", "[", "'bspn'", "]", ",", "ignore_dontcare", "=", "True", ")", "\n", "", "", "if", "not", "gen_cons", ":", "\n", "# if no entity is provided, choose the state of the last dialog turn", "\n", "                ", "gen_cons", "=", "self", ".", "_normalize_constraint", "(", "dial", "[", "-", "1", "]", "[", "'bspn_gen'", "]", ",", "ignore_dontcare", "=", "True", ")", "\n", "", "if", "list", "(", "truth_cons", ".", "values", "(", ")", ")", "!=", "[", "''", ",", "''", ",", "''", "]", ":", "\n", "                ", "if", "gen_cons", "==", "truth_cons", ":", "\n", "                    ", "match", "+=", "1", "\n", "", "total", "+=", "1", "\n", "\n", "", "", "return", "match", "/", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.CamRestEvaluator.clean": [[385, 394], ["utils.clean_replace.replace", "metric.CamRestEvaluator.entitiy_to_slot_dict.items", "utils.clean_replace"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.clean_replace"], ["", "def", "clean", "(", "self", ",", "resp", ")", ":", "\n", "# we  use the same clean process as in Sequicity, SEDST, FSDM", "\n", "# to ensure comparable results", "\n", "        ", "resp", "=", "resp", ".", "replace", "(", "'<go_r> '", ",", "''", ")", "\n", "resp", "=", "'<go_r> '", "+", "resp", "+", "' <eos_r>'", "\n", "for", "value", ",", "slot", "in", "self", ".", "entitiy_to_slot_dict", ".", "items", "(", ")", ":", "\n", "# s = s.replace(item, 'VALUE_{}'.format(self.entity_dict[item]))", "\n", "            ", "resp", "=", "utils", ".", "clean_replace", "(", "resp", ",", "value", ",", "'[value_%s]'", "%", "slot", ")", "\n", "", "return", "resp", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.__init__": [[397, 402], ["metric.GenericEvaluator.__init__", "metric.KvretEvaluator.get_entities"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.get_entities"], ["    ", "def", "__init__", "(", "self", ",", "reader", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "reader", ")", "\n", "self", ".", "entities_flat", ",", "self", ".", "entitiy_to_slot_dict", "=", "self", ".", "get_entities", "(", "cfg", ".", "ontology_path", ")", "\n", "self", ".", "informable_slots", "=", "self", ".", "reader", ".", "otlg", ".", "informable_slots", "\n", "self", ".", "requestable_slots", "=", "self", ".", "reader", ".", "otlg", ".", "requestable_slots", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.run_metrics": [[407, 430], ["metric.KvretEvaluator.bleu_metric", "metric.KvretEvaluator.tracker_metric", "metric.KvretEvaluator.match_metric", "metric.KvretEvaluator.request_metric", "logging.info", "slot_acc.items", "logging.info", "slot.split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.bleu_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.tracker_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.match_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.request_metric"], ["", "def", "run_metrics", "(", "self", ",", "results", ")", ":", "\n", "        ", "metrics", "=", "{", "}", "\n", "bleu", "=", "self", ".", "bleu_metric", "(", "results", ")", "\n", "p", ",", "r", ",", "f1", ",", "goal_acc", ",", "slot_acc", ",", "db_acc", "=", "self", ".", "tracker_metric", "(", "results", ",", "normalize", "=", "True", ")", "\n", "match", "=", "self", ".", "match_metric", "(", "results", ")", "\n", "req_f1", ",", "req_p", ",", "req_r", "=", "self", ".", "request_metric", "(", "results", ")", "\n", "\n", "logging", ".", "info", "(", "'[RES] bleu: %.3f  match: %.3f  req_f1: %.3f  db_acc: %.3f'", "%", "(", "bleu", ",", "match", ",", "req_f1", ",", "db_acc", ")", ")", "\n", "# logging.info('[DST] joint goal: %.3f  slot p: %.3f  r: %.3f  f1: %.3f'%(goal_acc, p, r, f1))", "\n", "slot_accu_str", "=", "''", "\n", "for", "slot", ",", "accu", "in", "slot_acc", ".", "items", "(", ")", ":", "\n", "            ", "slot_accu_str", "+=", "'%s: %.3f '", "%", "(", "slot", ".", "split", "(", "'-'", ")", "[", "1", "]", ",", "accu", ")", "\n", "", "logging", ".", "info", "(", "'[DST] joint goal: %.3f  '", "%", "(", "goal_acc", ")", "+", "slot_accu_str", ")", "\n", "\n", "metrics", "[", "'bleu'", "]", "=", "bleu", "\n", "metrics", "[", "'match'", "]", "=", "match", "\n", "metrics", "[", "'req_f1'", "]", "=", "req_f1", "\n", "metrics", "[", "'joint_goal'", "]", "=", "goal_acc", "\n", "metrics", "[", "'slot_accu'", "]", "=", "slot_acc", "\n", "metrics", "[", "'slot-p/r/f1'", "]", "=", "(", "p", ",", "r", ",", "f1", ")", "\n", "metrics", "[", "'db_acc'", "]", "=", "db_acc", "\n", "\n", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint": [[431, 453], ["constraint.items", "v.replace().split", "v.replace"], "methods", ["None"], ["", "def", "_normalize_constraint", "(", "self", ",", "constraint", ",", "ignore_dontcare", "=", "False", ",", "intersection", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Normalize belief span, e.g. delete repeated words\n        :param constraint - {'food': 'asian oritental', 'pricerange': 'cheap'}\n        :param intersection: if true, only keeps the words that appear in th ontology\n                                        we set intersection=True as in previous works\n        :returns: normalized constraint dict\n                      e.g. - {'food': 'asian oritental', 'pricerange': 'cheap', 'area': ''}\n        \"\"\"", "\n", "junk", "=", "[", "'good'", ",", "'great'", ",", "'quickest'", ",", "'shortest'", ",", "'route'", ",", "'week'", ",", "'fastest'", ",", "'nearest'", ",", "'next'", ",", "'closest'", ",", "\n", "'way'", ",", "'mile'", ",", "'activity'", ",", "'restaurant'", ",", "'appointment'", "]", "\n", "normalized", "=", "{", "}", "\n", "for", "s", "in", "self", ".", "informable_slots", ":", "\n", "            ", "normalized", "[", "s", "]", "=", "''", "\n", "", "for", "s", ",", "v", "in", "constraint", ".", "items", "(", ")", ":", "\n", "            ", "for", "j", "in", "junk", ":", "\n", "                ", "v", "=", "' '", ".", "join", "(", "v", ".", "replace", "(", "j", ",", "''", ")", ".", "split", "(", ")", ")", "\n", "", "if", "intersection", "and", "v", "not", "in", "self", ".", "entities_flat", ":", "\n", "                ", "continue", "\n", "", "normalized", "[", "s", "]", "=", "v", "\n", "\n", "", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.get_entities": [[455, 465], ["entities_flat.append"], "methods", ["None"], ["", "def", "get_entities", "(", "self", ",", "entity_path", ")", ":", "\n", "        ", "entities_flat", "=", "[", "]", "\n", "entitiy_to_slot_dict", "=", "{", "}", "\n", "\n", "entitiy_to_slot_dict", "=", "self", ".", "reader", ".", "dataset", ".", "entity_dict", "\n", "for", "s", "in", "entitiy_to_slot_dict", ":", "\n", "            ", "if", "s", "not", "in", "entities_flat", ":", "\n", "                ", "entities_flat", ".", "append", "(", "s", ")", "\n", "# print(entitiy_to_slot_dict)", "\n", "", "", "return", "entities_flat", ",", "entitiy_to_slot_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.match_metric": [[466, 487], ["metric.KvretEvaluator.pack_dial", "enumerate", "metric.KvretEvaluator._normalize_constraint", "list", "metric.KvretEvaluator._normalize_constraint", "metric.KvretEvaluator._normalize_constraint", "metric.KvretEvaluator.values"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.pack_dial", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator._normalize_constraint"], ["", "def", "match_metric", "(", "self", ",", "data", ")", ":", "\n", "        ", "dials", "=", "self", ".", "pack_dial", "(", "data", ")", "\n", "match", ",", "total", "=", "0", ",", "1e-8", "\n", "for", "dial_id", "in", "dials", ":", "\n", "            ", "dial", "=", "dials", "[", "dial_id", "]", "\n", "truth_cons", ",", "gen_cons", "=", "{", "'1'", ":", "''", ",", "'2'", ":", "''", ",", "'3'", ":", "''", ",", "'4'", ":", "''", ",", "'5'", ":", "''", ",", "'6'", ":", "''", ",", "'7'", ":", "''", ",", "'8'", ":", "''", ",", "'9'", ":", "''", ",", "'10'", ":", "''", ",", "'11'", ":", "''", "}", ",", "None", "\n", "for", "turn_num", ",", "turn", "in", "enumerate", "(", "dial", ")", ":", "\n", "# find the last turn which the system provide an entity", "\n", "                ", "if", "'[value'", "in", "turn", "[", "'resp_gen'", "]", ":", "\n", "                    ", "gen_cons", "=", "self", ".", "_normalize_constraint", "(", "turn", "[", "'bspn_gen'", "]", ",", "ignore_dontcare", "=", "True", ")", "\n", "", "if", "'[value'", "in", "turn", "[", "'resp'", "]", ":", "\n", "                    ", "truth_cons", "=", "self", ".", "_normalize_constraint", "(", "turn", "[", "'bspn'", "]", ",", "ignore_dontcare", "=", "True", ")", "\n", "", "", "if", "not", "gen_cons", ":", "\n", "# if no entity is provided, choose the state of the last dialog turn", "\n", "                ", "gen_cons", "=", "self", ".", "_normalize_constraint", "(", "dial", "[", "-", "1", "]", "[", "'bspn_gen'", "]", ",", "ignore_dontcare", "=", "True", ")", "\n", "", "if", "list", "(", "truth_cons", ".", "values", "(", ")", ")", "!=", "[", "''", "]", "*", "11", ":", "\n", "                ", "if", "gen_cons", "==", "truth_cons", ":", "\n", "                    ", "match", "+=", "1", "\n", "", "total", "+=", "1", "\n", "\n", "", "", "return", "match", "/", "total", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.KvretEvaluator.clean": [[488, 497], ["utils.clean_replace.replace", "metric.KvretEvaluator.entitiy_to_slot_dict.items", "utils.clean_replace"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.clean_replace"], ["", "def", "clean", "(", "self", ",", "resp", ")", ":", "\n", "# we  use the same clean process as in Sequicity, SEDST, FSDM", "\n", "# to ensure comparable results", "\n", "        ", "resp", "=", "resp", ".", "replace", "(", "'<go_r> '", ",", "''", ")", "\n", "resp", "=", "'<go_r> '", "+", "resp", "+", "' <eos_r>'", "\n", "for", "value", ",", "slot", "in", "self", ".", "entitiy_to_slot_dict", ".", "items", "(", ")", ":", "\n", "# s = s.replace(item, 'VALUE_{}'.format(self.entity_dict[item]))", "\n", "            ", "resp", "=", "utils", ".", "clean_replace", "(", "resp", ",", "value", ",", "'[value_%s]'", "%", "slot", ")", "\n", "", "return", "resp", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.__init__": [[500, 509], ["metric.GenericEvaluator.__init__", "json.loads", "open().read().lower", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "reader", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "reader", ")", "\n", "self", ".", "otlg", "=", "self", ".", "reader", ".", "otlg", "\n", "self", ".", "dataset", "=", "self", ".", "reader", ".", "dataset", "\n", "self", ".", "vocab", "=", "self", ".", "reader", ".", "vocab", "\n", "self", ".", "goals", "=", "json", ".", "loads", "(", "open", "(", "cfg", ".", "dial_goals", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "self", ".", "informable_slots", "=", "self", ".", "reader", ".", "otlg", ".", "informable_slots", "\n", "self", ".", "requestable_slots", "=", "self", ".", "reader", ".", "otlg", ".", "requestable_slots", "\n", "self", ".", "eval_requestables", "=", "[", "'phone'", ",", "'address'", ",", "'postcode'", ",", "'reference'", ",", "'id'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.clean": [[510, 512], ["None"], "methods", ["None"], ["", "def", "clean", "(", "self", ",", "resp", ")", ":", "\n", "        ", "return", "resp", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.run_metrics": [[513, 544], ["metric.MultiwozEvaluator.bleu_metric", "metric.MultiwozEvaluator.tracker_metric", "metric.MultiwozEvaluator.context_to_response_eval", "logging.info", "logging.info", "metric.MultiwozEvaluator.act_metric", "logging.info"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.bleu_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.tracker_metric", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.context_to_response_eval", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.act_metric"], ["", "def", "run_metrics", "(", "self", ",", "results", ")", ":", "\n", "        ", "metrics", "=", "{", "}", "\n", "bleu", "=", "self", ".", "bleu_metric", "(", "results", ")", "\n", "p", ",", "r", ",", "f1", ",", "goal_acc", ",", "slot_acc", ",", "db_acc", "=", "self", ".", "tracker_metric", "(", "results", ",", "normalize", "=", "False", ")", "\n", "success", ",", "match", ",", "counts", ",", "dial_num", "=", "self", ".", "context_to_response_eval", "(", "results", ")", "\n", "\n", "logging", ".", "info", "(", "'[RES] bleu: %.3f  match: %.3f  success: %.3f  db_acc: %.3f'", "%", "(", "bleu", ",", "match", ",", "success", ",", "db_acc", ")", ")", "\n", "# logging.info('[DST] joint goal: %.3f  slot p: %.3f  r: %.3f  f1: %.3f'%(goal_acc, p, r, f1))", "\n", "slot_accu_str", "=", "''", "\n", "# for slot, accu in slot_acc.items():", "\n", "#     slot_accu_str += '%s: %.3f '%(slot.split('-')[1], accu)", "\n", "logging", ".", "info", "(", "'[DST] joint goal: %.3f  '", "%", "(", "goal_acc", ")", "+", "slot_accu_str", ")", "\n", "\n", "metrics", "[", "'bleu'", "]", "=", "bleu", "\n", "metrics", "[", "'match'", "]", "=", "match", "\n", "metrics", "[", "'success'", "]", "=", "success", "\n", "metrics", "[", "'joint_goal'", "]", "=", "goal_acc", "\n", "metrics", "[", "'slot_accu'", "]", "=", "slot_acc", "\n", "metrics", "[", "'slot-p/r/f1'", "]", "=", "(", "p", ",", "r", ",", "f1", ")", "\n", "metrics", "[", "'db_acc'", "]", "=", "db_acc", "\n", "\n", "if", "cfg", ".", "model_act", ":", "\n", "            ", "act_metric", "=", "self", ".", "act_metric", "(", "results", ")", "\n", "logging", ".", "info", "(", "'[ACT] value f1: %.3f  slot f1: %.3f'", "%", "(", "act_metric", "[", "'all_v'", "]", "[", "0", "]", ",", "act_metric", "[", "'all_s'", "]", "[", "0", "]", ")", ")", "\n", "metrics", "[", "'value_pred_f1'", "]", "=", "act_metric", "[", "'all_v'", "]", "[", "0", "]", "\n", "metrics", "[", "'slot_pred_f1'", "]", "=", "act_metric", "[", "'all_s'", "]", "[", "0", "]", "\n", "metrics", "[", "'act_verbose'", "]", "=", "act_metric", "\n", "", "else", ":", "\n", "            ", "metrics", "[", "'value_pred_f1'", "]", ",", "metrics", "[", "'slot_pred_f1'", "]", ",", "metrics", "[", "'act_verbose'", "]", "=", "''", ",", "''", ",", "''", "\n", "\n", "", "return", "metrics", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.context_to_response_eval": [[546, 580], ["metric.MultiwozEvaluator.pack_dial", "metric.MultiwozEvaluator.keys", "metric.MultiwozEvaluator._evaluateGeneratedDialogue", "metric.MultiwozEvaluator.goals[].get", "float", "float", "metric.MultiwozEvaluator._parseGoal"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.GenericEvaluator.pack_dial", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator._evaluateGeneratedDialogue", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator._parseGoal"], ["", "def", "context_to_response_eval", "(", "self", ",", "data", ",", "eval_dial_list", "=", "None", ",", "same_eval_as_cambridge", "=", "True", ")", ":", "\n", "        ", "dials", "=", "self", ".", "pack_dial", "(", "data", ")", "\n", "counts", "=", "{", "}", "\n", "for", "req", "in", "self", ".", "eval_requestables", ":", "\n", "            ", "counts", "[", "req", "+", "'_total'", "]", "=", "0", "\n", "counts", "[", "req", "+", "'_offer'", "]", "=", "0", "\n", "\n", "", "dial_num", ",", "successes", ",", "matches", "=", "0", ",", "0", ",", "0", "\n", "\n", "for", "dial_id", "in", "dials", ":", "\n", "            ", "if", "eval_dial_list", "and", "dial_id", "+", "'.json'", "not", "in", "eval_dial_list", ":", "\n", "                ", "continue", "\n", "", "dial", "=", "dials", "[", "dial_id", "]", "\n", "reqs", "=", "{", "}", "\n", "goal", "=", "{", "}", "\n", "for", "domain", "in", "self", ".", "otlg", ".", "all_domains", ":", "\n", "                ", "if", "self", ".", "goals", "[", "dial_id", "]", ".", "get", "(", "domain", ")", ":", "\n", "                    ", "true_goal", "=", "self", ".", "goals", "[", "dial_id", "]", "\n", "goal", "=", "self", ".", "_parseGoal", "(", "goal", ",", "true_goal", ",", "domain", ")", "\n", "# print(goal)", "\n", "", "", "for", "domain", "in", "goal", ".", "keys", "(", ")", ":", "\n", "                ", "reqs", "[", "domain", "]", "=", "goal", "[", "domain", "]", "[", "'requestable'", "]", "\n", "# print('\\n',dial_id)", "\n", "", "success", ",", "match", ",", "stats", ",", "counts", "=", "self", ".", "_evaluateGeneratedDialogue", "(", "dial", ",", "goal", ",", "reqs", ",", "counts", ",", "\n", "same_eval_as_cambridge", "=", "same_eval_as_cambridge", ")", "\n", "\n", "successes", "+=", "success", "\n", "matches", "+=", "match", "\n", "dial_num", "+=", "1", "\n", "\n", "# self.logger.info(report)", "\n", "", "succ_rate", "=", "successes", "/", "(", "float", "(", "dial_num", ")", "+", "1e-10", ")", "\n", "match_rate", "=", "matches", "/", "(", "float", "(", "dial_num", ")", "+", "1e-10", ")", "\n", "return", "succ_rate", ",", "match_rate", ",", "counts", ",", "dial_num", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.get_constraint_dict": [[581, 591], ["constraint.items", "d_s.split"], "methods", ["None"], ["", "def", "get_constraint_dict", "(", "self", ",", "constraint", ",", "intersection", "=", "False", ")", ":", "\n", "        ", "\"\"\"\n        \"\"\"", "\n", "normalized", "=", "{", "}", "\n", "for", "d_s", ",", "v", "in", "constraint", ".", "items", "(", ")", ":", "\n", "            ", "d", ",", "s", "=", "d_s", ".", "split", "(", "'-'", ")", "\n", "if", "d", "not", "in", "normalized", ":", "\n", "                ", "normalized", "[", "d", "]", "=", "{", "}", "\n", "", "normalized", "[", "d", "]", "[", "s", "]", "=", "v", "\n", "", "return", "normalized", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator._evaluateGeneratedDialogue": [[594, 780], ["goal.keys", "enumerate", "goal.keys", "goal.keys", "domains_in_goal.append", "goal.keys", "metric.MultiwozEvaluator.reader.db.queryJsons", "float", "len", "len", "goal.keys", "goal.keys", "len", "len", "float", "len", "len", "turn[].split", "turn[].split", "metric.MultiwozEvaluator.get_constraint_dict", "metric.MultiwozEvaluator.get", "type", "metric.MultiwozEvaluator.reader.db.queryJsons", "provided_requestables[].append", "len", "len", "len", "provided_requestables[].append", "set", "set"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.queryJsons", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.get_constraint_dict", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.queryJsons"], ["", "def", "_evaluateGeneratedDialogue", "(", "self", ",", "dialog", ",", "goal", ",", "real_requestables", ",", "counts", ",", "\n", "soft_acc", "=", "False", ",", "same_eval_as_cambridge", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluates the dialogue created by the model.\n            First we load the user goal of the dialogue, then for each turn\n            generated by the system we look for key-words.\n            For the Inform rate we look whether the entity was proposed.\n            For the Success rate we look for requestables slots\"\"\"", "\n", "# for computing corpus success", "\n", "#'id'", "\n", "requestables", "=", "self", ".", "eval_requestables", "\n", "\n", "# CHECK IF MATCH HAPPENED", "\n", "provided_requestables", "=", "{", "}", "\n", "venue_offered", "=", "{", "}", "\n", "domains_in_goal", "=", "[", "]", "\n", "bspans", "=", "{", "}", "\n", "\n", "for", "domain", "in", "goal", ".", "keys", "(", ")", ":", "\n", "            ", "venue_offered", "[", "domain", "]", "=", "[", "]", "\n", "provided_requestables", "[", "domain", "]", "=", "[", "]", "\n", "domains_in_goal", ".", "append", "(", "domain", ")", "\n", "\n", "", "for", "t", ",", "turn", "in", "enumerate", "(", "dialog", ")", ":", "\n", "            ", "sent_t", "=", "turn", "[", "'resp_gen'", "]", "\n", "# sent_t = turn['resp']", "\n", "for", "domain", "in", "goal", ".", "keys", "(", ")", ":", "\n", "# for computing success", "\n", "                ", "if", "same_eval_as_cambridge", ":", "\n", "# [restaurant_name], [hotel_name] instead of [value_name]", "\n", "                    ", "if", "cfg", ".", "use_true_domain_for_ctr_eval", ":", "\n", "                        ", "dom_pred", "=", "turn", "[", "'dom'", "]", ".", "split", "(", ")", "\n", "", "else", ":", "\n", "                        ", "dom_pred", "=", "turn", "[", "'dom_gen'", "]", ".", "split", "(", ")", "\n", "# else:", "\n", "#     raise NotImplementedError('Just use true domain label')", "\n", "# print(domain, dom_pred)", "\n", "", "if", "domain", "not", "in", "dom_pred", ":", "# fail", "\n", "                        ", "continue", "\n", "", "", "if", "'[value_name]'", "in", "sent_t", "or", "'[value_id]'", "in", "sent_t", ":", "\n", "                    ", "if", "domain", "in", "[", "'restaurant'", ",", "'hotel'", ",", "'attraction'", ",", "'train'", "]", ":", "\n", "# HERE YOU CAN PUT YOUR BELIEF STATE ESTIMATION", "\n", "                        ", "if", "not", "cfg", ".", "use_true_bspn_for_ctr_eval", ":", "\n", "                            ", "bspn", "=", "turn", "[", "'bspn_gen'", "]", "\n", "", "else", ":", "\n", "                            ", "bspn", "=", "turn", "[", "'bspn'", "]", "\n", "# bspn = turn['bspn']", "\n", "\n", "", "constraint_dict", "=", "self", ".", "get_constraint_dict", "(", "bspn", ")", "\n", "if", "constraint_dict", ".", "get", "(", "domain", ")", ":", "\n", "                            ", "venues", "=", "self", ".", "reader", ".", "db", ".", "queryJsons", "(", "domain", ",", "constraint_dict", "[", "domain", "]", ",", "return_name", "=", "True", ")", "\n", "", "else", ":", "\n", "                            ", "venues", "=", "[", "]", "\n", "\n", "# if venue has changed", "\n", "", "if", "len", "(", "venue_offered", "[", "domain", "]", ")", "==", "0", "and", "venues", ":", "\n", "# venue_offered[domain] = random.sample(venues, 1)", "\n", "                            ", "venue_offered", "[", "domain", "]", "=", "venues", "\n", "bspans", "[", "domain", "]", "=", "constraint_dict", "[", "domain", "]", "\n", "", "else", ":", "\n", "# flag = False", "\n", "# for ven in venues:", "\n", "#     if venue_offered[domain][0] == ven:", "\n", "#         flag = True", "\n", "#         break", "\n", "# if not flag and venues:", "\n", "                            ", "flag", "=", "False", "\n", "for", "ven", "in", "venues", ":", "\n", "                                ", "if", "ven", "not", "in", "venue_offered", "[", "domain", "]", ":", "\n", "                                    ", "flag", "=", "True", "\n", "break", "\n", "# if flag and venues:", "\n", "", "", "if", "flag", "and", "venues", ":", "# sometimes there are no results so sample won't work", "\n", "# print venues", "\n", "# venue_offered[domain] = random.sample(venues, 1)", "\n", "                                ", "venue_offered", "[", "domain", "]", "=", "venues", "\n", "bspans", "[", "domain", "]", "=", "constraint_dict", "[", "domain", "]", "\n", "", "", "", "else", ":", "# not limited so we can provide one", "\n", "                        ", "venue_offered", "[", "domain", "]", "=", "'[value_name]'", "\n", "\n", "# ATTENTION: assumption here - we didn't provide phone or address twice! etc", "\n", "", "", "for", "requestable", "in", "requestables", ":", "\n", "                    ", "if", "requestable", "==", "'reference'", ":", "\n", "                        ", "if", "'[value_reference]'", "in", "sent_t", ":", "\n", "                            ", "if", "'booked'", "in", "turn", "[", "'db_vec'", "]", "or", "'ok'", "in", "turn", "[", "'db_vec'", "]", ":", "# if pointer was allowing for that?", "\n", "                                ", "provided_requestables", "[", "domain", "]", ".", "append", "(", "'reference'", ")", "\n", "# provided_requestables[domain].append('reference')", "\n", "", "", "", "else", ":", "\n", "                        ", "if", "'[value_'", "+", "requestable", "+", "']'", "in", "sent_t", ":", "\n", "                            ", "provided_requestables", "[", "domain", "]", ".", "append", "(", "requestable", ")", "\n", "\n", "# if name was given in the task", "\n", "", "", "", "", "", "for", "domain", "in", "goal", ".", "keys", "(", ")", ":", "\n", "# if name was provided for the user, the match is being done automatically", "\n", "            ", "if", "'name'", "in", "goal", "[", "domain", "]", "[", "'informable'", "]", ":", "\n", "                ", "venue_offered", "[", "domain", "]", "=", "'[value_name]'", "\n", "\n", "# special domains - entity does not need to be provided", "\n", "", "if", "domain", "in", "[", "'taxi'", ",", "'police'", ",", "'hospital'", "]", ":", "\n", "                ", "venue_offered", "[", "domain", "]", "=", "'[value_name]'", "\n", "\n", "", "if", "domain", "==", "'train'", ":", "\n", "                ", "if", "not", "venue_offered", "[", "domain", "]", "and", "'id'", "not", "in", "goal", "[", "domain", "]", "[", "'requestable'", "]", ":", "\n", "                    ", "venue_offered", "[", "domain", "]", "=", "'[value_name]'", "\n", "\n", "", "", "", "\"\"\"\n        Given all inform and requestable slots\n        we go through each domain from the user goal\n        and check whether right entity was provided and\n        all requestable slots were given to the user.\n        The dialogue is successful if that's the case for all domains.\n        \"\"\"", "\n", "# HARD EVAL", "\n", "stats", "=", "{", "'restaurant'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'hotel'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'attraction'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'train'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'taxi'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "\n", "'hospital'", ":", "[", "0", ",", "0", ",", "0", "]", ",", "'police'", ":", "[", "0", ",", "0", ",", "0", "]", "}", "\n", "\n", "match", "=", "0", "\n", "success", "=", "0", "\n", "# MATCH", "\n", "for", "domain", "in", "goal", ".", "keys", "(", ")", ":", "\n", "            ", "match_stat", "=", "0", "\n", "if", "domain", "in", "[", "'restaurant'", ",", "'hotel'", ",", "'attraction'", ",", "'train'", "]", ":", "\n", "                ", "goal_venues", "=", "self", ".", "reader", ".", "db", ".", "queryJsons", "(", "domain", ",", "goal", "[", "domain", "]", "[", "'informable'", "]", ",", "return_name", "=", "True", ")", "\n", "if", "type", "(", "venue_offered", "[", "domain", "]", ")", "is", "str", "and", "'_name'", "in", "venue_offered", "[", "domain", "]", ":", "\n", "                    ", "match", "+=", "1", "\n", "match_stat", "=", "1", "\n", "", "elif", "len", "(", "venue_offered", "[", "domain", "]", ")", ">", "0", "and", "len", "(", "set", "(", "venue_offered", "[", "domain", "]", ")", "&", "set", "(", "goal_venues", ")", ")", ">", "0", ":", "\n", "                    ", "match", "+=", "1", "\n", "match_stat", "=", "1", "\n", "", "", "else", ":", "\n", "                ", "if", "'_name]'", "in", "venue_offered", "[", "domain", "]", ":", "\n", "                    ", "match", "+=", "1", "\n", "match_stat", "=", "1", "\n", "\n", "", "", "stats", "[", "domain", "]", "[", "0", "]", "=", "match_stat", "\n", "stats", "[", "domain", "]", "[", "2", "]", "=", "1", "\n", "\n", "", "if", "soft_acc", ":", "\n", "            ", "match", "=", "float", "(", "match", ")", "/", "len", "(", "goal", ".", "keys", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "if", "match", "==", "len", "(", "goal", ".", "keys", "(", ")", ")", ":", "\n", "                ", "match", "=", "1.0", "\n", "", "else", ":", "\n", "                ", "match", "=", "0.0", "\n", "\n", "", "", "for", "domain", "in", "domains_in_goal", ":", "\n", "            ", "for", "request", "in", "real_requestables", "[", "domain", "]", ":", "\n", "                ", "counts", "[", "request", "+", "'_total'", "]", "+=", "1", "\n", "if", "request", "in", "provided_requestables", "[", "domain", "]", ":", "\n", "                    ", "counts", "[", "request", "+", "'_offer'", "]", "+=", "1", "\n", "\n", "# SUCCESS", "\n", "", "", "", "if", "match", "==", "1.0", ":", "\n", "            ", "for", "domain", "in", "domains_in_goal", ":", "\n", "                ", "success_stat", "=", "0", "\n", "domain_success", "=", "0", "\n", "if", "len", "(", "real_requestables", "[", "domain", "]", ")", "==", "0", ":", "\n", "                    ", "success", "+=", "1", "\n", "success_stat", "=", "1", "\n", "stats", "[", "domain", "]", "[", "1", "]", "=", "success_stat", "\n", "continue", "\n", "# if values in sentences are super set of requestables", "\n", "# for request in set(provided_requestables[domain]):", "\n", "#     if request in real_requestables[domain]:", "\n", "#         domain_success += 1", "\n", "", "for", "request", "in", "real_requestables", "[", "domain", "]", ":", "\n", "                    ", "if", "request", "in", "provided_requestables", "[", "domain", "]", ":", "\n", "                        ", "domain_success", "+=", "1", "\n", "\n", "# if domain_success >= len(real_requestables[domain]):", "\n", "", "", "if", "domain_success", "==", "len", "(", "real_requestables", "[", "domain", "]", ")", ":", "\n", "                    ", "success", "+=", "1", "\n", "success_stat", "=", "1", "\n", "\n", "", "stats", "[", "domain", "]", "[", "1", "]", "=", "success_stat", "\n", "\n", "# final eval", "\n", "", "if", "soft_acc", ":", "\n", "                ", "success", "=", "float", "(", "success", ")", "/", "len", "(", "real_requestables", ")", "\n", "", "else", ":", "\n", "                ", "if", "success", ">=", "len", "(", "real_requestables", ")", ":", "\n", "                    ", "success", "=", "1", "\n", "", "else", ":", "\n", "                    ", "success", "=", "0", "\n", "\n", "", "", "", "return", "success", ",", "match", ",", "stats", ",", "counts", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator._parseGoal": [[783, 816], ["[].items", "metric.MultiwozEvaluator.otlg.slot_normlize.get", "v.strip.strip.strip", "[].append", "[].append", "len", "[].append", "v.strip.strip.split", "nltk.tokenize.word_tokenize", "v.strip.strip.replace().split", "[].append", "v.strip.strip.replace"], "methods", ["None"], ["", "def", "_parseGoal", "(", "self", ",", "goal", ",", "true_goal", ",", "domain", ")", ":", "\n", "        ", "\"\"\"Parses user goal into dictionary format.\"\"\"", "\n", "goal", "[", "domain", "]", "=", "{", "}", "\n", "goal", "[", "domain", "]", "=", "{", "'informable'", ":", "{", "}", ",", "'requestable'", ":", "[", "]", ",", "'booking'", ":", "[", "]", "}", "\n", "if", "'info'", "in", "true_goal", "[", "domain", "]", ":", "\n", "            ", "if", "domain", "==", "'train'", ":", "\n", "# we consider dialogues only where train had to be booked!", "\n", "                ", "if", "'book'", "in", "true_goal", "[", "domain", "]", ":", "\n", "                    ", "goal", "[", "domain", "]", "[", "'requestable'", "]", ".", "append", "(", "'reference'", ")", "\n", "", "if", "'reqt'", "in", "true_goal", "[", "domain", "]", ":", "\n", "                    ", "if", "'id'", "in", "true_goal", "[", "domain", "]", "[", "'reqt'", "]", ":", "\n", "                        ", "goal", "[", "domain", "]", "[", "'requestable'", "]", ".", "append", "(", "'id'", ")", "\n", "", "", "", "else", ":", "\n", "                ", "if", "'reqt'", "in", "true_goal", "[", "domain", "]", ":", "\n", "                    ", "for", "s", "in", "true_goal", "[", "domain", "]", "[", "'reqt'", "]", ":", "# addtional requests:", "\n", "                        ", "if", "s", "in", "[", "'phone'", ",", "'address'", ",", "'postcode'", ",", "'reference'", ",", "'id'", "]", ":", "\n", "# ones that can be easily delexicalized", "\n", "                            ", "goal", "[", "domain", "]", "[", "'requestable'", "]", ".", "append", "(", "s", ")", "\n", "", "", "", "if", "'book'", "in", "true_goal", "[", "domain", "]", ":", "\n", "                    ", "goal", "[", "domain", "]", "[", "'requestable'", "]", ".", "append", "(", "\"reference\"", ")", "\n", "\n", "", "", "for", "s", ",", "v", "in", "true_goal", "[", "domain", "]", "[", "'info'", "]", ".", "items", "(", ")", ":", "\n", "                ", "s", "=", "self", ".", "otlg", ".", "slot_normlize", ".", "get", "(", "s", ",", "s", ")", "\n", "if", "len", "(", "v", ".", "split", "(", ")", ")", ">", "1", ":", "\n", "                    ", "v", "=", "' '", ".", "join", "(", "tknz", "(", "v", ")", ")", "\n", "", "if", "'|'", "in", "v", ":", "# do not consider multiple names", "\n", "                    ", "v", "=", "v", ".", "replace", "(", "'|'", ",", "' | '", ")", ".", "split", "(", "'|'", ")", "[", "0", "]", "\n", "", "v", "=", "v", ".", "strip", "(", ")", "\n", "goal", "[", "domain", "]", "[", "\"informable\"", "]", "[", "s", "]", "=", "v", "\n", "\n", "", "if", "'book'", "in", "true_goal", "[", "domain", "]", ":", "\n", "                ", "goal", "[", "domain", "]", "[", "\"booking\"", "]", "=", "true_goal", "[", "domain", "]", "[", "'book'", "]", "\n", "", "", "return", "goal", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.similar": [[14, 16], ["a.split", "b.split", "a.split", "b.split"], "function", ["None"], ["def", "similar", "(", "a", ",", "b", ")", ":", "\n", "    ", "return", "a", "==", "b", "or", "a", "in", "b", "or", "b", "in", "a", "or", "a", ".", "split", "(", ")", "[", "0", "]", "==", "b", ".", "split", "(", ")", "[", "0", "]", "or", "a", ".", "split", "(", ")", "[", "-", "1", "]", "==", "b", ".", "split", "(", ")", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.setsub": [[18, 36], ["metric.similar", "junks_a.append"], "function", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.similar"], ["", "def", "setsub", "(", "a", ",", "b", ")", ":", "\n", "    ", "junks_a", "=", "[", "]", "\n", "useless_constraint", "=", "[", "'temperature'", ",", "'week'", ",", "'est '", ",", "'quick'", ",", "'reminder'", ",", "'near'", "]", "\n", "for", "i", "in", "a", ":", "\n", "        ", "flg", "=", "False", "\n", "for", "j", "in", "b", ":", "\n", "            ", "if", "similar", "(", "i", ",", "j", ")", ":", "\n", "                ", "flg", "=", "True", "\n", "", "", "if", "not", "flg", ":", "\n", "            ", "junks_a", ".", "append", "(", "i", ")", "\n", "", "", "for", "junk", "in", "junks_a", ":", "\n", "        ", "flg", "=", "False", "\n", "for", "item", "in", "useless_constraint", ":", "\n", "            ", "if", "item", "in", "junk", ":", "\n", "                ", "flg", "=", "True", "\n", "", "", "if", "not", "flg", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.setsim": [[38, 41], ["set", "set", "metric.setsub", "metric.setsub"], "function", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.setsub", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.setsub"], ["", "def", "setsim", "(", "a", ",", "b", ")", ":", "\n", "    ", "a", ",", "b", "=", "set", "(", "a", ")", ",", "set", "(", "b", ")", "\n", "return", "setsub", "(", "a", ",", "b", ")", "and", "setsub", "(", "b", ",", "a", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.metric_handler": [[820, 833], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "ev_class", "ev_class.run_metrics", "ev_class.dump"], "function", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.MultiwozEvaluator.run_metrics"], ["", "", "def", "metric_handler", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "parser", ".", "add_argument", "(", "'-file'", ")", "\n", "parser", ".", "add_argument", "(", "'-type'", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "ev_class", "=", "None", "\n", "if", "args", ".", "type", "==", "'camrest'", ":", "\n", "        ", "ev_class", "=", "CamRestEvaluator", "\n", "# elif args.type == 'kvret':", "\n", "#     ev_class = KvretEvaluator", "\n", "", "ev", "=", "ev_class", "(", "args", ".", "file", ")", "\n", "ev", ".", "run_metrics", "(", ")", "\n", "ev", ".", "dump", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.MultinomialKLDivergenceLoss.__init__": [[11, 13], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.MultinomialKLDivergenceLoss.forward": [[14, 27], ["torch.sum().mean", "torch.log", "torch.log", "torch.sum"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "p_proba", ",", "q_proba", ")", ":", "# [B, T, V]", "\n", "# mask = cuda_(torch.zeros(p_proba.size(0), p_proba.size(1)))", "\n", "# for i in range(q_proba.size(0)):", "\n", "#     for j in range(q_proba.size(1)):", "\n", "#         topv, topi = torch.max(p_proba[i,j], -1)", "\n", "#         if topi.item() == 0:", "\n", "#             mask[i,j] = 0", "\n", "#         else:", "\n", "#             mask[i,j] = 1", "\n", "        ", "loss", "=", "q_proba", "*", "(", "torch", ".", "log", "(", "q_proba", ")", "-", "torch", ".", "log", "(", "p_proba", ")", ")", "\n", "# masked_loss = torch.sum(mask.unsqueeze(-1) * loss, dim=-1)", "\n", "# return masked_loss.mean()", "\n", "return", "torch", ".", "sum", "(", "loss", ",", "dim", "=", "-", "1", ")", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.MultinomialKLDivergenceLoss_Corr.__init__": [[29, 31], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.MultinomialKLDivergenceLoss_Corr.forward": [[32, 37], ["torch.sum", "torch.sum", "torch.sum.mean", "torch.log", "torch.log"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "p_proba", ",", "q_proba", ")", ":", "# [B, T, V]", "\n", "        ", "loss", "=", "q_proba", "*", "(", "torch", ".", "log", "(", "q_proba", ")", "-", "torch", ".", "log", "(", "p_proba", ")", ")", "\n", "loss", "=", "torch", ".", "sum", "(", "loss", ",", "dim", "=", "2", ")", "# sum over vocabulary", "\n", "loss", "=", "torch", ".", "sum", "(", "loss", ",", "dim", "=", "1", ")", "# sum over sequence", "\n", "return", "loss", ".", "mean", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.__init__": [[40, 44], ["base_model.BaseModel.__init__", "vae_model.MultinomialKLDivergenceLoss", "metric.BLEUScorer"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "has_qnet", "=", "True", ",", "**", "kwargs", ")", "\n", "self", ".", "kl_loss", "=", "MultinomialKLDivergenceLoss", "(", ")", "\n", "self", ".", "bleu_scorer", "=", "BLEUScorer", "(", ")", "\n", "# self.kl_loss = MultinomialKLDivergenceLoss_Corr()", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.forward": [[47, 85], ["vae_model.SemiCVAE.forward_turn", "torch.cat", "index.update", "vae_model.SemiCVAE.supervised_loss", "vae_model.SemiCVAE.forward_turn", "list", "torch.cat", "losses.update", "index.update", "index.update", "vae_model.SemiCVAE.rl_loss", "torch.cat.values", "list", "vae_model.SemiCVAE.unsupervised_loss", "vae_model.SemiCVAE.supervised_loss", "a_input.values", "losses.update"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.forward_turn", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.supervised_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.forward_turn", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.rl_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.unsupervised_loss", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.supervised_loss"], ["", "def", "forward", "(", "self", ",", "u_input", ",", "m_input", ",", "z_input", ",", "a_input", ",", "turn_states", ",", "z_supervised", ",", "\n", "mode", ",", "db_vec", "=", "None", ",", "filling_vec", "=", "None", ",", "no_label_train", "=", "False", ")", ":", "\n", "        ", "if", "mode", "in", "[", "'train'", ",", "'loss_eval'", ",", "'rl_tune'", "]", ":", "\n", "            ", "z_input", "=", "None", "if", "not", "z_supervised", "else", "z_input", "\n", "probs", ",", "index", ",", "turn_states", "=", "self", ".", "forward_turn", "(", "u_input", "=", "u_input", ",", "m_input", "=", "m_input", ",", "\n", "z_input", "=", "z_input", ",", "a_input", "=", "a_input", ",", "\n", "turn_states", "=", "turn_states", ",", "db_vec", "=", "db_vec", ",", "\n", "filling_vec", "=", "filling_vec", ",", "is_train", "=", "True", ",", "mode", "=", "mode", ")", "\n", "if", "z_supervised", "and", "mode", "!=", "'rl_tune'", ":", "\n", "                ", "z_input", "=", "torch", ".", "cat", "(", "list", "(", "z_input", ".", "values", "(", ")", ")", ",", "dim", "=", "1", ")", "\n", "a_input", "=", "torch", ".", "cat", "(", "list", "(", "a_input", ".", "values", "(", ")", ")", ",", "dim", "=", "1", ")", "if", "cfg", ".", "model_act", "else", "None", "\n", "index", ".", "update", "(", "{", "'z_input'", ":", "z_input", ",", "'a_input'", ":", "a_input", ",", "'m_input'", ":", "m_input", "}", ")", "\n", "loss", ",", "pz_loss", ",", "qz_loss", ",", "pa_loss", ",", "qa_loss", ",", "m_loss", "=", "self", ".", "supervised_loss", "(", "probs", ",", "index", ",", "no_label_train", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'pz_loss'", ":", "pz_loss", ",", "'qz_loss'", ":", "qz_loss", ",", "'m_loss'", ":", "m_loss", "}", "\n", "if", "cfg", ".", "model_act", ":", "\n", "                    ", "losses", ".", "update", "(", "{", "'pa_loss'", ":", "pa_loss", ",", "'qa_loss'", ":", "qa_loss", "}", ")", "\n", "", "return", "losses", ",", "turn_states", "\n", "", "elif", "mode", "!=", "'rl_tune'", ":", "\n", "                ", "index", ".", "update", "(", "{", "'m_input'", ":", "m_input", "}", ")", "\n", "if", "not", "no_label_train", ":", "\n", "                    ", "loss", ",", "kl_loss", ",", "kl_a_loss", ",", "m_loss", "=", "self", ".", "unsupervised_loss", "(", "probs", ",", "index", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'kl_loss'", ":", "kl_loss", ",", "'m_loss'", ":", "m_loss", "}", "\n", "if", "cfg", ".", "model_act", ":", "\n", "                        ", "losses", ".", "update", "(", "{", "'kl_a_loss'", ":", "kl_a_loss", "}", ")", "\n", "", "", "else", ":", "\n", "                    ", "loss", ",", "pz_loss", ",", "qz_loss", ",", "pa_loss", ",", "qa_loss", ",", "m_loss", "=", "self", ".", "supervised_loss", "(", "probs", ",", "index", ",", "no_label_train", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'m_loss'", ":", "m_loss", "}", "\n", "", "", "else", ":", "\n", "                ", "index", ".", "update", "(", "{", "'m_input'", ":", "m_input", "}", ")", "\n", "loss", ",", "reward", "=", "self", ".", "rl_loss", "(", "probs", ",", "index", ")", "\n", "losses", "=", "{", "'loss'", ":", "loss", ",", "'reward'", ":", "reward", "}", "\n", "", "return", "losses", ",", "turn_states", "\n", "\n", "", "elif", "mode", "==", "'test'", ":", "\n", "            ", "index", ",", "db", ",", "turn_states", "=", "self", ".", "forward_turn", "(", "u_input", "=", "u_input", ",", "\n", "is_train", "=", "False", ",", "turn_states", "=", "turn_states", ",", "db_vec", "=", "db_vec", ")", "\n", "return", "index", ",", "db", ",", "turn_states", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.forward_turn": [[87, 200], ["u_input.size", "vae_model.SemiCVAE.u_encoder", "modules.get_one_hot_input", "vae_model.SemiCVAE.u_encoder_q", "vae_model.SemiCVAE.m_encoder", "modules.get_one_hot_input", "vae_model.SemiCVAE.decode_z", "vae_model.SemiCVAE.decode_z", "vae_model.SemiCVAE.decode_m", "vae_model.SemiCVAE.decode_z", "vae_model.SemiCVAE.reader.cons_tensors_to_indicator", "modules.cuda_", "vae_model.SemiCVAE.max_sampling", "vae_model.SemiCVAE.reader.cons_tensors_to_indicator", "modules.cuda_", "vae_model.SemiCVAE.decode_a", "vae_model.SemiCVAE.decode_a", "vae_model.SemiCVAE.db_op.get_db_degree", "modules.cuda_", "torch.from_numpy().float", "vae_model.SemiCVAE.decode_a", "vae_model.SemiCVAE.decode_m", "vae_model.SemiCVAE.beam_search_decode", "vae_model.SemiCVAE.max_sampling", "vae_model.SemiCVAE.db_op.get_db_degree", "modules.cuda_", "torch.from_numpy().float", "torch.from_numpy().float", "vae_model.SemiCVAE.db_op.get_db_degree", "modules.cuda_", "torch.from_numpy().float", "vae_model.SemiCVAE.db_op.get_db_degree", "modules.cuda_", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy().float", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.get_one_hot_input", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.modules.get_one_hot_input", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_m", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_tensors_to_indicator", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.max_sampling", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_tensors_to_indicator", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_a", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_a", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_a", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_m", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.beam_search_decode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.max_sampling", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "", "def", "forward_turn", "(", "self", ",", "u_input", ",", "turn_states", ",", "is_train", ",", "m_input", "=", "None", ",", "z_input", "=", "None", ",", "\n", "a_input", "=", "None", ",", "db_vec", "=", "None", ",", "filling_vec", "=", "None", ",", "mode", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        compute required outputs for a single dialogue turn. Turn state{Dict} will be updated in each call.\n        :param u_len:\n        :param turn_states:\n        :param u_input: [B,T]\n        :param m_input: [B,T]\n        :param z_input: [B,T]\n        pv_pz_pr: K * [B,T,V]\n        pv_z_dec_outs: K * [B,T,H]\n        :return:\n        \"\"\"", "\n", "\n", "batch_size", "=", "u_input", ".", "size", "(", "0", ")", "\n", "u_hiddens", ",", "u_last_hidden", "=", "self", ".", "u_encoder", "(", "u_input", ")", "\n", "u_input_1hot", "=", "get_one_hot_input", "(", "u_input", ",", "self", ".", "vocab_size", ")", "\n", "\n", "if", "is_train", ":", "\n", "            ", "u_hiddens_q", ",", "u_last_hidden_q", "=", "self", ".", "u_encoder_q", "(", "u_input", ")", "\n", "m_hiddens", ",", "m_last_hidden", "=", "self", ".", "m_encoder", "(", "m_input", ")", "\n", "m_input_1hot", "=", "get_one_hot_input", "(", "m_input", ",", "self", ".", "vocab_size", ")", "\n", "# Q(z|pv_z, u, m)", "\n", "sample_type", "=", "cfg", ".", "sample_type", "if", "z_input", "is", "None", "else", "'supervised'", "\n", "qz_prob", ",", "qz_samples", ",", "qz_hiddens", ",", "turn_states", ",", "_", "=", "self", ".", "decode_z", "(", "batch_size", ",", "u_input", ",", "u_hiddens_q", ",", "u_input_1hot", ",", "u_last_hidden_q", ",", "\n", "z_input", ",", "turn_states", ",", "m_input", "=", "m_input", ",", "m_hiddens", "=", "m_hiddens", ",", "\n", "m_input_1hot", "=", "m_input_1hot", ",", "sample_type", "=", "sample_type", ",", "\n", "decoder_type", "=", "'qz'", ")", "\n", "\n", "# P(z|pv_z, u)", "\n", "sample_type", "=", "'posterior'", "if", "z_input", "is", "None", "else", "'supervised'", "\n", "pz_prob", ",", "pz_samples", ",", "pz_hiddens", ",", "turn_states", ",", "log_pz", "=", "self", ".", "decode_z", "(", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "z_input", ",", "\n", "turn_states", ",", "qz_samples", "=", "qz_samples", ",", "qz_hiddens", "=", "qz_hiddens", ",", "\n", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'pz'", ")", "\n", "\n", "# DB indicator and slot filling indicator", "\n", "if", "z_input", "is", "None", ":", "\n", "                ", "if", "cfg", ".", "dataset", "==", "'camrest'", ":", "\n", "                    ", "db_vec_np", ",", "match", "=", "self", ".", "db_op", ".", "get_db_degree", "(", "pz_samples", ",", "self", ".", "vocab", ")", "\n", "db_vec", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "db_vec_np", ")", ".", "float", "(", ")", ")", "\n", "", "elif", "cfg", ".", "dataset", "==", "'multiwoz'", ":", "\n", "                    ", "db_vec_np", ",", "match", "=", "self", ".", "db_op", ".", "get_db_degree", "(", "pz_samples", ",", "turn_states", "[", "'dom'", "]", ",", "self", ".", "vocab", ")", "\n", "db_vec_new", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "db_vec_np", ")", ".", "float", "(", ")", ")", "\n", "db_vec", "[", ":", ",", ":", "4", "]", "=", "db_vec_new", "\n", "", "else", ":", "\n", "                    ", "match", "=", "[", "0", "]", "*", "batch_size", "\n", "", "filling_vec", "=", "self", ".", "reader", ".", "cons_tensors_to_indicator", "(", "pz_samples", ")", "\n", "filling_vec", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "filling_vec", ")", ".", "float", "(", ")", ")", "\n", "\n", "", "if", "self", ".", "model_act", ":", "\n", "                ", "sample_type", "=", "cfg", ".", "sample_type", "if", "z_input", "is", "None", "else", "'supervised'", "\n", "qa_prob", ",", "qa_samples", ",", "qa_hiddens", ",", "log_qa", "=", "self", ".", "decode_a", "(", "batch_size", ",", "u_input", ",", "u_hiddens_q", ",", "u_input_1hot", ",", "u_last_hidden", ",", "a_input", ",", "\n", "db_vec", ",", "filling_vec", ",", "m_input", "=", "m_input", ",", "m_hiddens", "=", "m_hiddens", ",", "\n", "m_input_1hot", "=", "m_input_1hot", ",", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'qa'", ")", "\n", "\n", "sample_type", "=", "'posterior'", "if", "z_input", "is", "None", "else", "'supervised'", "\n", "pa_prob", ",", "pa_samples", ",", "pa_hiddens", ",", "log_pa", "=", "self", ".", "decode_a", "(", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "a_input", ",", "\n", "db_vec", ",", "filling_vec", ",", "qa_samples", "=", "qa_samples", ",", "qa_hiddens", "=", "qa_hiddens", ",", "\n", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'pa'", ")", "\n", "", "else", ":", "\n", "                ", "pa_prob", ",", "pa_samples", ",", "pa_hiddens", ",", "qa_prob", "=", "None", ",", "None", ",", "None", ",", "None", "\n", "\n", "", "pm_prob", ",", "m_idx", ",", "log_pm", "=", "self", ".", "decode_m", "(", "batch_size", ",", "u_last_hidden", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "\n", "pz_samples", ",", "pz_prob", ",", "pz_hiddens", ",", "pa_samples", ",", "pa_prob", ",", "pa_hiddens", ",", "\n", "db_vec", ",", "m_input", ",", "is_train", "=", "True", ")", "\n", "probs", "=", "{", "'pz_prob'", ":", "pz_prob", ",", "'pm_prob'", ":", "pm_prob", ",", "'pa_prob'", ":", "pa_prob", ",", "\n", "'qz_prob'", ":", "qz_prob", ",", "'qa_prob'", ":", "qa_prob", ",", "'log_pm'", ":", "log_pm", "}", "\n", "index", "=", "{", "'z_input'", ":", "pz_samples", ",", "'a_input'", ":", "pa_samples", ",", "'m_idx'", ":", "m_idx", ",", "}", "\n", "return", "probs", ",", "index", ",", "turn_states", "\n", "\n", "", "else", ":", "# testing", "\n", "            ", "sample_type", "=", "'top1'", "\n", "pz_prob", ",", "pz_samples", ",", "pz_hiddens", ",", "turn_states", ",", "log_pz", "=", "self", ".", "decode_z", "(", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "z_input", ",", "\n", "turn_states", ",", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'pz'", ")", "\n", "\n", "if", "cfg", ".", "dataset", "==", "'camrest'", ":", "\n", "                ", "db_vec_np", ",", "match", "=", "self", ".", "db_op", ".", "get_db_degree", "(", "pz_samples", ",", "self", ".", "vocab", ")", "\n", "db_vec", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "db_vec_np", ")", ".", "float", "(", ")", ")", "\n", "", "elif", "cfg", ".", "dataset", "==", "'multiwoz'", ":", "\n", "                ", "db_vec_np", ",", "match", "=", "self", ".", "db_op", ".", "get_db_degree", "(", "pz_samples", ",", "turn_states", "[", "'dom'", "]", ",", "self", ".", "vocab", ")", "\n", "db_vec_new", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "db_vec_np", ")", ".", "float", "(", ")", ")", "\n", "db_vec", "[", ":", ",", ":", "4", "]", "=", "db_vec_new", "\n", "", "else", ":", "\n", "                ", "match", "=", "[", "0", "]", "*", "batch_size", "\n", "", "filling_vec", "=", "self", ".", "reader", ".", "cons_tensors_to_indicator", "(", "pz_samples", ")", "\n", "filling_vec", "=", "cuda_", "(", "torch", ".", "from_numpy", "(", "filling_vec", ")", ".", "float", "(", ")", ")", "\n", "\n", "if", "self", ".", "model_act", ":", "\n", "                ", "pa_prob", ",", "pa_samples", ",", "pa_hiddens", ",", "log_pa", "=", "self", ".", "decode_a", "(", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "a_input", ",", "\n", "db_vec", ",", "filling_vec", ",", "sample_type", "=", "sample_type", ",", "decoder_type", "=", "'pa'", ")", "\n", "", "else", ":", "\n", "                ", "pa_prob", ",", "pa_samples", ",", "pa_hiddens", "=", "None", ",", "None", ",", "None", "\n", "\n", "", "if", "not", "self", ".", "beam_search", ":", "\n", "                ", "pm_prob", ",", "m_idx", ",", "log_pm", "=", "self", ".", "decode_m", "(", "batch_size", ",", "u_last_hidden", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "\n", "pz_samples", ",", "pz_prob", ",", "pz_hiddens", ",", "pa_samples", ",", "pa_prob", ",", "pa_hiddens", ",", "\n", "db_vec", ",", "m_input", ",", "is_train", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "m_idx", "=", "self", ".", "beam_search_decode", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "pz_samples", ",", "\n", "pz_prob", ",", "pz_hiddens", ",", "db_vec", ",", "u_last_hidden", "[", ":", "-", "1", "]", ",", "\n", "pa_samples", ",", "pa_prob", ",", "pa_hiddens", ")", "\n", "", "z_idx", "=", "self", ".", "max_sampling", "(", "pz_prob", ")", "\n", "a_idx", "=", "self", ".", "max_sampling", "(", "pa_prob", ")", "if", "self", ".", "model_act", "else", "None", "\n", "index", "=", "{", "'m_idx'", ":", "m_idx", ",", "'z_idx'", ":", "z_idx", ",", "'a_idx'", ":", "a_idx", "}", "\n", "return", "index", ",", "match", ",", "turn_states", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.supervised_loss": [[202, 221], ["torch.log", "vae_model.SemiCVAE.nll_loss", "vae_model.SemiCVAE.nll_loss", "vae_model.SemiCVAE.nll_loss", "torch.log", "torch.log", "pz_prob.view", "z_input.view", "qz_prob.view", "z_input.view", "torch.log.view", "m_input.view", "vae_model.SemiCVAE.nll_loss", "vae_model.SemiCVAE.nll_loss", "pz_prob.size", "qz_prob.size", "torch.log.size", "torch.log", "torch.log", "pa_prob.view", "a_input.view", "qa_prob.view", "a_input.view", "torch.zeros", "torch.zeros", "pa_prob.size", "qa_prob.size"], "methods", ["None"], ["", "", "def", "supervised_loss", "(", "self", ",", "probs", ",", "index", ",", "no_label_train", "=", "False", ")", ":", "\n", "        ", "pz_prob", ",", "qz_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pz_prob'", "]", ")", ",", "torch", ".", "log", "(", "probs", "[", "'qz_prob'", "]", ")", "\n", "pm_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pm_prob'", "]", ")", "\n", "z_input", ",", "m_input", "=", "index", "[", "'z_input'", "]", ",", "index", "[", "'m_input'", "]", "\n", "pz_loss", "=", "self", ".", "nll_loss", "(", "pz_prob", ".", "view", "(", "-", "1", ",", "pz_prob", ".", "size", "(", "2", ")", ")", ",", "z_input", ".", "view", "(", "-", "1", ")", ")", "\n", "qz_loss", "=", "self", ".", "nll_loss", "(", "qz_prob", ".", "view", "(", "-", "1", ",", "qz_prob", ".", "size", "(", "2", ")", ")", ",", "z_input", ".", "view", "(", "-", "1", ")", ")", "\n", "m_loss", "=", "self", ".", "nll_loss", "(", "pm_prob", ".", "view", "(", "-", "1", ",", "pm_prob", ".", "size", "(", "2", ")", ")", ",", "m_input", ".", "view", "(", "-", "1", ")", ")", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "pa_prob", ",", "qa_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pa_prob'", "]", ")", ",", "torch", ".", "log", "(", "probs", "[", "'qa_prob'", "]", ")", "\n", "a_input", "=", "index", "[", "'a_input'", "]", "\n", "pa_loss", "=", "self", ".", "nll_loss", "(", "pa_prob", ".", "view", "(", "-", "1", ",", "pa_prob", ".", "size", "(", "2", ")", ")", ",", "a_input", ".", "view", "(", "-", "1", ")", ")", "\n", "qa_loss", "=", "self", ".", "nll_loss", "(", "qa_prob", ".", "view", "(", "-", "1", ",", "qa_prob", ".", "size", "(", "2", ")", ")", ",", "a_input", ".", "view", "(", "-", "1", ")", ")", "\n", "loss", "=", "pz_loss", "+", "qz_loss", "+", "m_loss", "+", "pa_loss", "+", "qa_loss", "\n", "", "else", ":", "\n", "            ", "pa_loss", ",", "qa_loss", "=", "torch", ".", "zeros", "(", "1", ")", ",", "torch", ".", "zeros", "(", "1", ")", "\n", "loss", "=", "pz_loss", "+", "qz_loss", "+", "m_loss", "\n", "", "if", "no_label_train", ":", "\n", "            ", "loss", "=", "m_loss", "\n", "", "return", "loss", ",", "pz_loss", ",", "qz_loss", ",", "pa_loss", ",", "qa_loss", ",", "m_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.unsupervised_loss": [[222, 237], ["torch.log", "vae_model.SemiCVAE.nll_loss", "torch.log.view", "m_input.view", "vae_model.SemiCVAE.kl_loss", "torch.zeros", "torch.log.size", "vae_model.SemiCVAE.kl_loss"], "methods", ["None"], ["", "def", "unsupervised_loss", "(", "self", ",", "probs", ",", "index", ")", ":", "\n", "# z_input only used for nll evaluation", "\n", "        ", "pm_prob", "=", "torch", ".", "log", "(", "probs", "[", "'pm_prob'", "]", ")", "\n", "m_input", "=", "index", "[", "'m_input'", "]", "\n", "m_loss", "=", "self", ".", "nll_loss", "(", "pm_prob", ".", "view", "(", "-", "1", ",", "pm_prob", ".", "size", "(", "2", ")", ")", ",", "m_input", ".", "view", "(", "-", "1", ")", ")", "\n", "pz_prob", ",", "qz_prob", "=", "probs", "[", "'pz_prob'", "]", ",", "probs", "[", "'qz_prob'", "]", "\n", "kl_loss", "=", "self", ".", "kl_loss", "(", "pz_prob", ",", "qz_prob", ")", "*", "cfg", ".", "kl_loss_weight", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "pa_prob", ",", "qa_prob", "=", "probs", "[", "'pa_prob'", "]", ",", "probs", "[", "'qa_prob'", "]", "\n", "kl_a_loss", "=", "self", ".", "kl_loss", "(", "pa_prob", ",", "qa_prob", ")", "*", "cfg", ".", "kl_loss_weight", "\n", "loss", "=", "m_loss", "+", "kl_loss", "+", "kl_a_loss", "\n", "", "else", ":", "\n", "            ", "kl_a_loss", "=", "torch", ".", "zeros", "(", "1", ")", "\n", "loss", "=", "m_loss", "+", "kl_loss", "\n", "", "return", "loss", ",", "kl_loss", ",", "kl_a_loss", ",", "m_loss", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vae_model.SemiCVAE.rl_loss": [[239, 288], ["range", "vae_model.SemiCVAE.split", "vae_model.SemiCVAE.split", "index[].size", "vae_model.SemiCVAE.reader.vocab.sentence_decode", "vae_model.SemiCVAE.reader.vocab.sentence_decode", "vae_model.SemiCVAE.bleu_scorer.score", "vae_model.SemiCVAE.rl_loss.request_score"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_decode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_decode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.metric.BLEUScorer.score"], ["", "def", "rl_loss", "(", "self", ",", "probs", ",", "index", ")", ":", "\n", "        ", "\"\"\"\n        :param probs: dict of decoding probabilities, size [B, T, V]\n        :param index: dict of decoding indexes, size [B, T]\n        \"\"\"", "\n", "def", "request_score", "(", "gen", ",", "truth", ")", ":", "\n", "            ", "tp", ",", "fp", ",", "fn", "=", "0", ",", "0", ",", "0", "\n", "truth_req", ",", "gen_req", "=", "set", "(", ")", ",", "set", "(", ")", "\n", "for", "w", "in", "gen", ".", "split", "(", ")", ":", "\n", "                ", "if", "'[value_'", "in", "w", "and", "w", ".", "endswith", "(", "']'", ")", "and", "w", "!=", "'[value_name]'", ":", "\n", "                    ", "gen_req", ".", "add", "(", "w", "[", "1", ":", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "\n", "", "", "for", "w", "in", "truth", ".", "split", "(", ")", ":", "\n", "                ", "if", "'[value_'", "in", "w", "and", "w", ".", "endswith", "(", "']'", ")", "and", "w", "!=", "'[value_name]'", ":", "\n", "                    ", "truth_req", ".", "add", "(", "w", "[", "1", ":", "-", "1", "]", ".", "split", "(", "'_'", ")", "[", "1", "]", ")", "\n", "", "", "for", "req", "in", "gen_req", ":", "\n", "                ", "if", "req", "in", "truth_req", ":", "\n", "                    ", "tp", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "fp", "+=", "1", "\n", "", "", "for", "req", "in", "truth_req", ":", "\n", "                ", "if", "req", "not", "in", "gen_req", ":", "\n", "                    ", "fn", "+=", "1", "\n", "", "", "precision", ",", "recall", "=", "tp", "/", "(", "tp", "+", "fp", "+", "1e-8", ")", ",", "tp", "/", "(", "tp", "+", "fn", "+", "1e-8", ")", "\n", "# print('precision:', precision, 'recall:', recall)", "\n", "f1", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", "+", "1e-8", ")", "\n", "return", "f1", "\n", "\n", "", "batch_size", "=", "index", "[", "'m_input'", "]", ".", "size", "(", ")", "[", "0", "]", "\n", "# log_prob = probs['log_pa']", "\n", "log_prob", "=", "probs", "[", "'log_pm'", "]", "\n", "m_true", "=", "index", "[", "'m_input'", "]", "\n", "m_gen", "=", "index", "[", "'m_idx'", "]", "\n", "\n", "loss", "=", "0", "\n", "total_reward", "=", "0", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "truth", "=", "self", ".", "reader", ".", "vocab", ".", "sentence_decode", "(", "m_true", "[", "b", "]", ",", "eos", "=", "'<eos_r>'", ")", "\n", "gen", "=", "self", ".", "reader", ".", "vocab", ".", "sentence_decode", "(", "m_gen", "[", "b", "]", ",", "eos", "=", "'<eos_r>'", ")", "\n", "bleu", "=", "self", ".", "bleu_scorer", ".", "score", "(", "[", "(", "[", "gen", "]", ",", "[", "truth", "]", ")", "]", ")", "\n", "f1", "=", "request_score", "(", "gen", ",", "truth", ")", "\n", "# f1 = f1 if f1>0.5 else 0", "\n", "# print('bleu', bleu, 'f1', f1)", "\n", "reward", "=", "cfg", ".", "rl_coef", "*", "bleu", "+", "f1", "\n", "# reward = f1", "\n", "loss", "+=", "-", "reward", "*", "log_prob", "[", "b", "]", "\n", "total_reward", "+=", "reward", "\n", "", "loss", "/=", "batch_size", "\n", "total_reward", "/=", "batch_size", "\n", "return", "loss", ",", "total_reward", "\n", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.__init__": [[7, 87], ["torch.nn.Module.__init__", "torch.nn.Embedding", "Encoder", "Encoder", "copy_modules.PriorDecoder_Pz", "copy_modules.ResponseDecoder_Pm", "torch.nn.NLLLoss", "Encoder", "copy_modules.PriorDecoder_Pa", "Encoder", "copy_modules.PosteriorDecoder_Qz", "len", "copy_modules.PriorDecoder_Pa", "Encoder", "copy_modules.PosteriorDecoder_Qa", "len", "len", "copy_modules.PosteriorDecoder_Qa", "len"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ",", "cfg", ",", "reader", ",", "has_qnet", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "cfg", "=", "cfg", "\n", "self", ".", "hidden_size", "=", "cfg", ".", "hidden_size", "\n", "self", ".", "vocab_size", "=", "cfg", ".", "vocab_size", "\n", "self", ".", "z_length", "=", "cfg", ".", "z_length", "\n", "self", ".", "a_length", "=", "cfg", ".", "a_length", "\n", "self", ".", "max_len", "=", "cfg", ".", "m_max_len", "\n", "self", ".", "teacher_force", "=", "cfg", ".", "teacher_force", "\n", "self", ".", "model_act", "=", "cfg", ".", "model_act", "\n", "self", ".", "use_act_slot_decoder", "=", "cfg", ".", "use_act_slot_decoder", "\n", "self", ".", "multi_domain", "=", "False", "if", "cfg", ".", "dataset", "==", "'camrest'", "else", "True", "\n", "self", ".", "gumbel_temp", "=", "cfg", ".", "gumbel_temp", "\n", "self", ".", "prev_z_continuous", "=", "cfg", ".", "prev_z_continuous", "\n", "self", ".", "beam_search", "=", "cfg", ".", "beam_search", "\n", "\n", "self", ".", "reader", "=", "reader", "\n", "self", ".", "vocab", "=", "self", ".", "reader", ".", "vocab", "\n", "self", ".", "db_op", "=", "self", ".", "reader", ".", "dataset", "\n", "self", ".", "z_eos_map", "=", "self", ".", "reader", ".", "otlg", ".", "z_eos_map", "\n", "self", ".", "eos_m_token", "=", "self", ".", "reader", ".", "otlg", ".", "eos_syntax", "[", "'resp'", "]", "\n", "\n", "if", "self", ".", "beam_search", ":", "\n", "            ", "self", ".", "beam_size", "=", "cfg", ".", "beam_params", "[", "'size'", "]", "\n", "self", ".", "beam_len_bonus", "=", "cfg", ".", "beam_params", "[", "'len_bonus'", "]", "\n", "\n", "", "self", ".", "embedding", "=", "nn", ".", "Embedding", "(", "cfg", ".", "vocab_size", ",", "cfg", ".", "embed_size", ")", "\n", "self", ".", "u_encoder", "=", "Encoder", "(", "self", ".", "embedding", ",", "cfg", ".", "vocab_size", ",", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "\n", "cfg", ".", "layer_num", ",", "cfg", ".", "dropout_rate", ")", "\n", "self", ".", "z_encoder", "=", "Encoder", "(", "self", ".", "embedding", ",", "cfg", ".", "vocab_size", ",", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "\n", "cfg", ".", "layer_num", ",", "cfg", ".", "dropout_rate", ")", "\n", "self", ".", "pz_decoder", "=", "PriorDecoder_Pz", "(", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "cfg", ".", "vocab_size", ",", "\n", "cfg", ".", "dropout_rate", ",", "enable_selc_read", "=", "False", ")", "# prior", "\n", "self", ".", "decode_z", "=", "self", ".", "decode_z_order", "if", "not", "cfg", ".", "parallel_z", "else", "self", ".", "decode_z_parallel", "\n", "\n", "# if self.cfg.multi_domain:", "\n", "#     self.domain_classifier = DomainClassifier(cfg.hidden_size, 8, cfg.dropout_rate)", "\n", "\n", "if", "self", ".", "model_act", ":", "\n", "            ", "self", ".", "a_encoder", "=", "Encoder", "(", "self", ".", "embedding", ",", "cfg", ".", "vocab_size", ",", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "\n", "cfg", ".", "layer_num", ",", "cfg", ".", "dropout_rate", ")", "\n", "\n", "self", ".", "pa_decoder_v", "=", "PriorDecoder_Pa", "(", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "cfg", ".", "vocab_size", ",", "\n", "cfg", ".", "db_vec_size", ",", "len", "(", "self", ".", "z_eos_map", ")", ",", "cfg", ".", "dropout_rate", ")", "# prior", "\n", "if", "self", ".", "use_act_slot_decoder", "and", "not", "cfg", ".", "share_act_decoder", ":", "\n", "                ", "self", ".", "pa_decoder_s", "=", "PriorDecoder_Pa", "(", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "cfg", ".", "vocab_size", ",", "\n", "cfg", ".", "db_vec_size", ",", "len", "(", "self", ".", "z_eos_map", ")", ",", "cfg", ".", "dropout_rate", ")", "# prior", "\n", "", "else", ":", "\n", "                ", "self", ".", "pa_decoder_s", "=", "self", ".", "pa_decoder_v", "\n", "", "self", ".", "pa_decoder", "=", "{", "'av'", ":", "self", ".", "pa_decoder_v", ",", "'as'", ":", "self", ".", "pa_decoder_s", "}", "\n", "\n", "", "if", "has_qnet", ":", "\n", "            ", "if", "not", "cfg", ".", "share_q_encoder", ":", "\n", "                ", "self", ".", "u_encoder_q", "=", "Encoder", "(", "self", ".", "embedding", ",", "cfg", ".", "vocab_size", ",", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "\n", "cfg", ".", "layer_num", ",", "cfg", ".", "dropout_rate", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "u_encoder_q", "=", "self", ".", "u_encoder", "\n", "", "self", ".", "m_encoder", "=", "Encoder", "(", "self", ".", "embedding", ",", "cfg", ".", "vocab_size", ",", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "\n", "cfg", ".", "layer_num", ",", "cfg", ".", "dropout_rate", ")", "\n", "self", ".", "qz_decoder", "=", "PosteriorDecoder_Qz", "(", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "cfg", ".", "vocab_size", ",", "\n", "cfg", ".", "dropout_rate", ",", "\n", "enable_selc_read", "=", "False", ")", "# posterior", "\n", "if", "self", ".", "model_act", ":", "\n", "                ", "self", ".", "qa_decoder_v", "=", "PosteriorDecoder_Qa", "(", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "cfg", ".", "vocab_size", ",", "\n", "cfg", ".", "db_vec_size", ",", "len", "(", "self", ".", "z_eos_map", ")", ",", "\n", "cfg", ".", "dropout_rate", ",", "\n", "enable_selc_read", "=", "False", ")", "# posterior", "\n", "if", "not", "cfg", ".", "share_act_decoder", ":", "\n", "                    ", "self", ".", "qa_decoder_s", "=", "PosteriorDecoder_Qa", "(", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "cfg", ".", "vocab_size", ",", "\n", "cfg", ".", "db_vec_size", ",", "len", "(", "self", ".", "z_eos_map", ")", ",", "\n", "cfg", ".", "dropout_rate", ",", "\n", "enable_selc_read", "=", "False", ")", "# posterior", "\n", "", "else", ":", "\n", "                    ", "self", ".", "qa_decoder_s", "=", "self", ".", "qa_decoder_v", "\n", "", "self", ".", "qa_decoder", "=", "{", "'av'", ":", "self", ".", "qa_decoder_v", ",", "'as'", ":", "self", ".", "qa_decoder_s", "}", "\n", "\n", "", "", "self", ".", "m_decoder", "=", "ResponseDecoder_Pm", "(", "self", ".", "embedding", ",", "cfg", ".", "embed_size", ",", "cfg", ".", "hidden_size", ",", "\n", "cfg", ".", "vocab_size", ",", "cfg", ".", "db_vec_size", ",", "\n", "cfg", ".", "dropout_rate", ",", "enable_selc_read", "=", "False", ")", "\n", "self", ".", "nll_loss", "=", "nn", ".", "NLLLoss", "(", "ignore_index", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_z_order": [[88, 169], ["turn_states.get", "turn_states.get", "turn_states.get", "enumerate", "torch.stack", "torch.stack", "base_model.BaseModel.vocab.encode", "base_model.BaseModel.get_first_z_input", "cuda_", "range", "z_hiddens.detach", "torch.stack.detach", "torch.stack.detach", "torch.zeros", "torch.stack.append", "torch.stack.append", "base_model.BaseModel.z_encoder", "torch.stack", "torch.matmul", "base_model.BaseModel.z_encoder", "base_model.BaseModel.pz_decoder", "base_model.BaseModel.qz_decoder", "base_model.BaseModel.mask_probs", "base_model.BaseModel.embedding", "torch.gather().squeeze", "torch.log", "base_model.BaseModel.mask_samples", "torch.argmax.view", "torch.argmax.view", "torch.topk", "torch.topk", "torch.multinomial", "torch.gather", "torch.gather", "base_model.BaseModel.squeeze", "torch.argmax.view", "torch.argmax", "torch.matmul().unsqueeze", "base_model.BaseModel.mask_samples", "gmb_samples.append", "torch.matmul"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.get_first_z_input", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_probs", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples"], ["", "def", "decode_z_order", "(", "self", ",", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "z_input", ",", "\n", "turn_states", ",", "sample_type", ",", "decoder_type", ",", "qz_samples", "=", "None", ",", "qz_hiddens", "=", "None", ",", "\n", "m_input", "=", "None", ",", "m_hiddens", "=", "None", ",", "m_input_1hot", "=", "None", ",", "mask_otlg", "=", "False", ")", ":", "\n", "        ", "return_gmb", "=", "True", "if", "'gumbel'", "in", "sample_type", "else", "False", "\n", "pv_z_pr", "=", "turn_states", ".", "get", "(", "'pv_%s_pr'", "%", "decoder_type", ",", "None", ")", "\n", "pv_z_h", "=", "turn_states", ".", "get", "(", "'pv_%s_h'", "%", "decoder_type", ",", "None", ")", "\n", "pv_z_id", "=", "turn_states", ".", "get", "(", "'pv_%s_id'", "%", "decoder_type", ",", "None", ")", "\n", "z_prob", ",", "z_samples", ",", "gmb_samples", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "log_pz", "=", "0", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "reader", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "            ", "last_hidden", "=", "u_last_hidden", "[", ":", "-", "1", "]", "\n", "# last_hidden = (u_last_hidden[-1] + u_last_hidden[-2]).unsqueeze(0)", "\n", "z_eos_idx", "=", "self", ".", "vocab", ".", "encode", "(", "self", ".", "z_eos_map", "[", "sn", "]", ")", "\n", "emb_zt", "=", "self", ".", "get_first_z_input", "(", "sn", ",", "batch_size", ",", "self", ".", "multi_domain", ")", "\n", "zero_vec", "=", "cuda_", "(", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "self", ".", "hidden_size", ")", ")", "\n", "selc_read_u", "=", "selc_read_m", "=", "selc_read_pv_z", "=", "zero_vec", "\n", "if", "pv_z_pr", "is", "not", "None", ":", "\n", "                ", "b", ",", "e", "=", "si", "*", "self", ".", "z_length", ",", "(", "si", "+", "1", ")", "*", "self", ".", "z_length", "\n", "pv_pr", ",", "pv_h", ",", "pv_idx", "=", "pv_z_pr", "[", ":", ",", "b", ":", "e", "]", ",", "pv_z_h", "[", ":", ",", "b", ":", "e", "]", ",", "pv_z_id", "[", ":", ",", "b", ":", "e", "]", "\n", "", "else", ":", "\n", "                ", "pv_pr", ",", "pv_h", ",", "pv_idx", "=", "None", ",", "None", ",", "None", "\n", "", "prev_zt", "=", "None", "\n", "for", "t", "in", "range", "(", "self", ".", "z_length", ")", ":", "\n", "                ", "if", "decoder_type", "==", "'pz'", ":", "\n", "                    ", "prob", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_pv_z", "=", "self", ".", "pz_decoder", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "\n", "pv_z_prob", "=", "pv_pr", ",", "pv_z_hidden", "=", "pv_h", ",", "pv_z_idx", "=", "pv_idx", ",", "\n", "emb_zt", "=", "emb_zt", ",", "last_hidden", "=", "last_hidden", ",", "\n", "selc_read_u", "=", "selc_read_u", ",", "selc_read_pv_z", "=", "selc_read_pv_z", ")", "\n", "", "else", ":", "\n", "                    ", "prob", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_m", ",", "selc_read_pv_z", ",", "gmb_samp", "=", "self", ".", "qz_decoder", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "m_input", ",", "m_input_1hot", ",", "m_hiddens", ",", "\n", "pv_z_prob", "=", "pv_pr", ",", "pv_z_hidden", "=", "pv_h", ",", "pv_z_idx", "=", "pv_idx", ",", "\n", "emb_zt", "=", "emb_zt", ",", "last_hidden", "=", "last_hidden", ",", "selc_read_u", "=", "selc_read_u", ",", "\n", "selc_read_m", "=", "selc_read_m", ",", "selc_read_pv_z", "=", "selc_read_pv_z", ",", "\n", "temp", "=", "self", ".", "gumbel_temp", ",", "return_gmb", "=", "return_gmb", ")", "\n", "", "if", "mask_otlg", ":", "\n", "                    ", "prob", "=", "self", ".", "mask_probs", "(", "prob", ",", "tokens_allow", "=", "self", ".", "reader", ".", "slot_value_mask", "[", "sn", "]", ")", "\n", "\n", "", "if", "sample_type", "==", "'supervised'", ":", "\n", "                    ", "zt", "=", "z_input", "[", "sn", "]", "[", ":", ",", "t", "]", "\n", "", "elif", "sample_type", "==", "'top1'", ":", "\n", "                    ", "zt", "=", "torch", ".", "topk", "(", "prob", ",", "1", ")", "[", "1", "]", "\n", "", "elif", "sample_type", "==", "'topk'", ":", "\n", "                    ", "topk_probs", ",", "topk_words", "=", "torch", ".", "topk", "(", "prob", ".", "squeeze", "(", "1", ")", ",", "cfg", ".", "topk_num", ")", "\n", "widx", "=", "torch", ".", "multinomial", "(", "topk_probs", ",", "1", ",", "replacement", "=", "True", ")", "\n", "zt", "=", "torch", ".", "gather", "(", "topk_words", ",", "1", ",", "widx", ")", "#[B]", "\n", "", "elif", "sample_type", "==", "'posterior'", ":", "\n", "                    ", "zt", "=", "qz_samples", "[", ":", ",", "si", "*", "self", ".", "z_length", "+", "t", "]", "\n", "", "elif", "'gumbel'", "in", "sample_type", ":", "\n", "                    ", "zt", "=", "torch", ".", "argmax", "(", "gmb_samp", ",", "dim", "=", "1", ")", "#[B]", "\n", "emb_zt", "=", "torch", ".", "matmul", "(", "gmb_samp", ",", "self", ".", "embedding", ".", "weight", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, H]", "\n", "zt", ",", "prev_zt", ",", "gmb_samp", "=", "self", ".", "mask_samples", "(", "zt", ",", "prev_zt", ",", "batch_size", ",", "z_eos_idx", ",", "gmb_samp", ",", "True", ")", "\n", "gmb_samples", ".", "append", "(", "gmb_samp", ")", "\n", "\n", "", "if", "'gumbel'", "not", "in", "sample_type", ":", "\n", "                    ", "emb_zt", "=", "self", ".", "embedding", "(", "zt", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "prob_zt", "=", "torch", ".", "gather", "(", "prob", ",", "1", ",", "zt", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "squeeze", "(", "1", ")", "#[B, 1]", "\n", "log_prob_zt", "=", "torch", ".", "log", "(", "prob_zt", ")", "\n", "zt", ",", "prev_zt", ",", "log_prob_zt", "=", "self", ".", "mask_samples", "(", "zt", ",", "prev_zt", ",", "batch_size", ",", "z_eos_idx", ",", "log_prob_zt", ")", "\n", "log_pz", "+=", "log_prob_zt", "\n", "", "z_samples", ".", "append", "(", "zt", ".", "view", "(", "-", "1", ")", ")", "\n", "z_prob", ".", "append", "(", "prob", ")", "\n", "\n", "", "", "z_prob", "=", "torch", ".", "stack", "(", "z_prob", ",", "dim", "=", "1", ")", "# [B*K,Tz,V]", "\n", "z_samples", "=", "torch", ".", "stack", "(", "z_samples", ",", "dim", "=", "1", ")", "# [B*K,Tz]", "\n", "if", "sample_type", "==", "'posterior'", ":", "\n", "            ", "z_samples", ",", "z_hiddens", "=", "qz_samples", ",", "qz_hiddens", "\n", "", "elif", "'gumbel'", "not", "in", "sample_type", ":", "\n", "            ", "z_hiddens", ",", "z_last_hidden", "=", "self", ".", "z_encoder", "(", "z_samples", ",", "input_type", "=", "'index'", ")", "\n", "", "else", ":", "\n", "            ", "z_gumbel", "=", "torch", ".", "stack", "(", "gmb_samples", ",", "dim", "=", "1", ")", "# [B,Tz, V]", "\n", "z_gumbel", "=", "torch", ".", "matmul", "(", "z_gumbel", ",", "self", ".", "embedding", ".", "weight", ")", "# [B,Tz, E]", "\n", "z_hiddens", ",", "z_last_hidden", "=", "self", ".", "z_encoder", "(", "z_gumbel", ",", "input_type", "=", "'embedding'", ")", "\n", "\n", "", "retain", "=", "self", ".", "prev_z_continuous", "\n", "turn_states", "[", "'pv_%s_h'", "%", "decoder_type", "]", "=", "z_hiddens", "if", "retain", "else", "z_hiddens", ".", "detach", "(", ")", "\n", "turn_states", "[", "'pv_%s_pr'", "%", "decoder_type", "]", "=", "z_prob", "if", "retain", "else", "z_prob", ".", "detach", "(", ")", "\n", "turn_states", "[", "'pv_%s_id'", "%", "decoder_type", "]", "=", "z_samples", "if", "retain", "else", "z_samples", ".", "detach", "(", ")", "\n", "\n", "return", "z_prob", ",", "z_samples", ",", "z_hiddens", ",", "turn_states", ",", "log_pz", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_z_parallel": [[171, 295], ["len", "turn_states.get", "turn_states.get", "turn_states.get", "u_last_hidden[].repeat", "u_input.repeat.repeat.repeat", "u_input_1hot.repeat.repeat.repeat", "u_hiddens.repeat.repeat.repeat", "enumerate", "torch.cat", "cuda_", "range", "torch.stack", "torch.stack", "range", "torch.cat", "torch.cat", "m_input.repeat.repeat.repeat", "m_input_1hot.repeat.repeat.repeat", "m_hiddens.repeat.repeat.repeat", "enumerate", "torch.cat", "torch.cat", "torch.cat", "z_eos_idx.append", "torch.matmul().unsqueeze.append", "enumerate", "torch.cat", "torch.zeros", "z_prob_col.append", "z_samples_col.append", "z_hiddens.detach", "torch.cat.detach", "torch.cat.detach", "pv_z_prob.append", "pv_z_hid.append", "pv_z_idx.append", "base_model.BaseModel.vocab.encode", "base_model.BaseModel.get_first_z_input", "torch.cat.append", "base_model.BaseModel.pz_decoder", "base_model.BaseModel.qz_decoder", "base_model.BaseModel.mask_probs", "base_model.BaseModel.embedding", "torch.gather().squeeze", "torch.log", "base_model.BaseModel.mask_samples", "torch.cat.append", "torch.cat.append", "base_model.BaseModel.z_encoder", "torch.stack", "torch.matmul", "base_model.BaseModel.z_encoder", "torch.argmax.view", "torch.argmax.view", "torch.topk", "torch.topk", "torch.multinomial", "torch.gather", "torch.gather", "base_model.BaseModel.squeeze", "torch.argmax.view", "torch.argmax", "torch.matmul().unsqueeze", "base_model.BaseModel.mask_samples", "gmb_samples.append", "torch.matmul"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.get_first_z_input", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_probs", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples"], ["", "def", "decode_z_parallel", "(", "self", ",", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "z_input", ",", "\n", "turn_states", ",", "sample_type", ",", "decoder_type", ",", "qz_samples", "=", "None", ",", "qz_hiddens", "=", "None", ",", "\n", "m_input", "=", "None", ",", "m_hiddens", "=", "None", ",", "m_input_1hot", "=", "None", ",", "mask_otlg", "=", "False", ")", ":", "\n", "        ", "return_gmb", "=", "True", "if", "'gumbel'", "in", "sample_type", "else", "False", "\n", "\n", "slot_num", "=", "len", "(", "self", ".", "reader", ".", "otlg", ".", "informable_slots", ")", "\n", "pv_z_pr", "=", "turn_states", ".", "get", "(", "'pv_%s_pr'", "%", "decoder_type", ",", "None", ")", "\n", "pv_z_h", "=", "turn_states", ".", "get", "(", "'pv_%s_h'", "%", "decoder_type", ",", "None", ")", "\n", "pv_z_id", "=", "turn_states", ".", "get", "(", "'pv_%s_id'", "%", "decoder_type", ",", "None", ")", "\n", "z_prob", ",", "z_samples", ",", "gmb_samples", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "log_pz", "=", "0", "\n", "\n", "last_hidden", "=", "u_last_hidden", "[", ":", "-", "1", "]", ".", "repeat", "(", "1", ",", "slot_num", ",", "1", ")", "# [1, B*|slot|, H]", "\n", "u_input", "=", "u_input", ".", "repeat", "(", "slot_num", ",", "1", ")", "\n", "u_input_1hot", "=", "u_input_1hot", ".", "repeat", "(", "slot_num", ",", "1", ",", "1", ")", "\n", "# u_input_1hot = get_one_hot_input(u_input, self.vocab_size)", "\n", "\n", "u_hiddens", "=", "u_hiddens", ".", "repeat", "(", "slot_num", ",", "1", ",", "1", ")", "\n", "if", "decoder_type", "!=", "'pz'", ":", "\n", "            ", "m_input", "=", "m_input", ".", "repeat", "(", "slot_num", ",", "1", ")", "\n", "m_input_1hot", "=", "m_input_1hot", ".", "repeat", "(", "slot_num", ",", "1", ",", "1", ")", "\n", "m_hiddens", "=", "m_hiddens", ".", "repeat", "(", "slot_num", ",", "1", ",", "1", ")", "\n", "# m_input_1hot = get_one_hot_input(m_input, self.vocab_size)", "\n", "", "if", "pv_z_pr", "is", "not", "None", ":", "\n", "# pv_z_pr = pv_z_pr.transpose(1,0).reshape(self.z_length, -1, cfg.vocab_size).transpose(1,0)    # [B*|slot|, T, V]", "\n", "# pv_z_h = pv_z_h.transpose(1,0).reshape(self.z_length, -1, cfg.hidden_size).transpose(1,0)    # [B*|slot|, T, H]", "\n", "# pv_z_id = pv_z_id.transpose(1,0).reshape(self.z_length, -1).transpose(1,0)    # [B*|slot|, T]", "\n", "            ", "pv_z_prob", ",", "pv_z_hid", ",", "pv_z_idx", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "reader", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "                ", "pv_z_prob", ".", "append", "(", "pv_z_pr", "[", ":", ",", "si", "*", "self", ".", "z_length", ":", "(", "si", "+", "1", ")", "*", "self", ".", "z_length", "]", ")", "\n", "pv_z_hid", ".", "append", "(", "pv_z_h", "[", ":", ",", "si", "*", "self", ".", "z_length", ":", "(", "si", "+", "1", ")", "*", "self", ".", "z_length", "]", ")", "\n", "pv_z_idx", ".", "append", "(", "pv_z_id", "[", ":", ",", "si", "*", "self", ".", "z_length", ":", "(", "si", "+", "1", ")", "*", "self", ".", "z_length", "]", ")", "\n", "", "pv_z_pr", "=", "torch", ".", "cat", "(", "pv_z_prob", ",", "dim", "=", "0", ")", "\n", "pv_z_h", "=", "torch", ".", "cat", "(", "pv_z_hid", ",", "dim", "=", "0", ")", "\n", "pv_z_id", "=", "torch", ".", "cat", "(", "pv_z_idx", ",", "dim", "=", "0", ")", "\n", "# print(pv_z_pr.size())", "\n", "# print(pv_z_id)", "\n", "\n", "", "emb_zt", ",", "z_eos_idx", "=", "[", "]", ",", "[", "]", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "reader", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "            ", "z_eos_idx", ".", "append", "(", "self", ".", "vocab", ".", "encode", "(", "self", ".", "z_eos_map", "[", "sn", "]", ")", ")", "\n", "emb_zt", ".", "append", "(", "self", ".", "get_first_z_input", "(", "sn", ",", "batch_size", ",", "self", ".", "multi_domain", ")", ")", "\n", "", "emb_zt", "=", "torch", ".", "cat", "(", "emb_zt", ",", "dim", "=", "0", ")", "\n", "\n", "if", "z_input", "is", "not", "None", ":", "\n", "            ", "z_input_cat", "=", "[", "]", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "reader", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "                ", "z_input_cat", ".", "append", "(", "z_input", "[", "sn", "]", ")", "\n", "", "z_input_cat", "=", "torch", ".", "cat", "(", "z_input_cat", ",", "dim", "=", "0", ")", "\n", "\n", "", "zero_vec", "=", "cuda_", "(", "torch", ".", "zeros", "(", "batch_size", "*", "slot_num", ",", "1", ",", "self", ".", "hidden_size", ")", ")", "\n", "selc_read_u", "=", "selc_read_m", "=", "selc_read_pv_z", "=", "zero_vec", "\n", "\n", "prev_zt", "=", "None", "\n", "for", "t", "in", "range", "(", "self", ".", "z_length", ")", ":", "\n", "            ", "if", "decoder_type", "==", "'pz'", ":", "\n", "                ", "prob", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_pv_z", "=", "self", ".", "pz_decoder", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "\n", "pv_z_prob", "=", "pv_z_pr", ",", "pv_z_hidden", "=", "pv_z_h", ",", "pv_z_idx", "=", "pv_z_id", ",", "\n", "emb_zt", "=", "emb_zt", ",", "last_hidden", "=", "last_hidden", ",", "\n", "selc_read_u", "=", "selc_read_u", ",", "selc_read_pv_z", "=", "selc_read_pv_z", ")", "\n", "", "else", ":", "\n", "\n", "                ", "prob", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_m", ",", "selc_read_pv_z", ",", "gmb_samp", "=", "self", ".", "qz_decoder", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "m_input", ",", "m_input_1hot", ",", "m_hiddens", ",", "\n", "pv_z_prob", "=", "pv_z_pr", ",", "pv_z_hidden", "=", "pv_z_h", ",", "pv_z_idx", "=", "pv_z_id", ",", "\n", "emb_zt", "=", "emb_zt", ",", "last_hidden", "=", "last_hidden", ",", "selc_read_u", "=", "selc_read_u", ",", "\n", "selc_read_m", "=", "selc_read_m", ",", "selc_read_pv_z", "=", "selc_read_pv_z", ",", "\n", "temp", "=", "self", ".", "gumbel_temp", ",", "return_gmb", "=", "return_gmb", ")", "\n", "", "if", "mask_otlg", ":", "\n", "                ", "prob", "=", "self", ".", "mask_probs", "(", "prob", ",", "tokens_allow", "=", "self", ".", "reader", ".", "slot_value_mask", "[", "sn", "]", ")", "\n", "\n", "", "if", "sample_type", "==", "'supervised'", ":", "\n", "# zt = z_input[sn][:, t]", "\n", "                ", "zt", "=", "z_input_cat", "[", ":", ",", "t", "]", "\n", "", "elif", "sample_type", "==", "'top1'", ":", "\n", "                ", "zt", "=", "torch", ".", "topk", "(", "prob", ",", "1", ")", "[", "1", "]", "\n", "", "elif", "sample_type", "==", "'topk'", ":", "\n", "                ", "topk_probs", ",", "topk_words", "=", "torch", ".", "topk", "(", "prob", ".", "squeeze", "(", "1", ")", ",", "cfg", ".", "topk_num", ")", "\n", "widx", "=", "torch", ".", "multinomial", "(", "topk_probs", ",", "1", ",", "replacement", "=", "True", ")", "\n", "zt", "=", "torch", ".", "gather", "(", "topk_words", ",", "1", ",", "widx", ")", "#[B]", "\n", "", "elif", "sample_type", "==", "'posterior'", ":", "\n", "                ", "zt", "=", "qz_samples", "[", ":", ",", "si", "*", "self", ".", "z_length", "+", "t", "]", "\n", "", "elif", "'gumbel'", "in", "sample_type", ":", "\n", "                ", "zt", "=", "torch", ".", "argmax", "(", "gmb_samp", ",", "dim", "=", "1", ")", "#[B]", "\n", "emb_zt", "=", "torch", ".", "matmul", "(", "gmb_samp", ",", "self", ".", "embedding", ".", "weight", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, H]", "\n", "zt", ",", "prev_zt", ",", "gmb_samp", "=", "self", ".", "mask_samples", "(", "zt", ",", "prev_zt", ",", "batch_size", ",", "z_eos_idx", ",", "gmb_samp", ",", "True", ")", "\n", "gmb_samples", ".", "append", "(", "gmb_samp", ")", "\n", "\n", "", "if", "'gumbel'", "not", "in", "sample_type", ":", "\n", "                ", "emb_zt", "=", "self", ".", "embedding", "(", "zt", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "prob_zt", "=", "torch", ".", "gather", "(", "prob", ",", "1", ",", "zt", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "squeeze", "(", "1", ")", "#[B, 1]", "\n", "log_prob_zt", "=", "torch", ".", "log", "(", "prob_zt", ")", "\n", "zt", ",", "prev_zt", ",", "log_prob_zt", "=", "self", ".", "mask_samples", "(", "zt", ",", "prev_zt", ",", "batch_size", ",", "z_eos_idx", ",", "log_prob_zt", ")", "\n", "log_pz", "+=", "log_prob_zt", "\n", "z_samples", ".", "append", "(", "zt", ".", "view", "(", "-", "1", ")", ")", "\n", "z_prob", ".", "append", "(", "prob", ")", "\n", "\n", "", "", "z_prob", "=", "torch", ".", "stack", "(", "z_prob", ",", "dim", "=", "1", ")", "# [B*|slot|,Tz,V]", "\n", "z_samples", "=", "torch", ".", "stack", "(", "z_samples", ",", "dim", "=", "1", ")", "# [B*|slot|,Tz]", "\n", "z_prob_col", ",", "z_samples_col", "=", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "range", "(", "slot_num", ")", ":", "\n", "            ", "z_prob_col", ".", "append", "(", "z_prob", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ")", "\n", "z_samples_col", ".", "append", "(", "z_samples", "[", "i", "*", "batch_size", ":", "(", "i", "+", "1", ")", "*", "batch_size", "]", ")", "\n", "", "z_prob", "=", "torch", ".", "cat", "(", "z_prob_col", ",", "dim", "=", "1", ")", "# [B,Tz*|slot|,V]", "\n", "z_samples", "=", "torch", ".", "cat", "(", "z_samples_col", ",", "dim", "=", "1", ")", "# [B,Tz*|slot|]", "\n", "\n", "#    Tz*|slot|, B", "\n", "\n", "if", "sample_type", "==", "'posterior'", ":", "\n", "            ", "z_samples", ",", "z_hiddens", "=", "qz_samples", ",", "qz_hiddens", "\n", "", "elif", "'gumbel'", "not", "in", "sample_type", ":", "\n", "            ", "z_hiddens", ",", "z_last_hidden", "=", "self", ".", "z_encoder", "(", "z_samples", ",", "input_type", "=", "'index'", ")", "\n", "", "else", ":", "\n", "            ", "z_gumbel", "=", "torch", ".", "stack", "(", "gmb_samples", ",", "dim", "=", "1", ")", "# [B, Tz, V]", "\n", "z_gumbel", "=", "torch", ".", "matmul", "(", "z_gumbel", ",", "self", ".", "embedding", ".", "weight", ")", "# [B, Tz, E]", "\n", "z_hiddens", ",", "z_last_hidden", "=", "self", ".", "z_encoder", "(", "z_gumbel", ",", "input_type", "=", "'embedding'", ")", "\n", "\n", "", "retain", "=", "self", ".", "prev_z_continuous", "\n", "turn_states", "[", "'pv_%s_h'", "%", "decoder_type", "]", "=", "z_hiddens", "if", "retain", "else", "z_hiddens", ".", "detach", "(", ")", "\n", "turn_states", "[", "'pv_%s_pr'", "%", "decoder_type", "]", "=", "z_prob", "if", "retain", "else", "z_prob", ".", "detach", "(", ")", "\n", "turn_states", "[", "'pv_%s_id'", "%", "decoder_type", "]", "=", "z_samples", "if", "retain", "else", "z_samples", ".", "detach", "(", ")", "\n", "\n", "return", "z_prob", ",", "z_samples", ",", "z_hiddens", ",", "turn_states", ",", "log_pz", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_a": [[297, 362], ["enumerate", "torch.stack", "torch.stack", "base_model.BaseModel.vocab.encode", "base_model.BaseModel.vocab.encode", "cuda_().long", "base_model.BaseModel.embedding", "cuda_", "torch.cat", "range", "torch.zeros", "cuda_", "torch.stack.append", "torch.stack.append", "base_model.BaseModel.a_encoder", "torch.stack", "torch.matmul", "base_model.BaseModel.a_encoder", "cuda_", "torch.zeros", "base_model.BaseModel.embedding", "torch.gather().squeeze", "torch.log", "base_model.BaseModel.mask_samples", "torch.argmax.view", "cuda_.size", "torch.argmax.view", "torch.ones", "torch.topk", "torch.topk", "torch.multinomial", "torch.gather", "torch.gather", "prob.squeeze", "torch.argmax.view", "torch.argmax", "torch.matmul().unsqueeze", "base_model.BaseModel.mask_samples", "gmb_samples.append", "torch.matmul"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples"], ["", "def", "decode_a", "(", "self", ",", "batch_size", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "u_last_hidden", ",", "a_input", ",", "\n", "db_vec", ",", "filling_vec", ",", "sample_type", ",", "decoder_type", ",", "qa_samples", "=", "None", ",", "\n", "qa_hiddens", "=", "None", ",", "m_input", "=", "None", ",", "m_hiddens", "=", "None", ",", "m_input_1hot", "=", "None", ")", ":", "\n", "        ", "return_gmb", "=", "True", "if", "'gumbel'", "in", "sample_type", "else", "False", "\n", "a_prob", ",", "a_samples", ",", "gmb_samples", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "log_pa", "=", "0", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "reader", ".", "act_order", ")", ":", "\n", "            ", "last_hidden", "=", "u_last_hidden", "[", ":", "-", "1", "]", "\n", "a_eos_idx", "=", "self", ".", "vocab", ".", "encode", "(", "'<eos_%s>'", "%", "sn", ")", "\n", "a_sos_idx", "=", "self", ".", "vocab", ".", "encode", "(", "'<go_%s>'", "%", "sn", ")", "\n", "at", "=", "cuda_", "(", "torch", ".", "ones", "(", "batch_size", ",", "1", ")", "*", "a_sos_idx", ")", ".", "long", "(", ")", "\n", "emb_at", "=", "self", ".", "embedding", "(", "at", ")", "\n", "selc_read_m", "=", "cuda_", "(", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "self", ".", "hidden_size", ")", ")", "\n", "vec_input", "=", "torch", ".", "cat", "(", "[", "db_vec", ",", "filling_vec", "]", ",", "dim", "=", "1", ")", "\n", "if", "sn", "==", "'av'", ":", "\n", "                ", "vec_input", "=", "cuda_", "(", "torch", ".", "zeros", "(", "vec_input", ".", "size", "(", ")", ")", ")", "\n", "", "prev_at", "=", "None", "\n", "for", "t", "in", "range", "(", "self", ".", "a_length", ")", ":", "\n", "                ", "if", "decoder_type", "==", "'pa'", ":", "\n", "                    ", "prob", ",", "last_hidden", ",", "gru_out", "=", "self", ".", "pa_decoder", "[", "sn", "]", "(", "\n", "u_hiddens", ",", "emb_at", ",", "vec_input", ",", "last_hidden", ")", "\n", "", "else", ":", "\n", "                    ", "prob", ",", "last_hidden", ",", "gru_out", ",", "selc_read_m", ",", "gmb_samp", "=", "self", ".", "qa_decoder", "[", "sn", "]", "(", "u_hiddens", ",", "\n", "m_input", ",", "m_input_1hot", ",", "m_hiddens", ",", "\n", "emb_at", ",", "vec_input", ",", "last_hidden", ",", "\n", "selc_read_m", "=", "selc_read_m", ",", "temp", "=", "self", ".", "gumbel_temp", ",", "\n", "return_gmb", "=", "return_gmb", ")", "\n", "", "if", "sample_type", "==", "'supervised'", ":", "\n", "                    ", "at", "=", "a_input", "[", "sn", "]", "[", ":", ",", "t", "]", "\n", "", "elif", "sample_type", "==", "'top1'", ":", "\n", "                    ", "at", "=", "torch", ".", "topk", "(", "prob", ",", "1", ")", "[", "1", "]", "\n", "", "elif", "sample_type", "==", "'topk'", ":", "\n", "                    ", "topk_probs", ",", "topk_words", "=", "torch", ".", "topk", "(", "prob", ".", "squeeze", "(", "1", ")", ",", "cfg", ".", "topk_num", ")", "\n", "widx", "=", "torch", ".", "multinomial", "(", "topk_probs", ",", "1", ",", "replacement", "=", "True", ")", "\n", "at", "=", "torch", ".", "gather", "(", "topk_words", ",", "1", ",", "widx", ")", "#[B]", "\n", "", "elif", "sample_type", "==", "'posterior'", ":", "\n", "                    ", "at", "=", "qa_samples", "[", ":", ",", "si", "*", "self", ".", "a_length", "+", "t", "]", "\n", "", "elif", "'gumbel'", "in", "sample_type", ":", "\n", "                    ", "at", "=", "torch", ".", "argmax", "(", "gmb_samp", ",", "dim", "=", "1", ")", "#[B]", "\n", "emb_at", "=", "torch", ".", "matmul", "(", "gmb_samp", ",", "self", ".", "embedding", ".", "weight", ")", ".", "unsqueeze", "(", "1", ")", "# [B, 1, H]", "\n", "at", ",", "prev_at", ",", "gmb_samp", "=", "self", ".", "mask_samples", "(", "at", ",", "prev_at", ",", "batch_size", ",", "a_eos_idx", ",", "gmb_samp", ",", "True", ")", "\n", "gmb_samples", ".", "append", "(", "gmb_samp", ")", "\n", "\n", "", "if", "'gumbel'", "not", "in", "sample_type", ":", "\n", "                    ", "emb_at", "=", "self", ".", "embedding", "(", "at", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "prob_at", "=", "torch", ".", "gather", "(", "prob", ",", "1", ",", "at", ".", "view", "(", "-", "1", ",", "1", ")", ")", ".", "squeeze", "(", "1", ")", "#[B, 1]", "\n", "log_prob_at", "=", "torch", ".", "log", "(", "prob_at", ")", "\n", "at", ",", "prev_at", ",", "log_prob_at", "=", "self", ".", "mask_samples", "(", "at", ",", "prev_at", ",", "batch_size", ",", "a_eos_idx", ",", "log_prob_at", ")", "\n", "log_pa", "+=", "log_prob_at", "\n", "", "a_samples", ".", "append", "(", "at", ".", "view", "(", "-", "1", ")", ")", "\n", "a_prob", ".", "append", "(", "prob", ")", "\n", "", "", "a_prob", "=", "torch", ".", "stack", "(", "a_prob", ",", "dim", "=", "1", ")", "\n", "a_samples", "=", "torch", ".", "stack", "(", "a_samples", ",", "dim", "=", "1", ")", "# [B,Ta]", "\n", "\n", "if", "sample_type", "==", "'posterior'", ":", "\n", "            ", "a_samples", ",", "a_hiddens", "=", "qa_samples", ",", "qa_hiddens", "\n", "", "elif", "'gumbel'", "not", "in", "sample_type", ":", "\n", "            ", "a_hiddens", ",", "a_last_hidden", "=", "self", ".", "a_encoder", "(", "a_samples", ",", "input_type", "=", "'index'", ")", "\n", "", "else", ":", "\n", "            ", "a_gumbel", "=", "torch", ".", "stack", "(", "gmb_samples", ",", "dim", "=", "1", ")", "# [B,Ta, V]", "\n", "a_gumbel", "=", "torch", ".", "matmul", "(", "a_gumbel", ",", "self", ".", "embedding", ".", "weight", ")", "# [B,Ta, E]", "\n", "a_hiddens", ",", "a_last_hidden", "=", "self", ".", "a_encoder", "(", "a_gumbel", ",", "input_type", "=", "'embedding'", ")", "\n", "\n", "", "return", "a_prob", ",", "a_samples", ",", "a_hiddens", ",", "log_pa", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.decode_m": [[363, 399], ["cuda_", "cuda_", "base_model.BaseModel.vocab.encode", "range", "torch.stack", "torch.stack", "torch.ones().long", "torch.zeros", "m_input.size", "base_model.BaseModel.m_decoder", "torch.stack.append", "list", "utils.toss_", "mt.view.view.view", "torch.gather().squeeze", "torch.log", "base_model.BaseModel.mask_samples", "torch.stack.append", "torch.topk", "torch.stack.append", "list", "torch.ones", "[].data.view", "mt.view.view.data.view", "torch.topk", "torch.gather", "torch.topk"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.toss_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples"], ["", "def", "decode_m", "(", "self", ",", "batch_size", ",", "u_last_hidden", ",", "u_input", ",", "u_hiddens", ",", "u_input_1hot", ",", "\n", "pz_samples", ",", "pz_prob", ",", "z_hiddens", ",", "pa_samples", ",", "pa_prob", ",", "a_hiddens", ",", "\n", "db_vec", ",", "m_input", ",", "is_train", ")", ":", "\n", "        ", "last_hidden", "=", "u_last_hidden", "[", ":", "-", "1", "]", "\n", "mt", "=", "cuda_", "(", "torch", ".", "ones", "(", "batch_size", ",", "1", ")", ".", "long", "(", ")", ")", "# GO token", "\n", "m_idx", ",", "pm_prob", "=", "[", "]", ",", "[", "]", "\n", "zero_vec", "=", "cuda_", "(", "torch", ".", "zeros", "(", "batch_size", ",", "1", ",", "self", ".", "hidden_size", ")", ")", "\n", "selc_read_u", "=", "selc_read_z", "=", "selc_read_a", "=", "zero_vec", "\n", "m_eos_idx", "=", "self", ".", "vocab", ".", "encode", "(", "self", ".", "eos_m_token", ")", "\n", "log_pm", "=", "0", "\n", "prev_mt", "=", "None", "\n", "m_len", "=", "m_input", ".", "size", "(", "1", ")", "if", "m_input", "is", "not", "None", "else", "self", ".", "max_len", "\n", "for", "t", "in", "range", "(", "m_len", ")", ":", "\n", "            ", "prob", ",", "last_hidden", ",", "gru_out", ",", "selc_read_u", ",", "selc_read_z", ",", "selc_read_a", "=", "self", ".", "m_decoder", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "\n", "pz_samples", ",", "pz_prob", ",", "z_hiddens", ",", "\n", "mt", ",", "db_vec", ",", "last_hidden", ",", "\n", "pa_samples", ",", "pa_prob", ",", "a_hiddens", ",", "\n", "selc_read_u", ",", "selc_read_z", ",", "selc_read_a", ")", "\n", "if", "is_train", ":", "\n", "                ", "teacher_forcing", "=", "toss_", "(", "self", ".", "teacher_force", ")", "\n", "mt", "=", "m_input", "[", ":", ",", "t", "]", "if", "teacher_forcing", "else", "torch", ".", "topk", "(", "prob", ",", "1", ")", "[", "1", "]", "\n", "mt", "=", "mt", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "prob_mt", "=", "torch", ".", "gather", "(", "prob", ",", "1", ",", "mt", ")", ".", "squeeze", "(", "1", ")", "#[B*K]", "\n", "log_pmt", "=", "torch", ".", "log", "(", "prob_mt", ")", "\n", "mt", ",", "prev_mt", ",", "log_pmt", "=", "self", ".", "mask_samples", "(", "mt", ",", "prev_mt", ",", "batch_size", ",", "m_eos_idx", ",", "log_pmt", ")", "\n", "log_pm", "+=", "log_pmt", "\n", "m_idx", ".", "append", "(", "torch", ".", "topk", "(", "prob", ",", "1", ")", "[", "1", "]", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "mt_prob", ",", "mt", "=", "torch", ".", "topk", "(", "prob", ",", "1", ")", "\n", "m_idx", ".", "append", "(", "mt", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "pm_prob", ".", "append", "(", "prob", ")", "\n", "", "pm_prob", "=", "torch", ".", "stack", "(", "pm_prob", ",", "dim", "=", "1", ")", "# [B,T,V]", "\n", "m_idx", "=", "torch", ".", "stack", "(", "m_idx", ",", "dim", "=", "1", ")", "\n", "m_idx", "=", "[", "list", "(", "_", ")", "for", "_", "in", "list", "(", "m_idx", ")", "]", "\n", "return", "pm_prob", ",", "m_idx", ",", "log_pm", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.max_sampling": [[400, 409], ["torch.topk", "list", "list.squeeze", "list"], "methods", ["None"], ["", "def", "max_sampling", "(", "self", ",", "prob", ")", ":", "\n", "        ", "\"\"\"\n        Max-sampling procedure of pz during testing.\n        :param pz_prob: # [B, T, V]\n        :return: nested-list: B * [T]\n        \"\"\"", "\n", "p", ",", "token", "=", "torch", ".", "topk", "(", "prob", ",", "1", ",", "dim", "=", "2", ")", "# [B, T, 1]", "\n", "token", "=", "list", "(", "token", ".", "squeeze", "(", "2", ")", ")", "\n", "return", "[", "list", "(", "_", ")", "for", "_", "in", "token", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.get_first_z_input": [[411, 430], ["domain_slot_name.split", "smap.get", "base_model.BaseModel.vocab.encode", "cuda_().long", "base_model.BaseModel.embedding", "base_model.BaseModel.vocab.encode", "cuda_().long", "base_model.BaseModel.embedding", "cuda_", "cuda_", "torch.ones", "torch.ones"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "def", "get_first_z_input", "(", "self", ",", "domain_slot_name", ",", "batch_size", ",", "multi_domain", "=", "True", ")", ":", "\n", "# domain_slot_name: a string likes \"domain-slot\"", "\n", "\n", "        ", "domain", ",", "slot", "=", "domain_slot_name", ".", "split", "(", "'-'", ")", "\n", "smap", "=", "{", "'pricerange'", ":", "'price'", ",", "\n", "'weather_attribute'", ":", "'weather'", ",", "\n", "'poi_type'", ":", "'type'", ",", "\n", "'traffic_info'", ":", "'traffic'", ",", "\n", "}", "\n", "slot", "=", "smap", ".", "get", "(", "slot", ",", "slot", ")", "\n", "slot_idx", "=", "self", ".", "vocab", ".", "encode", "(", "slot", ")", "\n", "slot_idx", "=", "cuda_", "(", "torch", ".", "ones", "(", "batch_size", ",", "1", ")", "*", "slot_idx", ")", ".", "long", "(", ")", "\n", "emb", "=", "self", ".", "embedding", "(", "slot_idx", ")", "\n", "if", "multi_domain", ":", "\n", "            ", "domain_idx", "=", "self", ".", "vocab", ".", "encode", "(", "domain", ")", "\n", "domain_idx", "=", "cuda_", "(", "torch", ".", "ones", "(", "batch_size", ",", "1", ")", "*", "domain_idx", ")", ".", "long", "(", ")", "\n", "d_emb", "=", "self", ".", "embedding", "(", "domain_idx", ")", "\n", "emb", "=", "emb", "+", "d_emb", "\n", "", "return", "emb", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_samples": [[432, 453], ["cuda_", "isinstance", "torch.ones", "range", "mask.view.view.long", "curr_z.size", "mask.view.view.view", "mask.view.view.view", "mask.view.view.expand", "prev_z[].item", "prev_z[].item", "curr_z_pr.size", "mask.view.view.size", "curr_z_pr.size"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "def", "mask_samples", "(", "self", ",", "curr_z", ",", "prev_z", ",", "batch_size", ",", "eos_idx", ",", "curr_z_pr", "=", "None", ",", "is_gumbel", "=", "False", ")", ":", "\n", "# change tokens and probabilities after <eos> to zeros", "\n", "# necessary for log-likelihood computation in SMC", "\n", "        ", "if", "not", "isinstance", "(", "eos_idx", ",", "list", ")", ":", "\n", "            ", "eos_idx", "=", "[", "eos_idx", "]", "\n", "", "mask", "=", "cuda_", "(", "torch", ".", "ones", "(", "curr_z", ".", "size", "(", ")", ")", ")", "\n", "if", "prev_z", "is", "not", "None", ":", "\n", "            ", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "                ", "if", "prev_z", "[", "b", "]", ".", "item", "(", ")", "in", "eos_idx", "or", "prev_z", "[", "b", "]", ".", "item", "(", ")", "==", "0", ":", "\n", "                    ", "mask", "[", "b", "]", "=", "0", "\n", "", "", "", "curr_z_masked", "=", "curr_z", "*", "mask", ".", "long", "(", ")", "\n", "new_prev_z", "=", "curr_z_masked", "\n", "if", "curr_z_pr", "is", "not", "None", ":", "\n", "            ", "if", "not", "is_gumbel", ":", "\n", "                ", "curr_z_pr_masked", "=", "curr_z_pr", "*", "mask", ".", "view", "(", "curr_z_pr", ".", "size", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "mask", "=", "mask", ".", "view", "(", "-", "1", ",", "1", ")", "\n", "curr_z_pr_masked", "=", "curr_z_pr", "*", "mask", ".", "expand", "(", "mask", ".", "size", "(", "0", ")", ",", "curr_z_pr", ".", "size", "(", "1", ")", ")", "\n", "", "return", "curr_z_masked", ",", "new_prev_z", ",", "curr_z_pr_masked", "\n", "", "else", ":", "\n", "            ", "return", "curr_z_masked", ",", "new_prev_z", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.mask_probs": [[456, 472], ["cuda_", "torch.zeros().fill_", "torch.zeros", "prob.size"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "", "def", "mask_probs", "(", "self", ",", "prob", ",", "tokens_allow", ")", ":", "\n", "        ", "\"\"\" set probability of all the special tokens to ~0 except tokens in list special_allow\n        : param prob: size [B,V]\n        :param special_allow: [description]\n        :type special_allow: [type]\n        \"\"\"", "\n", "# mask_idx = [0,1,3,4,5,6,7,8]", "\n", "# for idx in special_allow:", "\n", "#     if idx in mask_idx:", "\n", "#         mask_idx.remove(idx)", "\n", "# mask = cuda_(torch.ones(prob.size()))", "\n", "# mask[:, mask_idx] = 1e-10", "\n", "mask", "=", "cuda_", "(", "torch", ".", "zeros", "(", "prob", ".", "size", "(", ")", ")", ".", "fill_", "(", "1e-10", ")", ")", "\n", "mask", "[", ":", ",", "tokens_allow", "]", "=", "1", "\n", "prob", "=", "prob", "*", "mask", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.beam_search_decode": [[474, 499], ["u_input.size", "range", "u_input[].unsqueeze", "u_input_1hot[].unsqueeze", "u_hiddens[].unsqueeze", "pz_samples[].unsqueeze", "pz_prob[].unsqueeze", "z_hiddens[].unsqueeze", "db_vec[].unsqueeze", "last_hidden[].unsqueeze", "base_model.BaseModel.beam_single", "decoded.append", "list", "pa_samples[].unsqueeze", "pa_prob[].unsqueeze", "a_hiddens[].unsqueeze", "_.view"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.beam_single"], ["", "def", "beam_search_decode", "(", "self", ",", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "pz_samples", ",", "pz_prob", ",", "z_hiddens", ",", "\n", "db_vec", ",", "last_hidden", ",", "pa_samples", "=", "None", ",", "pa_prob", "=", "None", ",", "a_hiddens", "=", "None", ")", ":", "\n", "# Beam search decoding does not support selective read", "\n", "        ", "batch_size", "=", "u_input", ".", "size", "(", "0", ")", "\n", "decoded", "=", "[", "]", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "u_input_s", "=", "u_input", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "u_input_1hot_s", "=", "u_input_1hot", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "u_hiddens_s", "=", "u_hiddens", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "pz_samples_s", "=", "pz_samples", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "pz_prob_s", "=", "pz_prob", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "z_hiddens_s", "=", "z_hiddens", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "db_vec_s", "=", "db_vec", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "last_hidden_s", "=", "last_hidden", "[", ":", ",", "b", "]", ".", "unsqueeze", "(", "1", ")", "\n", "if", "pa_samples", "is", "not", "None", ":", "\n", "                ", "pa_samples_s", "=", "pa_samples", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "pa_prob_s", "=", "pa_prob", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "a_hiddens_s", "=", "a_hiddens", "[", "b", "]", ".", "unsqueeze", "(", "0", ")", "\n", "", "else", ":", "\n", "                ", "pa_samples_s", ",", "pa_prob_s", ",", "a_hiddens_s", "=", "None", ",", "None", ",", "None", "\n", "", "decoded_s", "=", "self", ".", "beam_single", "(", "u_input_s", ",", "u_input_1hot_s", ",", "u_hiddens_s", ",", "pz_samples_s", ",", "\n", "pz_prob_s", ",", "z_hiddens_s", ",", "db_vec_s", ",", "last_hidden_s", ",", "\n", "pa_samples_s", ",", "pa_prob_s", ",", "a_hiddens_s", ")", "\n", "decoded", ".", "append", "(", "decoded_s", ")", "\n", "", "return", "[", "list", "(", "_", ".", "view", "(", "-", "1", ")", ")", "for", "_", "in", "decoded", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.beam_single": [[500, 586], ["cuda_", "states.append", "range", "finished.sort", "u_input.size", "torch.ones().long", "utils.BeamState", "new_states.sort", "_.view().item", "torch.cat", "base_model.BaseModel.m_decoder", "torch.log", "torch.topk", "range", "print", "len", "torch.ones", "len", "finished.append", "_.view", "[].item", "base_model.BaseModel.beam_single.score_bonus"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.rnn_net.cuda_"], ["", "def", "beam_single", "(", "self", ",", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "pz_samples", ",", "pz_prob", ",", "z_hiddens", ",", "db_vec", ",", "last_hidden", ",", "\n", "pa_samples", "=", "None", ",", "pa_prob", "=", "None", ",", "a_hiddens", "=", "None", ")", ":", "\n", "        ", "assert", "u_input", ".", "size", "(", "0", ")", "==", "1", ",", "\"Beam search single requires batch size to be 1\"", "\n", "\n", "\n", "def", "beam_result_valid", "(", "decoded_t", ")", ":", "\n", "            ", "return", "True", "\n", "\n", "", "def", "score_bonus", "(", "state", ",", "decoded", ")", ":", "\n", "            ", "\"\"\"\n            bonus scheme: bonus per token, or per new decoded slot.\n            :param state:\n            :return:\n            \"\"\"", "\n", "bonus", "=", "self", ".", "beam_len_bonus", "\n", "# decoded = self.vocab.decode(decoded)", "\n", "# decoded_t = [_.item() for _ in state.decoded]", "\n", "# decoded_sentence = self.vocab.sentence_decode(decoded_t, self.eos_m_token)", "\n", "# decoded_sentence = decoded_sentence.split()", "\n", "if", "len", "(", "state", ".", "decoded", ")", ">=", "1", "and", "state", ".", "decoded", "[", "-", "1", "]", "==", "decoded", ":", "# repeated words", "\n", "# print('repeat words!')", "\n", "                ", "bonus", "-=", "1000", "\n", "", "if", "decoded", "==", "'**unknown**'", ":", "\n", "                ", "bonus", "-=", "3.0", "\n", "", "return", "bonus", "\n", "\n", "\n", "", "finished", ",", "failed", "=", "[", "]", ",", "[", "]", "\n", "states", "=", "[", "]", "# sorted by score decreasingly", "\n", "dead_k", "=", "0", "\n", "mt", "=", "cuda_", "(", "torch", ".", "ones", "(", "1", ",", "1", ")", ".", "long", "(", ")", ")", "# GO token", "\n", "states", ".", "append", "(", "BeamState", "(", "0", ",", "last_hidden", ",", "[", "mt", "]", ",", "0", ")", ")", "\n", "\n", "for", "t", "in", "range", "(", "self", ".", "max_len", ")", ":", "\n", "            ", "new_states", "=", "[", "]", "\n", "k", "=", "0", "\n", "while", "k", "<", "len", "(", "states", ")", "and", "k", "<", "self", ".", "beam_size", "-", "dead_k", ":", "\n", "                ", "state", "=", "states", "[", "k", "]", "\n", "last_hidden", ",", "mt", "=", "state", ".", "last_hidden", ",", "state", ".", "decoded", "[", "-", "1", "]", "\n", "prob", ",", "last_hidden", ",", "_", ",", "_", ",", "_", ",", "_", "=", "self", ".", "m_decoder", "(", "u_input", ",", "u_input_1hot", ",", "u_hiddens", ",", "\n", "pz_samples", ",", "pz_prob", ",", "z_hiddens", ",", "\n", "mt", ",", "db_vec", ",", "last_hidden", ",", "\n", "pa_samples", ",", "pa_prob", ",", "a_hiddens", ")", "\n", "\n", "prob", "=", "torch", ".", "log", "(", "prob", ")", "\n", "mt_prob", ",", "mt_index", "=", "torch", ".", "topk", "(", "prob", ",", "self", ".", "beam_size", "-", "dead_k", ")", "# [1,K]", "\n", "for", "new_k", "in", "range", "(", "self", ".", "beam_size", "-", "dead_k", ")", ":", "\n", "                    ", "score_incre", "=", "mt_prob", "[", "0", "]", "[", "new_k", "]", ".", "item", "(", ")", "+", "score_bonus", "(", "state", ",", "\n", "mt_index", "[", "0", "]", "[", "new_k", "]", ".", "item", "(", ")", ")", "\n", "if", "len", "(", "new_states", ")", ">=", "self", ".", "beam_size", "-", "dead_k", "and", "state", ".", "score", "+", "score_incre", "<", "new_states", "[", "-", "1", "]", ".", "score", ":", "\n", "                        ", "break", "\n", "", "decoded_t", "=", "mt_index", "[", "0", "]", "[", "new_k", "]", "\n", "if", "decoded_t", ".", "item", "(", ")", ">=", "self", ".", "vocab_size", ":", "\n", "                        ", "decoded_t", "=", "cuda_", "(", "torch", ".", "ones", "(", "1", ",", "1", ")", "*", "2", ")", ".", "long", "(", ")", "# unk", "\n", "", "if", "self", ".", "vocab", ".", "decode", "(", "decoded_t", ".", "item", "(", ")", ")", "==", "self", ".", "eos_m_token", ":", "\n", "                        ", "if", "beam_result_valid", "(", "state", ".", "decoded", ")", ":", "\n", "                            ", "finished", ".", "append", "(", "state", ")", "\n", "dead_k", "+=", "1", "\n", "", "else", ":", "\n", "                            ", "failed", ".", "append", "(", "state", ")", "\n", "", "", "else", ":", "\n", "                        ", "decoded_t", "=", "decoded_t", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "new_state", "=", "state", ".", "update_clone", "(", "score_incre", ",", "last_hidden", ",", "decoded_t", ")", "\n", "new_states", ".", "append", "(", "new_state", ")", "\n", "\n", "", "", "k", "+=", "1", "\n", "", "if", "self", ".", "beam_size", "-", "dead_k", "<", "0", ":", "\n", "                ", "break", "\n", "", "new_states", "=", "new_states", "[", ":", "self", ".", "beam_size", "-", "dead_k", "]", "\n", "new_states", ".", "sort", "(", "key", "=", "lambda", "x", ":", "-", "x", ".", "score", ")", "\n", "states", "=", "new_states", "\n", "\n", "if", "t", "==", "self", ".", "max_len", "-", "1", "and", "not", "finished", ":", "\n", "                ", "finished", "=", "failed", "\n", "print", "(", "'FAIL'", ")", "\n", "if", "not", "finished", ":", "\n", "                    ", "finished", ".", "append", "(", "states", "[", "0", "]", ")", "\n", "\n", "", "", "", "finished", ".", "sort", "(", "key", "=", "lambda", "x", ":", "-", "x", ".", "score", ")", "\n", "decoded_t", "=", "finished", "[", "0", "]", ".", "decoded", "\n", "decoded_t", "=", "[", "_", ".", "view", "(", "-", "1", ")", ".", "item", "(", ")", "for", "_", "in", "decoded_t", "]", "\n", "# decoded_sentence = self.vocab.sentence_decode(decoded_t, self.eos_m_token)", "\n", "# print(decoded_sentence)", "\n", "generated", "=", "torch", ".", "cat", "(", "finished", "[", "0", "]", ".", "decoded", ",", "dim", "=", "1", ")", ".", "data", "# [B=1, T]", "\n", "return", "generated", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.base_model.BaseModel.self_adjust": [[587, 589], ["None"], "methods", ["None"], ["", "def", "self_adjust", "(", "self", ",", "epoch", ")", ":", "\n", "        ", "pass", "", "", "", ""]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.BeamState.__init__": [[111, 123], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "score", ",", "last_hidden", ",", "decoded", ",", "length", ")", ":", "\n", "        ", "\"\"\"\n        Beam state in beam decoding\n        :param score: sum of log-probabilities\n        :param last_hidden: last hidden\n        :param decoded: list of *Variable[1*1]* of all decoded words\n        :param length: current decoded sentence length\n        \"\"\"", "\n", "self", ".", "score", "=", "score", "\n", "self", ".", "last_hidden", "=", "last_hidden", "\n", "self", ".", "decoded", "=", "decoded", "\n", "self", ".", "length", "=", "length", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.BeamState.update_clone": [[124, 129], ["copy.copy", "copy.copy.append", "utils.BeamState"], "methods", ["None"], ["", "def", "update_clone", "(", "self", ",", "score_incre", ",", "last_hidden", ",", "decoded_t", ")", ":", "\n", "        ", "decoded", "=", "copy", ".", "copy", "(", "self", ".", "decoded", ")", "\n", "decoded", ".", "append", "(", "decoded_t", ")", "\n", "clone", "=", "BeamState", "(", "self", ".", "score", "+", "score_incre", ",", "last_hidden", ",", "decoded", ",", "self", ".", "length", "+", "1", ")", "\n", "return", "clone", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.toss_": [[4, 6], ["random.randint"], "function", ["None"], ["def", "toss_", "(", "p", ")", ":", "\n", "    ", "return", "random", ".", "randint", "(", "0", ",", "99", ")", "<=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.nan": [[7, 9], ["numpy.isnan", "numpy.sum", "v.data.cpu().numpy", "v.data.cpu"], "function", ["None"], ["", "def", "nan", "(", "v", ")", ":", "\n", "    ", "return", "np", ".", "isnan", "(", "np", ".", "sum", "(", "v", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.write_dict": [[10, 13], ["open", "json.dump"], "function", ["None"], ["", "def", "write_dict", "(", "fn", ",", "dic", ")", ":", "\n", "    ", "with", "open", "(", "fn", ",", "'w'", ")", "as", "f", ":", "\n", "        ", "json", ".", "dump", "(", "dic", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.clean_replace": [[14, 45], ["s.find", "utils.clean_replace.clean_replace_single"], "function", ["None"], ["", "", "def", "clean_replace", "(", "s", ",", "r", ",", "t", ",", "forward", "=", "True", ",", "backward", "=", "False", ")", ":", "\n", "    ", "def", "clean_replace_single", "(", "s", ",", "r", ",", "t", ",", "forward", ",", "backward", ",", "sidx", "=", "0", ")", ":", "\n", "# idx = s[sidx:].find(r)", "\n", "        ", "idx", "=", "s", ".", "find", "(", "r", ")", "\n", "if", "idx", "==", "-", "1", ":", "\n", "            ", "return", "s", ",", "-", "1", "\n", "", "idx_r", "=", "idx", "+", "len", "(", "r", ")", "\n", "if", "backward", ":", "\n", "            ", "while", "idx", ">", "0", "and", "s", "[", "idx", "-", "1", "]", ":", "\n", "                ", "idx", "-=", "1", "\n", "", "", "elif", "idx", ">", "0", "and", "s", "[", "idx", "-", "1", "]", "!=", "' '", ":", "\n", "            ", "return", "s", ",", "-", "1", "\n", "\n", "", "if", "forward", ":", "\n", "            ", "while", "idx_r", "<", "len", "(", "s", ")", "and", "(", "s", "[", "idx_r", "]", ".", "isalpha", "(", ")", "or", "s", "[", "idx_r", "]", ".", "isdigit", "(", ")", ")", ":", "\n", "                ", "idx_r", "+=", "1", "\n", "", "", "elif", "idx_r", "!=", "len", "(", "s", ")", "and", "(", "s", "[", "idx_r", "]", ".", "isalpha", "(", ")", "or", "s", "[", "idx_r", "]", ".", "isdigit", "(", ")", ")", ":", "\n", "            ", "return", "s", ",", "-", "1", "\n", "", "return", "s", "[", ":", "idx", "]", "+", "t", "+", "s", "[", "idx_r", ":", "]", ",", "idx_r", "\n", "\n", "# source, replace, target = s, r, t", "\n", "# count = 0", "\n", "", "sidx", "=", "0", "\n", "while", "sidx", "!=", "-", "1", ":", "\n", "        ", "s", ",", "sidx", "=", "clean_replace_single", "(", "s", ",", "r", ",", "t", ",", "forward", ",", "backward", ",", "sidx", ")", "\n", "# count += 1", "\n", "# print(s, sidx)", "\n", "# if count == 20:", "\n", "#     print(source, '\\n', replace, '\\n', target)", "\n", "#     quit()", "\n", "", "return", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.padSeqs": [[47, 100], ["len", "numpy.max", "tuple", "enumerate", "hasattr", "ValueError", "lengths.append", "numpy.asarray", "hasattr", "ValueError", "len", "min", "len", "len", "print", "ValueError", "numpy.ones", "ValueError", "ValueError", "str", "numpy.asarray", "len", "len"], "function", ["None"], ["", "def", "padSeqs", "(", "sequences", ",", "maxlen", "=", "None", ",", "truncated", "=", "False", ",", "fixed_length", "=", "False", ",", "\n", "pad_method", "=", "'post'", ",", "trunc_method", "=", "'pre'", ",", "dtype", "=", "'int32'", ",", "value", "=", "0.", ")", ":", "\n", "    ", "if", "not", "hasattr", "(", "sequences", ",", "'__len__'", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'`sequences` must be iterable.'", ")", "\n", "", "lengths", "=", "[", "]", "\n", "for", "x", "in", "sequences", ":", "\n", "        ", "if", "not", "hasattr", "(", "x", ",", "'__len__'", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'`sequences` must be a list of iterables. '", "\n", "'Found non-iterable: '", "+", "str", "(", "x", ")", ")", "\n", "", "lengths", ".", "append", "(", "len", "(", "x", ")", ")", "\n", "\n", "", "num_samples", "=", "len", "(", "sequences", ")", "\n", "seq_maxlen", "=", "np", ".", "max", "(", "lengths", ")", "\n", "\n", "if", "maxlen", "is", "not", "None", "and", "fixed_length", ":", "\n", "        ", "maxlen", "=", "maxlen", "\n", "", "elif", "maxlen", "is", "not", "None", "and", "truncated", ":", "\n", "        ", "maxlen", "=", "min", "(", "seq_maxlen", ",", "maxlen", ")", "\n", "", "else", ":", "\n", "        ", "maxlen", "=", "seq_maxlen", "\n", "# take the sample shape from the first non empty sequence", "\n", "# checking for consistency in the main loop below.", "\n", "", "sample_shape", "=", "tuple", "(", ")", "\n", "for", "s", "in", "sequences", ":", "\n", "        ", "if", "len", "(", "s", ")", ">", "0", ":", "\n", "            ", "sample_shape", "=", "np", ".", "asarray", "(", "s", ")", ".", "shape", "[", "1", ":", "]", "\n", "break", "\n", "\n", "", "", "x", "=", "(", "np", ".", "ones", "(", "(", "num_samples", ",", "maxlen", ")", "+", "sample_shape", ")", "*", "value", ")", ".", "astype", "(", "dtype", ")", "\n", "for", "idx", ",", "s", "in", "enumerate", "(", "sequences", ")", ":", "\n", "        ", "if", "not", "len", "(", "s", ")", ":", "\n", "            ", "print", "(", "'empty list/array was found'", ")", "\n", "continue", "# empty list/array was found", "\n", "", "if", "trunc_method", "==", "'pre'", ":", "\n", "            ", "trunc", "=", "s", "[", "-", "maxlen", ":", "]", "\n", "", "elif", "trunc_method", "==", "'post'", ":", "\n", "            ", "trunc", "=", "s", "[", ":", "maxlen", "]", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Truncating type \"%s\" not understood'", "%", "trunc_method", ")", "\n", "\n", "# check `trunc` has expected shape", "\n", "", "trunc", "=", "np", ".", "asarray", "(", "trunc", ",", "dtype", "=", "dtype", ")", "\n", "if", "trunc", ".", "shape", "[", "1", ":", "]", "!=", "sample_shape", ":", "\n", "            ", "raise", "ValueError", "(", "'Shape of sample %s of sequence at position %s is different from expected shape %s'", "%", "\n", "(", "trunc", ".", "shape", "[", "1", ":", "]", ",", "idx", ",", "sample_shape", ")", ")", "\n", "\n", "", "if", "pad_method", "==", "'post'", ":", "\n", "            ", "x", "[", "idx", ",", ":", "len", "(", "trunc", ")", "]", "=", "trunc", "\n", "", "elif", "pad_method", "==", "'pre'", ":", "\n", "            ", "x", "[", "idx", ",", "-", "len", "(", "trunc", ")", ":", "]", "=", "trunc", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Padding type \"%s\" not understood'", "%", "pad_method", ")", "\n", "", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.position_encoding_init": [[102, 109], ["numpy.array", "numpy.sin", "numpy.cos", "numpy.zeros", "range", "numpy.power", "range"], "function", ["None"], ["", "def", "position_encoding_init", "(", "self", ",", "n_position", ",", "d_pos_vec", ")", ":", "\n", "    ", "position_enc", "=", "np", ".", "array", "(", "[", "[", "pos", "/", "np", ".", "power", "(", "10000", ",", "2", "*", "(", "j", "//", "2", ")", "/", "d_pos_vec", ")", "for", "j", "in", "range", "(", "d_pos_vec", ")", "]", "\n", "if", "pos", "!=", "0", "else", "np", ".", "zeros", "(", "d_pos_vec", ")", "for", "pos", "in", "range", "(", "n_position", ")", "]", ")", "\n", "\n", "position_enc", "[", "1", ":", ",", "0", ":", ":", "2", "]", "=", "np", ".", "sin", "(", "position_enc", "[", "1", ":", ",", "0", ":", ":", "2", "]", ")", "# dim 2i", "\n", "position_enc", "[", "1", ":", ",", "1", ":", ":", "2", "]", "=", "np", ".", "cos", "(", "position_enc", "[", "1", ":", ",", "1", ":", ":", "2", "]", ")", "# dim 2i+1", "\n", "return", "position_enc", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.__init__": [[14, 22], ["vocab.Vocab"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "train", ",", "self", ".", "dev", ",", "self", ".", "test", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "self", ".", "vocab", "=", "Vocab", "(", "cfg", ".", "vocab_size", ")", "\n", "self", ".", "result_file", "=", "''", "\n", "if", "cfg", ".", "use_act_slot_decoder", ":", "\n", "            ", "self", ".", "act_order", "=", "[", "'av'", ",", "'as'", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "act_order", "=", "[", "'av'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct": [[23, 30], ["NotImplementedError"], "methods", ["None"], ["", "", "def", "_construct", "(", "self", ",", "*", "args", ")", ":", "\n", "        ", "\"\"\"\n        load data, construct vocab and store them in self.train/dev/test\n        :param args:\n        :return:\n        \"\"\"", "\n", "raise", "NotImplementedError", "(", "'This is an abstract class, bro'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._bucket_by_turn": [[32, 46], ["len", "turn_bucket[].append"], "methods", ["None"], ["", "def", "_bucket_by_turn", "(", "self", ",", "encoded_data", ")", ":", "\n", "        ", "turn_bucket", "=", "{", "}", "\n", "for", "dial", "in", "encoded_data", ":", "\n", "            ", "turn_len", "=", "len", "(", "dial", ")", "\n", "if", "turn_len", "not", "in", "turn_bucket", ":", "\n", "                ", "turn_bucket", "[", "turn_len", "]", "=", "[", "]", "\n", "", "turn_bucket", "[", "turn_len", "]", ".", "append", "(", "dial", ")", "\n", "# del_l = []", "\n", "# for k in turn_bucket:", "\n", "#     if k >=5: del_l.append(k)", "\n", "#     logging.debug(\"bucket %d instance %d\" % (k,len(turn_bucket[k])))", "\n", "#for k in del_l:", "\n", "#    turn_bucket.pop(k)", "\n", "", "return", "turn_bucket", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._turn_bucket_to_batch": [[47, 61], ["batch.append", "len", "all_batches.append", "len", "len", "all_batches.append", "all_batches[].extend"], "methods", ["None"], ["", "def", "_turn_bucket_to_batch", "(", "self", ",", "data", ",", "batch_size", ")", ":", "\n", "        ", "all_batches", "=", "[", "]", "\n", "batch", "=", "[", "]", "\n", "for", "dial", "in", "data", ":", "\n", "            ", "batch", ".", "append", "(", "dial", ")", "\n", "if", "len", "(", "batch", ")", "==", "batch_size", ":", "\n", "                ", "all_batches", ".", "append", "(", "batch", ")", "\n", "batch", "=", "[", "]", "\n", "# if remainder > 1/2 batch_size, just put them in the previous batch, otherwise form a new batch", "\n", "", "", "if", "len", "(", "batch", ")", ">", "0.5", "*", "batch_size", ":", "\n", "            ", "all_batches", ".", "append", "(", "batch", ")", "\n", "", "elif", "len", "(", "all_batches", ")", ":", "\n", "            ", "all_batches", "[", "-", "1", "]", ".", "extend", "(", "batch", ")", "\n", "", "return", "all_batches", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches": [[62, 86], ["reader._ReaderBase._bucket_by_turn", "reader._ReaderBase._mark_batch_as_supervised", "reader._ReaderBase._turn_bucket_to_batch", "logging.info", "logging.info", "random.shuffle", "logging.info", "transposed_all_batches.append", "reader._ReaderBase._transpose_batch"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._bucket_by_turn", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._mark_batch_as_supervised", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._turn_bucket_to_batch", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._transpose_batch"], ["", "def", "_construct_batches", "(", "self", ",", "dial_data", ",", "set_name", ",", "batch_size", ")", ":", "\n", "        ", "while", "True", ":", "\n", "            ", "turn_bucket", "=", "self", ".", "_bucket_by_turn", "(", "dial_data", ")", "\n", "all_batches", "=", "[", "]", "\n", "for", "k", "in", "turn_bucket", ":", "\n", "                ", "batches", "=", "self", ".", "_turn_bucket_to_batch", "(", "turn_bucket", "[", "k", "]", ",", "batch_size", ")", "\n", "all_batches", "+=", "batches", "\n", "", "skip", "=", "True", "if", "set_name", "!=", "'train'", "else", "False", "\n", "_", ",", "sup_turn_num", ",", "total_turn_num", "=", "self", ".", "_mark_batch_as_supervised", "(", "all_batches", ",", "skip", ")", "\n", "real_spv_prop", "=", "sup_turn_num", "/", "total_turn_num", "\n", "exp_spv_prop", "=", "cfg", ".", "spv_proportion", "/", "100", "\n", "if", "set_name", "!=", "'train'", "or", "exp_spv_prop", "*", "0.9", "<=", "real_spv_prop", "<=", "exp_spv_prop", "*", "1.1", ":", "\n", "                ", "if", "set_name", "==", "'train'", ":", "\n", "                    ", "logging", ".", "info", "(", "'Exp spv proportion: {:.3f} True spv proportion: {:.3f}'", ".", "\n", "format", "(", "exp_spv_prop", ",", "real_spv_prop", ")", ")", "\n", "", "transposed_all_batches", "=", "[", "]", "\n", "for", "batch", "in", "all_batches", ":", "\n", "                    ", "transposed_all_batches", ".", "append", "(", "self", ".", "_transpose_batch", "(", "batch", ")", ")", "\n", "", "return", "transposed_all_batches", "\n", "", "else", ":", "\n", "                ", "logging", ".", "info", "(", "'Exp spv proportion: {:.3f} True spv proportion: {:.3f}'", ".", "\n", "format", "(", "exp_spv_prop", ",", "real_spv_prop", ")", ")", "\n", "logging", ".", "info", "(", "'Spv proportion bias higher than 10%: relabeling training data'", ")", "\n", "random", ".", "shuffle", "(", "dial_data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._mark_batch_as_supervised": [[87, 103], ["int", "enumerate", "len"], "methods", ["None"], ["", "", "", "def", "_mark_batch_as_supervised", "(", "self", ",", "all_batches", ",", "skip", "=", "False", ")", ":", "\n", "        ", "supervised_num", "=", "int", "(", "len", "(", "all_batches", ")", "*", "cfg", ".", "spv_proportion", "/", "100", ")", "\n", "sup_turn", ",", "total_turn", "=", "0", ",", "0", "\n", "for", "i", ",", "batch", "in", "enumerate", "(", "all_batches", ")", ":", "\n", "            ", "for", "dial", "in", "batch", ":", "\n", "                ", "for", "turn", "in", "dial", ":", "\n", "                    ", "if", "skip", ":", "\n", "                        ", "turn", "[", "'supervised'", "]", "=", "True", "\n", "", "else", ":", "\n", "                        ", "turn", "[", "'supervised'", "]", "=", "i", "<", "supervised_num", "\n", "# if not turn['supervised']:", "\n", "#     turn['db_vec'] = [0.] * cfg.db_vec_size # unsupervised learning. DB degree should be unknown", "\n", "", "if", "turn", "[", "'supervised'", "]", ":", "\n", "                        ", "sup_turn", "+=", "1", "\n", "", "total_turn", "+=", "1", "\n", "", "", "", "return", "all_batches", ",", "sup_turn", ",", "total_turn", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._transpose_batch": [[104, 117], ["len", "range", "dial_batch.append", "turn_l[].append"], "methods", ["None"], ["", "def", "_transpose_batch", "(", "self", ",", "batch", ")", ":", "\n", "        ", "dial_batch", "=", "[", "]", "\n", "turn_num", "=", "len", "(", "batch", "[", "0", "]", ")", "\n", "for", "turn", "in", "range", "(", "turn_num", ")", ":", "\n", "            ", "turn_l", "=", "{", "}", "\n", "for", "dial", "in", "batch", ":", "\n", "                ", "this_turn", "=", "dial", "[", "turn", "]", "\n", "for", "k", "in", "this_turn", ":", "\n", "                    ", "if", "k", "not", "in", "turn_l", ":", "\n", "                        ", "turn_l", "[", "k", "]", "=", "[", "]", "\n", "", "turn_l", "[", "k", "]", ".", "append", "(", "this_turn", "[", "k", "]", ")", "\n", "", "", "dial_batch", ".", "append", "(", "turn_l", ")", "\n", "", "return", "dial_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.inverse_transpose_batch": [[118, 140], ["len", "enumerate", "range", "turn_batch.items", "dialogs[].append", "reader._ReaderBase.db.pointerBack"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.pointerBack"], ["", "def", "inverse_transpose_batch", "(", "self", ",", "turn_batch_list", ")", ":", "\n", "        ", "\"\"\"\n        :param turn_batch_list: list of transpose dial batch\n        \"\"\"", "\n", "dialogs", "=", "{", "}", "\n", "total_turn_num", "=", "len", "(", "turn_batch_list", ")", "\n", "# initialize", "\n", "for", "idx_in_batch", ",", "dial_id", "in", "enumerate", "(", "turn_batch_list", "[", "0", "]", "[", "'dial_id'", "]", ")", ":", "\n", "            ", "dialogs", "[", "dial_id", "]", "=", "[", "]", "\n", "for", "turn_n", "in", "range", "(", "total_turn_num", ")", ":", "\n", "                ", "dial_turn", "=", "{", "}", "\n", "turn_batch", "=", "turn_batch_list", "[", "turn_n", "]", "\n", "for", "key", ",", "v_list", "in", "turn_batch", ".", "items", "(", ")", ":", "\n", "                    ", "if", "key", "==", "'dial_id'", ":", "\n", "                        ", "continue", "\n", "", "value", "=", "v_list", "[", "idx_in_batch", "]", "\n", "if", "cfg", ".", "dataset", "==", "'multiwoz'", "and", "key", "==", "'db_vec'", ":", "\n", "                        ", "turn_domain", "=", "turn_batch", "[", "'dom'", "]", "[", "idx_in_batch", "]", "[", "-", "1", "]", "\n", "value", "=", "self", ".", "db", ".", "pointerBack", "(", "value", ",", "turn_domain", ")", "\n", "", "dial_turn", "[", "key", "]", "=", "value", "\n", "", "dialogs", "[", "dial_id", "]", ".", "append", "(", "dial_turn", ")", "\n", "", "", "return", "dialogs", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.save_result": [[142, 151], ["open", "csv.DictWriter", "csv.DictWriter.writeheader", "csv.DictWriter.writerows", "rf.write"], "methods", ["None"], ["", "def", "save_result", "(", "self", ",", "write_mode", ",", "results", ",", "field", ",", "write_title", "=", "False", ",", "result_save_path", "=", "None", ")", ":", "\n", "        ", "path", "=", "cfg", ".", "result_path", "if", "result_save_path", "is", "None", "else", "result_save_path", "\n", "with", "open", "(", "path", ",", "write_mode", ")", "as", "rf", ":", "\n", "            ", "if", "write_title", ":", "\n", "                ", "rf", ".", "write", "(", "write_title", "+", "'\\n'", ")", "\n", "", "writer", "=", "csv", ".", "DictWriter", "(", "rf", ",", "fieldnames", "=", "field", ")", "\n", "writer", ".", "writeheader", "(", ")", "\n", "writer", ".", "writerows", "(", "results", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.save_loss": [[152, 163], ["os.path.join", "open", "csv.writer", "csv.writer.writerow", "csv.writer.writerow", "csv.writer.writerow", "csv.writer.writerow", "list", "range", "len"], "methods", ["None"], ["", "def", "save_loss", "(", "self", ",", "train_loss", ",", "valid_loss", ",", "events", ",", "file_name", "=", "'loss.csv'", ")", ":", "\n", "        ", "path", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "exp_path", ",", "file_name", ")", "\n", "with", "open", "(", "path", ",", "'w'", ")", "as", "rf", ":", "\n", "            ", "writer", "=", "csv", ".", "writer", "(", "rf", ")", "\n", "writer", ".", "writerow", "(", "[", "'epoch'", "]", "+", "list", "(", "range", "(", "len", "(", "train_loss", ")", ")", ")", ")", "\n", "for", "k", "in", "train_loss", "[", "0", "]", ":", "\n", "                ", "writer", ".", "writerow", "(", "[", "'train_'", "+", "k", "]", "+", "[", "i", "[", "k", "]", "for", "i", "in", "train_loss", "]", ")", "\n", "", "for", "k", "in", "valid_loss", "[", "0", "]", ":", "\n", "                ", "writer", ".", "writerow", "(", "[", "'valid_'", "+", "k", "]", "+", "[", "i", "[", "k", "]", "for", "i", "in", "valid_loss", "]", ")", "\n", "", "writer", ".", "writerow", "(", "[", "'events'", "]", "+", "events", ")", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.wrap_result": [[165, 253], ["result_dict.items", "enumerate", "results.append", "enumerate", "decode_fn().strip", "decode_fn().split", "enumerate", "decode_fn", "decode_fn", "turn.get", "temp.append", "decode_fn().split", "decode_fn().split", "enumerate", "decode_fn", "temp.append", "decode_fn", "decode_fn", "temp.append"], "methods", ["None"], ["", "def", "wrap_result", "(", "self", ",", "result_dict", ",", "eos_syntax", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        wrap generated results\n        :param gen_z:\n        :param gen_m:\n        :param turn_batch: dict of [i_1,i_2,...,i_b] with keys\n        :return:\n        \"\"\"", "\n", "results", "=", "[", "]", "\n", "if", "eos_syntax", "is", "None", ":", "\n", "            ", "eos_syntax", "=", "self", ".", "otlg", ".", "eos_syntax", "\n", "", "decode_fn", "=", "self", ".", "vocab", ".", "sentence_decode", "\n", "\n", "if", "cfg", ".", "dataset", "==", "'camrest'", ":", "\n", "            ", "field", "=", "[", "'dial_id'", ",", "'turn'", ",", "'user'", ",", "'bspn_gen'", ",", "'bspn'", ",", "'aspn_gen'", ",", "'aspn'", ",", "'resp_gen'", ",", "'resp'", ",", "'db_gen'", ",", "'db_match'", "]", "\n", "", "elif", "cfg", ".", "dataset", "==", "'multiwoz'", ":", "\n", "            ", "field", "=", "[", "'dial_id'", ",", "'turn'", ",", "'user'", ",", "'bspn_gen'", ",", "'bspn'", ",", "'aspn_gen'", ",", "'aspn'", ",", "'resp_gen'", ",", "'resp'", ",", "'dom_gen'", ",", "'dom'", ",", "\n", "'db_gen'", ",", "'db_match'", ",", "'db_vec'", "]", "\n", "", "elif", "cfg", ".", "dataset", "==", "'kvret'", ":", "\n", "            ", "field", "=", "[", "'dial_id'", ",", "'turn'", ",", "'user'", ",", "'bspn_gen'", ",", "'bspn'", ",", "'resp_gen'", ",", "'resp'", ",", "'db_gen'", ",", "'db_match'", "]", "\n", "", "results", "=", "[", "]", "\n", "for", "dial_id", ",", "turns", "in", "result_dict", ".", "items", "(", ")", ":", "\n", "# entry = {'dial_id': dial_id, 'turn': len(turns)}", "\n", "# for prop in field[2:]:", "\n", "#     entry[prop] = ''", "\n", "# results.append(entry)", "\n", "            ", "for", "turn_no", ",", "turn", "in", "enumerate", "(", "turns", ")", ":", "\n", "                ", "entry", "=", "{", "'dial_id'", ":", "dial_id", "}", "\n", "for", "key", "in", "field", ":", "\n", "                    ", "if", "key", "in", "[", "'dial_id'", "]", ":", "\n", "                        ", "continue", "\n", "", "if", "key", "==", "'bspn'", ":", "\n", "\n", "                        ", "constraint", "=", "{", "}", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "                            ", "v", "=", "turn", "[", "key", "]", "[", "sn", "]", "\n", "constraint", "[", "sn", "]", "=", "decode_fn", "(", "v", ",", "eos", "=", "self", ".", "otlg", ".", "z_eos_map", "[", "sn", "]", ")", ".", "strip", "(", ")", "\n", "if", "constraint", "[", "sn", "]", "==", "''", ":", "\n", "                                ", "del", "constraint", "[", "sn", "]", "\n", "", "", "entry", "[", "key", "]", "=", "constraint", "\n", "# entry[key] = decode_fn(turn[key]['food'], eos=eos_syntax[key])", "\n", "", "elif", "key", "==", "'bspn_gen'", ":", "\n", "                        ", "constraint", "=", "{", "}", "\n", "idx_list", "=", "decode_fn", "(", "turn", "[", "key", "]", ",", "eos", "=", "None", ")", ".", "split", "(", ")", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "                            ", "b", ",", "e", "=", "si", "*", "cfg", ".", "z_length", ",", "(", "si", "+", "1", ")", "*", "cfg", ".", "z_length", "\n", "temp", "=", "[", "]", "\n", "for", "s", "in", "idx_list", "[", "b", ":", "e", "]", ":", "\n", "                                ", "if", "s", "==", "self", ".", "otlg", ".", "z_eos_map", "[", "sn", "]", "or", "s", "==", "'<eos_b>'", ":", "\n", "                                    ", "break", "\n", "# if s == 'moderately':", "\n", "#     print('covert moderately to moderate')", "\n", "#     s = 'moderate'", "\n", "# if s not in temp and s in self.otlg.slot_value_mask[sn] and s != '<pad>' and s != 'the':", "\n", "", "if", "s", "not", "in", "temp", ":", "# delete repeated words", "\n", "                                    ", "temp", ".", "append", "(", "s", ")", "\n", "", "", "if", "temp", ":", "\n", "                                ", "constraint", "[", "sn", "]", "=", "' '", ".", "join", "(", "temp", ")", ".", "strip", "(", ")", "\n", "# temp.append('|')", "\n", "# entry[key] = ' '.join(temp[:-1]).strip()", "\n", "", "", "entry", "[", "key", "]", "=", "constraint", "\n", "# entry[key] = decode_fn(turn[key], eos=eos_syntax[key])", "\n", "", "elif", "key", "==", "'aspn'", ":", "\n", "                        ", "temp", "=", "[", "]", "\n", "for", "sn", "in", "self", ".", "act_order", ":", "\n", "                            ", "temp", "+=", "decode_fn", "(", "turn", "[", "key", "]", "[", "sn", "]", ",", "eos", "=", "'<eos_%s>'", "%", "sn", ")", ".", "split", "(", ")", "+", "[", "'|'", "]", "\n", "", "entry", "[", "key", "]", "=", "' '", ".", "join", "(", "temp", "[", ":", "-", "1", "]", ")", ".", "strip", "(", ")", "\n", "", "elif", "key", "==", "'aspn_gen'", ":", "\n", "                        ", "if", "key", "not", "in", "turn", ":", "\n", "                            ", "entry", "[", "key", "]", "=", "''", "\n", "", "else", ":", "\n", "                            ", "temp", "=", "[", "]", "\n", "idx_list", "=", "decode_fn", "(", "turn", "[", "key", "]", ",", "eos", "=", "None", ")", ".", "split", "(", ")", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "act_order", ")", ":", "\n", "                                ", "b", ",", "e", "=", "si", "*", "cfg", ".", "a_length", ",", "(", "si", "+", "1", ")", "*", "cfg", ".", "a_length", "\n", "for", "s", "in", "idx_list", "[", "b", ":", "e", "]", ":", "\n", "                                    ", "if", "s", "==", "'<eos_%s>'", "%", "sn", ":", "\n", "                                        ", "break", "\n", "", "if", "s", "not", "in", "temp", ":", "# delete repeated words", "\n", "                                        ", "temp", ".", "append", "(", "s", ")", "\n", "", "", "temp", ".", "append", "(", "'|'", ")", "\n", "", "entry", "[", "key", "]", "=", "' '", ".", "join", "(", "temp", "[", ":", "-", "1", "]", ")", ".", "strip", "(", ")", "\n", "", "", "else", ":", "\n", "                        ", "v", "=", "turn", ".", "get", "(", "key", ",", "''", ")", "\n", "entry", "[", "key", "]", "=", "decode_fn", "(", "v", ",", "eos", "=", "eos_syntax", "[", "key", "]", ")", "if", "key", "in", "eos_syntax", "and", "v", "!=", "''", "else", "v", "\n", "", "", "results", ".", "append", "(", "entry", ")", "\n", "# print(results[0:3])", "\n", "", "", "return", "results", ",", "field", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.get_glove_matrix": [[254, 303], ["numpy.average", "numpy.std", "vec_array.astype.astype.astype", "open.close", "logging.info", "open", "open.readlines", "open", "pickle.load", "pickle.load.items", "line.strip().split.strip().split.strip().split", "numpy.array", "reader._ReaderBase.vocab.encode", "numpy.array", "reader._ReaderBase.vocab.encode", "reader._ReaderBase.vocab.has_word", "numpy.average", "numpy.std", "reader._ReaderBase.vocab.has_word", "word.lower", "numpy.average", "numpy.std", "line.strip().split.strip().split.strip", "word.lower"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.has_word", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.has_word"], ["", "def", "get_glove_matrix", "(", "self", ",", "glove_path", ",", "initial_embedding_np", ")", ":", "\n", "        ", "\"\"\"\n        return a glove embedding matrix\n        :param self:\n        :param glove_file:\n        :param initial_embedding_np:\n        :return: np array of [V,E]\n        \"\"\"", "\n", "\n", "cnt", "=", "0", "\n", "vec_array", "=", "initial_embedding_np", "\n", "old_avg", "=", "np", ".", "average", "(", "vec_array", ")", "\n", "old_std", "=", "np", ".", "std", "(", "vec_array", ")", "\n", "vec_array", "=", "vec_array", ".", "astype", "(", "np", ".", "float32", ")", "\n", "new_avg", ",", "new_std", "=", "0", ",", "0", "\n", "\n", "if", "'glove'", "in", "glove_path", ":", "\n", "            ", "ef", "=", "open", "(", "glove_path", ",", "'r'", ",", "encoding", "=", "'UTF-8'", ")", "\n", "for", "line", "in", "ef", ".", "readlines", "(", ")", ":", "\n", "                ", "line", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "word", ",", "vec", "=", "line", "[", "0", "]", ",", "line", "[", "1", ":", "]", "\n", "vec", "=", "np", ".", "array", "(", "vec", ",", "np", ".", "float32", ")", "\n", "if", "not", "self", ".", "vocab", ".", "has_word", "(", "word", ")", ":", "\n", "                    ", "continue", "\n", "", "word_idx", "=", "self", ".", "vocab", ".", "encode", "(", "word", ")", "\n", "if", "word_idx", "<", "self", ".", "vocab", ".", "vocab_size", ":", "\n", "                    ", "cnt", "+=", "1", "\n", "vec_array", "[", "word_idx", "]", "=", "vec", "\n", "new_avg", "+=", "np", ".", "average", "(", "vec", ")", "\n", "new_std", "+=", "np", ".", "std", "(", "vec", ")", "\n", "", "", "new_avg", "/=", "cnt", "\n", "new_std", "/=", "cnt", "\n", "", "else", ":", "\n", "            ", "ef", "=", "open", "(", "glove_path", ",", "'rb'", ")", "\n", "emb_mat", "=", "pickle", ".", "load", "(", "ef", ")", "\n", "for", "word", ",", "vec", "in", "emb_mat", ".", "items", "(", ")", ":", "\n", "                ", "vec", "=", "np", ".", "array", "(", "vec", ",", "np", ".", "float32", ")", "\n", "if", "not", "self", ".", "vocab", ".", "has_word", "(", "word", ".", "lower", "(", ")", ")", ":", "\n", "                    ", "continue", "\n", "", "word_idx", "=", "self", ".", "vocab", ".", "encode", "(", "word", ".", "lower", "(", ")", ")", "\n", "if", "word_idx", "<", "self", ".", "vocab", ".", "vocab_size", ":", "\n", "                    ", "cnt", "+=", "1", "\n", "vec_array", "[", "word_idx", "]", "=", "vec", "\n", "new_avg", "+=", "np", ".", "average", "(", "vec", ")", "\n", "new_std", "+=", "np", ".", "std", "(", "vec", ")", "\n", "", "", "", "ef", ".", "close", "(", ")", "\n", "logging", ".", "info", "(", "'%d known embedding. old mean: %f new mean %f, old std %f new std %f'", "%", "(", "\n", "cnt", ",", "old_avg", ",", "new_avg", ",", "old_std", ",", "new_std", ")", ")", "\n", "return", "vec_array", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_dict_to_indicator": [[304, 314], ["reader._ReaderBase.vocab.decode", "indicator.append", "indicator.append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.decode"], ["", "def", "cons_dict_to_indicator", "(", "self", ",", "constraint", ")", ":", "\n", "        ", "indicator", "=", "[", "]", "\n", "for", "k", "in", "self", ".", "otlg", ".", "informable_slots", ":", "\n", "            ", "eos", "=", "self", ".", "otlg", ".", "z_eos_map", "[", "k", "]", "\n", "cons_1st_widx", "=", "constraint", "[", "k", "]", "[", "0", "]", "\n", "if", "eos", "==", "self", ".", "vocab", ".", "decode", "(", "cons_1st_widx", ")", ":", "\n", "                ", "indicator", ".", "append", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "indicator", ".", "append", "(", "1", ")", "\n", "", "", "return", "indicator", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_tensors_to_indicator": [[315, 328], ["numpy.array", "enumerate", "indicators.append", "reader._ReaderBase.vocab.decode", "indicator.append", "indicator.append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.decode"], ["", "def", "cons_tensors_to_indicator", "(", "self", ",", "z_samples", ")", ":", "\n", "        ", "indicators", "=", "[", "]", "\n", "for", "z_sample", "in", "z_samples", ":", "\n", "            ", "indicator", "=", "[", "]", "\n", "for", "si", ",", "sn", "in", "enumerate", "(", "self", ".", "otlg", ".", "informable_slots", ")", ":", "\n", "                ", "eos", "=", "self", ".", "otlg", ".", "z_eos_map", "[", "sn", "]", "\n", "b", "=", "si", "*", "cfg", ".", "z_length", "\n", "if", "eos", "==", "self", ".", "vocab", ".", "decode", "(", "z_sample", "[", "b", "]", ")", ":", "\n", "                    ", "indicator", ".", "append", "(", "-", "1", ")", "\n", "", "else", ":", "\n", "                    ", "indicator", ".", "append", "(", "1", ")", "\n", "", "", "indicators", ".", "append", "(", "indicator", ")", "\n", "", "return", "np", ".", "array", "(", "indicators", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.CamRest676Reader.__init__": [[331, 339], ["reader._ReaderBase.__init__", "datasets.CamRest676", "reader.CamRest676Reader._construct", "reader.CamRest676Reader.otlg.covert_mask_words_to_idx"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._construct", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.ontologies.Ontology.covert_mask_words_to_idx"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dataset", "=", "CamRest676", "(", ")", "\n", "self", ".", "db", "=", "self", ".", "dataset", ".", "db", "\n", "self", ".", "otlg", "=", "self", ".", "dataset", ".", "otlg", "\n", "# self.otlg = CamRest676Ontology(cfg.ontology_path)", "\n", "self", ".", "_construct", "(", ")", "\n", "self", ".", "slot_value_mask", "=", "self", ".", "otlg", ".", "covert_mask_words_to_idx", "(", "self", ".", "vocab", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.CamRest676Reader._construct": [[342, 360], ["reader.CamRest676Reader.vocab.load_vocab", "reader.CamRest676Reader._get_encoded_data", "reader.CamRest676Reader._split_data", "random.shuffle", "reader.CamRest676Reader._construct_batches", "reader.CamRest676Reader._construct_batches", "reader.CamRest676Reader._construct_batches", "reader.CamRest676Reader.dataset.preprocess_data", "json.loads", "os.path.exists", "os.path.exists", "open().read().lower", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.load_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._get_encoded_data", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.CamRest676Reader._split_data", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.preprocess_data"], ["", "def", "_construct", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        construct encoded train, dev, test set.\n        \"\"\"", "\n", "vocab_path", "=", "cfg", ".", "dataset_path", "+", "'vocab.word2idx.json'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "dataset", ".", "data_path", ")", "or", "not", "os", ".", "path", ".", "exists", "(", "vocab_path", ")", ":", "\n", "            ", "self", ".", "data", "=", "self", ".", "dataset", ".", "preprocess_data", "(", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "data", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "dataset", ".", "data_path", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "", "self", ".", "vocab", ".", "load_vocab", "(", "cfg", ".", "vocab_path", ")", "\n", "\n", "encoded_data", "=", "self", ".", "_get_encoded_data", "(", "self", ".", "data", ")", "\n", "self", ".", "train", ",", "self", ".", "dev", ",", "self", ".", "test", "=", "self", ".", "_split_data", "(", "encoded_data", ",", "cfg", ".", "split", ")", "\n", "random", ".", "shuffle", "(", "self", ".", "train", ")", "\n", "self", ".", "train_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "train", ",", "'train'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "dev_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "dev", ",", "'dev'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "test_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "test", ",", "'test'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "batches", "=", "{", "'train'", ":", "self", ".", "train_batch", ",", "'dev'", ":", "self", ".", "dev_batch", ",", "'test'", ":", "self", ".", "test_batch", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.CamRest676Reader._get_encoded_data": [[362, 405], ["data.items", "encoded_data.append", "reader.CamRest676Reader.vocab.sentence_encode", "reader.CamRest676Reader.vocab.sentence_encode", "json.loads", "reader.CamRest676Reader.dataset.degree_vec_mapping", "reader.CamRest676Reader.vocab.sentence_encode", "reader.CamRest676Reader.vocab.sentence_encode", "encoded_dial.append", "reader.CamRest676Reader.vocab.sentence_encode", "turn[].split", "turn[].split", "turn[].split", "turn[].split", "reader.CamRest676Reader.cons_dict_to_indicator", "len", "len"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.degree_vec_mapping", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_dict_to_indicator"], ["", "def", "_get_encoded_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "encoded_data", "=", "[", "]", "\n", "\n", "for", "dial_id", ",", "dial", "in", "data", ".", "items", "(", ")", ":", "\n", "            ", "encoded_dial", "=", "[", "]", "\n", "prev_response", "=", "[", "]", "\n", "\n", "for", "turn", "in", "dial", "[", "'log'", "]", ":", "\n", "                ", "user", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'user'", "]", ".", "split", "(", ")", "+", "[", "'<eos_u>'", "]", ")", "\n", "response", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'response'", "]", ".", "split", "(", ")", "+", "[", "'<eos_r>'", "]", ")", "\n", "constraint", "=", "json", ".", "loads", "(", "turn", "[", "'constraint'", "]", ")", "\n", "# cons = {'food': [], 'pricerange': [], 'area':[]}", "\n", "# for k,v in constraint.items():", "\n", "#     constraint[k] = self.vocab.sentence_encode(v + [self.otlg.z_eos_map[k]])", "\n", "# cons['food'].extend(self.vocab.sentence_encode(v))", "\n", "# constraint[k] = self.vocab.sentence_encode(v + ['<eos_b>'])", "\n", "# cons['food'].append(5)", "\n", "# cons['pricerange'].append(5)", "\n", "# cons['area'].append(5)", "\n", "cons", "=", "{", "}", "\n", "for", "k", "in", "self", ".", "otlg", ".", "informable_slots", ":", "\n", "                    ", "cons", "[", "k", "]", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "constraint", "[", "k", "]", "+", "[", "self", ".", "otlg", ".", "z_eos_map", "[", "k", "]", "]", ")", "\n", "", "db_vec", "=", "self", ".", "dataset", ".", "degree_vec_mapping", "(", "turn", "[", "'db_match'", "]", ")", "\n", "turn_num", "=", "turn", "[", "'turn'", "]", "\n", "sys_offer_value", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'user_request'", "]", ".", "split", "(", ")", "+", "[", "'<eos_av>'", "]", ")", "\n", "sys_ask_slot", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'sys_request'", "]", ".", "split", "(", ")", "+", "[", "'<eos_as>'", "]", ")", "\n", "# final input", "\n", "encoded_dial", ".", "append", "(", "{", "\n", "'dial_id'", ":", "dial_id", ",", "\n", "'turn'", ":", "turn_num", ",", "\n", "'user'", ":", "prev_response", "+", "user", ",", "\n", "'resp'", ":", "response", ",", "\n", "'bspn'", ":", "cons", ",", "\n", "'filling_vec'", ":", "self", ".", "cons_dict_to_indicator", "(", "cons", ")", ",", "\n", "'aspn'", ":", "{", "'av'", ":", "sys_offer_value", ",", "'as'", ":", "sys_ask_slot", "}", ",", "\n", "'u_len'", ":", "len", "(", "prev_response", "+", "user", ")", ",", "\n", "'m_len'", ":", "len", "(", "response", ")", ",", "\n", "'db_vec'", ":", "db_vec", ",", "\n", "'db_match'", ":", "turn", "[", "'db_match'", "]", "\n", "}", ")", "\n", "prev_response", "=", "response", "\n", "", "encoded_data", ".", "append", "(", "encoded_dial", ")", "\n", "", "return", "encoded_data", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.CamRest676Reader._split_data": [[406, 418], ["sum", "len", "len"], "methods", ["None"], ["", "def", "_split_data", "(", "self", ",", "encoded_data", ",", "split", ")", ":", "\n", "        ", "\"\"\"\n        split data into train/dev/test\n        :param encoded_data: list\n        :param split: tuple / list\n        :return:\n        \"\"\"", "\n", "total", "=", "sum", "(", "split", ")", "\n", "dev_thr", "=", "len", "(", "encoded_data", ")", "*", "split", "[", "0", "]", "//", "total", "\n", "test_thr", "=", "len", "(", "encoded_data", ")", "*", "(", "split", "[", "0", "]", "+", "split", "[", "1", "]", ")", "//", "total", "\n", "train", ",", "dev", ",", "test", "=", "encoded_data", "[", ":", "dev_thr", "]", ",", "encoded_data", "[", "dev_thr", ":", "test_thr", "]", ",", "encoded_data", "[", "test_thr", ":", "]", "\n", "return", "train", ",", "dev", ",", "test", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.CamRest676Reader.save_result_report": [[419, 448], ["results[].items", "res.update", "res.update", "res.update", "os.path.exists", "open", "csv.DictWriter", "csv.DictWriter.writerows", "config.global_config.eval_load_path.split", "csv.DictWriter.writeheader", "list", "res.keys"], "methods", ["None"], ["", "def", "save_result_report", "(", "self", ",", "results", ",", "ctr_save_path", "=", "None", ")", ":", "\n", "        ", "ctr_save_path", "=", "cfg", ".", "global_record_path", "if", "ctr_save_path", "is", "None", "else", "ctr_save_path", "\n", "write_title", "=", "False", "if", "os", ".", "path", ".", "exists", "(", "ctr_save_path", ")", "else", "True", "\n", "\n", "unsup_prop", "=", "0", "if", "cfg", ".", "skip_unsup", "else", "100", "-", "cfg", ".", "spv_proportion", "\n", "exp", "=", "cfg", ".", "eval_load_path", ".", "split", "(", "'/'", ")", "[", "2", "]", "if", "'experiments/'", "in", "cfg", ".", "eval_load_path", "else", "cfg", ".", "eval_load_path", "\n", "res", "=", "{", "'exp'", ":", "exp", ",", "'labeled data %'", ":", "cfg", ".", "spv_proportion", ",", "'unlabeled data %'", ":", "unsup_prop", ",", "\n", "'bleu'", ":", "results", "[", "'bleu'", "]", ",", "'match'", ":", "results", "[", "'match'", "]", ",", "'joint_goal'", ":", "results", "[", "'joint_goal'", "]", ",", "'request f1'", ":", "results", "[", "'req_f1'", "]", ",", "\n", "'act value gen f1'", ":", "results", "[", "'value_pred_f1'", "]", ",", "'act slot pred f1'", ":", "results", "[", "'slot_pred_f1'", "]", "}", "\n", "for", "s", ",", "accu", "in", "results", "[", "'slot_accu'", "]", ".", "items", "(", ")", ":", "\n", "            ", "res", "[", "s", "]", "=", "accu", "\n", "", "res", ".", "update", "(", "{", "'db_acc'", ":", "results", "[", "'db_acc'", "]", ",", "'epoch_num'", ":", "results", "[", "'epoch_num'", "]", "}", ")", "\n", "res", ".", "update", "(", "{", "'slot_accu'", ":", "results", "[", "'slot_accu'", "]", ",", "'slot - p/r/f1'", ":", "results", "[", "'slot-p/r/f1'", "]", "}", ")", "\n", "res", ".", "update", "(", "{", "'act_verbose'", ":", "results", "[", "'act_verbose'", "]", "}", ")", "\n", "# if 'final_train_loss' in results:", "\n", "#     res.update({'train_sup_nll': results['final_train_loss'].get('sup_p_joint_nll', 0),", "\n", "#                         'valid_nll': results['best_valid_loss']['loss'],", "\n", "#                         'test_nll': results['test_loss']['loss'],", "\n", "#                         'train_sup_pm': results['final_train_loss'].get('sup_m_loss', 0),", "\n", "#                         'valid_pm': results['best_valid_loss']['m_loss'],", "\n", "#                         'test_pm': results['test_loss']['m_loss'],", "\n", "#                         'train_unsup_nll': results['final_train_loss'].get('unsup_p_joint_nll', 0),", "\n", "#                         'train_unsup_pm': results['final_train_loss'].get('unsup_m_loss', 0)})", "\n", "\n", "with", "open", "(", "ctr_save_path", ",", "'a'", ")", "as", "rf", ":", "\n", "            ", "writer", "=", "csv", ".", "DictWriter", "(", "rf", ",", "fieldnames", "=", "list", "(", "res", ".", "keys", "(", ")", ")", ")", "\n", "if", "write_title", ":", "\n", "                ", "writer", ".", "writeheader", "(", ")", "\n", "", "writer", ".", "writerows", "(", "[", "res", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.KvretReader.__init__": [[451, 457], ["reader._ReaderBase.__init__", "datasets.Kvret", "reader.KvretReader._construct"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._construct"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dataset", "=", "Kvret", "(", ")", "\n", "self", ".", "otlg", "=", "self", ".", "dataset", ".", "otlg", "\n", "# self.otlg = CamRest676Ontology(cfg.ontology_path)", "\n", "self", ".", "_construct", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.KvretReader._construct": [[460, 479], ["reader.KvretReader.vocab.load_vocab", "reader.KvretReader._get_encoded_data", "random.shuffle", "reader.KvretReader._construct_batches", "reader.KvretReader._construct_batches", "reader.KvretReader._construct_batches", "reader.KvretReader.dataset.preprocess_data", "json.loads", "os.path.exists", "os.path.exists", "open().read().lower", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.load_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._get_encoded_data", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.preprocess_data"], ["", "def", "_construct", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        construct encoded train, dev, test set.\n        \"\"\"", "\n", "self", ".", "data", "=", "{", "}", "\n", "vocab_path", "=", "cfg", ".", "dataset_path", "+", "'vocab.word2idx.json'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "self", ".", "dataset", ".", "data_path", "[", "'train'", "]", ")", "or", "not", "os", ".", "path", ".", "exists", "(", "vocab_path", ")", ":", "\n", "            ", "self", ".", "dataset", ".", "preprocess_data", "(", ")", "\n", "", "for", "d", "in", "[", "'train'", ",", "'dev'", ",", "'test'", "]", ":", "\n", "            ", "self", ".", "data", "[", "d", "]", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "dataset", ".", "data_path", "[", "d", "]", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "", "self", ".", "vocab", ".", "load_vocab", "(", "cfg", ".", "vocab_path", ")", "\n", "\n", "self", ".", "train", ",", "self", ".", "dev", ",", "self", ".", "test", "=", "self", ".", "_get_encoded_data", "(", "self", ".", "data", ")", "\n", "\n", "random", ".", "shuffle", "(", "self", ".", "train", ")", "\n", "self", ".", "train_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "train", ",", "'train'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "dev_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "dev", ",", "'dev'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "test_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "test", ",", "'test'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "batches", "=", "{", "'train'", ":", "self", ".", "train_batch", ",", "'dev'", ":", "self", ".", "dev_batch", ",", "'test'", ":", "self", ".", "test_batch", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.KvretReader._get_encoded_data": [[481, 515], ["data[].items", "data_mapping[].append", "reader.KvretReader.vocab.sentence_encode", "reader.KvretReader.vocab.sentence_encode", "json.loads", "encoded_dial.append", "turn[].split", "turn[].split", "reader.KvretReader.vocab.sentence_encode", "reader.KvretReader.vocab.sentence_encode", "reader.KvretReader.cons_dict_to_indicator", "numpy.array", "constraint[].split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_dict_to_indicator"], ["", "def", "_get_encoded_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "train", ",", "dev", ",", "test", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "data_mapping", "=", "{", "'train'", ":", "train", ",", "'dev'", ":", "dev", ",", "'test'", ":", "test", "}", "\n", "\n", "for", "data_type", "in", "data", ":", "\n", "\n", "            ", "for", "dial_id", ",", "dial", "in", "data", "[", "data_type", "]", ".", "items", "(", ")", ":", "\n", "                ", "encoded_dial", "=", "[", "]", "\n", "prev_response", "=", "[", "]", "\n", "\n", "for", "turn", "in", "dial", ":", "\n", "                    ", "user", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'user'", "]", ".", "split", "(", ")", "+", "[", "'<eos_u>'", "]", ")", "\n", "response", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'response'", "]", ".", "split", "(", ")", "+", "[", "'<eos_r>'", "]", ")", "\n", "constraint", "=", "json", ".", "loads", "(", "turn", "[", "'constraint'", "]", ")", "\n", "cons", "=", "{", "}", "\n", "for", "k", "in", "self", ".", "otlg", ".", "informable_slots", ":", "\n", "                        ", "if", "k", "in", "constraint", ":", "\n", "                            ", "cons", "[", "k", "]", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "constraint", "[", "k", "]", ".", "split", "(", ")", "+", "[", "self", ".", "otlg", ".", "z_eos_map", "[", "k", "]", "]", ")", "\n", "", "else", ":", "\n", "                            ", "cons", "[", "k", "]", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "[", "self", ".", "otlg", ".", "z_eos_map", "[", "k", "]", "]", ")", "\n", "# final input", "\n", "", "", "encoded_dial", ".", "append", "(", "{", "\n", "'dial_id'", ":", "dial_id", ",", "\n", "'turn'", ":", "turn", "[", "'turn_num'", "]", ",", "\n", "'user'", ":", "prev_response", "+", "user", ",", "\n", "'resp'", ":", "response", ",", "\n", "'bspn'", ":", "cons", ",", "\n", "'filling_vec'", ":", "self", ".", "cons_dict_to_indicator", "(", "cons", ")", ",", "\n", "'db_vec'", ":", "np", ".", "array", "(", "[", "0", "]", ")", ",", "\n", "'db_match'", ":", "0", ",", "\n", "}", ")", "\n", "prev_response", "=", "response", "\n", "", "data_mapping", "[", "data_type", "]", ".", "append", "(", "encoded_dial", ")", "\n", "", "", "return", "train", ",", "dev", ",", "test", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.KvretReader.save_result_report": [[517, 536], ["results[].items", "res.update", "res.update", "os.path.exists", "open", "csv.DictWriter", "csv.DictWriter.writerows", "config.global_config.eval_load_path.split", "csv.DictWriter.writeheader", "list", "res.keys"], "methods", ["None"], ["", "def", "save_result_report", "(", "self", ",", "results", ",", "ctr_save_path", "=", "None", ")", ":", "\n", "        ", "ctr_save_path", "=", "cfg", ".", "global_record_path", "if", "ctr_save_path", "is", "None", "else", "ctr_save_path", "\n", "write_title", "=", "False", "if", "os", ".", "path", ".", "exists", "(", "ctr_save_path", ")", "else", "True", "\n", "\n", "unsup_prop", "=", "0", "if", "cfg", ".", "skip_unsup", "else", "100", "-", "cfg", ".", "spv_proportion", "\n", "exp", "=", "cfg", ".", "eval_load_path", ".", "split", "(", "'/'", ")", "[", "2", "]", "if", "'experiments/'", "in", "cfg", ".", "eval_load_path", "else", "cfg", ".", "eval_load_path", "\n", "res", "=", "{", "'exp'", ":", "exp", ",", "'labeled data %'", ":", "cfg", ".", "spv_proportion", ",", "'unlabeled data %'", ":", "unsup_prop", ",", "\n", "'bleu'", ":", "results", "[", "'bleu'", "]", ",", "'match'", ":", "results", "[", "'match'", "]", ",", "'joint_goal'", ":", "results", "[", "'joint_goal'", "]", ",", "'request f1'", ":", "results", "[", "'req_f1'", "]", ",", "\n", "}", "\n", "for", "s", ",", "accu", "in", "results", "[", "'slot_accu'", "]", ".", "items", "(", ")", ":", "\n", "            ", "res", "[", "s", "]", "=", "accu", "\n", "", "res", ".", "update", "(", "{", "'db_acc'", ":", "results", "[", "'db_acc'", "]", ",", "'epoch_num'", ":", "results", "[", "'epoch_num'", "]", "}", ")", "\n", "res", ".", "update", "(", "{", "'slot_accu'", ":", "results", "[", "'slot_accu'", "]", ",", "'slot - p/r/f1'", ":", "results", "[", "'slot-p/r/f1'", "]", "}", ")", "\n", "\n", "with", "open", "(", "ctr_save_path", ",", "'a'", ")", "as", "rf", ":", "\n", "            ", "writer", "=", "csv", ".", "DictWriter", "(", "rf", ",", "fieldnames", "=", "list", "(", "res", ".", "keys", "(", ")", ")", ")", "\n", "if", "write_title", ":", "\n", "                ", "writer", ".", "writeheader", "(", ")", "\n", "", "writer", ".", "writerows", "(", "[", "res", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader.__init__": [[539, 542], ["reader._ReaderBase.__init__", "reader.MultiwozReader._construct"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._construct"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "_construct", "(", ")", "\n", "# self.slot_value_mask = self.otlg.covert_mask_words_to_idx(self.vocab)", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._construct": [[546, 570], ["os.path.join", "datasets.Multiwoz", "json.loads", "reader.MultiwozReader.vocab.load_vocab", "reader.MultiwozReader._get_encoded_data", "random.shuffle", "reader.MultiwozReader._construct_batches", "reader.MultiwozReader._construct_batches", "reader.MultiwozReader._construct_batches", "print", "multiwoz_preprocess.DataPreprocessor", "open().read().lower", "os.path.exists", "os.path.exists", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.load_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._get_encoded_data", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase._construct_batches"], ["", "def", "_construct", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        construct encoded train, dev, test set.\n        \"\"\"", "\n", "vocab_file", "=", "os", ".", "path", ".", "join", "(", "cfg", ".", "data_path", ",", "'vocab.word2idx.json'", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cfg", ".", "data_file", ")", "or", "not", "os", ".", "path", ".", "exists", "(", "vocab_file", ")", ":", "\n", "            ", "print", "(", "'Data preprocessing'", ")", "\n", "DataPreprocessor", "(", "do_analysis", "=", "True", ")", "\n", "\n", "", "self", ".", "dataset", "=", "Multiwoz", "(", ")", "\n", "self", ".", "db", "=", "self", ".", "dataset", ".", "db", "\n", "self", ".", "otlg", "=", "self", ".", "dataset", ".", "otlg", "\n", "\n", "self", ".", "data", "=", "json", ".", "loads", "(", "open", "(", "cfg", ".", "data_file", ",", "'r'", ",", "encoding", "=", "'utf-8'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "self", ".", "vocab", ".", "load_vocab", "(", "cfg", ".", "vocab_path", ")", "\n", "\n", "self", ".", "train", ",", "self", ".", "dev", ",", "self", ".", "test", "=", "self", ".", "_get_encoded_data", "(", "self", ".", "data", ")", "\n", "\n", "random", ".", "shuffle", "(", "self", ".", "train", ")", "\n", "self", ".", "train_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "train", ",", "'train'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "dev_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "dev", ",", "'dev'", ",", "cfg", ".", "batch_size", ")", "\n", "self", ".", "test_batch", "=", "self", ".", "_construct_batches", "(", "self", ".", "test", ",", "'test'", ",", "cfg", ".", "batch_size", ")", "\n", "# self.test_batch = self._construct_batches(self.test[:50], 'test', 8)", "\n", "self", ".", "batches", "=", "{", "'train'", ":", "self", ".", "train_batch", ",", "'dev'", ":", "self", ".", "dev_batch", ",", "'test'", ":", "self", ".", "test_batch", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader._get_encoded_data": [[572, 649], ["data.items", "l.strip().lower", "l.strip().lower", "open().readlines", "open().readlines", "reader.MultiwozReader.vocab.sentence_encode", "reader.MultiwozReader.vocab.sentence_encode", "json.loads", "reader.MultiwozReader.vocab.sentence_encode", "reader.MultiwozReader.vocab.sentence_encode", "encoded_dial.append", "test.append", "l.strip", "l.strip", "fn.replace", "fn.replace", "d_s.split", "reader.MultiwozReader.replace", "reader.MultiwozReader.vocab.sentence_encode", "len", "dev.append", "train.append", "open", "open", "turn[].split", "turn[].split", "reader.MultiwozReader.vocab.sentence_encode", "reader.MultiwozReader.vocab.sentence_encode", "turn[].split", "turn[].split", "reader.MultiwozReader.cons_dict_to_indicator", "len", "len", "reader.MultiwozReader.split", "int", "len", "len", "[].split", "turn[].split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader._ReaderBase.cons_dict_to_indicator"], ["", "def", "_get_encoded_data", "(", "self", ",", "data", ")", ":", "\n", "        ", "test_list", "=", "[", "l", ".", "strip", "(", ")", ".", "lower", "(", ")", "for", "l", "in", "open", "(", "cfg", ".", "test_list", ",", "'r'", ")", ".", "readlines", "(", ")", "]", "\n", "dev_list", "=", "[", "l", ".", "strip", "(", ")", ".", "lower", "(", ")", "for", "l", "in", "open", "(", "cfg", ".", "dev_list", ",", "'r'", ")", ".", "readlines", "(", ")", "]", "\n", "self", ".", "dev_files", ",", "self", ".", "test_files", "=", "{", "}", ",", "{", "}", "\n", "for", "fn", "in", "test_list", ":", "\n", "            ", "self", ".", "test_files", "[", "fn", ".", "replace", "(", "'.json'", ",", "''", ")", "]", "=", "1", "\n", "self", ".", "test_files", "[", "fn", "]", "=", "1", "\n", "", "for", "fn", "in", "dev_list", ":", "\n", "            ", "self", ".", "dev_files", "[", "fn", ".", "replace", "(", "'.json'", ",", "''", ")", "]", "=", "1", "\n", "self", ".", "dev_files", "[", "fn", "]", "=", "1", "\n", "\n", "", "train", ",", "dev", ",", "test", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "length", "=", "{", "}", "\n", "\n", "for", "dial_id", ",", "dial", "in", "data", ".", "items", "(", ")", ":", "\n", "            ", "encoded_dial", "=", "[", "]", "\n", "prev_response", "=", "''", "\n", "\n", "for", "turn", "in", "dial", "[", "'log'", "]", ":", "\n", "                ", "user", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'user'", "]", ".", "split", "(", ")", "+", "[", "'<eos_u>'", "]", ")", "\n", "response", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'resp'", "]", ".", "split", "(", ")", "+", "[", "'<eos_r>'", "]", ")", "\n", "constraint", "=", "json", ".", "loads", "(", "turn", "[", "'constraint'", "]", "[", "0", "]", ")", "\n", "cons", "=", "{", "}", "\n", "for", "d_s", "in", "self", ".", "otlg", ".", "informable_slots", ":", "\n", "                    ", "dom", ",", "slot", "=", "d_s", ".", "split", "(", "'-'", ")", "\n", "if", "dom", "in", "constraint", "and", "slot", "in", "constraint", "[", "dom", "]", ":", "\n", "                        ", "cons", "[", "d_s", "]", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "constraint", "[", "dom", "]", "[", "slot", "]", ".", "split", "(", ")", "+", "[", "self", ".", "otlg", ".", "z_eos_map", "[", "d_s", "]", "]", ")", "\n", "", "else", ":", "\n", "                        ", "cons", "[", "d_s", "]", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "[", "self", ".", "otlg", ".", "z_eos_map", "[", "d_s", "]", "]", ")", "\n", "", "", "sys_offer_value", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'sys_inform'", "]", ".", "split", "(", ")", "+", "[", "'<eos_av>'", "]", ")", "\n", "sys_ask_slot", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "turn", "[", "'sys_request'", "]", ".", "split", "(", ")", "+", "[", "'<eos_as>'", "]", ")", "\n", "\n", "if", "turn", "[", "'name_from_db'", "]", ":", "\n", "                    ", "prev_response", "=", "prev_response", ".", "replace", "(", "'[value_name]'", ",", "turn", "[", "'name_from_db'", "]", ")", "\n", "", "if", "prev_response", "!=", "''", ":", "\n", "                    ", "prev_response", "=", "self", ".", "vocab", ".", "sentence_encode", "(", "prev_response", ".", "split", "(", ")", "+", "[", "'<eos_r>'", "]", ")", "\n", "", "else", ":", "\n", "                    ", "prev_response", "=", "[", "]", "\n", "\n", "# final input", "\n", "", "encoded_dial", ".", "append", "(", "{", "\n", "'dial_id'", ":", "dial_id", ",", "\n", "'turn'", ":", "turn", "[", "'turn_num'", "]", ",", "\n", "'user'", ":", "prev_response", "+", "user", ",", "\n", "# 'pv_resp': prev_response,", "\n", "'resp'", ":", "response", ",", "\n", "'bspn'", ":", "cons", ",", "\n", "'filling_vec'", ":", "self", ".", "cons_dict_to_indicator", "(", "cons", ")", ",", "\n", "'aspn'", ":", "{", "'av'", ":", "sys_offer_value", ",", "'as'", ":", "sys_ask_slot", "}", ",", "\n", "'u_len'", ":", "len", "(", "prev_response", "+", "user", ")", ",", "\n", "'m_len'", ":", "len", "(", "response", ")", ",", "\n", "'db_vec'", ":", "[", "int", "(", "i", ")", "for", "i", "in", "turn", "[", "'pointer'", "]", ".", "split", "(", "','", ")", "]", ",", "\n", "'db_match'", ":", "turn", "[", "'match'", "]", ",", "\n", "'dom'", ":", "turn", "[", "'turn_domain'", "]", "\n", "}", ")", "\n", "prev_response", "=", "turn", "[", "'resp'", "]", "\n", "if", "len", "(", "turn", "[", "'user'", "]", ")", "not", "in", "length", ":", "\n", "                    ", "length", "[", "len", "(", "turn", "[", "'user'", "]", ")", "]", "=", "1", "\n", "", "else", ":", "\n", "                    ", "length", "[", "len", "(", "turn", "[", "'user'", "]", ")", "]", "+=", "1", "\n", "", "", "if", "dial_id", "in", "self", ".", "test_files", ":", "\n", "                ", "test", ".", "append", "(", "encoded_dial", ")", "\n", "", "elif", "dial_id", "in", "self", ".", "dev_files", ":", "\n", "                ", "dev", ".", "append", "(", "encoded_dial", ")", "\n", "", "else", ":", "\n", "                ", "train", ".", "append", "(", "encoded_dial", ")", "\n", "# length = dict(sorted(length.items(), key=lambda kv:kv[0], reverse=True))", "\n", "# small, large=0,0", "\n", "# for k,v in length.items():", "\n", "#     if k<80:", "\n", "#         small += v", "\n", "#     else:", "\n", "#         large += v", "\n", "# print(small, large)", "\n", "# quit()", "\n", "", "", "return", "train", ",", "dev", ",", "test", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.reader.MultiwozReader.save_result_report": [[650, 672], ["results[].items", "res.update", "res.update", "res.update", "os.path.exists", "open", "csv.DictWriter", "csv.DictWriter.writerows", "config.global_config.eval_load_path.split", "csv.DictWriter.writeheader", "list", "res.keys"], "methods", ["None"], ["", "def", "save_result_report", "(", "self", ",", "results", ",", "ctr_save_path", "=", "None", ")", ":", "\n", "        ", "ctr_save_path", "=", "cfg", ".", "global_record_path", "if", "ctr_save_path", "is", "None", "else", "ctr_save_path", "\n", "write_title", "=", "False", "if", "os", ".", "path", ".", "exists", "(", "ctr_save_path", ")", "else", "True", "\n", "\n", "unsup_prop", "=", "0", "if", "cfg", ".", "skip_unsup", "else", "100", "-", "cfg", ".", "spv_proportion", "\n", "exp", "=", "cfg", ".", "eval_load_path", ".", "split", "(", "'/'", ")", "[", "2", "]", "if", "'experiments/'", "in", "cfg", ".", "eval_load_path", "else", "cfg", ".", "eval_load_path", "\n", "res", "=", "{", "'exp'", ":", "exp", ",", "'labeled data %'", ":", "cfg", ".", "spv_proportion", ",", "'unlabeled data %'", ":", "unsup_prop", ",", "\n", "'bleu'", ":", "results", "[", "'bleu'", "]", ",", "'match'", ":", "results", "[", "'match'", "]", ",", "'success'", ":", "results", "[", "'success'", "]", ",", "\n", "'joint_goal'", ":", "results", "[", "'joint_goal'", "]", ",", "\n", "# 'domain': results['dom'],", "\n", "'act value gen f1'", ":", "results", "[", "'value_pred_f1'", "]", ",", "'act slot pred f1'", ":", "results", "[", "'slot_pred_f1'", "]", "}", "\n", "for", "s", ",", "accu", "in", "results", "[", "'slot_accu'", "]", ".", "items", "(", ")", ":", "\n", "            ", "res", "[", "s", "]", "=", "accu", "\n", "", "res", ".", "update", "(", "{", "'db_acc'", ":", "results", "[", "'db_acc'", "]", ",", "'epoch_num'", ":", "results", "[", "'epoch_num'", "]", "}", ")", "\n", "res", ".", "update", "(", "{", "'slot_accu'", ":", "results", "[", "'slot_accu'", "]", ",", "'slot - p/r/f1'", ":", "results", "[", "'slot-p/r/f1'", "]", "}", ")", "\n", "res", ".", "update", "(", "{", "'act_verbose'", ":", "results", "[", "'act_verbose'", "]", "}", ")", "\n", "\n", "with", "open", "(", "ctr_save_path", ",", "'a'", ")", "as", "rf", ":", "\n", "            ", "writer", "=", "csv", ".", "DictWriter", "(", "rf", ",", "fieldnames", "=", "list", "(", "res", ".", "keys", "(", ")", ")", ")", "\n", "if", "write_title", ":", "\n", "                ", "writer", ".", "writeheader", "(", ")", "\n", "", "writer", ".", "writerows", "(", "[", "res", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Dataset.__init__": [[15, 18], ["nltk.stem.WordNetLemmatizer"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "word_tokenize", "=", "nltk_word_tokenize", "\n", "self", ".", "wn", "=", "WordNetLemmatizer", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.__init__": [[20, 43], ["datasets.Dataset.__init__", "ontologies.CamRest676Ontology", "os.path.join", "config.global_config.db.replace", "json.loads", "sqlite3.connect().cursor", "datasets.CamRest676.get_value_to_slot_mapping", "open().read().lower", "os.path.exists", "datasets.CamRest676._db_construct", "sqlite3.connect", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.get_value_to_slot_mapping", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676._db_construct"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dataset_path", "=", "cfg", ".", "dataset_path", "\n", "self", ".", "raw_data_path", "=", "cfg", ".", "raw_data", "\n", "self", ".", "otlg", "=", "CamRest676Ontology", "(", "cfg", ".", "ontology_path", ")", "\n", "self", ".", "requestable_slots", "=", "self", ".", "otlg", ".", "requestable_slots", "\n", "self", ".", "informable_slots", "=", "self", ".", "otlg", ".", "informable_slots", "\n", "\n", "self", ".", "data_path", "=", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "\n", "# 'CamRest676_preprocessed_add_dontcare_330.json')", "\n", "# 'CamRest676_preprocessed_add_dontcare_41.json')", "\n", "'CamRest676_preprocessed_add_request_47.json'", ")", "\n", "\n", "db_json_path", "=", "cfg", ".", "db", ".", "replace", "(", "'.db'", ",", "'.json'", ")", "\n", "self", ".", "db_json", "=", "json", ".", "loads", "(", "open", "(", "db_json_path", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "cfg", ".", "db", ")", ":", "\n", "            ", "self", ".", "_db_construct", "(", "cfg", ".", "db", ")", "\n", "", "self", ".", "db", "=", "sql", ".", "connect", "(", "cfg", ".", "db", ")", ".", "cursor", "(", ")", "\n", "self", ".", "v_to_s", "=", "self", ".", "get_value_to_slot_mapping", "(", "cfg", ".", "ontology_path", ")", "\n", "\n", "\n", "self", ".", "db_vec_size", "=", "cfg", ".", "db_vec_size", "\n", "self", ".", "z_length", "=", "cfg", ".", "z_length", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.get_value_to_slot_mapping": [[45, 52], ["json.loads", "otlg_json[].items", "open().read().lower", "open().read", "open"], "methods", ["None"], ["", "def", "get_value_to_slot_mapping", "(", "self", ",", "save_dir", ")", ":", "\n", "        ", "v_to_s", "=", "{", "}", "\n", "otlg_json", "=", "json", ".", "loads", "(", "open", "(", "save_dir", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "for", "slot", ",", "values", "in", "otlg_json", "[", "'informable'", "]", ".", "items", "(", ")", ":", "\n", "            ", "for", "v", "in", "values", ":", "\n", "                ", "v_to_s", "[", "v", "]", "=", "slot", "\n", "", "", "return", "v_to_s", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.preprocess_data": [[53, 115], ["print", "json.loads", "datasets.CamRest676._value_key_map", "vocab.Vocab.Vocab", "enumerate", "vocab.Vocab.Vocab.construct", "vocab.Vocab.Vocab.save_vocab", "open().read().lower", "open", "json.dump", "dict", "datasets.CamRest676.word_tokenize", "datasets.CamRest676._replace_entity", "resp.split.split.replace().replace", "resp.split.split.split", "turns.append", "open().read", "datasets.CamRest676.word_tokenize", "vocab.Vocab.Vocab.add_word", "sys_request.extend", "resp.split.split.replace", "json.dumps", "len", "open", "constraint[].extend", "constraint_flat.extend", "constraint[].extend", "constraint_flat.extend", "user_request.append", "datasets.CamRest676.db_json_search", "datasets.CamRest676.word_tokenize", "datasets.CamRest676.word_tokenize"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676._value_key_map", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.construct", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.save_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._replace_entity", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.add_word", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.db_json_search"], ["", "def", "preprocess_data", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Preprocessing data'", ")", "\n", "raw_data", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "raw_data_path", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "db_data", "=", "self", ".", "db_json", "\n", "sw_ent", ",", "mw_ent", "=", "self", ".", "_value_key_map", "(", "db_data", ")", "\n", "vocab", "=", "Vocab", "(", "cfg", ".", "vocab_size", ",", "self", ".", "otlg", ".", "special_tokens", ")", "\n", "# delexicalization", "\n", "dialogs", "=", "{", "}", "\n", "for", "dial_id", ",", "dial", "in", "enumerate", "(", "raw_data", ")", ":", "\n", "            ", "dialogs", "[", "dial_id", "]", "=", "{", "}", "\n", "dialogs", "[", "dial_id", "]", "[", "'goal'", "]", "=", "dial", "[", "'goal'", "]", "\n", "turns", "=", "[", "]", "\n", "for", "turn", "in", "dial", "[", "'dial'", "]", ":", "\n", "                ", "turn_num", "=", "turn", "[", "'turn'", "]", "\n", "constraint", "=", "dict", "(", "(", "slot", ",", "[", "]", ")", "for", "slot", "in", "self", ".", "informable_slots", ")", "\n", "constraint_flat", ",", "user_request", ",", "sys_request", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "slot_values", "in", "turn", "[", "'usr'", "]", "[", "'slu'", "]", ":", "\n", "                    ", "if", "slot_values", "[", "'act'", "]", "==", "'inform'", ":", "\n", "                        ", "slot", ",", "value", "=", "slot_values", "[", "'slots'", "]", "[", "0", "]", "[", "0", "]", ",", "slot_values", "[", "'slots'", "]", "[", "0", "]", "[", "1", "]", "\n", "slot", "=", "'restaurant-'", "+", "slot", "\n", "if", "slot", "!=", "'restaurant-slot'", "and", "value", "not", "in", "[", "'dontcare'", ",", "'none'", "]", ":", "\n", "                            ", "constraint", "[", "slot", "]", ".", "extend", "(", "self", ".", "word_tokenize", "(", "value", ")", ")", "\n", "constraint_flat", ".", "extend", "(", "self", ".", "word_tokenize", "(", "value", ")", ")", "\n", "", "if", "value", "==", "'dontcare'", ":", "\n", "                            ", "constraint", "[", "slot", "]", ".", "extend", "(", "[", "'dontcare'", "]", ")", "\n", "constraint_flat", ".", "extend", "(", "[", "'dontcare'", "]", ")", "\n", "", "", "elif", "slot_values", "[", "'act'", "]", "==", "'request'", ":", "\n", "                        ", "user_request", ".", "append", "(", "'[value_%s]'", "%", "slot_values", "[", "'slots'", "]", "[", "0", "]", "[", "1", "]", ")", "\n", "# constraint[slot].extend(['do', \"n't\", 'care'])", "\n", "", "", "if", "turn", "[", "'sys'", "]", "[", "'da'", "]", ":", "\n", "                    ", "for", "s", "in", "turn", "[", "'sys'", "]", "[", "'da'", "]", ":", "\n", "                        ", "s", "=", "[", "'price'", ",", "'range'", "]", "if", "s", "==", "'pricerange'", "else", "[", "s", "]", "\n", "if", "s", "==", "[", "[", "\"area, centre\"", "]", "]", ":", "\n", "                            ", "s", "=", "[", "'area'", "]", "\n", "", "sys_request", ".", "extend", "(", "s", ")", "\n", "", "", "user", "=", "self", ".", "word_tokenize", "(", "turn", "[", "'usr'", "]", "[", "'transcript'", "]", ")", "\n", "resp", "=", "' '", ".", "join", "(", "self", ".", "word_tokenize", "(", "turn", "[", "'sys'", "]", "[", "'sent'", "]", ")", ")", "\n", "resp", "=", "self", ".", "_replace_entity", "(", "resp", ",", "sw_ent", ",", "mw_ent", ",", "constraint_flat", ")", "\n", "resp", "=", "resp", ".", "replace", "(", "'[value_phone].'", ",", "'[value_phone] .'", ")", ".", "replace", "(", "'ok.'", ",", "'ok .'", ")", "\n", "resp", "=", "resp", ".", "split", "(", ")", "\n", "# try:", "\n", "turns", ".", "append", "(", "{", "\n", "'turn'", ":", "turn_num", ",", "\n", "'user'", ":", "' '", ".", "join", "(", "user", ")", ",", "\n", "'response'", ":", "' '", ".", "join", "(", "resp", ")", ",", "\n", "'constraint'", ":", "json", ".", "dumps", "(", "constraint", ")", ",", "\n", "'user_request'", ":", "' '", ".", "join", "(", "user_request", ")", ",", "\n", "'sys_request'", ":", "' '", ".", "join", "(", "sys_request", ")", ",", "\n", "'db_match'", ":", "len", "(", "self", ".", "db_json_search", "(", "constraint", ")", ")", ",", "\n", "}", ")", "\n", "for", "word", "in", "user", "+", "resp", ":", "\n", "                    ", "vocab", ".", "add_word", "(", "word", ")", "\n", "", "", "dialogs", "[", "dial_id", "]", "[", "'log'", "]", "=", "turns", "\n", "\n", "# save preprocessed data", "\n", "", "with", "open", "(", "self", ".", "data_path", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "dialogs", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "# construct vocabulary", "\n", "", "vocab", ".", "construct", "(", ")", "\n", "vocab", ".", "save_vocab", "(", "self", ".", "dataset_path", "+", "'vocab'", ")", "\n", "return", "dialogs", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676._replace_entity": [[116, 138], ["re.sub", "re.sub", "multi_word_ent.items", "text.replace.replace.split", "single_word_ent.items", "text.replace.replace.replace", "text.replace.split.index", "text.replace.split.index"], "methods", ["None"], ["", "def", "_replace_entity", "(", "self", ",", "text", ",", "single_word_ent", ",", "multi_word_ent", ",", "constraint", ")", ":", "\n", "        ", "text", "=", "re", ".", "sub", "(", "r'[cC][., ]*[bB][., ]*\\d[., ]*\\d[., ]*\\w[., ]*\\w'", ",", "'[value_postcode]'", ",", "text", ")", "\n", "text", "=", "re", ".", "sub", "(", "r'\\d{5}\\s?\\d{6}'", ",", "'[value_phone]'", ",", "text", ")", "\n", "constraint_str", "=", "' '", ".", "join", "(", "constraint", ")", "\n", "\n", "for", "value", ",", "slot", "in", "multi_word_ent", ".", "items", "(", ")", ":", "\n", "            ", "if", "value", "in", "constraint_str", ":", "\n", "                ", "continue", "\n", "", "text", "=", "text", ".", "replace", "(", "value", ",", "'[value_%s]'", "%", "slot", ")", "\n", "\n", "", "tokens", "=", "text", ".", "split", "(", ")", "\n", "for", "value", ",", "slot", "in", "single_word_ent", ".", "items", "(", ")", ":", "\n", "# if value == 'ask':", "\n", "#     continue", "\n", "            ", "if", "value", "in", "constraint_str", "or", "value", "not", "in", "tokens", ":", "\n", "                ", "continue", "\n", "", "tokens", "[", "tokens", ".", "index", "(", "value", ")", "]", "=", "'[value_%s]'", "%", "slot", "\n", "if", "'moderately'", "in", "tokens", ":", "\n", "                ", "tokens", "[", "tokens", ".", "index", "(", "'moderately'", ")", "]", "=", "'[value_pricerange]'", "\n", "", "text", "=", "' '", ".", "join", "(", "tokens", ")", "\n", "\n", "", "return", "text", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676._value_key_map": [[139, 154], ["collections.OrderedDict", "collections.OrderedDict", "db_entry.items", "sorted", "sorted", "open", "json.dump", "collections.OrderedDict.items", "collections.OrderedDict.items", "os.path.join", "datasets.CamRest676.word_tokenize", "len", "value.split", "len", "len"], "methods", ["None"], ["", "def", "_value_key_map", "(", "self", ",", "db_data", ")", ":", "\n", "        ", "single_word_ent", ",", "multi_word_ent", "=", "{", "}", ",", "{", "}", "\n", "for", "db_entry", "in", "db_data", ":", "\n", "            ", "for", "slot", ",", "value", "in", "db_entry", ".", "items", "(", ")", ":", "\n", "                ", "value", "=", "' '", ".", "join", "(", "self", ".", "word_tokenize", "(", "value", ")", ")", "\n", "if", "slot", "in", "self", ".", "requestable_slots", ":", "\n", "                    ", "if", "len", "(", "value", ".", "split", "(", ")", ")", "==", "1", ":", "\n", "                        ", "single_word_ent", "[", "value", "]", "=", "slot", "\n", "", "else", ":", "\n", "                        ", "multi_word_ent", "[", "value", "]", "=", "slot", "\n", "", "", "", "", "single_word_ent", "=", "OrderedDict", "(", "sorted", "(", "single_word_ent", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "len", "(", "x", "[", "0", "]", ")", ")", ")", "\n", "multi_word_ent", "=", "OrderedDict", "(", "sorted", "(", "multi_word_ent", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "len", "(", "x", "[", "0", "]", ")", ")", ")", "\n", "with", "open", "(", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "'value_dict.json'", ")", ",", "'w'", ")", "as", "f", ":", "\n", "            ", "json", ".", "dump", "(", "{", "'single'", ":", "single_word_ent", ",", "'multi'", ":", "multi_word_ent", "}", ",", "f", ",", "indent", "=", "2", ")", "\n", "", "return", "single_word_ent", ",", "multi_word_ent", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676._db_construct": [[155, 181], ["sqlite3.connect", "sqlite3.connect.cursor", "sql.connect.cursor.execute", "sqlite3.connect.commit", "sqlite3.connect.close", "sql.connect.cursor.execute", "entry.get", "str"], "methods", ["None"], ["", "def", "_db_construct", "(", "self", ",", "save_dir", "=", "None", ")", ":", "\n", "        ", "all_slots", "=", "[", "'id'", ",", "'name'", ",", "'food'", ",", "'pricerange'", ",", "'area'", ",", "'phone'", ",", "'postcode'", ",", "'address'", ",", "\n", "'type'", ",", "'location'", "]", "\n", "if", "save_dir", "is", "None", ":", "\n", "            ", "save_dir", "=", "'data/CamRest676/CamRestDB.db'", "\n", "", "conn", "=", "sql", ".", "connect", "(", "save_dir", ")", "\n", "cur", "=", "conn", ".", "cursor", "(", ")", "\n", "# create table", "\n", "exec_create", "=", "\"CREATE TABLE restaurant(\"", "\n", "for", "slot", "in", "all_slots", ":", "\n", "            ", "exec_create", "+=", "\"%s TEXT ,\"", "%", "slot", "\n", "", "exec_create", "=", "exec_create", "[", ":", "-", "1", "]", "+", "\");\"", "\n", "cur", ".", "execute", "(", "exec_create", ")", "\n", "\n", "for", "entry", "in", "self", ".", "db_json", ":", "\n", "            ", "slots", "=", "\",\"", ".", "join", "(", "[", "s", "for", "s", "in", "all_slots", "]", ")", "\n", "exec_insert", "=", "\"INSERT INTO restaurant(\"", "+", "slots", "+", "\")\\nVALUES (\"", "\n", "for", "slot", "in", "all_slots", ":", "\n", "                ", "if", "entry", ".", "get", "(", "slot", ")", ":", "\n", "                    ", "exec_insert", "+=", "'\"'", "+", "str", "(", "entry", "[", "slot", "]", ")", "+", "'\",'", "\n", "", "else", ":", "\n", "                    ", "exec_insert", "+=", "'NULL,'", "\n", "", "", "exec_insert", "=", "exec_insert", "[", ":", "-", "1", "]", "+", "')'", "\n", "cur", ".", "execute", "(", "exec_insert", ")", "\n", "", "conn", ".", "commit", "(", ")", "\n", "conn", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.db_search": [[182, 193], ["constraints.items", "datasets.CamRest676.db.execute().fetchall", "s.split", "datasets.CamRest676.db.execute"], "methods", ["None"], ["", "def", "db_search", "(", "self", ",", "constraints", ")", ":", "\n", "        ", "match_results", "=", "[", "]", "\n", "sql_query", "=", "\"select * from restaurant where\"", "\n", "for", "s", ",", "v", "in", "constraints", ".", "items", "(", ")", ":", "\n", "            ", "s", "=", "s", ".", "split", "(", "'-'", ")", "[", "1", "]", "\n", "if", "v", "in", "[", "'dontcare'", ",", "\"do n't care\"", ",", "'any'", "]", "or", "v", "==", "[", "]", ":", "\n", "                ", "continue", "\n", "", "sql_query", "+=", "\" %s='%s' and\"", "%", "(", "s", ",", "' '", ".", "join", "(", "v", ")", ")", "\n", "", "match_results", "=", "self", ".", "db", ".", "execute", "(", "sql_query", "[", ":", "-", "3", "]", ")", ".", "fetchall", "(", ")", "\n", "# print(len(match_results))", "\n", "return", "match_results", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.db_json_search": [[194, 212], ["constraints.items", "match_results.append"], "methods", ["None"], ["", "def", "db_json_search", "(", "self", ",", "constraints", ")", ":", "\n", "        ", "match_results", "=", "[", "]", "\n", "for", "entry", "in", "self", ".", "db_json", ":", "\n", "            ", "if", "'food'", "not", "in", "entry", ":", "\n", "                ", "entry_values", "=", "entry", "[", "'area'", "]", "+", "' '", "+", "entry", "[", "'pricerange'", "]", "\n", "", "else", ":", "\n", "                ", "entry_values", "=", "entry", "[", "'area'", "]", "+", "' '", "+", "entry", "[", "'food'", "]", "+", "' '", "+", "entry", "[", "'pricerange'", "]", "\n", "", "match", "=", "True", "\n", "for", "s", ",", "v", "in", "constraints", ".", "items", "(", ")", ":", "\n", "                ", "if", "v", "in", "[", "'dontcare'", ",", "\"do n't care\"", ",", "'any'", "]", ":", "\n", "                    ", "continue", "\n", "", "if", "' '", ".", "join", "(", "v", ")", "not", "in", "entry_values", ":", "\n", "                    ", "match", "=", "False", "\n", "break", "\n", "", "", "if", "match", ":", "\n", "                ", "match_results", ".", "append", "(", "entry", ")", "\n", "# print(len(match_results))", "\n", "", "", "return", "match_results", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.degree_vec_mapping": [[213, 217], ["min"], "methods", ["None"], ["", "def", "degree_vec_mapping", "(", "self", ",", "match_num", ")", ":", "\n", "        ", "l", "=", "[", "0.", "]", "*", "self", ".", "db_vec_size", "\n", "l", "[", "min", "(", "self", ".", "db_vec_size", "-", "1", ",", "match_num", ")", "]", "=", "1.", "\n", "return", "l", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.pointer_back": [[218, 226], ["degree.index", "len", "str", "len"], "methods", ["None"], ["", "def", "pointer_back", "(", "self", ",", "degree", ")", ":", "\n", "        ", "if", "1", "not", "in", "degree", ":", "\n", "            ", "return", "'-'", "\n", "", "i", "=", "degree", ".", "index", "(", "1", ")", "\n", "if", "i", "==", "len", "(", "degree", "-", "1", ")", ":", "\n", "            ", "return", "'>%d'", "%", "(", "len", "(", "degree", "-", "2", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "str", "(", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.get_db_degree": [[227, 254], ["all_slots_idx.split", "enumerate", "len", "db_vec.append", "match.append", "numpy.array", "datasets.CamRest676.db_json_search", "datasets.CamRest676.degree_vec_mapping", "vocab.decode", "constraints[].append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.db_json_search", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.CamRest676.degree_vec_mapping", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.decode"], ["", "", "def", "get_db_degree", "(", "self", ",", "z_samples", ",", "vocab", ")", ":", "\n", "        ", "\"\"\"\n        returns degree of database searching and it may be used to control further decoding.\n        One hot vector, indicating the number of entries found: [0, 1, 2, 3, >=4]\n        :param z_samples: tensor of [B, Tz*informable_slot_num]\n        :return: an one-hot *numpy* db results vector and a list of match numbers\n        \"\"\"", "\n", "db_vec", "=", "[", "]", "\n", "match", "=", "[", "]", "\n", "\n", "for", "all_slots_idx", "in", "z_samples", ":", "\n", "            ", "all_slots_idx_tuple", "=", "all_slots_idx", ".", "split", "(", "self", ".", "z_length", ")", "\n", "# print(all_slots_idx_tuple)", "\n", "constraints", "=", "{", "}", "\n", "for", "sidx", ",", "slot", "in", "enumerate", "(", "self", ".", "informable_slots", ")", ":", "\n", "                ", "constraints", "[", "slot", "]", "=", "[", "]", "\n", "slot_idx", "=", "all_slots_idx_tuple", "[", "sidx", "]", "\n", "for", "widx", "in", "slot_idx", ":", "\n", "                    ", "w", "=", "vocab", ".", "decode", "(", "widx", ")", "\n", "if", "w", "in", "[", "'<eos_b1>'", ",", "'<eos_b2>'", ",", "'<eos_b3>'", ",", "'<eos_b>'", "]", ":", "\n", "                        ", "break", "\n", "", "if", "w", "not", "in", "constraints", "[", "slot", "]", ":", "\n", "                        ", "constraints", "[", "slot", "]", ".", "append", "(", "w", ")", "\n", "", "", "", "match_num", "=", "len", "(", "self", ".", "db_json_search", "(", "constraints", ")", ")", "\n", "db_vec", ".", "append", "(", "self", ".", "degree_vec_mapping", "(", "match_num", ")", ")", "\n", "match", ".", "append", "(", "match_num", ")", "\n", "", "return", "np", ".", "array", "(", "db_vec", ")", ",", "match", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.__init__": [[257, 277], ["datasets.Dataset.__init__", "ontologies.KvretOntology", "json.loads", "datasets.Kvret.get_value_to_slot_mapping", "os.path.join", "os.path.join", "os.path.join", "open().read().lower", "open().read", "open"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.get_value_to_slot_mapping"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "dataset_path", "=", "cfg", ".", "dataset_path", "\n", "self", ".", "raw_data_path", "=", "{", "\n", "'train'", ":", "cfg", ".", "raw_train_data", ",", "\n", "'dev'", ":", "cfg", ".", "raw_dev_data", ",", "\n", "'test'", ":", "cfg", ".", "raw_test_data", "\n", "}", "\n", "self", ".", "otlg", "=", "KvretOntology", "(", "cfg", ".", "ontology_path", ")", "\n", "self", ".", "requestable_slots", "=", "self", ".", "otlg", ".", "requestable_slots", "\n", "self", ".", "informable_slots", "=", "self", ".", "otlg", ".", "informable_slots", "\n", "\n", "self", ".", "data_path", "=", "{", "\n", "'train'", ":", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "'train_preprocessed.json'", ")", ",", "\n", "'dev'", ":", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "'dev_preprocessed.json'", ")", ",", "\n", "'test'", ":", "os", ".", "path", ".", "join", "(", "self", ".", "dataset_path", ",", "'test_preprocessed.json'", ")", "\n", "}", "\n", "\n", "self", ".", "entities", "=", "json", ".", "loads", "(", "open", "(", "cfg", ".", "ontology_path", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "self", ".", "get_value_to_slot_mapping", "(", "self", ".", "entities", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._tokenize": [[278, 280], ["datasets.Kvret.word_tokenize"], "methods", ["None"], ["", "def", "_tokenize", "(", "self", ",", "sent", ")", ":", "\n", "        ", "return", "' '", ".", "join", "(", "self", ".", "word_tokenize", "(", "sent", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._lemmatize": [[281, 283], ["datasets.Kvret.wn.lemmatize", "sent.split"], "methods", ["None"], ["", "def", "_lemmatize", "(", "self", ",", "sent", ")", ":", "\n", "        ", "return", "' '", ".", "join", "(", "[", "self", ".", "wn", ".", "lemmatize", "(", "_", ")", "for", "_", "in", "sent", ".", "split", "(", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.get_value_to_slot_mapping": [[284, 304], ["type", "datasets.Kvret._lemmatize", "type", "datasets.Kvret._tokenize", "entity_entry.items", "datasets.Kvret._lemmatize", "datasets.Kvret._tokenize", "datasets.Kvret.split", "datasets.Kvret.split", "datasets.Kvret.split", "datasets.Kvret.split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._lemmatize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._tokenize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._lemmatize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._tokenize"], ["", "def", "get_value_to_slot_mapping", "(", "self", ",", "entity_data", ")", ":", "\n", "        ", "self", ".", "entity_dict", "=", "{", "}", "\n", "self", ".", "abbr_dict", "=", "{", "}", "\n", "for", "k", "in", "entity_data", ":", "\n", "            ", "if", "type", "(", "entity_data", "[", "k", "]", "[", "0", "]", ")", "is", "str", ":", "\n", "                ", "for", "entity", "in", "entity_data", "[", "k", "]", ":", "\n", "                    ", "entity", "=", "self", ".", "_lemmatize", "(", "self", ".", "_tokenize", "(", "entity", ")", ")", "\n", "self", ".", "entity_dict", "[", "entity", "]", "=", "k", "\n", "if", "k", "in", "[", "'event'", ",", "'poi_type'", "]", ":", "\n", "                        ", "self", ".", "entity_dict", "[", "entity", ".", "split", "(", ")", "[", "0", "]", "]", "=", "k", "\n", "self", ".", "abbr_dict", "[", "entity", ".", "split", "(", ")", "[", "0", "]", "]", "=", "entity", "\n", "", "", "", "elif", "type", "(", "entity_data", "[", "k", "]", "[", "0", "]", ")", "is", "dict", ":", "\n", "                ", "for", "entity_entry", "in", "entity_data", "[", "k", "]", ":", "\n", "                    ", "for", "entity_type", ",", "entity", "in", "entity_entry", ".", "items", "(", ")", ":", "\n", "                        ", "entity_type", "=", "'poi_type'", "if", "entity_type", "==", "'type'", "else", "entity_type", "\n", "entity", "=", "self", ".", "_lemmatize", "(", "self", ".", "_tokenize", "(", "entity", ")", ")", "\n", "self", ".", "entity_dict", "[", "entity", "]", "=", "entity_type", "\n", "if", "entity_type", "in", "[", "'event'", ",", "'poi_type'", "]", ":", "\n", "                            ", "self", ".", "entity_dict", "[", "entity", ".", "split", "(", ")", "[", "0", "]", "]", "=", "entity_type", "\n", "self", ".", "abbr_dict", "[", "entity", ".", "split", "(", ")", "[", "0", "]", "]", "=", "entity", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._replace_entity": [[306, 326], ["re.sub", "re.sub", "re.sub", "datasets.Kvret._lemmatize", "utils.clean_replace.replace().replace", "sorted", "datasets.Kvret._tokenize", "datasets.Kvret.entity_dict.items", "utils.clean_replace.find", "utils.clean_replace.replace", "len", "v.replace().replace().replace", "response[].replace().replace().replace", "utils.clean_replace", "len", "len", "v.replace().replace", "response[].replace().replace", "v.replace", "response[].replace"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._lemmatize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._tokenize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.clean_replace"], ["", "", "", "", "", "", "def", "_replace_entity", "(", "self", ",", "response", ",", "prev_user_input", ",", "intent", ")", ":", "\n", "        ", "response", "=", "re", ".", "sub", "(", "r'\\d+-?\\d*fs?'", ",", "'[value_temperature]'", ",", "response", ")", "\n", "response", "=", "re", ".", "sub", "(", "r'\\d+\\s?miles?'", ",", "'[value_distance]'", ",", "response", ")", "\n", "response", "=", "re", ".", "sub", "(", "r'\\d+\\s\\w+\\s(dr)?(ct)?(rd)?(road)?(st)?(ave)?(way)?(pl)?\\w*[.]?'", ",", "'[value_address]'", ",", "response", ")", "\n", "response", "=", "self", ".", "_lemmatize", "(", "self", ".", "_tokenize", "(", "response", ")", ")", "\n", "response", "=", "response", ".", "replace", "(", "'[ '", ",", "'['", ")", ".", "replace", "(", "' ]'", ",", "']'", ")", "\n", "requestable", "=", "self", ".", "otlg", ".", "requestable_slots_dict", "\n", "for", "v", ",", "k", "in", "sorted", "(", "self", ".", "entity_dict", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "len", "(", "x", "[", "0", "]", ")", ")", ":", "\n", "            ", "start_idx", "=", "response", ".", "find", "(", "v", ")", "\n", "if", "start_idx", "==", "-", "1", "or", "k", "not", "in", "requestable", "[", "intent", "]", ":", "\n", "                ", "continue", "\n", "", "end_idx", "=", "start_idx", "+", "len", "(", "v", ")", "\n", "while", "end_idx", "<", "len", "(", "response", ")", "and", "response", "[", "end_idx", "]", "!=", "' '", ":", "\n", "                ", "end_idx", "+=", "1", "\n", "# test whether they are indeed the same word", "\n", "", "lm1", ",", "lm2", "=", "v", ".", "replace", "(", "'.'", ",", "''", ")", ".", "replace", "(", "' '", ",", "''", ")", ".", "replace", "(", "\"'\"", ",", "''", ")", ",", "response", "[", "start_idx", ":", "end_idx", "]", ".", "replace", "(", "'.'", ",", "''", ")", ".", "replace", "(", "' '", ",", "''", ")", ".", "replace", "(", "\"'\"", ",", "''", ")", "\n", "if", "lm1", "==", "lm2", "and", "lm1", "not", "in", "prev_user_input", "and", "v", "not", "in", "prev_user_input", ":", "\n", "                ", "response", "=", "utils", ".", "clean_replace", "(", "response", ",", "response", "[", "start_idx", ":", "end_idx", "]", ",", "'[value_%s]'", "%", "k", ")", "\n", "", "", "return", "response", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._clean_constraint_dict": [[328, 369], ["list", "constraint_dict.keys", "datasets.Kvret._lemmatize", "re.sub", "re.sub", "re.sub.strip", "constraint_dict_new.pop", "constraint_dict.pop", "datasets.Kvret._tokenize", "invalid_key.append", "x.group", "x.group", "x.group", "datasets.Kvret.abbr_dict.get", "ValueError", "re.sub.split", "x.group", "re.sub.split", "datasets.Kvret.abbr_dict.get", "ValueError", "re.sub.split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._lemmatize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._tokenize"], ["", "def", "_clean_constraint_dict", "(", "self", ",", "constraint_dict", ",", "intent", ",", "prefer", "=", "'short'", ")", ":", "\n", "        ", "\"\"\"\n        clean the constraint dict so that every key is in \"informable\" and similar to one in provided entity dict.\n        :param constraint_dict:\n        :return:\n        \"\"\"", "\n", "for", "s", "in", "list", "(", "constraint_dict", ".", "keys", "(", ")", ")", ":", "\n", "            ", "if", "s", "not", "in", "self", ".", "otlg", ".", "informable_slots", ":", "\n", "                ", "constraint_dict", ".", "pop", "(", "s", ")", "\n", "\n", "", "", "invalid_key", "=", "[", "]", "\n", "constraint_dict_new", "=", "{", "}", "\n", "for", "k", "in", "constraint_dict", ":", "\n", "            ", "v", "=", "self", ".", "_lemmatize", "(", "self", ".", "_tokenize", "(", "constraint_dict", "[", "k", "]", ")", ")", "\n", "v", "=", "re", ".", "sub", "(", "r'(\\d+) ([ap]m)'", ",", "lambda", "x", ":", "x", ".", "group", "(", "1", ")", "+", "x", ".", "group", "(", "2", ")", ",", "v", ")", "\n", "v", "=", "re", ".", "sub", "(", "r'(\\d+)\\s?(mile)s?'", ",", "lambda", "x", ":", "x", ".", "group", "(", "1", ")", "+", "' '", "+", "x", ".", "group", "(", "2", ")", ",", "v", ")", "\n", "constraint_dict_new", "[", "k", "]", "=", "v", ".", "strip", "(", ")", "\n", "if", "v", "in", "self", ".", "entity_dict", ":", "\n", "                ", "if", "prefer", "==", "'short'", ":", "\n", "                    ", "constraint_dict_new", "[", "k", "]", "=", "v", "\n", "", "elif", "prefer", "==", "'long'", ":", "\n", "                    ", "constraint_dict_new", "[", "k", "]", "=", "self", ".", "abbr_dict", ".", "get", "(", "v", ",", "v", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'what is %s prefer, bro?'", "%", "prefer", ")", "\n", "", "", "elif", "v", ".", "split", "(", ")", "[", "0", "]", "in", "self", ".", "entity_dict", ":", "\n", "                ", "if", "prefer", "==", "'short'", ":", "\n", "                    ", "constraint_dict_new", "[", "k", "]", "=", "v", ".", "split", "(", ")", "[", "0", "]", "\n", "", "elif", "prefer", "==", "'long'", ":", "\n", "                    ", "constraint_dict_new", "[", "k", "]", "=", "self", ".", "abbr_dict", ".", "get", "(", "v", ".", "split", "(", ")", "[", "0", "]", ",", "v", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'what is %s prefer, bro?'", "%", "prefer", ")", "\n", "", "", "else", ":", "\n", "                ", "invalid_key", ".", "append", "(", "k", ")", "\n", "\n", "# if invalid_key:", "\n", "#     print('invalid key', invalid_key)", "\n", "", "", "for", "key", "in", "invalid_key", ":", "\n", "# print(constraint_dict_new[key])", "\n", "            ", "constraint_dict_new", ".", "pop", "(", "key", ")", "\n", "\n", "", "return", "constraint_dict_new", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret.preprocess_data": [[371, 442], ["vocab.Vocab.Vocab", "vocab.Vocab.Vocab.construct", "vocab.Vocab.Vocab.save_vocab", "print", "json.loads", "enumerate", "open().read().lower", "enumerate", "open", "json.dump", "open().read", "ValueError", "datasets.Kvret._lemmatize", "re.sub", "single_turn[].split", "vocab.Vocab.Vocab.add_word", "datasets.Kvret._tokenize", "re.sub", "datasets.Kvret._replace_entity", "[].items", "datasets.Kvret._clean_constraint_dict", "list", "json.dumps", "len", "single_turn[].split", "open", "datasets.Kvret.values", "precessed_dialog.append", "x.group", "x.group", "x.group", "x.group", "len"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.construct", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.save_vocab", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._lemmatize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.add_word", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._tokenize", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._replace_entity", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Kvret._clean_constraint_dict"], ["", "def", "preprocess_data", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Somerrthing to note: We define requestable and informable slots as below in further experiments\n        (including other baselines):\n        :param raw_data:\n        :param add_to_vocab:\n        :param data_type:\n        :return:\n        \"\"\"", "\n", "vocab", "=", "Vocab", "(", "cfg", ".", "vocab_size", ",", "self", ".", "otlg", ".", "special_tokens", ")", "\n", "for", "data_type", "in", "[", "'train'", ",", "'dev'", ",", "'test'", "]", ":", "\n", "            ", "print", "(", "'Preprocessing %s data'", "%", "data_type", ")", "\n", "raw_data", "=", "json", ".", "loads", "(", "open", "(", "self", ".", "raw_data_path", "[", "data_type", "]", ",", "'r'", ")", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "precessed_dialogs", "=", "{", "}", "\n", "state_dump", "=", "{", "}", "\n", "for", "dial_id", ",", "raw_dial", "in", "enumerate", "(", "raw_data", ")", ":", "\n", "                ", "precessed_dialog", "=", "[", "]", "\n", "prev_utter", "=", "''", "\n", "single_turn", "=", "{", "}", "\n", "constraint_flat", "=", "[", "]", "\n", "constraint_dict", "=", "{", "}", "\n", "intent", "=", "raw_dial", "[", "'scenario'", "]", "[", "'task'", "]", "[", "'intent'", "]", "\n", "if", "cfg", ".", "domain", "!=", "'all'", "and", "cfg", ".", "domain", "!=", "intent", ":", "\n", "                    ", "if", "intent", "not", "in", "[", "'navigate'", ",", "'weather'", ",", "'schedule'", "]", ":", "\n", "                        ", "raise", "ValueError", "(", "'what is %s intent bro?'", "%", "intent", ")", "\n", "", "else", ":", "\n", "                        ", "continue", "\n", "", "", "for", "turn_num", ",", "dial_turn", "in", "enumerate", "(", "raw_dial", "[", "'dialogue'", "]", ")", ":", "\n", "                    ", "state_dump", "[", "(", "dial_id", ",", "turn_num", ")", "]", "=", "{", "}", "\n", "if", "dial_turn", "[", "'turn'", "]", "==", "'driver'", ":", "\n", "                        ", "u", "=", "self", ".", "_lemmatize", "(", "self", ".", "_tokenize", "(", "dial_turn", "[", "'data'", "]", "[", "'utterance'", "]", ")", ")", "\n", "u", "=", "re", ".", "sub", "(", "r'(\\d+) ([ap]m)'", ",", "lambda", "x", ":", "x", ".", "group", "(", "1", ")", "+", "x", ".", "group", "(", "2", ")", ",", "u", ")", "\n", "single_turn", "[", "'user'", "]", "=", "u", "\n", "prev_utter", "+=", "u", "\n", "", "elif", "dial_turn", "[", "'turn'", "]", "==", "'assistant'", ":", "\n", "                        ", "s", "=", "dial_turn", "[", "'data'", "]", "[", "'utterance'", "]", "\n", "# find entities and replace them", "\n", "s", "=", "re", ".", "sub", "(", "r'(\\d+) ([ap]m)'", ",", "lambda", "x", ":", "x", ".", "group", "(", "1", ")", "+", "x", ".", "group", "(", "2", ")", ",", "s", ")", "\n", "s", "=", "self", ".", "_replace_entity", "(", "s", ",", "prev_utter", ",", "intent", ")", "\n", "single_turn", "[", "'response'", "]", "=", "s", "\n", "\n", "# get constraints", "\n", "for", "s", ",", "v", "in", "dial_turn", "[", "'data'", "]", "[", "'slots'", "]", ".", "items", "(", ")", ":", "\n", "                            ", "constraint_dict", "[", "intent", "+", "'-'", "+", "s", "]", "=", "v", "\n", "\n", "", "constraint_dict", "=", "self", ".", "_clean_constraint_dict", "(", "constraint_dict", ",", "intent", ")", "\n", "constraint_flat", "=", "list", "(", "constraint_dict", ".", "values", "(", ")", ")", "\n", "\n", "single_turn", "[", "'constraint'", "]", "=", "json", ".", "dumps", "(", "constraint_dict", ")", "\n", "single_turn", "[", "'turn_num'", "]", "=", "len", "(", "precessed_dialog", ")", "\n", "single_turn", "[", "'dial_id'", "]", "=", "dial_id", "\n", "\n", "if", "'user'", "in", "single_turn", ":", "\n", "                            ", "state_dump", "[", "(", "dial_id", ",", "len", "(", "precessed_dialog", ")", ")", "]", "[", "'constraint'", "]", "=", "constraint_dict", "\n", "precessed_dialog", ".", "append", "(", "single_turn", ")", "\n", "", "single_turn", "=", "{", "}", "\n", "\n", "", "", "for", "single_turn", "in", "precessed_dialog", ":", "\n", "                    ", "for", "word_token", "in", "constraint_flat", "+", "single_turn", "[", "'user'", "]", ".", "split", "(", ")", "+", "single_turn", "[", "'response'", "]", ".", "split", "(", ")", ":", "\n", "                        ", "vocab", ".", "add_word", "(", "word_token", ")", "\n", "", "", "precessed_dialogs", "[", "dial_id", "]", "=", "precessed_dialog", "\n", "\n", "", "with", "open", "(", "self", ".", "data_path", "[", "data_type", "]", ",", "'w'", ")", "as", "f", ":", "\n", "                ", "json", ".", "dump", "(", "precessed_dialogs", ",", "f", ",", "indent", "=", "2", ")", "\n", "\n", "# construct vocabulary", "\n", "", "", "vocab", ".", "construct", "(", ")", "\n", "vocab", ".", "save_vocab", "(", "self", ".", "dataset_path", "+", "'vocab'", ")", "\n", "\n", "return", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.__init__": [[446, 458], ["datasets.Dataset.__init__", "ontologies.MultiwozOntology", "datasets.MultiwozDB", "list", "datasets.Multiwoz.otlg.z_eos_map.values"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "raw_data_path", "=", "cfg", ".", "raw_data", "\n", "self", ".", "otlg", "=", "MultiwozOntology", "(", ")", "\n", "self", ".", "requestable_slots", "=", "self", ".", "otlg", ".", "requestable_slots", "\n", "self", ".", "informable_slots", "=", "self", ".", "otlg", ".", "informable_slots", "\n", "\n", "self", ".", "db", "=", "MultiwozDB", "(", "cfg", ".", "db_paths", ",", "self", ".", "otlg", ")", "\n", "self", ".", "db_vec_size", "=", "cfg", ".", "db_vec_size", "\n", "\n", "self", ".", "z_length", "=", "cfg", ".", "z_length", "\n", "self", ".", "z_eos_tokens", "=", "list", "(", "self", ".", "otlg", ".", "z_eos_map", ".", "values", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.get_db_degree": [[460, 475], ["enumerate", "datasets.Multiwoz.bspn_to_constraint_dict", "datasets.Multiwoz.db.get_match_num", "db_vec.append", "match.append", "numpy.array", "datasets.Multiwoz.db.addDBPointer", "str", "domains[].split"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.bspn_to_constraint_dict", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.get_match_num", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.addDBPointer"], ["", "def", "get_db_degree", "(", "self", ",", "z_samples", ",", "domains", ",", "vocab", ")", ":", "\n", "# z_samples: [B, slot_num * z_length]", "\n", "        ", "db_vec", "=", "[", "]", "\n", "match", "=", "[", "]", "\n", "\n", "for", "bidx", ",", "z_sample", "in", "enumerate", "(", "z_samples", ")", ":", "\n", "            ", "constraints", "=", "self", ".", "bspn_to_constraint_dict", "(", "z_sample", ",", "vocab", ")", "\n", "match_num", "=", "self", ".", "db", ".", "get_match_num", "(", "constraints", ")", "\n", "\n", "if", "' '", "in", "domains", "[", "bidx", "]", ":", "\n", "                ", "domains", "[", "bidx", "]", "=", "domains", "[", "bidx", "]", ".", "split", "(", ")", "[", "0", "]", "\n", "", "db_vec", ".", "append", "(", "self", ".", "db", ".", "addDBPointer", "(", "domains", "[", "bidx", "]", ",", "match_num", "[", "domains", "[", "bidx", "]", "]", ")", ")", "\n", "match", ".", "append", "(", "str", "(", "match_num", "[", "domains", "[", "bidx", "]", "]", ")", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "db_vec", ")", ",", "match", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.Multiwoz.bspn_to_constraint_dict": [[476, 500], ["z_sample.split", "enumerate", "dom_slot.split", "vocab.decode", "[].append"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.decode"], ["", "def", "bspn_to_constraint_dict", "(", "self", ",", "z_sample", ",", "vocab", ")", ":", "\n", "        ", "constraints", "=", "{", "}", "\n", "all_slots_idx_tuple", "=", "z_sample", ".", "split", "(", "self", ".", "z_length", ")", "\n", "for", "sidx", ",", "dom_slot", "in", "enumerate", "(", "self", ".", "informable_slots", ")", ":", "\n", "            ", "dom", ",", "slot", "=", "dom_slot", ".", "split", "(", "'-'", ")", "\n", "if", "dom", "not", "in", "constraints", ":", "\n", "                ", "constraints", "[", "dom", "]", "=", "{", "}", "\n", "", "constraints", "[", "dom", "]", "[", "slot", "]", "=", "[", "]", "\n", "\n", "slot_idx", "=", "all_slots_idx_tuple", "[", "sidx", "]", "\n", "for", "widx", "in", "slot_idx", ":", "\n", "                ", "w", "=", "vocab", ".", "decode", "(", "widx", ")", "\n", "if", "w", "in", "self", ".", "z_eos_tokens", ":", "\n", "                    ", "break", "\n", "", "if", "w", "not", "in", "constraints", "[", "dom", "]", "[", "slot", "]", ":", "\n", "                    ", "constraints", "[", "dom", "]", "[", "slot", "]", ".", "append", "(", "w", ")", "\n", "\n", "", "", "if", "not", "constraints", "[", "dom", "]", "[", "slot", "]", ":", "\n", "                ", "del", "constraints", "[", "dom", "]", "[", "slot", "]", "\n", "", "else", ":", "\n", "                ", "constraints", "[", "dom", "]", "[", "slot", "]", "=", "' '", ".", "join", "(", "constraints", "[", "dom", "]", "[", "slot", "]", ")", ".", "strip", "(", ")", "\n", "", "if", "not", "constraints", "[", "dom", "]", ":", "\n", "                ", "del", "constraints", "[", "dom", "]", "\n", "", "", "return", "constraints", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.__init__": [[503, 507], ["open", "json.loads", "f.read().lower", "f.read"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "db_path", ",", "ontology", ")", ":", "\n", "        ", "self", ".", "otlg", "=", "ontology", "\n", "with", "open", "(", "db_path", ",", "'r'", ")", "as", "f", ":", "\n", "            ", "self", ".", "dbs", "=", "json", ".", "loads", "(", "f", ".", "read", "(", ")", ".", "lower", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.oneHotVector": [[509, 533], ["None"], "methods", ["None"], ["", "", "def", "oneHotVector", "(", "self", ",", "domain", ",", "num", ")", ":", "\n", "        ", "\"\"\"Return number of available entities for particular domain.\"\"\"", "\n", "vector", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "if", "num", "==", "''", ":", "\n", "            ", "return", "vector", "\n", "", "if", "domain", "!=", "'train'", ":", "\n", "            ", "if", "num", "==", "0", ":", "\n", "                ", "vector", "=", "[", "1", ",", "0", ",", "0", ",", "0", "]", "\n", "", "elif", "num", "==", "1", ":", "\n", "                ", "vector", "=", "[", "0", ",", "1", ",", "0", ",", "0", "]", "\n", "", "elif", "num", "<=", "3", ":", "\n", "                ", "vector", "=", "[", "0", ",", "0", ",", "1", ",", "0", "]", "\n", "", "else", ":", "\n", "                ", "vector", "=", "[", "0", ",", "0", ",", "0", ",", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "if", "num", "==", "0", ":", "\n", "                ", "vector", "=", "[", "1", ",", "0", ",", "0", ",", "0", "]", "\n", "", "elif", "num", "<=", "5", ":", "\n", "                ", "vector", "=", "[", "0", ",", "1", ",", "0", ",", "0", "]", "\n", "", "elif", "num", "<=", "10", ":", "\n", "                ", "vector", "=", "[", "0", ",", "0", ",", "1", ",", "0", "]", "\n", "", "else", ":", "\n", "                ", "vector", "=", "[", "0", ",", "0", ",", "0", ",", "1", "]", "\n", "", "", "return", "vector", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.addBookingPointer": [[535, 545], ["turn_da.get", "turn_da.get", "turn_da.get"], "methods", ["None"], ["", "def", "addBookingPointer", "(", "self", ",", "turn_da", ")", ":", "\n", "        ", "\"\"\"Add information about availability of the booking option.\"\"\"", "\n", "# Booking pointer", "\n", "# Do not consider booking two things in a single turn.", "\n", "vector", "=", "[", "0", ",", "0", "]", "\n", "if", "turn_da", ".", "get", "(", "'booking-nobook'", ")", ":", "\n", "            ", "vector", "=", "[", "1", ",", "0", "]", "\n", "", "if", "turn_da", ".", "get", "(", "'booking-book'", ")", "or", "turn_da", ".", "get", "(", "'train-offerbooked'", ")", ":", "\n", "            ", "vector", "=", "[", "0", ",", "1", "]", "\n", "", "return", "vector", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.addDBPointer": [[547, 556], ["datasets.MultiwozDB.oneHotVector"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.oneHotVector"], ["", "def", "addDBPointer", "(", "self", ",", "domain", ",", "match_num", ",", "return_num", "=", "False", ")", ":", "\n", "        ", "\"\"\"Create database pointer for all related domains.\"\"\"", "\n", "# if turn_domains is None:", "\n", "#     turn_domains = db_domains", "\n", "if", "domain", "in", "self", ".", "otlg", ".", "db_domains", ":", "\n", "            ", "vector", "=", "self", ".", "oneHotVector", "(", "domain", ",", "match_num", ")", "\n", "", "else", ":", "\n", "            ", "vector", "=", "[", "0", ",", "0", ",", "0", ",", "0", "]", "\n", "", "return", "vector", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.get_match_num": [[558, 574], ["constraints.get", "datasets.MultiwozDB.queryJsons", "len"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.queryJsons"], ["", "def", "get_match_num", "(", "self", ",", "constraints", ",", "return_entry", "=", "False", ")", ":", "\n", "        ", "\"\"\"Create database pointer for all related domains.\"\"\"", "\n", "match", "=", "{", "'general'", ":", "''", "}", "\n", "entry", "=", "{", "}", "\n", "# if turn_domains is None:", "\n", "#     turn_domains = db_domains", "\n", "for", "domain", "in", "self", ".", "otlg", ".", "all_domains", ":", "\n", "            ", "match", "[", "domain", "]", "=", "''", "\n", "if", "domain", "in", "self", ".", "otlg", ".", "db_domains", "and", "constraints", ".", "get", "(", "domain", ")", ":", "\n", "                ", "matched_ents", "=", "self", ".", "queryJsons", "(", "domain", ",", "constraints", "[", "domain", "]", ")", "\n", "match", "[", "domain", "]", "=", "len", "(", "matched_ents", ")", "\n", "if", "return_entry", ":", "\n", "                    ", "entry", "[", "domain", "]", "=", "matched_ents", "\n", "", "", "", "if", "return_entry", ":", "\n", "            ", "return", "entry", "\n", "", "return", "match", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.pointerBack": [[576, 607], ["domain.endswith", "vector.index"], "methods", ["None"], ["", "def", "pointerBack", "(", "self", ",", "vector", ",", "domain", ")", ":", "\n", "# multi domain implementation", "\n", "# domnum = cfg.domain_num", "\n", "        ", "if", "domain", ".", "endswith", "(", "']'", ")", ":", "\n", "            ", "domain", "=", "domain", "[", "1", ":", "-", "1", "]", "\n", "", "if", "domain", "!=", "'train'", ":", "\n", "            ", "nummap", "=", "{", "\n", "0", ":", "'0'", ",", "\n", "1", ":", "'1'", ",", "\n", "2", ":", "'2-3'", ",", "\n", "3", ":", "'>3'", "\n", "}", "\n", "", "else", ":", "\n", "            ", "nummap", "=", "{", "\n", "0", ":", "'0'", ",", "\n", "1", ":", "'1-5'", ",", "\n", "2", ":", "'6-10'", ",", "\n", "3", ":", "'>10'", "\n", "}", "\n", "", "if", "vector", "[", ":", "4", "]", "==", "[", "0", ",", "0", ",", "0", ",", "0", "]", ":", "\n", "            ", "report", "=", "''", "\n", "", "else", ":", "\n", "            ", "num", "=", "vector", ".", "index", "(", "1", ")", "\n", "report", "=", "domain", "+", "': '", "+", "nummap", "[", "num", "]", "+", "'; '", "\n", "\n", "", "if", "vector", "[", "-", "2", "]", "==", "0", "and", "vector", "[", "-", "1", "]", "==", "1", ":", "\n", "            ", "report", "+=", "'booking: ok'", "\n", "", "if", "vector", "[", "-", "2", "]", "==", "1", "and", "vector", "[", "-", "1", "]", "==", "0", ":", "\n", "            ", "report", "+=", "'booking: unable'", "\n", "\n", "", "return", "report", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.datasets.MultiwozDB.queryJsons": [[609, 704], ["constraints.values", "constraints.get", "constraints.items", "skip_case.get", "match_result.append", "entry.get", "constraints.get", "dbn.endswith", "dbn.startswith", "cons.endswith", "cons.startswith", "match_result.append", "v.split", "int", "int", "int", "int", "db_ent[].split", "db_ent[].split"], "methods", ["None"], ["", "def", "queryJsons", "(", "self", ",", "domain", ",", "constraints", ",", "exactly_match", "=", "True", ",", "return_name", "=", "False", ")", ":", "\n", "        ", "\"\"\"Returns the list of entities for a given domain\n        based on the annotation of the belief state\n        constraints: dict e.g. {'pricerange': 'cheap', 'area': 'west'}\n        \"\"\"", "\n", "# query the db", "\n", "# if domain == 'taxi':", "\n", "#     return [{'taxi_colors': random.choice(self.dbs[domain]['taxi_colors']),", "\n", "#     'taxi_types': random.choice(self.dbs[domain]['taxi_types']),", "\n", "#     'taxi_phone': [random.randint(1, 9) for _ in range(10)]}]", "\n", "# if domain == 'police':", "\n", "#     return self.dbs['police']", "\n", "if", "domain", "==", "'hospital'", ":", "\n", "            ", "if", "constraints", ".", "get", "(", "'department'", ")", ":", "\n", "                ", "for", "entry", "in", "self", ".", "dbs", "[", "'hospital'", "]", ":", "\n", "                    ", "if", "entry", ".", "get", "(", "'department'", ")", "==", "constraints", ".", "get", "(", "'department'", ")", ":", "\n", "                        ", "return", "[", "entry", "]", "\n", "", "", "", "else", ":", "\n", "                ", "return", "[", "]", "\n", "\n", "", "", "valid_cons", "=", "False", "\n", "for", "v", "in", "constraints", ".", "values", "(", ")", ":", "\n", "            ", "if", "v", "not", "in", "[", "\"not mentioned\"", ",", "\"\"", "]", ":", "\n", "                ", "valid_cons", "=", "True", "\n", "", "", "if", "not", "valid_cons", ":", "\n", "            ", "return", "[", "]", "\n", "\n", "", "match_result", "=", "[", "]", "\n", "\n", "\n", "if", "'name'", "in", "constraints", ":", "\n", "            ", "for", "db_ent", "in", "self", ".", "dbs", "[", "domain", "]", ":", "\n", "                ", "if", "'name'", "in", "db_ent", ":", "\n", "                    ", "cons", "=", "constraints", "[", "'name'", "]", "\n", "dbn", "=", "db_ent", "[", "'name'", "]", "\n", "# if cons == dbn:", "\n", "# use a relaxed search constraint when searching by names", "\n", "if", "dbn", ".", "endswith", "(", "cons", ")", "or", "dbn", ".", "startswith", "(", "cons", ")", "or", "cons", ".", "endswith", "(", "dbn", ")", "or", "cons", ".", "startswith", "(", "dbn", ")", ":", "\n", "                        ", "db_ent", "=", "db_ent", "if", "not", "return_name", "else", "db_ent", "[", "'name'", "]", "\n", "match_result", ".", "append", "(", "db_ent", ")", "\n", "return", "match_result", "\n", "\n", "", "", "", "", "for", "db_ent", "in", "self", ".", "dbs", "[", "domain", "]", ":", "\n", "            ", "match", "=", "True", "\n", "for", "s", ",", "v", "in", "constraints", ".", "items", "(", ")", ":", "\n", "                ", "if", "s", "==", "'name'", ":", "\n", "                    ", "continue", "\n", "", "if", "s", "in", "[", "'people'", ",", "'stay'", "]", "or", "(", "domain", "==", "'hotel'", "and", "s", "==", "'day'", ")", "or", "(", "domain", "==", "'restaurant'", "and", "s", "in", "[", "'day'", ",", "'time'", "]", ")", ":", "\n", "                    ", "continue", "\n", "\n", "", "skip_case", "=", "{", "\"don't care\"", ":", "1", ",", "\"do n't care\"", ":", "1", ",", "\"dont care\"", ":", "1", ",", "\"not mentioned\"", ":", "1", ",", "\"dontcare\"", ":", "1", ",", "\"\"", ":", "1", "}", "\n", "if", "skip_case", ".", "get", "(", "v", ")", ":", "\n", "                    ", "continue", "\n", "\n", "", "if", "s", "not", "in", "db_ent", ":", "\n", "# logging.warning('Searching warning: slot %s not in %s db'%(s, domain))", "\n", "                    ", "match", "=", "False", "\n", "break", "\n", "\n", "# v = 'guesthouse' if v == 'guest house' else v", "\n", "# v = 'swimmingpool' if v == 'swimming pool' else v", "\n", "", "v", "=", "'yes'", "if", "v", "==", "'free'", "else", "v", "\n", "\n", "if", "s", "in", "[", "'arrive'", ",", "'leave'", "]", ":", "\n", "                    ", "try", ":", "\n", "                        ", "h", ",", "m", "=", "v", ".", "split", "(", "':'", ")", "# raise error if time value is not xx:xx format", "\n", "v", "=", "int", "(", "h", ")", "*", "60", "+", "int", "(", "m", ")", "\n", "", "except", ":", "\n", "                        ", "match", "=", "False", "\n", "break", "\n", "", "time", "=", "int", "(", "db_ent", "[", "s", "]", ".", "split", "(", "':'", ")", "[", "0", "]", ")", "*", "60", "+", "int", "(", "db_ent", "[", "s", "]", ".", "split", "(", "':'", ")", "[", "1", "]", ")", "\n", "if", "s", "==", "'arrive'", "and", "v", ">", "time", ":", "\n", "                        ", "match", "=", "False", "\n", "", "if", "s", "==", "'leave'", "and", "v", "<", "time", ":", "\n", "                        ", "match", "=", "False", "\n", "", "", "else", ":", "\n", "                    ", "if", "exactly_match", "and", "v", "!=", "db_ent", "[", "s", "]", ":", "\n", "                        ", "match", "=", "False", "\n", "break", "\n", "", "elif", "v", "not", "in", "db_ent", "[", "s", "]", ":", "\n", "                        ", "match", "=", "False", "\n", "break", "\n", "\n", "", "", "", "if", "match", ":", "\n", "                ", "match_result", ".", "append", "(", "db_ent", ")", "\n", "\n", "", "", "if", "not", "return_name", ":", "\n", "            ", "return", "match_result", "\n", "", "else", ":", "\n", "            ", "if", "domain", "==", "'train'", ":", "\n", "                ", "match_result", "=", "[", "e", "[", "'id'", "]", "for", "e", "in", "match_result", "]", "\n", "", "else", ":", "\n", "                ", "match_result", "=", "[", "e", "[", "'name'", "]", "for", "e", "in", "match_result", "]", "\n", "", "return", "match_result", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__init__": [[6, 14], ["vocab.Vocab._absolute_add_word"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab._absolute_add_word"], ["    ", "def", "__init__", "(", "self", ",", "vocab_size", ",", "special_tokens", "=", "[", "]", ")", ":", "\n", "        ", "self", ".", "vocab_size", "=", "vocab_size", "\n", "self", ".", "_idx2word", "=", "{", "}", "\n", "self", ".", "_word2idx", "=", "{", "}", "\n", "self", ".", "_freq_dict", "=", "{", "}", "\n", "self", ".", "special_tokens", "=", "special_tokens", "\n", "for", "w", "in", "self", ".", "special_tokens", ":", "\n", "            ", "self", ".", "_absolute_add_word", "(", "w", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.__len__": [[15, 17], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "_idx2word", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab._absolute_add_word": [[18, 22], ["len"], "methods", ["None"], ["", "def", "_absolute_add_word", "(", "self", ",", "w", ")", ":", "\n", "        ", "idx", "=", "len", "(", "self", ")", "\n", "self", ".", "_idx2word", "[", "idx", "]", "=", "w", "\n", "self", ".", "_word2idx", "[", "w", "]", "=", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.add_word": [[23, 27], ["None"], "methods", ["None"], ["", "def", "add_word", "(", "self", ",", "word", ")", ":", "\n", "        ", "if", "word", "not", "in", "self", ".", "_freq_dict", ":", "\n", "            ", "self", ".", "_freq_dict", "[", "word", "]", "=", "0", "\n", "", "self", ".", "_freq_dict", "[", "word", "]", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.has_word": [[28, 30], ["vocab.Vocab._freq_dict.get"], "methods", ["None"], ["", "def", "has_word", "(", "self", ",", "word", ")", ":", "\n", "        ", "return", "self", ".", "_freq_dict", ".", "get", "(", "word", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab._add_to_vocab": [[31, 36], ["len"], "methods", ["None"], ["", "def", "_add_to_vocab", "(", "self", ",", "word", ")", ":", "\n", "        ", "if", "word", "not", "in", "self", ".", "_word2idx", ":", "\n", "            ", "idx", "=", "len", "(", "self", ".", "_idx2word", ")", "\n", "self", ".", "_idx2word", "[", "idx", "]", "=", "word", "\n", "self", ".", "_word2idx", "[", "word", "]", "=", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.construct": [[37, 46], ["sorted", "vocab.Vocab._freq_dict.keys", "logging.warning", "vocab.Vocab._add_to_vocab", "len", "len", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab._add_to_vocab"], ["", "", "def", "construct", "(", "self", ")", ":", "\n", "        ", "l", "=", "sorted", "(", "self", ".", "_freq_dict", ".", "keys", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "self", ".", "_freq_dict", "[", "x", "]", ")", "\n", "if", "len", "(", "l", ")", "+", "len", "(", "self", ".", "_idx2word", ")", "<", "self", ".", "vocab_size", ":", "\n", "            ", "logging", ".", "warning", "(", "'actual vocabulary set smaller than that configured: {}/{}'", "\n", ".", "format", "(", "len", "(", "l", ")", "+", "len", "(", "self", ".", "_idx2word", ")", ",", "self", ".", "vocab_size", ")", ")", "\n", "", "for", "word", "in", "l", ":", "\n", "            ", "self", ".", "_add_to_vocab", "(", "word", ")", "\n", "if", "len", "(", "self", ".", "_idx2word", ")", ">=", "self", ".", "vocab_size", ":", "\n", "                ", "break", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.load_vocab": [[47, 56], ["json.loads", "json.loads", "vocab.Vocab._word2idx.items", "len", "print", "print", "open().read", "open().read", "open", "open"], "methods", ["None"], ["", "", "", "def", "load_vocab", "(", "self", ",", "vocab_path", ")", ":", "\n", "        ", "self", ".", "_freq_dict", "=", "json", ".", "loads", "(", "open", "(", "vocab_path", "+", "'.freq.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "_word2idx", "=", "json", ".", "loads", "(", "open", "(", "vocab_path", "+", "'.word2idx.json'", ",", "'r'", ")", ".", "read", "(", ")", ")", "\n", "self", ".", "_idx2word", "=", "{", "}", "\n", "for", "w", ",", "idx", "in", "self", ".", "_word2idx", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "_idx2word", "[", "idx", "]", "=", "w", "\n", "", "self", ".", "vocab_size_true", "=", "len", "(", "self", ".", "_idx2word", ")", "\n", "print", "(", "'vocab file loaded from \"'", "+", "vocab_path", "+", "'\"'", ")", "\n", "print", "(", "'Vocabulary size: %d'", "%", "(", "self", ".", "vocab_size_true", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.save_vocab": [[57, 61], ["collections.OrderedDict", "utils.write_dict", "utils.write_dict", "sorted", "vocab.Vocab._freq_dict.items"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.write_dict", "home.repos.pwc.inspect_result.thu-spmi_LABES.None.utils.write_dict"], ["", "def", "save_vocab", "(", "self", ",", "vocab_path", ")", ":", "\n", "        ", "_freq_dict", "=", "OrderedDict", "(", "sorted", "(", "self", ".", "_freq_dict", ".", "items", "(", ")", ",", "key", "=", "lambda", "kv", ":", "kv", "[", "1", "]", ",", "reverse", "=", "True", ")", ")", "\n", "utils", ".", "write_dict", "(", "vocab_path", "+", "'.word2idx.json'", ",", "self", ".", "_word2idx", ")", "\n", "utils", ".", "write_dict", "(", "vocab_path", "+", "'.freq.json'", ",", "_freq_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_encode": [[62, 64], ["vocab.Vocab.encode"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode"], ["", "def", "sentence_encode", "(", "self", ",", "word_list", ")", ":", "\n", "        ", "return", "[", "self", ".", "encode", "(", "_", ")", "for", "_", "in", "word_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_decode": [[65, 72], ["vocab.Vocab.decode", "l.index"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.decode"], ["", "def", "sentence_decode", "(", "self", ",", "index_list", ",", "eos", "=", "None", ")", ":", "\n", "        ", "l", "=", "[", "self", ".", "decode", "(", "_", ")", "for", "_", "in", "index_list", "]", "\n", "if", "not", "eos", "or", "eos", "not", "in", "l", ":", "\n", "            ", "return", "' '", ".", "join", "(", "l", ")", "\n", "", "else", ":", "\n", "            ", "idx", "=", "l", ".", "index", "(", "eos", ")", "\n", "return", "' '", ".", "join", "(", "l", "[", ":", "idx", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.nl_decode": [[73, 75], ["vocab.Vocab.sentence_decode"], "methods", ["home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.sentence_decode"], ["", "", "def", "nl_decode", "(", "self", ",", "l", ",", "eos", "=", "None", ")", ":", "\n", "        ", "return", "[", "self", ".", "sentence_decode", "(", "_", ",", "eos", ")", "+", "'\\n'", "for", "_", "in", "l", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.encode": [[76, 79], ["None"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "word", ")", ":", "\n", "        ", "word", "=", "'<unk>'", "if", "word", "not", "in", "self", ".", "_word2idx", "else", "word", "\n", "return", "self", ".", "_word2idx", "[", "word", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.thu-spmi_LABES.None.vocab.Vocab.decode": [[80, 84], ["vocab.Vocab._idx2word.get", "type", "int", "int.item"], "methods", ["None"], ["", "def", "decode", "(", "self", ",", "idx", ")", ":", "\n", "        ", "if", "type", "(", "idx", ")", "is", "not", "int", ":", "\n", "            ", "idx", "=", "int", "(", "idx", ".", "item", "(", ")", ")", "\n", "", "return", "self", ".", "_idx2word", ".", "get", "(", "idx", ",", "'<unk>'", ")", "", "", "", ""]]}