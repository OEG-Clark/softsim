{"home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.None.main.load_datasets": [[42, 50], ["torch.load", "torch.load", "[].size", "range", "len", "max", "max", "len", "[].max", "[].max"], "function", ["None"], ["def", "load_datasets", "(", "args", ")", ":", "\n", "    ", "d_tr", ",", "d_te", "=", "torch", ".", "load", "(", "args", ".", "data_path", "+", "'/'", "+", "args", ".", "data_file", ")", "\n", "n_inputs", "=", "d_tr", "[", "0", "]", "[", "1", "]", ".", "size", "(", "1", ")", "\n", "n_outputs", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "d_tr", ")", ")", ":", "\n", "        ", "n_outputs", "=", "max", "(", "n_outputs", ",", "d_tr", "[", "i", "]", "[", "2", "]", ".", "max", "(", ")", ")", "\n", "n_outputs", "=", "max", "(", "n_outputs", ",", "d_te", "[", "i", "]", "[", "2", "]", ".", "max", "(", ")", ")", "\n", "", "return", "d_tr", ",", "d_te", ",", "n_inputs", ",", "n_outputs", "+", "1", ",", "len", "(", "d_tr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.None.main.loader": [[51, 60], ["print", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "int", "int", "torch.randperm", "torch.randperm", "yy.view", "y.size", "y.size"], "function", ["None"], ["", "def", "loader", "(", "x", ",", "y", ",", "batch_size", "=", "32", ",", "use", "=", "0.5", ")", ":", "\n", "    ", "n_data", "=", "int", "(", "y", ".", "size", "(", "0", ")", "*", "use", ")", "if", "use", "<=", "1", "else", "int", "(", "use", ")", "\n", "print", "(", "n_data", ")", "\n", "idx", "=", "torch", ".", "randperm", "(", "y", ".", "size", "(", "0", ")", ")", "[", ":", "n_data", "]", "\n", "xx", "=", "x", "[", "idx", ",", ":", "]", "\n", "yy", "=", "y", "[", "idx", "]", "\n", "train", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "xx", ",", "yy", ".", "view", "(", "-", "1", ")", ",", "idx", ")", "\n", "loader_", "=", "DataLoader", "(", "train", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "False", ",", "num_workers", "=", "0", ")", "\n", "return", "loader_", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.None.main.eval_tasks": [[61, 91], ["model.eval", "enumerate", "model.adapt", "range", "result.append", "x.size", "min", "x[].view.cuda", "torch.max", "torch.max", "x[].view", "torch.LongTensor().view", "torch.LongTensor().view", "model().data.cpu", "x.size", "x.size", "torch.LongTensor", "torch.LongTensor", "model"], "function", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.adapt"], ["", "def", "eval_tasks", "(", "model", ",", "tasks", ",", "args", "=", "None", ")", ":", "\n", "    ", "model", ".", "eval", "(", ")", "\n", "if", "args", ".", "adapt", ":", "\n", "        ", "model", ".", "adapt", "(", ")", "\n", "", "result", "=", "[", "]", "\n", "for", "i", ",", "task", "in", "enumerate", "(", "tasks", ")", ":", "\n", "        ", "t", "=", "i", "\n", "x", "=", "task", "[", "1", "]", "\n", "y", "=", "task", "[", "2", "]", "\n", "#x = x / 255.0", "\n", "rt", "=", "0", "\n", "\n", "eval_bs", "=", "128", "\n", "#with torch.no_grad():", "\n", "for", "b_from", "in", "range", "(", "0", ",", "x", ".", "size", "(", "0", ")", ",", "eval_bs", ")", ":", "\n", "            ", "b_to", "=", "min", "(", "b_from", "+", "eval_bs", ",", "x", ".", "size", "(", "0", ")", "-", "1", ")", "\n", "if", "b_from", "==", "b_to", ":", "\n", "                ", "xb", "=", "x", "[", "b_from", "]", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "yb", "=", "torch", ".", "LongTensor", "(", "[", "y", "[", "b_to", "]", "]", ")", ".", "view", "(", "1", ",", "-", "1", ")", "\n", "", "else", ":", "\n", "                ", "xb", "=", "x", "[", "b_from", ":", "b_to", "]", "\n", "yb", "=", "y", "[", "b_from", ":", "b_to", "]", "\n", "", "xb", "=", "xb", ".", "cuda", "(", ")", "\n", "_", ",", "pb", "=", "torch", ".", "max", "(", "model", "(", "xb", ",", "t", ")", ".", "data", ".", "cpu", "(", ")", ",", "1", ",", "keepdim", "=", "False", ")", "\n", "\n", "rt", "+=", "(", "pb", "==", "yb", ")", ".", "float", "(", ")", ".", "sum", "(", ")", "\n", "\n", "", "result", ".", "append", "(", "rt", "/", "x", ".", "size", "(", "0", ")", ")", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.__init__": [[28, 92], ["torch.Module.__init__", "any", "torch.nn.modules.loss.CrossEntropyLoss", "torch.nn.modules.loss.CrossEntropyLoss", "torch.nn.modules.loss.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "int", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "common.ResNet18", "ftml.Net.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "ftml.Net.memx.cuda", "ftml.Net.memy.cuda", "ftml.Net.net.cuda", "resnet.ResNet18", "common.MLP", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "args", ".", "pretrained", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "\n", "", "self", ".", "bce", "=", "CrossEntropyLoss", "(", ")", "\n", "\n", "self", ".", "n_meta", "=", "args", ".", "n_meta", "\n", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "n_tasks", "=", "n_tasks", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "self", ".", "age", "=", "0", "\n", "\n", "self", ".", "bsz", "=", "args", ".", "replay_batch_size", "\n", "self", ".", "lr", "=", "args", ".", "lr", "\n", "self", ".", "adapt_", "=", "args", ".", "adapt", "\n", "self", ".", "grad_step", "=", "args", ".", "inner_steps", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "\n", "", "self", ".", "memories", "=", "args", ".", "n_memories", "\n", "self", ".", "steps", "=", "int", "(", "args", ".", "batches_per_example", ")", "\n", "self", ".", "beta", "=", "args", ".", "beta", "\n", "self", ".", "gamma", "=", "args", ".", "gamma", "\n", "\n", "# allocate buffer", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "if", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "224", ",", "224", ")", "\n", "", "elif", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "128", ",", "128", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "", "self", ".", "memy", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memx", "=", "self", ".", "memx", ".", "cuda", "(", ")", "\n", "self", ".", "memy", "=", "self", ".", "memy", ".", "cuda", "(", ")", "\n", "\n", "", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "current_task", "=", "0", "\n", "self", ".", "models", "=", "{", "}", "\n", "\n", "# handle gpus if specified", "\n", "self", ".", "cuda", "=", "args", ".", "cuda", "\n", "if", "self", ".", "cuda", ":", "\n", "            ", "self", ".", "net", "=", "self", ".", "net", ".", "cuda", "(", ")", "\n", "\n", "# meta params", "\n", "", "self", ".", "beta", "=", "args", ".", "beta", "\n", "self", ".", "adapt_lr", "=", "args", ".", "adapt_lr", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.compute_offsets": [[93, 101], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "(", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.forward": [[102, 121], ["ftml.Net.compute_offsets", "ftml.Net.net", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "'''\n        if self.net.training:\n            output = self.net(x)\n        else:\n            output = self.models[t](x)\n        '''", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "\n", "if", "self", ".", "adapt_", "and", "not", "self", ".", "net", ".", "training", ":", "\n", "            ", "output", "=", "self", ".", "models", "[", "t", "]", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "", "if", "self", ".", "is_cifar", ":", "\n", "            ", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.on_epoch_end": [[122, 124], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.getBatch": [[125, 134], ["None"], "methods", ["None"], ["", "def", "getBatch", "(", "self", ",", "t", ")", ":", "\n", "#data = [x for x in self.M if x[-1] == t]", "\n", "        ", "if", "self", ".", "net", ".", "training", "and", "t", "==", "self", ".", "current_task", ":", "\n", "            ", "xx", "=", "self", ".", "memx", "[", "t", ",", ":", "self", ".", "age", "]", "\n", "yy", "=", "self", ".", "memy", "[", "t", ",", ":", "self", ".", "age", "]", "\n", "", "else", ":", "\n", "            ", "xx", "=", "self", ".", "memx", "[", "t", ",", ":", "]", "\n", "yy", "=", "self", ".", "memy", "[", "t", ",", ":", "]", "\n", "", "return", "xx", ",", "yy", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.adapt": [[135, 157], ["print", "range", "copy.deepcopy", "torch.SGD", "torch.SGD", "torch.SGD", "ftml.Net.getBatch", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "range", "copy.deepcopy.parameters", "copy.deepcopy.zero_grad", "copy.deepcopy.forward", "ftml.Net.bce", "ftml.Net.backward", "torch.SGD.step"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.getBatch", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward"], ["", "def", "adapt", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Adapting'", ")", "\n", "for", "t", "in", "range", "(", "self", ".", "n_tasks", ")", ":", "\n", "            ", "model", "=", "deepcopy", "(", "self", ".", "net", ")", "\n", "opt", "=", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "self", ".", "adapt_lr", ")", "\n", "# data prepare  ", "\n", "xx", ",", "yy", "=", "self", ".", "getBatch", "(", "t", ")", "\n", "if", "t", ">", "self", ".", "current_task", ":", "\n", "                ", "self", ".", "models", "[", "t", "]", "=", "model", "\n", "continue", "\n", "", "train", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "xx", ",", "yy", ")", "\n", "loader", "=", "DataLoader", "(", "train", ",", "batch_size", "=", "self", ".", "bsz", ",", "shuffle", "=", "True", ",", "num_workers", "=", "0", ")", "\n", "\n", "for", "_", "in", "range", "(", "self", ".", "grad_step", ")", ":", "\n", "#for x, y in loader:", "\n", "                ", "model", ".", "zero_grad", "(", ")", "\n", "pred", "=", "model", ".", "forward", "(", "xx", ")", "\n", "loss", "=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "opt", ".", "step", "(", ")", "\n", "\n", "", "self", ".", "models", "[", "t", "]", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.observe": [[159, 208], ["ftml.Net.net.train", "y.data.size", "min", "ftml.Net.memx[].copy_", "ftml.Net.memy[].copy_", "copy.deepcopy", "range", "ftml.Net.net.state_dict", "ftml.Net.net.load_state_dict", "range", "ftml.Net.net.state_dict", "ftml.Net.net.zero_grad", "ftml.Net.forward", "ftml.Net.compute_offsets", "ftml.Net.bce", "ftml.Net.backward", "ftml.Net.opt.step", "numpy.random.choice", "ftml.Net.getBatch", "copy.deepcopy", "range", "ftml.Net.net.state_dict", "ftml.Net.net.load_state_dict", "copy.deepcopy.keys", "ftml.Net.net.state_dict", "ftml.Net.net.zero_grad", "ftml.Net.forward", "ftml.Net.compute_offsets", "ftml.Net.bce", "ftml.Net.backward", "ftml.Net.opt.step", "copy.deepcopy.keys", "copy.deepcopy.keys"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ftml.Net.getBatch", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "self", ".", "current_task", "=", "t", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "age", "=", "0", "\n", "\n", "", "self", ".", "net", ".", "train", "(", ")", "\n", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memx", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "memy", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "self", ".", "age", "+=", "effbsz", "\n", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "age", "=", "self", ".", "n_memories", "\n", "\n", "", "weights_before", "=", "deepcopy", "(", "self", ".", "net", ".", "state_dict", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "grad_step", ")", ":", "\n", "            ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "pred", "=", "self", ".", "forward", "(", "x", ",", "t", ")", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "pred", "=", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", "\n", "loss", "=", "self", ".", "bce", "(", "pred", ",", "y", "-", "offset1", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "", "weights_after", "=", "self", ".", "net", ".", "state_dict", "(", ")", "\n", "\n", "new_params", "=", "{", "name", ":", "weights_before", "[", "name", "]", "+", "(", "(", "weights_after", "[", "name", "]", "-", "weights_before", "[", "name", "]", ")", "*", "self", ".", "beta", ")", "for", "name", "in", "weights_before", ".", "keys", "(", ")", "}", "\n", "self", ".", "net", ".", "load_state_dict", "(", "new_params", ")", "\n", "# meta Update", "\n", "for", "_", "in", "range", "(", "self", ".", "n_meta", ")", ":", "\n", "            ", "idx", "=", "np", ".", "random", ".", "choice", "(", "t", "+", "1", ")", "\n", "xx", ",", "yy", "=", "self", ".", "getBatch", "(", "idx", ")", "\n", "weights_before", "=", "deepcopy", "(", "self", ".", "net", ".", "state_dict", "(", ")", ")", "\n", "beta", "=", "{", "k", ":", "self", ".", "beta", "for", "k", "in", "weights_before", ".", "keys", "(", ")", "}", "\n", "for", "tmp", "in", "range", "(", "self", ".", "grad_step", ")", ":", "\n", "                ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "pred", "=", "self", ".", "forward", "(", "xx", ",", "idx", ")", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "idx", ")", "\n", "pred", "=", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", "\n", "loss", "=", "self", ".", "bce", "(", "pred", ",", "yy", "-", "offset1", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "", "weights_after", "=", "self", ".", "net", ".", "state_dict", "(", ")", "\n", "new_params", "=", "{", "name", ":", "weights_before", "[", "name", "]", "+", "(", "(", "weights_after", "[", "name", "]", "-", "weights_before", "[", "name", "]", ")", "*", "beta", "[", "name", "]", ")", "for", "name", "in", "weights_before", ".", "keys", "(", ")", "}", "\n", "self", ".", "net", ".", "load_state_dict", "(", "new_params", ")", "\n", "", "return", "loss", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.icarl.Net.__init__": [[20, 59], ["super().__init__", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.KLDivLoss", "torch.nn.LogSoftmax", "torch.nn.Softmax", "int", "common.ResNet18", "resnet.ResNet18", "icarl.Net.parameters"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "nt", "=", "n_tasks", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "num_exemplars", "=", "0", "\n", "self", ".", "n_feat", "=", "n_outputs", "\n", "self", ".", "n_classes", "=", "n_outputs", "\n", "self", ".", "examples_seen", "=", "0", "\n", "\n", "# setup network", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "args", ".", "pretrained", ",", "n_outputs", ")", "\n", "# setup optimizer", "\n", "", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "kl", "=", "torch", ".", "nn", ".", "KLDivLoss", "(", ")", "# for distillation", "\n", "self", ".", "lsm", "=", "torch", ".", "nn", ".", "LogSoftmax", "(", "dim", "=", "1", ")", "\n", "self", ".", "sm", "=", "torch", ".", "nn", ".", "Softmax", "(", "dim", "=", "1", ")", "\n", "\n", "# memory", "\n", "self", ".", "memx", "=", "None", "# stores raw inputs, PxD", "\n", "self", ".", "memy", "=", "None", "\n", "self", ".", "mem_class_x", "=", "{", "}", "# stores exemplars class by class", "\n", "self", ".", "mem_class_y", "=", "{", "}", "\n", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "self", ".", "nc_per_task", "=", "int", "(", "n_outputs", "/", "n_tasks", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "current_task", "=", "0", "\n", "self", ".", "x", "=", "None", "\n", "", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.icarl.Net.compute_offsets": [[59, 63], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.icarl.Net.forward": [[64, 99], ["x.size", "icarl.Net.compute_offsets", "range", "torch.LongTensor", "icarl.Net.net().data.clone", "range", "torch.zeros", "range", "icarl.Net.mem_class_x.keys", "torch.Tensor().fill_", "out[].fill_", "torch.ones", "float", "means.cuda.cuda.cuda", "icarl.Net.net().data.mean", "dist.min", "ii.squeeze.squeeze.squeeze", "out.cuda.cuda.cuda", "out.cuda.cuda.cuda", "ii.squeeze.squeeze.item", "torch.Tensor", "icarl.Net.net", "icarl.Net.net", "preds[].expand", "int", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "# nearest neighbor", "\n", "        ", "nd", "=", "self", ".", "n_feat", "\n", "ns", "=", "x", ".", "size", "(", "0", ")", "\n", "if", "t", "*", "self", ".", "nc_per_task", "not", "in", "self", ".", "mem_class_x", ".", "keys", "(", ")", ":", "\n", "# no exemplar in memory yet, output uniform distr. over classes in", "\n", "# task t above, we check presence of first class for this task, we", "\n", "# should check them all", "\n", "            ", "out", "=", "torch", ".", "Tensor", "(", "ns", ",", "self", ".", "n_classes", ")", ".", "fill_", "(", "-", "10e10", ")", "\n", "out", "[", ":", ",", "int", "(", "t", "*", "self", ".", "nc_per_task", ")", ":", "int", "(", "(", "t", "+", "1", ")", "*", "self", ".", "nc_per_task", ")", "]", ".", "fill_", "(", "\n", "1.0", "/", "self", ".", "nc_per_task", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                ", "out", "=", "out", ".", "cuda", "(", ")", "\n", "", "return", "out", "\n", "", "means", "=", "torch", ".", "ones", "(", "self", ".", "nc_per_task", ",", "nd", ")", "*", "float", "(", "'inf'", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "            ", "means", "=", "means", ".", "cuda", "(", ")", "\n", "", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "for", "cc", "in", "range", "(", "offset1", ",", "offset2", ")", ":", "\n", "            ", "means", "[", "cc", "-", "\n", "offset1", "]", "=", "self", ".", "net", "(", "self", ".", "mem_class_x", "[", "cc", "]", ")", ".", "data", ".", "mean", "(", "0", ")", "\n", "", "classpred", "=", "torch", ".", "LongTensor", "(", "ns", ")", "\n", "preds", "=", "self", ".", "net", "(", "x", ")", ".", "data", ".", "clone", "(", ")", "\n", "for", "ss", "in", "range", "(", "ns", ")", ":", "\n", "            ", "dist", "=", "(", "means", "-", "preds", "[", "ss", "]", ".", "expand", "(", "self", ".", "nc_per_task", ",", "nd", ")", ")", ".", "norm", "(", "2", ",", "1", ")", "\n", "_", ",", "ii", "=", "dist", ".", "min", "(", "0", ")", "\n", "ii", "=", "ii", ".", "squeeze", "(", ")", "\n", "classpred", "[", "ss", "]", "=", "ii", ".", "item", "(", ")", "+", "offset1", "\n", "\n", "", "out", "=", "torch", ".", "zeros", "(", "ns", ",", "self", ".", "n_classes", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "            ", "out", "=", "out", ".", "cuda", "(", ")", "\n", "", "for", "ss", "in", "range", "(", "ns", ")", ":", "\n", "            ", "out", "[", "ss", ",", "classpred", "[", "ss", "]", "]", "=", "1", "\n", "", "return", "out", "# return 1-of-C code, ns x nc", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.icarl.Net.forward_training": [[100, 109], ["icarl.Net.net", "icarl.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward_training", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "# make sure we predict classes within the current task", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "            ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "            ", "output", "[", ":", ",", "offset2", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.icarl.Net.observe": [[111, 157], ["icarl.Net.net.train", "x.size", "icarl.Net.net.zero_grad", "icarl.Net.compute_offsets", "icarl.Net.bce", "icarl.Net.backward", "icarl.Net.opt.step", "icarl.Net.item", "x.data.clone", "y.data.clone", "range", "icarl.Net.memx.size", "torch.cat", "torch.cat", "icarl.Net.net", "torch.zeros", "torch.zeros", "icarl.Net.compute_offsets", "range", "list", "inp_dist.cuda.cuda.cuda", "target_dist.cuda.cuda.cuda", "random.randint", "[].clone", "[].clone", "x.data.clone", "y.data.clone", "x.size", "icarl.Net.kl", "len", "icarl.Net.lsm", "icarl.Net.sm", "icarl.Net.net"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "self", ".", "net", ".", "train", "(", ")", "\n", "self", ".", "examples_seen", "+=", "x", ".", "size", "(", "0", ")", "\n", "self", ".", "x", "=", "x", "\n", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "self", ".", "current_task", "=", "t", "\n", "", "if", "self", ".", "memx", "is", "None", ":", "\n", "            ", "self", ".", "memx", "=", "x", ".", "data", ".", "clone", "(", ")", "\n", "self", ".", "memy", "=", "y", ".", "data", ".", "clone", "(", ")", "\n", "", "elif", "self", ".", "memx", ".", "size", "(", "0", ")", "<", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "cat", "(", "(", "self", ".", "memx", ",", "x", ".", "data", ".", "clone", "(", ")", ")", ")", "\n", "self", ".", "memy", "=", "torch", ".", "cat", "(", "(", "self", ".", "memy", ",", "y", ".", "data", ".", "clone", "(", ")", ")", ")", "\n", "\n", "", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "loss", "=", "self", ".", "bce", "(", "(", "self", ".", "net", "(", "x", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ",", "\n", "y", "-", "offset1", ")", "\n", "\n", "if", "self", ".", "num_exemplars", ">", "0", ":", "\n", "# distillation", "\n", "            ", "for", "tt", "in", "range", "(", "t", ")", ":", "\n", "# first generate a minibatch with one example per class from", "\n", "# previous tasks", "\n", "                ", "sz", "=", "list", "(", "x", ".", "size", "(", ")", ")", "[", "1", ":", "]", "\n", "sz", "=", "[", "self", ".", "nc_per_task", "]", "+", "sz", "\n", "#inp_dist = torch.zeros(self.nc_per_task, x.size(1))", "\n", "inp_dist", "=", "torch", ".", "zeros", "(", "sz", ")", "\n", "target_dist", "=", "torch", ".", "zeros", "(", "self", ".", "nc_per_task", ",", "self", ".", "n_feat", ")", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "tt", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                    ", "inp_dist", "=", "inp_dist", ".", "cuda", "(", ")", "\n", "target_dist", "=", "target_dist", ".", "cuda", "(", ")", "\n", "", "for", "cc", "in", "range", "(", "self", ".", "nc_per_task", ")", ":", "\n", "                    ", "indx", "=", "random", ".", "randint", "(", "0", ",", "len", "(", "self", ".", "mem_class_x", "[", "cc", "+", "offset1", "]", ")", "-", "1", ")", "\n", "inp_dist", "[", "cc", "]", "=", "self", ".", "mem_class_x", "[", "cc", "+", "offset1", "]", "[", "indx", "]", ".", "clone", "(", ")", "\n", "target_dist", "[", "cc", "]", "=", "self", ".", "mem_class_y", "[", "cc", "+", "\n", "offset1", "]", "[", "indx", "]", ".", "clone", "(", ")", "\n", "# Add distillation loss", "\n", "", "loss", "+=", "self", ".", "reg", "*", "self", ".", "kl", "(", "\n", "self", ".", "lsm", "(", "self", ".", "net", "(", "inp_dist", ")", "\n", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ",", "\n", "self", ".", "sm", "(", "target_dist", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ")", "*", "self", ".", "nc_per_task", "\n", "# bprop and update", "\n", "", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.icarl.Net.on_epoch_end": [[158, 222], ["torch.LongTensor.size", "int", "icarl.Net.compute_offsets", "range", "icarl.Net.mem_class_x.keys", "torch.LongTensor", "torch.LongTensor", "all_labs[].cuda", "icarl.Net.memx.index_select", "torch.cat", "torch.cat.mean", "list", "torch.zeros", "icarl.Net.size", "torch.zeros", "[].data.clone", "range", "exemplars[].clone.clone", "icarl.Net.net().data.clone", "numpy.unique", "numpy.unique", "icarl.Net.x.size", "exemplars[].clone.cuda", "torch.zeros", "cost.sort", "icarl.Net.memy.cpu().numpy", "icarl.Net.memy.numpy", "len", "[].data.clone().sum.cuda", "[].data.clone().sum", "indx.size", "cdata[].clone", "exemplars[].clone", "indx.size", "all_labs[].cuda.item", "icarl.Net.mem_class_x.keys", "icarl.Net.net", "icarl.Net.split", "indx.size", "icarl.Net.net", "icarl.Net.memy.cpu", "icarl.Net.net", "[].data.clone", "torch.cat.mean.expand", "indx.size", "icarl.Net.net", "[].data.clone().sum.expand"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "self", ".", "examples_seen", "=", "0", "\n", "t", "=", "self", ".", "current_task", "\n", "# get labels from previous task; we assume labels are consecutive", "\n", "if", "self", ".", "gpu", ":", "\n", "            ", "all_labs", "=", "torch", ".", "LongTensor", "(", "np", ".", "unique", "(", "self", ".", "memy", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", ")", "\n", "", "else", ":", "\n", "            ", "all_labs", "=", "torch", ".", "LongTensor", "(", "np", ".", "unique", "(", "self", ".", "memy", ".", "numpy", "(", ")", ")", ")", "\n", "", "num_classes", "=", "all_labs", ".", "size", "(", "0", ")", "\n", "assert", "(", "num_classes", "==", "self", ".", "nc_per_task", ")", "\n", "# Reduce exemplar set by updating value of num. exemplars per class", "\n", "self", ".", "num_exemplars", "=", "int", "(", "self", ".", "n_memories", "/", "\n", "(", "num_classes", "+", "len", "(", "self", ".", "mem_class_x", ".", "keys", "(", ")", ")", ")", ")", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "for", "ll", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "lab", "=", "all_labs", "[", "ll", "]", ".", "cuda", "(", ")", "\n", "indxs", "=", "(", "self", ".", "memy", "==", "lab", ")", ".", "nonzero", "(", ")", ".", "squeeze", "(", ")", "\n", "cdata", "=", "self", ".", "memx", ".", "index_select", "(", "0", ",", "indxs", ")", "\n", "\n", "# Construct exemplar set for last task", "\n", "feat", "=", "torch", ".", "cat", "(", "[", "self", ".", "net", "(", "x", ")", "[", ":", ",", "offset1", ":", "offset2", "]", "for", "x", "in", "cdata", ".", "split", "(", "100", ",", "0", ")", "]", ",", "0", ")", "\n", "mean_feature", "=", "feat", ".", "mean", "(", "0", ")", "\n", "#mean_feature = self.net(cdata)[", "\n", "#    :, offset1: offset2].data.clone().mean(0)", "\n", "nd", "=", "self", ".", "nc_per_task", "\n", "sz", "=", "list", "(", "self", ".", "x", ".", "size", "(", ")", ")", "\n", "sz", "[", "0", "]", "=", "self", ".", "num_exemplars", "\n", "exemplars", "=", "torch", ".", "zeros", "(", "sz", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                ", "exemplars", "=", "exemplars", ".", "cuda", "(", ")", "\n", "", "ntr", "=", "cdata", ".", "size", "(", "0", ")", "\n", "# used to keep track of which examples we have already used", "\n", "taken", "=", "torch", ".", "zeros", "(", "ntr", ")", "\n", "model_output", "=", "self", ".", "net", "(", "cdata", ")", "[", "\n", ":", ",", "offset1", ":", "offset2", "]", ".", "data", ".", "clone", "(", ")", "\n", "for", "ee", "in", "range", "(", "self", ".", "num_exemplars", ")", ":", "\n", "                ", "prev", "=", "torch", ".", "zeros", "(", "1", ",", "nd", ")", "\n", "if", "self", ".", "gpu", ":", "\n", "                    ", "prev", "=", "prev", ".", "cuda", "(", ")", "\n", "", "if", "ee", ">", "0", ":", "\n", "                    ", "prev", "=", "self", ".", "net", "(", "exemplars", "[", ":", "ee", "]", ")", "[", "\n", ":", ",", "offset1", ":", "offset2", "]", ".", "data", ".", "clone", "(", ")", ".", "sum", "(", "0", ")", "\n", "", "cost", "=", "(", "mean_feature", ".", "expand", "(", "ntr", ",", "nd", ")", "-", "(", "model_output", "\n", "+", "prev", ".", "expand", "(", "ntr", ",", "nd", ")", ")", "/", "(", "ee", "+", "1", ")", ")", ".", "norm", "(", "2", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "_", ",", "indx", "=", "cost", ".", "sort", "(", "0", ")", "\n", "winner", "=", "0", "\n", "while", "winner", "<", "indx", ".", "size", "(", "0", ")", "and", "taken", "[", "indx", "[", "winner", "]", "]", "==", "1", ":", "\n", "                    ", "winner", "+=", "1", "\n", "", "if", "winner", "<", "indx", ".", "size", "(", "0", ")", ":", "\n", "                    ", "taken", "[", "indx", "[", "winner", "]", "]", "=", "1", "\n", "exemplars", "[", "ee", "]", "=", "cdata", "[", "indx", "[", "winner", "]", "]", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "                    ", "exemplars", "=", "exemplars", "[", ":", "indx", ".", "size", "(", "0", ")", ",", ":", "]", ".", "clone", "(", ")", "\n", "self", ".", "num_exemplars", "=", "indx", ".", "size", "(", "0", ")", "\n", "break", "\n", "# update memory with exemplars", "\n", "", "", "self", ".", "mem_class_x", "[", "lab", ".", "item", "(", ")", "]", "=", "exemplars", ".", "clone", "(", ")", "\n", "\n", "# recompute outputs for distillation purposes", "\n", "", "for", "cc", "in", "self", ".", "mem_class_x", ".", "keys", "(", ")", ":", "\n", "            ", "self", ".", "mem_class_y", "[", "cc", "]", "=", "self", ".", "net", "(", "\n", "self", ".", "mem_class_x", "[", "cc", "]", ")", ".", "data", ".", "clone", "(", ")", "\n", "", "self", ".", "memx", "=", "None", "\n", "self", ".", "memy", "=", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.lwf.Net.__init__": [[17, 69], ["super().__init__", "any", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "common.ResNet18", "lwf.Net.net.parameters", "resnet.ResNet18", "common.MLP", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "temp", "=", "args", ".", "temperature", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "True", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "#self.net = MLP([n_inputs] + [nh] * nl + [n_outputs])", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "if", "args", ".", "data_file", "==", "'notMNIST.pt'", ":", "\n", "                ", "self", ".", "is_cifar", "=", "True", "\n", "# setup optimizer", "\n", "", "", "self", ".", "lr", "=", "args", ".", "lr", "\n", "#if self.is_cifar:", "\n", "#    self.opt = torch.optim.Adam(self.net.parameters(), lr=self.lr)", "\n", "#else:", "\n", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "# setup memories", "\n", "self", ".", "current_task", "=", "0", "\n", "self", ".", "fisher", "=", "{", "}", "\n", "self", ".", "optpar", "=", "{", "}", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "\n", "#self.memx = torch.FloatTensor(n_tasks, self.n_memories, n_inputs)", "\n", "#self.memy = torch.FloatTensor(n_tasks, self.n_memories, n_outputs)", "\n", "self", ".", "mem", "=", "{", "}", "\n", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "kl", "=", "nn", ".", "KLDivLoss", "(", ")", "\n", "self", ".", "samples_seen", "=", "0", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "reg_keys", "=", "True", "\n", "", "def", "reset_optim", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.lwf.Net.reset_optim": [[69, 74], ["None"], "methods", ["None"], ["", "def", "reset_optim", "(", "self", ")", ":", "\n", "#if self.is_cifar:", "\n", "#    self.opt = torch.optim.Adam(self.net.parameters(), lr=self.lr)", "\n", "#else:", "\n", "        ", "self", ".", "reg_keys", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.lwf.Net.compute_offsets": [[75, 83], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.lwf.Net.on_epoch_end": [[84, 86], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "self", ".", "reg_keys", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.lwf.Net.forward": [[87, 97], ["lwf.Net.net", "lwf.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.lwf.Net.observe": [[98, 144], ["lwf.Net.net.zero_grad", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "lwf.Net.compute_offsets", "lwf.Net.net", "lwf.Net.bce", "loss.backward", "lwf.Net.opt.step", "loss.item", "lwf.Net.compute_offsets", "range", "lwf.Net.compute_offsets", "range", "lwf.Net.net", "x.size", "idx[].item", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "x.size", "lwf.Net.kl", "key_.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "idx[].item", "key_.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "observe", "(", "self", ",", "x", ",", "info", ",", "y", ")", ":", "\n", "        ", "t", "=", "info", "[", "0", "]", "\n", "idx", "=", "info", "[", "1", "]", "\n", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "self", ".", "current_task", "=", "t", "\n", "self", ".", "samples_seen", "=", "0", "\n", "self", ".", "mem", "=", "{", "}", "\n", "self", ".", "reg_keys", "=", "True", "\n", "\n", "", "if", "self", ".", "reg_keys", ":", "\n", "            ", "if", "t", "==", "0", ":", "return", "0", "\n", "tt", "=", "t", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "tt", ")", "\n", "pred", "=", "self", ".", "net", "(", "x", ")", "[", ":", ",", "offset1", ":", "offset2", "]", "\n", "for", "j", "in", "range", "(", "x", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "key", "=", "idx", "[", "j", "]", ".", "item", "(", ")", "\n", "self", ".", "mem", "[", "key", "]", "=", "pred", "[", "j", ",", ":", "]", ".", "data", "\n", "", "return", "0", "\n", "", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "loss1", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "loss2", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "loss3", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "pred", "=", "self", ".", "net", "(", "x", ")", "\n", "loss1", "=", "self", ".", "bce", "(", "(", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ",", "y", "-", "offset1", ")", "\n", "\n", "if", "t", ">", "0", ":", "\n", "            ", "tt", "=", "t", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "tt", ")", "\n", "key_y", "=", "None", "\n", "for", "j", "in", "range", "(", "x", ".", "size", "(", "0", ")", ")", ":", "\n", "                ", "x_", "=", "x", "[", "j", ",", ":", "]", "\n", "key_", "=", "self", ".", "mem", "[", "idx", "[", "j", "]", ".", "item", "(", ")", "]", "\n", "if", "key_y", "is", "None", ":", "\n", "                    ", "key_y", "=", "key_", ".", "unsqueeze", "(", "0", ")", "\n", "", "else", ":", "\n", "                    ", "key_y", "=", "torch", ".", "cat", "(", "[", "key_y", ",", "key_", ".", "unsqueeze", "(", "0", ")", "]", ",", "dim", "=", "0", ")", "\n", "\n", "", "", "prev_pred", "=", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", "\n", "loss2", "+=", "self", ".", "reg", "*", "self", ".", "kl", "(", "F", ".", "log_softmax", "(", "prev_pred", "/", "self", ".", "temp", ",", "dim", "=", "1", ")", ",", "key_y", ")", "\n", "", "loss", "=", "loss1", "+", "loss2", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "\n", "return", "loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.er.Net.__init__": [[18, 82], ["super().__init__", "any", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "common.ResNet18", "er.Net.net.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "er.Net.memx.cuda", "er.Net.memy.cuda", "er.Net.mem_feat.cuda", "resnet.ResNet18", "common.MLP", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "temp", "=", "args", ".", "temperature", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "args", ".", "pretrained", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "#self.net = MLP([n_inputs] + [nh] * nl + [n_outputs])", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "if", "args", ".", "data_file", "==", "'notMNIST.pt'", ":", "\n", "                ", "self", ".", "is_cifar", "=", "True", "\n", "# setup optimizer", "\n", "", "", "self", ".", "lr", "=", "args", ".", "lr", "\n", "#if self.is_cifar:", "\n", "#    self.opt = torch.optim.Adam(self.net.parameters(), lr=self.lr)", "\n", "#else:", "\n", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "# setup memories", "\n", "", "self", ".", "current_task", "=", "0", "\n", "self", ".", "fisher", "=", "{", "}", "\n", "self", ".", "optpar", "=", "{", "}", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "if", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "224", ",", "224", ")", "\n", "", "elif", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "128", ",", "128", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "", "self", ".", "memy", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ")", "\n", "self", ".", "mem_feat", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "self", ".", "nc_per_task", ")", "\n", "self", ".", "mem", "=", "{", "}", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memx", "=", "self", ".", "memx", ".", "cuda", "(", ")", "\n", "self", ".", "memy", "=", "self", ".", "memy", ".", "cuda", "(", ")", "\n", "self", ".", "mem_feat", "=", "self", ".", "mem_feat", ".", "cuda", "(", ")", "\n", "", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "bsz", "=", "args", ".", "batch_size", "\n", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "mse", "=", "nn", ".", "MSELoss", "(", ")", "\n", "self", ".", "kl", "=", "nn", ".", "KLDivLoss", "(", ")", "\n", "self", ".", "samples_seen", "=", "0", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "sz", "=", "args", ".", "replay_batch_size", "\n", "self", ".", "inner_steps", "=", "args", ".", "inner_steps", "\n", "", "def", "on_epoch_end", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.er.Net.on_epoch_end": [[82, 84], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.er.Net.compute_offsets": [[85, 93], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.er.Net.forward": [[94, 106], ["er.Net.net", "er.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ",", "return_feat", "=", "False", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.er.Net.memory_sampling": [[107, 124], ["min", "numpy.random.choice", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "xx.size", "torch.zeros.size", "torch.zeros.size", "torch.zeros.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros.long().cuda", "torch.zeros.long().cuda", "torch.zeros.long().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros.long", "torch.zeros.long", "torch.zeros.long", "er.Net.compute_offsets"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "memory_sampling", "(", "self", ",", "t", ")", ":", "\n", "        ", "mem_x", "=", "self", ".", "memx", "[", ":", "t", ",", ":", "]", "\n", "mem_y", "=", "self", ".", "memy", "[", ":", "t", ",", ":", "]", "\n", "mem_feat", "=", "self", ".", "mem_feat", "[", ":", "t", ",", ":", "]", "\n", "sz", "=", "min", "(", "self", ".", "n_memories", ",", "self", ".", "sz", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "t", "*", "self", ".", "n_memories", ",", "sz", ",", "False", ")", "\n", "t_idx", "=", "torch", ".", "from_numpy", "(", "idx", "/", "self", ".", "n_memories", ")", "\n", "s_idx", "=", "torch", ".", "from_numpy", "(", "idx", "%", "self", ".", "n_memories", ")", "\n", "\n", "offsets", "=", "torch", ".", "tensor", "(", "[", "self", ".", "compute_offsets", "(", "i", ")", "for", "i", "in", "t_idx", "]", ")", ".", "cuda", "(", ")", "\n", "xx", "=", "mem_x", "[", "t_idx", ",", "s_idx", "]", "\n", "yy", "=", "mem_y", "[", "t_idx", ",", "s_idx", "]", "-", "offsets", "[", ":", ",", "0", "]", "\n", "feat", "=", "mem_feat", "[", "t_idx", ",", "s_idx", "]", "\n", "mask", "=", "torch", ".", "zeros", "(", "xx", ".", "size", "(", "0", ")", ",", "self", ".", "nc_per_task", ")", "\n", "for", "j", "in", "range", "(", "mask", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "mask", "[", "j", "]", "=", "torch", ".", "arange", "(", "offsets", "[", "j", "]", "[", "0", "]", ",", "offsets", "[", "j", "]", "[", "1", "]", ")", "\n", "", "return", "xx", ",", "yy", ",", "feat", ",", "mask", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.er.Net.observe": [[124, 164], ["er.Net.net.train", "y.data.size", "min", "er.Net.memx[].copy_", "er.Net.memy[].copy_", "range", "loss.item", "er.Net.compute_offsets", "er.Net.forward", "er.Net.net.zero_grad", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "er.Net.compute_offsets", "er.Net.forward", "er.Net.bce", "loss.backward", "er.Net.opt.step", "er.Net.memory_sampling", "er.Net.net", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "er.Net.bce", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.memory_sampling"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "#t = info[0]", "\n", "#idx = info[1]", "\n", "        ", "self", ".", "net", ".", "train", "(", ")", "\n", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memx", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "memy", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "\n", "", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "tt", "=", "self", ".", "current_task", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "tt", ")", "\n", "out", "=", "self", ".", "forward", "(", "self", ".", "memx", "[", "tt", "]", ",", "tt", ",", "True", ")", "\n", "#self.mem_feat[tt] = F.softmax(out[:, offset1:offset2] / self.temp, dim=1 ).data.clone()", "\n", "self", ".", "current_task", "=", "t", "\n", "\n", "", "for", "_", "in", "range", "(", "self", ".", "inner_steps", ")", ":", "\n", "            ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "loss1", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "loss2", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "loss3", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "pred", "=", "self", ".", "forward", "(", "x", ",", "t", ",", "True", ")", "\n", "loss1", "=", "self", ".", "bce", "(", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "y", "-", "offset1", ")", "\n", "if", "t", ">", "0", ":", "\n", "                ", "xx", ",", "yy", ",", "target", ",", "mask", "=", "self", ".", "memory_sampling", "(", "t", ")", "\n", "pred_", "=", "self", ".", "net", "(", "xx", ")", "\n", "pred", "=", "torch", ".", "gather", "(", "pred_", ",", "1", ",", "mask", ")", "\n", "loss2", "+=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "\n", "", "loss", "=", "loss1", "+", "loss2", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "\n", "", "return", "loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.MLP.__init__": [[24, 35], ["torch.Module.__init__", "range", "torch.Sequential", "torch.Sequential", "common.MLP.net.apply", "int", "layers.append", "len", "torch.Linear", "torch.Linear", "layers.append", "len", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__"], ["    ", "def", "__init__", "(", "self", ",", "sizes", ")", ":", "\n", "        ", "super", "(", "MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "layers", "=", "[", "]", "\n", "sizes", "=", "[", "int", "(", "x", ")", "for", "x", "in", "sizes", "]", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "sizes", ")", "-", "1", ")", ":", "\n", "            ", "layers", ".", "append", "(", "nn", ".", "Linear", "(", "sizes", "[", "i", "]", ",", "sizes", "[", "i", "+", "1", "]", ")", ")", "\n", "if", "i", "<", "(", "len", "(", "sizes", ")", "-", "2", ")", ":", "\n", "                ", "layers", ".", "append", "(", "nn", ".", "ReLU", "(", ")", ")", "\n", "\n", "", "", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "self", ".", "net", ".", "apply", "(", "Xavier", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.MLP.forward": [[36, 38], ["common.MLP.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "net", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.block.__init__": [[40, 44], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "common.block.net.apply", "torch.Linear", "torch.Linear", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_in", ",", "n_out", ")", ":", "\n", "        ", "super", "(", "block", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "*", "[", "nn", ".", "Linear", "(", "n_in", ",", "n_out", ")", ",", "nn", ".", "ReLU", "(", ")", "]", ")", "\n", "self", ".", "net", ".", "apply", "(", "Xavier", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.block.forward": [[45, 47], ["common.block.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "net", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.BasicBlock.__init__": [[57, 70], ["torch.Module.__init__", "common.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "common.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3"], ["def", "__init__", "(", "self", ",", "in_planes", ",", "planes", ",", "stride", "=", "1", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "in_planes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "\n", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", ")", "\n", "if", "stride", "!=", "1", "or", "in_planes", "!=", "self", ".", "expansion", "*", "planes", ":", "\n", "            ", "self", ".", "shortcut", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_planes", ",", "self", ".", "expansion", "*", "planes", ",", "kernel_size", "=", "1", ",", "\n", "stride", "=", "stride", ",", "bias", "=", "False", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "expansion", "*", "planes", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.BasicBlock.forward": [[72, 78], ["torch.nn.functional.relu", "torch.nn.functional.relu", "common.BasicBlock.bn2", "common.BasicBlock.shortcut", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.BasicBlock.bn1", "common.BasicBlock.conv2", "common.BasicBlock.conv1"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "out", "=", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "out", "=", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "out", ")", ")", "\n", "out", "+=", "self", ".", "shortcut", "(", "x", ")", "\n", "out", "=", "relu", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.ResNet.__init__": [[82, 94], ["torch.Module.__init__", "common.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.MaxPool2d", "torch.MaxPool2d", "common.ResNet._make_layer", "common.ResNet._make_layer", "common.ResNet._make_layer", "common.ResNet._make_layer", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "num_blocks", ",", "num_classes", ",", "nf", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_planes", "=", "nf", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "3", ",", "nf", "*", "1", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "nf", "*", "1", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "1", ",", "num_blocks", "[", "0", "]", ",", "stride", "=", "1", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "2", ",", "num_blocks", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "4", ",", "num_blocks", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "nf", "*", "8", ",", "num_blocks", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "nf", "*", "8", "*", "block", ".", "expansion", ",", "int", "(", "num_classes", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.ResNet._make_layer": [[95, 102], ["torch.Sequential", "torch.Sequential", "layers.append", "common.block"], "methods", ["None"], ["", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "num_blocks", ",", "stride", ")", ":", "\n", "        ", "strides", "=", "[", "stride", "]", "+", "[", "1", "]", "*", "(", "num_blocks", "-", "1", ")", "\n", "layers", "=", "[", "]", "\n", "for", "stride", "in", "strides", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "in_planes", ",", "planes", ",", "stride", ")", ")", "\n", "self", ".", "in_planes", "=", "planes", "*", "block", ".", "expansion", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.ResNet.forward": [[103, 121], ["x.view.view.size", "common.ResNet.conv1", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.ResNet.maxpool", "common.ResNet.layer1", "common.ResNet.layer2", "common.ResNet.layer3", "common.ResNet.layer4", "common.ResNet.avgpool", "common.ResNet.view", "common.ResNet.linear", "x.view.view.dim", "x.view.view.view", "common.ResNet.bn1", "common.ResNet.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "return_feat", "=", "False", ")", ":", "\n", "        ", "bsz", "=", "x", ".", "size", "(", "0", ")", "\n", "if", "x", ".", "dim", "(", ")", "<", "4", ":", "\n", "            ", "x", "=", "x", ".", "view", "(", "bsz", ",", "3", ",", "32", ",", "32", ")", "\n", "", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "relu", "(", "self", ".", "bn1", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "maxpool", "(", "out", ")", "\n", "out", "=", "self", ".", "layer1", "(", "out", ")", "\n", "out", "=", "self", ".", "layer2", "(", "out", ")", "\n", "out", "=", "self", ".", "layer3", "(", "out", ")", "\n", "out", "=", "self", ".", "layer4", "(", "out", ")", "\n", "out", "=", "self", ".", "avgpool", "(", "out", ")", "\n", "feat", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "y", "=", "self", ".", "linear", "(", "feat", ")", "\n", "if", "return_feat", ":", "\n", "            ", "y", "=", "[", "feat", ",", "y", "]", "\n", "\n", "", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.CNN.__init__": [[130, 143], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.MaxPool2d", "torch.MaxPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_tasks", "=", "10", ",", "n_out", "=", "10", ")", ":", "\n", "        ", "super", "(", "CNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "32", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "padding", "=", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "32", ",", "32", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "32", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "bias", "=", "True", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv2d", "(", "64", ",", "64", ",", "kernel_size", "=", "3", ",", "stride", "=", "1", ",", "bias", "=", "True", ")", "\n", "\n", "self", ".", "pool2d", "=", "nn", ".", "MaxPool2d", "(", "2", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "1600", ",", "512", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "512", ",", "100", ")", "\n", "self", ".", "dropout1", "=", "nn", ".", "Dropout", "(", "0.25", ")", "\n", "self", ".", "dropout2", "=", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.CNN.forward": [[143, 160], ["x.size", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.CNN.pool2d", "common.CNN.dropout1", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.CNN.pool2d", "common.CNN.dropout1", "common.CNN.view", "torch.nn.functional.relu", "torch.nn.functional.relu", "common.CNN.dropout2", "common.CNN.linear2", "common.CNN.conv1", "common.CNN.conv2", "common.CNN.conv3", "common.CNN.conv4", "common.CNN.size", "common.CNN.linear1", "x.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "bsz", "=", "x", ".", "size", "(", "0", ")", "\n", "out", "=", "relu", "(", "self", ".", "conv1", "(", "x", ".", "view", "(", "bsz", ",", "3", ",", "32", ",", "32", ")", ")", ")", "\n", "out", "=", "relu", "(", "self", ".", "conv2", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "pool2d", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout1", "(", "out", ")", "\n", "\n", "out", "=", "relu", "(", "self", ".", "conv3", "(", "out", ")", ")", "\n", "out", "=", "relu", "(", "self", ".", "conv4", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "pool2d", "(", "out", ")", "\n", "out", "=", "self", ".", "dropout1", "(", "out", ")", "\n", "\n", "out", "=", "out", ".", "view", "(", "out", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "out", "=", "relu", "(", "self", ".", "linear1", "(", "out", ")", ")", "\n", "out", "=", "self", ".", "dropout2", "(", "out", ")", "\n", "out", "=", "self", ".", "linear2", "(", "out", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.Xavier": [[14, 21], ["m.weight.data.uniform_", "m.bias.data.fill_", "m.weight.data.size", "m.weight.data.size", "math.sqrt", "math.sqrt"], "function", ["None"], ["def", "Xavier", "(", "m", ")", ":", "\n", "    ", "if", "m", ".", "__class__", ".", "__name__", "==", "'Linear'", ":", "\n", "        ", "fan_in", ",", "fan_out", "=", "m", ".", "weight", ".", "data", ".", "size", "(", "1", ")", ",", "m", ".", "weight", ".", "data", ".", "size", "(", "0", ")", "\n", "std", "=", "1.0", "*", "math", ".", "sqrt", "(", "2.0", "/", "(", "fan_in", "+", "fan_out", ")", ")", "\n", "a", "=", "math", ".", "sqrt", "(", "3.0", ")", "*", "std", "\n", "m", ".", "weight", ".", "data", ".", "uniform_", "(", "-", "a", ",", "a", ")", "\n", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.conv3x3": [[49, 52], ["torch.Conv2d"], "function", ["None"], ["", "", "def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.ResNet18": [[123, 125], ["common.ResNet"], "function", ["None"], ["", "", "def", "ResNet18", "(", "num_classes", ",", "nf", "=", "20", ")", ":", "\n", "    ", "return", "ResNet", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "num_classes", ",", "nf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.ResNet32": [[126, 128], ["common.ResNet"], "function", ["None"], ["", "def", "ResNet32", "(", "num_classes", ",", "nf", "=", "64", ")", ":", "\n", "    ", "return", "ResNet", "(", "BasicBlock", ",", "[", "3", ",", "4", ",", "6", ",", "3", "]", ",", "num_classes", ",", "nf", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.common.Flatten": [[161, 163], ["x.view", "x.size"], "function", ["None"], ["", "", "def", "Flatten", "(", "x", ")", ":", "\n", "    ", "return", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.__init__": [[20, 85], ["super().__init__", "any", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "common.ResNet18", "bcl_single.Net.net.parameters", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "bcl_single.Net.memx.cuda", "bcl_single.Net.memy.cuda", "bcl_single.Net.mem_feat.cuda", "resnet.ResNet18", "common.MLP", "bcl_single.Net.net.cuda", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "temp", "=", "args", ".", "temperature", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "True", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "self", ".", "net", ".", "cuda", "(", ")", "\n", "if", "args", ".", "data_file", "==", "'notMNIST.pt'", ":", "\n", "                ", "self", ".", "is_cifar", "=", "True", "\n", "\n", "", "", "self", ".", "lr", "=", "args", ".", "lr", "\n", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "int", "(", "n_outputs", "/", "n_tasks", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "# setup memories", "\n", "", "self", ".", "current_task", "=", "0", "\n", "self", ".", "fisher", "=", "{", "}", "\n", "self", ".", "optpar", "=", "{", "}", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "n_tasks", "=", "n_tasks", "\n", "if", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "224", ",", "224", ")", "\n", "", "elif", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "84", ",", "84", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "", "self", ".", "memy", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ")", "\n", "self", ".", "mem_feat", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "self", ".", "nc_per_task", ")", "\n", "self", ".", "mem", "=", "{", "}", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memx", "=", "self", ".", "memx", ".", "cuda", "(", ")", "\n", "self", ".", "memy", "=", "self", ".", "memy", ".", "cuda", "(", ")", "\n", "self", ".", "mem_feat", "=", "self", ".", "mem_feat", ".", "cuda", "(", ")", "\n", "", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "bsz", "=", "args", ".", "replay_batch_size", "\n", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "mse", "=", "nn", ".", "MSELoss", "(", ")", "\n", "self", ".", "kl", "=", "nn", ".", "KLDivLoss", "(", ")", "\n", "self", ".", "samples_seen", "=", "0", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "sz", "=", "args", ".", "replay_batch_size", "\n", "self", ".", "inner_steps", "=", "args", ".", "inner_steps", "\n", "self", ".", "beta", "=", "args", ".", "beta", "\n", "self", ".", "adapt_", "=", "args", ".", "adapt", "\n", "self", ".", "adapt_lr", "=", "args", ".", "adapt_lr", "\n", "self", ".", "models", "=", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.on_epoch_end": [[86, 88], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.adapt": [[89, 109], ["print", "range", "copy.deepcopy", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "range", "copy.deepcopy.parameters", "copy.deepcopy.zero_grad", "copy.deepcopy.forward", "bcl_single.Net.bce", "bcl_single.Net.backward", "torch.optim.SGD.step", "torch.optim.SGD.step", "torch.optim.SGD.step"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward"], ["", "def", "adapt", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Adapting'", ")", "\n", "for", "t", "in", "range", "(", "self", ".", "n_tasks", ")", ":", "\n", "            ", "model", "=", "deepcopy", "(", "self", ".", "net", ")", "\n", "if", "t", ">", "self", ".", "current_task", ":", "\n", "                ", "self", ".", "models", "[", "t", "]", "=", "model", "\n", "continue", "\n", "", "xx", "=", "self", ".", "memx", "[", "t", "]", "\n", "yy", "=", "self", ".", "memy", "[", "t", "]", "\n", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "self", ".", "adapt_lr", ")", "\n", "train", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "xx", ",", "yy", ")", "\n", "loader", "=", "DataLoader", "(", "train", ",", "batch_size", "=", "self", ".", "bsz", ",", "shuffle", "=", "True", ",", "num_workers", "=", "0", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "inner_steps", ")", ":", "\n", "#for x,y in loader:", "\n", "                ", "model", ".", "zero_grad", "(", ")", "\n", "pred", "=", "model", ".", "forward", "(", "xx", ")", "\n", "loss", "=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "opt", ".", "step", "(", ")", "\n", "", "self", ".", "models", "[", "t", "]", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.compute_offsets": [[110, 118], ["int", "int"], "methods", ["None"], ["", "", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.forward": [[119, 133], ["bcl_single.Net.net", "bcl_single.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ",", "return_feat", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "adapt_", "and", "not", "self", ".", "net", ".", "training", ":", "\n", "            ", "output", "=", "self", ".", "models", "[", "t", "]", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.memory_sampling": [[134, 151], ["min", "numpy.random.choice", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "xx.size", "torch.zeros.size", "torch.zeros.size", "torch.zeros.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros.long().cuda", "torch.zeros.long().cuda", "torch.zeros.long().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros.long", "torch.zeros.long", "torch.zeros.long", "bcl_single.Net.compute_offsets"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "memory_sampling", "(", "self", ",", "t", ")", ":", "\n", "        ", "mem_x", "=", "self", ".", "memx", "[", ":", "t", ",", ":", "]", "\n", "mem_y", "=", "self", ".", "memy", "[", ":", "t", ",", ":", "]", "\n", "mem_feat", "=", "self", ".", "mem_feat", "[", ":", "t", ",", ":", "]", "\n", "sz", "=", "min", "(", "self", ".", "sz", ",", "self", ".", "n_memories", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "t", "*", "self", ".", "n_memories", ",", "sz", ",", "False", ")", "\n", "t_idx", "=", "torch", ".", "from_numpy", "(", "idx", "//", "self", ".", "n_memories", ")", "\n", "s_idx", "=", "torch", ".", "from_numpy", "(", "idx", "%", "self", ".", "n_memories", ")", "\n", "\n", "offsets", "=", "torch", ".", "tensor", "(", "[", "self", ".", "compute_offsets", "(", "i", ")", "for", "i", "in", "t_idx", "]", ")", ".", "cuda", "(", ")", "\n", "xx", "=", "mem_x", "[", "t_idx", ",", "s_idx", "]", "\n", "yy", "=", "mem_y", "[", "t_idx", ",", "s_idx", "]", "-", "offsets", "[", ":", ",", "0", "]", "\n", "feat", "=", "mem_feat", "[", "t_idx", ",", "s_idx", "]", "\n", "mask", "=", "torch", ".", "zeros", "(", "xx", ".", "size", "(", "0", ")", ",", "self", ".", "nc_per_task", ")", "\n", "for", "j", "in", "range", "(", "mask", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "mask", "[", "j", "]", "=", "torch", ".", "arange", "(", "offsets", "[", "j", "]", "[", "0", "]", ",", "offsets", "[", "j", "]", "[", "1", "]", ")", "\n", "", "return", "xx", ",", "yy", ",", "feat", ",", "mask", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_single.Net.observe": [[151, 193], ["bcl_single.Net.net.train", "y.data.size", "min", "bcl_single.Net.memx[].copy_", "bcl_single.Net.memy[].copy_", "copy.deepcopy", "range", "bcl_single.Net.net.state_dict", "bcl_single.Net.net.load_state_dict", "loss.item", "bcl_single.Net.compute_offsets", "bcl_single.Net.forward", "torch.softmax().data.clone", "torch.softmax().data.clone", "torch.softmax().data.clone", "bcl_single.Net.net.state_dict", "bcl_single.Net.net.zero_grad", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "bcl_single.Net.compute_offsets", "bcl_single.Net.forward", "bcl_single.Net.bce", "loss.backward", "bcl_single.Net.opt.step", "bcl_single.Net.memory_sampling", "bcl_single.Net.net", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "bcl_single.Net.bce", "copy.deepcopy.keys", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "bcl_single.Net.kl", "torch.softmax", "torch.softmax", "torch.softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.memory_sampling"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "tt", "=", "self", ".", "current_task", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "tt", ")", "\n", "out", "=", "self", ".", "forward", "(", "self", ".", "memx", "[", "tt", "]", ",", "tt", ",", "True", ")", "\n", "self", ".", "mem_feat", "[", "tt", "]", "=", "F", ".", "softmax", "(", "out", "[", ":", ",", "offset1", ":", "offset2", "]", "/", "self", ".", "temp", ",", "dim", "=", "1", ")", ".", "data", ".", "clone", "(", ")", "\n", "self", ".", "current_task", "=", "t", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "", "self", ".", "net", ".", "train", "(", ")", "\n", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memx", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "memy", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "\n", "", "weights_before", "=", "deepcopy", "(", "self", ".", "net", ".", "state_dict", "(", ")", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "inner_steps", ")", ":", "\n", "            ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "loss1", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "loss2", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "loss3", "=", "torch", ".", "tensor", "(", "0.", ")", ".", "cuda", "(", ")", "\n", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "pred", "=", "self", ".", "forward", "(", "x", ",", "t", ",", "True", ")", "\n", "loss1", "=", "self", ".", "bce", "(", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "y", "-", "offset1", ")", "\n", "if", "t", ">", "0", ":", "\n", "                ", "xx", ",", "yy", ",", "target", ",", "mask", "=", "self", ".", "memory_sampling", "(", "t", ")", "\n", "pred_", "=", "self", ".", "net", "(", "xx", ")", "\n", "pred", "=", "torch", ".", "gather", "(", "pred_", ",", "1", ",", "mask", ")", "\n", "loss2", "+=", "self", ".", "reg", "*", "self", ".", "kl", "(", "F", ".", "log_softmax", "(", "pred", "/", "self", ".", "temp", ",", "dim", "=", "1", ")", ",", "target", ")", "\n", "loss2", "+=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "\n", "", "loss", "=", "loss1", "+", "loss2", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "", "weights_after", "=", "self", ".", "net", ".", "state_dict", "(", ")", "\n", "new_params", "=", "{", "name", ":", "weights_before", "[", "name", "]", "+", "(", "(", "weights_after", "[", "name", "]", "-", "weights_before", "[", "name", "]", ")", "*", "self", ".", "beta", ")", "for", "name", "in", "weights_before", ".", "keys", "(", ")", "}", "\n", "self", ".", "net", ".", "load_state_dict", "(", "new_params", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.__init__": [[21, 102], ["super().__init__", "any", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "int", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.FloatTensor().fill_", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "common.ResNet18", "bcl_dual.Net.net.parameters", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "bcl_dual.Net.memy.cuda().fill_", "bcl_dual.Net.memx.cuda().fill_", "bcl_dual.Net.mem_feat.cuda", "bcl_dual.Net.valx.cuda().fill_", "bcl_dual.Net.valy.cuda().fill_", "resnet.ResNet18", "common.MLP", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "str", "bcl_dual.Net.memy.cuda", "bcl_dual.Net.memx.cuda", "bcl_dual.Net.valx.cuda", "bcl_dual.Net.valy.cuda"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_tasks", "=", "n_tasks", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "temp", "=", "args", ".", "temperature", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "True", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "#self.net = MLP([n_inputs] + [nh] * nl + [n_outputs])", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "#self.net = ContextMLP(784,int(args.nh),10)", "\n", "if", "args", ".", "data_file", "==", "'notMNIST.pt'", ":", "\n", "                ", "self", ".", "is_cifar", "=", "True", "\n", "# setup optimizer", "\n", "", "", "self", ".", "inner_lr", "=", "args", ".", "lr", "\n", "self", ".", "beta", "=", "args", ".", "beta", "\n", "#self.outer_opt = torch.optim.SGD(self.net.parameters(), lr=self.outer_lr)", "\n", "self", ".", "inner_opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "inner_lr", ")", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "int", "(", "n_outputs", "/", "n_tasks", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "# setup memories", "\n", "", "self", ".", "current_task", "=", "0", "\n", "self", ".", "fisher", "=", "{", "}", "\n", "self", ".", "optpar", "=", "{", "}", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "\n", "self", ".", "n_val", "=", "int", "(", "self", ".", "n_memories", "*", "0.2", ")", "\n", "self", ".", "n_memories", "-=", "self", ".", "n_val", "\n", "\n", "if", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "224", ",", "224", ")", "\n", "self", ".", "valx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_val", ",", "3", ",", "224", ",", "224", ")", "\n", "", "elif", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "84", ",", "84", ")", "\n", "self", ".", "valx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_val", ",", "3", ",", "84", ",", "84", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "self", ".", "valx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_val", ",", "n_inputs", ")", "\n", "", "self", ".", "memy", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ")", "\n", "self", ".", "mem_feat", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "self", ".", "nc_per_task", ")", ".", "fill_", "(", "0", ")", "\n", "self", ".", "valy", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_val", ")", "\n", "self", ".", "mem", "=", "{", "}", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memy", "=", "self", ".", "memy", ".", "cuda", "(", ")", ".", "fill_", "(", "0", ")", "\n", "self", ".", "memx", "=", "self", ".", "memx", ".", "cuda", "(", ")", ".", "fill_", "(", "0", ")", "\n", "self", ".", "mem_feat", "=", "self", ".", "mem_feat", ".", "cuda", "(", ")", "\n", "self", ".", "valx", "=", "self", ".", "valx", ".", "cuda", "(", ")", ".", "fill_", "(", "0", ")", "\n", "self", ".", "valy", "=", "self", ".", "valy", ".", "cuda", "(", ")", ".", "fill_", "(", "0", ")", "\n", "\n", "", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "val_cnt", "=", "0", "\n", "self", ".", "bsz", "=", "args", ".", "batch_size", "\n", "self", ".", "valid_id", "=", "[", "]", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "mse", "=", "nn", ".", "MSELoss", "(", ")", "\n", "self", ".", "kl", "=", "nn", ".", "KLDivLoss", "(", ")", "\n", "self", ".", "samples_seen", "=", "0", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "sz", "=", "args", ".", "replay_batch_size", "\n", "self", ".", "inner_steps", "=", "args", ".", "inner_steps", "\n", "self", ".", "n_meta", "=", "args", ".", "n_meta", "\n", "self", ".", "count", "=", "0", "\n", "self", ".", "val_count", "=", "0", "\n", "self", ".", "adapt_", "=", "args", ".", "adapt", "\n", "self", ".", "adapt_lr", "=", "args", ".", "adapt_lr", "\n", "self", ".", "models", "=", "{", "}", "\n", "", "def", "on_epoch_end", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.on_epoch_end": [[102, 104], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.adapt": [[105, 124], ["print", "range", "copy.deepcopy", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "range", "copy.deepcopy.parameters", "copy.deepcopy.zero_grad", "copy.deepcopy.forward", "bcl_dual.Net.bce", "bcl_dual.Net.backward", "torch.optim.SGD.step", "torch.optim.SGD.step", "torch.optim.SGD.step"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward"], ["", "def", "adapt", "(", "self", ")", ":", "\n", "        ", "print", "(", "'Adapting'", ")", "\n", "for", "t", "in", "range", "(", "self", ".", "n_tasks", ")", ":", "\n", "            ", "model", "=", "deepcopy", "(", "self", ".", "net", ")", "\n", "if", "t", ">", "self", ".", "current_task", ":", "\n", "                ", "self", ".", "models", "[", "t", "]", "=", "model", "\n", "continue", "\n", "", "xx", "=", "self", ".", "memx", "[", "t", "]", "\n", "yy", "=", "self", ".", "memy", "[", "t", "]", "\n", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "model", ".", "parameters", "(", ")", ",", "self", ".", "adapt_lr", ")", "\n", "train", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "xx", ",", "yy", ")", "\n", "loader", "=", "DataLoader", "(", "train", ",", "batch_size", "=", "self", ".", "bsz", ",", "shuffle", "=", "True", ",", "num_workers", "=", "0", ")", "\n", "for", "_", "in", "range", "(", "self", ".", "inner_steps", ")", ":", "\n", "                ", "model", ".", "zero_grad", "(", ")", "\n", "pred", "=", "model", ".", "forward", "(", "xx", ")", "\n", "loss", "=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "opt", ".", "step", "(", ")", "\n", "", "self", ".", "models", "[", "t", "]", "=", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.compute_offsets": [[126, 134], ["int", "int"], "methods", ["None"], ["", "", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.forward": [[135, 150], ["bcl_dual.Net.net", "bcl_dual.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ",", "return_feat", "=", "False", ")", ":", "\n", "        ", "if", "self", ".", "adapt_", "and", "not", "self", ".", "net", ".", "training", ":", "\n", "            ", "output", "=", "self", ".", "models", "[", "t", "]", "(", "x", ")", "\n", "", "else", ":", "\n", "            ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.memory_sampling": [[151, 190], ["torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "mask.long().cuda.long().cuda.long().cuda", "min", "numpy.random.choice", "numpy.array.tolist", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "min", "numpy.random.choice", "numpy.array", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "xx.size", "mask.long().cuda.long().cuda.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.from_numpy.tolist", "torch.from_numpy.tolist", "torch.from_numpy.tolist", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "mask.long().cuda.long().cuda.long", "bcl_dual.Net.compute_offsets"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "memory_sampling", "(", "self", ",", "t", ",", "valid", "=", "False", ")", ":", "\n", "        ", "'''  \n        if t == self.current_task:\n            val_idx = self.val_count\n            mem_idx = self.count\n        else:\n            val_idx = self.n_val + 1\n            mem_idx = self.count + 1\n        t + = 1\n        '''", "\n", "if", "valid", ":", "\n", "            ", "mem_x", "=", "self", ".", "valx", "[", ":", "t", ",", ":", "]", "\n", "mem_y", "=", "self", ".", "valy", "[", ":", "t", ",", ":", "]", "\n", "mem_feat", "=", "self", ".", "mem_feat", "[", ":", "t", ",", ":", "]", "\n", "sz", "=", "min", "(", "t", "*", "self", ".", "n_val", ",", "self", ".", "sz", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "t", "*", "self", ".", "n_val", ",", "sz", ",", "False", ")", "\n", "self", ".", "valid_id", "=", "idx", ".", "tolist", "(", ")", "\n", "t_idx", "=", "torch", ".", "from_numpy", "(", "idx", "//", "self", ".", "n_val", ")", "\n", "s_idx", "=", "torch", ".", "from_numpy", "(", "idx", "%", "self", ".", "n_val", ")", "\n", "", "else", ":", "\n", "            ", "mem_x", "=", "self", ".", "memx", "[", ":", "t", ",", ":", "]", "\n", "mem_y", "=", "self", ".", "memy", "[", ":", "t", ",", ":", "]", "\n", "mem_feat", "=", "self", ".", "mem_feat", "[", ":", "t", ",", ":", "]", "\n", "sz", "=", "min", "(", "self", ".", "n_memories", ",", "self", ".", "sz", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "t", "*", "self", ".", "n_memories", ",", "sz", ",", "False", ")", "\n", "idx", "=", "[", "x", "for", "x", "in", "idx", "if", "x", "not", "in", "self", ".", "valid_id", "]", "\n", "idx", "=", "np", ".", "array", "(", "idx", ")", "\n", "t_idx", "=", "torch", ".", "from_numpy", "(", "idx", "//", "self", ".", "n_memories", ")", "\n", "s_idx", "=", "torch", ".", "from_numpy", "(", "idx", "%", "self", ".", "n_memories", ")", "\n", "\n", "", "offsets", "=", "torch", ".", "tensor", "(", "[", "self", ".", "compute_offsets", "(", "i", ")", "for", "i", "in", "t_idx", "]", ")", ".", "cuda", "(", ")", "\n", "xx", "=", "mem_x", "[", "t_idx", ",", "s_idx", "]", "\n", "yy", "=", "mem_y", "[", "t_idx", ",", "s_idx", "]", "-", "offsets", "[", ":", ",", "0", "]", "\n", "feat", "=", "mem_feat", "[", "t_idx", ",", "s_idx", "]", "\n", "mask", "=", "torch", ".", "zeros", "(", "xx", ".", "size", "(", "0", ")", ",", "self", ".", "nc_per_task", ")", "\n", "for", "j", "in", "range", "(", "mask", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "mask", "[", "j", "]", "=", "torch", ".", "arange", "(", "offsets", "[", "j", "]", "[", "0", "]", ",", "offsets", "[", "j", "]", "[", "1", "]", ")", "\n", "", "mask", "=", "mask", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "return", "xx", ",", "yy", ",", "feat", ",", "mask", ",", "t_idx", ".", "tolist", "(", ")", "\n", "", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.bcl_dual.Net.observe": [[190, 268], ["bcl_dual.Net.net.train", "torch.cat.data.size", "torch.cat.data.size", "torch.cat.data.size", "min", "bcl_dual.Net.memx[].copy_", "bcl_dual.Net.memy[].copy_", "bcl_dual.Net.zero_grad", "range", "bcl_dual.Net.item", "bcl_dual.Net.compute_offsets", "bcl_dual.Net.forward", "torch.softmax().data.clone", "torch.softmax().data.clone", "torch.softmax().data.clone", "bcl_dual.Net.valx[].copy_", "bcl_dual.Net.valy[].copy_", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "bcl_dual.Net.valx[].copy_", "bcl_dual.Net.valy[].copy_", "bcl_dual.Net.memx[].copy_", "bcl_dual.Net.memy[].copy_", "copy.deepcopy", "bcl_dual.Net.compute_offsets", "range", "bcl_dual.Net.memory_sampling", "bcl_dual.Net.net", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "bcl_dual.Net.bce", "bcl_dual.Net.backward", "bcl_dual.Net.inner_opt.step", "bcl_dual.Net.zero_grad", "bcl_dual.Net.net.state_dict", "bcl_dual.Net.net.load_state_dict", "bcl_dual.Net.net.state_dict", "bcl_dual.Net.forward", "bcl_dual.Net.bce", "loss.backward", "bcl_dual.Net.inner_opt.step", "bcl_dual.Net.valx[].unsqueeze_", "bcl_dual.Net.valy[].unsqueeze_", "bcl_dual.Net.memory_sampling", "bcl_dual.Net.net", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "bcl_dual.Net.bce", "copy.deepcopy.keys", "torch.softmax", "torch.softmax", "torch.softmax", "bcl_dual.Net.kl", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.memory_sampling", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.memory_sampling"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "tt", "=", "self", ".", "current_task", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "tt", ")", "\n", "out", "=", "self", ".", "forward", "(", "self", ".", "memx", "[", "tt", "]", ",", "tt", ",", "True", ")", "\n", "self", ".", "mem_feat", "[", "tt", "]", "=", "F", ".", "softmax", "(", "out", "[", ":", ",", "offset1", ":", "offset2", "]", "/", "self", ".", "temp", ",", "dim", "=", "1", ")", ".", "data", ".", "clone", "(", ")", "\n", "self", ".", "current_task", "=", "t", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "self", ".", "val_cnt", "=", "0", "\n", "self", ".", "val_count", "=", "0", "\n", "self", ".", "memy", "[", "t", "]", "=", "0", "\n", "self", ".", "count", "=", "0", "\n", "\n", "# evalidation set", "\n", "", "valx", ",", "valy", "=", "x", "[", "0", "]", ",", "y", "[", "0", "]", "\n", "x", ",", "y", "=", "x", "[", "1", ":", "]", ",", "y", "[", "1", ":", "]", "\n", "if", "self", ".", "val_cnt", "==", "0", "and", "self", ".", "val_count", "==", "0", ":", "\n", "            ", "self", ".", "valx", "[", "t", ",", ":", "]", ".", "copy_", "(", "valx", ")", "\n", "self", ".", "valy", "[", "t", ",", ":", "]", ".", "copy_", "(", "valy", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "torch", ".", "cat", "(", "[", "x", ",", "self", ".", "valx", "[", "t", ",", "self", ".", "val_cnt", "]", ".", "unsqueeze_", "(", "0", ")", "]", ")", "\n", "y", "=", "torch", ".", "cat", "(", "[", "y", ",", "self", ".", "valy", "[", "t", ",", "self", ".", "val_cnt", "]", ".", "unsqueeze_", "(", "0", ")", "]", ")", "\n", "self", ".", "valx", "[", "t", ",", "self", ".", "val_cnt", "]", ".", "copy_", "(", "valx", ")", "\n", "self", ".", "valy", "[", "t", ",", "self", ".", "val_cnt", "]", ".", "copy_", "(", "valy", ")", "\n", "", "self", ".", "val_cnt", "+=", "1", "\n", "self", ".", "val_count", "+=", "1", "\n", "if", "self", ".", "val_count", "==", "self", ".", "n_val", ":", "\n", "            ", "self", ".", "val_count", "-=", "1", "\n", "", "if", "self", ".", "val_cnt", "==", "self", ".", "n_val", ":", "\n", "            ", "self", ".", "val_cnt", "=", "0", "\n", "\n", "# memory set", "\n", "", "self", ".", "net", ".", "train", "(", ")", "\n", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "if", "self", ".", "count", "==", "0", ":", "\n", "            ", "self", ".", "memx", "[", "t", ",", ":", "]", ".", "copy_", "(", "x", ".", "data", "[", "0", "]", ")", "\n", "self", ".", "memy", "[", "t", ",", ":", "]", ".", "copy_", "(", "y", ".", "data", "[", "0", "]", ")", "\n", "", "self", ".", "memx", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "memy", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "self", ".", "count", "+=", "effbsz", "\n", "if", "self", ".", "count", ">=", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "count", "-=", "effbsz", "\n", "", "if", "self", ".", "mem_cnt", ">=", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "\n", "", "self", ".", "zero_grad", "(", ")", "\n", "tt", "=", "t", "+", "1", "\n", "for", "_", "in", "range", "(", "self", ".", "n_meta", ")", ":", "\n", "            ", "weights_before", "=", "deepcopy", "(", "self", ".", "net", ".", "state_dict", "(", ")", ")", "\n", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "inner_steps", ")", ":", "\n", "                ", "pred", "=", "self", ".", "forward", "(", "x", ",", "t", ")", "\n", "loss1", "=", "self", ".", "bce", "(", "pred", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "y", "-", "offset1", ")", "\n", "if", "t", ">", "0", ":", "\n", "                    ", "xx", ",", "yy", ",", "feat", ",", "mask", ",", "list_t", "=", "self", ".", "memory_sampling", "(", "t", ")", "\n", "pred_", "=", "self", ".", "net", "(", "xx", ")", "\n", "pred", "=", "torch", ".", "gather", "(", "pred_", ",", "1", ",", "mask", ")", "\n", "loss2", "=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "loss3", "=", "self", ".", "reg", "*", "self", ".", "kl", "(", "F", ".", "log_softmax", "(", "pred", "/", "self", ".", "temp", ",", "dim", "=", "1", ")", ",", "feat", ")", "\n", "loss", "=", "loss1", "+", "loss2", "+", "loss3", "\n", "", "else", ":", "\n", "                    ", "loss", "=", "loss1", "\n", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "inner_opt", ".", "step", "(", ")", "\n", "", "xval", ",", "yval", ",", "_", ",", "mask_val", ",", "list_t", "=", "self", ".", "memory_sampling", "(", "tt", ",", "valid", "=", "True", ")", "\n", "pred_", "=", "self", ".", "net", "(", "xval", ")", "\n", "pred", "=", "torch", ".", "gather", "(", "pred_", ",", "1", ",", "mask_val", ")", "\n", "outer_loss", "=", "self", ".", "bce", "(", "pred", ",", "yval", ")", "\n", "outer_loss", ".", "backward", "(", ")", "\n", "self", ".", "inner_opt", ".", "step", "(", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "weights_after", "=", "self", ".", "net", ".", "state_dict", "(", ")", "\n", "new_params", "=", "{", "name", ":", "weights_before", "[", "name", "]", "+", "(", "(", "weights_after", "[", "name", "]", "-", "weights_before", "[", "name", "]", ")", "*", "self", ".", "beta", ")", "for", "name", "in", "weights_before", ".", "keys", "(", ")", "}", "\n", "self", ".", "net", ".", "load_state_dict", "(", "new_params", ")", "\n", "", "return", "outer_loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.BasicBlock.__init__": [[33, 42], ["torch.Module.__init__", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "BasicBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv3x3", "(", "inplanes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.BasicBlock.forward": [[43, 60], ["resnet.BasicBlock.conv1", "resnet.BasicBlock.bn1", "resnet.BasicBlock.relu", "resnet.BasicBlock.conv2", "resnet.BasicBlock.bn2", "resnet.BasicBlock.relu", "resnet.BasicBlock.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.Bottleneck.__init__": [[65, 76], ["torch.Module.__init__", "resnet.conv1x1", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "resnet.conv3x3", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "resnet.conv1x1", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv1x1", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv1x1"], ["def", "__init__", "(", "self", ",", "inplanes", ",", "planes", ",", "stride", "=", "1", ",", "downsample", "=", "None", ")", ":", "\n", "        ", "super", "(", "Bottleneck", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv1", "=", "conv1x1", "(", "inplanes", ",", "planes", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv2", "=", "conv3x3", "(", "planes", ",", "planes", ",", "stride", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "planes", ")", "\n", "self", ".", "conv3", "=", "conv1x1", "(", "planes", ",", "planes", "*", "self", ".", "expansion", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "planes", "*", "self", ".", "expansion", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "downsample", "=", "downsample", "\n", "self", ".", "stride", "=", "stride", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.Bottleneck.forward": [[77, 98], ["resnet.Bottleneck.conv1", "resnet.Bottleneck.bn1", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv2", "resnet.Bottleneck.bn2", "resnet.Bottleneck.relu", "resnet.Bottleneck.conv3", "resnet.Bottleneck.bn3", "resnet.Bottleneck.relu", "resnet.Bottleneck.downsample"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "identity", "=", "x", "\n", "\n", "out", "=", "self", ".", "conv1", "(", "x", ")", "\n", "out", "=", "self", ".", "bn1", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv2", "(", "out", ")", "\n", "out", "=", "self", ".", "bn2", "(", "out", ")", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "out", "=", "self", ".", "conv3", "(", "out", ")", "\n", "out", "=", "self", ".", "bn3", "(", "out", ")", "\n", "\n", "if", "self", ".", "downsample", "is", "not", "None", ":", "\n", "            ", "identity", "=", "self", ".", "downsample", "(", "x", ")", "\n", "\n", "", "out", "+=", "identity", "\n", "out", "=", "self", ".", "relu", "(", "out", ")", "\n", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet.__init__": [[101, 132], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "resnet.ResNet._make_layer", "resnet.ResNet._make_layer", "resnet.ResNet._make_layer", "resnet.ResNet._make_layer", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.AdaptiveAvgPool2d", "torch.Linear", "torch.Linear", "torch.Linear", "resnet.ResNet.modules", "isinstance", "resnet.ResNet.modules", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "torch.init.kaiming_normal_", "isinstance", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_", "isinstance", "torch.init.constant_", "torch.init.constant_", "torch.init.constant_"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer"], ["    ", "def", "__init__", "(", "self", ",", "block", ",", "layers", ",", "num_classes", "=", "1000", ",", "zero_init_residual", "=", "False", ")", ":", "\n", "        ", "super", "(", "ResNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "inplanes", "=", "64", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "3", ",", "64", ",", "kernel_size", "=", "7", ",", "stride", "=", "2", ",", "padding", "=", "3", ",", "\n", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "relu", "=", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", "self", ".", "maxpool", "=", "nn", ".", "MaxPool2d", "(", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ")", "\n", "self", ".", "layer1", "=", "self", ".", "_make_layer", "(", "block", ",", "64", ",", "layers", "[", "0", "]", ")", "\n", "self", ".", "layer2", "=", "self", ".", "_make_layer", "(", "block", ",", "128", ",", "layers", "[", "1", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer3", "=", "self", ".", "_make_layer", "(", "block", ",", "256", ",", "layers", "[", "2", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "layer4", "=", "self", ".", "_make_layer", "(", "block", ",", "512", ",", "layers", "[", "3", "]", ",", "stride", "=", "2", ")", "\n", "self", ".", "avgpool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "(", "1", ",", "1", ")", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "512", "*", "block", ".", "expansion", ",", "num_classes", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "nn", ".", "BatchNorm2d", ")", ":", "\n", "                ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "weight", ",", "1", ")", "\n", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bias", ",", "0", ")", "\n", "\n", "# Zero-initialize the last BN in each residual branch,", "\n", "# so that the residual branch starts with zeros, and each residual block behaves like an identity.", "\n", "# This improves the model by 0.2~0.3% according to https://arxiv.org/abs/1706.02677", "\n", "", "", "if", "zero_init_residual", ":", "\n", "            ", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "                ", "if", "isinstance", "(", "m", ",", "Bottleneck", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bn3", ".", "weight", ",", "0", ")", "\n", "", "elif", "isinstance", "(", "m", ",", "BasicBlock", ")", ":", "\n", "                    ", "nn", ".", "init", ".", "constant_", "(", "m", ".", "bn2", ".", "weight", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet._make_layer": [[133, 148], ["layers.append", "range", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "block", "layers.append", "resnet.conv1x1", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "block"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv1x1"], ["", "", "", "", "def", "_make_layer", "(", "self", ",", "block", ",", "planes", ",", "blocks", ",", "stride", "=", "1", ")", ":", "\n", "        ", "downsample", "=", "None", "\n", "if", "stride", "!=", "1", "or", "self", ".", "inplanes", "!=", "planes", "*", "block", ".", "expansion", ":", "\n", "            ", "downsample", "=", "nn", ".", "Sequential", "(", "\n", "conv1x1", "(", "self", ".", "inplanes", ",", "planes", "*", "block", ".", "expansion", ",", "stride", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "planes", "*", "block", ".", "expansion", ")", ",", "\n", ")", "\n", "\n", "", "layers", "=", "[", "]", "\n", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ",", "stride", ",", "downsample", ")", ")", "\n", "self", ".", "inplanes", "=", "planes", "*", "block", ".", "expansion", "\n", "for", "_", "in", "range", "(", "1", ",", "blocks", ")", ":", "\n", "            ", "layers", ".", "append", "(", "block", "(", "self", ".", "inplanes", ",", "planes", ")", ")", "\n", "\n", "", "return", "nn", ".", "Sequential", "(", "*", "layers", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet.forward": [[149, 165], ["resnet.ResNet.conv1", "resnet.ResNet.bn1", "resnet.ResNet.relu", "resnet.ResNet.maxpool", "resnet.ResNet.layer1", "resnet.ResNet.layer2", "resnet.ResNet.layer3", "resnet.ResNet.layer4", "resnet.ResNet.avgpool", "resnet.ResNet.view", "resnet.ResNet.fc", "resnet.ResNet.size"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "bn1", "(", "x", ")", "\n", "x", "=", "self", ".", "relu", "(", "x", ")", "\n", "x", "=", "self", ".", "maxpool", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "layer1", "(", "x", ")", "\n", "x", "=", "self", ".", "layer2", "(", "x", ")", "\n", "x", "=", "self", ".", "layer3", "(", "x", ")", "\n", "x", "=", "self", ".", "layer4", "(", "x", ")", "\n", "\n", "x", "=", "self", ".", "avgpool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "x", ".", "size", "(", "0", ")", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv3x3": [[19, 23], ["torch.Conv2d"], "function", ["None"], ["def", "conv3x3", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"3x3 convolution with padding\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "3", ",", "stride", "=", "stride", ",", "\n", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.conv1x1": [[25, 28], ["torch.Conv2d"], "function", ["None"], ["", "def", "conv1x1", "(", "in_planes", ",", "out_planes", ",", "stride", "=", "1", ")", ":", "\n", "    ", "\"\"\"1x1 convolution\"\"\"", "\n", "return", "nn", ".", "Conv2d", "(", "in_planes", ",", "out_planes", ",", "kernel_size", "=", "1", ",", "stride", "=", "stride", ",", "bias", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18": [[168, 180], ["resnet.ResNet", "torch.Linear", "print", "ResNet.load_state_dict", "torch.load_url"], "function", ["None"], ["", "", "def", "ResNet18", "(", "pretrained", "=", "True", ",", "num_classes", "=", "50", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Constructs a ResNet-18 model.\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet\n    \"\"\"", "\n", "model", "=", "ResNet", "(", "BasicBlock", ",", "[", "2", ",", "2", ",", "2", ",", "2", "]", ",", "**", "kwargs", ")", "\n", "if", "pretrained", ":", "\n", "        ", "print", "(", "'Loading pretrained model'", ")", "\n", "model", ".", "load_state_dict", "(", "model_zoo", ".", "load_url", "(", "model_urls", "[", "'resnet18'", "]", ")", ")", "\n", "", "model", ".", "fc", "=", "nn", ".", "Linear", "(", "512", ",", "num_classes", ")", "\n", "return", "model", "\n", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.__init__": [[20, 80], ["super().__init__", "any", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.nn.CrossEntropyLoss", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.MSELoss", "torch.MSELoss", "torch.MSELoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "common.ResNet18", "offline.Net.net.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "offline.Net.memx.cuda", "offline.Net.memy.cuda", "offline.Net.memt.cuda", "resnet.ResNet18", "common.MLP", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "self", ".", "temp", "=", "args", ".", "temperature", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "args", ".", "pretrained", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "#self.net = MLP([n_inputs] + [nh] * nl + [n_outputs])", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "400", "]", "*", "2", "+", "[", "10", "]", ")", "\n", "if", "args", ".", "data_file", "==", "'notMNIST.pt'", ":", "\n", "                ", "self", ".", "is_cifar", "=", "True", "\n", "# setup optimizer", "\n", "", "", "self", ".", "lr", "=", "args", ".", "lr", "\n", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "# setup memories", "\n", "", "self", ".", "current_task", "=", "0", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "\n", "if", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", "*", "self", ".", "samples_per_task", ",", "3", ",", "224", ",", "224", ")", "\n", "", "elif", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", "*", "self", ".", "samples_per_task", ",", "3", ",", "128", ",", "128", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memx", "=", "torch", ".", "FloatTensor", "(", "n_tasks", "*", "self", ".", "samples_per_task", ",", "n_inputs", ")", "\n", "", "self", ".", "memy", "=", "torch", ".", "LongTensor", "(", "n_tasks", "*", "self", ".", "samples_per_task", ",", "1", ")", "\n", "self", ".", "memt", "=", "torch", ".", "LongTensor", "(", "n_tasks", "*", "self", ".", "samples_per_task", ",", "1", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memx", "=", "self", ".", "memx", ".", "cuda", "(", ")", "\n", "self", ".", "memy", "=", "self", ".", "memy", ".", "cuda", "(", ")", "\n", "self", ".", "memt", "=", "self", ".", "memt", ".", "cuda", "(", ")", "\n", "", "self", ".", "age", "=", "0", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "bsz", "=", "args", ".", "batch_size", "\n", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "n_tasks", "=", "n_tasks", "\n", "self", ".", "mse", "=", "nn", ".", "MSELoss", "(", ")", "\n", "self", ".", "kl", "=", "nn", ".", "KLDivLoss", "(", ")", "\n", "self", ".", "samples_seen", "=", "0", "\n", "self", ".", "samples_per_task", "=", "args", ".", "samples_per_task", "\n", "self", ".", "sz", "=", "args", ".", "replay_batch_size", "\n", "self", ".", "inner_steps", "=", "args", ".", "inner_steps", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.compute_offsets": [[81, 89], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.forward": [[90, 102], ["offline.Net.net", "offline.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ",", "return_feat", "=", "False", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.memory_sampling": [[103, 120], ["min", "numpy.random.choice", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "xx.size", "torch.zeros.size", "torch.zeros.size", "torch.zeros.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.zeros.long().cuda", "torch.zeros.long().cuda", "torch.zeros.long().cuda", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.zeros.long", "torch.zeros.long", "torch.zeros.long", "offline.Net.compute_offsets"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "memory_sampling", "(", "self", ",", "t", ")", ":", "\n", "        ", "mem_x", "=", "self", ".", "memx", "[", ":", "t", ",", ":", "]", "\n", "mem_y", "=", "self", ".", "memy", "[", ":", "t", ",", ":", "]", "\n", "mem_feat", "=", "self", ".", "mem_feat", "[", ":", "t", ",", ":", "]", "\n", "sz", "=", "min", "(", "self", ".", "n_memories", ",", "self", ".", "sz", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "t", "*", "self", ".", "n_memories", ",", "sz", ",", "False", ")", "\n", "t_idx", "=", "torch", ".", "from_numpy", "(", "idx", "/", "self", ".", "n_memories", ")", "\n", "s_idx", "=", "torch", ".", "from_numpy", "(", "idx", "%", "self", ".", "n_memories", ")", "\n", "\n", "offsets", "=", "torch", ".", "tensor", "(", "[", "self", ".", "compute_offsets", "(", "i", ")", "for", "i", "in", "t_idx", "]", ")", ".", "cuda", "(", ")", "\n", "xx", "=", "mem_x", "[", "t_idx", ",", "s_idx", "]", "\n", "yy", "=", "mem_y", "[", "t_idx", ",", "s_idx", "]", "-", "offsets", "[", ":", ",", "0", "]", "\n", "feat", "=", "mem_feat", "[", "t_idx", ",", "s_idx", "]", "\n", "mask", "=", "torch", ".", "zeros", "(", "xx", ".", "size", "(", "0", ")", ",", "self", ".", "nc_per_task", ")", "\n", "for", "j", "in", "range", "(", "mask", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "mask", "[", "j", "]", "=", "torch", ".", "arange", "(", "offsets", "[", "j", "]", "[", "0", "]", ",", "offsets", "[", "j", "]", "[", "1", "]", ")", "\n", "", "return", "xx", ",", "yy", ",", "feat", ",", "mask", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.observe": [[121, 129], ["range", "x.size"], "methods", ["None"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "x", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "self", ".", "memx", "[", "self", ".", "age", "]", "=", "x", "[", "i", "]", "\n", "self", ".", "memy", "[", "self", ".", "age", "]", "=", "y", "[", "i", "]", "\n", "self", ".", "memt", "[", "self", ".", "age", "]", "=", "t", "\n", "self", ".", "age", "+=", "1", "\n", "self", ".", "current_task", "=", "t", "\n", "", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.offline.Net.on_epoch_end": [[130, 154], ["offline.Net.net.train", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.TensorDataset", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "print", "range", "tqdm.tqdm.tqdm", "offline.Net.net.zero_grad", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.tensor().cuda", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "range", "mask.long().cuda.long().cuda.long().cuda", "offline.Net.net", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "offline.Net.bce", "offline.Net.backward", "offline.Net.opt.step", "x.size", "mask.long().cuda.long().cuda.size", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "torch.arange", "y.squeeze", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "mask.long().cuda.long().cuda.long", "offline.Net.compute_offsets", "i.item"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "current_task", "+", "1", "<", "self", ".", "n_tasks", ":", "\n", "            ", "return", "0", "\n", "", "self", ".", "net", ".", "train", "(", ")", "\n", "self", ".", "memx", "=", "self", ".", "memx", "[", ":", "self", ".", "age", "]", "\n", "self", ".", "memy", "=", "self", ".", "memy", "[", ":", "self", ".", "age", "]", "\n", "self", ".", "memt", "=", "self", ".", "memt", "[", ":", "self", ".", "age", "]", "\n", "train", "=", "torch", ".", "utils", ".", "data", ".", "TensorDataset", "(", "self", ".", "memx", ",", "self", ".", "memy", ",", "self", ".", "memt", ")", "\n", "loader", "=", "DataLoader", "(", "train", ",", "batch_size", "=", "10", ",", "shuffle", "=", "True", ",", "num_workers", "=", "0", ")", "\n", "print", "(", "'Offline training'", ")", "\n", "for", "_", "in", "range", "(", "2", ")", ":", "\n", "            ", "for", "x", ",", "y", ",", "t", "in", "tqdm", "(", "loader", ",", "ncols", "=", "69", ")", ":", "\n", "                ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "offsets", "=", "torch", ".", "tensor", "(", "[", "self", ".", "compute_offsets", "(", "i", ".", "item", "(", ")", ")", "for", "i", "in", "t", "]", ")", ".", "cuda", "(", ")", "\n", "mask", "=", "torch", ".", "zeros", "(", "x", ".", "size", "(", "0", ")", ",", "self", ".", "nc_per_task", ")", "\n", "for", "j", "in", "range", "(", "mask", ".", "size", "(", "0", ")", ")", ":", "\n", "                    ", "mask", "[", "j", "]", "=", "torch", ".", "arange", "(", "offsets", "[", "j", "]", "[", "0", "]", ",", "offsets", "[", "j", "]", "[", "1", "]", ")", "\n", "", "mask", "=", "mask", ".", "long", "(", ")", ".", "cuda", "(", ")", "\n", "pred_", "=", "self", ".", "net", "(", "x", ")", "\n", "pred", "=", "torch", ".", "gather", "(", "pred_", ",", "1", ",", "mask", ")", "\n", "yy", "=", "y", ".", "squeeze", "(", ")", "-", "offsets", "[", ":", ",", "0", "]", "\n", "loss", "=", "self", ".", "bce", "(", "pred", ",", "yy", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ewc.Net.__init__": [[14, 51], ["super().__init__", "any", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "common.ResNet18", "ewc.Net.net.parameters", "resnet.ResNet18", "common.MLP", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "reg", "=", "args", ".", "memory_strength", "\n", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "True", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "\n", "# setup optimizer", "\n", "", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "net", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "# setup memories", "\n", "self", ".", "current_task", "=", "0", "\n", "self", ".", "fisher", "=", "{", "}", "\n", "self", ".", "optpar", "=", "{", "}", "\n", "self", ".", "memx", "=", "None", "\n", "self", ".", "memy", "=", "None", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "", "self", ".", "n_outputs", "=", "n_outputs", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ewc.Net.compute_offsets": [[52, 60], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ewc.Net.forward": [[61, 71], ["ewc.Net.net", "ewc.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_", "int"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "int", "(", "offset2", ")", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "", "def", "on_epoch_end", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ewc.Net.on_epoch_end": [[71, 73], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.ewc.Net.observe": [[74, 126], ["ewc.Net.net.train", "ewc.Net.net.zero_grad", "range", "ewc.Net.backward", "ewc.Net.opt.step", "ewc.Net.item", "ewc.Net.net.zero_grad", "ewc.Net.net.parameters", "x.data.clone", "y.data.clone", "ewc.Net.compute_offsets", "ewc.Net.bce", "ewc.Net.bce", "enumerate", "ewc.Net.compute_offsets", "ewc.Net.bce().backward", "ewc.Net.bce().backward", "p.data.clone", "p.grad.data.clone().pow", "ewc.Net.optpar[].append", "ewc.Net.fisher[].append", "ewc.Net.memx.size", "torch.cat", "torch.cat", "ewc.Net.", "ewc.Net.net.parameters", "l.sum", "ewc.Net.memx.size", "ewc.Net.net", "ewc.Net.bce", "ewc.Net.bce", "p.grad.data.clone", "x.data.clone", "y.data.clone", "ewc.Net.", "ewc.Net.net"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "self", ".", "net", ".", "train", "(", ")", "\n", "\n", "# next task?", "\n", "if", "t", "!=", "self", ".", "current_task", ":", "\n", "            ", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "                ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "self", ".", "current_task", ")", "\n", "self", ".", "bce", "(", "(", "self", ".", "net", "(", "self", ".", "memx", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ",", "\n", "self", ".", "memy", "-", "offset1", ")", ".", "backward", "(", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "bce", "(", "self", "(", "self", ".", "memx", ",", "\n", "self", ".", "current_task", ")", ",", "\n", "self", ".", "memy", ")", ".", "backward", "(", ")", "\n", "", "self", ".", "fisher", "[", "self", ".", "current_task", "]", "=", "[", "]", "\n", "self", ".", "optpar", "[", "self", ".", "current_task", "]", "=", "[", "]", "\n", "for", "p", "in", "self", ".", "net", ".", "parameters", "(", ")", ":", "\n", "                ", "pd", "=", "p", ".", "data", ".", "clone", "(", ")", "\n", "pg", "=", "p", ".", "grad", ".", "data", ".", "clone", "(", ")", ".", "pow", "(", "2", ")", "\n", "self", ".", "optpar", "[", "self", ".", "current_task", "]", ".", "append", "(", "pd", ")", "\n", "self", ".", "fisher", "[", "self", ".", "current_task", "]", ".", "append", "(", "pg", ")", "\n", "", "self", ".", "current_task", "=", "t", "\n", "self", ".", "memx", "=", "None", "\n", "self", ".", "memy", "=", "None", "\n", "\n", "", "if", "self", ".", "memx", "is", "None", ":", "\n", "            ", "self", ".", "memx", "=", "x", ".", "data", ".", "clone", "(", ")", "\n", "self", ".", "memy", "=", "y", ".", "data", ".", "clone", "(", ")", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "memx", ".", "size", "(", "0", ")", "<", "self", ".", "n_memories", ":", "\n", "                ", "self", ".", "memx", "=", "torch", ".", "cat", "(", "(", "self", ".", "memx", ",", "x", ".", "data", ".", "clone", "(", ")", ")", ")", "\n", "self", ".", "memy", "=", "torch", ".", "cat", "(", "(", "self", ".", "memy", ",", "y", ".", "data", ".", "clone", "(", ")", ")", ")", "\n", "if", "self", ".", "memx", ".", "size", "(", "0", ")", ">", "self", ".", "n_memories", ":", "\n", "                    ", "self", ".", "memx", "=", "self", ".", "memx", "[", ":", "self", ".", "n_memories", "]", "\n", "self", ".", "memy", "=", "self", ".", "memy", "[", ":", "self", ".", "n_memories", "]", "\n", "\n", "", "", "", "self", ".", "net", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "loss", "=", "self", ".", "bce", "(", "(", "self", ".", "net", "(", "x", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ",", "\n", "y", "-", "offset1", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "self", ".", "bce", "(", "self", "(", "x", ",", "t", ")", ",", "y", ")", "\n", "", "for", "tt", "in", "range", "(", "t", ")", ":", "\n", "            ", "for", "i", ",", "p", "in", "enumerate", "(", "self", ".", "net", ".", "parameters", "(", ")", ")", ":", "\n", "                ", "l", "=", "self", ".", "reg", "*", "self", ".", "fisher", "[", "tt", "]", "[", "i", "]", "\n", "l", "=", "l", "*", "(", "p", "-", "self", ".", "optpar", "[", "tt", "]", "[", "i", "]", ")", ".", "pow", "(", "2", ")", "\n", "loss", "+=", "l", ".", "sum", "(", ")", "\n", "", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.Net.__init__": [[94, 148], ["torch.Module.__init__", "any", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.SGD", "torch.SGD", "torch.SGD", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "gem.Net.parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "common.ResNet18", "gem.Net.parameters", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "gem.Net.memory_data.cuda", "gem.Net.memory_labs.cuda", "gem.Net.grad_dims.append", "sum", "gem.Net.grads.cuda", "int", "resnet.ResNet18", "common.MLP", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "param.data.numel", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "margin", "=", "args", ".", "memory_strength", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "args", ".", "pretrained", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "#self.net = MLP([n_inputs] + [nh] * nl + [n_outputs])", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "100", "]", "*", "2", "+", "[", "10", "]", ")", "\n", "\n", "", "self", ".", "ce", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n", "self", ".", "opt", "=", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "args", ".", "lr", ")", "\n", "\n", "self", ".", "n_memories", "=", "args", ".", "n_memories", "\n", "self", ".", "gpu", "=", "args", ".", "cuda", "\n", "\n", "# allocate episodic memory", "\n", "if", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "224", ",", "224", ")", "\n", "", "elif", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ",", "3", ",", "128", ",", "128", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_data", "=", "torch", ".", "FloatTensor", "(", "\n", "n_tasks", ",", "self", ".", "n_memories", ",", "n_inputs", ")", "\n", "", "self", ".", "memory_labs", "=", "torch", ".", "LongTensor", "(", "n_tasks", ",", "self", ".", "n_memories", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "memory_data", "=", "self", ".", "memory_data", ".", "cuda", "(", ")", "\n", "self", ".", "memory_labs", "=", "self", ".", "memory_labs", ".", "cuda", "(", ")", "\n", "\n", "# allocate temporary synaptic memory", "\n", "", "self", ".", "grad_dims", "=", "[", "]", "\n", "for", "param", "in", "self", ".", "parameters", "(", ")", ":", "\n", "            ", "self", ".", "grad_dims", ".", "append", "(", "param", ".", "data", ".", "numel", "(", ")", ")", "\n", "", "self", ".", "grads", "=", "torch", ".", "Tensor", "(", "sum", "(", "self", ".", "grad_dims", ")", ",", "n_tasks", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "grads", "=", "self", ".", "grads", ".", "cuda", "(", ")", "\n", "\n", "# allocate counters", "\n", "", "self", ".", "observed_tasks", "=", "[", "]", "\n", "self", ".", "old_task", "=", "-", "1", "\n", "self", ".", "mem_cnt", "=", "0", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "int", "(", "n_outputs", "/", "n_tasks", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.Net.forward": [[150, 161], ["gem.Net.net", "int", "int", "output[].data.fill_", "output[].data.fill_"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", "=", "int", "(", "t", "*", "self", ".", "nc_per_task", ")", "\n", "offset2", "=", "int", "(", "(", "t", "+", "1", ")", "*", "self", ".", "nc_per_task", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "offset2", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "", "def", "on_epoch_end", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.Net.on_epoch_end": [[161, 163], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.Net.observe": [[164, 227], ["y.data.size", "min", "gem.Net.memory_data[].copy_", "gem.Net.zero_grad", "gem.compute_offsets", "gem.Net.ce", "gem.Net.backward", "gem.Net.opt.step", "gem.Net.item", "gem.Net.observed_tasks.append", "gem.Net.memory_labs[].copy_", "len", "range", "len", "gem.store_grad", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "torch.mm", "gem.Net.zero_grad", "gem.compute_offsets", "gem.Net.ce", "gem.Net.backward", "gem.store_grad", "gem.Net.forward", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.cuda.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "gem.Net.grads[].unsqueeze", "gem.Net.grads.index_select", "gem.project2cone2", "gem.overwrite_grad", "len", "gem.Net.grads[].unsqueeze", "gem.Net.grads.index_select", "gem.Net.forward"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.store_grad", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.store_grad", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.project2cone2", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.overwrite_grad", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "# update memory", "\n", "        ", "if", "t", "!=", "self", ".", "old_task", ":", "\n", "            ", "self", ".", "observed_tasks", ".", "append", "(", "t", ")", "\n", "self", ".", "old_task", "=", "t", "\n", "#self.log.write('Task {}\\n'.format(t))", "\n", "\n", "# Update ring buffer storing examples from current task", "\n", "", "bsz", "=", "y", ".", "data", ".", "size", "(", "0", ")", "\n", "endcnt", "=", "min", "(", "self", ".", "mem_cnt", "+", "bsz", ",", "self", ".", "n_memories", ")", "\n", "effbsz", "=", "endcnt", "-", "self", ".", "mem_cnt", "\n", "self", ".", "memory_data", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "x", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "if", "bsz", "==", "1", ":", "\n", "            ", "self", ".", "memory_labs", "[", "t", ",", "self", ".", "mem_cnt", "]", "=", "y", ".", "data", "[", "0", "]", "\n", "", "else", ":", "\n", "            ", "self", ".", "memory_labs", "[", "t", ",", "self", ".", "mem_cnt", ":", "endcnt", "]", ".", "copy_", "(", "\n", "y", ".", "data", "[", ":", "effbsz", "]", ")", "\n", "", "self", ".", "mem_cnt", "+=", "effbsz", "\n", "if", "self", ".", "mem_cnt", "==", "self", ".", "n_memories", ":", "\n", "            ", "self", ".", "mem_cnt", "=", "0", "\n", "\n", "# compute gradient on previous tasks", "\n", "", "if", "len", "(", "self", ".", "observed_tasks", ")", ">", "1", ":", "\n", "            ", "for", "tt", "in", "range", "(", "len", "(", "self", ".", "observed_tasks", ")", "-", "1", ")", ":", "\n", "                ", "self", ".", "zero_grad", "(", ")", "\n", "# fwd/bwd on the examples in the memory", "\n", "past_task", "=", "self", ".", "observed_tasks", "[", "tt", "]", "\n", "\n", "offset1", ",", "offset2", "=", "compute_offsets", "(", "past_task", ",", "self", ".", "nc_per_task", ",", "\n", "self", ".", "is_cifar", ")", "\n", "ptloss", "=", "self", ".", "ce", "(", "\n", "self", ".", "forward", "(", "\n", "self", ".", "memory_data", "[", "past_task", "]", ",", "\n", "past_task", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "\n", "self", ".", "memory_labs", "[", "past_task", "]", "-", "offset1", ")", "\n", "ptloss", ".", "backward", "(", ")", "\n", "store_grad", "(", "self", ".", "parameters", ",", "self", ".", "grads", ",", "self", ".", "grad_dims", ",", "\n", "past_task", ")", "\n", "\n", "# now compute the grad on the current minibatch", "\n", "", "", "self", ".", "zero_grad", "(", ")", "\n", "\n", "offset1", ",", "offset2", "=", "compute_offsets", "(", "t", ",", "self", ".", "nc_per_task", ",", "self", ".", "is_cifar", ")", "\n", "loss", "=", "self", ".", "ce", "(", "self", ".", "forward", "(", "x", ",", "t", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ",", "y", "-", "offset1", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# check if gradient violates constraints", "\n", "if", "len", "(", "self", ".", "observed_tasks", ")", ">", "1", ":", "\n", "# copy gradient", "\n", "            ", "store_grad", "(", "self", ".", "parameters", ",", "self", ".", "grads", ",", "self", ".", "grad_dims", ",", "t", ")", "\n", "indx", "=", "torch", ".", "cuda", ".", "LongTensor", "(", "self", ".", "observed_tasks", "[", ":", "-", "1", "]", ")", "if", "self", ".", "gpu", "else", "torch", ".", "LongTensor", "(", "self", ".", "observed_tasks", "[", ":", "-", "1", "]", ")", "\n", "dotp", "=", "torch", ".", "mm", "(", "self", ".", "grads", "[", ":", ",", "t", "]", ".", "unsqueeze", "(", "0", ")", ",", "\n", "self", ".", "grads", ".", "index_select", "(", "1", ",", "indx", ")", ")", "\n", "if", "(", "dotp", "<", "0", ")", ".", "sum", "(", ")", "!=", "0", ":", "\n", "                ", "project2cone2", "(", "self", ".", "grads", "[", ":", ",", "t", "]", ".", "unsqueeze", "(", "1", ")", ",", "\n", "self", ".", "grads", ".", "index_select", "(", "1", ",", "indx", ")", ",", "self", ".", "margin", ")", "\n", "# copy gradients back", "\n", "overwrite_grad", "(", "self", ".", "parameters", ",", "self", ".", "grads", "[", ":", ",", "t", "]", ",", "\n", "self", ".", "grad_dims", ")", "\n", "", "", "self", ".", "opt", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.compute_offsets": [[18, 30], ["None"], "function", ["None"], ["def", "compute_offsets", "(", "task", ",", "nc_per_task", ",", "is_cifar", ")", ":", "\n", "    ", "\"\"\"\n        Compute offsets for cifar to determine which\n        outputs to select for a given task.\n    \"\"\"", "\n", "if", "is_cifar", ":", "\n", "        ", "offset1", "=", "task", "*", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "nc_per_task", "\n", "", "else", ":", "\n", "        ", "offset1", "=", "0", "\n", "offset2", "=", "nc_per_task", "\n", "", "return", "offset1", ",", "offset2", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.store_grad": [[32, 49], ["grads[].fill_", "pp", "sum", "grads[].copy_", "sum", "param.grad.data.view"], "function", ["None"], ["", "def", "store_grad", "(", "pp", ",", "grads", ",", "grad_dims", ",", "tid", ")", ":", "\n", "    ", "\"\"\"\n        This stores parameter gradients of past tasks.\n        pp: parameters\n        grads: gradients\n        grad_dims: list with number of parameters per layers\n        tid: task id\n    \"\"\"", "\n", "# store the gradients", "\n", "grads", "[", ":", ",", "tid", "]", ".", "fill_", "(", "0.0", ")", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "grads", "[", "beg", ":", "en", ",", "tid", "]", ".", "copy_", "(", "param", ".", "grad", ".", "data", ".", "view", "(", "-", "1", ")", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.overwrite_grad": [[51, 68], ["pp", "sum", "newgrad[].contiguous().view", "param.grad.data.copy_", "sum", "param.grad.data.size", "newgrad[].contiguous"], "function", ["None"], ["", "", "def", "overwrite_grad", "(", "pp", ",", "newgrad", ",", "grad_dims", ")", ":", "\n", "    ", "\"\"\"\n        This is used to overwrite the gradients with a new gradient\n        vector, whenever violations occur.\n        pp: parameters\n        newgrad: corrected gradient\n        grad_dims: list storing number of parameters at each layer\n    \"\"\"", "\n", "cnt", "=", "0", "\n", "for", "param", "in", "pp", "(", ")", ":", "\n", "        ", "if", "param", ".", "grad", "is", "not", "None", ":", "\n", "            ", "beg", "=", "0", "if", "cnt", "==", "0", "else", "sum", "(", "grad_dims", "[", ":", "cnt", "]", ")", "\n", "en", "=", "sum", "(", "grad_dims", "[", ":", "cnt", "+", "1", "]", ")", "\n", "this_grad", "=", "newgrad", "[", "beg", ":", "en", "]", ".", "contiguous", "(", ")", ".", "view", "(", "\n", "param", ".", "grad", ".", "data", ".", "size", "(", ")", ")", "\n", "param", ".", "grad", ".", "data", ".", "copy_", "(", "this_grad", ")", "\n", "", "cnt", "+=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.gem.project2cone2": [[70, 91], ["memories.cpu().t().double().numpy", "gradient.cpu().contiguous().view().double().numpy", "numpy.dot", "numpy.eye", "gradient.copy_", "memories.cpu().t().double().numpy.transpose", "numpy.dot", "numpy.zeros", "quadprog.solve_qp", "numpy.dot", "torch.Tensor().view", "torch.Tensor().view", "torch.Tensor().view", "memories.cpu().t().double", "gradient.cpu().contiguous().view().double", "numpy.eye", "np.dot.transpose", "torch.Tensor", "torch.Tensor", "torch.Tensor", "memories.cpu().t", "gradient.cpu().contiguous().view", "memories.cpu", "gradient.cpu().contiguous", "gradient.cpu"], "function", ["None"], ["", "", "def", "project2cone2", "(", "gradient", ",", "memories", ",", "margin", "=", "0.5", ",", "eps", "=", "1e-3", ")", ":", "\n", "    ", "\"\"\"\n        Solves the GEM dual QP described in the paper given a proposed\n        gradient \"gradient\", and a memory of task gradients \"memories\".\n        Overwrites \"gradient\" with the final projected update.\n\n        input:  gradient, p-vector\n        input:  memories, (t * p)-vector\n        output: x, p-vector\n    \"\"\"", "\n", "memories_np", "=", "memories", ".", "cpu", "(", ")", ".", "t", "(", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "gradient_np", "=", "gradient", ".", "cpu", "(", ")", ".", "contiguous", "(", ")", ".", "view", "(", "-", "1", ")", ".", "double", "(", ")", ".", "numpy", "(", ")", "\n", "t", "=", "memories_np", ".", "shape", "[", "0", "]", "\n", "P", "=", "np", ".", "dot", "(", "memories_np", ",", "memories_np", ".", "transpose", "(", ")", ")", "\n", "P", "=", "0.5", "*", "(", "P", "+", "P", ".", "transpose", "(", ")", ")", "+", "np", ".", "eye", "(", "t", ")", "*", "eps", "\n", "q", "=", "np", ".", "dot", "(", "memories_np", ",", "gradient_np", ")", "*", "-", "1", "\n", "G", "=", "np", ".", "eye", "(", "t", ")", "\n", "h", "=", "np", ".", "zeros", "(", "t", ")", "+", "margin", "\n", "v", "=", "quadprog", ".", "solve_qp", "(", "P", ",", "q", ",", "G", ",", "h", ")", "[", "0", "]", "\n", "x", "=", "np", ".", "dot", "(", "v", ",", "memories_np", ")", "+", "gradient_np", "\n", "gradient", ".", "copy_", "(", "torch", ".", "Tensor", "(", "x", ")", ".", "view", "(", "-", "1", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__": [[14, 42], ["super().__init__", "any", "torch.optim.SGD", "torch.nn.CrossEntropyLoss", "common.ResNet18", "single.Net.parameters", "resnet.ResNet18", "common.MLP", "str"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.__init__", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18", "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.resnet.ResNet18"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_inputs", ",", "\n", "n_outputs", ",", "\n", "n_tasks", ",", "\n", "args", ")", ":", "\n", "        ", "super", "(", "Net", ",", "self", ")", ".", "__init__", "(", ")", "\n", "#nl, nh = args.n_layers, args.n_hiddens", "\n", "\n", "# setup network", "\n", "self", ".", "is_cifar", "=", "any", "(", "x", "in", "str", "(", "args", ".", "data_file", ")", "for", "x", "in", "[", "'cifar'", ",", "'cub'", ",", "'mini'", "]", ")", "\n", "if", "'cifar'", "in", "args", ".", "data_file", "or", "'mini'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18", "(", "n_outputs", ")", "\n", "", "elif", "'cub'", "in", "args", ".", "data_file", ":", "\n", "            ", "self", ".", "net", "=", "ResNet18Full", "(", "True", ",", "n_outputs", ")", "\n", "", "else", ":", "\n", "#self.net = MLP([n_inputs] + [nh] * nl + [n_outputs])", "\n", "            ", "self", ".", "net", "=", "MLP", "(", "[", "784", "]", "+", "[", "128", "]", "*", "3", "+", "[", "10", "]", ")", "\n", "# setup optimizer", "\n", "", "self", ".", "opt", "=", "torch", ".", "optim", ".", "SGD", "(", "self", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "# setup losses", "\n", "self", ".", "bce", "=", "torch", ".", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "/", "n_tasks", "\n", "", "else", ":", "\n", "            ", "self", ".", "nc_per_task", "=", "n_outputs", "\n", "", "self", ".", "n_outputs", "=", "n_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets": [[43, 51], ["int", "int"], "methods", ["None"], ["", "def", "compute_offsets", "(", "self", ",", "task", ")", ":", "\n", "        ", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", "=", "task", "*", "self", ".", "nc_per_task", "\n", "offset2", "=", "(", "task", "+", "1", ")", "*", "self", ".", "nc_per_task", "\n", "", "else", ":", "\n", "            ", "offset1", "=", "0", "\n", "offset2", "=", "self", ".", "n_outputs", "\n", "", "return", "int", "(", "offset1", ")", ",", "int", "(", "offset2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.on_epoch_end": [[52, 54], ["None"], "methods", ["None"], ["", "def", "on_epoch_end", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.forward": [[55, 65], ["single.Net.net", "single.Net.compute_offsets", "output[].data.fill_", "output[].data.fill_"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "forward", "(", "self", ",", "x", ",", "t", ")", ":", "\n", "        ", "output", "=", "self", ".", "net", "(", "x", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "# make sure we predict classes within the current task", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "if", "offset1", ">", "0", ":", "\n", "                ", "output", "[", ":", ",", ":", "offset1", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "if", "offset2", "<", "self", ".", "n_outputs", ":", "\n", "                ", "output", "[", ":", ",", "offset2", ":", "self", ".", "n_outputs", "]", ".", "data", ".", "fill_", "(", "-", "10e10", ")", "\n", "", "", "return", "output", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.observe": [[66, 78], ["single.Net.train", "single.Net.zero_grad", "single.Net.backward", "single.Net.opt.step", "single.Net.item", "single.Net.compute_offsets", "single.Net.bce", "single.Net.bce", "single.Net.", "single.Net.net"], "methods", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.model.single.Net.compute_offsets"], ["", "def", "observe", "(", "self", ",", "x", ",", "t", ",", "y", ")", ":", "\n", "        ", "self", ".", "train", "(", ")", "\n", "self", ".", "zero_grad", "(", ")", "\n", "if", "self", ".", "is_cifar", ":", "\n", "            ", "offset1", ",", "offset2", "=", "self", ".", "compute_offsets", "(", "t", ")", "\n", "loss", "=", "self", ".", "bce", "(", "(", "self", ".", "net", "(", "x", ")", "[", ":", ",", "offset1", ":", "offset2", "]", ")", ",", "\n", "y", "-", "offset1", ")", "\n", "", "else", ":", "\n", "            ", "loss", "=", "self", ".", "bce", "(", "self", "(", "x", ",", "t", ")", ",", "y", ")", "\n", "", "loss", ".", "backward", "(", ")", "\n", "self", ".", "opt", ".", "step", "(", ")", "\n", "return", "loss", ".", "item", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.metrics.metrics.task_changes": [[11, 21], ["int", "enumerate", "result_t.max", "changes.append"], "function", ["None"], ["def", "task_changes", "(", "result_t", ")", ":", "\n", "    ", "n_tasks", "=", "int", "(", "result_t", ".", "max", "(", ")", "+", "1", ")", "\n", "changes", "=", "[", "]", "\n", "current", "=", "result_t", "[", "0", "]", "\n", "for", "i", ",", "t", "in", "enumerate", "(", "result_t", ")", ":", "\n", "        ", "if", "t", "!=", "current", ":", "\n", "            ", "changes", ".", "append", "(", "i", ")", "\n", "current", "=", "t", "\n", "\n", "", "", "return", "n_tasks", ",", "changes", "\n", "\n"]], "home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.metrics.metrics.confusion_matrix": [[23, 66], ["metrics.task_changes", "result.diag", "prev.max", "torch.zeros", "range", "stats.append", "stats.append", "stats.append", "open", "print", "print", "range", "print", "print", "print", "print", "print", "print", "print", "open.close", "fin.mean", "fm.mean", "result.diag.mean", "result.size", "print", "result.diag.mean", "fin.mean", "bwt.mean", "torch.zeros.mean", "fm.mean", "lca.mean"], "function", ["home.repos.pwc.inspect_result.phquang_Bilevel-Continual-Learning.metrics.metrics.task_changes"], ["", "def", "confusion_matrix", "(", "result_t", ",", "result_a", ",", "lca", ",", "fname", "=", "None", ")", ":", "\n", "    ", "nt", ",", "changes", "=", "task_changes", "(", "result_t", ")", "\n", "baseline", "=", "result_a", "[", "0", "]", "\n", "#changes = torch.LongTensor(changes + [result_a.size(0)]) - 1", "\n", "result", "=", "result_a", "[", ":", "nt", ",", ":", "nt", "]", "\n", "# acc[t] equals result[t,t]", "\n", "acc", "=", "result", ".", "diag", "(", ")", "\n", "fin", "=", "result", "[", "nt", "-", "1", "]", "\n", "# bwt[t] equals result[T,t] - acc[t]", "\n", "bwt", "=", "result", "[", "nt", "-", "1", "]", "-", "acc", "\n", "bwt", "=", "bwt", "[", ":", "-", "1", "]", "\n", "# fm ", "\n", "prev", "=", "result", "[", ":", "nt", "-", "1", ",", ":", "nt", "-", "1", "]", "\n", "max_a", ",", "_", "=", "prev", ".", "max", "(", "dim", "=", "0", ")", "\n", "fm", "=", "max_a", "-", "result", "[", "nt", "-", "1", ",", ":", "nt", "-", "1", "]", "\n", "# fwt[t] equals result[t-1,t] - baseline[t]", "\n", "fwt", "=", "torch", ".", "zeros", "(", "nt", ")", "\n", "for", "t", "in", "range", "(", "1", ",", "nt", ")", ":", "\n", "        ", "fwt", "[", "t", "]", "=", "result", "[", "t", "-", "1", ",", "t", "]", "-", "baseline", "[", "t", "]", "\n", "\n", "", "if", "fname", "is", "not", "None", ":", "\n", "        ", "f", "=", "open", "(", "fname", ",", "'w'", ")", "\n", "\n", "print", "(", "' '", ".", "join", "(", "[", "'%.4f'", "%", "r", "for", "r", "in", "baseline", "]", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'|'", ",", "file", "=", "f", ")", "\n", "for", "row", "in", "range", "(", "result", ".", "size", "(", "0", ")", ")", ":", "\n", "            ", "print", "(", "' '", ".", "join", "(", "[", "'%.4f'", "%", "r", "for", "r", "in", "result", "[", "row", "]", "]", ")", ",", "file", "=", "f", ")", "\n", "", "print", "(", "''", ",", "file", "=", "f", ")", "\n", "print", "(", "'Diagonal Accuracy: %.4f'", "%", "acc", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Final Accuracy: %.4f'", "%", "fin", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Backward: %.4f'", "%", "bwt", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Forward:  %.4f'", "%", "fwt", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'Forgetting Measure: %.4f'", "%", "fm", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "print", "(", "'LCA: %.4f'", "%", "lca", ".", "mean", "(", ")", ",", "file", "=", "f", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n", "", "stats", "=", "[", "]", "\n", "# stats.append(acc.mean())", "\n", "stats", ".", "append", "(", "fin", ".", "mean", "(", ")", ")", "\n", "stats", ".", "append", "(", "fm", ".", "mean", "(", ")", ")", "\n", "stats", ".", "append", "(", "acc", ".", "mean", "(", ")", ")", "\n", "\n", "return", "stats", "\n", "", ""]]}