{"home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging.__init__": [[205, 231], ["sklearn.ensemble._base.BaseEnsemble.__init__"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.__init__"], ["@", "abstractmethod", "\n", "def", "__init__", "(", "self", ",", "\n", "base_estimator", "=", "None", ",", "\n", "n_estimators", "=", "10", ",", "*", ",", "\n", "max_samples", "=", "1.0", ",", "\n", "max_features", "=", "1.0", ",", "\n", "bootstrap", "=", "True", ",", "\n", "bootstrap_features", "=", "False", ",", "\n", "oob_score", "=", "False", ",", "\n", "warm_start", "=", "False", ",", "\n", "n_jobs", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "0", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", "\n", "base_estimator", "=", "base_estimator", ",", "\n", "n_estimators", "=", "n_estimators", ")", "\n", "\n", "self", ".", "max_samples", "=", "max_samples", "\n", "self", ".", "max_features", "=", "max_features", "\n", "self", ".", "bootstrap", "=", "bootstrap", "\n", "self", ".", "bootstrap_features", "=", "bootstrap_features", "\n", "self", ".", "oob_score", "=", "oob_score", "\n", "self", ".", "warm_start", "=", "warm_start", "\n", "self", ".", "n_jobs", "=", "n_jobs", "\n", "self", ".", "random_state", "=", "random_state", "\n", "self", ".", "verbose", "=", "verbose", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging.fit": [[232, 252], ["bagging.BaseBagging._fit"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._fit"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", ",", "sample_weight", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Build a Bagging ensemble of estimators from the training\n\t\t   set (X, y).\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\ty : array-like of shape (n_samples,)\n\t\t\tThe target values (class labels in classification, real numbers in\n\t\t\tregression).\n\t\tsample_weight : array-like of shape (n_samples,), default=None\n\t\t\tSample weights. If None, then samples are equally weighted.\n\t\t\tNote that this is supported only if the base estimator supports\n\t\t\tsample weighting.\n\t\tReturns\n\t\t-------\n\t\tself : object\n\t\t\"\"\"", "\n", "return", "self", ".", "_fit", "(", "X", ",", "y", ",", "self", ".", "max_samples", ",", "sample_weight", "=", "sample_weight", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._parallel_args": [[253, 255], ["None"], "methods", ["None"], ["", "def", "_parallel_args", "(", "self", ")", ":", "\n", "\t\t", "return", "{", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._fit": [[256, 395], ["sklearn.utils.check_random_state", "bagging.BaseBagging._validate_y", "bagging.BaseBagging._validate_estimator", "isinstance", "max", "sklearn.ensemble._base._partition_estimators", "sum", "sklearn.utils.check_random_state.randint", "list", "list", "ValueError", "isinstance", "ValueError", "int", "ValueError", "ValueError", "hasattr", "len", "ValueError", "sklearn.utils.check_random_state.randint", "joblib.Parallel", "itertools.chain.from_iterable", "itertools.chain.from_iterable", "bagging.BaseBagging._set_oob_score", "isinstance", "int", "ValueError", "hasattr", "warnings.warn", "len", "len", "bagging.BaseBagging._parallel_args", "joblib.delayed", "range", "len"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier._validate_y", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor._validate_estimator", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._set_oob_score", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._parallel_args"], ["", "def", "_fit", "(", "self", ",", "X", ",", "y", ",", "max_samples", "=", "None", ",", "max_depth", "=", "None", ",", "sample_weight", "=", "None", ",", "rotation_matrix", "=", "None", ")", ":", "\n", "\t\t", "\"\"\"Build a Bagging ensemble of estimators from the training\n\t\t   set (X, y).\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\ty : array-like of shape (n_samples,)\n\t\t\tThe target values (class labels in classification, real numbers in\n\t\t\tregression).\n\t\tmax_samples : int or float, default=None\n\t\t\tArgument to use instead of self.max_samples.\n\t\tmax_depth : int, default=None\n\t\t\tOverride value used when constructing base estimator. Only\n\t\t\tsupported if the base estimator has a max_depth parameter.\n\t\tsample_weight : array-like of shape (n_samples,), default=None\n\t\t\tSample weights. If None, then samples are equally weighted.\n\t\t\tNote that this is supported only if the base estimator supports\n\t\t\tsample weighting.\n\t\tReturns\n\t\t-------\n\t\tself : object\n\t\t\"\"\"", "\n", "random_state", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "\n", "# Convert data (X is required to be 2d and indexable)", "\n", "# X, y = self._validate_data(", "\n", "# \tX, y, accept_sparse=['csr', 'csc'], dtype=None,", "\n", "# \tforce_all_finite=False, multi_output=True", "\n", "# )", "\n", "# if sample_weight is not None:", "\n", "# \tsample_weight = _check_sample_weight(sample_weight, X, dtype=None)", "\n", "\n", "# Remap output", "\n", "n_samples", ",", "self", ".", "n_features_", "=", "X", ".", "shape", "\n", "self", ".", "_n_samples", "=", "n_samples", "\n", "y", "=", "self", ".", "_validate_y", "(", "y", ")", "\n", "\n", "# Check parameters", "\n", "self", ".", "_validate_estimator", "(", ")", "\n", "\n", "if", "max_depth", "is", "not", "None", ":", "\n", "\t\t\t", "self", ".", "base_estimator_", ".", "max_depth", "=", "max_depth", "\n", "\n", "# Validate max_samples", "\n", "", "if", "max_samples", "is", "None", ":", "\n", "\t\t\t", "max_samples", "=", "self", ".", "max_samples", "\n", "", "elif", "not", "isinstance", "(", "max_samples", ",", "numbers", ".", "Integral", ")", ":", "\n", "\t\t\t", "max_samples", "=", "int", "(", "max_samples", "*", "X", ".", "shape", "[", "0", "]", ")", "\n", "\n", "", "if", "not", "(", "0", "<", "max_samples", "<=", "X", ".", "shape", "[", "0", "]", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"max_samples must be in (0, n_samples]\"", ")", "\n", "\n", "# Store validated integer row sampling value", "\n", "", "self", ".", "_max_samples", "=", "max_samples", "\n", "\n", "# Validate max_features", "\n", "if", "isinstance", "(", "self", ".", "max_features", ",", "numbers", ".", "Integral", ")", ":", "\n", "\t\t\t", "max_features", "=", "self", ".", "max_features", "\n", "", "elif", "isinstance", "(", "self", ".", "max_features", ",", "np", ".", "float", ")", ":", "\n", "\t\t\t", "max_features", "=", "self", ".", "max_features", "*", "self", ".", "n_features_", "\n", "", "else", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"max_features must be int or float\"", ")", "\n", "\n", "", "if", "not", "(", "0", "<", "max_features", "<=", "self", ".", "n_features_", ")", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"max_features must be in (0, n_features]\"", ")", "\n", "\n", "", "max_features", "=", "max", "(", "1", ",", "int", "(", "max_features", ")", ")", "\n", "\n", "# Store validated integer feature sampling value", "\n", "self", ".", "_max_features", "=", "max_features", "\n", "\n", "# Other checks", "\n", "if", "not", "self", ".", "bootstrap", "and", "self", ".", "oob_score", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Out of bag estimation only available\"", "\n", "\" if bootstrap=True\"", ")", "\n", "\n", "", "if", "self", ".", "warm_start", "and", "self", ".", "oob_score", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Out of bag estimate only available\"", "\n", "\" if warm_start=False\"", ")", "\n", "\n", "", "if", "hasattr", "(", "self", ",", "\"oob_score_\"", ")", "and", "self", ".", "warm_start", ":", "\n", "\t\t\t", "del", "self", ".", "oob_score_", "\n", "\n", "", "if", "not", "self", ".", "warm_start", "or", "not", "hasattr", "(", "self", ",", "'estimators_'", ")", ":", "\n", "# Free allocated memory, if any", "\n", "\t\t\t", "self", ".", "estimators_", "=", "[", "]", "\n", "self", ".", "estimators_features_", "=", "[", "]", "\n", "\n", "", "n_more_estimators", "=", "self", ".", "n_estimators", "-", "len", "(", "self", ".", "estimators_", ")", "\n", "\n", "if", "n_more_estimators", "<", "0", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "'n_estimators=%d must be larger or equal to '", "\n", "'len(estimators_)=%d when warm_start==True'", "\n", "%", "(", "self", ".", "n_estimators", ",", "len", "(", "self", ".", "estimators_", ")", ")", ")", "\n", "\n", "", "elif", "n_more_estimators", "==", "0", ":", "\n", "\t\t\t", "warn", "(", "\"Warm-start fitting without increasing n_estimators does not \"", "\n", "\"fit new trees.\"", ")", "\n", "return", "self", "\n", "\n", "# Parallel loop", "\n", "", "n_jobs", ",", "n_estimators", ",", "starts", "=", "_partition_estimators", "(", "n_more_estimators", ",", "\n", "self", ".", "n_jobs", ")", "\n", "total_n_estimators", "=", "sum", "(", "n_estimators", ")", "\n", "\n", "# Advance random state to state after training", "\n", "# the first n_estimators", "\n", "if", "self", ".", "warm_start", "and", "len", "(", "self", ".", "estimators_", ")", ">", "0", ":", "\n", "\t\t\t", "random_state", ".", "randint", "(", "MAX_INT", ",", "size", "=", "len", "(", "self", ".", "estimators_", ")", ")", "\n", "\n", "", "seeds", "=", "random_state", ".", "randint", "(", "MAX_INT", ",", "size", "=", "n_more_estimators", ")", "\n", "self", ".", "_seeds", "=", "seeds", "\n", "\n", "all_results", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "self", ".", "verbose", ",", "\n", "**", "self", ".", "_parallel_args", "(", ")", ")", "(", "\n", "delayed", "(", "_parallel_build_estimators", ")", "(", "\n", "n_estimators", "[", "i", "]", ",", "\n", "self", ",", "\n", "X", ",", "\n", "y", ",", "\n", "sample_weight", ",", "\n", "seeds", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "total_n_estimators", ",", "\n", "verbose", "=", "self", ".", "verbose", ",", "\n", "rotation_matrix", "=", "rotation_matrix", ")", "\n", "for", "i", "in", "range", "(", "n_jobs", ")", ")", "\n", "\n", "# Reduce", "\n", "self", ".", "estimators_", "+=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "\n", "t", "[", "0", "]", "for", "t", "in", "all_results", ")", ")", "\n", "self", ".", "estimators_features_", "+=", "list", "(", "itertools", ".", "chain", ".", "from_iterable", "(", "\n", "t", "[", "1", "]", "for", "t", "in", "all_results", ")", ")", "\n", "\n", "if", "self", ".", "oob_score", ":", "\n", "\t\t\t", "self", ".", "_set_oob_score", "(", "X", ",", "y", ")", "\n", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._set_oob_score": [[396, 399], ["None"], "methods", ["None"], ["", "@", "abstractmethod", "\n", "def", "_set_oob_score", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "\t\t", "\"\"\"Calculate out of bag predictions and score.\"\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._validate_y": [[400, 405], ["sklearn.utils.column_or_1d", "len"], "methods", ["None"], ["", "def", "_validate_y", "(", "self", ",", "y", ")", ":", "\n", "\t\t", "if", "len", "(", "y", ".", "shape", ")", "==", "1", "or", "y", ".", "shape", "[", "1", "]", "==", "1", ":", "\n", "\t\t\t", "return", "column_or_1d", "(", "y", ",", "warn", "=", "True", ")", "\n", "", "else", ":", "\n", "\t\t\t", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._get_estimators_indices": [[406, 417], ["bagging._generate_bagging_indices"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._generate_bagging_indices"], ["", "", "def", "_get_estimators_indices", "(", "self", ")", ":", "\n", "# Get drawn indices along both sample and feature axes", "\n", "# for seed in self._seeds:", "\n", "# \t# Operations accessing random_state must be performed identically", "\n", "# \t# to those in `_parallel_build_estimators()`", "\n", "\t\t", "feature_indices", ",", "sample_indices", "=", "_generate_bagging_indices", "(", "\n", "seed", ",", "self", ".", "bootstrap_features", ",", "self", ".", "bootstrap", ",", "\n", "self", ".", "n_features_", ",", "self", ".", "_n_samples", ",", "self", ".", "_max_features", ",", "\n", "self", ".", "_max_samples", ")", "\n", "\n", "yield", "feature_indices", ",", "sample_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging.estimators_samples_": [[418, 431], ["bagging.BaseBagging._get_estimators_indices"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._get_estimators_indices"], ["", "@", "property", "\n", "def", "estimators_samples_", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"\n\t\tThe subset of drawn samples for each base estimator.\n\t\tReturns a dynamically generated list of indices identifying\n\t\tthe samples used for fitting each member of the ensemble, i.e.,\n\t\tthe in-bag samples.\n\t\tNote: the list is re-created at each call to the property in order\n\t\tto reduce the object memory footprint by not storing the sampling\n\t\tdata. Thus fetching the property may be slower than expected.\n\t\t\"\"\"", "\n", "return", "[", "sample_indices", "\n", "for", "_", ",", "sample_indices", "in", "self", ".", "_get_estimators_indices", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.__init__": [[549, 574], ["sklearn.base.ClassifierMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.__init__"], ["def", "__init__", "(", "self", ",", "\n", "base_estimator", "=", "None", ",", "\n", "n_estimators", "=", "10", ",", "*", ",", "\n", "max_samples", "=", "1.0", ",", "\n", "max_features", "=", "1.0", ",", "\n", "bootstrap", "=", "True", ",", "\n", "bootstrap_features", "=", "False", ",", "\n", "oob_score", "=", "False", ",", "\n", "warm_start", "=", "False", ",", "\n", "n_jobs", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "0", ")", ":", "\n", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", "\n", "base_estimator", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "max_samples", "=", "max_samples", ",", "\n", "max_features", "=", "max_features", ",", "\n", "bootstrap", "=", "bootstrap", ",", "\n", "bootstrap_features", "=", "bootstrap_features", ",", "\n", "oob_score", "=", "oob_score", ",", "\n", "warm_start", "=", "warm_start", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "random_state", "=", "random_state", ",", "\n", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier._validate_estimator": [[575, 579], ["super()._validate_estimator", "sklearn.tree.DecisionTreeClassifier"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor._validate_estimator"], ["", "def", "_validate_estimator", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"Check the estimator and set the base_estimator_ attribute.\"\"\"", "\n", "super", "(", ")", ".", "_validate_estimator", "(", "\n", "default", "=", "DecisionTreeClassifier", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier._set_oob_score": [[580, 616], ["numpy.zeros", "zip", "sklearn.metrics.accuracy_score", "hasattr", "warnings.warn", "numpy.argmax", "sklearn.utils.indices_to_mask", "estimator.predict_proba", "estimator.predict", "range", "numpy.zeros.sum", "numpy.zeros.sum"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_proba", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.predict"], ["", "def", "_set_oob_score", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "\t\t", "n_samples", "=", "y", ".", "shape", "[", "0", "]", "\n", "n_classes_", "=", "self", ".", "n_classes_", "\n", "\n", "predictions", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", "n_classes_", ")", ")", "\n", "\n", "for", "estimator", ",", "samples", ",", "features", "in", "zip", "(", "self", ".", "estimators_", ",", "\n", "self", ".", "estimators_samples_", ",", "\n", "self", ".", "estimators_features_", ")", ":", "\n", "# Create mask for OOB samples", "\n", "\t\t\t", "mask", "=", "~", "indices_to_mask", "(", "samples", ",", "n_samples", ")", "\n", "\n", "if", "hasattr", "(", "estimator", ",", "\"predict_proba\"", ")", ":", "\n", "\t\t\t\t", "predictions", "[", "mask", ",", ":", "]", "+=", "estimator", ".", "predict_proba", "(", "\n", "(", "X", "[", "mask", ",", ":", "]", ")", "[", ":", ",", "features", "]", ")", "\n", "\n", "", "else", ":", "\n", "\t\t\t\t", "p", "=", "estimator", ".", "predict", "(", "(", "X", "[", "mask", ",", ":", "]", ")", "[", ":", ",", "features", "]", ")", "\n", "j", "=", "0", "\n", "\n", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "\t\t\t\t\t", "if", "mask", "[", "i", "]", ":", "\n", "\t\t\t\t\t\t", "predictions", "[", "i", ",", "p", "[", "j", "]", "]", "+=", "1", "\n", "j", "+=", "1", "\n", "\n", "", "", "", "", "if", "(", "predictions", ".", "sum", "(", "axis", "=", "1", ")", "==", "0", ")", ".", "any", "(", ")", ":", "\n", "\t\t\t", "warn", "(", "\"Some inputs do not have OOB scores. \"", "\n", "\"This probably means too few estimators were used \"", "\n", "\"to compute any reliable oob estimates.\"", ")", "\n", "\n", "", "oob_decision_function", "=", "(", "predictions", "/", "\n", "predictions", ".", "sum", "(", "axis", "=", "1", ")", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "oob_score", "=", "accuracy_score", "(", "y", ",", "np", ".", "argmax", "(", "predictions", ",", "axis", "=", "1", ")", ")", "\n", "\n", "self", ".", "oob_decision_function_", "=", "oob_decision_function", "\n", "self", ".", "oob_score_", "=", "oob_score", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier._validate_y": [[617, 624], ["sklearn.utils.column_or_1d", "sklearn.utils.multiclass.check_classification_targets", "numpy.unique", "len"], "methods", ["None"], ["", "def", "_validate_y", "(", "self", ",", "y", ")", ":", "\n", "\t\t", "y", "=", "column_or_1d", "(", "y", ",", "warn", "=", "True", ")", "\n", "check_classification_targets", "(", "y", ")", "\n", "self", ".", "classes_", ",", "y", "=", "np", ".", "unique", "(", "y", ",", "return_inverse", "=", "True", ")", "\n", "self", ".", "n_classes_", "=", "len", "(", "self", ".", "classes_", ")", "\n", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict": [[625, 643], ["bagging.BaggingClassifier.predict_proba", "bagging.BaggingClassifier.classes_.take", "numpy.argmax"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_proba"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "\"\"\"Predict class for X.\n\t\tThe predicted class of an input sample is computed as the class with\n\t\tthe highest mean predicted probability. If base estimators do not\n\t\timplement a ``predict_proba`` method, then it resorts to voting.\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\tReturns\n\t\t-------\n\t\ty : ndarray of shape (n_samples,)\n\t\t\tThe predicted classes.\n\t\t\"\"\"", "\n", "predicted_probabilitiy", "=", "self", ".", "predict_proba", "(", "X", ")", "\n", "return", "self", ".", "classes_", ".", "take", "(", "(", "np", ".", "argmax", "(", "predicted_probabilitiy", ",", "axis", "=", "1", ")", ")", ",", "\n", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_proba": [[644, 693], ["sklearn.utils.validation.check_is_fitted", "sklearn.utils.check_array", "sklearn.ensemble._base._partition_estimators", "ValueError", "joblib.Parallel", "sum", "bagging.BaggingClassifier._parallel_args", "joblib.delayed", "range"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._parallel_args"], ["", "def", "predict_proba", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "\"\"\"Predict class probabilities for X.\n\t\tThe predicted class probabilities of an input sample is computed as\n\t\tthe mean predicted class probabilities of the base estimators in the\n\t\tensemble. If base estimators do not implement a ``predict_proba``\n\t\tmethod, then it resorts to voting and the predicted class probabilities\n\t\tof an input sample represents the proportion of estimators predicting\n\t\teach class.\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\tReturns\n\t\t-------\n\t\tp : ndarray of shape (n_samples, n_classes)\n\t\t\tThe class probabilities of the input samples. The order of the\n\t\t\tclasses corresponds to that in the attribute :term:`classes_`.\n\t\t\"\"\"", "\n", "check_is_fitted", "(", "self", ")", "\n", "# Check data", "\n", "X", "=", "check_array", "(", "\n", "X", ",", "accept_sparse", "=", "[", "'csr'", ",", "'csc'", "]", ",", "dtype", "=", "None", ",", "\n", "force_all_finite", "=", "False", "\n", ")", "\n", "\n", "if", "self", ".", "n_features_", "!=", "X", ".", "shape", "[", "1", "]", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Number of features of the model must \"", "\n", "\"match the input. Model n_features is {0} and \"", "\n", "\"input n_features is {1}.\"", "\n", "\"\"", ".", "format", "(", "self", ".", "n_features_", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "# Parallel loop", "\n", "", "n_jobs", ",", "n_estimators", ",", "starts", "=", "_partition_estimators", "(", "self", ".", "n_estimators", ",", "\n", "self", ".", "n_jobs", ")", "\n", "\n", "all_proba", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "self", ".", "verbose", ",", "\n", "**", "self", ".", "_parallel_args", "(", ")", ")", "(", "\n", "delayed", "(", "_parallel_predict_proba", ")", "(", "\n", "self", ".", "estimators_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "self", ".", "estimators_features_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "X", ",", "\n", "self", ".", "n_classes_", ")", "\n", "for", "i", "in", "range", "(", "n_jobs", ")", ")", "\n", "\n", "# Reduce", "\n", "proba", "=", "sum", "(", "all_proba", ")", "/", "self", ".", "n_estimators", "\n", "\n", "return", "proba", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_log_proba": [[694, 748], ["sklearn.utils.validation.check_is_fitted", "hasattr", "sklearn.utils.check_array", "sklearn.ensemble._base._partition_estimators", "range", "numpy.log", "numpy.log", "ValueError", "joblib.Parallel", "len", "numpy.logaddexp", "bagging.BaggingClassifier.predict_proba", "joblib.delayed", "range"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_proba"], ["", "def", "predict_log_proba", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "\"\"\"Predict class log-probabilities for X.\n\t\tThe predicted class log-probabilities of an input sample is computed as\n\t\tthe log of the mean predicted class probabilities of the base\n\t\testimators in the ensemble.\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\tReturns\n\t\t-------\n\t\tp : ndarray of shape (n_samples, n_classes)\n\t\t\tThe class log-probabilities of the input samples. The order of the\n\t\t\tclasses corresponds to that in the attribute :term:`classes_`.\n\t\t\"\"\"", "\n", "check_is_fitted", "(", "self", ")", "\n", "if", "hasattr", "(", "self", ".", "base_estimator_", ",", "\"predict_log_proba\"", ")", ":", "\n", "# Check data", "\n", "\t\t\t", "X", "=", "check_array", "(", "\n", "X", ",", "accept_sparse", "=", "[", "'csr'", ",", "'csc'", "]", ",", "dtype", "=", "None", ",", "\n", "force_all_finite", "=", "False", "\n", ")", "\n", "\n", "if", "self", ".", "n_features_", "!=", "X", ".", "shape", "[", "1", "]", ":", "\n", "\t\t\t\t", "raise", "ValueError", "(", "\"Number of features of the model must \"", "\n", "\"match the input. Model n_features is {0} \"", "\n", "\"and input n_features is {1} \"", "\n", "\"\"", ".", "format", "(", "self", ".", "n_features_", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "# Parallel loop", "\n", "", "n_jobs", ",", "n_estimators", ",", "starts", "=", "_partition_estimators", "(", "\n", "self", ".", "n_estimators", ",", "self", ".", "n_jobs", ")", "\n", "\n", "all_log_proba", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "self", ".", "verbose", ")", "(", "\n", "delayed", "(", "_parallel_predict_log_proba", ")", "(", "\n", "self", ".", "estimators_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "self", ".", "estimators_features_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "X", ",", "\n", "self", ".", "n_classes_", ")", "\n", "for", "i", "in", "range", "(", "n_jobs", ")", ")", "\n", "\n", "# Reduce", "\n", "log_proba", "=", "all_log_proba", "[", "0", "]", "\n", "\n", "for", "j", "in", "range", "(", "1", ",", "len", "(", "all_log_proba", ")", ")", ":", "\n", "\t\t\t\t", "log_proba", "=", "np", ".", "logaddexp", "(", "log_proba", ",", "all_log_proba", "[", "j", "]", ")", "\n", "\n", "", "log_proba", "-=", "np", ".", "log", "(", "self", ".", "n_estimators", ")", "\n", "\n", "return", "log_proba", "\n", "\n", "", "else", ":", "\n", "\t\t\t", "return", "np", ".", "log", "(", "self", ".", "predict_proba", "(", "X", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.decision_function": [[749, 794], ["sklearn.utils.metaestimators.if_delegate_has_method", "sklearn.utils.validation.check_is_fitted", "sklearn.utils.check_array", "sklearn.ensemble._base._partition_estimators", "ValueError", "joblib.Parallel", "sum", "joblib.delayed", "range"], "methods", ["None"], ["", "", "@", "if_delegate_has_method", "(", "delegate", "=", "'base_estimator'", ")", "\n", "def", "decision_function", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "\"\"\"Average of the decision functions of the base classifiers.\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\tReturns\n\t\t-------\n\t\tscore : ndarray of shape (n_samples, k)\n\t\t\tThe decision function of the input samples. The columns correspond\n\t\t\tto the classes in sorted order, as they appear in the attribute\n\t\t\t``classes_``. Regression and binary classification are special\n\t\t\tcases with ``k == 1``, otherwise ``k==n_classes``.\n\t\t\"\"\"", "\n", "check_is_fitted", "(", "self", ")", "\n", "\n", "# Check data", "\n", "X", "=", "check_array", "(", "\n", "X", ",", "accept_sparse", "=", "[", "'csr'", ",", "'csc'", "]", ",", "dtype", "=", "None", ",", "\n", "force_all_finite", "=", "False", "\n", ")", "\n", "\n", "if", "self", ".", "n_features_", "!=", "X", ".", "shape", "[", "1", "]", ":", "\n", "\t\t\t", "raise", "ValueError", "(", "\"Number of features of the model must \"", "\n", "\"match the input. Model n_features is {0} and \"", "\n", "\"input n_features is {1} \"", "\n", "\"\"", ".", "format", "(", "self", ".", "n_features_", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "# Parallel loop", "\n", "", "n_jobs", ",", "n_estimators", ",", "starts", "=", "_partition_estimators", "(", "self", ".", "n_estimators", ",", "\n", "self", ".", "n_jobs", ")", "\n", "\n", "all_decisions", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "self", ".", "verbose", ")", "(", "\n", "delayed", "(", "_parallel_decision_function", ")", "(", "\n", "self", ".", "estimators_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "self", ".", "estimators_features_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "X", ")", "\n", "for", "i", "in", "range", "(", "n_jobs", ")", ")", "\n", "\n", "# Reduce", "\n", "decisions", "=", "sum", "(", "all_decisions", ")", "/", "self", ".", "n_estimators", "\n", "\n", "return", "decisions", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor.__init__": [[906, 930], ["sklearn.base.RegressorMixin.__init__"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.__init__"], ["def", "__init__", "(", "self", ",", "\n", "base_estimator", "=", "None", ",", "\n", "n_estimators", "=", "10", ",", "*", ",", "\n", "max_samples", "=", "1.0", ",", "\n", "max_features", "=", "1.0", ",", "\n", "bootstrap", "=", "True", ",", "\n", "bootstrap_features", "=", "False", ",", "\n", "oob_score", "=", "False", ",", "\n", "warm_start", "=", "False", ",", "\n", "n_jobs", "=", "None", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "0", ")", ":", "\n", "\t\t", "super", "(", ")", ".", "__init__", "(", "\n", "base_estimator", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "max_samples", "=", "max_samples", ",", "\n", "max_features", "=", "max_features", ",", "\n", "bootstrap", "=", "bootstrap", ",", "\n", "bootstrap_features", "=", "bootstrap_features", ",", "\n", "oob_score", "=", "oob_score", ",", "\n", "warm_start", "=", "warm_start", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "random_state", "=", "random_state", ",", "\n", "verbose", "=", "verbose", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor.predict": [[931, 967], ["sklearn.utils.validation.check_is_fitted", "sklearn.utils.check_array", "sklearn.ensemble._base._partition_estimators", "joblib.Parallel", "sum", "joblib.delayed", "range"], "methods", ["None"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "\"\"\"Predict regression target for X.\n\t\tThe predicted regression target of an input sample is computed as the\n\t\tmean predicted regression targets of the estimators in the ensemble.\n\t\tParameters\n\t\t----------\n\t\tX : {array-like, sparse matrix} of shape (n_samples, n_features)\n\t\t\tThe training input samples. Sparse matrices are accepted only if\n\t\t\tthey are supported by the base estimator.\n\t\tReturns\n\t\t-------\n\t\ty : ndarray of shape (n_samples,)\n\t\t\tThe predicted values.\n\t\t\"\"\"", "\n", "check_is_fitted", "(", "self", ")", "\n", "# Check data", "\n", "X", "=", "check_array", "(", "\n", "X", ",", "accept_sparse", "=", "[", "'csr'", ",", "'csc'", "]", ",", "dtype", "=", "None", ",", "\n", "force_all_finite", "=", "False", "\n", ")", "\n", "\n", "# Parallel loop", "\n", "n_jobs", ",", "n_estimators", ",", "starts", "=", "_partition_estimators", "(", "self", ".", "n_estimators", ",", "\n", "self", ".", "n_jobs", ")", "\n", "\n", "all_y_hat", "=", "Parallel", "(", "n_jobs", "=", "n_jobs", ",", "verbose", "=", "self", ".", "verbose", ")", "(", "\n", "delayed", "(", "_parallel_predict_regression", ")", "(", "\n", "self", ".", "estimators_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "self", ".", "estimators_features_", "[", "starts", "[", "i", "]", ":", "starts", "[", "i", "+", "1", "]", "]", ",", "\n", "X", ")", "\n", "for", "i", "in", "range", "(", "n_jobs", ")", ")", "\n", "\n", "# Reduce", "\n", "y_hat", "=", "sum", "(", "all_y_hat", ")", "/", "self", ".", "n_estimators", "\n", "\n", "return", "y_hat", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor._validate_estimator": [[968, 972], ["super()._validate_estimator", "sklearn.tree.DecisionTreeRegressor"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor._validate_estimator"], ["", "def", "_validate_estimator", "(", "self", ")", ":", "\n", "\t\t", "\"\"\"Check the estimator and set the base_estimator_ attribute.\"\"\"", "\n", "super", "(", ")", ".", "_validate_estimator", "(", "\n", "default", "=", "DecisionTreeRegressor", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingRegressor._set_oob_score": [[973, 998], ["numpy.zeros", "numpy.zeros", "zip", "sklearn.metrics.r2_score", "estimator.predict", "warnings.warn", "sklearn.utils.indices_to_mask"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.predict"], ["", "def", "_set_oob_score", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "\t\t", "n_samples", "=", "y", ".", "shape", "[", "0", "]", "\n", "\n", "predictions", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", ")", ")", "\n", "n_predictions", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", ")", ")", "\n", "\n", "for", "estimator", ",", "samples", ",", "features", "in", "zip", "(", "self", ".", "estimators_", ",", "\n", "self", ".", "estimators_samples_", ",", "\n", "self", ".", "estimators_features_", ")", ":", "\n", "# Create mask for OOB samples", "\n", "\t\t\t", "mask", "=", "~", "indices_to_mask", "(", "samples", ",", "n_samples", ")", "\n", "\n", "predictions", "[", "mask", "]", "+=", "estimator", ".", "predict", "(", "(", "X", "[", "mask", ",", ":", "]", ")", "[", ":", ",", "features", "]", ")", "\n", "n_predictions", "[", "mask", "]", "+=", "1", "\n", "\n", "", "if", "(", "n_predictions", "==", "0", ")", ".", "any", "(", ")", ":", "\n", "\t\t\t", "warn", "(", "\"Some inputs do not have OOB scores. \"", "\n", "\"This probably means too few estimators were used \"", "\n", "\"to compute any reliable oob estimates.\"", ")", "\n", "n_predictions", "[", "n_predictions", "==", "0", "]", "=", "1", "\n", "\n", "", "predictions", "/=", "n_predictions", "\n", "\n", "self", ".", "oob_prediction_", "=", "predictions", "\n", "self", ".", "oob_score_", "=", "r2_score", "(", "y", ",", "predictions", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._generate_indices": [[42, 52], ["random_state.randint", "sklearn.utils.random.sample_without_replacement"], "function", ["None"], ["def", "_generate_indices", "(", "random_state", ",", "bootstrap", ",", "n_population", ",", "n_samples", ")", ":", "\n", "\t", "\"\"\"Draw randomly sampled indices.\"\"\"", "\n", "# Draw sample indices", "\n", "if", "bootstrap", ":", "\n", "\t\t", "indices", "=", "random_state", ".", "randint", "(", "0", ",", "n_population", ",", "n_samples", ")", "\n", "", "else", ":", "\n", "\t\t", "indices", "=", "sample_without_replacement", "(", "n_population", ",", "n_samples", ",", "\n", "random_state", "=", "random_state", ")", "\n", "\n", "", "return", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._generate_bagging_indices": [[54, 68], ["sklearn.utils.check_random_state", "bagging._generate_indices", "bagging._generate_indices"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._generate_indices", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._generate_indices"], ["", "def", "_generate_bagging_indices", "(", "random_state", ",", "bootstrap_features", ",", "\n", "bootstrap_samples", ",", "n_features", ",", "n_samples", ",", "\n", "max_features", ",", "max_samples", ")", ":", "\n", "\t", "\"\"\"Randomly draw feature and sample indices.\"\"\"", "\n", "# Get valid random state", "\n", "random_state", "=", "check_random_state", "(", "random_state", ")", "\n", "\n", "# Draw indices", "\n", "feature_indices", "=", "_generate_indices", "(", "random_state", ",", "bootstrap_features", ",", "\n", "n_features", ",", "max_features", ")", "\n", "sample_indices", "=", "_generate_indices", "(", "random_state", ",", "bootstrap_samples", ",", "\n", "n_samples", ",", "max_samples", ")", "\n", "\n", "return", "feature_indices", ",", "sample_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._parallel_build_estimators": [[70, 132], ["sklearn.utils.validation.has_fit_parameter", "range", "ValueError", "ensemble._make_estimator", "bagging._generate_bagging_indices", "estimators.append", "estimators_features.append", "print", "numpy.ones", "sample_weight.copy", "numpy.bincount", "ensemble._make_estimator.fit", "ensemble._make_estimator.fit", "ensemble._make_estimator.fit", "ensemble._make_estimator.fit", "sklearn.utils.indices_to_mask", "numpy.matmul", "numpy.matmul"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._generate_bagging_indices", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit"], ["", "def", "_parallel_build_estimators", "(", "n_estimators", ",", "ensemble", ",", "X", ",", "y", ",", "sample_weight", ",", "\n", "seeds", ",", "total_n_estimators", ",", "verbose", ",", "rotation_matrix", ")", ":", "\n", "\t", "\"\"\"Private function used to build a batch of estimators within a job.\"\"\"", "\n", "# Retrieve settings", "\n", "n_samples", ",", "n_features", "=", "X", ".", "shape", "\n", "max_features", "=", "ensemble", ".", "_max_features", "\n", "max_samples", "=", "ensemble", ".", "_max_samples", "\n", "bootstrap", "=", "ensemble", ".", "bootstrap", "\n", "bootstrap_features", "=", "ensemble", ".", "bootstrap_features", "\n", "support_sample_weight", "=", "has_fit_parameter", "(", "ensemble", ".", "base_estimator_", ",", "\n", "\"sample_weight\"", ")", "\n", "if", "not", "support_sample_weight", "and", "sample_weight", "is", "not", "None", ":", "\n", "\t\t", "raise", "ValueError", "(", "\"The base estimator doesn't support sample weight\"", ")", "\n", "\n", "# Build estimators", "\n", "", "estimators", "=", "[", "]", "\n", "estimators_features", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "n_estimators", ")", ":", "\n", "\t\t", "if", "verbose", ">", "1", ":", "\n", "\t\t\t", "print", "(", "\"Building estimator %d of %d for this parallel run \"", "\n", "\"(total %d)...\"", "%", "(", "i", "+", "1", ",", "n_estimators", ",", "total_n_estimators", ")", ")", "\n", "\n", "", "random_state", "=", "seeds", "[", "i", "]", "\n", "estimator", "=", "ensemble", ".", "_make_estimator", "(", "append", "=", "False", ",", "\n", "random_state", "=", "random_state", ")", "\n", "\n", "# Draw random feature, sample indices", "\n", "features", ",", "indices", "=", "_generate_bagging_indices", "(", "random_state", ",", "\n", "bootstrap_features", ",", "\n", "bootstrap", ",", "n_features", ",", "\n", "n_samples", ",", "max_features", ",", "\n", "max_samples", ")", "\n", "\n", "# Draw samples, using sample weights, and then fit", "\n", "if", "support_sample_weight", ":", "\n", "\t\t\t", "if", "sample_weight", "is", "None", ":", "\n", "\t\t\t\t", "curr_sample_weight", "=", "np", ".", "ones", "(", "(", "n_samples", ",", ")", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "curr_sample_weight", "=", "sample_weight", ".", "copy", "(", ")", "\n", "\n", "", "if", "bootstrap", ":", "\n", "\t\t\t\t", "sample_counts", "=", "np", ".", "bincount", "(", "indices", ",", "minlength", "=", "n_samples", ")", "\n", "curr_sample_weight", "*=", "sample_counts", "\n", "", "else", ":", "\n", "\t\t\t\t", "not_indices_mask", "=", "~", "indices_to_mask", "(", "indices", ",", "n_samples", ")", "\n", "curr_sample_weight", "[", "not_indices_mask", "]", "=", "0", "\n", "\n", "", "if", "rotation_matrix", "is", "not", "None", ":", "\n", "\t\t\t\t", "estimator", ".", "fit", "(", "np", ".", "matmul", "(", "X", "[", ":", ",", "features", "]", ",", "rotation_matrix", "[", "i", "]", ")", ",", "y", ",", "sample_weight", "=", "curr_sample_weight", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "estimator", ".", "fit", "(", "X", "[", ":", ",", "features", "]", ",", "y", ",", "sample_weight", "=", "curr_sample_weight", ")", "\n", "", "", "else", ":", "\n", "\t\t\t", "if", "rotation_matrix", "is", "not", "None", ":", "\n", "\t\t\t\t", "estimator", ".", "fit", "(", "(", "np", ".", "matmul", "(", "(", "X", "[", "indices", "]", ")", "[", ":", ",", "features", "]", ",", "rotation_matrix", "[", "i", "]", ")", ")", ",", "y", "[", "indices", "]", ")", "\n", "", "else", ":", "\n", "\t\t\t\t", "estimator", ".", "fit", "(", "(", "X", "[", "indices", "]", ")", "[", ":", ",", "features", "]", ",", "y", "[", "indices", "]", ")", "\n", "\n", "", "", "estimators", ".", "append", "(", "estimator", ")", "\n", "estimators_features", ".", "append", "(", "features", ")", "\n", "\n", "", "return", "estimators", ",", "estimators_features", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._parallel_predict_proba": [[134, 158], ["numpy.zeros", "zip", "hasattr", "estimator.predict_proba", "estimator.predict", "range", "len", "range", "len"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_proba", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.predict"], ["", "def", "_parallel_predict_proba", "(", "estimators", ",", "estimators_features", ",", "X", ",", "n_classes", ")", ":", "\n", "\t", "\"\"\"Private function used to compute (proba-)predictions within a job.\"\"\"", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "proba", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", "n_classes", ")", ")", "\n", "\n", "for", "estimator", ",", "features", "in", "zip", "(", "estimators", ",", "estimators_features", ")", ":", "\n", "\t\t", "if", "hasattr", "(", "estimator", ",", "\"predict_proba\"", ")", ":", "\n", "\t\t\t", "proba_estimator", "=", "estimator", ".", "predict_proba", "(", "X", "[", ":", ",", "features", "]", ")", "\n", "\n", "if", "n_classes", "==", "len", "(", "estimator", ".", "classes_", ")", ":", "\n", "\t\t\t\t", "proba", "+=", "proba_estimator", "\n", "\n", "", "else", ":", "\n", "\t\t\t\t", "proba", "[", ":", ",", "estimator", ".", "classes_", "]", "+=", "proba_estimator", "[", ":", ",", "range", "(", "len", "(", "estimator", ".", "classes_", ")", ")", "]", "\n", "\n", "", "", "else", ":", "\n", "# Resort to voting", "\n", "\t\t\t", "predictions", "=", "estimator", ".", "predict", "(", "X", "[", ":", ",", "features", "]", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "\t\t\t\t", "proba", "[", "i", ",", "predictions", "[", "i", "]", "]", "+=", "1", "\n", "\n", "", "", "", "return", "proba", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._parallel_predict_log_proba": [[160, 183], ["numpy.empty", "np.logaddexp.fill", "numpy.arange", "zip", "estimator.predict_log_proba", "len", "numpy.logaddexp", "numpy.logaddexp", "numpy.setdiff1d", "numpy.logaddexp", "range", "len"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaggingClassifier.predict_log_proba"], ["", "def", "_parallel_predict_log_proba", "(", "estimators", ",", "estimators_features", ",", "X", ",", "n_classes", ")", ":", "\n", "\t", "\"\"\"Private function used to compute log probabilities within a job.\"\"\"", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "log_proba", "=", "np", ".", "empty", "(", "(", "n_samples", ",", "n_classes", ")", ")", "\n", "log_proba", ".", "fill", "(", "-", "np", ".", "inf", ")", "\n", "all_classes", "=", "np", ".", "arange", "(", "n_classes", ",", "dtype", "=", "np", ".", "int", ")", "\n", "\n", "for", "estimator", ",", "features", "in", "zip", "(", "estimators", ",", "estimators_features", ")", ":", "\n", "\t\t", "log_proba_estimator", "=", "estimator", ".", "predict_log_proba", "(", "X", "[", ":", ",", "features", "]", ")", "\n", "\n", "if", "n_classes", "==", "len", "(", "estimator", ".", "classes_", ")", ":", "\n", "\t\t\t", "log_proba", "=", "np", ".", "logaddexp", "(", "log_proba", ",", "log_proba_estimator", ")", "\n", "\n", "", "else", ":", "\n", "\t\t\t", "log_proba", "[", ":", ",", "estimator", ".", "classes_", "]", "=", "np", ".", "logaddexp", "(", "\n", "log_proba", "[", ":", ",", "estimator", ".", "classes_", "]", ",", "\n", "log_proba_estimator", "[", ":", ",", "range", "(", "len", "(", "estimator", ".", "classes_", ")", ")", "]", ")", "\n", "\n", "missing", "=", "np", ".", "setdiff1d", "(", "all_classes", ",", "estimator", ".", "classes_", ")", "\n", "log_proba", "[", ":", ",", "missing", "]", "=", "np", ".", "logaddexp", "(", "log_proba", "[", ":", ",", "missing", "]", ",", "\n", "-", "np", ".", "inf", ")", "\n", "\n", "", "", "return", "log_proba", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._parallel_decision_function": [[185, 190], ["sum", "estimator.decision_function", "zip"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.decision_function"], ["", "def", "_parallel_decision_function", "(", "estimators", ",", "estimators_features", ",", "X", ")", ":", "\n", "\t", "\"\"\"Private function used to compute decisions within a job.\"\"\"", "\n", "return", "sum", "(", "estimator", ".", "decision_function", "(", "X", "[", ":", ",", "features", "]", ")", "\n", "for", "estimator", ",", "features", "in", "zip", "(", "estimators", ",", "\n", "estimators_features", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging._parallel_predict_regression": [[192, 197], ["sum", "estimator.predict", "zip"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.predict"], ["", "def", "_parallel_predict_regression", "(", "estimators", ",", "estimators_features", ",", "X", ")", ":", "\n", "\t", "\"\"\"Private function used to compute predictions within a job.\"\"\"", "\n", "return", "sum", "(", "estimator", ".", "predict", "(", "X", "[", ":", ",", "features", "]", ")", "\n", "for", "estimator", ",", "features", "in", "zip", "(", "estimators", ",", "\n", "estimators_features", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.__init__": [[159, 190], ["sklearn.base.OutlierMixin.__init__", "sklearn.tree.ExtraTreeRegressor"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.__init__"], ["def", "__init__", "(", "self", ",", "\n", "n_estimators", "=", "100", ",", "\n", "max_samples", "=", "\"auto\"", ",", "\n", "contamination", "=", "\"auto\"", ",", "\n", "max_features", "=", "1.", ",", "\n", "bootstrap", "=", "False", ",", "\n", "n_jobs", "=", "None", ",", "\n", "behaviour", "=", "'deprecated'", ",", "\n", "random_state", "=", "None", ",", "\n", "verbose", "=", "0", ",", "\n", "warm_start", "=", "False", ",", "\n", "rotate", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "\n", "base_estimator", "=", "ExtraTreeRegressor", "(", "\n", "max_features", "=", "1", ",", "\n", "splitter", "=", "'random'", ",", "\n", "random_state", "=", "random_state", ")", ",", "\n", "# here above max_features has no links with self.max_features", "\n", "bootstrap", "=", "bootstrap", ",", "\n", "bootstrap_features", "=", "False", ",", "\n", "n_estimators", "=", "n_estimators", ",", "\n", "max_samples", "=", "max_samples", ",", "\n", "max_features", "=", "max_features", ",", "\n", "warm_start", "=", "warm_start", ",", "\n", "n_jobs", "=", "n_jobs", ",", "\n", "random_state", "=", "random_state", ",", "\n", "verbose", "=", "verbose", ")", "\n", "\n", "self", ".", "behaviour", "=", "behaviour", "\n", "self", ".", "contamination", "=", "contamination", "\n", "self", ".", "rotate", "=", "rotate", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._set_oob_score": [[191, 193], ["NotImplementedError"], "methods", ["None"], ["", "def", "_set_oob_score", "(", "self", ",", "X", ",", "y", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"OOB score not supported by iforest\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._parallel_args": [[194, 200], ["sklearn.utils.fixes._joblib_parallel_args"], "methods", ["None"], ["", "def", "_parallel_args", "(", "self", ")", ":", "\n", "# ExtraTreeRegressor releases the GIL, so it's more efficient to use", "\n", "# a thread-based backend rather than a process-based backend so as", "\n", "# to avoid suffering from communication overhead and extra memory", "\n", "# copies.", "\n", "        ", "return", "_joblib_parallel_args", "(", "prefer", "=", "'threads'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.fit": [[201, 299], ["sklearn.utils.check_array", "scipy.sparse.issparse", "sklearn.utils.check_random_state", "sklearn.utils.check_random_state.uniform", "isinstance", "super()._fit", "numpy.percentile", "sklearn.utils.check_array.sort_indices", "isinstance", "range", "numpy.array", "int", "iforest.IsolationForest.score_samples", "warnings.warn", "NotImplementedError", "min", "ValueError", "int", "numpy.array", "rotation_matrix.append", "numpy.ceil", "warnings.warn", "ValueError", "numpy.log2", "max", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.bagging.BaseBagging._fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.score_samples"], ["", "def", "fit", "(", "self", ",", "X", ",", "y", "=", "None", ",", "sample_weight", "=", "None", ",", "max_depth", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Fit estimator.\n        Parameters\n        ----------\n        X : array-like or sparse matrix, shape (n_samples, n_features)\n            The input samples. Use ``dtype=np.float32`` for maximum\n            efficiency. Sparse matrices are also supported, use sparse\n            ``csc_matrix`` for maximum efficiency.\n        y : Ignored\n            Not used, present for API consistency by convention.\n        sample_weight : array-like of shape (n_samples,), default=None\n            Sample weights. If None, then samples are equally weighted.\n        Returns\n        -------\n        self : object\n            Fitted estimator.\n        \"\"\"", "\n", "if", "self", ".", "behaviour", "!=", "'deprecated'", ":", "\n", "            ", "if", "self", ".", "behaviour", "==", "'new'", ":", "\n", "                ", "warn", "(", "\n", "\"'behaviour' is deprecated in 0.22 and will be removed \"", "\n", "\"in 0.24. You should not pass or set this parameter.\"", ",", "\n", "FutureWarning", "\n", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "\n", "\"The old behaviour of IsolationForest is not implemented \"", "\n", "\"anymore. Remove the 'behaviour' parameter.\"", "\n", ")", "\n", "\n", "", "", "X", "=", "check_array", "(", "X", ",", "accept_sparse", "=", "[", "'csc'", "]", ")", "\n", "if", "issparse", "(", "X", ")", ":", "\n", "# Pre-sort indices to avoid that each individual tree of the", "\n", "# ensemble sorts the indices.", "\n", "            ", "X", ".", "sort_indices", "(", ")", "\n", "\n", "", "rnd", "=", "check_random_state", "(", "self", ".", "random_state", ")", "\n", "y", "=", "rnd", ".", "uniform", "(", "size", "=", "X", ".", "shape", "[", "0", "]", ")", "\n", "\n", "# ensure that max_sample is in [1, n_samples]:", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "if", "isinstance", "(", "self", ".", "max_samples", ",", "str", ")", ":", "\n", "            ", "if", "self", ".", "max_samples", "==", "'auto'", ":", "\n", "                ", "max_samples", "=", "min", "(", "256", ",", "n_samples", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'max_samples (%s) is not supported.'", "\n", "'Valid choices are: \"auto\", int or'", "\n", "'float'", "%", "self", ".", "max_samples", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "self", ".", "max_samples", ",", "numbers", ".", "Integral", ")", ":", "\n", "            ", "if", "self", ".", "max_samples", ">", "n_samples", ":", "\n", "                ", "warn", "(", "\"max_samples (%s) is greater than the \"", "\n", "\"total number of samples (%s). max_samples \"", "\n", "\"will be set to n_samples for estimation.\"", "\n", "%", "(", "self", ".", "max_samples", ",", "n_samples", ")", ")", "\n", "max_samples", "=", "n_samples", "\n", "", "else", ":", "\n", "                ", "max_samples", "=", "self", ".", "max_samples", "\n", "", "", "else", ":", "# float", "\n", "            ", "if", "not", "0.", "<", "self", ".", "max_samples", "<=", "1.", ":", "\n", "                ", "raise", "ValueError", "(", "\"max_samples must be in (0, 1], got %r\"", "\n", "%", "self", ".", "max_samples", ")", "\n", "", "max_samples", "=", "int", "(", "self", ".", "max_samples", "*", "X", ".", "shape", "[", "0", "]", ")", "\n", "\n", "", "if", "self", ".", "rotate", ":", "\n", "            ", "self", ".", "max_features", "=", "2", "\n", "self", ".", "n_estimators", "=", "180", "\n", "\n", "rotation_matrix", "=", "[", "]", "\n", "for", "theta", "in", "range", "(", "180", ")", ":", "\n", "                ", "RM", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "theta", ")", ",", "-", "np", ".", "sin", "(", "theta", ")", "]", ",", "\n", "[", "np", ".", "sin", "(", "theta", ")", ",", "np", ".", "cos", "(", "theta", ")", "]", "]", ")", "\n", "rotation_matrix", ".", "append", "(", "RM", ")", "\n", "", "self", ".", "rotation_matrix", "=", "np", ".", "array", "(", "rotation_matrix", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rotation_matrix", "=", "None", "\n", "\n", "", "self", ".", "max_samples_", "=", "max_samples", "\n", "if", "max_depth", "==", "None", ":", "\n", "            ", "max_depth", "=", "int", "(", "np", ".", "ceil", "(", "np", ".", "log2", "(", "max", "(", "max_samples", ",", "2", ")", ")", ")", ")", "\n", "", "super", "(", ")", ".", "_fit", "(", "X", ",", "y", ",", "max_samples", ",", "\n", "max_depth", "=", "max_depth", ",", "\n", "sample_weight", "=", "sample_weight", ",", "\n", "rotation_matrix", "=", "self", ".", "rotation_matrix", ")", "\n", "\n", "if", "self", ".", "contamination", "==", "\"auto\"", ":", "\n", "# 0.5 plays a special role as described in the original paper.", "\n", "# we take the opposite as we consider the opposite of their score.", "\n", "            ", "self", ".", "offset_", "=", "-", "0.5", "\n", "return", "self", "\n", "\n", "# else, define offset_ wrt contamination parameter", "\n", "", "self", ".", "offset_", "=", "np", ".", "percentile", "(", "self", ".", "score_samples", "(", "X", ")", ",", "\n", "100.", "*", "self", ".", "contamination", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.predict": [[300, 320], ["sklearn.utils.check_array", "numpy.ones", "iforest.IsolationForest.decision_function"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.decision_function"], ["", "def", "predict", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Predict if a particular sample is an outlier or not.\n        Parameters\n        ----------\n        X : array-like or sparse matrix, shape (n_samples, n_features)\n            The input samples. Internally, it will be converted to\n            ``dtype=np.float32`` and if a sparse matrix is provided\n            to a sparse ``csr_matrix``.\n        Returns\n        -------\n        is_inlier : array, shape (n_samples,)\n            For each observation, tells whether or not (+1 or -1) it should\n            be considered as an inlier according to the fitted model.\n        \"\"\"", "\n", "# check_is_fitted(self)", "\n", "X", "=", "check_array", "(", "X", ",", "accept_sparse", "=", "'csr'", ")", "\n", "is_inlier", "=", "np", ".", "ones", "(", "X", ".", "shape", "[", "0", "]", ",", "dtype", "=", "int", ")", "\n", "is_inlier", "[", "self", ".", "decision_function", "(", "X", ")", "<", "0", "]", "=", "-", "1", "\n", "return", "is_inlier", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.decision_function": [[321, 348], ["iforest.IsolationForest.score_samples"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.score_samples"], ["", "def", "decision_function", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Average anomaly score of X of the base classifiers.\n        The anomaly score of an input sample is computed as\n        the mean anomaly score of the trees in the forest.\n        The measure of normality of an observation given a tree is the depth\n        of the leaf containing this observation, which is equivalent to\n        the number of splittings required to isolate this point. In case of\n        several observations n_left in the leaf, the average path length of\n        a n_left samples isolation tree is added.\n        Parameters\n        ----------\n        X : array-like or sparse matrix, shape (n_samples, n_features)\n            The input samples. Internally, it will be converted to\n            ``dtype=np.float32`` and if a sparse matrix is provided\n            to a sparse ``csr_matrix``.\n        Returns\n        -------\n        scores : array, shape (n_samples,)\n            The anomaly score of the input samples.\n            The lower, the more abnormal. Negative scores represent outliers,\n            positive scores represent inliers.\n        \"\"\"", "\n", "# We subtract self.offset_ to make 0 be the threshold value for being", "\n", "# an outlier:", "\n", "\n", "return", "self", ".", "score_samples", "(", "X", ")", "-", "self", ".", "offset_", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.score_samples": [[349, 383], ["sklearn.utils.check_array", "ValueError", "iforest.IsolationForest._compute_chunked_score_samples"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_chunked_score_samples"], ["", "def", "score_samples", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Opposite of the anomaly score defined in the original paper.\n        The anomaly score of an input sample is computed as\n        the mean anomaly score of the trees in the forest.\n        The measure of normality of an observation given a tree is the depth\n        of the leaf containing this observation, which is equivalent to\n        the number of splittings required to isolate this point. In case of\n        several observations n_left in the leaf, the average path length of\n        a n_left samples isolation tree is added.\n        Parameters\n        ----------\n        X : array-like or sparse matrix, shape (n_samples, n_features)\n            The input samples.\n        Returns\n        -------\n        scores : array, shape (n_samples,)\n            The anomaly score of the input samples.\n            The lower, the more abnormal.\n        \"\"\"", "\n", "# code structure from ForestClassifier/predict_proba", "\n", "# check_is_fitted(self)", "\n", "\n", "# Check data", "\n", "X", "=", "check_array", "(", "X", ",", "accept_sparse", "=", "'csr'", ")", "\n", "if", "self", ".", "n_features_", "!=", "X", ".", "shape", "[", "1", "]", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of features of the model must \"", "\n", "\"match the input. Model n_features is {0} and \"", "\n", "\"input n_features is {1}.\"", "\n", "\"\"", ".", "format", "(", "self", ".", "n_features_", ",", "X", ".", "shape", "[", "1", "]", ")", ")", "\n", "\n", "# Take the opposite of the scores as bigger is better (here less", "\n", "# abnormal)", "\n", "", "return", "-", "self", ".", "_compute_chunked_score_samples", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_chunked_score_samples": [[384, 418], ["time.time", "sklearn.utils.validation._num_samples", "sklearn.utils.get_chunk_n_rows", "sklearn.utils.gen_batches", "numpy.zeros", "time.time", "iforest.IsolationForest._compute_score_samples"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_score_samples"], ["", "def", "_compute_chunked_score_samples", "(", "self", ",", "X", ")", ":", "\n", "        ", "t0", "=", "time", ".", "time", "(", ")", "\n", "\n", "n_samples", "=", "_num_samples", "(", "X", ")", "\n", "\n", "if", "self", ".", "_max_features", "==", "X", ".", "shape", "[", "1", "]", ":", "\n", "            ", "subsample_features", "=", "False", "\n", "", "else", ":", "\n", "            ", "subsample_features", "=", "True", "\n", "\n", "# We get as many rows as possible within our working_memory budget", "\n", "# (defined by sklearn.get_config()['working_memory']) to store", "\n", "# self._max_features in each row during computation.", "\n", "#", "\n", "# Note:", "\n", "#  - this will get at least 1 row, even if 1 row of score will", "\n", "#    exceed working_memory.", "\n", "#  - this does only account for temporary memory usage while loading", "\n", "#    the data needed to compute the scores -- the returned scores", "\n", "#    themselves are 1D.", "\n", "\n", "", "chunk_n_rows", "=", "get_chunk_n_rows", "(", "row_bytes", "=", "16", "*", "self", ".", "_max_features", ",", "\n", "max_n_rows", "=", "n_samples", ")", "\n", "slices", "=", "gen_batches", "(", "n_samples", ",", "chunk_n_rows", ")", "\n", "\n", "scores", "=", "np", ".", "zeros", "(", "n_samples", ",", "order", "=", "\"f\"", ")", "\n", "\n", "for", "sl", "in", "slices", ":", "\n", "# compute score on the slices of test samples:", "\n", "            ", "scores", "[", "sl", "]", "=", "self", ".", "_compute_score_samples", "(", "X", "[", "sl", "]", ",", "subsample_features", ")", "\n", "\n", "", "t1", "=", "time", ".", "time", "(", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_score_samples": [[419, 455], ["numpy.zeros", "enumerate", "zip", "tree.apply", "tree.decision_path", "numpy.matmul", "numpy.ravel", "iforest._average_path_length", "len", "iforest._average_path_length", "tree.decision_path.sum"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest._average_path_length", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest._average_path_length"], ["", "def", "_compute_score_samples", "(", "self", ",", "X", ",", "subsample_features", ")", ":", "\n", "        ", "\"\"\"\n        Compute the score of each samples in X going through the extra trees.\n        Parameters\n        ----------\n        X : array-like or sparse matrix\n        subsample_features : bool,\n            whether features should be subsampled\n        \"\"\"", "\n", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "depths", "=", "np", ".", "zeros", "(", "n_samples", ",", "order", "=", "\"f\"", ")", "\n", "\n", "for", "idx", ",", "(", "tree", ",", "features", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "estimators_", ",", "self", ".", "estimators_features_", ")", ")", ":", "\n", "            ", "X_subset", "=", "X", "[", ":", ",", "features", "]", "if", "subsample_features", "else", "X", "\n", "if", "self", ".", "rotate", ":", "\n", "                ", "X_subset", "=", "np", ".", "matmul", "(", "X_subset", ",", "self", ".", "rotation_matrix", "[", "idx", "]", ")", "\n", "\n", "", "leaves_index", "=", "tree", ".", "apply", "(", "X_subset", ")", "\n", "node_indicator", "=", "tree", ".", "decision_path", "(", "X_subset", ")", "\n", "n_samples_leaf", "=", "tree", ".", "tree_", ".", "n_node_samples", "[", "leaves_index", "]", "\n", "\n", "depths", "+=", "(", "\n", "np", ".", "ravel", "(", "node_indicator", ".", "sum", "(", "axis", "=", "1", ")", ")", "\n", "+", "_average_path_length", "(", "n_samples_leaf", ")", "\n", "-", "1.0", "\n", ")", "\n", "\n", "", "scores", "=", "2", "**", "(", "\n", "-", "depths", "\n", "/", "(", "len", "(", "self", ".", "estimators_", ")", "\n", "*", "_average_path_length", "(", "[", "self", ".", "max_samples_", "]", ")", ")", "\n", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_actual_depth": [[456, 476], ["numpy.zeros", "enumerate", "numpy.array", "zip", "tree.apply", "tree.decision_path", "len", "numpy.matmul", "numpy.array", "numpy.ravel", "tree.decision_path.sum"], "methods", ["None"], ["", "def", "_compute_actual_depth", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        New\n        \"\"\"", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "depths", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "estimators_", ")", ",", "n_samples", ")", ")", "\n", "\n", "for", "idx", ",", "(", "tree", ",", "features", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "estimators_", ",", "self", ".", "estimators_features_", ")", ")", ":", "\n", "            ", "if", "self", ".", "rotate", ":", "\n", "                ", "Xs", "=", "X", "[", ":", ",", "features", "]", "\n", "Xs", "=", "np", ".", "matmul", "(", "Xs", ",", "self", ".", "rotation_matrix", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "                ", "Xs", "=", "np", ".", "array", "(", "X", ")", "\n", "\n", "", "leaves_index", "=", "tree", ".", "apply", "(", "Xs", ")", "\n", "node_indicator", "=", "tree", ".", "decision_path", "(", "Xs", ")", "\n", "depths", "[", "idx", "]", "=", "np", ".", "ravel", "(", "node_indicator", ".", "sum", "(", "axis", "=", "1", ")", ")", "-", "1.0", "\n", "\n", "", "return", "np", ".", "array", "(", "depths", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_actual_depth_leaf": [[477, 500], ["numpy.zeros", "numpy.zeros", "enumerate", "zip", "tree.apply", "tree.decision_path", "numpy.array", "numpy.array", "len", "len", "numpy.matmul", "numpy.array", "numpy.ravel", "tree.decision_path.sum"], "methods", ["None"], ["", "def", "_compute_actual_depth_leaf", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        New\n        \"\"\"", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "depths", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "estimators_", ")", ",", "n_samples", ")", ")", "\n", "leaves", "=", "np", ".", "zeros", "(", "(", "len", "(", "self", ".", "estimators_", ")", ",", "n_samples", ")", ")", "\n", "\n", "for", "idx", ",", "(", "tree", ",", "features", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "estimators_", ",", "self", ".", "estimators_features_", ")", ")", ":", "\n", "            ", "if", "self", ".", "rotate", ":", "\n", "                ", "Xs", "=", "np", ".", "matmul", "(", "X", "[", ":", ",", "features", "]", ",", "self", ".", "rotation_matrix", "[", "idx", "]", ")", "\n", "", "else", ":", "\n", "                ", "Xs", "=", "np", ".", "array", "(", "X", ")", "\n", "\n", "", "leaves_index", "=", "tree", ".", "apply", "(", "Xs", ")", "\n", "node_indicator", "=", "tree", ".", "decision_path", "(", "Xs", ")", "\n", "n_samples_leaf", "=", "tree", ".", "tree_", ".", "n_node_samples", "[", "leaves_index", "]", "\n", "\n", "depths", "[", "idx", "]", "=", "np", ".", "ravel", "(", "node_indicator", ".", "sum", "(", "axis", "=", "1", ")", ")", "-", "1.0", "\n", "leaves", "[", "idx", "]", "=", "n_samples_leaf", "\n", "\n", "", "return", "np", ".", "array", "(", "depths", ")", ",", "np", ".", "array", "(", "leaves", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._probability": [[501, 510], ["iforest.IsolationForest._compute_actual_depth_leaf", "enumerate", "numpy.array", "zip", "scipy.stats.zscore", "iforest._average_path_length", "max", "scipy.special.erf", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_actual_depth_leaf", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest._average_path_length"], ["", "def", "_probability", "(", "self", ",", "X", ")", ":", "\n", "        ", "depths", ",", "leaves", "=", "self", ".", "_compute_actual_depth_leaf", "(", "X", ")", "\n", "for", "idx", ",", "(", "d", ",", "l", ")", "in", "enumerate", "(", "zip", "(", "depths", ",", "leaves", ")", ")", ":", "\n", "            ", "depths", "[", "idx", "]", "=", "d", "+", "_average_path_length", "(", "l", ")", "\n", "\n", "", "dp", "=", "-", "zscore", "(", "depths", ",", "axis", "=", "1", ")", "\n", "scores", "=", "np", ".", "array", "(", "[", "max", "(", "i", ",", "0", ")", "for", "i", "in", "erf", "(", "np", ".", "mean", "(", "dp", ",", "axis", "=", "0", ")", ")", "]", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_depth": [[511, 537], ["tree.apply", "tree.decision_path", "depths.append", "numpy.array", "numpy.ravel", "iforest._average_path_length", "tree.decision_path.sum"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest._average_path_length"], ["", "def", "_compute_depth", "(", "self", ",", "X", ")", ":", "\n", "        ", "\"\"\"\n        Compute the score of each samples in X going through the extra trees.\n        Parameters\n        ----------\n        X : array-like or sparse matrix\n        subsample_features : bool,\n            whether features should be subsampled\n        \"\"\"", "\n", "n_samples", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "# depths = np.zeros(n_samples, order=\"f\")", "\n", "depths", "=", "[", "]", "\n", "\n", "for", "tree", "in", "self", ".", "estimators_", ":", "\n", "            ", "leaves_index", "=", "tree", ".", "apply", "(", "X", ")", "\n", "node_indicator", "=", "tree", ".", "decision_path", "(", "X", ")", "\n", "n_samples_leaf", "=", "tree", ".", "tree_", ".", "n_node_samples", "[", "leaves_index", "]", "\n", "\n", "depths", ".", "append", "(", "\n", "np", ".", "ravel", "(", "node_indicator", ".", "sum", "(", "axis", "=", "1", ")", ")", "\n", "+", "_average_path_length", "(", "n_samples_leaf", ")", "\n", "-", "1.0", "\n", ")", "\n", "\n", "", "return", "np", ".", "array", "(", "depths", ")", ".", "T", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest._average_path_length": [[539, 572], ["sklearn.utils.check_array", "n_samples_leaf.reshape.reshape", "numpy.zeros", "np.zeros.reshape", "numpy.logical_or", "numpy.log"], "function", ["None"], ["", "", "def", "_average_path_length", "(", "n_samples_leaf", ")", ":", "\n", "    ", "\"\"\"\n    The average path length in a n_samples iTree, which is equal to\n    the average path length of an unsuccessful BST search since the\n    latter has the same structure as an isolation tree.\n    Parameters\n    ----------\n    n_samples_leaf : array-like, shape (n_samples,).\n        The number of training samples in each test sample leaf, for\n        each estimators.\n    Returns\n    -------\n    average_path_length : array, same shape as n_samples_leaf\n    \"\"\"", "\n", "\n", "n_samples_leaf", "=", "check_array", "(", "n_samples_leaf", ",", "ensure_2d", "=", "False", ")", "\n", "\n", "n_samples_leaf_shape", "=", "n_samples_leaf", ".", "shape", "\n", "n_samples_leaf", "=", "n_samples_leaf", ".", "reshape", "(", "(", "1", ",", "-", "1", ")", ")", "\n", "average_path_length", "=", "np", ".", "zeros", "(", "n_samples_leaf", ".", "shape", ")", "\n", "\n", "mask_1", "=", "n_samples_leaf", "<=", "1", "\n", "mask_2", "=", "n_samples_leaf", "==", "2", "\n", "not_mask", "=", "~", "np", ".", "logical_or", "(", "mask_1", ",", "mask_2", ")", "\n", "\n", "average_path_length", "[", "mask_1", "]", "=", "0.", "\n", "average_path_length", "[", "mask_2", "]", "=", "1.", "\n", "average_path_length", "[", "not_mask", "]", "=", "(", "\n", "2.0", "*", "(", "np", ".", "log", "(", "n_samples_leaf", "[", "not_mask", "]", "-", "1.0", ")", "+", "np", ".", "euler_gamma", ")", "\n", "-", "2.0", "*", "(", "n_samples_leaf", "[", "not_mask", "]", "-", "1.0", ")", "/", "n_samples_leaf", "[", "not_mask", "]", "\n", ")", "\n", "\n", "return", "average_path_length", ".", "reshape", "(", "n_samples_leaf_shape", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.__init__": [[21, 29], ["float"], "methods", ["None"], ["\t", "def", "__init__", "(", "self", ",", "lower_bound", "=", "9", ",", "upper_bound", "=", "12", ",", "max_depth", "=", "7", ",", "\n", "rotate", "=", "True", ",", "contamination", "=", "'auto'", ",", "random_state", "=", "None", ")", ":", "\n", "\t\t", "self", ".", "lower_bound", "=", "lower_bound", "\n", "self", ".", "upper_bound", "=", "upper_bound", "\n", "self", ".", "max_depth", "=", "max_depth", "\n", "self", ".", "rotate", "=", "rotate", "\n", "self", ".", "contamination", "=", "contamination", "if", "contamination", "==", "'auto'", "else", "float", "(", "contamination", ")", "\n", "self", ".", "random_state", "=", "random_state", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.func": [[30, 40], ["iforest.IsolationForest().fit", "numpy.mean", "numpy.arange", "numpy.histogram", "iforest.IsolationForest().fit._compute_actual_depth", "int", "int", "iforest.IsolationForest", "numpy.mean.min", "numpy.mean.max", "numpy.argmax", "len"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_actual_depth"], ["", "def", "func", "(", "self", ",", "Xs", ",", "i", ")", ":", "\n", "### Fit forest with full-grown trees", "\n", "\t\t", "clf", "=", "IsolationForest", "(", "random_state", "=", "self", ".", "random_state", ",", "\n", "max_samples", "=", "len", "(", "Xs", ")", ",", "\n", "contamination", "=", "self", ".", "contamination", ",", "\n", "rotate", "=", "self", ".", "rotate", ")", ".", "fit", "(", "Xs", ",", "max_depth", "=", "100000000", ")", "\n", "depths", "=", "np", ".", "mean", "(", "clf", ".", "_compute_actual_depth", "(", "Xs", ")", ",", "axis", "=", "0", ")", "\n", "bins", "=", "np", ".", "arange", "(", "int", "(", "depths", ".", "min", "(", ")", ")", ",", "int", "(", "depths", ".", "max", "(", ")", "+", "2", ")", ")", "\n", "y", ",", "x", "=", "np", ".", "histogram", "(", "depths", ",", "bins", "=", "bins", ")", "\n", "return", "i", ",", "x", "[", "np", ".", "argmax", "(", "y", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit": [[41, 58], ["sklearn.linear_model.LinearRegression().fit", "iforest.IsolationForest().fit", "numpy.random.seed", "joblib.Parallel", "numpy.array", "x_arr.reshape", "sklearn.linear_model.LinearRegression", "iforest.IsolationForest", "joblib.delayed", "numpy.arange", "len", "numpy.random.choice"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit"], ["", "def", "fit", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "if", "self", ".", "random_state", ":", "\n", "\t\t\t", "np", ".", "random", ".", "seed", "(", "self", ".", "random_state", ")", "\n", "", "self", ".", "n_sample", "=", "X", ".", "shape", "[", "0", "]", "\n", "\n", "params_arr", "=", "Parallel", "(", "n_jobs", "=", "self", ".", "upper_bound", "-", "self", ".", "lower_bound", ")", "(", "\n", "[", "delayed", "(", "self", ".", "func", ")", "(", "X", "[", "np", ".", "random", ".", "choice", "(", "self", ".", "n_sample", ",", "2", "**", "i", ",", "replace", "=", "True", ")", "]", ",", "i", ")", "\n", "for", "i", "in", "np", ".", "arange", "(", "self", ".", "lower_bound", ",", "self", ".", "upper_bound", ")", "]", ")", "\n", "x_arr", ",", "y_arr", "=", "np", ".", "array", "(", "params_arr", ")", ".", "T", "\n", "\n", "self", ".", "reg", "=", "LinearRegression", "(", "fit_intercept", "=", "False", ")", ".", "fit", "(", "x_arr", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "y_arr", ")", "\n", "self", ".", "clf", "=", "IsolationForest", "(", "random_state", "=", "self", ".", "random_state", ",", "\n", "max_samples", "=", "len", "(", "X", ")", ",", "\n", "contamination", "=", "self", ".", "contamination", ",", "\n", "rotate", "=", "self", ".", "rotate", ")", ".", "fit", "(", "X", ",", "max_depth", "=", "self", ".", "max_depth", ")", "\n", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.average_path_length": [[59, 64], ["numpy.array", "gen2out.gen2Out.reg.predict", "numpy.log2"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest.predict"], ["", "def", "average_path_length", "(", "self", ",", "n", ")", ":", "\n", "\t\t", "n", "=", "np", ".", "array", "(", "n", ")", "\n", "apl", "=", "self", ".", "reg", ".", "predict", "(", "np", ".", "log2", "(", "[", "n", "]", ")", ".", "T", ")", "\n", "apl", "[", "apl", "<", "0", "]", "=", "0", "\n", "return", "apl", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.decision_function": [[65, 77], ["gen2out.gen2Out.clf._compute_actual_depth_leaf", "numpy.zeros", "zip", "gen2out.gen2Out.average_path_length", "len", "gen2out.gen2Out.average_path_length"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.iforest.IsolationForest._compute_actual_depth_leaf", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.average_path_length", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.average_path_length"], ["", "def", "decision_function", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "depths", ",", "leaves", "=", "self", ".", "clf", ".", "_compute_actual_depth_leaf", "(", "X", ")", "\n", "\n", "new_depths", "=", "np", ".", "zeros", "(", "X", ".", "shape", "[", "0", "]", ")", "\n", "for", "d", ",", "l", "in", "zip", "(", "depths", ",", "leaves", ")", ":", "\n", "\t\t\t", "new_depths", "+=", "d", "+", "self", ".", "average_path_length", "(", "l", ")", "\n", "\n", "", "scores", "=", "2", "**", "(", "-", "new_depths", "\n", "/", "(", "len", "(", "self", ".", "clf", ".", "estimators_", ")", "\n", "*", "self", ".", "average_path_length", "(", "[", "self", ".", "n_sample", "]", ")", ")", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.point_anomaly_scores": [[78, 81], ["gen2out.gen2Out.fit", "gen2out.gen2Out.decision_function"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.decision_function"], ["", "def", "point_anomaly_scores", "(", "self", ",", "X", ")", ":", "\n", "\t\t", "self", "=", "self", ".", "fit", "(", "X", ")", "\n", "return", "self", ".", "decision_function", "(", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.group_anomaly_scores": [[82, 126], ["numpy.zeros", "print", "tqdm.tqdm.tqdm", "numpy.max", "numpy.max", "enumerate", "numpy.array", "sklearn.cluster.DBSCAN().fit_predict", "zip", "numpy.argmax", "numpy.array", "int", "range", "range", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.ones().astype", "numpy.mean", "len", "gen2out.gen2Out.fit", "gen2out.gen2Out.decision_function", "numpy.std", "numpy.array.append", "sklearn.cluster.DBSCAN", "numpy.arange", "numpy.unique", "scipy.spatial.distance.cityblock", "gen2out.gen2Out.s_arr[].append", "numpy.median", "numpy.where", "numpy.unique", "numpy.log2", "numpy.ones", "len", "numpy.random.choice", "len", "len", "int", "numpy.log2", "len"], "methods", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.fit", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.gen2out.gen2Out.decision_function"], ["", "def", "group_anomaly_scores", "(", "self", ",", "X", ",", "trials", "=", "10", ")", ":", "\n", "### Fit a sequence of gen2Out0", "\n", "\t\t", "self", ".", "min_rate", "=", "int", "(", "np", ".", "log2", "(", "len", "(", "X", ")", ")", "-", "8", ")", "+", "1", "\n", "self", ".", "scores", "=", "np", ".", "zeros", "(", "(", "self", ".", "min_rate", ",", "trials", ",", "len", "(", "X", ")", ")", ")", "\n", "\n", "print", "(", "'Fitting gen2Out0...'", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "self", ".", "min_rate", ")", ")", ":", "\n", "\t\t\t", "for", "j", "in", "range", "(", "trials", ")", ":", "\n", "\t\t\t\t", "X_sampled", "=", "X", "[", "np", ".", "random", ".", "choice", "(", "len", "(", "X", ")", ",", "int", "(", "len", "(", "X", ")", "*", "(", "1", "/", "(", "2", "**", "i", ")", ")", ")", ")", "]", "\n", "clf", "=", "self", ".", "fit", "(", "X_sampled", ")", "\n", "self", ".", "scores", "[", "i", "]", "[", "j", "]", "=", "clf", ".", "decision_function", "(", "X", ")", "\n", "\n", "### Create X-ray plot", "\n", "", "", "smax", "=", "np", ".", "max", "(", "np", ".", "mean", "(", "self", ".", "scores", ",", "axis", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "self", ".", "threshold", "=", "np", ".", "mean", "(", "smax", ")", "+", "3", "*", "np", ".", "std", "(", "smax", ")", "\n", "\n", "sr_list", "=", "[", "]", "\n", "xrays", "=", "np", ".", "max", "(", "np", ".", "mean", "(", "self", ".", "scores", ",", "axis", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "for", "idx", ",", "xray", "in", "enumerate", "(", "xrays", ")", ":", "\n", "\t\t\t", "if", "xray", ">=", "self", ".", "threshold", ":", "\n", "\t\t\t\t", "sr_list", ".", "append", "(", "idx", ")", "\n", "", "", "sr_list", "=", "np", ".", "array", "(", "sr_list", ")", "\n", "\n", "### Outlier grouping", "\n", "groups", "=", "DBSCAN", "(", ")", ".", "fit_predict", "(", "X", "[", "sr_list", "]", ")", "\n", "\n", "self", ".", "labels", "=", "-", "np", ".", "ones", "(", "len", "(", "X", ")", ")", ".", "astype", "(", "int", ")", "\n", "for", "idx", ",", "g", "in", "zip", "(", "sr_list", ",", "groups", ")", ":", "\n", "\t\t\t", "if", "g", "!=", "-", "1", ":", "\n", "\t\t\t\t", "self", ".", "labels", "[", "idx", "]", "=", "g", "+", "1", "\n", "\n", "### Compute iso-curves", "\n", "", "", "xline", "=", "1", "/", "(", "2", "**", "np", ".", "arange", "(", "0", ",", "self", ".", "min_rate", ")", ")", "\n", "self", ".", "s_arr", "=", "[", "[", "]", "for", "l", "in", "np", ".", "unique", "(", "self", ".", "labels", ")", "if", "l", "!=", "-", "1", "]", "\n", "xrays_max", "=", "np", ".", "argmax", "(", "np", ".", "mean", "(", "self", ".", "scores", ",", "axis", "=", "1", ")", ",", "axis", "=", "0", ")", "\n", "for", "idx", "in", "sr_list", ":", "\n", "\t\t\t", "if", "self", ".", "labels", "[", "idx", "]", "!=", "-", "1", ":", "\n", "\t\t\t\t", "dis", "=", "cityblock", "(", "[", "np", ".", "log2", "(", "xrays_max", "[", "idx", "]", ")", "/", "10", "+", "1", ",", "xrays", "[", "idx", "]", "]", ",", "[", "1", ",", "1", "]", ")", "\n", "self", ".", "s_arr", "[", "self", ".", "labels", "[", "idx", "]", "-", "1", "]", ".", "append", "(", "(", "2", "-", "dis", ")", "/", "2", ")", "\n", "\n", "", "", "ga_scores", "=", "np", ".", "array", "(", "[", "np", ".", "median", "(", "s", ")", "for", "s", "in", "self", ".", "s_arr", "]", ")", "\n", "ga_indices", "=", "[", "np", ".", "where", "(", "self", ".", "labels", "==", "l", ")", "[", "0", "]", "for", "l", "in", "np", ".", "unique", "(", "self", ".", "labels", ")", "if", "l", "!=", "-", "1", "]", "\n", "\n", "return", "ga_scores", ",", "ga_indices", "", "", "", ""]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.uni_disk": [[13, 19], ["numpy.random.uniform", "numpy.random.uniform", "numpy.sqrt", "numpy.cos", "numpy.sqrt", "numpy.sin"], "function", ["None"], ["def", "uni_disk", "(", "n", ",", "low", "=", "0", ",", "high", "=", "1", ")", ":", "\n", "    ", "r", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "low", ",", "high", "=", "high", ",", "size", "=", "n", ")", "# radius", "\n", "theta", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0", ",", "high", "=", "2", "*", "np", ".", "pi", ",", "size", "=", "n", ")", "# angle", "\n", "x", "=", "np", ".", "sqrt", "(", "r", ")", "*", "np", ".", "cos", "(", "theta", ")", "\n", "y", "=", "np", ".", "sqrt", "(", "r", ")", "*", "np", ".", "sin", "(", "theta", ")", "\n", "return", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.sythetic_group_anomaly": [[20, 43], ["numpy.random.seed", "utils.uni_disk", "utils.uni_disk", "utils.uni_disk", "numpy.concatenate", "numpy.concatenate", "numpy.array"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.uni_disk", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.uni_disk", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.uni_disk"], ["", "def", "sythetic_group_anomaly", "(", "seed", "=", "0", ")", ":", "\n", "    ", "np", ".", "random", ".", "seed", "(", "seed", ")", "\n", "\n", "x1", ",", "y1", "=", "uni_disk", "(", "100000", ")", "\n", "x1", "*=", "5", "\n", "y1", "*=", "5", "\n", "\n", "x2", ",", "y2", "=", "uni_disk", "(", "1000", ")", "\n", "x2", "=", "x2", "*", "1.5", "+", "10", "\n", "y2", "=", "y2", "*", "1.5", "+", "5", "\n", "\n", "x3", ",", "y3", "=", "uni_disk", "(", "2000", ")", "\n", "x3", "=", "x3", "*", "6", "+", "3", "\n", "y3", "=", "y3", "-", "10", "\n", "\n", "x4", "=", "[", "11", ",", "-", "2", ",", "13", ",", "14", "]", "\n", "y4", "=", "[", "0", ",", "9", ",", "-", "10", ",", "10", "]", "\n", "\n", "x", "=", "np", ".", "concatenate", "(", "[", "x1", ",", "x2", ",", "x3", ",", "x4", "]", ")", "\n", "y", "=", "np", ".", "concatenate", "(", "[", "y1", ",", "y2", ",", "y3", ",", "y4", "]", ")", "\n", "X_norm", "=", "np", ".", "array", "(", "[", "x", ",", "y", "]", ")", ".", "T", "\n", "\n", "return", "X_norm", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.plot_xray": [[44, 65], ["matplotlib.scatter", "matplotlib.plot", "matplotlib.ylim", "matplotlib.xlim", "matplotlib.xscale", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "numpy.argmax", "matplotlib.scatter", "numpy.arange", "numpy.std", "numpy.mean", "matplotlib.plot", "matplotlib.fill_between"], "function", ["None"], ["", "def", "plot_xray", "(", "X", ",", "model", ",", "idx_arr", ",", "line", "=", "False", ")", ":", "\n", "    ", "plt", ".", "scatter", "(", "1", ",", "1", ",", "s", "=", "100", ",", "c", "=", "'k'", ",", "marker", "=", "'*'", ")", "\n", "xline", "=", "1", "/", "(", "2", "**", "np", ".", "arange", "(", "0", ",", "model", ".", "min_rate", ")", ")", "\n", "\n", "for", "idx", "in", "idx_arr", ":", "\n", "        ", "s", "=", "model", ".", "scores", ".", "T", "[", "idx", "]", ".", "T", "\n", "std", ",", "mean", "=", "np", ".", "std", "(", "s", ",", "axis", "=", "1", ")", ",", "np", ".", "mean", "(", "s", ",", "axis", "=", "1", ")", "\n", "if", "line", ":", "\n", "            ", "plt", ".", "plot", "(", "xline", ",", "mean", ",", "c", "=", "'k'", ",", "alpha", "=", "0.7", ")", "\n", "plt", ".", "fill_between", "(", "xline", ",", "mean", "-", "std", ",", "mean", "+", "std", ",", "color", "=", "'grey'", ",", "alpha", "=", "0.2", ")", "\n", "\n", "", "max_idx", "=", "np", ".", "argmax", "(", "mean", ")", "\n", "plt", ".", "scatter", "(", "xline", "[", "max_idx", "]", ",", "mean", "[", "max_idx", "]", ",", "s", "=", "20", ",", "c", "=", "'k'", ")", "\n", "\n", "", "plt", ".", "plot", "(", "[", "2", "**", "(", "-", "(", "model", ".", "min_rate", "-", "0.7", ")", ")", ",", "1.2", "]", ",", "[", "model", ".", "threshold", ",", "model", ".", "threshold", "]", ",", "'--'", ",", "label", "=", "'Mean + 3 * Std'", ",", "alpha", "=", "0.8", ",", "c", "=", "'r'", ")", "\n", "plt", ".", "ylim", "(", "-", "0.05", ",", "1.05", ")", "\n", "plt", ".", "xlim", "(", "2", "**", "(", "-", "(", "model", ".", "min_rate", "-", "0.7", ")", ")", ",", "1.2", ")", "\n", "plt", ".", "xscale", "(", "'log'", ",", "base", "=", "2", ")", "\n", "plt", ".", "xlabel", "(", "'Qualification Rate'", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "ylabel", "(", "'Anomaly Score'", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "legend", "(", "fontsize", "=", "12", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.plot_results": [[66, 161], ["numpy.concatenate", "matplotlib.figure", "matplotlib.hexbin", "matplotlib.colorbar", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.figure", "utils.plot_xray", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.figure", "utils.plot_xray", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.figure", "matplotlib.scatter", "numpy.unique", "matplotlib.legend", "matplotlib.tight_layout", "matplotlib.savefig", "numpy.arange", "matplotlib.figure", "matplotlib.scatter", "matplotlib.colorbar", "matplotlib.scatter", "numpy.unique", "matplotlib.xscale", "matplotlib.ylim", "matplotlib.xlim", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "matplotlib.tight_layout", "matplotlib.savefig", "matplotlib.figure", "enumerate", "matplotlib.xticks", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.tight_layout", "matplotlib.savefig", "numpy.arange", "numpy.array", "numpy.array", "numpy.array", "numpy.median", "matplotlib.scatter", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "matplotlib.plot", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "numpy.arange", "matplotlib.scatter", "man_x.append", "man_y.append", "man_dis.append", "numpy.arange", "matplotlib.plot", "numpy.argmax", "matplotlib.scatter", "matplotlib.plot", "numpy.min", "numpy.max", "numpy.percentile", "numpy.percentile", "len", "numpy.where", "scipy.spatial.distance.cityblock", "numpy.std", "numpy.mean", "str", "range", "len", "str", "str", "numpy.log2"], "function", ["home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.plot_xray", "home.repos.pwc.inspect_result.mengchillee_gen2out.None.utils.plot_xray"], ["", "def", "plot_results", "(", "X", ",", "model", ")", ":", "\n", "### Randomly sample when plotting", "\n", "    ", "idx_arr", "=", "np", ".", "concatenate", "(", "[", "np", ".", "arange", "(", "300", ")", ",", "\n", "np", ".", "arange", "(", "100000", ",", "100300", ")", ",", "\n", "np", ".", "arange", "(", "101000", ",", "101300", ")", ",", "\n", "np", ".", "arange", "(", "103000", ",", "103004", ")", "]", ")", "\n", "\n", "### Plot heatmap", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "4.8", ",", "4", ")", ")", "\n", "plt", ".", "hexbin", "(", "X", "[", ":", ",", "0", "]", ",", "X", "[", ":", ",", "1", "]", ",", "cmap", "=", "'cool'", ",", "gridsize", "=", "30", ",", "bins", "=", "'log'", ",", "mincnt", "=", "1", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'results/step0_heatmap.png'", ")", "\n", "\n", "### Step 1: X-ray plot", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "4", ",", "4", ")", ")", "\n", "plot_xray", "(", "X", ",", "model", ",", "idx_arr", ",", "line", "=", "True", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'results/step1_xray_plot.png'", ")", "\n", "\n", "### Step 2: Apex extraction", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "4", ",", "4", ")", ")", "\n", "plot_xray", "(", "X", ",", "model", ",", "idx_arr", ",", "line", "=", "False", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'results/step2_apex_extraction.png'", ")", "\n", "\n", "### Step 3: Outlier grouping ", "\n", "c_arr", "=", "[", "''", ",", "'b'", ",", "'r'", ",", "'y'", ",", "'m'", ",", "'g'", ",", "'c'", "]", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "4", ",", "4", ")", ")", "\n", "plt", ".", "scatter", "(", "X", "[", ":", ",", "0", "]", ",", "X", "[", ":", ",", "1", "]", ",", "c", "=", "'lightgrey'", ",", "alpha", "=", "0.5", ")", "\n", "\n", "for", "l", "in", "np", ".", "unique", "(", "model", ".", "labels", ")", ":", "\n", "        ", "if", "l", "!=", "-", "1", ":", "\n", "            ", "idx", "=", "np", ".", "where", "(", "model", ".", "labels", "==", "l", ")", "[", "0", "]", "\n", "plt", ".", "scatter", "(", "X", "[", "idx", ",", "0", "]", ",", "X", "[", "idx", ",", "1", "]", ",", "c", "=", "c_arr", "[", "l", "]", ",", "label", "=", "'GA '", "+", "str", "(", "l", ")", ")", "\n", "\n", "", "", "plt", ".", "legend", "(", "fontsize", "=", "12", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'results/step3_outlier_grouping.png'", ")", "\n", "\n", "### Step 4: Anomaly iso-curves", "\n", "man_x", ",", "man_y", ",", "man_dis", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "i", "in", "np", ".", "arange", "(", "0", ",", "model", ".", "min_rate", ",", "0.01", ")", ":", "\n", "        ", "for", "j", "in", "np", ".", "arange", "(", "0", ",", "1.01", ",", "0.01", ")", ":", "\n", "            ", "ix", "=", "1", "/", "(", "2", "**", "i", ")", "\n", "man_x", ".", "append", "(", "ix", ")", "\n", "man_y", ".", "append", "(", "j", ")", "\n", "man_dis", ".", "append", "(", "cityblock", "(", "[", "np", ".", "log2", "(", "ix", ")", "/", "10", ",", "j", "]", ",", "[", "1", ",", "1", "]", ")", ")", "\n", "", "", "man_x", ",", "man_y", ",", "man_dis", "=", "np", ".", "array", "(", "man_x", ")", ",", "np", ".", "array", "(", "man_y", ")", ",", "np", ".", "array", "(", "man_dis", ")", "\n", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "4.8", ",", "4", ")", ")", "\n", "plt", ".", "scatter", "(", "man_x", ",", "man_y", ",", "c", "=", "man_dis", ",", "cmap", "=", "'gist_rainbow'", ",", "alpha", "=", "0.1", ")", "\n", "plt", ".", "colorbar", "(", ")", "\n", "plt", ".", "scatter", "(", "1", ",", "1", ",", "s", "=", "100", ",", "c", "=", "'k'", ",", "marker", "=", "'*'", ")", "\n", "\n", "xline", "=", "1", "/", "(", "2", "**", "np", ".", "arange", "(", "0", ",", "model", ".", "min_rate", ")", ")", "\n", "for", "idx", "in", "idx_arr", ":", "\n", "        ", "if", "model", ".", "labels", "[", "idx", "]", "!=", "-", "1", ":", "\n", "            ", "c", "=", "c_arr", "[", "model", ".", "labels", "[", "idx", "]", "]", "\n", "s", "=", "model", ".", "scores", ".", "T", "[", "idx", "]", ".", "T", "\n", "std", ",", "mean", "=", "np", ".", "std", "(", "s", ",", "axis", "=", "1", ")", ",", "np", ".", "mean", "(", "s", ",", "axis", "=", "1", ")", "\n", "plt", ".", "plot", "(", "xline", ",", "mean", ",", "c", "=", "c", ",", "alpha", "=", "0.05", ")", "\n", "max_idx", "=", "np", ".", "argmax", "(", "mean", ")", "\n", "plt", ".", "scatter", "(", "xline", "[", "max_idx", "]", ",", "mean", "[", "max_idx", "]", ",", "s", "=", "20", ",", "c", "=", "c", ")", "\n", "", "", "for", "l", "in", "np", ".", "unique", "(", "model", ".", "labels", ")", ":", "\n", "        ", "if", "l", "!=", "-", "1", ":", "\n", "            ", "plt", ".", "plot", "(", "[", "]", ",", "[", "]", ",", "'-o'", ",", "c", "=", "c_arr", "[", "l", "]", ",", "label", "=", "'GA '", "+", "str", "(", "l", ")", ")", "\n", "\n", "", "", "plt", ".", "xscale", "(", "'log'", ",", "base", "=", "2", ")", "\n", "plt", ".", "ylim", "(", "-", "0.05", ",", "1.05", ")", "\n", "plt", ".", "xlim", "(", "2", "**", "(", "-", "(", "model", ".", "min_rate", "-", "0.7", ")", ")", ",", "1.2", ")", "\n", "plt", ".", "xlabel", "(", "'Qualification Rate'", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "ylabel", "(", "'Anomaly Score'", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "legend", "(", "fontsize", "=", "12", ",", "loc", "=", "4", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'results/step4_anomaly_isocurves.png'", ")", "\n", "\n", "### Step 5: Scoring", "\n", "plt", ".", "figure", "(", "figsize", "=", "(", "4.4", ",", "4", ")", ")", "\n", "\n", "for", "idx", ",", "s", "in", "enumerate", "(", "model", ".", "s_arr", ")", ":", "\n", "        ", "ymin", ",", "ymax", "=", "np", ".", "min", "(", "s", ")", ",", "np", ".", "max", "(", "s", ")", "\n", "Q1", ",", "Q3", "=", "np", ".", "percentile", "(", "s", ",", "25", ")", ",", "np", ".", "percentile", "(", "s", ",", "75", ")", "\n", "m", "=", "np", ".", "median", "(", "s", ")", "\n", "plt", ".", "scatter", "(", "[", "idx", ",", "idx", "]", ",", "[", "ymin", ",", "ymax", "]", ",", "facecolors", "=", "'none'", ",", "edgecolors", "=", "'lightgrey'", ")", "\n", "plt", ".", "plot", "(", "[", "idx", ",", "idx", "]", ",", "[", "Q1", ",", "Q3", "]", ",", "c", "=", "'grey'", ",", "linewidth", "=", "0.9", ")", "\n", "plt", ".", "plot", "(", "[", "idx", "-", "0.12", ",", "idx", "+", "0.12", "]", ",", "[", "Q1", ",", "Q1", "]", ",", "c", "=", "'grey'", ",", "linewidth", "=", "0.9", ")", "\n", "plt", ".", "plot", "(", "[", "idx", "-", "0.12", ",", "idx", "+", "0.12", "]", ",", "[", "Q3", ",", "Q3", "]", ",", "c", "=", "'grey'", ",", "linewidth", "=", "0.9", ")", "\n", "plt", ".", "plot", "(", "[", "idx", "-", "0.24", ",", "idx", "+", "0.24", "]", ",", "[", "m", ",", "m", "]", ",", "c", "=", "'r'", ",", "linewidth", "=", "3", ")", "\n", "\n", "", "plt", ".", "xticks", "(", "np", ".", "arange", "(", "len", "(", "model", ".", "s_arr", ")", ")", ",", "[", "'GA '", "+", "str", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "len", "(", "model", ".", "s_arr", ")", ")", "]", ",", "fontsize", "=", "12", ")", "\n", "plt", ".", "xlabel", "(", "'Generalized Anomaly ID'", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "ylabel", "(", "'Distribution of\\nAnomaly Score'", ",", "fontsize", "=", "20", ")", "\n", "plt", ".", "tight_layout", "(", ")", "\n", "plt", ".", "savefig", "(", "'results/step5_scoring.png'", ")", "", "", ""]]}