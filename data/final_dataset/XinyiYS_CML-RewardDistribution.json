{"home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.metrics.creditratings": [[15, 21], ["None"], "function", ["None"], ["@", "ex", ".", "named_config", "\n", "def", "creditratings", "(", ")", ":", "\n", "    ", "ds", "=", "\"creditratings\"", "\n", "num_classes", "=", "5", "\n", "d", "=", "2", "\n", "party_data_size", "=", "1000", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.metrics.creditcard": [[23, 29], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "creditcard", "(", ")", ":", "\n", "    ", "ds", "=", "\"creditcard\"", "\n", "num_classes", "=", "5", "\n", "d", "=", "4", "\n", "party_data_size", "=", "5000", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.metrics.mnist": [[31, 37], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "mnist", "(", ")", ":", "\n", "    ", "ds", "=", "\"mnist\"", "\n", "num_classes", "=", "10", "\n", "d", "=", "8", "\n", "party_data_size", "=", "5000", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.metrics.cifar": [[39, 45], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "cifar", "(", ")", ":", "\n", "    ", "ds", "=", "\"cifar\"", "\n", "num_classes", "=", "10", "\n", "d", "=", "8", "\n", "party_data_size", "=", "5000", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.metrics.main": [[47, 218], ["dict", "print", "print", "print", "print", "print", "print", "sorted", "print", "print", "print", "print", "print", "print", "range", "print", "print", "print", "locals().items", "pickle.load", "range", "range", "torch.tensor", "core.kernel.get_kernel", "range", "range", "all_wass.append", "all_dkl.append", "all_num_rewards.append", "all_mmd_u.append", "all_imba.append", "corrs_num_rewards.append", "corrs_mmd.append", "open", "len", "numpy.argmax", "torch.tensor", "torch.tensor", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "imba_after.append", "len", "numpy.mean", "scipy.stats.sem", "numpy.mean", "scipy.stats.sem", "numpy.mean", "scipy.stats.sem", "numpy.mean", "scipy.stats.sem", "numpy.mean", "scipy.stats.sem", "num_rewards_greeds.append", "mmd_unbiased_greeds.append", "numpy.mean", "scipy.stats.sem", "numpy.mean", "scipy.stats.sem", "locals", "print", "range", "range", "numpy.concatenate", "core.mmd.mmd_neg_unbiased_batched().item", "core.mmd.mmd_neg_unbiased_batched().item", "range", "numpy.corrcoef", "numpy.corrcoef", "numpy.corrcoef", "numpy.corrcoef", "numpy.corrcoef", "numpy.corrcoef", "numpy.corrcoef", "len", "metrics.class_imbalance.class_proportion", "len", "len", "core.mmd.mmd_neg_unbiased_batched", "core.mmd.mmd_neg_unbiased_batched", "metrics.class_imbalance.get_classes"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.get_kernel", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.class_imbalance.class_proportion", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_unbiased_batched", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_unbiased_batched", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.class_imbalance.get_classes"], ["", "@", "ex", ".", "automain", "\n", "def", "main", "(", "ds", ",", "num_classes", ",", "d", ",", "party_data_size", ")", ":", "\n", "    ", "args", "=", "dict", "(", "sorted", "(", "locals", "(", ")", ".", "items", "(", ")", ")", ")", "\n", "print", "(", "\"Running with parameters {}\"", ".", "format", "(", "args", ")", ")", "\n", "\n", "# Parameters", "\n", "device", "=", "'cuda:0'", "\n", "num_parties", "=", "5", "\n", "splits", "=", "[", "'equaldisjoint'", ",", "'unequal'", "]", "\n", "inv_temps", "=", "[", "1", ",", "2", ",", "4", ",", "8", "]", "\n", "condition", "=", "'stable'", "\n", "keys", "=", "[", "'party_datasets'", ",", "'party_labels'", ",", "'reference_dataset'", ",", "'candidate_datasets'", ",", "'candidate_labels'", ",", "\n", "'rewards'", ",", "'deltas'", ",", "'mus'", ",", "'alpha'", ",", "'lengthscale'", ",", "'class_props'", ",", "'wass_before'", ",", "'wass_after'", ",", "\n", "'dkl_before'", ",", "'dkl_after'", "]", "\n", "\n", "# Create empty dicts", "\n", "results_dict", "=", "{", "}", "\n", "for", "split", "in", "splits", ":", "\n", "        ", "results_dict", "[", "split", "]", "=", "{", "}", "\n", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "=", "{", "}", "\n", "\n", "# Load data", "\n", "", "", "for", "split", "in", "splits", ":", "\n", "        ", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "tup", "=", "pickle", ".", "load", "(", "open", "(", "\"data/metrics/metrics-{}-{}-{}.p\"", ".", "format", "(", "ds", ",", "\n", "split", ",", "\n", "inv_temp", ")", ",", "\"rb\"", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "keys", ")", ")", ":", "\n", "                ", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "keys", "[", "i", "]", "]", "=", "tup", "[", "i", "]", "\n", "\n", "# Cut down rewards at maximum v(S) attained if stopped early", "\n", "", "", "", "for", "split", "in", "splits", ":", "\n", "        ", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "dic", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "\n", "for", "party", "in", "range", "(", "num_parties", ")", ":", "\n", "                ", "mus", "=", "dic", "[", "'mus'", "]", "[", "party", "]", "\n", "max_mu_idx", "=", "np", ".", "argmax", "(", "mus", ")", "\n", "if", "max_mu_idx", "!=", "len", "(", "mus", ")", "-", "1", ":", "\n", "                    ", "print", "(", "'{}-{}-{} party {}: max at {}, total length is {}'", ".", "format", "(", "ds", ",", "split", ",", "inv_temp", ",", "party", "+", "1", ",", "\n", "max_mu_idx", ",", "len", "(", "mus", ")", ")", ")", "\n", "\n", "# MMD unbiased", "\n", "", "", "", "", "print", "(", "\"Calculating MMD unbiased\"", ")", "\n", "for", "split", "in", "splits", ":", "\n", "        ", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "rewards", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'rewards'", "]", "\n", "reference_dataset", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'reference_dataset'", "]", "\n", "party_datasets", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'party_datasets'", "]", "\n", "reference_dataset_tens", "=", "torch", ".", "tensor", "(", "reference_dataset", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "ls", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'lengthscale'", "]", "\n", "k", "=", "get_kernel", "(", "'se'", ",", "d", ",", "ls", ",", "device", ")", "\n", "mmd_unbiased_before", "=", "[", "0", "for", "i", "in", "range", "(", "num_parties", ")", "]", "\n", "mmd_unbiased_after", "=", "[", "0", "for", "i", "in", "range", "(", "num_parties", ")", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "                ", "party_dataset_tens", "=", "torch", ".", "tensor", "(", "party_datasets", "[", "i", "]", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "party_dataset_with_rewards_tens", "=", "torch", ".", "tensor", "(", "np", ".", "concatenate", "(", "[", "party_datasets", "[", "i", "]", ",", "rewards", "[", "i", "]", "]", ",", "axis", "=", "0", ")", ",", "\n", "device", "=", "device", ",", "\n", "dtype", "=", "torch", ".", "float32", ")", "\n", "mmd_unbiased_before", "[", "i", "]", "=", "-", "mmd_neg_unbiased_batched", "(", "party_dataset_tens", ",", "\n", "reference_dataset_tens", ",", "\n", "k", ")", ".", "item", "(", ")", "\n", "mmd_unbiased_after", "[", "i", "]", "=", "-", "mmd_neg_unbiased_batched", "(", "party_dataset_with_rewards_tens", ",", "\n", "reference_dataset_tens", ",", "\n", "k", ")", ".", "item", "(", ")", "\n", "", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'mmd_unbiased_before'", "]", "=", "mmd_unbiased_before", "\n", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'mmd_unbiased_after'", "]", "=", "mmd_unbiased_after", "\n", "\n", "# Class imbalance", "\n", "", "", "print", "(", "\"Calculating class imbalance\"", ")", "\n", "for", "split", "in", "splits", ":", "# Reduce all party_labels to party_data_size in case its larger", "\n", "        ", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'party_labels'", "]", "=", "[", "labels", "[", ":", "party_data_size", "]", "for", "labels", "in", "\n", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'party_labels'", "]", "]", "\n", "\n", "", "", "for", "split", "in", "splits", ":", "\n", "        ", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "party_datasets", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'party_datasets'", "]", "\n", "party_labels", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'party_labels'", "]", "\n", "rewards", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'rewards'", "]", "\n", "candidate_dataset", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'candidate_datasets'", "]", "[", "0", "]", "\n", "candidate_labels", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'candidate_labels'", "]", "\n", "\n", "imba_after", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "                ", "party_dataset", "=", "party_datasets", "[", "i", "]", "\n", "party_label", "=", "party_labels", "[", "i", "]", "\n", "party_ds_with_rewards", "=", "np", ".", "concatenate", "(", "[", "party_dataset", ",", "rewards", "[", "i", "]", "]", ",", "axis", "=", "0", ")", "\n", "all_dataset", "=", "np", ".", "concatenate", "(", "[", "party_dataset", ",", "candidate_dataset", "]", ",", "axis", "=", "0", ")", "\n", "all_labels", "=", "np", ".", "concatenate", "(", "[", "party_label", ",", "candidate_labels", "]", ",", "axis", "=", "0", ")", "\n", "imba_after", ".", "append", "(", "class_proportion", "(", "get_classes", "(", "party_ds_with_rewards", ",", "\n", "all_dataset", ",", "\n", "all_labels", ")", ",", "num_classes", ")", "[", "1", "]", ")", "\n", "\n", "", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'imba_after'", "]", "=", "imba_after", "\n", "\n", "# Number of rewards", "\n", "", "", "for", "split", "in", "splits", ":", "\n", "        ", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "rewards", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'rewards'", "]", "\n", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'num_rewards'", "]", "=", "[", "len", "(", "rewards", "[", "i", "]", ")", "for", "i", "in", "range", "(", "len", "(", "rewards", ")", ")", "]", "\n", "\n", "# Show alpha", "\n", "", "", "print", "(", "\"======= Alpha =======\"", ")", "\n", "for", "split", "in", "splits", ":", "\n", "        ", "print", "(", "\"Split: {}\"", ".", "format", "(", "split", ")", ")", "\n", "print", "(", "\"Alpha: {}\"", ".", "format", "(", "results_dict", "[", "split", "]", "[", "inv_temps", "[", "0", "]", "]", "[", "'alpha'", "]", ")", ")", "\n", "\n", "# Show mean and standard deviation of correlations across inv_temps", "\n", "", "print", "(", "\"======= Mean and standard deviation of correlations across inv_temps =======\"", ")", "\n", "for", "split", "in", "splits", ":", "\n", "        ", "print", "(", "\"Split: {}\"", ".", "format", "(", "split", ")", ")", "\n", "all_wass", "=", "[", "]", "\n", "all_dkl", "=", "[", "]", "\n", "all_num_rewards", "=", "[", "]", "\n", "all_mmd_u", "=", "[", "]", "\n", "all_imba", "=", "[", "]", "\n", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "alpha", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'alpha'", "]", "\n", "wass", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'wass_after'", "]", "\n", "dkl", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'dkl_after'", "]", "\n", "num_rewards", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'num_rewards'", "]", "\n", "mmd_u", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'mmd_unbiased_after'", "]", "\n", "imba", "=", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'imba_after'", "]", "\n", "\n", "all_wass", ".", "append", "(", "np", ".", "corrcoef", "(", "alpha", ",", "wass", ")", "[", "0", ",", "1", "]", ")", "\n", "all_dkl", ".", "append", "(", "np", ".", "corrcoef", "(", "alpha", ",", "dkl", ")", "[", "0", ",", "1", "]", ")", "\n", "all_num_rewards", ".", "append", "(", "np", ".", "corrcoef", "(", "alpha", ",", "num_rewards", ")", "[", "0", ",", "1", "]", ")", "\n", "all_mmd_u", ".", "append", "(", "np", ".", "corrcoef", "(", "alpha", ",", "mmd_u", ")", "[", "0", ",", "1", "]", ")", "\n", "all_imba", ".", "append", "(", "np", ".", "corrcoef", "(", "alpha", ",", "imba", ")", "[", "0", ",", "1", "]", ")", "\n", "\n", "", "results_dict", "[", "split", "]", "[", "'all_wass'", "]", "=", "all_wass", "\n", "results_dict", "[", "split", "]", "[", "'all_dkl'", "]", "=", "all_dkl", "\n", "results_dict", "[", "split", "]", "[", "'all_num_rewards'", "]", "=", "all_num_rewards", "\n", "results_dict", "[", "split", "]", "[", "'all_mmd_u'", "]", "=", "all_mmd_u", "\n", "results_dict", "[", "split", "]", "[", "'all_imba'", "]", "=", "all_imba", "\n", "\n", "print", "(", "\"MMD: {} +/- {} \\n DKL: {} +/- {} \\n Wass: {} +/- {} \\n Class imbalance: {} +/- {} \\n num rewards: {} +/- {} |\"", ".", "format", "(", "\n", "np", ".", "mean", "(", "all_mmd_u", ")", ",", "\n", "stats", ".", "sem", "(", "all_mmd_u", ")", ",", "\n", "np", ".", "mean", "(", "all_dkl", ")", ",", "\n", "stats", ".", "sem", "(", "all_dkl", ")", ",", "\n", "np", ".", "mean", "(", "all_wass", ")", ",", "\n", "stats", ".", "sem", "(", "all_wass", ")", ",", "\n", "np", ".", "mean", "(", "all_imba", ")", ",", "\n", "stats", ".", "sem", "(", "all_imba", ")", ",", "\n", "np", ".", "mean", "(", "all_num_rewards", ")", ",", "\n", "stats", ".", "sem", "(", "all_num_rewards", ")", ")", ")", "\n", "print", "(", "\"========\"", ")", "\n", "\n", "# Show correlation between inv_temp and number of rewards / MMD unbiased", "\n", "", "print", "(", "\"======= Correlation between inv_temp and number of rewards / MMD unbiased =======\"", ")", "\n", "for", "split", "in", "splits", ":", "\n", "        ", "print", "(", "\"Split: {}\"", ".", "format", "(", "split", ")", ")", "\n", "corrs_num_rewards", "=", "[", "]", "\n", "corrs_mmd", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "# print(\"Party {}\".format(i))", "\n", "            ", "num_rewards_greeds", "=", "[", "]", "\n", "mmd_unbiased_greeds", "=", "[", "]", "\n", "for", "inv_temp", "in", "inv_temps", ":", "\n", "                ", "num_rewards_greeds", ".", "append", "(", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'num_rewards'", "]", "[", "i", "]", ")", "\n", "mmd_unbiased_greeds", ".", "append", "(", "results_dict", "[", "split", "]", "[", "inv_temp", "]", "[", "'mmd_unbiased_after'", "]", "[", "i", "]", ")", "\n", "", "corrs_num_rewards", ".", "append", "(", "np", ".", "corrcoef", "(", "inv_temps", ",", "num_rewards_greeds", ")", "[", "0", ",", "1", "]", ")", "\n", "corrs_mmd", ".", "append", "(", "np", ".", "corrcoef", "(", "inv_temps", ",", "mmd_unbiased_greeds", ")", "[", "0", ",", "1", "]", ")", "\n", "", "print", "(", "\"Correlation between inv_temps and num_rewards mean and std err: {}, {}\"", ".", "format", "(", "np", ".", "mean", "(", "corrs_num_rewards", ")", ",", "\n", "stats", ".", "sem", "(", "\n", "corrs_num_rewards", ")", ")", ")", "\n", "print", "(", "\"Correlation between inv_temps and mmd_unbiased mean and std err: {}, {}\"", ".", "format", "(", "np", ".", "mean", "(", "corrs_mmd", ")", ",", "\n", "stats", ".", "sem", "(", "corrs_mmd", ")", ")", ")", "\n", "print", "(", "\"========\"", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.supervised.creditcard": [[13, 21], ["None"], "function", ["None"], ["@", "ex", ".", "named_config", "\n", "def", "creditcard", "(", ")", ":", "\n", "    ", "ds", "=", "'creditcard'", "\n", "num_classes", "=", "5", "\n", "party_data_size", "=", "5000", "\n", "condition", "=", "'stable'", "\n", "num_parties", "=", "5", "\n", "d", "=", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.supervised.mnist": [[23, 31], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "mnist", "(", ")", ":", "\n", "    ", "ds", "=", "'mnist'", "\n", "num_classes", "=", "10", "\n", "party_data_size", "=", "5000", "\n", "condition", "=", "'stable'", "\n", "num_parties", "=", "5", "\n", "d", "=", "8", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.supervised.cifar": [[33, 41], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "cifar", "(", ")", ":", "\n", "    ", "ds", "=", "'cifar'", "\n", "num_classes", "=", "10", "\n", "party_data_size", "=", "5000", "\n", "condition", "=", "'stable'", "\n", "num_parties", "=", "5", "\n", "d", "=", "8", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.supervised.main": [[43, 146], ["dict", "print", "sorted", "print", "print", "print", "print", "locals().items", "print", "print", "pickle.load", "print", "range", "range", "range", "print", "print", "print", "print", "corrs_before.append", "corrs_with_reward.append", "open", "len", "range", "party_datasets_rewards.append", "party_labels_rewards.append", "range", "numpy.concatenate", "numpy.concatenate", "sklearn.svm.SVC", "sklearn.svm.SVC.fit", "scores_before.append", "sklearn.svm.SVC", "sklearn.svm.SVC.fit", "scores_with_reward.append", "numpy.corrcoef", "numpy.corrcoef", "numpy.mean", "scipy.stats.sem", "numpy.mean", "scipy.stats.sem", "locals", "range", "range", "numpy.where", "numpy.concatenate", "numpy.concatenate", "sklearn.svm.SVC.score", "sklearn.svm.SVC.score", "numpy.allclose", "Exception", "other_party_datasets.append", "other_party_labels.append", "reward_idxs[].append"], "function", ["None"], ["", "@", "ex", ".", "automain", "\n", "def", "main", "(", "ds", ",", "num_classes", ",", "party_data_size", ",", "condition", ",", "num_parties", ",", "d", ")", ":", "\n", "    ", "args", "=", "dict", "(", "sorted", "(", "locals", "(", ")", ".", "items", "(", ")", ")", ")", "\n", "print", "(", "\"Running with parameters {}\"", ".", "format", "(", "args", ")", ")", "\n", "candidate_data_size", "=", "100000", "\n", "splits", "=", "[", "'equaldisjoint'", ",", "'unequal'", "]", "\n", "inv_temps", "=", "[", "1", ",", "2", ",", "4", ",", "8", "]", "\n", "result_dir", "=", "\"data/{}/cgm-results/\"", ".", "format", "(", "ds", ")", "\n", "\n", "for", "split", "in", "splits", ":", "\n", "        ", "print", "(", "\"===========\"", ")", "\n", "print", "(", "split", ")", "\n", "corrs_before", "=", "[", "]", "\n", "corrs_with_reward", "=", "[", "]", "\n", "\n", "for", "inv_temp", "in", "inv_temps", ":", "\n", "            ", "print", "(", "\"-----\"", ")", "\n", "print", "(", "\"inv_temp = {}:\"", ".", "format", "(", "inv_temp", ")", ")", "\n", "file_name", "=", "\"CGM-{}-{}-invtemp{}-{}.p\"", ".", "format", "(", "ds", ",", "\n", "split", ",", "\n", "inv_temp", ",", "\n", "condition", ")", "\n", "(", "\n", "party_datasets", ",", "party_labels", ",", "reference_dataset", ",", "candidate_datasets", ",", "candidate_labels", ",", "rewards", ",", "deltas", ",", "\n", "mus", ",", "\n", "alpha", ")", "=", "pickle", ".", "load", "(", "open", "(", "result_dir", "+", "file_name", ",", "\"rb\"", ")", ")", "\n", "\n", "# Trim party_labels to party_data_size", "\n", "party_labels", "=", "[", "party_labels", "[", "i", "]", "[", ":", "party_data_size", "]", "for", "i", "in", "range", "(", "num_parties", ")", "]", "\n", "\n", "print", "(", "\"alpha = {}\"", ".", "format", "(", "alpha", ")", ")", "\n", "# Get index in candidate set of each reward point", "\n", "candidates", "=", "candidate_datasets", "[", "0", "]", "\n", "reward_idxs", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_parties", ")", "]", "\n", "\n", "for", "party", "in", "range", "(", "num_parties", ")", ":", "\n", "                ", "rews", "=", "rewards", "[", "party", "]", "\n", "n", "=", "len", "(", "rews", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                    ", "rows", ",", "cols", "=", "np", ".", "where", "(", "candidates", "==", "rews", "[", "i", "]", ")", "\n", "index_found", "=", "False", "\n", "for", "row", "in", "rows", ":", "\n", "                        ", "if", "np", ".", "allclose", "(", "rews", "[", "i", "]", ",", "candidates", "[", "row", "]", ")", ":", "\n", "                            ", "reward_idxs", "[", "party", "]", ".", "append", "(", "row", ")", "\n", "index_found", "=", "True", "\n", "break", "\n", "", "", "if", "not", "index_found", ":", "\n", "                        ", "raise", "Exception", "(", "\"Index not found for point {}\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "# Concatenate rewards and labels", "\n", "", "", "", "party_datasets_rewards", "=", "[", "]", "\n", "party_labels_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "                ", "party_datasets_rewards", ".", "append", "(", "\n", "np", ".", "concatenate", "(", "[", "party_datasets", "[", "i", "]", ",", "rewards", "[", "i", "]", "]", ",", "axis", "=", "0", ")", ")", "\n", "party_labels_rewards", ".", "append", "(", "np", ".", "concatenate", "(", "[", "party_labels", "[", "i", "]", ",", "candidate_labels", "[", "reward_idxs", "[", "i", "]", "]", "]", ",", "axis", "=", "0", ")", ")", "\n", "\n", "# Classification with SVM", "\n", "", "scores_before", "=", "[", "]", "\n", "scores_with_reward", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "# Construct test set as all real data in the system except for parties own (unseen data)", "\n", "                ", "other_party_datasets", "=", "[", "]", "\n", "other_party_labels", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "num_parties", ")", ":", "\n", "                    ", "if", "j", "==", "i", ":", "\n", "                        ", "continue", "\n", "", "else", ":", "\n", "                        ", "other_party_datasets", ".", "append", "(", "party_datasets", "[", "j", "]", ")", "\n", "other_party_labels", ".", "append", "(", "party_labels", "[", "j", "]", ")", "\n", "", "", "test_ds", "=", "np", ".", "concatenate", "(", "other_party_datasets", ")", "\n", "test_labels", "=", "np", ".", "concatenate", "(", "other_party_labels", ")", "\n", "\n", "# Without reward", "\n", "train_ds", "=", "party_datasets", "[", "i", "]", "\n", "train_labels", "=", "party_labels", "[", "i", "]", "\n", "clf", "=", "SVC", "(", ")", "\n", "clf", ".", "fit", "(", "train_ds", ",", "train_labels", ")", "\n", "scores_before", ".", "append", "(", "clf", ".", "score", "(", "test_ds", ",", "test_labels", ")", ")", "\n", "\n", "# With reward", "\n", "train_with_reward_ds", "=", "party_datasets_rewards", "[", "i", "]", "\n", "train_with_reward_labels", "=", "party_labels_rewards", "[", "i", "]", "\n", "clf_with_reward", "=", "SVC", "(", ")", "\n", "clf_with_reward", ".", "fit", "(", "train_with_reward_ds", ",", "train_with_reward_labels", ")", "\n", "scores_with_reward", ".", "append", "(", "clf_with_reward", ".", "score", "(", "test_ds", ",", "test_labels", ")", ")", "\n", "\n", "", "print", "(", "\"Classification accuracy before adding rewards:\\n{}\"", ".", "format", "(", "scores_before", ")", ")", "\n", "print", "(", "\"Classification accuracy after adding rewards:\\n{}\"", ".", "format", "(", "scores_with_reward", ")", ")", "\n", "\n", "corr_before", "=", "np", ".", "corrcoef", "(", "alpha", ",", "scores_before", ")", "[", "0", ",", "1", "]", "\n", "print", "(", "\"Correlation with alpha before rewards: {}\"", ".", "format", "(", "corr_before", ")", ")", "\n", "corr_with_reward", "=", "np", ".", "corrcoef", "(", "alpha", ",", "scores_with_reward", ")", "[", "0", ",", "1", "]", "\n", "print", "(", "\"Correlation with alpha after rewards: {}\"", ".", "format", "(", "corr_with_reward", ")", ")", "\n", "corrs_before", ".", "append", "(", "corr_before", ")", "\n", "corrs_with_reward", ".", "append", "(", "corr_with_reward", ")", "\n", "", "print", "(", "\"Average correlation with alpha before rewards for {} split: {}, stderr: {}\"", ".", "format", "(", "split", ",", "\n", "np", ".", "mean", "(", "corrs_before", ")", ",", "\n", "stats", ".", "sem", "(", "corrs_before", ")", "\n", ")", ")", "\n", "print", "(", "\"Average correlation with alpha after rewards for {} split: {}, stderr: {}\"", ".", "format", "(", "split", ",", "\n", "np", ".", "mean", "(", "corrs_with_reward", ")", ",", "\n", "stats", ".", "sem", "(", "corrs_with_reward", ")", "\n", ")", ")", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.cgm.creditratings": [[19, 34], ["None"], "function", ["None"], ["@", "ex", ".", "named_config", "\n", "def", "creditratings", "(", ")", ":", "\n", "    ", "dataset", "=", "\"creditratings\"", "\n", "split", "=", "\"equaldisjoint\"", "# \"equaldisjoint\" or \"unequal\"", "\n", "inv_temp", "=", "1", "\n", "condition", "=", "\"stable\"", "\n", "num_parties", "=", "5", "\n", "num_classes", "=", "5", "\n", "d", "=", "2", "\n", "party_data_size", "=", "1000", "\n", "candidate_data_size", "=", "100000", "\n", "kernel", "=", "'se'", "\n", "gpu", "=", "True", "\n", "batch_size", "=", "2048", "\n", "optimize_kernel_params", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.cgm.creditcard": [[36, 51], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "creditcard", "(", ")", ":", "\n", "    ", "dataset", "=", "\"creditcard\"", "\n", "split", "=", "\"equaldisjoint\"", "# \"equaldisjoint\" or \"unequal\"", "\n", "inv_temp", "=", "1", "\n", "condition", "=", "\"stable\"", "\n", "num_parties", "=", "5", "\n", "num_classes", "=", "5", "\n", "d", "=", "4", "\n", "party_data_size", "=", "5000", "\n", "candidate_data_size", "=", "100000", "\n", "kernel", "=", "'se'", "\n", "gpu", "=", "True", "\n", "batch_size", "=", "256", "\n", "optimize_kernel_params", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.cgm.mnist": [[53, 68], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "mnist", "(", ")", ":", "\n", "    ", "dataset", "=", "\"mnist\"", "\n", "split", "=", "\"equaldisjoint\"", "# \"equaldisjoint\" or \"unequal\"", "\n", "inv_temp", "=", "1", "\n", "condition", "=", "\"stable\"", "\n", "num_parties", "=", "5", "\n", "num_classes", "=", "10", "\n", "d", "=", "8", "\n", "party_data_size", "=", "5000", "\n", "candidate_data_size", "=", "100000", "\n", "kernel", "=", "'se'", "\n", "gpu", "=", "True", "\n", "batch_size", "=", "256", "\n", "optimize_kernel_params", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.cgm.cifar": [[70, 85], ["None"], "function", ["None"], ["", "@", "ex", ".", "named_config", "\n", "def", "cifar", "(", ")", ":", "\n", "    ", "dataset", "=", "\"cifar\"", "\n", "split", "=", "\"equaldisjoint\"", "# \"equaldisjoint\" or \"unequal\"", "\n", "inv_temp", "=", "1", "\n", "condition", "=", "\"stable\"", "\n", "num_parties", "=", "5", "\n", "num_classes", "=", "10", "\n", "d", "=", "8", "\n", "party_data_size", "=", "5000", "\n", "candidate_data_size", "=", "100000", "\n", "kernel", "=", "'se'", "\n", "gpu", "=", "True", "\n", "batch_size", "=", "256", "\n", "optimize_kernel_params", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.None.cgm.main": [[87, 176], ["dict", "print", "pathlib.Path().mkdir", "data.pipeline.get_data_features", "core.kernel.get_kernel", "print", "core.reward_calculation.get_v", "print", "core.reward_calculation.shapley", "print", "core.utils.norm", "print", "core.reward_calculation.get_vN", "core.reward_calculation.get_v_is", "print", "core.reward_calculation.get_v_maxs", "print", "print", "core.reward_calculation.opt_vstar", "print", "print", "print", "list", "print", "core.reward_realization.reward_realization", "pickle.dump", "print", "metrics.compute.compute_metrics", "sorted", "print", "core.kernel.optimize_kernel_binsearch_only", "core.reward_calculation.get_vCi", "map", "numpy.ones", "open", "locals().items", "pathlib.Path", "range", "locals"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.pipeline.get_data_features", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.get_kernel", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.shapley", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.norm", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_vN", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v_is", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v_maxs", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.opt_vstar", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.reward_realization", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.compute.compute_metrics", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.optimize_kernel_binsearch_only", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_vCi"], ["", "@", "ex", ".", "automain", "\n", "def", "main", "(", "dataset", ",", "split", ",", "inv_temp", ",", "condition", ",", "num_parties", ",", "num_classes", ",", "d", ",", "party_data_size", ",", "\n", "candidate_data_size", ",", "kernel", ",", "gpu", ",", "batch_size", ",", "optimize_kernel_params", ")", ":", "\n", "    ", "args", "=", "dict", "(", "sorted", "(", "locals", "(", ")", ".", "items", "(", ")", ")", ")", "\n", "print", "(", "\"Running with parameters {}\"", ".", "format", "(", "args", ")", ")", "\n", "run_id", "=", "ex", ".", "current_run", ".", "_id", "\n", "if", "gpu", "is", "True", ":", "\n", "        ", "device", "=", "'cuda:0'", "# single GPU", "\n", "", "else", ":", "\n", "        ", "device", "=", "'cpu'", "\n", "", "result_dir", "=", "\"data/{}/cgm-results/\"", ".", "format", "(", "dataset", ")", "\n", "Path", "(", "result_dir", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "file_name", "=", "\"CGM-{}-{}-invtemp{}-{}.p\"", ".", "format", "(", "dataset", ",", "\n", "split", ",", "\n", "inv_temp", ",", "\n", "condition", ")", "\n", "\n", "# Setup data and kernel", "\n", "party_datasets", ",", "party_labels", ",", "reference_dataset", ",", "candidate_datasets", ",", "candidate_labels", "=", "get_data_features", "(", "dataset", ",", "\n", "num_classes", ",", "\n", "d", ",", "\n", "num_parties", ",", "\n", "party_data_size", ",", "\n", "candidate_data_size", ",", "\n", "split", ")", "\n", "\n", "kernel", "=", "get_kernel", "(", "kernel", ",", "d", ",", "1.", ",", "device", ")", "\n", "if", "optimize_kernel_params", ":", "\n", "        ", "print", "(", "\"Optimizing kernel parameters\"", ")", "\n", "kernel", ",", "lengthscale", "=", "optimize_kernel_binsearch_only", "(", "kernel", ",", "device", ",", "party_datasets", ",", "reference_dataset", ")", "\n", "\n", "", "print", "(", "\"Kernel lengthscale: {}\"", ".", "format", "(", "kernel", ".", "lengthscale", ")", ")", "\n", "# Reward calculation", "\n", "v", "=", "get_v", "(", "party_datasets", ",", "reference_dataset", ",", "kernel", ",", "device", "=", "device", ",", "batch_size", "=", "batch_size", ")", "\n", "print", "(", "\"Coalition values:\\n{}\"", ".", "format", "(", "v", ")", ")", "\n", "phi", "=", "shapley", "(", "v", ",", "num_parties", ")", "\n", "print", "(", "\"Shapley values:\\n{}\"", ".", "format", "(", "phi", ")", ")", "\n", "alpha", "=", "norm", "(", "phi", ")", "\n", "print", "(", "\"alpha:\\n{}\"", ".", "format", "(", "alpha", ")", ")", "\n", "vN", "=", "get_vN", "(", "v", ",", "num_parties", ")", "\n", "v_is", "=", "get_v_is", "(", "v", ",", "num_parties", ")", "\n", "v_Cis", "=", "[", "get_vCi", "(", "i", ",", "phi", ",", "v", ")", "for", "i", "in", "range", "(", "1", ",", "num_parties", "+", "1", ")", "]", "\n", "print", "(", "\"V_Cis:\\n{}\"", ".", "format", "(", "v_Cis", ")", ")", "\n", "v_maxs", "=", "get_v_maxs", "(", "party_datasets", ",", "reference_dataset", ",", "candidate_datasets", "[", "0", "]", ",", "kernel", ",", "device", ",", "batch_size", ")", "\n", "print", "(", "\"v_maxs:\\n{}\"", ".", "format", "(", "v_maxs", ")", ")", "\n", "\n", "print", "(", "\"Using opt_vstar to calculate reward vector\"", ")", "\n", "q", ",", "v_star", ",", "v_star_frac", ",", "rho", "=", "opt_vstar", "(", "alpha", ",", "v_is", ",", "v_maxs", ",", "v_Cis", ",", "cond", "=", "condition", ",", "rho_penalty", "=", "-", "0.001", ")", "\n", "print", "(", "\"v*: {}\"", ".", "format", "(", "v_star", ")", ")", "\n", "print", "(", "\"Fraction of maximum possible v*: {}\"", ".", "format", "(", "v_star_frac", ")", ")", "\n", "print", "(", "\"rho: {}\"", ".", "format", "(", "rho", ")", ")", "\n", "\n", "r", "=", "list", "(", "map", "(", "q", ",", "alpha", ")", ")", "\n", "print", "(", "\"Reward values: \\n{}\"", ".", "format", "(", "r", ")", ")", "\n", "\n", "# Reward realization", "\n", "inv_temps", "=", "np", ".", "ones", "(", "num_parties", ")", "*", "inv_temp", "\n", "rewards", ",", "deltas", ",", "mus", "=", "reward_realization", "(", "candidate_datasets", ",", "\n", "reference_dataset", ",", "\n", "r", ",", "\n", "party_datasets", ",", "\n", "kernel", ",", "\n", "inv_temps", "=", "inv_temps", ",", "\n", "device", "=", "device", ",", "\n", "batch_size", "=", "batch_size", ")", "\n", "\n", "# Save results", "\n", "pickle", ".", "dump", "(", "\n", "(", "party_datasets", ",", "party_labels", ",", "reference_dataset", ",", "candidate_datasets", ",", "candidate_labels", ",", "rewards", ",", "deltas", ",", "mus", ",", "\n", "alpha", ")", ",", "\n", "open", "(", "result_dir", "+", "file_name", ",", "\"wb\"", ")", ")", "\n", "print", "(", "\"Results saved successfully\"", ")", "\n", "\n", "# Metrics", "\n", "compute_metrics", "(", "dataset", ",", "\n", "split", ",", "\n", "inv_temp", ",", "\n", "num_parties", ",", "\n", "num_classes", ",", "\n", "alpha", ",", "\n", "lengthscale", ",", "\n", "party_datasets", ",", "\n", "party_labels", ",", "\n", "reference_dataset", ",", "\n", "candidate_datasets", ",", "\n", "candidate_labels", ",", "\n", "rewards", ",", "\n", "deltas", ",", "\n", "mus", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.compute.compute_metrics": [[10, 62], ["print", "range", "print", "print", "print", "metrics.phi_div.average_dkl", "print", "print", "metrics.phi_div.average_dkl", "print", "print", "print", "print", "print", "print", "print", "pathlib.Path().mkdir", "pickle.dump", "party_datasets_with_rewards.append", "class_props.append", "metrics.wasserstein.wasserstein_2", "metrics.wasserstein.wasserstein_2", "open", "numpy.concatenate", "metrics.class_imbalance.class_proportion", "range", "numpy.concatenate", "range", "pathlib.Path", "len", "numpy.corrcoef", "metrics.class_imbalance.get_classes", "numpy.corrcoef", "numpy.array", "numpy.array", "os.getcwd"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.phi_div.average_dkl", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.phi_div.average_dkl", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.wasserstein.wasserstein_2", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.wasserstein.wasserstein_2", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.class_imbalance.class_proportion", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.class_imbalance.get_classes"], ["def", "compute_metrics", "(", "ds", ",", "\n", "split", ",", "\n", "inv_temp", ",", "\n", "num_parties", ",", "\n", "num_classes", ",", "\n", "alpha", ",", "\n", "lengthscale", ",", "\n", "party_datasets", ",", "\n", "party_labels", ",", "\n", "reference_dataset", ",", "\n", "candidate_datasets", ",", "\n", "candidate_labels", ",", "\n", "rewards", ",", "\n", "deltas", ",", "\n", "mus", ")", ":", "\n", "    ", "print", "(", "\"Computing metrics\"", ")", "\n", "party_datasets_with_rewards", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "        ", "party_datasets_with_rewards", ".", "append", "(", "np", ".", "concatenate", "(", "[", "party_datasets", "[", "i", "]", ",", "rewards", "[", "i", "]", "]", ",", "axis", "=", "0", ")", ")", "\n", "\n", "", "print", "(", "\"Length of rewards: {}\"", ".", "format", "(", "[", "len", "(", "r", ")", "for", "r", "in", "rewards", "]", ")", ")", "\n", "\n", "print", "(", "\"alpha:\\n{}\"", ".", "format", "(", "alpha", ")", ")", "\n", "\n", "print", "(", "\"Calculating average DKLs before\"", ")", "\n", "dkls_before", "=", "average_dkl", "(", "party_datasets", ",", "reference_dataset", ")", "\n", "print", "(", "dkls_before", ")", "\n", "\n", "print", "(", "\"Calculating average DKLs after\"", ")", "\n", "dkls_after", "=", "average_dkl", "(", "party_datasets_with_rewards", ",", "reference_dataset", ")", "\n", "print", "(", "dkls_after", ")", "\n", "print", "(", "\"Correlation coefficient with alpha: \\n{}\"", ".", "format", "(", "np", ".", "corrcoef", "(", "alpha", ",", "dkls_after", ")", "[", "0", ",", "1", "]", ")", ")", "\n", "\n", "class_props", "=", "[", "]", "\n", "for", "result", "in", "rewards", ":", "\n", "        ", "class_props", ".", "append", "(", "\n", "class_proportion", "(", "get_classes", "(", "np", ".", "array", "(", "result", ")", ",", "candidate_datasets", "[", "0", "]", ",", "candidate_labels", ")", ",", "num_classes", ")", ")", "\n", "", "print", "(", "\"Class proportions and class imbalance of rewards: {}\"", ".", "format", "(", "class_props", ")", ")", "\n", "\n", "print", "(", "\"Calculating Wasserstein-2 before\"", ")", "\n", "wass_before", "=", "[", "wasserstein_2", "(", "party_datasets", "[", "i", "]", ",", "reference_dataset", ")", "for", "i", "in", "range", "(", "num_parties", ")", "]", "\n", "wass_after", "=", "[", "wasserstein_2", "(", "np", ".", "concatenate", "(", "[", "party_datasets", "[", "i", "]", ",", "np", ".", "array", "(", "rewards", "[", "i", "]", ")", "]", ",", "axis", "=", "0", ")", ",", "reference_dataset", ")", "\n", "for", "i", "in", "range", "(", "num_parties", ")", "]", "\n", "print", "(", "\"Wasserstein-2 before: \\n{}\"", ".", "format", "(", "wass_before", ")", ")", "\n", "print", "(", "\"Wasserstein-2 after: \\n{}\"", ".", "format", "(", "wass_after", ")", ")", "\n", "print", "(", "\"Correlation coefficient with alpha: \\n{}\"", ".", "format", "(", "np", ".", "corrcoef", "(", "alpha", ",", "wass_after", ")", "[", "0", ",", "1", "]", ")", ")", "\n", "\n", "#Save metrics", "\n", "Path", "(", "os", ".", "getcwd", "(", ")", "+", "'/data/metrics'", ")", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "pickle", ".", "dump", "(", "(", "party_datasets", ",", "party_labels", ",", "reference_dataset", ",", "candidate_datasets", ",", "candidate_labels", ",", "\n", "rewards", ",", "deltas", ",", "mus", ",", "alpha", ",", "lengthscale", ",", "class_props", ",", "wass_before", ",", "wass_after", ",", "dkls_before", ",", "dkls_after", ")", ",", "\n", "open", "(", "\"data/metrics/metrics-{}-{}-{}.p\"", ".", "format", "(", "ds", ",", "split", ",", "inv_temp", ")", ",", "'wb'", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.wasserstein.wasserstein_2": [[5, 18], ["numpy.mean", "numpy.cov", "numpy.mean", "numpy.cov", "numpy.inner", "numpy.trace", "scipy.linalg.sqrtm"], "function", ["None"], ["def", "wasserstein_2", "(", "P", ",", "Q", ")", ":", "\n", "    ", "\"\"\"\n\n    :param P: (m, d) matrix. Reference data\n    :param Q: (n, d) matrix. Distribution we are evaluating\n    :return: float\n    \"\"\"", "\n", "\n", "P_mean", ",", "P_cov", "=", "np", ".", "mean", "(", "P", ",", "axis", "=", "0", ")", ",", "np", ".", "cov", "(", "P", ",", "rowvar", "=", "False", ")", "\n", "Q_mean", ",", "Q_cov", "=", "np", ".", "mean", "(", "Q", ",", "axis", "=", "0", ")", ",", "np", ".", "cov", "(", "Q", ",", "rowvar", "=", "False", ")", "\n", "\n", "QP_diff", "=", "Q_mean", "-", "P_mean", "\n", "return", "np", ".", "inner", "(", "QP_diff", ",", "QP_diff", ")", "+", "np", ".", "trace", "(", "Q_cov", "+", "P_cov", "-", "2", "*", "sqrtm", "(", "Q_cov", "@", "P_cov", ")", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.class_imbalance.get_classes": [[4, 29], ["range", "numpy.where", "numpy.allclose", "Exception", "reward_classes.append"], "function", ["None"], ["def", "get_classes", "(", "rewards", ",", "candidates", ",", "classes", ")", ":", "\n", "    ", "\"\"\"\n    :param rewards: array of shape (n, d), of which we want to find the classes that the points belong to.\n    Must be a subset of candidates\n    :param candidates: array of shape (m ,d), of which we have the class indexes.\n    :param classes: array of shape (m), indicating the class index of each point in candidates\n    :return: array of shape (n), indicating class index of each point in rewards\n    \"\"\"", "\n", "n", "=", "rewards", ".", "shape", "[", "0", "]", "\n", "m", "=", "candidates", ".", "shape", "[", "0", "]", "\n", "d", "=", "rewards", ".", "shape", "[", "1", "]", "\n", "reward_classes", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "rows", ",", "cols", "=", "np", ".", "where", "(", "candidates", "==", "rewards", "[", "i", "]", ")", "\n", "class_found", "=", "False", "\n", "for", "row", "in", "rows", ":", "\n", "            ", "if", "np", ".", "allclose", "(", "rewards", "[", "i", "]", ",", "candidates", "[", "row", "]", ")", ":", "\n", "                ", "reward_classes", ".", "append", "(", "classes", "[", "row", "]", ")", "\n", "class_found", "=", "True", "\n", "break", "\n", "", "", "if", "not", "class_found", ":", "\n", "            ", "raise", "Exception", "(", "\"Class not found for point {}\"", ".", "format", "(", "i", ")", ")", "\n", "\n", "", "", "return", "reward_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.class_imbalance.class_proportion": [[31, 42], ["numpy.bincount", "len", "numpy.dot"], "function", ["None"], ["", "def", "class_proportion", "(", "classes", ",", "num_classes", ")", ":", "\n", "    ", "\"\"\"\n    :param classes: array of shape (n), indicating class index of each point in rewards. From 0-9\n    :param num_classes: int\n    :return: tuple of (proportions, imbalance_score). proportions is a k-simplex where k is number of classes,\n    imbalance_score is float scalar indicating level of imbalance between classes\n    \"\"\"", "\n", "proportions", "=", "np", ".", "bincount", "(", "classes", ",", "minlength", "=", "num_classes", ")", "/", "len", "(", "classes", ")", "\n", "imbalance_score", "=", "1", "/", "num_classes", "*", "np", ".", "dot", "(", "proportions", ",", "proportions", ")", "\n", "\n", "return", "proportions", ",", "imbalance_score", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.phi_div.dkl": [[6, 74], ["print", "numpy.zeros", "print", "sklearn.neighbors.NearestNeighbors().fit", "NearestNeighbors().fit.kneighbors", "print", "tqdm.tqdm", "print", "range", "print", "print", "print", "print", "print", "print", "print", "print", "range", "numpy.linalg.norm", "numpy.argpartition", "numpy.min", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "sklearn.neighbors.NearestNeighbors", "numpy.nonzero"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.norm"], ["def", "dkl", "(", "P", ",", "Q", ",", "k", "=", "2", ")", ":", "\n", "    ", "\"\"\"\n    Calculates an estimate of the Kullback-Leibler divergence between P and Q based on finite samples from P and Q\n    using k-nearest neighbours (Perez-Cruz, 2008)\n    :param P: array of size (n, d)\n    :param Q: array of size(m, d)\n    :param k: int, kth-nearest neighbour\n    :return: KL(P||Q) estimate\n    \"\"\"", "\n", "print", "(", "\"Calculating DKL for k={}\"", ".", "format", "(", "k", ")", ")", "\n", "(", "n", ",", "d", ")", "=", "P", ".", "shape", "\n", "m", "=", "Q", ".", "shape", "[", "0", "]", "\n", "\n", "PQ_distances", "=", "np", ".", "zeros", "(", "n", ")", "\n", "min_PQ_dist", "=", "np", ".", "inf", "\n", "\n", "print", "(", "\"Calculating P_distances using NN\"", ")", "\n", "P_nbrs", "=", "NearestNeighbors", "(", "n_neighbors", "=", "k", "+", "1", ",", "algorithm", "=", "'ball_tree'", ")", ".", "fit", "(", "P", ")", "\n", "P_distances", ",", "indices", "=", "P_nbrs", ".", "kneighbors", "(", "P", ")", "\n", "\n", "kl", "=", "0", "\n", "print", "(", "\"Calculating PQ_distances\"", ")", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "n", ")", ")", ":", "\n", "        ", "dist_arr", "=", "np", ".", "linalg", ".", "norm", "(", "Q", "-", "P", "[", "i", "]", ",", "axis", "=", "1", ")", "\n", "\n", "partition", "=", "np", ".", "argpartition", "(", "dist_arr", ",", "k", ")", "\n", "idx", "=", "partition", "[", "k", "]", "\n", "PQ_distances", "[", "i", "]", "=", "dist_arr", "[", "idx", "]", "\n", "\n", "curr_min", "=", "np", ".", "min", "(", "dist_arr", "[", "np", ".", "nonzero", "(", "dist_arr", ")", "]", ")", "\n", "if", "curr_min", "<", "min_PQ_dist", ":", "\n", "            ", "min_PQ_dist", "=", "curr_min", "\n", "\n", "", "", "log_P_dist_sum", "=", "0", "\n", "log_PQ_dist_sum", "=", "0", "\n", "num_skips", "=", "0", "\n", "num_replacements", "=", "0", "\n", "\n", "print", "(", "\"Updating KL divergence\"", ")", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "        ", "P_distance", "=", "P_distances", "[", "i", ",", "k", "]", "\n", "\n", "if", "P_distance", "==", "0", ":", "# If P distance is 0, PQ distance will also be 0 so just skip", "\n", "            ", "num_skips", "+=", "1", "\n", "continue", "\n", "\n", "", "PQ_distance", "=", "PQ_distances", "[", "i", "]", "\n", "if", "PQ_distance", "==", "0", ":", "# If PQ distance is 0, replace with smallest distance observed for numerical reasons", "\n", "            ", "num_replacements", "+=", "1", "\n", "PQ_distance", "=", "min_PQ_dist", "\n", "\n", "", "log_PQ_dist_sum", "+=", "np", ".", "log", "(", "PQ_distance", ")", "\n", "log_P_dist_sum", "+=", "np", ".", "log", "(", "P_distance", ")", "\n", "\n", "", "print", "(", "\"num_skips: {}\"", ".", "format", "(", "num_skips", ")", ")", "\n", "print", "(", "\"num_replacements: {}\"", ".", "format", "(", "num_replacements", ")", ")", "\n", "print", "(", "\"log_P_dist_sum: {}\"", ".", "format", "(", "log_P_dist_sum", ")", ")", "\n", "print", "(", "\"log_PQ_dist_sum: {}\"", ".", "format", "(", "log_PQ_dist_sum", ")", ")", "\n", "kl", "+=", "log_PQ_dist_sum", "-", "log_P_dist_sum", "\n", "print", "(", "\"KL before factor and adding logs: {}\"", ".", "format", "(", "kl", ")", ")", "\n", "factor", "=", "d", "/", "n", "\n", "print", "(", "\"factor: {}\"", ".", "format", "(", "factor", ")", ")", "\n", "kl", "*=", "factor", "\n", "const", "=", "np", ".", "log", "(", "m", ")", "-", "np", ".", "log", "(", "n", "-", "1", ")", "\n", "print", "(", "const", ")", "\n", "kl", "+=", "const", "\n", "print", "(", "\"final KL: {}\"", ".", "format", "(", "kl", ")", ")", "\n", "return", "kl", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.phi_div.average_dkl": [[76, 91], ["len", "numpy.zeros", "range", "numpy.array", "print", "phi_div.dkl", "range"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.metrics.phi_div.dkl"], ["", "def", "average_dkl", "(", "party_datasets", ",", "reference_dataset", ",", "min_k", "=", "2", ",", "max_k", "=", "6", ")", ":", "\n", "    ", "num_k", "=", "max_k", "-", "min_k", "+", "1", "\n", "num_parties", "=", "len", "(", "party_datasets", ")", "\n", "dkl_sum", "=", "np", ".", "zeros", "(", "num_parties", ")", "\n", "\n", "for", "k", "in", "range", "(", "min_k", ",", "max_k", "+", "1", ")", ":", "\n", "        ", "dkl_after", "=", "np", ".", "array", "(", "[", "dkl", "(", "party_datasets", "[", "i", "]", ",", "\n", "reference_dataset", ",", "\n", "k", "=", "k", ")", "for", "i", "in", "range", "(", "num_parties", ")", "]", ")", "\n", "print", "(", "\"DKL for k = {}: {}\"", ".", "format", "(", "k", ",", "dkl_after", ")", ")", "\n", "dkl_sum", "+=", "dkl_after", "\n", "\n", "", "avg_dkl", "=", "dkl_sum", "/", "num_k", "\n", "\n", "return", "avg_dkl", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.GMM.sample_GMM": [[4, 23], ["numpy.zeros", "numpy.zeros", "range", "numpy.random.randint", "numpy.random.multivariate_normal"], "function", ["None"], ["def", "sample_GMM", "(", "means", ",", "covs", ",", "num_samples", ")", ":", "\n", "    ", "\"\"\"\n    Samples equally from clusters of normal distributions.\n    \"\"\"", "\n", "assert", "(", "means", ".", "shape", "[", "0", "]", "==", "covs", ".", "shape", "[", "0", "]", ")", "\n", "assert", "(", "means", ".", "shape", "[", "1", "]", "==", "covs", ".", "shape", "[", "1", "]", ")", "\n", "assert", "(", "covs", ".", "shape", "[", "1", "]", "==", "covs", ".", "shape", "[", "2", "]", ")", "\n", "\n", "n", "=", "means", ".", "shape", "[", "0", "]", "\n", "d", "=", "means", ".", "shape", "[", "1", "]", "\n", "samples", "=", "np", ".", "zeros", "(", "(", "num_samples", ",", "d", ")", ")", "\n", "clusters", "=", "np", ".", "zeros", "(", "num_samples", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_samples", ")", ":", "\n", "        ", "cluster", "=", "np", ".", "random", ".", "randint", "(", "n", ")", "\n", "samples", "[", "i", "]", "=", "np", ".", "random", ".", "multivariate_normal", "(", "means", "[", "cluster", "]", ",", "covs", "[", "cluster", "]", ",", "check_valid", "=", "'raise'", ")", "\n", "clusters", "[", "i", "]", "=", "cluster", "\n", "\n", "", "return", "samples", ",", "clusters", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.pipeline.get_proportions": [[6, 33], ["numpy.array", "numpy.array", "numpy.array", "numpy.array"], "function", ["None"], ["def", "get_proportions", "(", "split", ",", "dataset", ")", ":", "\n", "    ", "if", "dataset", "==", "'creditratings'", "or", "dataset", "==", "'creditcard'", ":", "# WARNING: implicitly assumes 5 parties and 5 classes", "\n", "        ", "if", "split", "==", "'equaldisjoint'", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "[", "0.96", ",", "0.01", ",", "0.01", ",", "0.01", ",", "0.01", "]", ",", "\n", "[", "0.01", ",", "0.96", ",", "0.01", ",", "0.01", ",", "0.01", "]", ",", "\n", "[", "0.01", ",", "0.01", ",", "0.96", ",", "0.01", ",", "0.01", "]", ",", "\n", "[", "0.01", ",", "0.01", ",", "0.01", ",", "0.96", ",", "0.01", "]", ",", "\n", "[", "0.01", ",", "0.01", ",", "0.01", ",", "0.01", ",", "0.96", "]", "]", ")", "\n", "", "elif", "split", "==", "'unequal'", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "[", "0.20", ",", "0.20", ",", "0.20", ",", "0.20", ",", "0.20", "]", ",", "\n", "[", "0.20", ",", "0.20", ",", "0.20", ",", "0.20", ",", "0.20", "]", ",", "\n", "[", "0.58", ",", "0.39", ",", "0.01", ",", "0.01", ",", "0.01", "]", ",", "\n", "[", "0.01", ",", "0.20", ",", "0.58", ",", "0.20", ",", "0.01", "]", ",", "\n", "[", "0.01", ",", "0.01", ",", "0.01", ",", "0.39", ",", "0.58", "]", "]", ")", "\n", "", "", "elif", "dataset", "==", "'mnist'", "or", "dataset", "==", "'cifar'", ":", "# WARNING: implicitly assumes 5 parties and 10 classes", "\n", "        ", "if", "split", "==", "'equaldisjoint'", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "[", "0.480", ",", "0.480", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", "]", ",", "\n", "[", "0.005", ",", "0.005", ",", "0.480", ",", "0.480", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", "]", ",", "\n", "[", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.480", ",", "0.480", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", "]", ",", "\n", "[", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.480", ",", "0.480", ",", "0.005", ",", "0.005", "]", ",", "\n", "[", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.480", ",", "0.480", "]", "]", ")", "\n", "", "elif", "split", "==", "'unequal'", ":", "\n", "            ", "return", "np", ".", "array", "(", "[", "[", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", "]", ",", "\n", "[", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", ",", "0.100", "]", ",", "\n", "[", "0.290", ",", "0.290", ",", "0.195", ",", "0.195", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", "]", ",", "\n", "[", "0.005", ",", "0.005", ",", "0.100", ",", "0.100", ",", "0.290", ",", "0.290", ",", "0.100", ",", "0.100", ",", "0.005", ",", "0.005", "]", ",", "\n", "[", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.005", ",", "0.195", ",", "0.195", ",", "0.290", ",", "0.290", "]", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.pipeline.get_data_features": [[35, 77], ["pipeline.get_proportions", "numpy.concatenate", "numpy.concatenate", "numpy.random.seed", "numpy.random.uniform", "numpy.zeros", "range", "numpy.zeros", "range", "core.utils.split_proportions", "data.GMM.sample_GMM", "numpy.array", "numpy.random.multivariate_normal", "numpy.random.seed", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "numpy.array", "Exception", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.pipeline.get_proportions", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.split_proportions", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.GMM.sample_GMM"], ["", "", "", "def", "get_data_features", "(", "dataset", ",", "num_classes", ",", "d", ",", "num_parties", ",", "party_data_size", ",", "candidate_data_size", ",", "split", ")", ":", "\n", "    ", "prop", "=", "get_proportions", "(", "split", ",", "dataset", ")", "\n", "\n", "if", "dataset", "==", "'creditratings'", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "2", ")", "\n", "means", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "num_classes", ",", "d", ")", ")", "\n", "covs", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "d", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "covs", "[", "i", "]", "=", "np", ".", "eye", "(", "d", ")", "/", "200", "\n", "\n", "# Party datasets", "\n", "", "num_samples", "=", "(", "party_data_size", "*", "num_parties", ")", "//", "num_classes", "\n", "data_in_classes", "=", "np", ".", "zeros", "(", "(", "num_classes", ",", "num_samples", ",", "d", ")", ")", "\n", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "data_in_classes", "[", "i", "]", "=", "np", ".", "random", ".", "multivariate_normal", "(", "means", "[", "i", "]", ",", "covs", "[", "i", "]", ",", "size", "=", "(", "num_samples", ")", ",", "check_valid", "=", "'raise'", ")", "\n", "", "party_datasets", ",", "party_labels", "=", "split_proportions", "(", "data_in_classes", ",", "prop", ")", "\n", "\n", "# Candidate datasets", "\n", "gmm_points", ",", "candidate_labels", "=", "sample_GMM", "(", "means", ",", "covs", ",", "candidate_data_size", ")", "\n", "candidate_datasets", "=", "np", ".", "array", "(", "[", "gmm_points", "]", "*", "num_parties", ")", "\n", "\n", "", "elif", "dataset", "==", "'mnist'", "or", "dataset", "==", "'cifar'", "or", "dataset", "==", "'creditcard'", ":", "\n", "        ", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "party_datasets", "=", "np", ".", "load", "(", "\"data/{}/{}-party_features.npy\"", ".", "format", "(", "dataset", ",", "split", ")", ")", "\n", "party_labels", "=", "np", ".", "load", "(", "\"data/{}/{}-party_labels.npy\"", ".", "format", "(", "dataset", ",", "split", ")", ")", "\n", "candidate_dataset", "=", "np", ".", "load", "(", "\"data/{}/{}-cand_features.npy\"", ".", "format", "(", "dataset", ",", "split", ")", ")", "\n", "candidate_labels", "=", "np", ".", "load", "(", "\"data/{}/{}-cand_labels.npy\"", ".", "format", "(", "dataset", ",", "split", ")", ")", "\n", "\n", "candidate_datasets", "=", "np", ".", "array", "(", "[", "candidate_dataset", "]", "*", "num_parties", ")", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Parameter dataset must be 'creditratings', 'creditcard', 'mnist', 'cifar'\"", ")", "\n", "\n", "# If party_data_size or candidate_data_size are lower than actual, trim data", "\n", "", "party_datasets", "=", "party_datasets", "[", ":", ",", ":", "party_data_size", ",", ":", "]", "\n", "candidate_datasets", "=", "candidate_datasets", "[", ":", ",", ":", "candidate_data_size", ",", ":", "]", "\n", "\n", "# Reference dataset", "\n", "all_parties_dataset", "=", "np", ".", "concatenate", "(", "party_datasets", ")", "\n", "reference_dataset", "=", "np", ".", "concatenate", "(", "[", "all_parties_dataset", ",", "candidate_datasets", "[", "0", "]", "]", ",", "axis", "=", "0", ")", "\n", "\n", "return", "party_datasets", ",", "party_labels", ",", "reference_dataset", ",", "candidate_datasets", ",", "candidate_labels", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.pipeline.get_data_raw": [[79, 97], ["pipeline.get_proportions", "numpy.random.seed", "numpy.load", "numpy.load", "numpy.load", "numpy.load", "core.utils.split_data_into_classes", "core.utils.split_proportions"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.data.pipeline.get_proportions", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.split_data_into_classes", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.split_proportions"], ["", "def", "get_data_raw", "(", "dataset", ",", "num_classes", ",", "party_data_size", ",", "candidate_data_size", ",", "split", ")", ":", "\n", "    ", "prop", "=", "get_proportions", "(", "split", ",", "dataset", ")", "\n", "np", ".", "random", ".", "seed", "(", "0", ")", "\n", "\n", "train_images", "=", "np", ".", "load", "(", "\"data/{}/{}_train_images.npy\"", ".", "format", "(", "dataset", ",", "dataset", ")", ")", "\n", "train_labels", "=", "np", ".", "load", "(", "\"data/{}/{}_train_labels.npy\"", ".", "format", "(", "dataset", ",", "dataset", ")", ")", "\n", "candidate_images", "=", "np", ".", "load", "(", "\"data/{}/{}_samples.npy\"", ".", "format", "(", "dataset", ",", "dataset", ")", ")", "\n", "candidate_labels", "=", "np", ".", "load", "(", "\"data/{}/{}_samples_labels.npy\"", ".", "format", "(", "dataset", ",", "dataset", ")", ")", "\n", "\n", "# Party datasets", "\n", "data_in_classes", "=", "split_data_into_classes", "(", "train_images", ",", "train_labels", ",", "num_classes", ")", "\n", "party_datasets", ",", "party_labels", "=", "split_proportions", "(", "data_in_classes", ",", "prop", ",", "party_data_size", ")", "\n", "\n", "# Candidate dataset", "\n", "candidate_dataset", "=", "candidate_images", "[", ":", "candidate_data_size", "]", "\n", "candidate_labels", "=", "candidate_labels", "[", ":", "candidate_data_size", "]", "\n", "\n", "return", "party_datasets", ",", "party_labels", ",", "candidate_dataset", ",", "candidate_labels", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.SEKernel.__init__": [[13, 18], ["torch.tensor", "range"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "ard_num_dims", ",", "inv_lengthscale_squared", ",", "device", ")", ":", "\n", "        ", "self", ".", "inv_ls_squared", "=", "torch", ".", "tensor", "(", "[", "inv_lengthscale_squared", "for", "_", "in", "range", "(", "ard_num_dims", ")", "]", ",", "device", "=", "device", ",", "\n", "requires_grad", "=", "True", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "self", ".", "ard_num_dims", "=", "ard_num_dims", "\n", "self", ".", "device", "=", "device", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.SEKernel.__call__": [[19, 31], ["torch.square", "torch.matmul", "torch.exp", "torch.unsqueeze"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "X", ",", "Y", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param X: torch tensor of size (m, d)\n        :param Y: torch tensor of size (n, d)\n        :return: lazy tensor of size (m, n)\n        \"\"\"", "\n", "if", "Y", "is", "None", ":", "\n", "            ", "Y", "=", "X", "\n", "\n", "", "diff_squared", "=", "torch", ".", "square", "(", "torch", ".", "unsqueeze", "(", "X", ",", "1", ")", "-", "Y", ")", "# tensor of shape (m, n, d)", "\n", "exponent", "=", "torch", ".", "matmul", "(", "diff_squared", ",", "self", ".", "inv_ls_squared", ")", "# tensor of shape (m, n)", "\n", "return", "torch", ".", "exp", "(", "-", "0.5", "*", "exponent", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.SEKernel.parameters": [[32, 34], ["None"], "methods", ["None"], ["", "def", "parameters", "(", "self", ")", ":", "\n", "        ", "return", "[", "self", ".", "inv_ls_squared", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.SEKernel.set_inv_ls_squared_scalar": [[35, 38], ["torch.tensor", "range"], "methods", ["None"], ["", "def", "set_inv_ls_squared_scalar", "(", "self", ",", "inv_ls", ")", ":", "\n", "        ", "self", ".", "inv_ls_squared", "=", "torch", ".", "tensor", "(", "[", "inv_ls", "for", "_", "in", "range", "(", "self", ".", "ard_num_dims", ")", "]", ",", "device", "=", "self", ".", "device", ",", "\n", "requires_grad", "=", "True", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.SEKernel.set_inv_ls_squared": [[39, 41], ["torch.tensor"], "methods", ["None"], ["", "def", "set_inv_ls_squared", "(", "self", ",", "inv_ls_squared", ")", ":", "\n", "        ", "self", ".", "inv_ls_squared", "=", "torch", ".", "tensor", "(", "inv_ls_squared", ",", "device", "=", "self", ".", "device", ",", "requires_grad", "=", "True", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.median_heuristic": [[43, 58], ["numpy.zeros", "tqdm.tqdm", "numpy.median", "numpy.random.permutation", "range", "numpy.linalg.norm", "len", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.norm"], ["", "", "def", "median_heuristic", "(", "input", ",", "num_samples", "=", "5000", ")", ":", "\n", "    ", "\"\"\"\n    :param input: array of shape (n, d)\n    \"\"\"", "\n", "idxs", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "input", ")", ")", "[", ":", "num_samples", "]", "\n", "data", "=", "input", "[", "idxs", "]", "\n", "\n", "n", ",", "d", "=", "data", ".", "shape", "\n", "norms", "=", "np", ".", "zeros", "(", "n", "*", "(", "n", "-", "1", ")", "//", "2", ")", "\n", "idx", "=", "0", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "len", "(", "data", ")", ")", ")", ":", "\n", "        ", "current_norms", "=", "np", ".", "linalg", ".", "norm", "(", "data", "[", "i", ":", "i", "+", "1", "]", "-", "data", "[", "i", "+", "1", ":", "]", ",", "axis", "=", "1", ")", "\n", "norms", "[", "idx", ":", "idx", "+", "len", "(", "current_norms", ")", "]", "=", "current_norms", "\n", "idx", "=", "idx", "+", "len", "(", "current_norms", ")", "\n", "", "return", "np", ".", "median", "(", "norms", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.nonneg_lb": [[60, 73], ["None"], "function", ["None"], ["", "def", "nonneg_lb", "(", "n", ",", "S", ",", "k", ",", "eta", "=", "None", ",", "tol", "=", "1e-04", ")", ":", "\n", "    ", "\"\"\"\n    Lower bound required for non-negativity of v(S).\n    :param n: size of reference dataset Y\n    :param S: minimum party dataset size\n    :param k: value of diagonal terms (usually 1)\n    :param eta: upper bound (if none, set to k)\n    :return: scalar\n    \"\"\"", "\n", "if", "eta", "is", "None", ":", "\n", "        ", "eta", "=", "k", "\n", "\n", "", "return", "(", "n", "-", "2", "*", "S", ")", "/", "(", "2", "*", "S", "*", "(", "n", "-", "S", ")", ")", "*", "(", "k", "+", "(", "S", "-", "1", ")", "*", "eta", ")", "-", "tol", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_above_lb": [[75, 78], ["len", "k().cpu().detach().numpy", "k().cpu().detach", "k().cpu", "k"], "function", ["None"], ["", "def", "is_all_above_lb", "(", "k", ",", "val_points", ",", "lb", ")", ":", "\n", "    ", "num_above", "=", "(", "k", "(", "val_points", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ">", "lb", ")", ".", "sum", "(", ")", "\n", "return", "num_above", "==", "len", "(", "val_points", ")", "**", "2", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_pareto_efficient": [[80, 108], ["numpy.arange", "tqdm.tqdm", "numpy.zeros", "len", "numpy.any", "pbar.set_postfix", "pbar.update", "len", "numpy.sum", "len"], "function", ["None"], ["", "def", "is_pareto_efficient", "(", "costs", ",", "return_mask", "=", "True", ")", ":", "\n", "    ", "\"\"\"\n    Find pareto-efficient points. Defined in terms of costs, so returns lowest values. From accepted answer in\n    https://stackoverflow.com/questions/32791911/fast-calculation-of-pareto-front-in-python\n    :param costs: An (n_points, n_costs) array\n    :param return_mask: True to return a mask\n    :return: An array of indices of pareto-efficient points.\n        If return_mask is True, this will be an (n_points, ) boolean array\n        Otherwise it will be a (n_efficient_points, ) integer array of indices.\n    \"\"\"", "\n", "is_efficient", "=", "np", ".", "arange", "(", "costs", ".", "shape", "[", "0", "]", ")", "\n", "n_points", "=", "costs", ".", "shape", "[", "0", "]", "\n", "next_point_index", "=", "0", "# Next index in the is_efficient array to search for", "\n", "with", "tqdm", "(", "total", "=", "len", "(", "costs", ")", ")", "as", "pbar", ":", "\n", "        ", "while", "next_point_index", "<", "len", "(", "costs", ")", ":", "\n", "            ", "nondominated_point_mask", "=", "np", ".", "any", "(", "costs", "<", "costs", "[", "next_point_index", "]", ",", "axis", "=", "1", ")", "\n", "nondominated_point_mask", "[", "next_point_index", "]", "=", "True", "\n", "is_efficient", "=", "is_efficient", "[", "nondominated_point_mask", "]", "# Remove dominated points", "\n", "costs", "=", "costs", "[", "nondominated_point_mask", "]", "\n", "next_point_index", "=", "np", ".", "sum", "(", "nondominated_point_mask", "[", ":", "next_point_index", "]", ")", "+", "1", "\n", "pbar", ".", "set_postfix", "(", "num_is_efficient", "=", "len", "(", "is_efficient", ")", ")", "\n", "pbar", ".", "update", "(", "1", ")", "\n", "", "", "if", "return_mask", ":", "\n", "        ", "is_efficient_mask", "=", "np", ".", "zeros", "(", "n_points", ",", "dtype", "=", "bool", ")", "\n", "is_efficient_mask", "[", "is_efficient", "]", "=", "True", "\n", "return", "is_efficient_mask", "\n", "", "else", ":", "\n", "        ", "return", "is_efficient", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.get_kernel": [[110, 140], ["gpytorch.kernels.RBFKernel", "gpytorch.kernels.RBFKernel.to", "gpytorch.kernels.ScaleKernel", "gpytorch.kernels.ScaleKernel", "gpytorch.kernels.ScaleKernel", "gpytorch.kernels.RBFKernel.kernels.append", "range", "gpytorch.kernels.RBFKernel", "gpytorch.kernels.RBFKernel", "gpytorch.kernels.RBFKernel", "gpytorch.kernels.RQKernel", "gpytorch.kernels.RQKernel", "gpytorch.kernels.RQKernel", "gpytorch.kernels.RBFKernel.kernels.append", "Exception", "range", "range", "range"], "function", ["None"], ["", "", "def", "get_kernel", "(", "kernel_name", ",", "d", ",", "lengthscale", ",", "device", ")", ":", "\n", "    ", "if", "kernel_name", "==", "'se'", ":", "\n", "        ", "kernel", "=", "gpytorch", ".", "kernels", ".", "RBFKernel", "(", "ard_num_dims", "=", "d", ")", "\n", "kernel", ".", "lengthscale", "=", "[", "lengthscale", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "kernel", ".", "to", "(", "device", ")", "\n", "", "elif", "kernel_name", "==", "'se_sum'", ":", "\n", "        ", "kernel01", "=", "gpytorch", ".", "kernels", ".", "ScaleKernel", "(", "gpytorch", ".", "kernels", ".", "RBFKernel", "(", "ard_num_dims", "=", "d", ")", ")", "\n", "kernel01", ".", "base_kernel", ".", "lengthscale", "=", "[", "0.1", "*", "lengthscale", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "kernel01", ".", "outputscale", "=", "1", "\n", "kernel1", "=", "gpytorch", ".", "kernels", ".", "ScaleKernel", "(", "gpytorch", ".", "kernels", ".", "RBFKernel", "(", "ard_num_dims", "=", "d", ")", ")", "\n", "kernel1", ".", "base_kernel", ".", "lengthscale", "=", "[", "1", "*", "lengthscale", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "kernel1", ".", "outputscale", "=", "1", "\n", "kernel10", "=", "gpytorch", ".", "kernels", ".", "ScaleKernel", "(", "gpytorch", ".", "kernels", ".", "RBFKernel", "(", "ard_num_dims", "=", "d", ")", ")", "\n", "kernel10", ".", "base_kernel", ".", "lengthscale", "=", "[", "10", "*", "lengthscale", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "kernel10", ".", "outputscale", "=", "1", "\n", "kernel", "=", "kernel01", "+", "kernel1", "\n", "kernel", ".", "kernels", ".", "append", "(", "kernel10", ")", "\n", "", "elif", "kernel_name", "==", "'rq'", ":", "\n", "        ", "rq01", "=", "gpytorch", ".", "kernels", ".", "RQKernel", "(", ")", "\n", "rq01", ".", "alpha", "=", "0.1", "\n", "rq1", "=", "gpytorch", ".", "kernels", ".", "RQKernel", "(", ")", "\n", "rq1", ".", "alpha", "=", "1.", "\n", "rq10", "=", "gpytorch", ".", "kernels", ".", "RQKernel", "(", ")", "\n", "rq10", ".", "alpha", "=", "10.", "\n", "kernel", "=", "rq01", "+", "rq1", "\n", "kernel", ".", "kernels", ".", "append", "(", "rq10", ")", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"Kernel name must be 'se' or 'se_sum' or 'rq'\"", ")", "\n", "\n", "", "return", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive": [[142, 146], ["core.reward_calculation.get_v", "core.reward_calculation.get_v_is", "numpy.all", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v_is"], ["", "def", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "    ", "v", "=", "get_v", "(", "party_datasets", ",", "reference_dataset", ",", "k", ",", "device", "=", "device", ",", "batch_size", "=", "batch_size", ")", "\n", "v_is", "=", "get_v_is", "(", "v", ",", "len", "(", "party_datasets", ")", ")", "\n", "return", "np", ".", "all", "(", "np", ".", "array", "(", "v_is", ")", ">=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.optimize_kernel_binsearch_only": [[148, 179], ["kernel.is_all_lb_positive", "tqdm.tqdm", "print", "kernel.is_all_lb_positive", "Exception", "Exception", "range", "kernel.is_all_lb_positive", "range", "range", "range", "range"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive"], ["", "def", "optimize_kernel_binsearch_only", "(", "k", ",", "device", ",", "party_datasets", ",", "reference_dataset", ",", "low", "=", "0.01", ",", "high", "=", "1000", ",", "num_iters", "=", "20", ",", "batch_size", "=", "256", ")", ":", "\n", "    ", "\"\"\"\n    Does a binary search over lengthscales for minimum value that gives non-negative party dataset values\n    :param k:\n    :param device:\n    :param party_datasets:\n    :param reference_dataset:\n    :return:\n    \"\"\"", "\n", "d", "=", "reference_dataset", ".", "shape", "[", "-", "1", "]", "\n", "\n", "k", ".", "lengthscale", "=", "[", "high", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "if", "not", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"High value of lengthscale is already invalid\"", ")", "\n", "\n", "", "k", ".", "lengthscale", "=", "[", "low", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "if", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"Low value of lengthscale is still valid, can be pushed lower\"", ")", "\n", "\n", "", "for", "_", "in", "tqdm", "(", "range", "(", "num_iters", ")", ")", ":", "\n", "        ", "mid", "=", "(", "high", "+", "low", ")", "/", "2", "\n", "k", ".", "lengthscale", "=", "[", "mid", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "if", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "            ", "high", "=", "mid", "\n", "", "else", ":", "\n", "            ", "low", "=", "mid", "\n", "\n", "", "", "k", ".", "lengthscale", "=", "[", "high", "for", "_", "in", "range", "(", "d", ")", "]", "\n", "print", "(", "\"Optimal lengthscale: {}\"", ".", "format", "(", "high", ")", ")", "\n", "\n", "return", "k", ",", "high", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.binary_search_ls": [[181, 207], ["gpytorch.kernels.RBFKernel", "gpytorch.kernels.RBFKernel.to", "tqdm.tqdm", "kernel.is_all_lb_positive", "Exception", "range", "kernel.is_all_lb_positive"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive"], ["", "def", "binary_search_ls", "(", "lengthscales", ",", "device", ",", "party_datasets", ",", "reference_dataset", ",", "high", "=", "100", ",", "low", "=", "1", ",", "num_iters", "=", "10", ",", "batch_size", "=", "128", ")", ":", "\n", "    ", "\"\"\"\n    Searches for minimum factor to multiply lengthscales by in order to be valid\n    :param lengthscale: d length numpy array of lengthscales\n    :param device:\n    :param party_datasets:\n    :param reference_dataset:\n    :return:\n    \"\"\"", "\n", "d", "=", "reference_dataset", ".", "shape", "[", "-", "1", "]", "\n", "k", "=", "gpytorch", ".", "kernels", ".", "RBFKernel", "(", "ard_num_dims", "=", "d", ")", "\n", "k", ".", "to", "(", "device", ")", "\n", "\n", "k", ".", "lengthscale", "=", "lengthscales", "*", "high", "\n", "if", "not", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "        ", "raise", "Exception", "(", "\"High value of lengthscale is already invalid\"", ")", "\n", "\n", "", "for", "_", "in", "tqdm", "(", "range", "(", "num_iters", ")", ")", ":", "\n", "        ", "mid", "=", "(", "high", "+", "low", ")", "/", "2", "\n", "k", ".", "lengthscale", "=", "lengthscales", "*", "mid", "\n", "if", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "            ", "high", "=", "mid", "\n", "", "else", ":", "\n", "            ", "low", "=", "mid", "\n", "\n", "", "", "return", "lengthscales", "*", "high", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.optimize_kernel": [[209, 285], ["numpy.min", "int", "len", "torch.tensor", "torch.tensor", "torch.tensor", "torch.optim.Adam", "range", "k.parameters", "print", "print", "range", "numpy.mean", "print", "averages.append", "print", "print", "range", "len", "core.mmd.mmd_neg_unbiased_batched().cpu().detach().numpy", "print", "stats.append", "torch.optim.Adam.zero_grad", "numpy.min", "numpy.random.randint", "range", "loss.backward", "torch.optim.Adam.step", "kernel.is_all_lb_positive", "print", "kernel.binary_search_ls", "print", "print", "print", "core.mmd.mmd_neg_unbiased", "k.lengthscale.cpu().detach().numpy", "core.mmd.mmd_neg_unbiased_batched().cpu().detach", "len", "k.lengthscale.cpu().detach", "core.mmd.mmd_neg_unbiased_batched().cpu", "k.lengthscale.cpu", "core.mmd.mmd_neg_unbiased_batched"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.SEKernel.parameters", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.is_all_lb_positive", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.kernel.binary_search_ls", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_unbiased", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_unbiased_batched"], ["", "def", "optimize_kernel", "(", "k", ",", "device", ",", "party_datasets", ",", "reference_dataset", ",", "num_epochs", "=", "30", ",", "batch_size", "=", "128", ",", "patience", "=", "8", ")", ":", "\n", "    ", "\"\"\"\n\n    :param k:\n    :param device:\n    :param party_datasets:\n    :param reference_dataset:\n    :return:\n    \"\"\"", "\n", "# Data setup", "\n", "S", "=", "np", ".", "min", "(", "[", "len", "(", "ds", ")", "for", "ds", "in", "party_datasets", "]", ")", "\n", "train_test_split_idx", "=", "int", "(", "0.6", "*", "S", ")", "\n", "party_ds_size", "=", "train_test_split_idx", "\n", "num_parties", "=", "len", "(", "party_datasets", ")", "\n", "\n", "party_datasets_tens", "=", "torch", ".", "tensor", "(", "party_datasets", "[", ":", ",", ":", "train_test_split_idx", "]", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "reference_dataset_tens", "=", "torch", ".", "tensor", "(", "reference_dataset", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "party_datasets_test", "=", "torch", ".", "tensor", "(", "party_datasets", "[", ":", ",", "train_test_split_idx", ":", "]", ",", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "k", ".", "parameters", "(", ")", ",", "lr", "=", "0.1", ")", "\n", "averages", "=", "[", "]", "\n", "best_idx", "=", "0", "\n", "\n", "for", "epoch", "in", "range", "(", "num_epochs", ")", ":", "\n", "        ", "print", "(", "\"Epoch {}\"", ".", "format", "(", "epoch", ")", ")", "\n", "print", "(", "\"========= Test -MMD unbiased ===========\"", ")", "\n", "stats", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "            ", "stat", "=", "mmd_neg_unbiased_batched", "(", "party_datasets_test", "[", "i", "]", ",", "reference_dataset_tens", ",", "k", ")", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "print", "(", "\"Party {}: {}\"", ".", "format", "(", "i", "+", "1", ",", "stat", ")", ")", "\n", "stats", ".", "append", "(", "stat", ")", "\n", "", "avg", "=", "np", ".", "mean", "(", "stats", ")", "\n", "print", "(", "\"Average: {}\"", ".", "format", "(", "avg", ")", ")", "\n", "\n", "# Code for early termination if no improvement after patience number of epochs", "\n", "averages", ".", "append", "(", "avg", ")", "\n", "if", "avg", "<=", "averages", "[", "best_idx", "]", ":", "\n", "            ", "best_idx", "=", "epoch", "# Low is better for this", "\n", "", "elif", "avg", ">", "averages", "[", "best_idx", "]", "and", "epoch", "-", "best_idx", ">=", "patience", ":", "\n", "            ", "print", "(", "\"No improvement for {} epochs, terminating early\"", ".", "format", "(", "patience", ")", ")", "\n", "break", "\n", "\n", "", "print", "(", "\"========= Kernel parameters ===========\"", ")", "\n", "print", "(", "\"lengthscale: {}\"", ".", "format", "(", "k", ".", "lengthscale", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "party_ds_size", "//", "batch_size", ")", ":", "\n", "# Zero gradients from previous iteration", "\n", "            ", "optimizer", ".", "zero_grad", "(", ")", "\n", "loss", "=", "0", "\n", "\n", "idx", "=", "(", "i", "+", "1", ")", "\n", "next_m", "=", "np", ".", "min", "(", "[", "idx", "*", "batch_size", ",", "party_ds_size", "]", ")", "\n", "m", "=", "i", "*", "batch_size", "\n", "\n", "ref_idx", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "len", "(", "reference_dataset", ")", "-", "batch_size", ")", "\n", "next_ref_idx", "=", "ref_idx", "+", "batch_size", "\n", "\n", "for", "party", "in", "range", "(", "num_parties", ")", ":", "\n", "                ", "loss", "+=", "mmd_neg_unbiased", "(", "party_datasets_tens", "[", "party", "]", "[", "m", ":", "next_m", "]", ",", "\n", "reference_dataset_tens", "[", "ref_idx", ":", "next_ref_idx", "]", ",", "\n", "k", ")", "\n", "\n", "# Calc loss and backprop gradients", "\n", "", "loss", ".", "backward", "(", ")", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "", "if", "not", "is_all_lb_positive", "(", "k", ",", "party_datasets", ",", "reference_dataset", ",", "device", ",", "batch_size", ")", ":", "\n", "# \"Project\" lengthscale back to valid range", "\n", "            ", "print", "(", "\"Projecting lengthscales back to valid range\"", ")", "\n", "valid_lengthscales", "=", "binary_search_ls", "(", "k", ".", "lengthscale", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ",", "device", ",", "party_datasets", ",", "reference_dataset", ")", "\n", "print", "(", "\"Found valid lengthscales: {}\"", ".", "format", "(", "valid_lengthscales", ")", ")", "\n", "k", ".", "lengthscale", "=", "valid_lengthscales", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"All lower bounds still positive\"", ")", "\n", "\n", "", "", "return", "k", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.v_update_batch": [[10, 41], ["torch.tensor", "torch.tensor", "torch.tensor", "S_X_update.detach().numpy", "S_XY_update.detach().numpy", "torch.diag", "torch.sum", "S_X_update.detach", "S_XY_update.detach", "torch.sum", "k().evaluate", "k().evaluate", "k().evaluate", "k", "k", "k"], "function", ["None"], ["def", "v_update_batch", "(", "x", ",", "X", ",", "Y", ",", "S_X", ",", "S_XY", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Calculates v when we add a batch of points to a set with an already calculated v. Updating one point like this takes\n    linear time instead of quadratic time by naively redoing the entire calculation.\n    :param x: vector of shape (z, d)\n    :param X: array of shape (n, d)\n    :param Y: array of shape (m, d)\n    :param S_X: Pairwise-XX summation term (NOT including minus sign), float\n    :param S_XY: Pairwise-XY summation term, float\n    :param k: GPyTorch kernel\n    :return: MMD^2, A, B, all arrays of size (z)\n    \"\"\"", "\n", "x_tens", "=", "torch", ".", "tensor", "(", "x", ")", "\n", "X_tens", "=", "torch", ".", "tensor", "(", "X", ")", "\n", "Y_tens", "=", "torch", ".", "tensor", "(", "Y", ")", "\n", "\n", "m", "=", "X", ".", "shape", "[", "0", "]", "\n", "n", "=", "Y", ".", "shape", "[", "0", "]", "\n", "\n", "S_X_update", "=", "(", "(", "m", "**", "2", ")", "/", "(", "(", "m", "+", "1", ")", "**", "2", ")", ")", "*", "S_X", "+", "(", "2", "/", "(", "(", "m", "+", "1", ")", "**", "2", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "x_tens", ",", "X_tens", ")", ".", "evaluate", "(", ")", ",", "axis", "=", "1", ")", "+", "(", "1", "/", "(", "(", "m", "+", "1", ")", "**", "2", ")", ")", "*", "torch", ".", "diag", "(", "k", "(", "x_tens", ")", ".", "evaluate", "(", ")", ")", "\n", "\n", "S_XY_update", "=", "(", "m", "/", "(", "m", "+", "1", ")", ")", "*", "S_XY", "+", "(", "2", "/", "(", "n", "*", "(", "m", "+", "1", ")", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "x_tens", ",", "Y_tens", ")", ".", "evaluate", "(", ")", ",", "axis", "=", "1", ")", "\n", "\n", "S_X_arr", "=", "S_X_update", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "S_XY_arr", "=", "S_XY_update", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "current_v", "=", "S_XY_arr", "-", "S_X_arr", "\n", "\n", "return", "current_v", ",", "S_X_arr", ",", "S_XY_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.v_update_batch_iter": [[43, 82], ["torch.no_grad", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.zeros", "numpy.zeros", "range", "int", "S_X_update.cpu().detach().numpy", "S_XY_update.cpu().detach().numpy", "numpy.ceil", "torch.diag", "torch.sum", "S_X_update.cpu().detach", "S_XY_update.cpu().detach", "torch.sum", "k().evaluate", "k().evaluate", "k().evaluate", "S_X_update.cpu", "S_XY_update.cpu", "k", "k", "k"], "function", ["None"], ["", "def", "v_update_batch_iter", "(", "x", ",", "X", ",", "Y", ",", "S_X", ",", "S_XY", ",", "k", ",", "device", ",", "batch_size", "=", "2048", ")", ":", "\n", "    ", "\"\"\"\n    Calculates v when we add a batch of points to a set with an already calculated v. Updating one point like this takes\n    linear time instead of quadratic time by naively redoing the entire calculation.\n    :param x: vector of shape (z, d)\n    :param X: array of shape (n, d)\n    :param Y: array of shape (m, d)\n    :param S_X: Pairwise-XX summation term (NOT including minus sign), float\n    :param S_XY: Pairwise-XY summation term, float\n    :param k: GPyTorch kernel\n    :return: MMD^2, A, B, all arrays of size (z)\n    \"\"\"", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "x_tens", "=", "torch", ".", "tensor", "(", "x", ",", "device", "=", "device", ")", "\n", "X_tens", "=", "torch", ".", "tensor", "(", "X", ",", "device", "=", "device", ")", "\n", "Y_tens", "=", "torch", ".", "tensor", "(", "Y", ",", "device", "=", "device", ")", "\n", "\n", "z", "=", "x", ".", "shape", "[", "0", "]", "\n", "m", "=", "X", ".", "shape", "[", "0", "]", "\n", "n", "=", "Y", ".", "shape", "[", "0", "]", "\n", "\n", "S_X_arr", "=", "np", ".", "zeros", "(", "z", ")", "\n", "S_XY_arr", "=", "np", ".", "zeros", "(", "z", ")", "\n", "\n", "for", "i", "in", "range", "(", "int", "(", "np", ".", "ceil", "(", "z", "/", "batch_size", ")", ")", ")", ":", "\n", "            ", "start", "=", "i", "*", "batch_size", "\n", "end", "=", "(", "i", "+", "1", ")", "*", "batch_size", "\n", "\n", "S_X_update", "=", "(", "(", "m", "**", "2", ")", "/", "(", "(", "m", "+", "1", ")", "**", "2", ")", ")", "*", "S_X", "+", "(", "2", "/", "(", "(", "m", "+", "1", ")", "**", "2", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "x_tens", "[", "start", ":", "end", "]", ",", "X_tens", ")", ".", "evaluate", "(", ")", ",", "axis", "=", "1", ")", "+", "(", "1", "/", "(", "(", "m", "+", "1", ")", "**", "2", ")", ")", "*", "torch", ".", "diag", "(", "k", "(", "x_tens", "[", "start", ":", "end", "]", ")", ".", "evaluate", "(", ")", ")", "\n", "\n", "S_XY_update", "=", "(", "m", "/", "(", "m", "+", "1", ")", ")", "*", "S_XY", "+", "(", "2", "/", "(", "n", "*", "(", "m", "+", "1", ")", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "x_tens", "[", "start", ":", "end", "]", ",", "Y_tens", ")", ".", "evaluate", "(", ")", ",", "axis", "=", "1", ")", "\n", "\n", "S_X_arr", "[", "start", ":", "end", "]", "=", "S_X_update", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "S_XY_arr", "[", "start", ":", "end", "]", "=", "S_XY_update", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "current_v", "=", "S_XY_arr", "-", "S_X_arr", "\n", "\n", "", "return", "current_v", ",", "S_X_arr", ",", "S_XY_arr", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.weighted_sampling": [[84, 138], ["print", "core.mmd.mmd_neg_biased_batched", "mus.append", "candidates.copy", "tqdm.tqdm", "range", "core.utils.union", "reward_realization.v_update_batch_iter", "numpy.amax", "numpy.amin", "scipy.special.softmax", "numpy.random.choice", "deltas.append", "mus.append", "R.append", "numpy.delete", "len", "len", "numpy.squeeze().copy", "print", "numpy.squeeze", "len"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_biased_batched", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.union", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.v_update_batch_iter"], ["", "def", "weighted_sampling", "(", "candidates", ",", "D", ",", "mu_target", ",", "Y", ",", "kernel", ",", "inv_temp", ",", "device", "=", "'cpu'", ",", "batch_size", "=", "2048", ")", ":", "\n", "    ", "print", "(", "\"Running weighted sampling algorithm with -MMD^2 target {}\"", ".", "format", "(", "mu_target", ")", ")", "\n", "m", "=", "candidates", ".", "shape", "[", "0", "]", "\n", "R", "=", "[", "]", "\n", "deltas", "=", "[", "]", "\n", "mus", "=", "[", "]", "\n", "\n", "mu", ",", "S_X", ",", "S_XY", "=", "mmd_neg_biased_batched", "(", "D", ",", "Y", ",", "kernel", ",", "device", ")", "\n", "mus", ".", "append", "(", "mu", ")", "\n", "G", "=", "candidates", ".", "copy", "(", ")", "\n", "\n", "mu_max", "=", "mu", "\n", "time_since_mu_max_update", "=", "0", "\n", "\n", "for", "_", "in", "tqdm", "(", "range", "(", "m", ")", ")", ":", "\n", "        ", "if", "len", "(", "G", ")", "==", "1", ":", "\n", "            ", "break", "\n", "\n", "", "DuR", "=", "union", "(", "D", ",", "R", ")", "\n", "neg_mmds_new", ",", "S_Xs_temp", ",", "S_XYs_temp", "=", "v_update_batch_iter", "(", "G", ",", "DuR", ",", "Y", ",", "S_X", ",", "S_XY", ",", "kernel", ",", "device", ",", "batch_size", ")", "\n", "deltas_temp", "=", "neg_mmds_new", "-", "mu", "\n", "weights", "=", "deltas_temp", "\n", "\n", "weight_max", "=", "np", ".", "amax", "(", "weights", ")", "\n", "weight_min", "=", "np", ".", "amin", "(", "weights", ")", "\n", "weights", "=", "(", "weights", "-", "weight_min", ")", "/", "(", "weight_max", "-", "weight_min", ")", "# Scale weights to [0, 1] because", "\n", "# inv_temp factor may not affect sampling for very small/large weight values", "\n", "probs", "=", "softmax", "(", "inv_temp", "*", "weights", ")", "\n", "idx", "=", "np", ".", "random", ".", "choice", "(", "len", "(", "G", ")", ",", "p", "=", "probs", ")", "\n", "\n", "x", "=", "G", "[", "idx", ":", "idx", "+", "1", "]", "\n", "delta", "=", "deltas_temp", "[", "idx", "]", "\n", "mu", "+=", "delta", "\n", "deltas", ".", "append", "(", "delta", ")", "\n", "mus", ".", "append", "(", "mu", ")", "\n", "S_X", "=", "S_Xs_temp", "[", "idx", "]", "\n", "S_XY", "=", "S_XYs_temp", "[", "idx", "]", "\n", "\n", "R", ".", "append", "(", "np", ".", "squeeze", "(", "x", ")", ".", "copy", "(", ")", ")", "\n", "G", "=", "np", ".", "delete", "(", "G", ",", "idx", ",", "axis", "=", "0", ")", "\n", "\n", "if", "mu", ">", "mu_max", ":", "\n", "            ", "mu_max", "=", "mu", "\n", "time_since_mu_max_update", "=", "0", "\n", "", "else", ":", "\n", "            ", "time_since_mu_max_update", "+=", "1", "\n", "if", "time_since_mu_max_update", ">=", "0.1", "*", "len", "(", "candidates", ")", ":", "\n", "                ", "print", "(", "\"Early stopping, no increment for a long time\"", ")", "\n", "break", "\n", "\n", "", "", "if", "mu", ">=", "mu_target", ":", "# Exit condition", "\n", "            ", "break", "\n", "\n", "", "", "return", "R", ",", "deltas", ",", "mus", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.reward_realization": [[140, 177], ["range", "print", "reward_realization.weighted_sampling", "rewards.append", "deltas.append", "mus.append", "print", "len"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_realization.weighted_sampling"], ["", "def", "reward_realization", "(", "candidates", ",", "Y", ",", "r", ",", "D", ",", "kernel", ",", "inv_temps", "=", "None", ",", "device", "=", "'cpu'", ",", "batch_size", "=", "2048", ")", ":", "\n", "    ", "\"\"\"\n    Reward realization algorithm. Defaults to pure greedy algorithm\n    :param candidates: Candidate points from generator distribution, one for each party. array of shape (k, m, d)\n    :param Y: Reference points to measure MMD against. array of shape (l, d)\n    :param r: reward vector. array of shape (k)\n    :param D: Parties data. array of shape (k, n, d)\n    :param kernel: kernel to measure MMD\n    :param inv_temps: list of floats in range [0, inf) of size (k). 0 corresponds to pure random sampling, inf\n    corresponds to pure greedy. Leave as None to set all to pure greedy. Set individual values to -1 for pure greedy\n    for specific parties\n    :param device:\n    :param batch_size:\n    \"\"\"", "\n", "k", "=", "D", ".", "shape", "[", "0", "]", "\n", "if", "inv_temps", "is", "None", ":", "\n", "        ", "inv_temps", "=", "[", "1", "]", "*", "k", "\n", "\n", "", "rewards", "=", "[", "]", "\n", "deltas", "=", "[", "]", "\n", "mus", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "print", "(", "\"Running weighted sampling for party {}\"", ".", "format", "(", "i", "+", "1", ")", ")", "\n", "reward", ",", "delta", ",", "mu", "=", "weighted_sampling", "(", "candidates", "=", "candidates", "[", "i", "]", ",", "\n", "D", "=", "D", "[", "i", "]", ",", "\n", "mu_target", "=", "r", "[", "i", "]", ",", "\n", "Y", "=", "Y", ",", "\n", "kernel", "=", "kernel", ",", "\n", "inv_temp", "=", "inv_temps", "[", "i", "]", ",", "\n", "device", "=", "device", ",", "\n", "batch_size", "=", "batch_size", ")", "\n", "rewards", ".", "append", "(", "reward", ")", "\n", "deltas", ".", "append", "(", "delta", ")", "\n", "mus", ".", "append", "(", "mu", ")", "\n", "print", "(", "\"Finished weight sampling for party {} with reward size {}\"", ".", "format", "(", "i", "+", "1", ",", "len", "(", "reward", ")", ")", ")", "\n", "\n", "", "return", "rewards", ",", "deltas", ",", "mus", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v": [[10, 32], ["list", "dict", "range", "range", "itertools.combinations", "numpy.concatenate", "core.mmd.mmd_neg_biased_batched", "repr", "set"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_biased_batched"], ["def", "get_v", "(", "parties_datasets", ",", "reference_dataset", ",", "kernel", ",", "device", ",", "batch_size", "=", "32", ")", ":", "\n", "    ", "\"\"\"\n    Returns a dictionary with keys as repr(set(C)), e.g. v[repr(set((4,)))] = 10, v[repr(set((1,2)))] = 18 etc.,\n    for all coalitions\n    :param parties_datasets: array of shape (num_parties, n, d)\n    :param reference_dataset: array of shape (m, d)\n    :param kernel: GPyTorch kernel\n    \"\"\"", "\n", "num_parties", "=", "parties_datasets", ".", "shape", "[", "0", "]", "\n", "party_list", "=", "list", "(", "range", "(", "1", ",", "num_parties", "+", "1", ")", ")", "\n", "v", "=", "dict", "(", ")", "\n", "\n", "for", "coalition_size", "in", "range", "(", "1", ",", "num_parties", "+", "1", ")", ":", "\n", "        ", "for", "coalition", "in", "itertools", ".", "combinations", "(", "party_list", ",", "coalition_size", ")", ":", "\n", "            ", "coalition_dataset", "=", "np", ".", "concatenate", "(", "[", "parties_datasets", "[", "i", "-", "1", "]", "for", "i", "in", "coalition", "]", ",", "axis", "=", "0", ")", "\n", "v", "[", "repr", "(", "set", "(", "coalition", ")", ")", "]", "=", "mmd_neg_biased_batched", "(", "coalition_dataset", ",", "\n", "reference_dataset", ",", "\n", "kernel", ",", "\n", "device", "=", "device", ",", "\n", "batch_size", "=", "batch_size", ")", "[", "0", "]", "\n", "\n", "", "", "return", "v", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.shapley": [[34, 49], ["itertools.permutations", "list", "list", "set", "map", "range", "range", "set.add", "repr", "repr", "math.factorial"], "function", ["None"], ["", "def", "shapley", "(", "v", ",", "num_parties", ")", ":", "\n", "    ", "\"\"\"\n    :param v: Dictionary with keys as repr(set(C)), e.g. v[repr(set((4,)))] = 10, v[repr(set((1,2)))] = 18 etc.,\n    for all permutations\n    \"\"\"", "\n", "sums", "=", "[", "0", "for", "i", "in", "range", "(", "num_parties", ")", "]", "\n", "for", "perm", "in", "itertools", ".", "permutations", "(", "list", "(", "range", "(", "1", ",", "num_parties", "+", "1", ")", ")", ")", ":", "\n", "        ", "current_val", "=", "0", "\n", "coalition", "=", "set", "(", ")", "\n", "for", "party", "in", "perm", ":", "\n", "            ", "coalition", ".", "add", "(", "party", ")", "\n", "marginal", "=", "v", "[", "repr", "(", "coalition", ")", "]", "-", "current_val", "\n", "sums", "[", "party", "-", "1", "]", "+=", "marginal", "\n", "current_val", "=", "v", "[", "repr", "(", "coalition", ")", "]", "\n", "", "", "return", "list", "(", "map", "(", "lambda", "x", ":", "(", "1", "/", "math", ".", "factorial", "(", "num_parties", ")", ")", "*", "x", ",", "sums", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_alpha_min": [[51, 56], ["min", "min", "sorted"], "function", ["None"], ["", "def", "get_alpha_min", "(", "alpha", ")", ":", "\n", "    ", "if", "min", "(", "alpha", ")", "==", "0", ":", "\n", "        ", "return", "sorted", "(", "alpha", ")", "[", "1", "]", "\n", "", "else", ":", "\n", "        ", "return", "min", "(", "alpha", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_vN": [[58, 60], ["repr", "set", "range"], "function", ["None"], ["", "", "def", "get_vN", "(", "v", ",", "num_parties", ")", ":", "\n", "    ", "return", "v", "[", "repr", "(", "set", "(", "range", "(", "1", ",", "num_parties", "+", "1", ")", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v_is": [[62, 64], ["range", "repr", "set"], "function", ["None"], ["", "def", "get_v_is", "(", "v", ",", "num_parties", ")", ":", "\n", "    ", "return", "[", "v", "[", "repr", "(", "set", "(", "[", "i", "]", ")", ")", "]", "for", "i", "in", "range", "(", "1", ",", "num_parties", "+", "1", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_vCi": [[66, 72], ["range", "len", "lower_phi.append", "repr", "set"], "function", ["None"], ["", "def", "get_vCi", "(", "i", ",", "phi", ",", "v", ")", ":", "\n", "    ", "lower_phi", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "len", "(", "phi", ")", ")", ":", "\n", "        ", "if", "phi", "[", "j", "]", "<=", "phi", "[", "i", "-", "1", "]", ":", "\n", "            ", "lower_phi", ".", "append", "(", "j", "+", "1", ")", "\n", "", "", "return", "v", "[", "repr", "(", "set", "(", "lower_phi", ")", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.perm_sampling_neg_biased": [[74, 95], ["int", "range", "sorted", "numpy.random.permutation", "mmds.append", "len", "core.mmd.mmd_neg_biased_batched"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_biased_batched"], ["", "def", "perm_sampling_neg_biased", "(", "P", ",", "Q", ",", "k", ",", "num_perms", "=", "200", ",", "eta", "=", "1.0", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "\"\"\"\n    Shuffles two datasets together, splits this mix in 2, then calculates MMD to simulate P=Q. Does this num_perms\n    number of times.\n    :param P: First dataset, array of shape (n, d)\n    :param Q: Second dataset, array of shape (m, d)\n    :param k: GPyTorch kernel\n    :param num_perms: Number of permutations done to get range of MMD values.\n    :param eta: Fraction of samples taken in each shuffle. The larger this parameter, the smaller the variance in the estimate. Defaults\n    to 0.5*(n+m)\n    :return: Sorted list of MMD values.\n    \"\"\"", "\n", "mmds", "=", "[", "]", "\n", "num_samples", "=", "int", "(", "eta", "*", "P", ".", "shape", "[", "0", "]", ")", "\n", "\n", "for", "_", "in", "range", "(", "num_perms", ")", ":", "\n", "        ", "p", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "P", ")", ")", "\n", "X", "=", "P", "[", "p", "[", ":", "num_samples", "]", "]", "\n", "Y", "=", "Q", "\n", "mmds", ".", "append", "(", "mmd_neg_biased_batched", "(", "X", ",", "Y", ",", "k", ",", "device", ")", "[", "0", "]", ")", "\n", "", "return", "sorted", "(", "mmds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_q": [[97, 132], ["scipy.stats.skewnorm.fit", "scipy.stats.skewnorm", "scipy.stats.skewnorm.cdf", "scipy.stats.skewnorm.cdf", "truncated_sorted_vX.append", "scipy.stats.skewnorm.ppf", "math.ceil", "len"], "function", ["None"], ["", "def", "get_q", "(", "sorted_vX", ",", "vN", ",", "dist", "=", "\"skewnormal\"", ")", ":", "\n", "    ", "\"\"\"\n    :param sorted_vX: list of sorted v(X)\n    :param vN: upper bound to truncate sorted_vX\n    \"\"\"", "\n", "\n", "if", "dist", "==", "\"discrete\"", ":", "\n", "        ", "truncated_sorted_vX", "=", "[", "]", "\n", "for", "val", "in", "sorted_vX", ":", "\n", "            ", "if", "val", "<=", "vN", ":", "\n", "                ", "truncated_sorted_vX", ".", "append", "(", "val", ")", "\n", "\n", "", "", "def", "q", "(", "alpha", ")", ":", "\n", "            ", "if", "alpha", "==", "1", ":", "\n", "                ", "return", "vN", "\n", "", "else", ":", "\n", "                ", "return", "truncated_sorted_vX", "[", "math", ".", "ceil", "(", "alpha", "*", "(", "len", "(", "truncated_sorted_vX", ")", "-", "1", ")", ")", "]", "\n", "\n", "", "", "return", "q", "\n", "\n", "", "elif", "dist", "==", "\"skewnormal\"", ":", "\n", "        ", "params", "=", "scipy", ".", "stats", ".", "skewnorm", ".", "fit", "(", "sorted_vX", ")", "\n", "skewnormal_dist", "=", "scipy", ".", "stats", ".", "skewnorm", "(", "*", "params", ")", "\n", "p_min", "=", "skewnormal_dist", ".", "cdf", "(", "0", ")", "\n", "if", "p_min", "<", "1e-10", ":", "\n", "            ", "p_min", "=", "1e-10", "\n", "", "p_max", "=", "skewnormal_dist", ".", "cdf", "(", "vN", ")", "\n", "\n", "def", "q", "(", "alpha", ")", ":", "\n", "            ", "if", "alpha", "==", "0", ":", "\n", "                ", "return", "0", "\n", "", "else", ":", "\n", "                ", "return", "skewnormal_dist", ".", "ppf", "(", "(", "p_max", "-", "p_min", ")", "*", "alpha", "+", "p_min", ")", "\n", "\n", "", "", "return", "q", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_eta_q": [[134, 203], ["print", "reward_calculation.perm_sampling_neg_biased", "reward_calculation.get_q", "print", "reward_calculation.perm_sampling_neg_biased", "reward_calculation.get_q", "condition", "range", "all", "all", "condition", "ValueError", "print", "print", "print", "print", "reward_calculation.perm_sampling_neg_biased", "reward_calculation.get_q", "condition", "get_q.", "max", "print", "print", "print", "reward_calculation.get_alpha_min", "get_q.", "range", "get_q.", "reward_calculation.get_vCi", "range", "len", "len"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.perm_sampling_neg_biased", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_q", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.perm_sampling_neg_biased", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_q", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.perm_sampling_neg_biased", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_q", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_alpha_min", "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_vCi"], ["", "", "def", "get_eta_q", "(", "vN", ",", "alpha", ",", "v_is", ",", "phi", ",", "v", ",", "perm_samp_dataset", ",", "reference_dataset", ",", "kernel", ",", "low", "=", "0.001", ",", "high", "=", "1.", ",", "num_iters", "=", "10", ",", "\n", "mode", "=", "\"all\"", ",", "device", "=", "'cpu'", ")", ":", "\n", "    ", "\"\"\"\n    Binary search for lowest value of eta that satisfies desired condition\n    alpha_i: list of N alpha values\n    v_i: list of N v(i) values\n    \"\"\"", "\n", "\n", "def", "all_condition", "(", "q", ")", ":", "\n", "        ", "\"\"\"\n        For all i, q(alpha_i) > v_i\n        \"\"\"", "\n", "return", "all", "(", "[", "q", "(", "alpha", "[", "i", "]", ")", ">", "v_is", "[", "i", "]", "for", "i", "in", "range", "(", "len", "(", "alpha", ")", ")", "]", ")", "\n", "\n", "", "def", "max_condition", "(", "q", ")", ":", "\n", "        ", "\"\"\"\n        q(alpha^+_{min})> max(v(i))\n        \"\"\"", "\n", "return", "q", "(", "get_alpha_min", "(", "alpha", ")", ")", ">", "max", "(", "v_is", ")", "\n", "\n", "", "def", "stable_condition", "(", "q", ")", ":", "\n", "        ", "return", "all", "(", "[", "q", "(", "alpha", "[", "i", "]", ")", ">=", "get_vCi", "(", "i", "+", "1", ",", "phi", ",", "v", ")", "for", "i", "in", "range", "(", "len", "(", "alpha", ")", ")", "]", ")", "\n", "\n", "", "if", "mode", "==", "\"all\"", ":", "\n", "        ", "condition", "=", "all_condition", "\n", "", "elif", "mode", "==", "\"max\"", ":", "\n", "        ", "condition", "=", "max_condition", "\n", "", "elif", "mode", "==", "\"stable\"", ":", "\n", "        ", "condition", "=", "stable_condition", "\n", "\n", "", "print", "(", "\"Checking high value of eta\"", ")", "\n", "eta", "=", "high", "\n", "sorted_vX", "=", "perm_sampling_neg_biased", "(", "perm_samp_dataset", ",", "reference_dataset", ",", "kernel", ",", "num_perms", "=", "200", ",", "eta", "=", "eta", ",", "device", "=", "device", ")", "\n", "q", "=", "get_q", "(", "sorted_vX", ",", "vN", ")", "\n", "if", "not", "condition", "(", "q", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"High value of eta already violates {} condition\"", ".", "format", "(", "mode", ")", ")", "\n", "\n", "", "print", "(", "\"Checking low value of eta\"", ")", "\n", "eta", "=", "low", "\n", "sorted_vX", "=", "perm_sampling_neg_biased", "(", "perm_samp_dataset", ",", "reference_dataset", ",", "kernel", ",", "num_perms", "=", "200", ",", "eta", "=", "eta", ",", "device", "=", "device", ")", "\n", "q", "=", "get_q", "(", "sorted_vX", ",", "vN", ")", "\n", "if", "condition", "(", "q", ")", ":", "\n", "        ", "print", "(", "\"Low value of eta already satisfies {} condition\"", ".", "format", "(", "mode", ")", ")", "\n", "return", "eta", ",", "q", "\n", "\n", "", "current_low", "=", "low", "\n", "current_high", "=", "high", "\n", "current_high_q", "=", "q", "\n", "for", "i", "in", "range", "(", "num_iters", ")", ":", "\n", "        ", "print", "(", "\"Iteration {}\"", ".", "format", "(", "i", ")", ")", "\n", "print", "(", "\"current_high={}, current_low={}\"", ".", "format", "(", "current_high", ",", "current_low", ")", ")", "\n", "eta", "=", "(", "current_high", "+", "current_low", ")", "/", "2", "\n", "print", "(", "\"Evaluating for eta = {}\"", ".", "format", "(", "eta", ")", ")", "\n", "sorted_vX", "=", "perm_sampling_neg_biased", "(", "perm_samp_dataset", ",", "reference_dataset", ",", "kernel", ",", "num_perms", "=", "200", ",", "eta", "=", "eta", ",", "device", "=", "device", ")", "\n", "q", "=", "get_q", "(", "sorted_vX", ",", "vN", ")", "\n", "\n", "if", "condition", "(", "q", ")", ":", "\n", "            ", "print", "(", "\"{} condition satisfied, setting current_high to {}\"", ".", "format", "(", "mode", ",", "eta", ")", ")", "\n", "current_high", "=", "eta", "\n", "current_high_q", "=", "q", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"{} condition not satisfied, setting current_low to {}\"", ".", "format", "(", "mode", ",", "eta", ")", ")", "\n", "current_low", "=", "eta", "\n", "\n", "", "if", "current_low", ">=", "current_high", ":", "\n", "            ", "print", "(", "\"Low greater than or equal to high, terminating\"", ")", "\n", "break", "\n", "\n", "", "", "return", "current_high", ",", "current_high_q", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_q_rho": [[205, 226], ["range", "len", "range", "Exception", "len", "reward_calculation.get_vCi", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_vCi"], ["", "def", "get_q_rho", "(", "alpha", ",", "v_is", ",", "vN", ",", "phi", ",", "v", ",", "cond", "=", "'stable'", ")", ":", "\n", "    ", "rho", "=", "1", "\n", "\n", "if", "cond", "==", "'all'", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "alpha", ")", ")", ":", "\n", "            ", "if", "alpha", "[", "i", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "if", "(", "np", ".", "log", "(", "v_is", "[", "i", "]", ")", "-", "np", ".", "log", "(", "vN", ")", ")", "/", "np", ".", "log", "(", "alpha", "[", "i", "]", ")", "<", "rho", ":", "\n", "                    ", "rho", "=", "(", "np", ".", "log", "(", "v_is", "[", "i", "]", ")", "-", "np", ".", "log", "(", "vN", ")", ")", "/", "np", ".", "log", "(", "alpha", "[", "i", "]", ")", "\n", "", "", "", "", "elif", "cond", "==", "'stable'", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "alpha", ")", ")", ":", "\n", "            ", "if", "alpha", "[", "i", "]", "==", "1", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "vCi", "=", "get_vCi", "(", "i", "+", "1", ",", "phi", ",", "v", ")", "\n", "if", "(", "np", ".", "log", "(", "vCi", ")", "-", "np", ".", "log", "(", "vN", ")", ")", "/", "np", ".", "log", "(", "alpha", "[", "i", "]", ")", "<", "rho", ":", "\n", "                    ", "rho", "=", "(", "np", ".", "log", "(", "vCi", ")", "-", "np", ".", "log", "(", "vN", ")", ")", "/", "np", ".", "log", "(", "alpha", "[", "i", "]", ")", "\n", "", "", "", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"cond must be either all or stable\"", ")", "\n", "", "return", "lambda", "x", ":", "x", "**", "rho", "*", "vN", ",", "rho", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.opt_vstar": [[228, 271], ["range", "len", "numpy.concatenate", "numpy.concatenate", "numpy.array", "scipy.optimize.linprog", "print", "numpy.exp", "len", "Exception", "numpy.stack().transpose", "numpy.array", "numpy.log", "numpy.stack().transpose", "numpy.log", "numpy.stack", "numpy.argmax", "numpy.stack", "numpy.ones", "numpy.log", "numpy.ones", "numpy.log"], "function", ["None"], ["", "def", "opt_vstar", "(", "alpha", ",", "v_is", ",", "v_maxs", ",", "v_Cis", ",", "cond", "=", "'all'", ",", "rho_penalty", "=", "0.0", ")", ":", "\n", "    ", "\"\"\"\n\n    :param alpha:\n    :param v_is:\n    :param v_maxs:\n    :param phi:\n    :param v:\n    :param cond:\n    :param rho_penalty: if want rho to be as close to 1 as possible, set to negative\n    :return:\n    \"\"\"", "\n", "if", "cond", "==", "'all'", ":", "\n", "        ", "v_lowers", "=", "v_is", "\n", "", "elif", "cond", "==", "'stable'", ":", "\n", "        ", "v_lowers", "=", "v_Cis", "\n", "", "else", ":", "\n", "        ", "raise", "Exception", "(", "\"cond must be either all or stable\"", ")", "\n", "\n", "# Replace any negative numbers by small positive value", "\n", "", "for", "i", "in", "range", "(", "len", "(", "v_lowers", ")", ")", ":", "\n", "        ", "if", "v_lowers", "[", "i", "]", "<=", "0", ":", "\n", "            ", "v_lowers", "[", "i", "]", "=", "1e-07", "\n", "\n", "", "", "num_parties", "=", "len", "(", "alpha", ")", "\n", "A", "=", "np", ".", "concatenate", "(", "[", "np", ".", "stack", "(", "[", "np", ".", "ones", "(", "num_parties", ")", ",", "np", ".", "log", "(", "alpha", ")", "]", ")", ".", "transpose", "(", ")", ",", "\n", "-", "np", ".", "stack", "(", "[", "np", ".", "ones", "(", "num_parties", ")", ",", "np", ".", "log", "(", "alpha", ")", "]", ")", ".", "transpose", "(", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "0", ",", "1", "]", ",", "\n", "[", "0", ",", "-", "1", "]", "]", ")", "]", ")", "\n", "\n", "b", "=", "np", ".", "concatenate", "(", "[", "np", ".", "log", "(", "v_maxs", ")", ",", "-", "np", ".", "log", "(", "v_lowers", ")", ",", "[", "1", "]", ",", "[", "0", "]", "]", ")", "\n", "c", "=", "np", ".", "array", "(", "[", "-", "1", ",", "rho_penalty", "]", ")", "\n", "res", "=", "linprog", "(", "c", "=", "c", ",", "\n", "A_ub", "=", "A", ",", "\n", "b_ub", "=", "b", ",", "\n", "bounds", "=", "(", "None", ",", "None", ")", ",", "\n", "method", "=", "'revised simplex'", ")", "\n", "print", "(", "res", ")", "\n", "\n", "v_star", "=", "np", ".", "exp", "(", "res", ".", "x", "[", "0", "]", ")", "\n", "rho", "=", "res", ".", "x", "[", "1", "]", "\n", "\n", "return", "lambda", "x", ":", "x", "**", "rho", "*", "v_star", ",", "v_star", ",", "v_star", "/", "v_maxs", "[", "np", ".", "argmax", "(", "alpha", ")", "]", ",", "rho", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.reward_calculation.get_v_maxs": [[273, 282], ["v_maxs.append", "core.mmd.mmd_neg_biased_batched", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_biased_batched"], ["", "def", "get_v_maxs", "(", "party_datasets", ",", "reference_dataset", ",", "candidate_dataset", ",", "kernel", ",", "device", ",", "batch_size", ")", ":", "\n", "    ", "v_maxs", "=", "[", "]", "\n", "for", "party_ds", "in", "party_datasets", ":", "\n", "        ", "v_maxs", ".", "append", "(", "mmd_neg_biased_batched", "(", "np", ".", "concatenate", "(", "[", "party_ds", ",", "candidate_dataset", "]", ",", "axis", "=", "0", ")", ",", "\n", "reference_dataset", ",", "\n", "kernel", ",", "\n", "device", ",", "\n", "batch_size", ")", "[", "0", "]", ")", "\n", "", "return", "v_maxs", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_biased": [[5, 23], ["torch.tensor", "torch.tensor", "torch.sum", "torch.sum", "S_X.item", "S_XY.item", "k().evaluate", "k().evaluate", "k", "k"], "function", ["None"], ["def", "mmd_neg_biased", "(", "X", ",", "Y", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Calculates biased MMD^2 without the S_YY term, where S_X, S_XY and S_YY are the pairwise-XX, pairwise-XY, pairwise-YY\n    summation terms respectively.\n    :param X: array of shape (m, d)\n    :param Y: array of shape (n, d)\n    :param k: GPyTorch kernel\n    :return: MMD^2, S_X, S_XY, S_Y\n    \"\"\"", "\n", "m", "=", "X", ".", "shape", "[", "0", "]", "\n", "n", "=", "Y", ".", "shape", "[", "0", "]", "\n", "X_tens", "=", "torch", ".", "tensor", "(", "X", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "Y_tens", "=", "torch", ".", "tensor", "(", "Y", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "S_X", "=", "(", "1", "/", "(", "m", "**", "2", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "X_tens", ")", ".", "evaluate", "(", ")", ")", "\n", "S_XY", "=", "(", "2", "/", "(", "m", "*", "n", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "X_tens", ",", "Y_tens", ")", ".", "evaluate", "(", ")", ")", "\n", "\n", "return", "(", "S_XY", "-", "S_X", ")", ".", "item", "(", ")", ",", "S_X", ".", "item", "(", ")", ",", "S_XY", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_biased_batched": [[25, 54], ["torch.tensor", "torch.tensor", "torch.no_grad", "range", "S_X.item", "S_XY.item", "numpy.min", "torch.sum", "torch.sum", "k().evaluate", "k().evaluate", "torch.sum", "k().evaluate", "k", "k", "k"], "function", ["None"], ["", "def", "mmd_neg_biased_batched", "(", "X", ",", "Y", ",", "k", ",", "device", ",", "batch_size", "=", "128", ")", ":", "\n", "    ", "\"\"\"\n    Calculates biased MMD^2 without the S_YY term, where S_X, S_XY and S_YY are the pairwise-XX, pairwise-XY, pairwise-YY\n    summation terms respectively. Does so using the GPU in a batch-wise manner.\n    :param X: array of shape (m, d)\n    :param Y: array of shape (n, d)\n    :param k: GPyTorch kernel\n    :param device:\n    :param batch_size:\n    :return: MMD^2, S_X, S_XY\n    \"\"\"", "\n", "max_m", "=", "X", ".", "shape", "[", "0", "]", "\n", "n", "=", "Y", ".", "shape", "[", "0", "]", "\n", "\n", "X_tens", "=", "torch", ".", "tensor", "(", "X", ",", "device", "=", "device", ")", "\n", "Y_tens", "=", "torch", ".", "tensor", "(", "Y", ",", "device", "=", "device", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "S_XY", "=", "0", "\n", "S_X", "=", "0", "\n", "for", "i", "in", "range", "(", "(", "max_m", "//", "batch_size", ")", "+", "1", ")", ":", "\n", "            ", "idx", "=", "i", "+", "1", "\n", "next_m", "=", "np", ".", "min", "(", "[", "idx", "*", "batch_size", ",", "max_m", "]", ")", "\n", "m", "=", "(", "idx", "-", "1", ")", "*", "batch_size", "\n", "S_XY", "=", "(", "m", "*", "S_XY", "+", "(", "2", "/", "n", ")", "*", "torch", ".", "sum", "(", "k", "(", "X_tens", "[", "m", ":", "next_m", "]", ",", "Y_tens", ")", ".", "evaluate", "(", ")", ")", ")", "/", "next_m", "\n", "S_X", "=", "(", "(", "m", "**", "2", ")", "*", "S_X", "+", "2", "*", "torch", ".", "sum", "(", "k", "(", "X_tens", "[", "m", ":", "next_m", "]", ",", "X_tens", "[", ":", "m", "]", ")", ".", "evaluate", "(", ")", ")", "+", "\n", "torch", ".", "sum", "(", "k", "(", "X_tens", "[", "m", ":", "next_m", "]", ")", ".", "evaluate", "(", ")", ")", ")", "/", "(", "next_m", "**", "2", ")", "\n", "\n", "", "", "return", "(", "S_XY", "-", "S_X", ")", ".", "item", "(", ")", ",", "S_X", ".", "item", "(", ")", ",", "S_XY", ".", "item", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_unbiased": [[56, 72], ["X.size", "Y.size", "torch.sum", "torch.sum", "torch.sum", "k().evaluate", "torch.sum", "torch.sum", "k().evaluate", "torch.diag", "k().evaluate", "torch.diag", "k().evaluate", "k", "k().evaluate", "k", "k", "k", "k"], "function", ["None"], ["", "def", "mmd_neg_unbiased", "(", "X", ",", "Y", ",", "k", ")", ":", "\n", "    ", "\"\"\"\n    Used as loss function.\n    :param X: Torch tensor\n    :param Y: Torch tensor\n    :param k: GPyTorch kernel\n    :return: scalar\n    \"\"\"", "\n", "m", "=", "X", ".", "size", "(", "0", ")", "\n", "n", "=", "Y", ".", "size", "(", "0", ")", "\n", "\n", "S_X", "=", "(", "1", "/", "(", "m", "*", "(", "m", "-", "1", ")", ")", ")", "*", "(", "torch", ".", "sum", "(", "k", "(", "X", ")", ".", "evaluate", "(", ")", ")", "-", "torch", ".", "sum", "(", "torch", ".", "diag", "(", "k", "(", "X", ")", ".", "evaluate", "(", ")", ")", ")", ")", "\n", "S_XY", "=", "(", "2", "/", "(", "m", "*", "n", ")", ")", "*", "torch", ".", "sum", "(", "k", "(", "X", ",", "Y", ")", ".", "evaluate", "(", ")", ")", "\n", "S_Y", "=", "(", "1", "/", "(", "n", "*", "(", "n", "-", "1", ")", ")", ")", "*", "(", "torch", ".", "sum", "(", "k", "(", "Y", ")", ".", "evaluate", "(", ")", ")", "-", "torch", ".", "sum", "(", "torch", ".", "diag", "(", "k", "(", "Y", ")", ".", "evaluate", "(", ")", ")", ")", ")", "\n", "\n", "return", "S_XY", "-", "S_X", "-", "S_Y", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.mmd.mmd_neg_unbiased_batched": [[74, 98], ["X.size", "Y.size", "torch.no_grad", "range", "range", "numpy.min", "numpy.min", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.diag", "torch.sum", "torch.diag", "k().evaluate", "k().evaluate", "k().evaluate", "k().evaluate", "k().evaluate", "torch.sum", "torch.sum", "k", "k().evaluate", "k", "k", "k().evaluate", "k", "k", "k", "k"], "function", ["None"], ["", "def", "mmd_neg_unbiased_batched", "(", "X", ",", "Y", ",", "k", ",", "batch_size", "=", "128", ")", ":", "\n", "    ", "max_m", "=", "X", ".", "size", "(", "0", ")", "\n", "max_n", "=", "Y", ".", "size", "(", "0", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "        ", "S_XY", "=", "0", "\n", "S_X", "=", "0", "\n", "S_Y", "=", "0", "\n", "for", "i", "in", "range", "(", "(", "max_m", "//", "batch_size", ")", "+", "1", ")", ":", "\n", "            ", "idx", "=", "i", "+", "1", "\n", "next_m", "=", "np", ".", "min", "(", "[", "idx", "*", "batch_size", ",", "max_m", "]", ")", "\n", "m", "=", "(", "idx", "-", "1", ")", "*", "batch_size", "\n", "S_XY", "=", "(", "m", "*", "S_XY", "+", "(", "2", "/", "max_n", ")", "*", "torch", ".", "sum", "(", "k", "(", "X", "[", "m", ":", "next_m", "]", ",", "Y", ")", ".", "evaluate", "(", ")", ")", ")", "/", "next_m", "\n", "S_X", "=", "(", "(", "m", "*", "(", "m", "-", "1", ")", ")", "*", "S_X", "+", "2", "*", "torch", ".", "sum", "(", "k", "(", "X", "[", "m", ":", "next_m", "]", ",", "X", "[", ":", "m", "]", ")", ".", "evaluate", "(", ")", ")", "+", "\n", "torch", ".", "sum", "(", "k", "(", "X", "[", "m", ":", "next_m", "]", ")", ".", "evaluate", "(", ")", ")", "-", "torch", ".", "sum", "(", "torch", ".", "diag", "(", "k", "(", "X", "[", "m", ":", "next_m", "]", ")", ".", "evaluate", "(", ")", ")", ")", ")", "/", "(", "next_m", "*", "(", "next_m", "-", "1", ")", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "(", "max_n", "//", "batch_size", ")", "+", "1", ")", ":", "\n", "            ", "idx", "=", "i", "+", "1", "\n", "next_n", "=", "np", ".", "min", "(", "[", "idx", "*", "batch_size", ",", "max_n", "]", ")", "\n", "n", "=", "(", "idx", "-", "1", ")", "*", "batch_size", "\n", "S_Y", "=", "(", "(", "n", "*", "(", "n", "-", "1", ")", ")", "*", "S_Y", "+", "2", "*", "torch", ".", "sum", "(", "k", "(", "Y", "[", "n", ":", "next_n", "]", ",", "Y", "[", ":", "n", "]", ")", ".", "evaluate", "(", ")", ")", "+", "\n", "torch", ".", "sum", "(", "k", "(", "Y", "[", "n", ":", "next_n", "]", ")", ".", "evaluate", "(", ")", ")", "-", "torch", ".", "sum", "(", "torch", ".", "diag", "(", "k", "(", "Y", "[", "n", ":", "next_n", "]", ")", ".", "evaluate", "(", ")", ")", ")", ")", "/", "(", "next_n", "*", "(", "next_n", "-", "1", ")", ")", "\n", "\n", "", "", "return", "S_XY", "-", "S_X", "-", "S_Y", "\n", "", ""]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.union": [[4, 9], ["len", "numpy.concatenate"], "function", ["None"], ["def", "union", "(", "D", ",", "R", ")", ":", "\n", "    ", "if", "len", "(", "R", ")", "==", "0", ":", "\n", "        ", "return", "D", "\n", "", "else", ":", "\n", "        ", "return", "np", ".", "concatenate", "(", "(", "D", ",", "R", ")", ",", "axis", "=", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.unison_shuffled_copies": [[11, 15], ["numpy.random.permutation", "len", "len", "len"], "function", ["None"], ["", "", "def", "unison_shuffled_copies", "(", "a", ",", "b", ")", ":", "\n", "    ", "assert", "len", "(", "a", ")", "==", "len", "(", "b", ")", "\n", "p", "=", "np", ".", "random", ".", "permutation", "(", "len", "(", "a", ")", ")", "\n", "return", "a", "[", "p", "]", ",", "b", "[", "p", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.split_proportions": [[17, 48], ["range", "range", "range", "min", "utils.unison_shuffled_copies", "numpy.array", "numpy.array", "range", "range", "range", "range", "numpy.array", "numpy.array", "int", "split_datasets[].append", "split_labels[].append", "len"], "function", ["home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.unison_shuffled_copies"], ["", "def", "split_proportions", "(", "dataset", ",", "proportions", ",", "party_data_size", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param dataset: array of shape (num_classes, N, ..).\n    :param proportions: array of probability simplices of shape (num_parties, num_classes). Must sum to 1 along\n    all rows and columns\n    :return: party_datasets array of shape (num_parties, N, ..), party_labels array of shape(num_parties, N)\n    \"\"\"", "\n", "num_classes", ",", "N", "=", "dataset", ".", "shape", "[", "0", "]", ",", "dataset", ".", "shape", "[", "1", "]", "\n", "num_parties", "=", "proportions", ".", "shape", "[", "0", "]", "\n", "split_datasets", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_parties", ")", "]", "\n", "split_labels", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_parties", ")", "]", "\n", "dataset_idx", "=", "[", "0", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "        ", "for", "j", "in", "range", "(", "num_classes", ")", ":", "\n", "            ", "prop", "=", "proportions", "[", "i", ",", "j", "]", "\n", "for", "_", "in", "range", "(", "int", "(", "prop", "*", "(", "num_classes", "/", "num_parties", ")", "*", "N", ")", ")", ":", "\n", "                ", "split_datasets", "[", "i", "]", ".", "append", "(", "dataset", "[", "j", ",", "dataset_idx", "[", "j", "]", "]", ")", "\n", "split_labels", "[", "i", "]", ".", "append", "(", "j", ")", "\n", "dataset_idx", "[", "j", "]", "+=", "1", "\n", "\n", "# Constrain all datasets to have the same length", "\n", "", "", "", "if", "party_data_size", "is", "None", ":", "\n", "        ", "party_data_size", "=", "min", "(", "len", "(", "ds", ")", "for", "ds", "in", "split_datasets", ")", "\n", "", "for", "i", "in", "range", "(", "num_parties", ")", ":", "\n", "        ", "current_dataset", ",", "current_labels", "=", "unison_shuffled_copies", "(", "np", ".", "array", "(", "split_datasets", "[", "i", "]", ")", ",", "\n", "np", ".", "array", "(", "split_labels", "[", "i", "]", ")", ")", "\n", "split_datasets", "[", "i", "]", "=", "current_dataset", "[", ":", "party_data_size", "]", "\n", "split_labels", "[", "i", "]", "=", "current_labels", "[", ":", "party_data_size", "]", "\n", "\n", "", "return", "np", ".", "array", "(", "split_datasets", ")", ",", "np", ".", "array", "(", "split_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.split_data_into_classes": [[50, 68], ["len", "range", "min", "range", "numpy.array", "dataset_in_classes[].append", "range", "len"], "function", ["None"], ["", "def", "split_data_into_classes", "(", "dataset", ",", "labels", ",", "num_classes", ")", ":", "\n", "    ", "\"\"\"\n    :param dataset: array of shape (N * num_classes, d)\n    :param labels: array of shape (N)\n    :param num_classes: int\n    :return: array of shape (num_classes, N, d)\n    \"\"\"", "\n", "N", "=", "len", "(", "labels", ")", "\n", "dataset_in_classes", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_classes", ")", "]", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "        ", "dataset_in_classes", "[", "labels", "[", "i", "]", "]", ".", "append", "(", "dataset", "[", "i", "]", ")", "\n", "\n", "# Constrain all classes to have the same length", "\n", "", "min_length", "=", "min", "(", "len", "(", "ds", ")", "for", "ds", "in", "dataset_in_classes", ")", "\n", "for", "i", "in", "range", "(", "num_classes", ")", ":", "\n", "        ", "dataset_in_classes", "[", "i", "]", "=", "dataset_in_classes", "[", "i", "]", "[", ":", "min_length", "]", "\n", "\n", "", "return", "np", ".", "array", "(", "dataset_in_classes", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.XinyiYS_CML-RewardDistribution.core.utils.norm": [[71, 74], ["max", "list", "map"], "function", ["None"], ["", "def", "norm", "(", "lst", ")", ":", "\n", "    ", "max_val", "=", "max", "(", "lst", ")", "\n", "return", "list", "(", "map", "(", "lambda", "x", ":", "x", "/", "max_val", ",", "lst", ")", ")", "\n", "", ""]]}