{"home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.exp.init_config": [[31, 41], ["arg_parser.parse_args", "torch.manual_seed", "np.random.seed", "torch.cuda.manual_seed", "int"], "function", ["None"], ["", "def", "init_config", "(", ")", ":", "\n", "    ", "args", "=", "arg_parser", ".", "parse_args", "(", ")", "\n", "\n", "# seed the RNG", "\n", "torch", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "if", "args", ".", "cuda", ":", "\n", "        ", "torch", ".", "cuda", ".", "manual_seed", "(", "args", ".", "seed", ")", "\n", "", "np", ".", "random", ".", "seed", "(", "int", "(", "args", ".", "seed", "*", "13", "/", "7", ")", ")", "\n", "\n", "return", "args", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.exp.train": [[43, 219], ["components.dataset.Dataset.from_bin_file", "six.load", "asdl.asdl.ASDLGrammar.from_text", "Registrable.by_name", "model.cuda.train", "eval", "eval.", "print", "print", "components.dataset.Dataset.from_bin_file", "components.dataset.Dataset", "open", "open().read", "Registrable.by_name", "print", "Registrable.by_name.load", "Registrable.by_name.", "Registrable.by_name", "model.cuda.cuda", "model.cuda.parameters", "time.time", "Dataset.from_bin_file.batch_iter", "print", "print", "model.nn_utils.uniform_init", "print", "model.utils.GloveHelper", "model.utils.GloveHelper.load_to", "repr", "torch.optim.Adam.zero_grad", "model.cuda.score", "torch.sum().data.item", "len", "torch.mean", "torch.mean.backward", "torch.optim.Adam.step", "print", "model.cuda.save", "print", "print", "print", "model.cuda.save", "torch.save", "print", "exit", "print", "print", "torch.load", "model.cuda.load_state_dict", "open", "model.cuda.parameters", "print", "model.nn_utils.glorot_init", "len", "len", "torch.nn.utils.clip_grad_norm_", "print", "print", "time.time", "evaluation.evaluate", "print", "history_dev_scores.append", "torch.optim.Adam.state_dict", "print", "print", "exit", "model.cuda.cuda", "print", "torch.optim.Adam", "print", "torch.optim.Adam.load_state_dict", "model.cuda.parameters", "model.cuda.parameters", "model.cuda.parameters", "torch.load", "len", "torch.sum", "torch.log().mean", "time.time", "max", "torch.log", "time.time", "torch.cat"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.from_text", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.batch_iter", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.uniform_init", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.load_to", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.score", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.glorot_init", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.evaluation.evaluate", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load"], ["", "def", "train", "(", "args", ")", ":", "\n", "    ", "\"\"\"Maximum Likelihood Estimation\"\"\"", "\n", "\n", "# load in train/dev set", "\n", "train_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "train_file", ")", "\n", "\n", "if", "args", ".", "dev_file", ":", "\n", "        ", "dev_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "dev_file", ")", "\n", "", "else", ":", "dev_set", "=", "Dataset", "(", "examples", "=", "[", "]", ")", "\n", "\n", "vocab", "=", "pickle", ".", "load", "(", "open", "(", "args", ".", "vocab", ",", "'rb'", ")", ")", "\n", "\n", "grammar", "=", "ASDLGrammar", ".", "from_text", "(", "open", "(", "args", ".", "asdl_file", ")", ".", "read", "(", ")", ")", "\n", "transition_system", "=", "Registrable", ".", "by_name", "(", "args", ".", "transition_system", ")", "(", "grammar", ")", "\n", "\n", "parser_cls", "=", "Registrable", ".", "by_name", "(", "args", ".", "parser", ")", "# TODO: add arg", "\n", "if", "args", ".", "pretrain", ":", "\n", "        ", "print", "(", "'Finetune with: '", ",", "args", ".", "pretrain", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "model", "=", "parser_cls", ".", "load", "(", "model_path", "=", "args", ".", "pretrain", ",", "cuda", "=", "args", ".", "cuda", ")", "\n", "", "else", ":", "\n", "        ", "model", "=", "parser_cls", "(", "args", ",", "vocab", ",", "transition_system", ")", "\n", "\n", "", "model", ".", "train", "(", ")", "\n", "evaluator", "=", "Registrable", ".", "by_name", "(", "args", ".", "evaluator", ")", "(", "transition_system", ",", "args", "=", "args", ")", "\n", "if", "args", ".", "cuda", ":", "model", ".", "cuda", "(", ")", "\n", "\n", "optimizer_cls", "=", "eval", "(", "'torch.optim.%s'", "%", "args", ".", "optimizer", ")", "# FIXME: this is evil!", "\n", "optimizer", "=", "optimizer_cls", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "if", "not", "args", ".", "pretrain", ":", "\n", "        ", "if", "args", ".", "uniform_init", ":", "\n", "            ", "print", "(", "'uniformly initialize parameters [-%f, +%f]'", "%", "(", "args", ".", "uniform_init", ",", "args", ".", "uniform_init", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "nn_utils", ".", "uniform_init", "(", "-", "args", ".", "uniform_init", ",", "args", ".", "uniform_init", ",", "model", ".", "parameters", "(", ")", ")", "\n", "", "elif", "args", ".", "glorot_init", ":", "\n", "            ", "print", "(", "'use glorot initialization'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "nn_utils", ".", "glorot_init", "(", "model", ".", "parameters", "(", ")", ")", "\n", "\n", "# load pre-trained word embedding (optional)", "\n", "", "if", "args", ".", "glove_embed_path", ":", "\n", "            ", "print", "(", "'load glove embedding from: %s'", "%", "args", ".", "glove_embed_path", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "glove_embedding", "=", "GloveHelper", "(", "args", ".", "glove_embed_path", ")", "\n", "glove_embedding", ".", "load_to", "(", "model", ".", "src_embed", ",", "vocab", ".", "source", ")", "\n", "\n", "", "", "print", "(", "'begin training, %d training examples, %d dev examples'", "%", "(", "len", "(", "train_set", ")", ",", "len", "(", "dev_set", ")", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'vocab: %s'", "%", "repr", "(", "vocab", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "epoch", "=", "train_iter", "=", "0", "\n", "report_loss", "=", "report_examples", "=", "report_sup_att_loss", "=", "0.", "\n", "history_dev_scores", "=", "[", "]", "\n", "num_trial", "=", "patience", "=", "0", "\n", "while", "True", ":", "\n", "        ", "epoch", "+=", "1", "\n", "epoch_begin", "=", "time", ".", "time", "(", ")", "\n", "\n", "for", "batch_examples", "in", "train_set", ".", "batch_iter", "(", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "True", ")", ":", "\n", "            ", "batch_examples", "=", "[", "e", "for", "e", "in", "batch_examples", "if", "len", "(", "e", ".", "tgt_actions", ")", "<=", "args", ".", "decode_max_time_step", "]", "\n", "train_iter", "+=", "1", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "ret_val", "=", "model", ".", "score", "(", "batch_examples", ")", "\n", "loss", "=", "-", "ret_val", "[", "0", "]", "\n", "\n", "# print(loss.data)", "\n", "loss_val", "=", "torch", ".", "sum", "(", "loss", ")", ".", "data", ".", "item", "(", ")", "\n", "report_loss", "+=", "loss_val", "\n", "report_examples", "+=", "len", "(", "batch_examples", ")", "\n", "loss", "=", "torch", ".", "mean", "(", "loss", ")", "\n", "\n", "if", "args", ".", "sup_attention", ":", "\n", "                ", "att_probs", "=", "ret_val", "[", "1", "]", "\n", "if", "att_probs", ":", "\n", "                    ", "sup_att_loss", "=", "-", "torch", ".", "log", "(", "torch", ".", "cat", "(", "att_probs", ")", ")", ".", "mean", "(", ")", "\n", "sup_att_loss_val", "=", "sup_att_loss", ".", "data", "[", "0", "]", "\n", "report_sup_att_loss", "+=", "sup_att_loss_val", "\n", "\n", "loss", "+=", "sup_att_loss", "\n", "\n", "", "", "loss", ".", "backward", "(", ")", "\n", "\n", "# clip gradient", "\n", "if", "args", ".", "clip_grad", ">", "0.", ":", "\n", "                ", "grad_norm", "=", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "args", ".", "clip_grad", ")", "\n", "\n", "", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "train_iter", "%", "args", ".", "log_every", "==", "0", ":", "\n", "                ", "log_str", "=", "'[Iter %d] encoder loss=%.5f'", "%", "(", "train_iter", ",", "report_loss", "/", "report_examples", ")", "\n", "if", "args", ".", "sup_attention", ":", "\n", "                    ", "log_str", "+=", "' supervised attention loss=%.5f'", "%", "(", "report_sup_att_loss", "/", "report_examples", ")", "\n", "report_sup_att_loss", "=", "0.", "\n", "\n", "", "print", "(", "log_str", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "report_loss", "=", "report_examples", "=", "0.", "\n", "\n", "", "", "print", "(", "'[Epoch %d] epoch elapsed %ds'", "%", "(", "epoch", ",", "time", ".", "time", "(", ")", "-", "epoch_begin", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "if", "args", ".", "save_all_models", ":", "\n", "            ", "model_file", "=", "args", ".", "save_to", "+", "'.iter%d.bin'", "%", "train_iter", "\n", "print", "(", "'save model to [%s]'", "%", "model_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "model", ".", "save", "(", "model_file", ")", "\n", "\n", "# perform validation", "\n", "", "is_better", "=", "False", "\n", "if", "args", ".", "dev_file", ":", "\n", "            ", "if", "epoch", "%", "args", ".", "valid_every_epoch", "==", "0", ":", "\n", "                ", "print", "(", "'[Epoch %d] begin validation'", "%", "epoch", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "eval_start", "=", "time", ".", "time", "(", ")", "\n", "eval_results", "=", "evaluation", ".", "evaluate", "(", "dev_set", ".", "examples", ",", "model", ",", "evaluator", ",", "args", ",", "\n", "verbose", "=", "False", ",", "eval_top_pred_only", "=", "args", ".", "eval_top_pred_only", ")", "\n", "dev_score", "=", "eval_results", "[", "evaluator", ".", "default_metric", "]", "\n", "\n", "print", "(", "'[Epoch %d] evaluate details: %s, dev %s: %.5f (took %ds)'", "%", "(", "\n", "epoch", ",", "eval_results", ",", "\n", "evaluator", ".", "default_metric", ",", "\n", "dev_score", ",", "\n", "time", ".", "time", "(", ")", "-", "eval_start", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "is_better", "=", "history_dev_scores", "==", "[", "]", "or", "dev_score", ">", "max", "(", "history_dev_scores", ")", "\n", "history_dev_scores", ".", "append", "(", "dev_score", ")", "\n", "", "", "else", ":", "\n", "            ", "is_better", "=", "True", "\n", "\n", "", "if", "args", ".", "decay_lr_every_epoch", "and", "epoch", ">", "args", ".", "lr_decay_after_epoch", ":", "\n", "            ", "lr", "=", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "*", "args", ".", "lr_decay", "\n", "print", "(", "'decay learning rate to %f'", "%", "lr", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# set new lr", "\n", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "                ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n", "", "", "if", "is_better", ":", "\n", "            ", "patience", "=", "0", "\n", "model_file", "=", "args", ".", "save_to", "+", "'.bin'", "\n", "print", "(", "'save the current model ..'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'save model to [%s]'", "%", "model_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "model", ".", "save", "(", "model_file", ")", "\n", "# also save the optimizers' state", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "args", ".", "save_to", "+", "'.optim.bin'", ")", "\n", "", "elif", "patience", "<", "args", ".", "patience", "and", "epoch", ">=", "args", ".", "lr_decay_after_epoch", ":", "\n", "            ", "patience", "+=", "1", "\n", "print", "(", "'hit patience %d'", "%", "patience", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "if", "epoch", "==", "args", ".", "max_epoch", ":", "\n", "            ", "print", "(", "'reached max epoch, stop!'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "", "if", "patience", ">=", "args", ".", "patience", "and", "epoch", ">=", "args", ".", "lr_decay_after_epoch", ":", "\n", "            ", "num_trial", "+=", "1", "\n", "print", "(", "'hit #%d trial'", "%", "num_trial", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "if", "num_trial", "==", "args", ".", "max_num_trial", ":", "\n", "                ", "print", "(", "'early stop!'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "# decay lr, and restore from previously best checkpoint", "\n", "", "lr", "=", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "*", "args", ".", "lr_decay", "\n", "print", "(", "'load previously best model and decay learning rate to %f'", "%", "lr", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# load model", "\n", "params", "=", "torch", ".", "load", "(", "args", ".", "save_to", "+", "'.bin'", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "model", ".", "load_state_dict", "(", "params", "[", "'state_dict'", "]", ")", "\n", "if", "args", ".", "cuda", ":", "model", "=", "model", ".", "cuda", "(", ")", "\n", "\n", "# load optimizers", "\n", "if", "args", ".", "reset_optimizer", ":", "\n", "                ", "print", "(", "'reset optimizer'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "'restore parameters of the optimizers'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "args", ".", "save_to", "+", "'.optim.bin'", ")", ")", "\n", "\n", "# set new lr", "\n", "", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "                ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n", "# reset patience", "\n", "", "patience", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.exp.train_rerank_feature": [[221, 456], ["components.dataset.Dataset.from_bin_file", "components.dataset.Dataset.from_bin_file", "six.load", "asdl.asdl.ASDLGrammar.from_text", "model.cuda.train", "torch.optim.Adam", "print", "print", "open", "open().read", "asdl.transition_system.TransitionSystem.get_class_by_lang", "six.moves.xrange", "exp.train_rerank_feature._get_feat_class"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.from_text", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_class_by_lang"], ["", "", "", "def", "train_rerank_feature", "(", "args", ")", ":", "\n", "    ", "train_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "train_file", ")", "\n", "dev_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "dev_file", ")", "\n", "vocab", "=", "pickle", ".", "load", "(", "open", "(", "args", ".", "vocab", ",", "'rb'", ")", ")", "\n", "\n", "grammar", "=", "ASDLGrammar", ".", "from_text", "(", "open", "(", "args", ".", "asdl_file", ")", ".", "read", "(", ")", ")", "\n", "transition_system", "=", "TransitionSystem", ".", "get_class_by_lang", "(", "args", ".", "lang", ")", "(", "grammar", ")", "\n", "\n", "train_paraphrase_model", "=", "args", ".", "mode", "==", "'train_paraphrase_identifier'", "\n", "\n", "def", "_get_feat_class", "(", ")", ":", "\n", "        ", "if", "args", ".", "mode", "==", "'train_reconstructor'", ":", "\n", "            ", "return", "Reconstructor", "\n", "", "elif", "args", ".", "mode", "==", "'train_paraphrase_identifier'", ":", "\n", "            ", "return", "ParaphraseIdentificationModel", "\n", "\n", "", "", "def", "_filter_hyps", "(", "_decode_results", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "_decode_results", ")", ")", ":", "\n", "            ", "valid_hyps", "=", "[", "]", "\n", "for", "hyp", "in", "_decode_results", "[", "i", "]", ":", "\n", "                ", "try", ":", "\n", "                    ", "transition_system", ".", "tokenize_code", "(", "hyp", ".", "code", ")", "\n", "valid_hyps", ".", "append", "(", "hyp", ")", "\n", "", "except", ":", "pass", "\n", "\n", "", "_decode_results", "[", "i", "]", "=", "valid_hyps", "\n", "\n", "", "", "model", "=", "_get_feat_class", "(", ")", "(", "args", ",", "vocab", ",", "transition_system", ")", "\n", "\n", "if", "args", ".", "glorot_init", ":", "\n", "        ", "print", "(", "'use glorot initialization'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "nn_utils", ".", "glorot_init", "(", "model", ".", "parameters", "(", ")", ")", "\n", "\n", "", "model", ".", "train", "(", ")", "\n", "if", "args", ".", "cuda", ":", "model", ".", "cuda", "(", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "parameters", "(", ")", ",", "lr", "=", "args", ".", "lr", ")", "\n", "\n", "# if training the paraphrase model, also load in decoding results", "\n", "if", "train_paraphrase_model", ":", "\n", "        ", "print", "(", "'load training decode results [%s]'", "%", "args", ".", "train_decode_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "train_decode_results", "=", "pickle", ".", "load", "(", "open", "(", "args", ".", "train_decode_file", ",", "'rb'", ")", ")", "\n", "_filter_hyps", "(", "train_decode_results", ")", "\n", "train_decode_results", "=", "{", "e", ".", "idx", ":", "hyps", "for", "e", ",", "hyps", "in", "zip", "(", "train_set", ",", "train_decode_results", ")", "}", "\n", "\n", "print", "(", "'load dev decode results [%s]'", "%", "args", ".", "dev_decode_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "dev_decode_results", "=", "pickle", ".", "load", "(", "open", "(", "args", ".", "dev_decode_file", ",", "'rb'", ")", ")", "\n", "_filter_hyps", "(", "dev_decode_results", ")", "\n", "dev_decode_results", "=", "{", "e", ".", "idx", ":", "hyps", "for", "e", ",", "hyps", "in", "zip", "(", "dev_set", ",", "dev_decode_results", ")", "}", "\n", "\n", "", "def", "evaluate_ppl", "(", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "cum_loss", "=", "0.", "\n", "cum_tgt_words", "=", "0.", "\n", "for", "batch", "in", "dev_set", ".", "batch_iter", "(", "args", ".", "batch_size", ")", ":", "\n", "            ", "loss", "=", "-", "model", ".", "score", "(", "batch", ")", ".", "sum", "(", ")", "\n", "cum_loss", "+=", "loss", ".", "data", ".", "item", "(", ")", "\n", "cum_tgt_words", "+=", "sum", "(", "len", "(", "e", ".", "src_sent", ")", "+", "1", "for", "e", "in", "batch", ")", "# add ending </s>", "\n", "\n", "", "ppl", "=", "np", ".", "exp", "(", "cum_loss", "/", "cum_tgt_words", ")", "\n", "model", ".", "train", "(", ")", "\n", "return", "ppl", "\n", "\n", "", "def", "evaluate_paraphrase_acc", "(", ")", ":", "\n", "        ", "model", ".", "eval", "(", ")", "\n", "labels", "=", "[", "]", "\n", "for", "batch", "in", "dev_set", ".", "batch_iter", "(", "args", ".", "batch_size", ")", ":", "\n", "            ", "probs", "=", "model", ".", "score", "(", "batch", ")", ".", "exp", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "p", "in", "probs", ":", "\n", "                ", "labels", ".", "append", "(", "p", ">=", "0.5", ")", "\n", "\n", "# get negative examples", "\n", "", "batch_decoding_results", "=", "[", "dev_decode_results", "[", "e", ".", "idx", "]", "for", "e", "in", "batch", "]", "\n", "batch_negative_examples", "=", "[", "get_negative_example", "(", "e", ",", "_hyps", ",", "type", "=", "'best'", ")", "\n", "for", "e", ",", "_hyps", "in", "zip", "(", "batch", ",", "batch_decoding_results", ")", "]", "\n", "batch_negative_examples", "=", "list", "(", "filter", "(", "None", ",", "batch_negative_examples", ")", ")", "\n", "probs", "=", "model", ".", "score", "(", "batch_negative_examples", ")", ".", "exp", "(", ")", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "for", "p", "in", "probs", ":", "\n", "                ", "labels", ".", "append", "(", "p", "<", "0.5", ")", "\n", "\n", "", "", "acc", "=", "np", ".", "average", "(", "labels", ")", "\n", "model", ".", "train", "(", ")", "\n", "return", "acc", "\n", "\n", "", "def", "get_negative_example", "(", "_example", ",", "_hyps", ",", "type", "=", "'sample'", ")", ":", "\n", "        ", "incorrect_hyps", "=", "[", "hyp", "for", "hyp", "in", "_hyps", "if", "not", "hyp", ".", "is_correct", "]", "\n", "if", "incorrect_hyps", ":", "\n", "            ", "incorrect_hyp_scores", "=", "[", "hyp", ".", "score", "for", "hyp", "in", "incorrect_hyps", "]", "\n", "if", "type", "in", "(", "'best'", ",", "'sample'", ")", ":", "\n", "                ", "if", "type", "==", "'best'", ":", "\n", "                    ", "sample_idx", "=", "np", ".", "argmax", "(", "incorrect_hyp_scores", ")", "\n", "sampled_hyp", "=", "incorrect_hyps", "[", "sample_idx", "]", "\n", "", "else", ":", "\n", "                    ", "incorrect_hyp_probs", "=", "[", "np", ".", "exp", "(", "score", ")", "for", "score", "in", "incorrect_hyp_scores", "]", "\n", "incorrect_hyp_probs", "=", "np", ".", "array", "(", "incorrect_hyp_probs", ")", "/", "sum", "(", "incorrect_hyp_probs", ")", "\n", "sampled_hyp", "=", "np", ".", "random", ".", "choice", "(", "incorrect_hyps", ",", "size", "=", "1", ",", "p", "=", "incorrect_hyp_probs", ")", "\n", "sampled_hyp", "=", "sampled_hyp", "[", "0", "]", "\n", "\n", "", "sample", "=", "Example", "(", "idx", "=", "'negative-%s'", "%", "_example", ".", "idx", ",", "\n", "src_sent", "=", "_example", ".", "src_sent", ",", "\n", "tgt_code", "=", "sampled_hyp", ".", "code", ",", "\n", "tgt_actions", "=", "None", ",", "\n", "tgt_ast", "=", "None", ")", "\n", "return", "sample", "\n", "", "elif", "type", "==", "'all'", ":", "\n", "                ", "samples", "=", "[", "]", "\n", "for", "i", ",", "hyp", "in", "enumerate", "(", "incorrect_hyps", ")", ":", "\n", "                    ", "sample", "=", "Example", "(", "idx", "=", "'negative-%s-%d'", "%", "(", "_example", ".", "idx", ",", "i", ")", ",", "\n", "src_sent", "=", "_example", ".", "src_sent", ",", "\n", "tgt_code", "=", "hyp", ".", "code", ",", "\n", "tgt_actions", "=", "None", ",", "\n", "tgt_ast", "=", "None", ")", "\n", "samples", ".", "append", "(", "sample", ")", "\n", "\n", "", "return", "samples", "\n", "", "", "else", ":", "\n", "            ", "return", "None", "\n", "\n", "", "", "print", "(", "'begin training decoder, %d training examples, %d dev examples'", "%", "(", "len", "(", "train_set", ")", ",", "len", "(", "dev_set", ")", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'vocab: %s'", "%", "repr", "(", "vocab", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "epoch", "=", "train_iter", "=", "0", "\n", "report_loss", "=", "report_examples", "=", "0.", "\n", "history_dev_scores", "=", "[", "]", "\n", "num_trial", "=", "patience", "=", "0", "\n", "while", "True", ":", "\n", "        ", "epoch", "+=", "1", "\n", "epoch_begin", "=", "time", ".", "time", "(", ")", "\n", "\n", "for", "batch_examples", "in", "train_set", ".", "batch_iter", "(", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "True", ")", ":", "\n", "            ", "batch_examples", "=", "[", "e", "for", "e", "in", "batch_examples", "if", "len", "(", "e", ".", "tgt_actions", ")", "<=", "args", ".", "decode_max_time_step", "]", "\n", "\n", "if", "train_paraphrase_model", ":", "\n", "                ", "positive_examples_num", "=", "len", "(", "batch_examples", ")", "\n", "labels", "=", "[", "0", "]", "*", "len", "(", "batch_examples", ")", "\n", "negative_samples", "=", "[", "]", "\n", "batch_decoding_results", "=", "[", "train_decode_results", "[", "e", ".", "idx", "]", "for", "e", "in", "batch_examples", "]", "\n", "# sample negative examples", "\n", "for", "example", ",", "hyps", "in", "zip", "(", "batch_examples", ",", "batch_decoding_results", ")", ":", "\n", "                    ", "if", "hyps", ":", "\n", "                        ", "negative_sample", "=", "get_negative_example", "(", "example", ",", "hyps", ",", "type", "=", "args", ".", "negative_sample_type", ")", "\n", "if", "negative_sample", ":", "\n", "                            ", "if", "isinstance", "(", "negative_sample", ",", "Example", ")", ":", "\n", "                                ", "negative_samples", ".", "append", "(", "negative_sample", ")", "\n", "labels", ".", "append", "(", "1", ")", "\n", "", "else", ":", "\n", "                                ", "negative_samples", ".", "extend", "(", "negative_sample", ")", "\n", "labels", ".", "extend", "(", "[", "1", "]", "*", "len", "(", "negative_sample", ")", ")", "\n", "\n", "", "", "", "", "batch_examples", "+=", "negative_samples", "\n", "\n", "", "train_iter", "+=", "1", "\n", "optimizer", ".", "zero_grad", "(", ")", "\n", "\n", "nll", "=", "-", "model", "(", "batch_examples", ")", "\n", "if", "train_paraphrase_model", ":", "\n", "                ", "idx_tensor", "=", "Variable", "(", "torch", ".", "LongTensor", "(", "labels", ")", ".", "unsqueeze", "(", "-", "1", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "args", ".", "cuda", ":", "idx_tensor", "=", "idx_tensor", ".", "cuda", "(", ")", "\n", "loss", "=", "torch", ".", "gather", "(", "nll", ",", "1", ",", "idx_tensor", ")", "\n", "", "else", ":", "\n", "                ", "loss", "=", "nll", "\n", "\n", "# print(loss.data)", "\n", "", "loss_val", "=", "torch", ".", "sum", "(", "loss", ")", ".", "data", ".", "item", "(", ")", "\n", "report_loss", "+=", "loss_val", "\n", "report_examples", "+=", "len", "(", "batch_examples", ")", "\n", "loss", "=", "torch", ".", "mean", "(", "loss", ")", "\n", "\n", "loss", ".", "backward", "(", ")", "\n", "\n", "# clip gradient", "\n", "grad_norm", "=", "torch", ".", "nn", ".", "utils", ".", "clip_grad_norm_", "(", "model", ".", "parameters", "(", ")", ",", "args", ".", "clip_grad", ")", "\n", "\n", "optimizer", ".", "step", "(", ")", "\n", "\n", "if", "train_iter", "%", "args", ".", "log_every", "==", "0", ":", "\n", "                ", "print", "(", "'[Iter %d] encoder loss=%.5f'", "%", "\n", "(", "train_iter", ",", "\n", "report_loss", "/", "report_examples", ")", ",", "\n", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "report_loss", "=", "report_examples", "=", "0.", "\n", "\n", "", "", "print", "(", "'[Epoch %d] epoch elapsed %ds'", "%", "(", "epoch", ",", "time", ".", "time", "(", ")", "-", "epoch_begin", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# perform validation", "\n", "print", "(", "'[Epoch %d] begin validation'", "%", "epoch", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "eval_start", "=", "time", ".", "time", "(", ")", "\n", "# evaluate dev_score", "\n", "dev_acc", "=", "evaluate_paraphrase_acc", "(", ")", "if", "train_paraphrase_model", "else", "-", "evaluate_ppl", "(", ")", "\n", "print", "(", "'[Epoch %d] dev_score=%.5f took %ds'", "%", "(", "epoch", ",", "dev_acc", ",", "time", ".", "time", "(", ")", "-", "eval_start", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "is_better", "=", "history_dev_scores", "==", "[", "]", "or", "dev_acc", ">", "max", "(", "history_dev_scores", ")", "\n", "history_dev_scores", ".", "append", "(", "dev_acc", ")", "\n", "\n", "if", "is_better", ":", "\n", "            ", "patience", "=", "0", "\n", "model_file", "=", "args", ".", "save_to", "+", "'.bin'", "\n", "print", "(", "'save currently the best model ..'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'save model to [%s]'", "%", "model_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "model", ".", "save", "(", "model_file", ")", "\n", "# also save the optimizers' state", "\n", "torch", ".", "save", "(", "optimizer", ".", "state_dict", "(", ")", ",", "args", ".", "save_to", "+", "'.optim.bin'", ")", "\n", "", "elif", "patience", "<", "args", ".", "patience", ":", "\n", "            ", "patience", "+=", "1", "\n", "print", "(", "'hit patience %d'", "%", "patience", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "", "if", "patience", "==", "args", ".", "patience", ":", "\n", "            ", "num_trial", "+=", "1", "\n", "print", "(", "'hit #%d trial'", "%", "num_trial", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "if", "num_trial", "==", "args", ".", "max_num_trial", ":", "\n", "                ", "print", "(", "'early stop!'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "exit", "(", "0", ")", "\n", "\n", "# decay lr, and restore from previously best checkpoint", "\n", "", "lr", "=", "optimizer", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", "*", "args", ".", "lr_decay", "\n", "print", "(", "'load previously best model and decay learning rate to %f'", "%", "lr", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "# load model", "\n", "params", "=", "torch", ".", "load", "(", "args", ".", "save_to", "+", "'.bin'", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "model", ".", "load_state_dict", "(", "params", "[", "'state_dict'", "]", ")", "\n", "if", "args", ".", "cuda", ":", "model", "=", "model", ".", "cuda", "(", ")", "\n", "\n", "# load optimizers", "\n", "if", "args", ".", "reset_optimizer", ":", "\n", "                ", "print", "(", "'reset optimizer'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "model", ".", "inference_model", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ")", "\n", "", "else", ":", "\n", "                ", "print", "(", "'restore parameters of the optimizers'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "optimizer", ".", "load_state_dict", "(", "torch", ".", "load", "(", "args", ".", "save_to", "+", "'.optim.bin'", ")", ")", "\n", "\n", "# set new lr", "\n", "", "for", "param_group", "in", "optimizer", ".", "param_groups", ":", "\n", "                ", "param_group", "[", "'lr'", "]", "=", "lr", "\n", "\n", "# reset patience", "\n", "", "patience", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.exp.test": [[459, 480], ["components.dataset.Dataset.from_bin_file", "print", "torch.load", "Registrable.by_name", "Registrable.by_name.load", "parser_cls.load.eval", "evaluation.evaluate", "print", "Registrable.by_name", "six.dump", "open"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.evaluation.evaluate", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name"], ["", "", "", "def", "test", "(", "args", ")", ":", "\n", "    ", "test_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "test_file", ")", "\n", "assert", "args", ".", "load_model", "\n", "\n", "print", "(", "'load model from [%s]'", "%", "args", ".", "load_model", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "params", "=", "torch", ".", "load", "(", "args", ".", "load_model", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "transition_system", "=", "params", "[", "'transition_system'", "]", "\n", "saved_args", "=", "params", "[", "'args'", "]", "\n", "saved_args", ".", "cuda", "=", "args", ".", "cuda", "\n", "# set the correct domain from saved arg", "\n", "args", ".", "lang", "=", "saved_args", ".", "lang", "\n", "\n", "parser_cls", "=", "Registrable", ".", "by_name", "(", "args", ".", "parser", ")", "\n", "parser", "=", "parser_cls", ".", "load", "(", "model_path", "=", "args", ".", "load_model", ",", "cuda", "=", "args", ".", "cuda", ")", "\n", "parser", ".", "eval", "(", ")", "\n", "evaluator", "=", "Registrable", ".", "by_name", "(", "args", ".", "evaluator", ")", "(", "transition_system", ",", "args", "=", "args", ")", "\n", "eval_results", ",", "decode_results", "=", "evaluation", ".", "evaluate", "(", "test_set", ".", "examples", ",", "parser", ",", "evaluator", ",", "args", ",", "\n", "verbose", "=", "args", ".", "verbose", ",", "return_decode_result", "=", "True", ")", "\n", "print", "(", "eval_results", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "if", "args", ".", "save_decode_to", ":", "\n", "        ", "pickle", ".", "dump", "(", "decode_results", ",", "open", "(", "args", ".", "save_decode_to", ",", "'wb'", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.exp.interactive_mode": [[482, 499], ["print", "components.standalone_parser.StandaloneParser", "six.moves.input().strip", "components.standalone_parser.StandaloneParser.parse", "enumerate", "print", "print", "six.moves.input"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse"], ["", "", "def", "interactive_mode", "(", "args", ")", ":", "\n", "    ", "\"\"\"Interactive mode\"\"\"", "\n", "print", "(", "'Start interactive mode'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "parser", "=", "StandaloneParser", "(", "args", ".", "parser", ",", "\n", "args", ".", "load_model", ",", "\n", "args", ".", "example_preprocessor", ",", "\n", "beam_size", "=", "args", ".", "beam_size", ",", "\n", "cuda", "=", "args", ".", "cuda", ")", "\n", "\n", "while", "True", ":", "\n", "        ", "utterance", "=", "input", "(", "'Query:'", ")", ".", "strip", "(", ")", "\n", "hypotheses", "=", "parser", ".", "parse", "(", "utterance", ",", "debug", "=", "True", ")", "\n", "\n", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hypotheses", ")", ":", "\n", "            ", "print", "(", "'------------------ Hypothesis %d ------------------'", "%", "hyp_id", ")", "\n", "print", "(", "hyp", ".", "code", ")", "\n", "# print(hyp.tree.to_string())", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.exp.train_reranker_and_test": [[505, 562], ["print", "components.dataset.Dataset.from_bin_file", "components.dataset.Dataset.from_bin_file", "next", "print", "six.load", "evaluator.evaluate_dataset", "print", "six.load", "evaluator.evaluate_dataset", "print", "print", "print", "print", "components.reranker.GridSearchReranker.compute_rerank_performance", "print", "print", "len", "Registrable.by_name", "print", "issubclass", "features.append", "Registrable.by_name", "open", "open", "components.reranker.GridSearchReranker.load", "components.reranker.GridSearchReranker", "os.path.join", "Registrable.by_name.load", "print", "Registrable.by_name.", "components.reranker.GridSearchReranker.train", "components.reranker.GridSearchReranker.train_multiprocess", "print", "components.reranker.GridSearchReranker.save", "hasattr"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.evaluate_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.evaluate_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.compute_rerank_performance", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.GridSearchReranker.train_multiprocess", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "", "", "def", "train_reranker_and_test", "(", "args", ")", ":", "\n", "    ", "print", "(", "'load dataset [test %s], [dev %s]'", "%", "(", "args", ".", "test_file", ",", "args", ".", "dev_file", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "test_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "test_file", ")", "\n", "dev_set", "=", "Dataset", ".", "from_bin_file", "(", "args", ".", "dev_file", ")", "\n", "\n", "features", "=", "[", "]", "\n", "i", "=", "0", "\n", "while", "i", "<", "len", "(", "args", ".", "features", ")", ":", "\n", "        ", "feat_name", "=", "args", ".", "features", "[", "i", "]", "\n", "feat_cls", "=", "Registrable", ".", "by_name", "(", "feat_name", ")", "\n", "print", "(", "'Add feature %s'", "%", "feat_name", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "if", "issubclass", "(", "feat_cls", ",", "nn", ".", "Module", ")", ":", "\n", "            ", "feat_path", "=", "os", ".", "path", ".", "join", "(", "'saved_models/conala/'", ",", "args", ".", "features", "[", "i", "]", "+", "'.bin'", ")", "\n", "feat_inst", "=", "feat_cls", ".", "load", "(", "feat_path", ")", "\n", "print", "(", "'Load feature %s from %s'", "%", "(", "feat_name", ",", "feat_path", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "else", ":", "\n", "            ", "feat_inst", "=", "feat_cls", "(", ")", "\n", "\n", "", "features", ".", "append", "(", "feat_inst", ")", "\n", "i", "+=", "1", "\n", "\n", "", "transition_system", "=", "next", "(", "feat", ".", "transition_system", "for", "feat", "in", "features", "if", "hasattr", "(", "feat", ",", "'transition_system'", ")", ")", "\n", "evaluator", "=", "Registrable", ".", "by_name", "(", "args", ".", "evaluator", ")", "(", "transition_system", ")", "\n", "\n", "\n", "print", "(", "'load dev decode results [%s]'", "%", "args", ".", "dev_decode_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "dev_decode_results", "=", "pickle", ".", "load", "(", "open", "(", "args", ".", "dev_decode_file", ",", "'rb'", ")", ")", "\n", "dev_eval_results", "=", "evaluator", ".", "evaluate_dataset", "(", "dev_set", ",", "dev_decode_results", ",", "fast_mode", "=", "False", ")", "\n", "\n", "print", "(", "'load test decode results [%s]'", "%", "args", ".", "test_decode_file", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "test_decode_results", "=", "pickle", ".", "load", "(", "open", "(", "args", ".", "test_decode_file", ",", "'rb'", ")", ")", "\n", "test_eval_results", "=", "evaluator", ".", "evaluate_dataset", "(", "test_set", ",", "test_decode_results", ",", "fast_mode", "=", "False", ")", "\n", "\n", "print", "(", "'Dev Eval Results'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "dev_eval_results", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'Test Eval Results'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "test_eval_results", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "if", "args", ".", "load_reranker", ":", "\n", "        ", "reranker", "=", "GridSearchReranker", ".", "load", "(", "args", ".", "load_reranker", ")", "\n", "", "else", ":", "\n", "        ", "reranker", "=", "GridSearchReranker", "(", "features", ",", "transition_system", "=", "transition_system", ")", "\n", "\n", "if", "args", ".", "num_workers", "==", "1", ":", "\n", "            ", "reranker", ".", "train", "(", "dev_set", ".", "examples", ",", "dev_decode_results", ",", "evaluator", "=", "evaluator", ")", "\n", "", "else", ":", "\n", "            ", "reranker", ".", "train_multiprocess", "(", "dev_set", ".", "examples", ",", "dev_decode_results", ",", "evaluator", "=", "evaluator", ",", "num_workers", "=", "args", ".", "num_workers", ")", "\n", "\n", "", "if", "args", ".", "save_to", ":", "\n", "            ", "print", "(", "'Save Reranker to %s'", "%", "args", ".", "save_to", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "reranker", ".", "save", "(", "args", ".", "save_to", ")", "\n", "\n", "", "", "test_score_with_rerank", "=", "reranker", ".", "compute_rerank_performance", "(", "test_set", ".", "examples", ",", "test_decode_results", ",", "verbose", "=", "True", ",", "\n", "evaluator", "=", "evaluator", ",", "args", "=", "args", ")", "\n", "\n", "print", "(", "'Test Eval Results After Reranking'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "test_score_with_rerank", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.evaluation.decode": [[9, 51], ["model.eval", "tqdm.tqdm", "print", "model.parse", "enumerate", "decode_results.append", "model.train", "len", "len", "model.transition_system.ast_to_surface_code", "decoded_hyps.append", "print", "print", "print", "traceback.print_exc", "print", "print", "print", "hyp.tree.to_string"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string"], ["def", "decode", "(", "examples", ",", "model", ",", "args", ",", "verbose", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "## TODO: create decoder for each dataset", "\n", "\n", "    ", "if", "verbose", ":", "\n", "        ", "print", "(", "'evaluating %d examples'", "%", "len", "(", "examples", ")", ")", "\n", "\n", "", "was_training", "=", "model", ".", "training", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "decode_results", "=", "[", "]", "\n", "count", "=", "0", "\n", "for", "example", "in", "tqdm", "(", "examples", ",", "desc", "=", "'Decoding'", ",", "file", "=", "sys", ".", "stdout", ",", "total", "=", "len", "(", "examples", ")", ")", ":", "\n", "        ", "hyps", "=", "model", ".", "parse", "(", "example", ".", "src_sent", ",", "context", "=", "None", ",", "beam_size", "=", "args", ".", "beam_size", ")", "\n", "decoded_hyps", "=", "[", "]", "\n", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyps", ")", ":", "\n", "            ", "got_code", "=", "False", "\n", "try", ":", "\n", "                ", "hyp", ".", "code", "=", "model", ".", "transition_system", ".", "ast_to_surface_code", "(", "hyp", ".", "tree", ")", "\n", "got_code", "=", "True", "\n", "decoded_hyps", ".", "append", "(", "hyp", ")", "\n", "", "except", ":", "\n", "                ", "if", "verbose", ":", "\n", "                    ", "print", "(", "\"Exception in converting tree to code:\"", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'Example: %s\\nIntent: %s\\nTarget Code:\\n%s\\nHypothesis[%d]:\\n%s'", "%", "(", "example", ".", "idx", ",", "\n", "' '", ".", "join", "(", "example", ".", "src_sent", ")", ",", "\n", "example", ".", "tgt_code", ",", "\n", "hyp_id", ",", "\n", "hyp", ".", "tree", ".", "to_string", "(", ")", ")", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "if", "got_code", ":", "\n", "                        ", "print", "(", ")", "\n", "print", "(", "hyp", ".", "code", ")", "\n", "", "traceback", ".", "print_exc", "(", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "\n", "", "", "", "count", "+=", "1", "\n", "\n", "decode_results", ".", "append", "(", "decoded_hyps", ")", "\n", "\n", "", "if", "was_training", ":", "model", ".", "train", "(", ")", "\n", "\n", "return", "decode_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.None.evaluation.evaluate": [[53, 62], ["evaluation.decode", "evaluator.evaluate_dataset"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.evaluate_dataset"], ["", "def", "evaluate", "(", "examples", ",", "parser", ",", "evaluator", ",", "args", ",", "verbose", "=", "False", ",", "return_decode_result", "=", "False", ",", "eval_top_pred_only", "=", "False", ")", ":", "\n", "    ", "decode_results", "=", "decode", "(", "examples", ",", "parser", ",", "args", ",", "verbose", "=", "verbose", ")", "\n", "\n", "eval_result", "=", "evaluator", ".", "evaluate_dataset", "(", "examples", ",", "decode_results", ",", "fast_mode", "=", "eval_top_pred_only", ",", "args", "=", "args", ")", "\n", "\n", "if", "return_decode_result", ":", "\n", "        ", "return", "eval_result", ",", "decode_results", "\n", "", "else", ":", "\n", "        ", "return", "eval_result", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.action_info.ActionInfo.__init__": [[9, 19], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "action", "=", "None", ")", ":", "\n", "        ", "self", ".", "t", "=", "0", "\n", "self", ".", "parent_t", "=", "-", "1", "\n", "self", ".", "action", "=", "action", "\n", "self", ".", "frontier_prod", "=", "None", "\n", "self", ".", "frontier_field", "=", "None", "\n", "\n", "# for GenToken actions only", "\n", "self", ".", "copy_from_src", "=", "False", "\n", "self", ".", "src_token_position", "=", "-", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.action_info.ActionInfo.__repr__": [[20, 40], ["isinstance", "repr", "action_info.ActionInfo.frontier_field.__repr__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__"], ["", "def", "__repr__", "(", "self", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "repr_str", "=", "'%s (t=%d, p_t=%d, frontier_field=%s)'", "%", "(", "repr", "(", "self", ".", "action", ")", ",", "\n", "self", ".", "t", ",", "\n", "self", ".", "parent_t", ",", "\n", "self", ".", "frontier_field", ".", "__repr__", "(", "True", ")", "if", "self", ".", "frontier_field", "else", "'None'", ")", "\n", "\n", "if", "verbose", ":", "\n", "            ", "verbose_repr", "=", "'action_prob=%.4f, '", "%", "self", ".", "action_prob", "\n", "if", "isinstance", "(", "self", ".", "action", ",", "GenTokenAction", ")", ":", "\n", "                ", "verbose_repr", "+=", "'in_vocab=%s, '", "'gen_copy_switch=%s, '", "'p(gen)=%s, p(copy)=%s, '", "'has_copy=%s, copy_pos=%s'", "%", "(", "self", ".", "in_vocab", ",", "\n", "self", ".", "gen_copy_switch", ",", "\n", "self", ".", "gen_token_prob", ",", "self", ".", "copy_token_prob", ",", "\n", "self", ".", "copy_from_src", ",", "self", ".", "src_token_position", ")", "\n", "\n", "", "repr_str", "+=", "'\\n'", "+", "verbose_repr", "\n", "\n", "", "return", "repr_str", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.action_info.get_action_infos": [[42, 65], ["asdl.hypothesis.Hypothesis", "enumerate", "action_info.ActionInfo", "isinstance", "asdl.hypothesis.Hypothesis.apply_action", "action_infos.append", "src_query.index", "str", "ValueError"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.apply_action"], ["", "", "def", "get_action_infos", "(", "src_query", ",", "tgt_actions", ",", "force_copy", "=", "False", ")", ":", "\n", "    ", "action_infos", "=", "[", "]", "\n", "hyp", "=", "Hypothesis", "(", ")", "\n", "for", "t", ",", "action", "in", "enumerate", "(", "tgt_actions", ")", ":", "\n", "        ", "action_info", "=", "ActionInfo", "(", "action", ")", "\n", "action_info", ".", "t", "=", "t", "\n", "if", "hyp", ".", "frontier_node", ":", "\n", "            ", "action_info", ".", "parent_t", "=", "hyp", ".", "frontier_node", ".", "created_time", "\n", "action_info", ".", "frontier_prod", "=", "hyp", ".", "frontier_node", ".", "production", "\n", "action_info", ".", "frontier_field", "=", "hyp", ".", "frontier_field", ".", "field", "\n", "\n", "", "if", "isinstance", "(", "action", ",", "GenTokenAction", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "tok_src_idx", "=", "src_query", ".", "index", "(", "str", "(", "action", ".", "token", ")", ")", "\n", "action_info", ".", "copy_from_src", "=", "True", "\n", "action_info", ".", "src_token_position", "=", "tok_src_idx", "\n", "", "except", "ValueError", ":", "\n", "                ", "if", "force_copy", ":", "raise", "ValueError", "(", "'cannot copy primitive token %s from source'", "%", "action", ".", "token", ")", "\n", "\n", "", "", "hyp", ".", "apply_action", "(", "action", ")", "\n", "action_infos", ".", "append", "(", "action_info", ")", "\n", "\n", "", "return", "action_infos", "\n", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.standalone_parser.StandaloneParser.__init__": [[26, 35], ["print", "common.registerable.Registrable.by_name().load().eval", "components.reranker.GridSearchReranker.load", "common.registerable.Registrable.by_name", "common.registerable.Registrable.by_name().load", "common.registerable.Registrable.by_name"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name"], ["def", "__init__", "(", "self", ",", "parser_name", ",", "model_path", ",", "example_processor_name", ",", "beam_size", "=", "5", ",", "reranker_path", "=", "None", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "print", "(", "'load parser from [%s]'", "%", "model_path", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "self", ".", "parser", "=", "parser", "=", "Registrable", ".", "by_name", "(", "parser_name", ")", ".", "load", "(", "model_path", ",", "cuda", "=", "cuda", ")", ".", "eval", "(", ")", "\n", "self", ".", "reranker", "=", "None", "\n", "if", "reranker_path", ":", "\n", "            ", "self", ".", "reranker", "=", "GridSearchReranker", ".", "load", "(", "reranker_path", ")", "\n", "", "self", ".", "example_processor", "=", "Registrable", ".", "by_name", "(", "example_processor_name", ")", "(", "parser", ".", "transition_system", ")", "\n", "self", ".", "beam_size", "=", "beam_size", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.standalone_parser.StandaloneParser.parse": [[36, 65], ["utterance.strip.strip.strip", "standalone_parser.StandaloneParser.example_processor.pre_process_utterance", "print", "print", "standalone_parser.StandaloneParser.parser.parse", "list", "enumerate", "components.dataset.Example", "standalone_parser.StandaloneParser.decode_tree_to_code", "filter", "standalone_parser.StandaloneParser.example_processor.post_process_hypothesis", "print", "print", "print", "print", "standalone_parser.StandaloneParser.reranker.rerank_hypotheses", "hyp.tree.to_string", "print", "standalone_parser.StandaloneParser.parser.transition_system.is_valid_hypothesis"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.example_processor.ConalaExampleProcessor.pre_process_utterance", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.standalone_parser.StandaloneParser.decode_tree_to_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.example_processor.ConalaExampleProcessor.post_process_hypothesis", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.rerank_hypotheses", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.is_valid_hypothesis"], ["", "def", "parse", "(", "self", ",", "utterance", ",", "debug", "=", "False", ")", ":", "\n", "        ", "utterance", "=", "utterance", ".", "strip", "(", ")", "\n", "processed_utterance_tokens", ",", "utterance_meta", "=", "self", ".", "example_processor", ".", "pre_process_utterance", "(", "utterance", ")", "\n", "print", "(", "processed_utterance_tokens", ")", "\n", "print", "(", "utterance_meta", ")", "\n", "examples", "=", "[", "Example", "(", "idx", "=", "None", ",", "\n", "src_sent", "=", "processed_utterance_tokens", ",", "\n", "tgt_code", "=", "None", ",", "\n", "tgt_actions", "=", "None", ",", "\n", "tgt_ast", "=", "None", ")", "]", "\n", "hypotheses", "=", "self", ".", "parser", ".", "parse", "(", "processed_utterance_tokens", ",", "beam_size", "=", "self", ".", "beam_size", ",", "debug", "=", "debug", ")", "\n", "\n", "if", "self", ".", "reranker", ":", "\n", "            ", "hypotheses", "=", "self", ".", "decode_tree_to_code", "(", "hypotheses", ")", "\n", "hypotheses", "=", "self", ".", "reranker", ".", "rerank_hypotheses", "(", "examples", ",", "[", "hypotheses", "]", ")", "[", "0", "]", "\n", "\n", "", "valid_hypotheses", "=", "list", "(", "filter", "(", "lambda", "hyp", ":", "self", ".", "parser", ".", "transition_system", ".", "is_valid_hypothesis", "(", "hyp", ")", ",", "hypotheses", ")", ")", "\n", "for", "hyp", "in", "valid_hypotheses", ":", "\n", "            ", "self", ".", "example_processor", ".", "post_process_hypothesis", "(", "hyp", ",", "utterance_meta", ")", "\n", "\n", "", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "valid_hypotheses", ")", ":", "\n", "            ", "print", "(", "'------------------ Hypothesis %d ------------------'", "%", "hyp_id", ")", "\n", "print", "(", "hyp", ".", "code", ")", "\n", "print", "(", "hyp", ".", "tree", ".", "to_string", "(", ")", ")", "\n", "print", "(", "'Actions:'", ")", "\n", "for", "action_t", "in", "hyp", ".", "action_infos", ":", "\n", "                ", "print", "(", "action_t", ".", "action", ")", "\n", "\n", "", "", "return", "valid_hypotheses", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.standalone_parser.StandaloneParser.decode_tree_to_code": [[66, 75], ["enumerate", "standalone_parser.StandaloneParser.parser.transition_system.ast_to_surface_code", "decoded_hyps.append"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code"], ["", "def", "decode_tree_to_code", "(", "self", ",", "hyps", ")", ":", "\n", "        ", "decoded_hyps", "=", "[", "]", "\n", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyps", ")", ":", "\n", "            ", "try", ":", "\n", "                ", "hyp", ".", "code", "=", "self", ".", "parser", ".", "transition_system", ".", "ast_to_surface_code", "(", "hyp", ".", "tree", ")", "\n", "decoded_hyps", ".", "append", "(", "hyp", ")", "\n", "", "except", ":", "\n", "                ", "pass", "\n", "", "", "return", "decoded_hyps", "", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.RerankingFeature.feature_name": [[58, 61], ["None"], "methods", ["None"], ["    ", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.RerankingFeature.is_batched": [[62, 65], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.RerankingFeature.get_feat_value": [[66, 68], ["None"], "methods", ["None"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.ParserScore.feature_name": [[72, 75], ["None"], "methods", ["None"], ["    ", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'parser_score'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.ParserScore.is_batched": [[76, 79], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.ParserScore.get_feat_value": [[80, 82], ["float", "len"], "methods", ["None"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "float", "(", "hyp", ".", "score", ")", "*", "len", "(", "hyp", ".", "actions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScoreByAction.__init__": [[86, 88], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScoreByAction.feature_name": [[89, 92], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'normalized_parser_score'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScoreByAction.is_batched": [[93, 96], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScoreByAction.get_feat_value": [[97, 100], ["float"], "methods", ["None"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "# return float(hyp.score) / len(kwargs['transition_system'].tokenize_code(hyp.code))", "\n", "        ", "return", "float", "(", "hyp", ".", "score", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScore.__init__": [[104, 106], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScore.feature_name": [[107, 110], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'normalized_parser_score'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScore.is_batched": [[111, 114], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.NormalizedParserScore.get_feat_value": [[115, 117], ["reranker.HypCodeTokensCount.get_feat_value", "float", "len", "reranker.HypCodeTokensCount"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.get_feat_value"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "float", "(", "hyp", ".", "score", ")", "*", "len", "(", "hyp", ".", "actions", ")", "/", "HypCodeTokensCount", "(", ")", ".", "get_feat_value", "(", "example", ",", "hyp", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.HypCodeTokensCount.feature_name": [[121, 124], ["None"], "methods", ["None"], ["    ", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'word_cnt'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.HypCodeTokensCount.is_batched": [[125, 128], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.HypCodeTokensCount.get_feat_value": [[129, 146], ["hasattr", "len", "float", "kwargs[].tokenize_code", "len", "isinstance", "re.sub().strip().split", "list", "float", "c.replace().replace().replace", "filter", "len", "kwargs[].tokenize_code", "re.sub().strip", "c.replace().replace", "re.sub", "len", "c.replace"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "# TODO: this is dataset specific, we should fix it", "\n", "        ", "if", "hasattr", "(", "hyp", ",", "'decanonical_code_tokens'", ")", ":", "\n", "# we use the tokenization for BLEU calculation", "\n", "            ", "code_tokens", "=", "[", "'#NEWLINE#'", "if", "c", "==", "'\\n'", "else", "c", "for", "c", "in", "hyp", ".", "decanonical_code_tokens", "]", "\n", "return", "float", "(", "len", "(", "code_tokens", ")", ")", "\n", "# else:", "\n", "#     return len(hyp.actions)", "\n", "", "elif", "six", ".", "PY2", "and", "isinstance", "(", "kwargs", "[", "'transition_system'", "]", ",", "PythonTransitionSystem", ")", ":", "\n", "            ", "code_tokens", "=", "[", "c", ".", "replace", "(", "'\\r\\n'", ",", "'#NEWLINE#'", ")", ".", "replace", "(", "'\\r'", ",", "'#NEWLINE#'", ")", ".", "replace", "(", "'\\n'", ",", "'#NEWLINE#'", ")", "\n", "for", "c", "in", "kwargs", "[", "'transition_system'", "]", ".", "tokenize_code", "(", "hyp", ".", "code", ")", "]", "\n", "# remove consecutive spaces", "\n", "code_tokens", "=", "re", ".", "sub", "(", "r'\\s+'", ",", "' '", ",", "' '", ".", "join", "(", "code_tokens", ")", ")", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "code_tokens", "=", "list", "(", "filter", "(", "lambda", "x", ":", "len", "(", "x", ")", ">", "0", ",", "code_tokens", ")", ")", "\n", "return", "float", "(", "len", "(", "code_tokens", ")", ")", "\n", "\n", "", "return", "len", "(", "kwargs", "[", "'transition_system'", "]", ".", "tokenize_code", "(", "hyp", ".", "code", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndScoreMargin.__init__": [[150, 152], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndScoreMargin.feature_name": [[153, 156], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'is_2nd_hyp_and_margin_with_top_hyp'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndScoreMargin.is_batched": [[157, 160], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndScoreMargin.get_feat_value": [[161, 165], ["None"], "methods", ["None"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "kwargs", "[", "'hyp_id'", "]", "==", "1", ":", "\n", "            ", "return", "kwargs", "[", "'all_hyps'", "]", "[", "0", "]", ".", "score", "-", "hyp", ".", "score", "\n", "", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.__init__": [[169, 171], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.feature_name": [[172, 175], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'is_2nd_hyp_and_paraphrase_score_margin_with_top_hyp'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.is_batched": [[176, 179], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.get_feat_value": [[180, 184], ["None"], "methods", ["None"], ["", "def", "get_feat_value", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "if", "kwargs", "[", "'hyp_id'", "]", "==", "1", ":", "\n", "            ", "return", "hyp", ".", "rerank_feature_values", "[", "'paraphrase_score'", "]", "-", "kwargs", "[", "'all_hyps'", "]", "[", "0", "]", ".", "rerank_feature_values", "[", "'paraphrase_score'", "]", "\n", "", "return", "0.", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.__init__": [[188, 201], ["collections.OrderedDict", "collections.OrderedDict", "reranker.Reranker._add_feature", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker._add_feature"], ["    ", "def", "__init__", "(", "self", ",", "features", ",", "parameter", "=", "None", ",", "transition_system", "=", "None", ")", ":", "\n", "        ", "self", ".", "features", "=", "[", "]", "\n", "self", ".", "transition_system", "=", "transition_system", "\n", "self", ".", "feat_map", "=", "OrderedDict", "(", ")", "\n", "self", ".", "batched_features", "=", "OrderedDict", "(", ")", "\n", "\n", "for", "feat", "in", "features", ":", "\n", "            ", "self", ".", "_add_feature", "(", "feat", ")", "\n", "\n", "", "if", "parameter", "is", "not", "None", ":", "\n", "            ", "self", ".", "parameter", "=", "parameter", "\n", "", "else", ":", "\n", "            ", "self", ".", "parameter", "=", "np", ".", "zeros", "(", "self", ".", "feature_num", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker._add_feature": [[202, 208], ["reranker.Reranker.features.append"], "methods", ["None"], ["", "", "def", "_add_feature", "(", "self", ",", "feature", ")", ":", "\n", "        ", "self", ".", "features", ".", "append", "(", "feature", ")", "\n", "self", ".", "feat_map", "[", "feature", ".", "feature_name", "]", "=", "feature", "\n", "\n", "if", "feature", ".", "is_batched", ":", "\n", "            ", "self", ".", "batched_features", "[", "feature", ".", "feature_name", "]", "=", "feature", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.get_initial_reranking_feature_values": [[209, 221], ["collections.OrderedDict", "reranker.Reranker.feat_map.items", "feat.get_feat_value", "float"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.get_feat_value"], ["", "", "def", "get_initial_reranking_feature_values", "(", "self", ",", "example", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Given a hypothesis, compute its reranking feature\"\"\"", "\n", "feat_values", "=", "OrderedDict", "(", ")", "\n", "for", "feat_name", ",", "feat", "in", "self", ".", "feat_map", ".", "items", "(", ")", ":", "\n", "            ", "if", "not", "feat", ".", "is_batched", ":", "\n", "                ", "feat_val", "=", "feat", ".", "get_feat_value", "(", "example", ",", "hyp", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "                ", "feat_val", "=", "float", "(", "'inf'", ")", "\n", "\n", "", "feat_values", "[", "feat_name", "]", "=", "feat_val", "\n", "\n", "", "return", "feat_values", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.rerank_hypotheses": [[222, 245], ["reranker.Reranker.filter_hyps_and_initialize_features", "zip", "zip", "sorted_decode_results.append", "reranker.Reranker.get_rerank_score", "numpy.argmax", "sorted_decode_results.append", "sorted_decode_results.append", "numpy.argsort"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.filter_hyps_and_initialize_features", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_rerank_score"], ["", "def", "rerank_hypotheses", "(", "self", ",", "examples", ",", "decode_results", ",", "fast_mode", "=", "False", ")", ":", "\n", "        ", "\"\"\"rerank the hypotheses using the current model parameter\"\"\"", "\n", "self", ".", "filter_hyps_and_initialize_features", "(", "examples", ",", "decode_results", ")", "\n", "\n", "param", "=", "self", ".", "parameter", "\n", "\n", "sorted_decode_results", "=", "[", "]", "\n", "for", "example", ",", "hyps", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "if", "hyps", ":", "\n", "                ", "new_hyp_scores", "=", "[", "self", ".", "get_rerank_score", "(", "hyp", ",", "param", "=", "param", ")", "for", "hyp", "in", "hyps", "]", "\n", "for", "score", ",", "hyp", "in", "zip", "(", "new_hyp_scores", ",", "hyps", ")", ":", "\n", "                    ", "hyp", ".", "rerank_score", "=", "score", "\n", "\n", "", "if", "fast_mode", ":", "\n", "                    ", "best_hyp_idx", "=", "np", ".", "argmax", "(", "new_hyp_scores", ")", "\n", "best_hyp", "=", "hyps", "[", "best_hyp_idx", "]", "\n", "sorted_decode_results", ".", "append", "(", "[", "best_hyp", "]", ")", "\n", "", "else", ":", "\n", "                    ", "sorted_decode_results", ".", "append", "(", "[", "hyps", "[", "i", "]", "for", "i", "in", "np", ".", "argsort", "(", "new_hyp_scores", ")", "[", ":", ":", "-", "1", "]", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "sorted_decode_results", ".", "append", "(", "[", "]", ")", "\n", "\n", "", "", "return", "sorted_decode_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.initialize_rerank_features": [[246, 284], ["print", "zip", "model.utils.batch_iter", "zip", "zip", "enumerate", "reranker.Reranker.batched_features.items", "enumerate", "components.dataset.Example", "hyp_examples.append", "collections.OrderedDict", "feat.score().data.cpu().tolist", "enumerate", "reranker.Reranker.batched_features.items", "reranker.Reranker.feat_map.items", "setattr", "getattr", "feat.score().data.cpu", "feat.get_feat_value", "feat.score"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.batch_iter", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.IsSecondHypAndParaphraseScoreMargin.get_feat_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.score"], ["", "def", "initialize_rerank_features", "(", "self", ",", "examples", ",", "decode_results", ")", ":", "\n", "        ", "hyp_examples", "=", "[", "]", "\n", "print", "(", "'initializing features...'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "for", "example", ",", "hyps", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyps", ")", ":", "\n", "                ", "hyp_example", "=", "Example", "(", "idx", "=", "None", ",", "\n", "src_sent", "=", "example", ".", "src_sent", ",", "\n", "tgt_code", "=", "hyp", ".", "code", ",", "\n", "tgt_actions", "=", "None", ",", "\n", "tgt_ast", "=", "None", ")", "\n", "hyp_examples", ".", "append", "(", "hyp_example", ")", "\n", "# hyp.tokenized_code = len(self.transition_system.tokenize_code(hyp.code))", "\n", "# hyp.code_token_count = len(hyp.code.split(' '))", "\n", "\n", "feat_vals", "=", "OrderedDict", "(", ")", "\n", "hyp", ".", "rerank_feature_values", "=", "feat_vals", "\n", "\n", "", "", "for", "batch_examples", "in", "utils", ".", "batch_iter", "(", "hyp_examples", ",", "batch_size", "=", "128", ")", ":", "\n", "            ", "for", "feat_name", ",", "feat", "in", "self", ".", "batched_features", ".", "items", "(", ")", ":", "\n", "                ", "batch_example_scores", "=", "feat", ".", "score", "(", "batch_examples", ")", ".", "data", ".", "cpu", "(", ")", ".", "tolist", "(", ")", "\n", "for", "i", ",", "e", "in", "enumerate", "(", "batch_examples", ")", ":", "\n", "                    ", "setattr", "(", "e", ",", "feat_name", ",", "batch_example_scores", "[", "i", "]", ")", "\n", "\n", "", "", "", "e_ptr", "=", "0", "\n", "for", "example", ",", "hyps", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "for", "hyp", "in", "hyps", ":", "\n", "                ", "for", "feat_name", ",", "feat", "in", "self", ".", "batched_features", ".", "items", "(", ")", ":", "\n", "                    ", "hyp", ".", "rerank_feature_values", "[", "feat_name", "]", "=", "getattr", "(", "hyp_examples", "[", "e_ptr", "]", ",", "feat_name", ")", "\n", "", "e_ptr", "+=", "1", "\n", "\n", "", "", "for", "example", ",", "hyps", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyps", ")", ":", "\n", "                ", "for", "feat_name", ",", "feat", "in", "self", ".", "feat_map", ".", "items", "(", ")", ":", "\n", "                    ", "if", "not", "feat", ".", "is_batched", ":", "\n", "                        ", "feat_val", "=", "feat", ".", "get_feat_value", "(", "example", ",", "hyp", ",", "\n", "hyp_id", "=", "hyp_id", ",", "all_hyps", "=", "hyps", ",", "\n", "transition_system", "=", "self", ".", "transition_system", ")", "\n", "hyp", ".", "rerank_feature_values", "[", "feat_name", "]", "=", "feat_val", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.get_rerank_score": [[285, 287], ["None"], "methods", ["None"], ["", "", "", "", "", "def", "get_rerank_score", "(", "self", ",", "hyp", ",", "param", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker._filter_hyps": [[288, 296], ["range", "len", "reranker.Reranker.filter_hyps_and_initialize_features.is_valid_hyp", "valid_hyps.append"], "methods", ["None"], ["", "def", "_filter_hyps", "(", "self", ",", "decode_results", ",", "is_valid_hyp", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "decode_results", ")", ")", ":", "\n", "            ", "valid_hyps", "=", "[", "]", "\n", "for", "hyp", "in", "decode_results", "[", "i", "]", ":", "\n", "                ", "if", "is_valid_hyp", "(", "hyp", ")", ":", "\n", "                    ", "valid_hyps", ".", "append", "(", "hyp", ")", "\n", "\n", "", "", "decode_results", "[", "i", "]", "=", "valid_hyps", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.filter_hyps_and_initialize_features": [[297, 315], ["print", "hasattr", "print", "reranker.Reranker._filter_hyps", "reranker.Reranker.initialize_rerank_features", "reranker.Reranker.transition_system.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker._filter_hyps", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.initialize_rerank_features", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "", "def", "filter_hyps_and_initialize_features", "(", "self", ",", "examples", ",", "decode_results", ")", ":", "\n", "        ", "print", "(", "decode_results", "[", "0", "]", "[", "0", "]", ".", "code", ")", "\n", "if", "not", "hasattr", "(", "decode_results", "[", "0", "]", "[", "0", "]", ",", "'rerank_feature_values'", ")", ":", "\n", "            ", "print", "(", "'initializing rerank features for hypotheses...'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "def", "is_valid_hyp", "(", "hyp", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "self", ".", "transition_system", ".", "tokenize_code", "(", "hyp", ".", "code", ")", "\n", "if", "hyp", ".", "code", ":", "\n", "                        ", "return", "True", "\n", "", "", "except", ":", "\n", "                    ", "return", "False", "\n", "\n", "", "return", "False", "\n", "\n", "", "self", ".", "_filter_hyps", "(", "decode_results", ",", "is_valid_hyp", ")", "\n", "\n", "self", ".", "initialize_rerank_features", "(", "examples", ",", "decode_results", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.compute_rerank_performance": [[316, 355], ["components.evaluator.CachedExactMatchEvaluator", "reranker.Reranker.filter_hyps_and_initialize_features", "zip", "datasets.conala.evaluator.evaluate_dataset", "numpy.argmax", "sorted_decode_results.append", "reranker.Reranker.get_rerank_score", "sorted_decode_results.append", "sorted_decode_results.append", "print", "print", "enumerate", "enumerate", "print", "print", "numpy.argsort", "reranker.Reranker.get_rerank_score"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.filter_hyps_and_initialize_features", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.evaluate_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_rerank_score", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_rerank_score"], ["", "", "def", "compute_rerank_performance", "(", "self", ",", "examples", ",", "decode_results", ",", "evaluator", "=", "CachedExactMatchEvaluator", "(", ")", ",", "\n", "param", "=", "None", ",", "fast_mode", "=", "False", ",", "verbose", "=", "False", ",", "args", "=", "None", ")", ":", "\n", "        ", "self", ".", "filter_hyps_and_initialize_features", "(", "examples", ",", "decode_results", ")", "\n", "\n", "if", "param", "is", "None", ":", "\n", "            ", "param", "=", "self", ".", "parameter", "\n", "\n", "", "sorted_decode_results", "=", "[", "]", "\n", "for", "example", ",", "hyps", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "if", "hyps", ":", "\n", "                ", "new_hyp_scores", "=", "[", "self", ".", "get_rerank_score", "(", "hyp", ",", "param", "=", "param", ")", "for", "hyp", "in", "hyps", "]", "\n", "best_hyp_idx", "=", "np", ".", "argmax", "(", "new_hyp_scores", ")", "\n", "best_hyp", "=", "hyps", "[", "best_hyp_idx", "]", "\n", "\n", "if", "fast_mode", ":", "\n", "                    ", "sorted_decode_results", ".", "append", "(", "[", "best_hyp", "]", ")", "\n", "", "else", ":", "\n", "                    ", "sorted_decode_results", ".", "append", "(", "[", "hyps", "[", "i", "]", "for", "i", "in", "np", ".", "argsort", "(", "new_hyp_scores", ")", "[", ":", ":", "-", "1", "]", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "sorted_decode_results", ".", "append", "(", "[", "]", ")", "\n", "\n", "", "if", "verbose", ":", "\n", "                ", "gold_standard_idx", "=", "[", "i", "for", "i", ",", "hyp", "in", "enumerate", "(", "hyps", ")", "if", "hyp", ".", "is_correct", "]", "\n", "if", "gold_standard_idx", "and", "gold_standard_idx", "[", "0", "]", "!=", "best_hyp_idx", ":", "\n", "                    ", "gold_standard_idx", "=", "gold_standard_idx", "[", "0", "]", "\n", "print", "(", "'Utterance: %s'", "%", "' '", ".", "join", "(", "example", ".", "src_sent", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'Gold hyp id: %d'", "%", "gold_standard_idx", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "for", "_i", ",", "hyp", "in", "enumerate", "(", "hyps", ")", ":", "\n", "                        ", "print", "(", "'Hyp %d: %s ||| score: %f ||| final score: %f'", "%", "(", "_i", ",", "\n", "hyp", ".", "code", ",", "\n", "hyp", ".", "score", ",", "\n", "self", ".", "get_rerank_score", "(", "hyp", ",", "param", "=", "param", ")", ")", ",", "\n", "file", "=", "sys", ".", "stderr", ")", "\n", "print", "(", "'\\t%s'", "%", "hyp", ".", "rerank_feature_values", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "\n", "", "", "", "", "metric", "=", "evaluator", ".", "evaluate_dataset", "(", "examples", ",", "sorted_decode_results", ",", "fast_mode", "=", "fast_mode", ",", "args", "=", "args", ")", "\n", "\n", "return", "metric", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.train": [[357, 359], ["None"], "methods", ["None"], ["", "def", "train", "(", "self", ",", "examples", ",", "decode_results", ",", "initial_performance", "=", "0.", ",", "metric", "=", "'accuracy'", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.feature_num": [[360, 363], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_num", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.__getattr__": [[364, 368], ["reranker.Reranker.feat_map.get"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "item", ")", ":", "\n", "        ", "if", "item", "in", "self", ".", "feat_map", ":", "\n", "            ", "return", "self", ".", "feat_map", ".", "get", "(", "item", ")", "\n", "", "raise", "ValueError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.save": [[369, 387], ["os.path.dirname", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.exists", "os.makedirs", "isinstance", "feature_names.append", "feat.save", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "dirname", "(", "path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_name", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_name", ")", "\n", "\n", "", "feature_names", "=", "[", "]", "\n", "for", "feat", "in", "self", ".", "features", ":", "\n", "            ", "if", "isinstance", "(", "feat", ",", "nn", ".", "Module", ")", ":", "\n", "                ", "feat", ".", "save", "(", "os", ".", "path", ".", "join", "(", "path", "+", "'.%s'", "%", "feat", ".", "feature_name", ")", ")", "\n", "", "feature_names", ".", "append", "(", "feat", ".", "feature_name", ")", "\n", "\n", "", "params", "=", "{", "\n", "'parameter'", ":", "self", ".", "parameter", ",", "\n", "'feature_names'", ":", "feature_names", ",", "\n", "'transition_system'", ":", "self", ".", "transition_system", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "params", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.load": [[388, 406], ["print", "torch.load", "torch.load", "torch.load", "torch.load", "cls", "issubclass", "features.append", "feat_cls.load", "feat_cls.eval", "feat_cls"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval"], ["", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "model_path", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "print", "(", "\"loading reranker...\"", ")", "\n", "params", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "feature_names", "=", "params", "[", "'feature_names'", "]", "\n", "features", "=", "[", "]", "\n", "for", "feat_name", "in", "feature_names", ":", "\n", "            ", "feat_cls", "=", "Registrable", ".", "registered_components", "[", "feat_name", "]", "\n", "if", "issubclass", "(", "feat_cls", ",", "Savable", ")", ":", "\n", "                ", "feat_inst", "=", "feat_cls", ".", "load", "(", "model_path", "+", "'.%s'", "%", "feat_name", ",", "cuda", "=", "cuda", ")", "\n", "feat_inst", ".", "eval", "(", ")", "\n", "", "else", ":", "\n", "                ", "feat_inst", "=", "feat_cls", "(", ")", "\n", "", "features", ".", "append", "(", "feat_inst", ")", "\n", "\n", "", "reranker", "=", "cls", "(", "features", ",", "params", "[", "'parameter'", "]", ",", "params", "[", "'transition_system'", "]", ")", "\n", "\n", "return", "reranker", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.LinearReranker.get_rerank_score": [[411, 418], ["sum", "param.items"], "methods", ["None"], ["def", "get_rerank_score", "(", "self", ",", "hyp", ",", "param", "=", "None", ")", ":", "\n", "        ", "if", "param", "is", "None", ":", "\n", "            ", "param", "=", "self", ".", "parameter", "\n", "\n", "", "score", "=", "sum", "(", "feat_weight", "*", "hyp", ".", "rerank_feature_values", "[", "feat_name", "]", "for", "feat_name", ",", "feat_weight", "in", "param", ".", "items", "(", ")", ")", "\n", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.LinearReranker.generate_nbest_list": [[419, 459], ["open", "open", "open", "reranker.LinearReranker.filter_hyps_and_initialize_features", "enumerate", "open.close", "open.close", "open.close", "zip", "open.write", "open.write", "range", "open.write", "len", "hyp_tokenizer", "reranker.LinearReranker.parameter.keys", "open.write", "target_tokenizer"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.filter_hyps_and_initialize_features"], ["", "def", "generate_nbest_list", "(", "self", ",", "examples", ",", "decode_results", ",", "nbest_file_name", ",", "target_tokenizer", ",", "hyp_tokenizer", ")", ":", "\n", "        ", "f_src", "=", "open", "(", "nbest_file_name", "+", "'.src'", ",", "'w'", ")", "\n", "f_tgt", "=", "open", "(", "nbest_file_name", "+", "'.tgt'", ",", "'w'", ")", "\n", "f_hyp", "=", "open", "(", "nbest_file_name", "+", "'.hyp'", ",", "'w'", ")", "\n", "\n", "self", ".", "filter_hyps_and_initialize_features", "(", "examples", ",", "decode_results", ")", "\n", "\n", "for", "e_id", ",", "(", "example", ",", "hyp_list", ")", "in", "enumerate", "(", "zip", "(", "examples", ",", "decode_results", ")", ")", ":", "\n", "            ", "f_src", ".", "write", "(", "' '", ".", "join", "(", "example", ".", "src_sent", ")", "+", "'\\n'", ")", "\n", "f_tgt", ".", "write", "(", "' '", ".", "join", "(", "target_tokenizer", "(", "example", ")", ")", "+", "'\\n'", ")", "\n", "\n", "if", "not", "hyp_list", ":", "\n", "                ", "hyp_str", "=", "\"{e_id} ||| pass ||| 0. |||\"", ".", "format", "(", "e_id", "=", "e_id", ")", "\n", "for", "feat_name", "in", "self", ".", "feat_map", ":", "\n", "                    ", "hyp_str", "+=", "' {}=0.0'", ".", "format", "(", "feat_name", ")", "\n", "", "hyp_str", "+=", "'\\n'", "\n", "f_hyp", ".", "write", "(", "hyp_str", ")", "\n", "\n", "continue", "\n", "\n", "# new_hyp_scores = [self.get_rerank_score(hyp) for hyp in hyp_list]", "\n", "\n", "# hyp_ranks = np.argsort(new_hyp_scores)[::-1]", "\n", "\n", "# for i, hyp_id in enumerate(hyp_ranks):", "\n", "", "for", "hyp_id", "in", "range", "(", "len", "(", "hyp_list", ")", ")", ":", "\n", "                ", "hyp", "=", "hyp_list", "[", "hyp_id", "]", "\n", "code_tokens", "=", "hyp_tokenizer", "(", "hyp", ")", "\n", "# reranker_score = new_hyp_scores[hyp_id]", "\n", "\n", "# code_token_count={code_token_count_feat.get_feat_value(example, hyp)}", "\n", "hyp_str", "=", "\"{e_id} ||| {code_tokens} ||| {hyp_score} |||\"", ".", "format", "(", "e_id", "=", "e_id", ",", "code_tokens", "=", "' '", ".", "join", "(", "code_tokens", ")", ",", "hyp_score", "=", "hyp", ".", "score", ")", "\n", "for", "feat_name", "in", "self", ".", "parameter", ".", "keys", "(", ")", ":", "\n", "                    ", "hyp_str", "+=", "' {feat_name}={feat_val}'", ".", "format", "(", "feat_name", "=", "feat_name", ",", "feat_val", "=", "hyp", ".", "rerank_feature_values", "[", "feat_name", "]", ")", "\n", "", "hyp_str", "+=", "'\\n'", "\n", "f_hyp", ".", "write", "(", "hyp_str", ")", "\n", "\n", "", "", "f_src", ".", "close", "(", ")", "\n", "f_tgt", ".", "close", "(", ")", "\n", "f_hyp", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.LinearReranker.train": [[460, 462], ["None"], "methods", ["None"], ["", "def", "train", "(", "self", ",", "examples", ",", "decode_results", ",", "initial_performance", "=", "0.", ",", "metric", "=", "'accuracy'", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.GridSearchReranker.get_rerank_score": [[467, 473], ["numpy.array", "list", "numpy.dot", "hyp.rerank_feature_values.values"], "methods", ["None"], ["def", "get_rerank_score", "(", "self", ",", "hyp", ",", "param", ")", ":", "\n", "        ", "feat_vals", "=", "np", ".", "array", "(", "list", "(", "hyp", ".", "rerank_feature_values", ".", "values", "(", ")", ")", ")", "\n", "score", "=", "hyp", ".", "score", "+", "np", ".", "dot", "(", "param", ",", "feat_vals", ")", "\n", "# score = np.dot(param, feat_vals)", "\n", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.GridSearchReranker.train": [[474, 489], ["components.evaluator.CachedExactMatchEvaluator", "numpy.zeros", "numpy.array", "reranker.GridSearchReranker.compute_rerank_performance", "itertools.combinations", "print", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.compute_rerank_performance"], ["", "def", "train", "(", "self", ",", "examples", ",", "decode_results", ",", "evaluator", "=", "CachedExactMatchEvaluator", "(", ")", ",", "initial_performance", "=", "0.", ")", ":", "\n", "        ", "\"\"\"optimize the ranker on a dataset using grid search\"\"\"", "\n", "best_score", "=", "initial_performance", "\n", "best_param", "=", "np", ".", "zeros", "(", "self", ".", "feature_num", ")", "\n", "\n", "param_space", "=", "(", "np", ".", "array", "(", "p", ")", "for", "p", "in", "itertools", ".", "combinations", "(", "np", ".", "arange", "(", "0", ",", "3.01", ",", "0.01", ")", ",", "self", ".", "feature_num", ")", ")", "\n", "\n", "for", "param", "in", "param_space", ":", "\n", "            ", "score", "=", "self", ".", "compute_rerank_performance", "(", "examples", ",", "decode_results", ",", "fast_mode", "=", "True", ",", "evaluator", "=", "evaluator", ",", "param", "=", "param", ")", "\n", "if", "score", ">", "best_score", ":", "\n", "                ", "print", "(", "'New param=%s, score=%.4f'", "%", "(", "param", ",", "score", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "best_param", "=", "param", "\n", "best_score", "=", "score", "\n", "\n", "", "", "self", ".", "parameter", "=", "best_param", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.GridSearchReranker.train_multiprocess": [[490, 532], ["components.evaluator.CachedExactMatchEvaluator", "numpy.zeros", "reranker.GridSearchReranker.initialize_rerank_features", "print", "print", "sum", "multiprocessing.Pool", "int", "print", "pool.imap_unordered", "itertools.combinations", "len", "param_space_segments.append", "numpy.arange", "len", "print", "len", "reranker.GridSearchReranker.train_multiprocess._norm"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.initialize_rerank_features"], ["", "def", "train_multiprocess", "(", "self", ",", "examples", ",", "decode_results", ",", "evaluator", "=", "CachedExactMatchEvaluator", "(", ")", ",", "initial_performance", "=", "0.", ",", "num_workers", "=", "8", ")", ":", "\n", "        ", "\"\"\"optimize the ranker on a dataset using grid search\"\"\"", "\n", "best_score", "=", "initial_performance", "\n", "best_param", "=", "np", ".", "zeros", "(", "self", ".", "feature_num", ")", "\n", "\n", "self", ".", "initialize_rerank_features", "(", "examples", ",", "decode_results", ")", "\n", "\n", "print", "(", "'generating parameter list'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "param_space", "=", "[", "p", "for", "p", "in", "itertools", ".", "combinations", "(", "np", ".", "arange", "(", "0", ",", "2.03", ",", "0.02", ")", ",", "self", ".", "feature_num", ")", "]", "\n", "print", "(", "'generating parameter list done'", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "global", "_examples", "\n", "_examples", "=", "examples", "\n", "global", "_decode_results", "\n", "_decode_results", "=", "decode_results", "\n", "global", "_evaluator", "\n", "_evaluator", "=", "evaluator", "\n", "global", "_ranker", "\n", "_ranker", "=", "self", "\n", "\n", "def", "_norm", "(", "_param", ")", ":", "\n", "            ", "return", "sum", "(", "p", "**", "2", "for", "p", "in", "_param", ")", "\n", "\n", "", "with", "multiprocessing", ".", "Pool", "(", "processes", "=", "num_workers", ")", "as", "pool", ":", "\n", "# segment the parameter space", "\n", "            ", "segment_size", "=", "int", "(", "len", "(", "param_space", ")", "/", "num_workers", "/", "5", ")", "\n", "param_space_segments", "=", "[", "]", "\n", "ptr", "=", "0", "\n", "while", "ptr", "<", "len", "(", "param_space", ")", ":", "\n", "                ", "param_space_segments", ".", "append", "(", "param_space", "[", "ptr", ":", "ptr", "+", "segment_size", "]", ")", "\n", "ptr", "+=", "segment_size", "\n", "", "print", "(", "'generated %d parameter segments'", "%", "len", "(", "param_space_segments", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "\n", "results", "=", "pool", ".", "imap_unordered", "(", "_rank_segment_worker", ",", "param_space_segments", ")", "\n", "\n", "for", "param", ",", "score", "in", "results", ":", "\n", "                ", "if", "score", ">", "best_score", "or", "score", "==", "best_score", "and", "_norm", "(", "param", ")", "<", "_norm", "(", "best_param", ")", ":", "\n", "                    ", "print", "(", "'[Main] New param=%s, score=%.4f'", "%", "(", "param", ",", "score", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "best_param", "=", "param", "\n", "best_score", "=", "score", "\n", "\n", "", "", "", "self", ".", "parameter", "=", "best_param", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.__init__": [[535, 543], ["reranker.Reranker.__init__", "xgboost.sklearn.XGBRanker"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "features", ",", "transition_system", "=", "None", ")", ":", "\n", "        ", "super", "(", "XGBoostReranker", ",", "self", ")", ".", "__init__", "(", "features", ",", "transition_system", "=", "transition_system", ")", "\n", "\n", "params", "=", "{", "'objective'", ":", "'rank:ndcg'", ",", "'learning_rate'", ":", ".1", ",", "\n", "'gamma'", ":", "5.0", ",", "'min_child_weight'", ":", "0.1", ",", "\n", "'max_depth'", ":", "4", ",", "'n_estimators'", ":", "5", "}", "\n", "\n", "self", ".", "ranker", "=", "xgb", ".", "sklearn", ".", "XGBRanker", "(", "**", "params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_feature_matrix": [[544, 566], ["numpy.stack", "numpy.array", "group.append", "numpy.array", "numpy.stack.append", "numpy.array.append", "len", "hyp.rerank_feature_values.values"], "methods", ["None"], ["", "def", "get_feature_matrix", "(", "self", ",", "decode_results", ",", "train", "=", "False", ")", ":", "\n", "        ", "x", ",", "y", ",", "group", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "\n", "for", "hyps", "in", "decode_results", ":", "\n", "            ", "if", "hyps", ":", "\n", "                ", "for", "hyp", "in", "hyps", ":", "\n", "                    ", "label", "=", "1", "if", "hyp", ".", "is_correct", "else", "0", "\n", "feat_vec", "=", "np", ".", "array", "(", "[", "hyp", ".", "score", "]", "+", "[", "v", "for", "v", "in", "hyp", ".", "rerank_feature_values", ".", "values", "(", ")", "]", ")", "\n", "x", ".", "append", "(", "feat_vec", ")", "\n", "y", ".", "append", "(", "label", ")", "\n", "", "group", ".", "append", "(", "len", "(", "hyps", ")", ")", "\n", "\n", "", "", "x", "=", "np", ".", "stack", "(", "x", ")", "\n", "y", "=", "np", ".", "array", "(", "y", ")", "\n", "\n", "# if train:", "\n", "#     self.scaler = preprocessing.StandardScaler().fit(x)", "\n", "#     x = self.scaler.transform(x)", "\n", "# else:", "\n", "#     x = self.scaler.transform(x)", "\n", "\n", "return", "x", ",", "y", ",", "group", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_rerank_score": [[567, 572], ["reranker.XGBoostReranker.get_feature_matrix", "reranker.XGBoostReranker.ranker.predict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_feature_matrix"], ["", "def", "get_rerank_score", "(", "self", ",", "hyp", ",", "param", ")", ":", "\n", "        ", "x", ",", "y", ",", "group", "=", "self", ".", "get_feature_matrix", "(", "[", "[", "hyp", "]", "]", ")", "\n", "y", "=", "self", ".", "ranker", ".", "predict", "(", "x", ")", "\n", "\n", "return", "y", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.train": [[573, 581], ["components.evaluator.CachedExactMatchEvaluator", "reranker.XGBoostReranker.initialize_rerank_features", "reranker.XGBoostReranker.get_feature_matrix", "reranker.XGBoostReranker.ranker.fit", "reranker.XGBoostReranker.compute_rerank_performance", "print"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.initialize_rerank_features", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.XGBoostReranker.get_feature_matrix", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.compute_rerank_performance"], ["", "def", "train", "(", "self", ",", "examples", ",", "decode_results", ",", "evaluator", "=", "CachedExactMatchEvaluator", "(", ")", ",", "initial_performance", "=", "0.", ")", ":", "\n", "        ", "self", ".", "initialize_rerank_features", "(", "examples", ",", "decode_results", ")", "\n", "\n", "train_x", ",", "train_y", ",", "group_train", "=", "self", ".", "get_feature_matrix", "(", "decode_results", ",", "train", "=", "True", ")", "\n", "self", ".", "ranker", ".", "fit", "(", "train_x", ",", "train_y", ",", "group_train", ")", "\n", "\n", "train_acc", "=", "self", ".", "compute_rerank_performance", "(", "examples", ",", "decode_results", ",", "fast_mode", "=", "True", ",", "evaluator", "=", "evaluator", ")", "\n", "print", "(", "'Dev acc: %f'", "%", "train_acc", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker._rank_worker": [[38, 41], ["_ranker.compute_rerank_performance"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.compute_rerank_performance"], ["def", "_rank_worker", "(", "param", ")", ":", "\n", "    ", "score", "=", "_ranker", ".", "compute_rerank_performance", "(", "_examples", ",", "_decode_results", ",", "fast_mode", "=", "True", ",", "evaluator", "=", "_evaluator", ",", "param", "=", "param", ")", "\n", "return", "param", ",", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker._rank_segment_worker": [[43, 55], ["print", "_ranker.compute_rerank_performance", "print", "len", "numpy.array"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.reranker.Reranker.compute_rerank_performance"], ["", "def", "_rank_segment_worker", "(", "param_space", ")", ":", "\n", "    ", "best_score", "=", "0.", "\n", "best_param", "=", "None", "\n", "print", "(", "'[Child] New parameter segments [%s ~ %s] (%d entries)'", "%", "(", "param_space", "[", "0", "]", ",", "param_space", "[", "-", "1", "]", ",", "len", "(", "param_space", ")", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "for", "param", "in", "param_space", ":", "\n", "        ", "score", "=", "_ranker", ".", "compute_rerank_performance", "(", "_examples", ",", "_decode_results", ",", "fast_mode", "=", "True", ",", "evaluator", "=", "_evaluator", ",", "param", "=", "np", ".", "array", "(", "param", ")", ")", "\n", "if", "score", ">", "best_score", ":", "\n", "            ", "print", "(", "'[Child] New param=%s, score=%.4f'", "%", "(", "param", ",", "score", ")", ",", "file", "=", "sys", ".", "stderr", ")", "\n", "best_param", "=", "param", "\n", "best_score", "=", "score", "\n", "\n", "", "", "return", "best_param", ",", "best_score", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.__init__": [[20, 22], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "examples", ")", ":", "\n", "        ", "self", ".", "examples", "=", "examples", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.all_source": [[23, 26], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "all_source", "(", "self", ")", ":", "\n", "        ", "return", "[", "e", ".", "src_sent", "for", "e", "in", "self", ".", "examples", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.all_targets": [[27, 30], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "all_targets", "(", "self", ")", ":", "\n", "        ", "return", "[", "e", ".", "tgt_code", "for", "e", "in", "self", ".", "examples", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.from_bin_file": [[31, 35], ["pickle.load", "dataset.Dataset", "open"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load"], ["", "@", "staticmethod", "\n", "def", "from_bin_file", "(", "file_path", ")", ":", "\n", "        ", "examples", "=", "pickle", ".", "load", "(", "open", "(", "file_path", ",", "'rb'", ")", ")", "\n", "return", "Dataset", "(", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.batch_iter": [[36, 48], ["numpy.arange", "int", "range", "len", "numpy.random.shuffle", "numpy.ceil", "batch_examples.sort", "len", "float", "len"], "methods", ["None"], ["", "def", "batch_iter", "(", "self", ",", "batch_size", ",", "shuffle", "=", "False", ")", ":", "\n", "        ", "index_arr", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "examples", ")", ")", "\n", "if", "shuffle", ":", "\n", "            ", "np", ".", "random", ".", "shuffle", "(", "index_arr", ")", "\n", "\n", "", "batch_num", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "self", ".", "examples", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "batch_id", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "batch_ids", "=", "index_arr", "[", "batch_size", "*", "batch_id", ":", "batch_size", "*", "(", "batch_id", "+", "1", ")", "]", "\n", "batch_examples", "=", "[", "self", ".", "examples", "[", "i", "]", "for", "i", "in", "batch_ids", "]", "\n", "batch_examples", ".", "sort", "(", "key", "=", "lambda", "e", ":", "-", "len", "(", "e", ".", "src_sent", ")", ")", "\n", "\n", "yield", "batch_examples", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.__len__": [[49, 51], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Dataset.__iter__": [[52, 54], ["iter"], "methods", ["None"], ["", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Example.__init__": [[57, 65], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "src_sent", ",", "tgt_actions", ",", "tgt_code", ",", "tgt_ast", ",", "idx", "=", "0", ",", "meta", "=", "None", ")", ":", "\n", "        ", "self", ".", "src_sent", "=", "src_sent", "\n", "self", ".", "tgt_code", "=", "tgt_code", "\n", "self", ".", "tgt_ast", "=", "tgt_ast", "\n", "self", ".", "tgt_actions", "=", "tgt_actions", "\n", "\n", "self", ".", "idx", "=", "idx", "\n", "self", ".", "meta", "=", "meta", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.__init__": [[68, 81], ["max", "dataset.Batch.init_index_tensors", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.init_index_tensors"], ["    ", "def", "__init__", "(", "self", ",", "examples", ",", "grammar", ",", "vocab", ",", "copy", "=", "True", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "self", ".", "examples", "=", "examples", "\n", "self", ".", "max_action_num", "=", "max", "(", "len", "(", "e", ".", "tgt_actions", ")", "for", "e", "in", "self", ".", "examples", ")", "\n", "\n", "self", ".", "src_sents", "=", "[", "e", ".", "src_sent", "for", "e", "in", "self", ".", "examples", "]", "\n", "self", ".", "src_sents_len", "=", "[", "len", "(", "e", ".", "src_sent", ")", "for", "e", "in", "self", ".", "examples", "]", "\n", "\n", "self", ".", "grammar", "=", "grammar", "\n", "self", ".", "vocab", "=", "vocab", "\n", "self", ".", "copy", "=", "copy", "\n", "self", ".", "cuda", "=", "cuda", "\n", "\n", "self", ".", "init_index_tensors", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.__len__": [[82, 84], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.get_frontier_field_idx": [[85, 95], ["torch.autograd.Variable", "torch.autograd.Variable", "len", "ids.append", "ids.append", "torch.cuda.LongTensor", "torch.LongTensor"], "methods", ["None"], ["", "def", "get_frontier_field_idx", "(", "self", ",", "t", ")", ":", "\n", "        ", "ids", "=", "[", "]", "\n", "for", "e", "in", "self", ".", "examples", ":", "\n", "            ", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "grammar", ".", "field2id", "[", "e", ".", "tgt_actions", "[", "t", "]", ".", "frontier_field", "]", ")", "\n", "# assert self.grammar.id2field[ids[-1]] == e.tgt_actions[t].frontier_field", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "Variable", "(", "torch", ".", "cuda", ".", "LongTensor", "(", "ids", ")", ")", "if", "self", ".", "cuda", "else", "Variable", "(", "torch", ".", "LongTensor", "(", "ids", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.get_frontier_prod_idx": [[96, 106], ["torch.autograd.Variable", "torch.autograd.Variable", "len", "ids.append", "ids.append", "torch.cuda.LongTensor", "torch.LongTensor"], "methods", ["None"], ["", "def", "get_frontier_prod_idx", "(", "self", ",", "t", ")", ":", "\n", "        ", "ids", "=", "[", "]", "\n", "for", "e", "in", "self", ".", "examples", ":", "\n", "            ", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "grammar", ".", "prod2id", "[", "e", ".", "tgt_actions", "[", "t", "]", ".", "frontier_prod", "]", ")", "\n", "# assert self.grammar.id2prod[ids[-1]] == e.tgt_actions[t].frontier_prod", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "Variable", "(", "torch", ".", "cuda", ".", "LongTensor", "(", "ids", ")", ")", "if", "self", ".", "cuda", "else", "Variable", "(", "torch", ".", "LongTensor", "(", "ids", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.get_frontier_field_type_idx": [[107, 117], ["torch.autograd.Variable", "torch.autograd.Variable", "len", "ids.append", "ids.append", "torch.cuda.LongTensor", "torch.LongTensor"], "methods", ["None"], ["", "def", "get_frontier_field_type_idx", "(", "self", ",", "t", ")", ":", "\n", "        ", "ids", "=", "[", "]", "\n", "for", "e", "in", "self", ".", "examples", ":", "\n", "            ", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "grammar", ".", "type2id", "[", "e", ".", "tgt_actions", "[", "t", "]", ".", "frontier_field", ".", "type", "]", ")", "\n", "# assert self.grammar.id2type[ids[-1]] == e.tgt_actions[t].frontier_field.type", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "Variable", "(", "torch", ".", "cuda", ".", "LongTensor", "(", "ids", ")", ")", "if", "self", ".", "cuda", "else", "Variable", "(", "torch", ".", "LongTensor", "(", "ids", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.init_index_tensors": [[118, 203], ["numpy.zeros", "range", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "enumerate", "dataset.Batch.apply_rule_idx_matrix.append", "dataset.Batch.apply_rule_mask.append", "dataset.Batch.primitive_idx_matrix.append", "dataset.Batch.gen_token_mask.append", "dataset.Batch.primitive_copy_mask.append", "T.LongTensor", "T.FloatTensor", "T.LongTensor", "T.FloatTensor", "T.FloatTensor", "torch.from_numpy", "dataset.Batch.primitive_copy_token_idx_mask.cuda", "len", "max", "app_rule_idx_row.append", "app_rule_mask_row.append", "token_row.append", "gen_token_mask_row.append", "copy_mask_row.append", "len", "isinstance", "isinstance", "len", "str", "enumerate"], "methods", ["None"], ["", "def", "init_index_tensors", "(", "self", ")", ":", "\n", "        ", "self", ".", "apply_rule_idx_matrix", "=", "[", "]", "\n", "self", ".", "apply_rule_mask", "=", "[", "]", "\n", "self", ".", "primitive_idx_matrix", "=", "[", "]", "\n", "self", ".", "gen_token_mask", "=", "[", "]", "\n", "self", ".", "primitive_copy_mask", "=", "[", "]", "\n", "self", ".", "primitive_copy_token_idx_mask", "=", "np", ".", "zeros", "(", "(", "self", ".", "max_action_num", ",", "len", "(", "self", ")", ",", "max", "(", "self", ".", "src_sents_len", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "for", "t", "in", "range", "(", "self", ".", "max_action_num", ")", ":", "\n", "            ", "app_rule_idx_row", "=", "[", "]", "\n", "app_rule_mask_row", "=", "[", "]", "\n", "token_row", "=", "[", "]", "\n", "gen_token_mask_row", "=", "[", "]", "\n", "copy_mask_row", "=", "[", "]", "\n", "\n", "for", "e_id", ",", "e", "in", "enumerate", "(", "self", ".", "examples", ")", ":", "\n", "                ", "app_rule_idx", "=", "app_rule_mask", "=", "token_idx", "=", "gen_token_mask", "=", "copy_mask", "=", "0", "\n", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                    ", "action", "=", "e", ".", "tgt_actions", "[", "t", "]", ".", "action", "\n", "action_info", "=", "e", ".", "tgt_actions", "[", "t", "]", "\n", "\n", "if", "isinstance", "(", "action", ",", "ApplyRuleAction", ")", ":", "\n", "                        ", "app_rule_idx", "=", "self", ".", "grammar", ".", "prod2id", "[", "action", ".", "production", "]", "\n", "# assert self.grammar.id2prod[app_rule_idx] == action.production", "\n", "app_rule_mask", "=", "1", "\n", "", "elif", "isinstance", "(", "action", ",", "ReduceAction", ")", ":", "\n", "                        ", "app_rule_idx", "=", "len", "(", "self", ".", "grammar", ")", "\n", "app_rule_mask", "=", "1", "\n", "", "else", ":", "\n", "                        ", "src_sent", "=", "self", ".", "src_sents", "[", "e_id", "]", "\n", "token", "=", "str", "(", "action", ".", "token", ")", "\n", "token_idx", "=", "self", ".", "vocab", ".", "primitive", "[", "action", ".", "token", "]", "\n", "\n", "token_can_copy", "=", "False", "\n", "\n", "if", "self", ".", "copy", "and", "token", "in", "src_sent", ":", "\n", "                            ", "token_pos_list", "=", "[", "idx", "for", "idx", ",", "_token", "in", "enumerate", "(", "src_sent", ")", "if", "_token", "==", "token", "]", "\n", "self", ".", "primitive_copy_token_idx_mask", "[", "t", ",", "e_id", ",", "token_pos_list", "]", "=", "1.", "\n", "copy_mask", "=", "1", "\n", "token_can_copy", "=", "True", "\n", "\n", "", "if", "token_can_copy", "is", "False", "or", "token_idx", "!=", "self", ".", "vocab", ".", "primitive", ".", "unk_id", ":", "\n", "# if the token is not copied, we can only generate this token from the vocabulary,", "\n", "# even if it is a <unk>.", "\n", "# otherwise, we can still generate it from the vocabulary", "\n", "                            ", "gen_token_mask", "=", "1", "\n", "\n", "", "if", "token_can_copy", ":", "\n", "                            ", "assert", "action_info", ".", "copy_from_src", "\n", "assert", "action_info", ".", "src_token_position", "in", "token_pos_list", "\n", "\n", "# # cannot copy, only generation", "\n", "# # could be unk!", "\n", "# if not action_info.copy_from_src:", "\n", "#     gen_token_mask = 1", "\n", "# else:  # copy", "\n", "#     copy_mask = 1", "\n", "#     copy_pos = action_info.src_token_position", "\n", "#     if token_idx != self.vocab.primitive.unk_id:", "\n", "#         # both copy and generate from vocabulary", "\n", "#         gen_token_mask = 1", "\n", "\n", "", "", "", "app_rule_idx_row", ".", "append", "(", "app_rule_idx", ")", "\n", "app_rule_mask_row", ".", "append", "(", "app_rule_mask", ")", "\n", "\n", "token_row", ".", "append", "(", "token_idx", ")", "\n", "gen_token_mask_row", ".", "append", "(", "gen_token_mask", ")", "\n", "copy_mask_row", ".", "append", "(", "copy_mask", ")", "\n", "\n", "", "self", ".", "apply_rule_idx_matrix", ".", "append", "(", "app_rule_idx_row", ")", "\n", "self", ".", "apply_rule_mask", ".", "append", "(", "app_rule_mask_row", ")", "\n", "\n", "self", ".", "primitive_idx_matrix", ".", "append", "(", "token_row", ")", "\n", "self", ".", "gen_token_mask", ".", "append", "(", "gen_token_mask_row", ")", "\n", "\n", "self", ".", "primitive_copy_mask", ".", "append", "(", "copy_mask_row", ")", "\n", "\n", "", "T", "=", "torch", ".", "cuda", "if", "self", ".", "cuda", "else", "torch", "\n", "self", ".", "apply_rule_idx_matrix", "=", "Variable", "(", "T", ".", "LongTensor", "(", "self", ".", "apply_rule_idx_matrix", ")", ")", "\n", "self", ".", "apply_rule_mask", "=", "Variable", "(", "T", ".", "FloatTensor", "(", "self", ".", "apply_rule_mask", ")", ")", "\n", "self", ".", "primitive_idx_matrix", "=", "Variable", "(", "T", ".", "LongTensor", "(", "self", ".", "primitive_idx_matrix", ")", ")", "\n", "self", ".", "gen_token_mask", "=", "Variable", "(", "T", ".", "FloatTensor", "(", "self", ".", "gen_token_mask", ")", ")", "\n", "self", ".", "primitive_copy_mask", "=", "Variable", "(", "T", ".", "FloatTensor", "(", "self", ".", "primitive_copy_mask", ")", ")", "\n", "self", ".", "primitive_copy_token_idx_mask", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "self", ".", "primitive_copy_token_idx_mask", ")", ")", "\n", "if", "self", ".", "cuda", ":", "self", ".", "primitive_copy_token_idx_mask", "=", "self", ".", "primitive_copy_token_idx_mask", ".", "cuda", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.primitive_mask": [[204, 207], ["torch.eq().float", "torch.eq"], "methods", ["None"], ["", "@", "property", "\n", "def", "primitive_mask", "(", "self", ")", ":", "\n", "        ", "return", "1.", "-", "torch", ".", "eq", "(", "self", ".", "gen_token_mask", "+", "self", ".", "primitive_copy_mask", ",", "0", ")", ".", "float", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.src_sents_var": [[208, 212], ["model.nn_utils.to_input_variable"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable"], ["", "@", "cached_property", "\n", "def", "src_sents_var", "(", "self", ")", ":", "\n", "        ", "return", "nn_utils", ".", "to_input_variable", "(", "self", ".", "src_sents", ",", "self", ".", "vocab", ".", "source", ",", "\n", "cuda", "=", "self", ".", "cuda", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.src_token_mask": [[213, 217], ["model.nn_utils.length_array_to_mask_tensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor"], ["", "@", "cached_property", "\n", "def", "src_token_mask", "(", "self", ")", ":", "\n", "        ", "return", "nn_utils", ".", "length_array_to_mask_tensor", "(", "self", ".", "src_sents_len", ",", "\n", "cuda", "=", "self", ".", "cuda", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.token_pos_list": [[218, 227], ["enumerate", "collections.OrderedDict", "enumerate", "collections.OrderedDict.setdefault().append", "collections.OrderedDict.setdefault"], "methods", ["None"], ["", "@", "cached_property", "\n", "def", "token_pos_list", "(", "self", ")", ":", "\n", "# (batch_size, src_token_pos, unique_src_token_num)", "\n", "\n", "        ", "batch_src_token_to_pos_map", "=", "[", "]", "\n", "for", "e_id", ",", "e", "in", "enumerate", "(", "self", ".", "examples", ")", ":", "\n", "            ", "aggregated_primitive_tokens", "=", "OrderedDict", "(", ")", "\n", "for", "token_pos", ",", "token", "in", "enumerate", "(", "e", ".", "src_sent", ")", ":", "\n", "                ", "aggregated_primitive_tokens", ".", "setdefault", "(", "token", ",", "[", "]", ")", ".", "append", "(", "token_pos", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.decode_hypothesis.DecodeHypothesis.__init__": [[9, 14], ["asdl.hypothesis.Hypothesis.__init__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "DecodeHypothesis", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "action_infos", "=", "[", "]", "\n", "self", ".", "code", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.decode_hypothesis.DecodeHypothesis.clone_and_apply_action_info": [[15, 22], ["decode_hypothesis.DecodeHypothesis.clone_and_apply_action", "decode_hypothesis.DecodeHypothesis.action_infos.append"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.clone_and_apply_action"], ["", "def", "clone_and_apply_action_info", "(", "self", ",", "action_info", ")", ":", "\n", "        ", "action", "=", "action_info", ".", "action", "\n", "\n", "new_hyp", "=", "self", ".", "clone_and_apply_action", "(", "action", ")", "\n", "new_hyp", ".", "action_infos", ".", "append", "(", "action_info", ")", "\n", "\n", "return", "new_hyp", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.decode_hypothesis.DecodeHypothesis.copy": [[23, 38], ["decode_hypothesis.DecodeHypothesis", "list", "list", "list", "DecodeHypothesis.update_frontier_info", "decode_hypothesis.DecodeHypothesis.tree.copy"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.copy"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "new_hyp", "=", "DecodeHypothesis", "(", ")", "\n", "if", "self", ".", "tree", ":", "\n", "            ", "new_hyp", ".", "tree", "=", "self", ".", "tree", ".", "copy", "(", ")", "\n", "\n", "", "new_hyp", ".", "actions", "=", "list", "(", "self", ".", "actions", ")", "\n", "new_hyp", ".", "action_infos", "=", "list", "(", "self", ".", "action_infos", ")", "\n", "new_hyp", ".", "score", "=", "self", ".", "score", "\n", "new_hyp", ".", "_value_buffer", "=", "list", "(", "self", ".", "_value_buffer", ")", "\n", "new_hyp", ".", "t", "=", "self", ".", "t", "\n", "new_hyp", ".", "code", "=", "self", ".", "code", "\n", "\n", "new_hyp", ".", "update_frontier_info", "(", ")", "\n", "\n", "return", "new_hyp", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.evaluator.Evaluator.__init__": [[10, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "transition_system", "=", "None", ",", "args", "=", "None", ")", ":", "\n", "        ", "self", ".", "transition_system", "=", "transition_system", "\n", "self", ".", "default_metric", "=", "'accuracy'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.evaluator.Evaluator.is_hyp_correct": [[14, 16], ["evaluator.Evaluator.transition_system.compare_ast"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.compare_ast"], ["", "def", "is_hyp_correct", "(", "self", ",", "example", ",", "hyp", ")", ":", "\n", "        ", "return", "self", ".", "transition_system", ".", "compare_ast", "(", "hyp", ".", "tree", ",", "example", ".", "tgt_ast", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.evaluator.Evaluator.evaluate_dataset": [[17, 54], ["zip", "numpy.average", "numpy.average", "dict", "enumerate", "correct_array.append", "oracle_array.append", "correct_array.append", "oracle_array.append", "any", "evaluator.Evaluator.is_hyp_correct", "print", "print", "print", "traceback.print_exc", "print"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.is_hyp_correct"], ["", "def", "evaluate_dataset", "(", "self", ",", "examples", ",", "decode_results", ",", "fast_mode", "=", "False", ")", ":", "\n", "        ", "correct_array", "=", "[", "]", "\n", "oracle_array", "=", "[", "]", "\n", "for", "example", ",", "hyp_list", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "if", "fast_mode", ":", "\n", "                ", "hyp_list", "=", "hyp_list", "[", ":", "1", "]", "\n", "\n", "", "if", "hyp_list", ":", "\n", "                ", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyp_list", ")", ":", "\n", "                    ", "try", ":", "\n", "                        ", "is_correct", "=", "self", ".", "is_hyp_correct", "(", "example", ",", "hyp", ")", "\n", "", "except", ":", "\n", "                        ", "is_correct", "=", "False", "\n", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'Error in evaluating Example %s, hyp %d {{ %s }}'", "%", "(", "example", ".", "idx", ",", "hyp_id", ",", "hyp", ".", "code", ")", ",", "\n", "file", "=", "sys", ".", "stdout", ")", "\n", "\n", "print", "(", "'example id: %s, hypothesis id: %d'", "%", "(", "example", ".", "idx", ",", "hyp_id", ")", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "traceback", ".", "print_exc", "(", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "\n", "", "hyp", ".", "is_correct", "=", "is_correct", "\n", "\n", "", "correct_array", ".", "append", "(", "hyp_list", "[", "0", "]", ".", "is_correct", ")", "\n", "oracle_array", ".", "append", "(", "any", "(", "hyp", ".", "is_correct", "for", "hyp", "in", "hyp_list", ")", ")", "\n", "", "else", ":", "\n", "                ", "correct_array", ".", "append", "(", "False", ")", "\n", "oracle_array", ".", "append", "(", "False", ")", "\n", "\n", "", "", "acc", "=", "np", ".", "average", "(", "correct_array", ")", "\n", "\n", "oracle_acc", "=", "np", ".", "average", "(", "oracle_array", ")", "\n", "eval_results", "=", "dict", "(", "accuracy", "=", "acc", ",", "\n", "oracle_accuracy", "=", "oracle_acc", ")", "\n", "\n", "return", "eval_results", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.evaluator.CachedExactMatchEvaluator.is_hyp_correct": [[58, 60], ["None"], "methods", ["None"], ["    ", "def", "is_hyp_correct", "(", "self", ",", "example", ",", "hyp", ")", ":", "\n", "        ", "raise", "hyp", ".", "is_correct", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.evaluator.CachedExactMatchEvaluator.evaluate_dataset": [[61, 74], ["dict", "acc_array.append", "oracle_array.append", "sum", "float", "any", "numpy.average", "numpy.average", "len", "len"], "methods", ["None"], ["", "def", "evaluate_dataset", "(", "self", ",", "examples", ",", "decode_results", ",", "fast_mode", "=", "False", ")", ":", "\n", "        ", "if", "fast_mode", ":", "\n", "            ", "acc", "=", "sum", "(", "hyps", "[", "0", "]", ".", "is_correct", "for", "hyps", "in", "decode_results", "if", "len", "(", "hyps", ")", ">", "0", ")", "/", "float", "(", "len", "(", "examples", ")", ")", "\n", "return", "acc", "\n", "\n", "", "acc_array", "=", "[", "]", "\n", "oracle_array", "=", "[", "]", "\n", "for", "hyp_list", "in", "decode_results", ":", "\n", "            ", "acc_array", ".", "append", "(", "hyp_list", "[", "0", "]", ".", "is_correct", "if", "hyp_list", "else", "False", ")", "\n", "oracle_array", ".", "append", "(", "any", "(", "hyp", ".", "is_correct", "for", "hyp", "in", "hyp_list", ")", ")", "\n", "\n", "", "return", "dict", "(", "accuracy", "=", "np", ".", "average", "(", "acc_array", ")", ",", "\n", "oracle_array", "=", "np", ".", "average", "(", "oracle_array", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.__init__": [[10, 19], ["dict", "vocab.VocabEntry.word2id.items"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "word2id", "=", "dict", "(", ")", "\n", "self", ".", "unk_id", "=", "3", "\n", "self", ".", "word2id", "[", "'<pad>'", "]", "=", "0", "\n", "self", ".", "word2id", "[", "'<s>'", "]", "=", "1", "\n", "self", ".", "word2id", "[", "'</s>'", "]", "=", "2", "\n", "self", ".", "word2id", "[", "'<unk>'", "]", "=", "3", "\n", "\n", "self", ".", "id2word", "=", "{", "v", ":", "k", "for", "k", ",", "v", "in", "self", ".", "word2id", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.__getitem__": [[20, 22], ["vocab.VocabEntry.word2id.get"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "word", ")", ":", "\n", "        ", "return", "self", ".", "word2id", ".", "get", "(", "word", ",", "self", ".", "unk_id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.__contains__": [[23, 25], ["None"], "methods", ["None"], ["", "def", "__contains__", "(", "self", ",", "word", ")", ":", "\n", "        ", "return", "word", "in", "self", ".", "word2id", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.__setitem__": [[26, 28], ["ValueError"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "key", ",", "value", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'vocabulary is readonly'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.__len__": [[29, 31], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "word2id", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.__repr__": [[32, 34], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'Vocabulary[size=%d]'", "%", "len", "(", "self", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.id2word": [[35, 37], ["None"], "methods", ["None"], ["", "def", "id2word", "(", "self", ",", "wid", ")", ":", "\n", "        ", "return", "self", ".", "id2word", "[", "wid", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.add": [[38, 45], ["len"], "methods", ["None"], ["", "def", "add", "(", "self", ",", "word", ")", ":", "\n", "        ", "if", "word", "not", "in", "self", ":", "\n", "            ", "wid", "=", "self", ".", "word2id", "[", "word", "]", "=", "len", "(", "self", ")", "\n", "self", ".", "id2word", "[", "wid", "]", "=", "word", "\n", "return", "wid", "\n", "", "else", ":", "\n", "            ", "return", "self", "[", "word", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.is_unk": [[46, 48], ["None"], "methods", ["None"], ["", "", "def", "is_unk", "(", "self", ",", "word", ")", ":", "\n", "        ", "return", "word", "not", "in", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.merge": [[49, 52], ["vocab.VocabEntry.add"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.add"], ["", "def", "merge", "(", "self", ",", "other_vocab_entry", ")", ":", "\n", "        ", "for", "word", "in", "other_vocab_entry", ".", "word2id", ":", "\n", "            ", "self", ".", "add", "(", "word", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.from_corpus": [[54, 85], ["vocab.VocabEntry", "collections.Counter", "print", "print", "print", "print", "print", "itertools.chain", "len", "sorted", "collections.Counter.keys", "len", "len", "len", "len", "vocab.VocabEntry.add", "words_not_included.append"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.add"], ["", "", "@", "staticmethod", "\n", "def", "from_corpus", "(", "corpus", ",", "size", ",", "freq_cutoff", "=", "0", ")", ":", "\n", "        ", "vocab_entry", "=", "VocabEntry", "(", ")", "\n", "\n", "word_freq", "=", "Counter", "(", "chain", "(", "*", "corpus", ")", ")", "\n", "non_singletons", "=", "[", "w", "for", "w", "in", "word_freq", "if", "word_freq", "[", "w", "]", ">", "1", "]", "\n", "singletons", "=", "[", "w", "for", "w", "in", "word_freq", "if", "word_freq", "[", "w", "]", "==", "1", "]", "\n", "print", "(", "'number of word types: %d, number of word types w/ frequency > 1: %d'", "%", "(", "len", "(", "word_freq", ")", ",", "\n", "len", "(", "non_singletons", ")", ")", ")", "\n", "print", "(", "'number of singletons: '", ",", "len", "(", "singletons", ")", ")", "\n", "# print('singletons: %s' % singletons)", "\n", "\n", "total_appearance_count", "=", "0", "\n", "top_k_words", "=", "sorted", "(", "word_freq", ".", "keys", "(", ")", ",", "reverse", "=", "True", ",", "key", "=", "word_freq", ".", "get", ")", "[", ":", "size", "]", "\n", "words_not_included", "=", "[", "]", "\n", "for", "word", "in", "top_k_words", ":", "\n", "            ", "total_appearance_count", "+=", "word_freq", "[", "word", "]", "\n", "if", "len", "(", "vocab_entry", ")", "<", "size", ":", "\n", "                ", "if", "word_freq", "[", "word", "]", ">=", "freq_cutoff", ":", "\n", "                    ", "vocab_entry", ".", "add", "(", "word", ")", "\n", "", "else", ":", "\n", "                    ", "words_not_included", ".", "append", "(", "word", ")", "\n", "\n", "", "", "", "print", "(", "'number of words not included: %s'", "%", "len", "(", "words_not_included", ")", ")", "\n", "appearance_count", "=", "0", "\n", "for", "word", "in", "words_not_included", ":", "\n", "            ", "appearance_count", "+=", "word_freq", "[", "word", "]", "\n", "\n", "", "print", "(", "'total token count: '", ",", "total_appearance_count", ")", "\n", "print", "(", "'unk token count: '", ",", "appearance_count", ")", "\n", "return", "vocab_entry", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.Vocab.__init__": [[88, 95], ["kwargs.items", "isinstance", "vocab.Vocab.__setattr__", "vocab.Vocab.entries.append"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "entries", "=", "[", "]", "\n", "for", "key", ",", "item", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "assert", "isinstance", "(", "item", ",", "VocabEntry", ")", "\n", "self", ".", "__setattr__", "(", "key", ",", "item", ")", "\n", "\n", "self", ".", "entries", ".", "append", "(", "key", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.Vocab.__repr__": [[96, 98], ["getattr"], "methods", ["None"], ["", "", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'Vocab(%s)'", "%", "(", "', '", ".", "join", "(", "'%s %swords'", "%", "(", "entry", ",", "getattr", "(", "self", ",", "entry", ")", ")", "for", "entry", "in", "self", ".", "entries", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.datasets.utils.ExampleProcessor.pre_process_utterance": [[9, 11], ["None"], "methods", ["None"], ["def", "pre_process_utterance", "(", "self", ",", "utterance", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.datasets.utils.ExampleProcessor.post_process_hypothesis": [[12, 14], ["None"], "methods", ["None"], ["", "def", "post_process_hypothesis", "(", "self", ",", "hyp", ",", "meta_info", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.datasets.utils.get_example_processor_cls": [[16, 22], ["RuntimeError"], "function", ["None"], ["", "", "def", "get_example_processor_cls", "(", "dataset", ")", ":", "\n", "    ", "if", "dataset", "==", "'conala'", ":", "\n", "        ", "from", "datasets", ".", "conala", ".", "example_processor", "import", "ConalaExampleProcessor", "\n", "return", "ConalaExampleProcessor", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score._get_ngrams": [[27, 43], ["collections.Counter", "range", "range", "tuple", "len"], "function", ["None"], ["def", "_get_ngrams", "(", "segment", ",", "max_order", ")", ":", "\n", "  ", "\"\"\"Extracts all n-grams upto a given maximum order from an input segment.\n  Args:\n    segment: text segment from which n-grams will be extracted.\n    max_order: maximum length in tokens of the n-grams returned by this\n        methods.\n  Returns:\n    The Counter containing all n-grams upto max_order in segment\n    with a count of how many times each n-gram occurred.\n  \"\"\"", "\n", "ngram_counts", "=", "collections", ".", "Counter", "(", ")", "\n", "for", "order", "in", "range", "(", "1", ",", "max_order", "+", "1", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "0", ",", "len", "(", "segment", ")", "-", "order", "+", "1", ")", ":", "\n", "      ", "ngram", "=", "tuple", "(", "segment", "[", "i", ":", "i", "+", "order", "]", ")", "\n", "ngram_counts", "[", "ngram", "]", "+=", "1", "\n", "", "", "return", "ngram_counts", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score.compute_bleu": [[45, 111], ["zip", "range", "min", "len", "collections.Counter", "bleu_score._get_ngrams", "range", "min", "sum", "math.exp", "float", "bleu_score._get_ngrams", "math.exp", "len", "len", "float", "math.log", "len"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score._get_ngrams", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score._get_ngrams"], ["", "def", "compute_bleu", "(", "reference_corpus", ",", "translation_corpus", ",", "max_order", "=", "4", ",", "\n", "smooth", "=", "False", ")", ":", "\n", "  ", "\"\"\"Computes BLEU score of translated segments against one or more references.\n  Args:\n    reference_corpus: list of lists of references for each translation. Each\n        reference should be tokenized into a list of tokens.\n    translation_corpus: list of translations to score. Each translation\n        should be tokenized into a list of tokens.\n    max_order: Maximum n-gram order to use when computing BLEU score.\n    smooth: Whether or not to apply Lin et al. 2004 smoothing.\n  Returns:\n    3-Tuple with the BLEU score, n-gram precisions, geometric mean of n-gram\n    precisions and brevity penalty.\n  \"\"\"", "\n", "matches_by_order", "=", "[", "0", "]", "*", "max_order", "\n", "possible_matches_by_order", "=", "[", "0", "]", "*", "max_order", "\n", "reference_length", "=", "0", "\n", "translation_length", "=", "0", "\n", "for", "(", "references", ",", "translation", ")", "in", "zip", "(", "reference_corpus", ",", "\n", "translation_corpus", ")", ":", "\n", "    ", "reference_length", "+=", "min", "(", "len", "(", "r", ")", "for", "r", "in", "references", ")", "\n", "translation_length", "+=", "len", "(", "translation", ")", "\n", "\n", "merged_ref_ngram_counts", "=", "collections", ".", "Counter", "(", ")", "\n", "for", "reference", "in", "references", ":", "\n", "      ", "merged_ref_ngram_counts", "|=", "_get_ngrams", "(", "reference", ",", "max_order", ")", "\n", "", "translation_ngram_counts", "=", "_get_ngrams", "(", "translation", ",", "max_order", ")", "\n", "overlap", "=", "translation_ngram_counts", "&", "merged_ref_ngram_counts", "\n", "for", "ngram", "in", "overlap", ":", "\n", "      ", "matches_by_order", "[", "len", "(", "ngram", ")", "-", "1", "]", "+=", "overlap", "[", "ngram", "]", "\n", "", "for", "order", "in", "range", "(", "1", ",", "max_order", "+", "1", ")", ":", "\n", "      ", "possible_matches", "=", "len", "(", "translation", ")", "-", "order", "+", "1", "\n", "if", "possible_matches", ">", "0", ":", "\n", "        ", "possible_matches_by_order", "[", "order", "-", "1", "]", "+=", "possible_matches", "\n", "\n", "", "", "", "precisions", "=", "[", "0", "]", "*", "max_order", "\n", "for", "i", "in", "range", "(", "0", ",", "max_order", ")", ":", "\n", "    ", "if", "smooth", ":", "\n", "      ", "precisions", "[", "i", "]", "=", "(", "(", "matches_by_order", "[", "i", "]", "+", "1.", ")", "/", "\n", "(", "possible_matches_by_order", "[", "i", "]", "+", "1.", ")", ")", "\n", "", "else", ":", "\n", "      ", "if", "possible_matches_by_order", "[", "i", "]", ">", "0", ":", "\n", "        ", "precisions", "[", "i", "]", "=", "(", "float", "(", "matches_by_order", "[", "i", "]", ")", "/", "\n", "possible_matches_by_order", "[", "i", "]", ")", "\n", "", "else", ":", "\n", "        ", "precisions", "[", "i", "]", "=", "0.0", "\n", "\n", "", "", "", "if", "min", "(", "precisions", ")", ">", "0", ":", "\n", "    ", "p_log_sum", "=", "sum", "(", "(", "1.", "/", "max_order", ")", "*", "math", ".", "log", "(", "p", ")", "for", "p", "in", "precisions", ")", "\n", "geo_mean", "=", "math", ".", "exp", "(", "p_log_sum", ")", "\n", "", "else", ":", "\n", "    ", "geo_mean", "=", "0", "\n", "\n", "", "ratio", "=", "float", "(", "translation_length", ")", "/", "reference_length", "\n", "\n", "if", "ratio", ">", "1.0", ":", "\n", "    ", "bp", "=", "1.", "\n", "", "else", ":", "\n", "    ", "if", "ratio", "==", "0.", ":", "\n", "      ", "bp", "=", "0.", "\n", "", "else", ":", "\n", "      ", "bp", "=", "math", ".", "exp", "(", "1", "-", "1.", "/", "ratio", ")", "\n", "\n", "", "", "bleu", "=", "geo_mean", "*", "bp", "\n", "\n", "return", "(", "bleu", ",", "precisions", ",", "bp", ",", "ratio", ",", "translation_length", ",", "reference_length", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.main": [[14, 77], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "datasets.compute_bleu", "open.write", "open.close", "ValueError", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "open", "json.load", "open", "json.load", "len", "len", "ValueError", "open", "sum", "len", "open.write", "conala_eval.tokenize_for_bleu_eval", "conala_eval.tokenize_for_bleu_eval", "open", "len", "len", "os.path.join", "os.path.join", "zip"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score.compute_bleu", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval"], ["def", "main", "(", ")", ":", "\n", "\n", "    ", "p", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "\"Evaluator for CoNaLa\"", ",", "\n", "formatter_class", "=", "argparse", ".", "ArgumentDefaultsHelpFormatter", ")", "\n", "\n", "p", ".", "add_argument", "(", "\"--input_dir\"", ",", "\n", "help", "=", "\"input directory, containing 'res/answer.txt' and 'ref/truth.txt'\"", ",", "\n", "default", "=", "None", ")", "\n", "p", ".", "add_argument", "(", "\"--input_ref\"", ",", "\n", "help", "=", "\"input reference file\"", ",", "\n", "default", "=", "None", ")", "\n", "p", ".", "add_argument", "(", "\"--input_hyp\"", ",", "\n", "help", "=", "\"input hypothesis file\"", ",", "\n", "default", "=", "None", ")", "\n", "p", ".", "add_argument", "(", "\"--output_file\"", ",", "\n", "help", "=", "\"output score file\"", ",", "\n", "default", "=", "None", ")", "\n", "p", ".", "add_argument", "(", "\"--output_dir\"", ",", "\n", "help", "=", "\"output score directory which will contain output_dir/scores.txt\"", ",", "\n", "default", "=", "None", ")", "\n", "p", ".", "add_argument", "(", "\"--no_exact_match\"", ",", "\n", "help", "=", "\"only output bleu scores and not exact_match score\"", ",", "\n", "action", "=", "\"store_true\"", ")", "\n", "p", ".", "add_argument", "(", "\"--strip_ref_metadata\"", ",", "\n", "help", "=", "\"strip metadata from the reference and get only the code\"", ",", "\n", "action", "=", "\"store_true\"", ")", "\n", "\n", "args", "=", "p", ".", "parse_args", "(", ")", "\n", "\n", "if", "not", "(", "args", ".", "input_dir", "or", "(", "args", ".", "input_ref", "and", "args", ".", "input_hyp", ")", ")", ":", "\n", "        ", "raise", "ValueError", "(", "\"Must specify input_dir or input_ref+input_hyp\"", ")", "\n", "\n", "", "input_hyp", "=", "args", ".", "input_hyp", "if", "args", ".", "input_hyp", "else", "os", ".", "path", ".", "join", "(", "args", ".", "input_dir", ",", "'res'", ",", "'answer.txt'", ")", "\n", "input_ref", "=", "args", ".", "input_ref", "if", "args", ".", "input_ref", "else", "os", ".", "path", ".", "join", "(", "args", ".", "input_dir", ",", "'ref'", ",", "'truth.txt'", ")", "\n", "\n", "with", "open", "(", "input_hyp", ",", "'r'", ")", "as", "f_hyp", ":", "\n", "        ", "c_hyp", "=", "json", ".", "load", "(", "f_hyp", ")", "\n", "c_hyp", "=", "[", "tokenize_for_bleu_eval", "(", "s", ")", "for", "s", "in", "c_hyp", "]", "\n", "", "with", "open", "(", "input_ref", ",", "'r'", ")", "as", "f_ref", ":", "\n", "        ", "c_ref", "=", "json", ".", "load", "(", "f_ref", ")", "\n", "if", "args", ".", "strip_ref_metadata", ":", "\n", "          ", "c_ref", "=", "[", "x", "[", "'snippet'", "]", "for", "x", "in", "c_ref", "]", "\n", "", "c_ref", "=", "[", "tokenize_for_bleu_eval", "(", "s", ")", "for", "s", "in", "c_ref", "]", "\n", "\n", "", "if", "len", "(", "c_hyp", ")", "!=", "len", "(", "c_ref", ")", ":", "\n", "        ", "raise", "ValueError", "(", "'Length of hypothesis and reference don\\'t match: {} != {}'", ".", "format", "(", "len", "(", "c_hyp", ")", ",", "len", "(", "c_ref", ")", ")", ")", "\n", "\n", "", "if", "args", ".", "output_file", ":", "\n", "        ", "f_out", "=", "open", "(", "args", ".", "output_file", ",", "'w'", ")", "\n", "", "elif", "args", ".", "output_dir", ":", "\n", "        ", "f_out", "=", "open", "(", "os", ".", "path", ".", "join", "(", "args", ".", "output_dir", ",", "'scores.txt'", ")", ",", "'w'", ")", "\n", "", "else", ":", "\n", "        ", "f_out", "=", "sys", ".", "stdout", "\n", "\n", "", "bleu_tup", "=", "bleu_score", ".", "compute_bleu", "(", "[", "[", "x", "]", "for", "x", "in", "c_ref", "]", ",", "c_hyp", ",", "smooth", "=", "False", ")", "\n", "bleu", "=", "bleu_tup", "[", "0", "]", "\n", "exact", "=", "sum", "(", "[", "1", "if", "h", "==", "r", "else", "0", "for", "h", ",", "r", "in", "zip", "(", "c_hyp", ",", "c_ref", ")", "]", ")", "/", "len", "(", "c_hyp", ")", "\n", "\n", "f_out", ".", "write", "(", "'bleu:{0:.2f}\\n'", ".", "format", "(", "bleu", "*", "100", ")", ")", "\n", "if", "not", "args", ".", "no_exact_match", ":", "\n", "        ", "f_out", ".", "write", "(", "'exact:{0:.2f}\\n'", ".", "format", "(", "exact", "*", "100", ")", ")", "\n", "\n", "", "f_out", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.parse_file_json": [[82, 89], ["json.load", "conala_eval.tokenize_for_bleu_eval", "result.append"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval"], ["def", "parse_file_json", "(", "f", ")", ":", "\n", "    ", "snippet_list", "=", "json", ".", "load", "(", "f", ")", "\n", "result", "=", "[", "]", "\n", "for", "snippet", "in", "snippet_list", ":", "\n", "        ", "toks", "=", "tokenize_for_bleu_eval", "(", "snippet", "[", "'snippet'", "]", ")", "\n", "result", ".", "append", "(", "toks", ")", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval": [[94, 103], ["re.sub", "re.sub", "re.sub", "code.replace.replace", "code.replace.replace", "code.replace.split"], "function", ["None"], ["def", "tokenize_for_bleu_eval", "(", "code", ")", ":", "\n", "    ", "code", "=", "re", ".", "sub", "(", "r'([^A-Za-z0-9_])'", ",", "r' \\1 '", ",", "code", ")", "\n", "code", "=", "re", ".", "sub", "(", "r'([a-z])([A-Z])'", ",", "r'\\1 \\2'", ",", "code", ")", "\n", "code", "=", "re", ".", "sub", "(", "r'\\s+'", ",", "' '", ",", "code", ")", "\n", "code", "=", "code", ".", "replace", "(", "'\"'", ",", "'`'", ")", "\n", "code", "=", "code", ".", "replace", "(", "'\\''", ",", "'`'", ")", "\n", "tokens", "=", "[", "t", "for", "t", "in", "code", ".", "split", "(", "' '", ")", "if", "t", "]", "\n", "\n", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_code": [[108, 117], ["string.strip().decode().encode.strip().decode().encode", "tokenize.generate_tokens", "string.strip().decode().encode.strip().decode", "StringIO", "tokens.append", "tokval.lower", "string.strip().decode().encode.strip"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode"], ["def", "tokenize_code", "(", "string", ",", "concat_symbol", "=", "None", ")", ":", "\n", "    ", "tokens", "=", "[", "]", "\n", "string", "=", "string", ".", "strip", "(", ")", ".", "decode", "(", "'utf-8'", ")", ".", "encode", "(", "'ascii'", ",", "'strict'", ")", "#.decode('string_escape')", "\n", "for", "toknum", ",", "tokval", ",", "_", ",", "_", ",", "_", "in", "tokenize", ".", "generate_tokens", "(", "StringIO", "(", "string", ")", ".", "readline", ")", ":", "\n", "# We ignore these tokens during evaluation.", "\n", "        ", "if", "toknum", "not", "in", "[", "token", ".", "ENDMARKER", ",", "token", ".", "INDENT", ",", "token", ".", "DEDENT", "]", ":", "\n", "            ", "tokens", ".", "append", "(", "tokval", ".", "lower", "(", ")", ")", "\n", "\n", "", "", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.get_reference_list": [[124, 129], ["open", "conala_eval.parse_file_json"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.parse_file_json"], ["def", "get_reference_list", "(", "reference_file_name", ")", ":", "\n", "    ", "f_reference", "=", "open", "(", "reference_file_name", ")", "\n", "a", "=", "parse_file_json", "(", "f_reference", ")", "\n", "a", "=", "[", "[", "l", "]", "for", "l", "in", "a", "]", "\n", "return", "a", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.evaluate_bleu": [[136, 139], ["datasets.compute_bleu", "conala_eval.tokenize_for_bleu_eval"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score.compute_bleu", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval"], ["def", "evaluate_bleu", "(", "reference_list", ",", "hypothesis_list", ")", ":", "\n", "    ", "b", "=", "[", "tokenize_for_bleu_eval", "(", "s", ")", "for", "s", "in", "hypothesis_list", "]", "\n", "return", "bleu_score", ".", "compute_bleu", "(", "reference_list", ",", "b", ",", "smooth", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.example_processor.ConalaExampleProcessor.__init__": [[10, 12], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "transition_system", ")", ":", "\n", "        ", "self", ".", "transition_system", "=", "transition_system", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.example_processor.ConalaExampleProcessor.pre_process_utterance": [[13, 18], ["datasets.conala.dataset.canonicalize_intent", "datasets.conala.dataset.tokenize_intent"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.canonicalize_intent", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.tokenize_intent"], ["", "def", "pre_process_utterance", "(", "self", ",", "utterance", ")", ":", "\n", "        ", "canonical_intent", ",", "slot_map", "=", "canonicalize_intent", "(", "utterance", ")", "\n", "intent_tokens", "=", "tokenize_intent", "(", "canonical_intent", ")", "\n", "\n", "return", "intent_tokens", ",", "slot_map", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.example_processor.ConalaExampleProcessor.post_process_hypothesis": [[19, 24], ["datasets.conala.dataset.asdl_ast_to_python_ast", "astor.to_source().strip", "datasets.conala.dataset.decanonicalize_code", "astor.to_source"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.decanonicalize_code"], ["", "def", "post_process_hypothesis", "(", "self", ",", "hyp", ",", "meta_info", ",", "utterance", "=", "None", ")", ":", "\n", "        ", "\"\"\"traverse the AST and replace slot ids with original strings\"\"\"", "\n", "hyp_ast", "=", "asdl_ast_to_python_ast", "(", "hyp", ".", "tree", ",", "self", ".", "transition_system", ".", "grammar", ")", "\n", "code_from_hyp", "=", "astor", ".", "to_source", "(", "hyp_ast", ")", ".", "strip", "(", ")", "\n", "hyp", ".", "code", "=", "decanonicalize_code", "(", "code_from_hyp", ",", "meta_info", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_conala_dataset": [[20, 99], ["numpy.random.seed", "open().read", "ASDLGrammar.from_text", "asdl.lang.py3.py3_transition_system.Python3TransitionSystem", "print", "dataset.preprocess_dataset", "numpy.random.shuffle", "print", "print", "print", "dataset.preprocess_dataset", "print", "components.vocab.VocabEntry.from_corpus", "components.vocab.VocabEntry.from_corpus", "components.vocab.VocabEntry.from_corpus", "components.vocab.Vocab", "print", "print", "print", "print", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "pickle.dump", "print", "print", "dataset.preprocess_dataset", "pickle.dump", "print", "dataset.preprocess_dataset", "pickle.dump", "pickle.dump", "map", "asdl.lang.py3.py3_transition_system.Python3TransitionSystem.tokenize_code", "len", "open", "open", "open", "open", "open", "open", "open", "os.path.splitext", "open", "open", "filter", "repr", "max", "numpy.average", "len", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.basename", "os.path.join", "os.path.join", "len", "len", "len", "list", "isinstance", "filter"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.from_text", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.from_corpus", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.from_corpus", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.from_corpus", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_dataset", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["    ", "def", "__init__", "(", "self", ",", "examples", ")", ":", "\n", "        ", "self", ".", "examples", "=", "examples", "\n", "\n", "", "@", "property", "\n", "def", "all_source", "(", "self", ")", ":", "\n", "        ", "return", "[", "e", ".", "src_sent", "for", "e", "in", "self", ".", "examples", "]", "\n", "\n", "", "@", "property", "\n", "def", "all_targets", "(", "self", ")", ":", "\n", "        ", "return", "[", "e", ".", "tgt_code", "for", "e", "in", "self", ".", "examples", "]", "\n", "\n", "", "@", "staticmethod", "\n", "def", "from_bin_file", "(", "file_path", ")", ":", "\n", "        ", "examples", "=", "pickle", ".", "load", "(", "open", "(", "file_path", ",", "'rb'", ")", ")", "\n", "return", "Dataset", "(", "examples", ")", "\n", "\n", "", "def", "batch_iter", "(", "self", ",", "batch_size", ",", "shuffle", "=", "False", ")", ":", "\n", "        ", "index_arr", "=", "np", ".", "arange", "(", "len", "(", "self", ".", "examples", ")", ")", "\n", "if", "shuffle", ":", "\n", "            ", "np", ".", "random", ".", "shuffle", "(", "index_arr", ")", "\n", "\n", "", "batch_num", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "self", ".", "examples", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "batch_id", "in", "range", "(", "batch_num", ")", ":", "\n", "            ", "batch_ids", "=", "index_arr", "[", "batch_size", "*", "batch_id", ":", "batch_size", "*", "(", "batch_id", "+", "1", ")", "]", "\n", "batch_examples", "=", "[", "self", ".", "examples", "[", "i", "]", "for", "i", "in", "batch_ids", "]", "\n", "batch_examples", ".", "sort", "(", "key", "=", "lambda", "e", ":", "-", "len", "(", "e", ".", "src_sent", ")", ")", "\n", "\n", "yield", "batch_examples", "\n", "\n", "", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "examples", ")", "\n", "\n", "", "def", "__iter__", "(", "self", ")", ":", "\n", "        ", "return", "iter", "(", "self", ".", "examples", ")", "\n", "\n", "\n", "", "", "class", "Example", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "src_sent", ",", "tgt_actions", ",", "tgt_code", ",", "tgt_ast", ",", "idx", "=", "0", ",", "meta", "=", "None", ")", ":", "\n", "        ", "self", ".", "src_sent", "=", "src_sent", "\n", "self", ".", "tgt_code", "=", "tgt_code", "\n", "self", ".", "tgt_ast", "=", "tgt_ast", "\n", "self", ".", "tgt_actions", "=", "tgt_actions", "\n", "\n", "self", ".", "idx", "=", "idx", "\n", "self", ".", "meta", "=", "meta", "\n", "\n", "\n", "", "", "class", "Batch", "(", "object", ")", ":", "\n", "    ", "def", "__init__", "(", "self", ",", "examples", ",", "grammar", ",", "vocab", ",", "copy", "=", "True", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "self", ".", "examples", "=", "examples", "\n", "self", ".", "max_action_num", "=", "max", "(", "len", "(", "e", ".", "tgt_actions", ")", "for", "e", "in", "self", ".", "examples", ")", "\n", "\n", "self", ".", "src_sents", "=", "[", "e", ".", "src_sent", "for", "e", "in", "self", ".", "examples", "]", "\n", "self", ".", "src_sents_len", "=", "[", "len", "(", "e", ".", "src_sent", ")", "for", "e", "in", "self", ".", "examples", "]", "\n", "\n", "self", ".", "grammar", "=", "grammar", "\n", "self", ".", "vocab", "=", "vocab", "\n", "self", ".", "copy", "=", "copy", "\n", "self", ".", "cuda", "=", "cuda", "\n", "\n", "self", ".", "init_index_tensors", "(", ")", "\n", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "examples", ")", "\n", "\n", "", "def", "get_frontier_field_idx", "(", "self", ",", "t", ")", ":", "\n", "        ", "ids", "=", "[", "]", "\n", "for", "e", "in", "self", ".", "examples", ":", "\n", "            ", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "grammar", ".", "field2id", "[", "e", ".", "tgt_actions", "[", "t", "]", ".", "frontier_field", "]", ")", "\n", "# assert self.grammar.id2field[ids[-1]] == e.tgt_actions[t].frontier_field", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "Variable", "(", "torch", ".", "cuda", ".", "LongTensor", "(", "ids", ")", ")", "if", "self", ".", "cuda", "else", "Variable", "(", "torch", ".", "LongTensor", "(", "ids", ")", ")", "\n", "\n", "", "def", "get_frontier_prod_idx", "(", "self", ",", "t", ")", ":", "\n", "        ", "ids", "=", "[", "]", "\n", "for", "e", "in", "self", ".", "examples", ":", "\n", "            ", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_dataset": [[101, 177], ["datasets.conala.evaluator.ConalaEvaluator", "open", "enumerate", "open.close", "print", "json.load", "components.dataset.Example", "datasets.conala.evaluator.ConalaEvaluator.is_hyp_correct", "examples.append", "open.write", "open.write", "open.write", "open.write", "open.write", "open.write", "open", "dataset.preprocess_example", "ast.parse", "astor.to_source().strip", "asdl.lang.py3.py3_transition_system.python_ast_to_asdl_ast", "transition_system.get_actions", "Hypothesis", "enumerate", "astor.to_source().strip", "decanonicalize_code", "compare_ast", "transition_system.compare_ast", "components.action_info.get_action_infos", "open.write", "open.write", "len", "json.loads", "isinstance", "hyp.clone_and_apply_action.clone_and_apply_action", "ast.parse", "ast.parse", "transition_system.surface_code_to_ast", "transition_system.surface_code_to_ast", "skipped_list.append", "dict", "open().readlines", "astor.to_source", "transition_system.get_valid_continuation_types", "astor.to_source", "transition_system.get_valid_continuating_productions", "asdl.lang.py3.py3_transition_system.asdl_ast_to_python_ast", "open"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.is_hyp_correct", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_example", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.python_ast_to_asdl_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_actions", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.decanonicalize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.compare_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.compare_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.action_info.get_action_infos", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.clone_and_apply_action", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.surface_code_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.surface_code_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_valid_continuation_types", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_valid_continuating_productions", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast"], ["# assert self.grammar.id2prod[ids[-1]] == e.tgt_actions[t].frontier_prod", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "Variable", "(", "torch", ".", "cuda", ".", "LongTensor", "(", "ids", ")", ")", "if", "self", ".", "cuda", "else", "Variable", "(", "torch", ".", "LongTensor", "(", "ids", ")", ")", "\n", "\n", "", "def", "get_frontier_field_type_idx", "(", "self", ",", "t", ")", ":", "\n", "        ", "ids", "=", "[", "]", "\n", "for", "e", "in", "self", ".", "examples", ":", "\n", "            ", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                ", "ids", ".", "append", "(", "self", ".", "grammar", ".", "type2id", "[", "e", ".", "tgt_actions", "[", "t", "]", ".", "frontier_field", ".", "type", "]", ")", "\n", "# assert self.grammar.id2type[ids[-1]] == e.tgt_actions[t].frontier_field.type", "\n", "", "else", ":", "\n", "                ", "ids", ".", "append", "(", "0", ")", "\n", "\n", "", "", "return", "Variable", "(", "torch", ".", "cuda", ".", "LongTensor", "(", "ids", ")", ")", "if", "self", ".", "cuda", "else", "Variable", "(", "torch", ".", "LongTensor", "(", "ids", ")", ")", "\n", "\n", "", "def", "init_index_tensors", "(", "self", ")", ":", "\n", "        ", "self", ".", "apply_rule_idx_matrix", "=", "[", "]", "\n", "self", ".", "apply_rule_mask", "=", "[", "]", "\n", "self", ".", "primitive_idx_matrix", "=", "[", "]", "\n", "self", ".", "gen_token_mask", "=", "[", "]", "\n", "self", ".", "primitive_copy_mask", "=", "[", "]", "\n", "self", ".", "primitive_copy_token_idx_mask", "=", "np", ".", "zeros", "(", "(", "self", ".", "max_action_num", ",", "len", "(", "self", ")", ",", "max", "(", "self", ".", "src_sents_len", ")", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "for", "t", "in", "range", "(", "self", ".", "max_action_num", ")", ":", "\n", "            ", "app_rule_idx_row", "=", "[", "]", "\n", "app_rule_mask_row", "=", "[", "]", "\n", "token_row", "=", "[", "]", "\n", "gen_token_mask_row", "=", "[", "]", "\n", "copy_mask_row", "=", "[", "]", "\n", "\n", "for", "e_id", ",", "e", "in", "enumerate", "(", "self", ".", "examples", ")", ":", "\n", "                ", "app_rule_idx", "=", "app_rule_mask", "=", "token_idx", "=", "gen_token_mask", "=", "copy_mask", "=", "0", "\n", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", ":", "\n", "                    ", "action", "=", "e", ".", "tgt_actions", "[", "t", "]", ".", "action", "\n", "action_info", "=", "e", ".", "tgt_actions", "[", "t", "]", "\n", "\n", "if", "isinstance", "(", "action", ",", "ApplyRuleAction", ")", ":", "\n", "                        ", "app_rule_idx", "=", "self", ".", "grammar", ".", "prod2id", "[", "action", ".", "production", "]", "\n", "# assert self.grammar.id2prod[app_rule_idx] == action.production", "\n", "app_rule_mask", "=", "1", "\n", "", "elif", "isinstance", "(", "action", ",", "ReduceAction", ")", ":", "\n", "                        ", "app_rule_idx", "=", "len", "(", "self", ".", "grammar", ")", "\n", "app_rule_mask", "=", "1", "\n", "", "else", ":", "\n", "                        ", "src_sent", "=", "self", ".", "src_sents", "[", "e_id", "]", "\n", "token", "=", "str", "(", "action", ".", "token", ")", "\n", "token_idx", "=", "self", ".", "vocab", ".", "primitive", "[", "action", ".", "token", "]", "\n", "\n", "token_can_copy", "=", "False", "\n", "\n", "if", "self", ".", "copy", "and", "token", "in", "src_sent", ":", "\n", "                            ", "token_pos_list", "=", "[", "idx", "for", "idx", ",", "_token", "in", "enumerate", "(", "src_sent", ")", "if", "_token", "==", "token", "]", "\n", "self", ".", "primitive_copy_token_idx_mask", "[", "t", ",", "e_id", ",", "token_pos_list", "]", "=", "1.", "\n", "copy_mask", "=", "1", "\n", "token_can_copy", "=", "True", "\n", "\n", "", "if", "token_can_copy", "is", "False", "or", "token_idx", "!=", "self", ".", "vocab", ".", "primitive", ".", "unk_id", ":", "\n", "# if the token is not copied, we can only generate this token from the vocabulary,", "\n", "# even if it is a <unk>.", "\n", "# otherwise, we can still generate it from the vocabulary", "\n", "                            ", "gen_token_mask", "=", "1", "\n", "\n", "", "if", "token_can_copy", ":", "\n", "                            ", "assert", "action_info", ".", "copy_from_src", "\n", "assert", "action_info", ".", "src_token_position", "in", "token_pos_list", "\n", "\n", "# # cannot copy, only generation", "\n", "# # could be unk!", "\n", "# if not action_info.copy_from_src:", "\n", "#     gen_token_mask = 1", "\n", "# else:  # copy", "\n", "#     copy_mask = 1", "\n", "#     copy_pos = action_info.src_token_position", "\n", "#     if token_idx != self.vocab.primitive.unk_id:", "\n", "#         # both copy and generate from vocabulary", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.dataset.preprocess_example": [[179, 204], ["canonicalize_intent", "canonicalize_code", "tokenize_intent", "decanonicalize_code", "astor.to_source().strip", "astor.to_source().strip", "compare_ast", "ast.parse", "ast.parse", "astor.to_source", "astor.to_source", "ast.parse", "ast.parse"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.canonicalize_intent", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.canonicalize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.tokenize_intent", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.decanonicalize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.compare_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse"], ["\n", "", "", "", "app_rule_idx_row", ".", "append", "(", "app_rule_idx", ")", "\n", "app_rule_mask_row", ".", "append", "(", "app_rule_mask", ")", "\n", "\n", "token_row", ".", "append", "(", "token_idx", ")", "\n", "gen_token_mask_row", ".", "append", "(", "gen_token_mask", ")", "\n", "copy_mask_row", ".", "append", "(", "copy_mask", ")", "\n", "\n", "", "self", ".", "apply_rule_idx_matrix", ".", "append", "(", "app_rule_idx_row", ")", "\n", "self", ".", "apply_rule_mask", ".", "append", "(", "app_rule_mask_row", ")", "\n", "\n", "self", ".", "primitive_idx_matrix", ".", "append", "(", "token_row", ")", "\n", "self", ".", "gen_token_mask", ".", "append", "(", "gen_token_mask_row", ")", "\n", "\n", "self", ".", "primitive_copy_mask", ".", "append", "(", "copy_mask_row", ")", "\n", "\n", "", "T", "=", "torch", ".", "cuda", "if", "self", ".", "cuda", "else", "torch", "\n", "self", ".", "apply_rule_idx_matrix", "=", "Variable", "(", "T", ".", "LongTensor", "(", "self", ".", "apply_rule_idx_matrix", ")", ")", "\n", "self", ".", "apply_rule_mask", "=", "Variable", "(", "T", ".", "FloatTensor", "(", "self", ".", "apply_rule_mask", ")", ")", "\n", "self", ".", "primitive_idx_matrix", "=", "Variable", "(", "T", ".", "LongTensor", "(", "self", ".", "primitive_idx_matrix", ")", ")", "\n", "self", ".", "gen_token_mask", "=", "Variable", "(", "T", ".", "FloatTensor", "(", "self", ".", "gen_token_mask", ")", ")", "\n", "self", ".", "primitive_copy_mask", "=", "Variable", "(", "T", ".", "FloatTensor", "(", "self", ".", "primitive_copy_mask", ")", ")", "\n", "self", ".", "primitive_copy_token_idx_mask", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "self", ".", "primitive_copy_token_idx_mask", ")", ")", "\n", "if", "self", ".", "cuda", ":", "self", ".", "primitive_copy_token_idx_mask", "=", "self", ".", "primitive_copy_token_idx_mask", ".", "cuda", "(", ")", "\n", "\n", "", "@", "property", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.docstring.docstring2conala": [[7, 48], ["open", "open", "open", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "open", "enumerate", "snippet.strip.strip", "[].strip", "os.path.join.readline().strip", "fout.write", "snippet.strip.startswith", "os.path.join.readline().strip", "os.path.join.readline", "len", "len", "json.dumps", "os.path.join.readline", "[].strip.split"], "function", ["None"], ["def", "docstring2conala", "(", "args", ")", ":", "\n", "    ", "if", "args", ".", "classmethod", ":", "\n", "        ", "snippet_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "inp", ",", "'parallel_methods_decl'", ")", "\n", "intent_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "inp", ",", "'parallel_methods_desc'", ")", "\n", "meta_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "inp", ",", "'parallel_methods_meta'", ")", "\n", "", "else", ":", "\n", "        ", "snippet_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "inp", ",", "'parallel_decl'", ")", "\n", "intent_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "inp", ",", "'parallel_desc'", ")", "\n", "meta_file", "=", "os", ".", "path", ".", "join", "(", "args", ".", "inp", ",", "'parallel_meta'", ")", "\n", "\n", "", "snippet_file", "=", "open", "(", "snippet_file", ",", "'r'", ",", "encoding", "=", "'latin-1'", ")", "\n", "intent_file", "=", "open", "(", "intent_file", ",", "'r'", ",", "encoding", "=", "'latin-1'", ")", "\n", "meta_file", "=", "open", "(", "meta_file", ",", "'r'", ",", "encoding", "=", "'latin-1'", ")", "\n", "\n", "num_pairs", "=", "0", "\n", "\n", "with", "open", "(", "args", ".", "out", ",", "'w'", ")", "as", "fout", ":", "\n", "        ", "for", "i", ",", "snippet", "in", "enumerate", "(", "snippet_file", ")", ":", "\n", "            ", "snippet", "=", "snippet", ".", "strip", "(", ")", "\n", "if", "not", "snippet", ".", "startswith", "(", "'def '", ")", ":", "\n", "                ", "continue", "\n", "", "snippet", "=", "snippet", "[", "4", ":", "-", "1", "]", "\n", "\n", "intent", "=", "intent_file", ".", "readline", "(", ")", ".", "strip", "(", ")", "[", "1", ":", "-", "1", "]", "\n", "intent", "=", "intent", ".", "split", "(", "'DCNL'", ",", "1", ")", "[", "0", "]", ".", "strip", "(", ")", "\n", "\n", "meta", "=", "meta_file", ".", "readline", "(", ")", ".", "strip", "(", ")", "\n", "\n", "if", "len", "(", "intent", ")", "<=", "0", "or", "len", "(", "snippet", ")", "<=", "0", ":", "\n", "                ", "continue", "\n", "\n", "", "num_pairs", "+=", "1", "\n", "\n", "result", "=", "{", "\n", "'snippet'", ":", "snippet", ",", "\n", "'intent'", ":", "intent", ",", "\n", "'question_id'", ":", "i", "+", "1", ",", "\n", "'from'", ":", "meta", "\n", "}", "\n", "\n", "fout", ".", "write", "(", "json", ".", "dumps", "(", "result", ")", "+", "'\\n'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.compare_ast": [[15, 30], ["isinstance", "isinstance", "list", "isinstance", "type", "type", "vars().items", "all", "util.compare_ast", "itertools.starmap", "vars", "getattr", "zip"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.compare_ast"], ["def", "compare_ast", "(", "node1", ",", "node2", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "node1", ",", "str", ")", ":", "\n", "        ", "if", "type", "(", "node1", ")", "is", "not", "type", "(", "node2", ")", ":", "\n", "            ", "return", "False", "\n", "", "", "if", "isinstance", "(", "node1", ",", "ast", ".", "AST", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "list", "(", "vars", "(", "node1", ")", ".", "items", "(", ")", ")", ":", "\n", "            ", "if", "k", "in", "(", "'lineno'", ",", "'col_offset'", ",", "'ctx'", ")", ":", "\n", "                ", "continue", "\n", "", "if", "not", "compare_ast", "(", "v", ",", "getattr", "(", "node2", ",", "k", ")", ")", ":", "\n", "                ", "return", "False", "\n", "", "", "return", "True", "\n", "", "elif", "isinstance", "(", "node1", ",", "list", ")", ":", "\n", "        ", "return", "all", "(", "itertools", ".", "starmap", "(", "compare_ast", ",", "zip", "(", "node1", ",", "node2", ")", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "node1", "==", "node2", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.tokenize_intent": [[32, 37], ["intent.lower", "nltk.word_tokenize"], "function", ["None"], ["", "", "def", "tokenize_intent", "(", "intent", ")", ":", "\n", "    ", "lower_intent", "=", "intent", ".", "lower", "(", ")", "\n", "tokens", "=", "nltk", ".", "word_tokenize", "(", "lower_intent", ")", "\n", "\n", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.infer_slot_type": [[39, 43], ["value.isidentifier"], "function", ["None"], ["", "def", "infer_slot_type", "(", "quote", ",", "value", ")", ":", "\n", "    ", "if", "quote", "==", "'`'", "and", "value", ".", "isidentifier", "(", ")", ":", "\n", "        ", "return", "'var'", "\n", "", "return", "'str'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.canonicalize_intent": [[45, 87], ["QUOTED_TOKEN_RE.findall", "dict", "util.infer_slot_type", "intent.replace.replace", "value.strip().encode().decode", "value.strip().encode", "value.strip"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.infer_slot_type", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode"], ["", "def", "canonicalize_intent", "(", "intent", ")", ":", "\n", "# handle the following special case: quote is `''`", "\n", "    ", "marked_token_matches", "=", "QUOTED_TOKEN_RE", ".", "findall", "(", "intent", ")", "\n", "\n", "slot_map", "=", "dict", "(", ")", "\n", "var_id", "=", "0", "\n", "str_id", "=", "0", "\n", "for", "match", "in", "marked_token_matches", ":", "\n", "        ", "quote", "=", "match", "[", "0", "]", "\n", "value", "=", "match", "[", "1", "]", "\n", "quoted_value", "=", "quote", "+", "value", "+", "quote", "\n", "\n", "# try:", "\n", "#     # if it's a number, then keep it and leave it to the copy mechanism", "\n", "#     float(value)", "\n", "#     intent = intent.replace(quoted_value, value)", "\n", "#     continue", "\n", "# except:", "\n", "#     pass", "\n", "\n", "slot_type", "=", "infer_slot_type", "(", "quote", ",", "value", ")", "\n", "\n", "if", "slot_type", "==", "'var'", ":", "\n", "            ", "slot_name", "=", "'var_%d'", "%", "var_id", "\n", "var_id", "+=", "1", "\n", "slot_type", "=", "'var'", "\n", "", "else", ":", "\n", "            ", "slot_name", "=", "'str_%d'", "%", "str_id", "\n", "str_id", "+=", "1", "\n", "slot_type", "=", "'str'", "\n", "\n", "# slot_id = len(slot_map)", "\n", "# slot_name = 'slot_%d' % slot_id", "\n", "# # make sure slot_name is also unicode", "\n", "# slot_name = unicode(slot_name)", "\n", "\n", "", "intent", "=", "intent", ".", "replace", "(", "quoted_value", ",", "slot_name", ")", "\n", "slot_map", "[", "slot_name", "]", "=", "{", "'value'", ":", "value", ".", "strip", "(", ")", ".", "encode", "(", ")", ".", "decode", "(", "'unicode_escape'", ",", "'ignore'", ")", ",", "\n", "'quote'", ":", "quote", ",", "\n", "'type'", ":", "slot_type", "}", "\n", "\n", "", "return", "intent", ",", "slot_map", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.replace_identifiers_in_ast": [[89, 105], ["ast.walk", "list", "vars().items", "isinstance", "vars", "setattr"], "function", ["None"], ["", "def", "replace_identifiers_in_ast", "(", "py_ast", ",", "identifier2slot", ")", ":", "\n", "    ", "for", "node", "in", "ast", ".", "walk", "(", "py_ast", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "list", "(", "vars", "(", "node", ")", ".", "items", "(", ")", ")", ":", "\n", "            ", "if", "k", "in", "(", "'lineno'", ",", "'col_offset'", ",", "'ctx'", ")", ":", "\n", "                ", "continue", "\n", "# Python 3", "\n", "# if isinstance(v, str) or isinstance(v, unicode):", "\n", "", "if", "isinstance", "(", "v", ",", "str", ")", ":", "\n", "                ", "if", "v", "in", "identifier2slot", ":", "\n", "                    ", "slot_name", "=", "identifier2slot", "[", "v", "]", "\n", "# Python 3", "\n", "# if isinstance(slot_name, unicode):", "\n", "#     try: slot_name = slot_name.encode('ascii')", "\n", "#     except: pass", "\n", "\n", "setattr", "(", "node", ",", "k", ",", "slot_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.is_enumerable_str": [[107, 113], ["len"], "function", ["None"], ["", "", "", "", "", "def", "is_enumerable_str", "(", "identifier_value", ")", ":", "\n", "    ", "\"\"\"\n    Test if the quoted identifier value is a list\n    \"\"\"", "\n", "\n", "return", "len", "(", "identifier_value", ")", ">", "2", "and", "identifier_value", "[", "0", "]", "in", "(", "'{'", ",", "'('", ",", "'['", ")", "and", "identifier_value", "[", "-", "1", "]", "in", "(", "'}'", ",", "']'", ",", "')'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.canonicalize_code": [[115, 142], ["ast.parse", "util.replace_identifiers_in_ast", "astor.to_source().strip", "list", "astor.to_source", "slot_map.items", "util.is_enumerable_str", "canonical_code.replace.replace", "slot_map.items"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.replace_identifiers_in_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.is_enumerable_str"], ["", "def", "canonicalize_code", "(", "code", ",", "slot_map", ")", ":", "\n", "    ", "string2slot", "=", "{", "x", "[", "'value'", "]", ":", "slot_name", "for", "slot_name", ",", "x", "in", "list", "(", "slot_map", ".", "items", "(", ")", ")", "}", "\n", "\n", "py_ast", "=", "ast", ".", "parse", "(", "code", ")", "\n", "replace_identifiers_in_ast", "(", "py_ast", ",", "string2slot", ")", "\n", "canonical_code", "=", "astor", ".", "to_source", "(", "py_ast", ")", ".", "strip", "(", ")", "\n", "\n", "# the following code handles the special case that", "\n", "# a list/dict/set mentioned in the intent, like", "\n", "# Intent: zip two lists `[1, 2]` and `[3, 4]` into a list of two tuples containing elements at the same index in each list", "\n", "# Code: zip([1, 2], [3, 4])", "\n", "\n", "entries_that_are_lists", "=", "[", "slot_name", "for", "slot_name", ",", "val", "in", "slot_map", ".", "items", "(", ")", "if", "is_enumerable_str", "(", "val", "[", "'value'", "]", ")", "]", "\n", "if", "entries_that_are_lists", ":", "\n", "        ", "for", "slot_name", "in", "entries_that_are_lists", ":", "\n", "            ", "list_repr", "=", "slot_map", "[", "slot_name", "]", "[", "'value'", "]", "\n", "#if list_repr[0] == '[' and list_repr[-1] == ']':", "\n", "first_token", "=", "list_repr", "[", "0", "]", "# e.g. `[`", "\n", "last_token", "=", "list_repr", "[", "-", "1", "]", "# e.g., `]`", "\n", "fake_list", "=", "first_token", "+", "slot_name", "+", "last_token", "\n", "slot_map", "[", "fake_list", "]", "=", "slot_map", "[", "slot_name", "]", "\n", "# else:", "\n", "#     fake_list = slot_name", "\n", "\n", "canonical_code", "=", "canonical_code", ".", "replace", "(", "list_repr", ",", "fake_list", ")", "\n", "\n", "", "", "return", "canonical_code", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.decanonicalize_code": [[144, 157], ["slot_map.items", "ast.parse", "util.replace_identifiers_in_ast", "astor.to_source().strip", "util.is_enumerable_str", "code.replace.replace", "list", "astor.to_source", "slot_map.items"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.replace_identifiers_in_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.is_enumerable_str"], ["", "def", "decanonicalize_code", "(", "code", ",", "slot_map", ")", ":", "\n", "    ", "for", "slot_name", ",", "slot_val", "in", "slot_map", ".", "items", "(", ")", ":", "\n", "        ", "if", "is_enumerable_str", "(", "slot_name", ")", ":", "\n", "            ", "code", "=", "code", ".", "replace", "(", "slot_name", ",", "slot_val", "[", "'value'", "]", ")", "\n", "\n", "", "", "slot2string", "=", "{", "x", "[", "0", "]", ":", "x", "[", "1", "]", "[", "'value'", "]", "for", "x", "in", "list", "(", "slot_map", ".", "items", "(", ")", ")", "}", "\n", "py_ast", "=", "ast", ".", "parse", "(", "code", ")", "\n", "replace_identifiers_in_ast", "(", "py_ast", ",", "slot2string", ")", "\n", "raw_code", "=", "astor", ".", "to_source", "(", "py_ast", ")", ".", "strip", "(", ")", "\n", "# for slot_name, slot_info in slot_map.items():", "\n", "#     raw_code = raw_code.replace(slot_name, slot_info['value'])", "\n", "\n", "return", "raw_code", "\n", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.__init__": [[17, 21], ["components.evaluator.Evaluator.__init__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["", "def", "evaluate_dataset", "(", "self", ",", "examples", ",", "decode_results", ",", "fast_mode", "=", "False", ")", ":", "\n", "        ", "correct_array", "=", "[", "]", "\n", "oracle_array", "=", "[", "]", "\n", "for", "example", ",", "hyp_list", "in", "zip", "(", "examples", ",", "decode_results", ")", ":", "\n", "            ", "if", "fast_mode", ":", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.is_hyp_correct": [[22, 31], ["ast.parse", "astor.to_source().strip", "evaluator.ConalaEvaluator.transition_system.tokenize_code", "evaluator.ConalaEvaluator.transition_system.tokenize_code", "astor.to_source"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["                ", "hyp_list", "=", "hyp_list", "[", ":", "1", "]", "\n", "\n", "", "if", "hyp_list", ":", "\n", "                ", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyp_list", ")", ":", "\n", "                    ", "try", ":", "\n", "                        ", "is_correct", "=", "self", ".", "is_hyp_correct", "(", "example", ",", "hyp", ")", "\n", "", "except", ":", "\n", "                        ", "is_correct", "=", "False", "\n", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.get_sentence_bleu": [[32, 36], ["nltk.translate.bleu_score.sentence_bleu", "conala_eval.tokenize_for_bleu_eval", "conala_eval.tokenize_for_bleu_eval", "nltk.translate.bleu_score.SmoothingFunction"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval"], ["print", "(", "'Error in evaluating Example %s, hyp %d {{ %s }}'", "%", "(", "example", ".", "idx", ",", "hyp_id", ",", "hyp", ".", "code", ")", ",", "\n", "file", "=", "sys", ".", "stdout", ")", "\n", "\n", "print", "(", "'example id: %s, hypothesis id: %d'", "%", "(", "example", ".", "idx", ",", "hyp_id", ")", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "traceback", ".", "print_exc", "(", "file", "=", "sys", ".", "stdout", ")", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.evaluate_dataset": [[38, 133], ["open", "isinstance", "len", "len", "hasattr", "hasattr", "enumerate", "bleu_score.compute_bleu", "zip", "bleu_score.compute_bleu", "bleu_score.compute_bleu", "numpy.average", "numpy.average", "numpy.average", "setattr", "nltk.translate.bleu_score.SmoothingFunction", "tokenized_ref_snippets.append", "numpy.average.append", "hyp_code_tokens.append", "sent_bleu_scores.append", "oracle_bleu_scores.append", "best_hyp_code_tokens.append", "sum", "float", "conala_eval.tokenize_for_bleu_eval", "enumerate", "numpy.argmax", "open.write", "any", "len", "hasattr", "nltk.translate.bleu_score.sentence_bleu", "evaluator.ConalaEvaluator.is_hyp_correct", "example_hyp_bleu_scores.append", "util.decanonicalize_code", "zip", "conala_eval.tokenize_for_bleu_eval", "filtered_hyp_list.append"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score.compute_bleu", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score.compute_bleu", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.bleu_score.compute_bleu", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.evaluator.ConalaEvaluator.is_hyp_correct", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.util.decanonicalize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.conala.conala_eval.tokenize_for_bleu_eval"], ["\n", "", "hyp", ".", "is_correct", "=", "is_correct", "\n", "\n", "", "correct_array", ".", "append", "(", "hyp_list", "[", "0", "]", ".", "is_correct", ")", "\n", "oracle_array", ".", "append", "(", "any", "(", "hyp", ".", "is_correct", "for", "hyp", "in", "hyp_list", ")", ")", "\n", "", "else", ":", "\n", "                ", "correct_array", ".", "append", "(", "False", ")", "\n", "oracle_array", ".", "append", "(", "False", ")", "\n", "\n", "", "", "acc", "=", "np", ".", "average", "(", "correct_array", ")", "\n", "\n", "oracle_acc", "=", "np", ".", "average", "(", "oracle_array", ")", "\n", "eval_results", "=", "dict", "(", "accuracy", "=", "acc", ",", "\n", "oracle_accuracy", "=", "oracle_acc", ")", "\n", "\n", "return", "eval_results", "\n", "\n", "\n", "", "", "@", "Registrable", ".", "register", "(", "'cached_evaluator'", ")", "\n", "class", "CachedExactMatchEvaluator", "(", "Evaluator", ")", ":", "\n", "    ", "def", "is_hyp_correct", "(", "self", ",", "example", ",", "hyp", ")", ":", "\n", "        ", "raise", "hyp", ".", "is_correct", "\n", "\n", "", "def", "evaluate_dataset", "(", "self", ",", "examples", ",", "decode_results", ",", "fast_mode", "=", "False", ")", ":", "\n", "        ", "if", "fast_mode", ":", "\n", "            ", "acc", "=", "sum", "(", "hyps", "[", "0", "]", ".", "is_correct", "for", "hyps", "in", "decode_results", "if", "len", "(", "hyps", ")", ">", "0", ")", "/", "float", "(", "len", "(", "examples", ")", ")", "\n", "return", "acc", "\n", "\n", "", "acc_array", "=", "[", "]", "\n", "oracle_array", "=", "[", "]", "\n", "for", "hyp_list", "in", "decode_results", ":", "\n", "            ", "acc_array", ".", "append", "(", "hyp_list", "[", "0", "]", ".", "is_correct", "if", "hyp_list", "else", "False", ")", "\n", "oracle_array", ".", "append", "(", "any", "(", "hyp", ".", "is_correct", "for", "hyp", "in", "hyp_list", ")", ")", "\n", "\n", "", "return", "dict", "(", "accuracy", "=", "np", ".", "average", "(", "acc_array", ")", ",", "\n", "oracle_array", "=", "np", ".", "average", "(", "oracle_array", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.__init__": [[9, 19], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "self", ".", "tree", "=", "None", "\n", "self", ".", "actions", "=", "[", "]", "\n", "self", ".", "score", "=", "0.", "\n", "self", ".", "frontier_node", "=", "None", "\n", "self", ".", "frontier_field", "=", "None", "\n", "self", ".", "_value_buffer", "=", "[", "]", "\n", "\n", "# record the current time step", "\n", "self", ".", "t", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.apply_action": [[20, 73], ["hypothesis.Hypothesis.actions.append", "isinstance", "asdl_ast.AbstractSyntaxTree", "hypothesis.Hypothesis.update_frontier_info", "isinstance", "isinstance", "isinstance", "asdl_ast.AbstractSyntaxTree", "hypothesis.Hypothesis.frontier_field.add_value", "hypothesis.Hypothesis.update_frontier_info", "isinstance", "isinstance", "hypothesis.Hypothesis.frontier_field.set_finish", "hypothesis.Hypothesis.update_frontier_info", "ValueError", "action.is_stop_signal", "hypothesis.Hypothesis.frontier_field.add_value", "hypothesis.Hypothesis.frontier_field.set_finish", "hypothesis.Hypothesis.update_frontier_info", "hypothesis.Hypothesis.frontier_field.set_finish", "hypothesis.Hypothesis.update_frontier_info", "ValueError", "hypothesis.Hypothesis.frontier_field.add_value", "hypothesis.Hypothesis._value_buffer.append"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.set_finish", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.GenTokenAction.is_stop_signal", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.set_finish", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.set_finish", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value"], ["", "def", "apply_action", "(", "self", ",", "action", ")", ":", "\n", "        ", "if", "self", ".", "tree", "is", "None", ":", "\n", "            ", "assert", "isinstance", "(", "action", ",", "ApplyRuleAction", ")", ",", "'Invalid action [%s], only ApplyRule action is valid '", "'at the beginning of decoding'", "\n", "\n", "self", ".", "tree", "=", "AbstractSyntaxTree", "(", "action", ".", "production", ")", "\n", "self", ".", "update_frontier_info", "(", ")", "\n", "", "elif", "self", ".", "frontier_node", ":", "\n", "            ", "if", "isinstance", "(", "self", ".", "frontier_field", ".", "type", ",", "ASDLCompositeType", ")", ":", "\n", "                ", "if", "isinstance", "(", "action", ",", "ApplyRuleAction", ")", ":", "\n", "                    ", "field_value", "=", "AbstractSyntaxTree", "(", "action", ".", "production", ")", "\n", "field_value", ".", "created_time", "=", "self", ".", "t", "\n", "self", ".", "frontier_field", ".", "add_value", "(", "field_value", ")", "\n", "self", ".", "update_frontier_info", "(", ")", "\n", "", "elif", "isinstance", "(", "action", ",", "ReduceAction", ")", ":", "\n", "                    ", "assert", "self", ".", "frontier_field", ".", "cardinality", "in", "(", "'optional'", ",", "'multiple'", ")", ",", "'Reduce action can only be '", "'applied on field with multiple '", "'cardinality'", "\n", "self", ".", "frontier_field", ".", "set_finish", "(", ")", "\n", "self", ".", "update_frontier_info", "(", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'Invalid action [%s] on field [%s]'", "%", "(", "action", ",", "self", ".", "frontier_field", ")", ")", "\n", "", "", "else", ":", "# fill in a primitive field", "\n", "                ", "if", "isinstance", "(", "action", ",", "GenTokenAction", ")", ":", "\n", "# only field of type string requires termination signal </primitive>", "\n", "                    ", "end_primitive", "=", "False", "\n", "if", "self", ".", "frontier_field", ".", "type", ".", "name", "==", "'string'", ":", "\n", "                        ", "if", "action", ".", "is_stop_signal", "(", ")", ":", "\n", "                            ", "self", ".", "frontier_field", ".", "add_value", "(", "' '", ".", "join", "(", "self", ".", "_value_buffer", ")", ")", "\n", "self", ".", "_value_buffer", "=", "[", "]", "\n", "\n", "end_primitive", "=", "True", "\n", "", "else", ":", "\n", "                            ", "self", ".", "_value_buffer", ".", "append", "(", "action", ".", "token", ")", "\n", "", "", "else", ":", "\n", "                        ", "self", ".", "frontier_field", ".", "add_value", "(", "action", ".", "token", ")", "\n", "end_primitive", "=", "True", "\n", "\n", "", "if", "end_primitive", "and", "self", ".", "frontier_field", ".", "cardinality", "in", "(", "'single'", ",", "'optional'", ")", ":", "\n", "                        ", "self", ".", "frontier_field", ".", "set_finish", "(", ")", "\n", "self", ".", "update_frontier_info", "(", ")", "\n", "\n", "", "", "elif", "isinstance", "(", "action", ",", "ReduceAction", ")", ":", "\n", "                    ", "assert", "self", ".", "frontier_field", ".", "cardinality", "in", "(", "'optional'", ",", "'multiple'", ")", ",", "'Reduce action can only be '", "'applied on field with multiple '", "'cardinality'", "\n", "self", ".", "frontier_field", ".", "set_finish", "(", ")", "\n", "self", ".", "update_frontier_info", "(", ")", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'Can only invoke GenToken or Reduce actions on primitive fields'", ")", "\n", "\n", "", "", "", "self", ".", "t", "+=", "1", "\n", "self", ".", "actions", ".", "append", "(", "action", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info": [[74, 99], ["hypothesis.Hypothesis.update_frontier_info._find_frontier_node_and_field"], "methods", ["None"], ["", "def", "update_frontier_info", "(", "self", ")", ":", "\n", "        ", "def", "_find_frontier_node_and_field", "(", "tree_node", ")", ":", "\n", "            ", "if", "tree_node", ":", "\n", "                ", "for", "field", "in", "tree_node", ".", "fields", ":", "\n", "# if it's an intermediate node, check its children", "\n", "                    ", "if", "isinstance", "(", "field", ".", "type", ",", "ASDLCompositeType", ")", "and", "field", ".", "value", ":", "\n", "                        ", "if", "field", ".", "cardinality", "in", "(", "'single'", ",", "'optional'", ")", ":", "iter_values", "=", "[", "field", ".", "value", "]", "\n", "else", ":", "iter_values", "=", "field", ".", "value", "\n", "\n", "for", "child_node", "in", "iter_values", ":", "\n", "                            ", "result", "=", "_find_frontier_node_and_field", "(", "child_node", ")", "\n", "if", "result", ":", "return", "result", "\n", "\n", "# now all its possible children are checked", "\n", "", "", "if", "not", "field", ".", "finished", ":", "\n", "                        ", "return", "tree_node", ",", "field", "\n", "\n", "", "", "return", "None", "\n", "", "else", ":", "return", "None", "\n", "\n", "", "frontier_info", "=", "_find_frontier_node_and_field", "(", "self", ".", "tree", ")", "\n", "if", "frontier_info", ":", "\n", "            ", "self", ".", "frontier_node", ",", "self", ".", "frontier_field", "=", "frontier_info", "\n", "", "else", ":", "\n", "            ", "self", ".", "frontier_node", ",", "self", ".", "frontier_field", "=", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.clone_and_apply_action": [[100, 105], ["hypothesis.Hypothesis.copy", "hypothesis.Hypothesis.apply_action"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.copy", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.apply_action"], ["", "", "def", "clone_and_apply_action", "(", "self", ",", "action", ")", ":", "\n", "        ", "new_hyp", "=", "self", ".", "copy", "(", ")", "\n", "new_hyp", ".", "apply_action", "(", "action", ")", "\n", "\n", "return", "new_hyp", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.copy": [[106, 119], ["hypothesis.Hypothesis", "list", "list", "hypothesis.Hypothesis.update_frontier_info", "hypothesis.Hypothesis.tree.copy"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.update_frontier_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.copy"], ["", "def", "copy", "(", "self", ")", ":", "\n", "        ", "new_hyp", "=", "Hypothesis", "(", ")", "\n", "if", "self", ".", "tree", ":", "\n", "            ", "new_hyp", ".", "tree", "=", "self", ".", "tree", ".", "copy", "(", ")", "\n", "\n", "", "new_hyp", ".", "actions", "=", "list", "(", "self", ".", "actions", ")", "\n", "new_hyp", ".", "score", "=", "self", ".", "score", "\n", "new_hyp", ".", "_value_buffer", "=", "list", "(", "self", ".", "_value_buffer", ")", "\n", "new_hyp", ".", "t", "=", "self", ".", "t", "\n", "\n", "new_hyp", ".", "update_frontier_info", "(", ")", "\n", "\n", "return", "new_hyp", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.hypothesis.Hypothesis.completed": [[120, 123], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "completed", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "tree", "and", "self", ".", "frontier_field", "is", "None", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.__init__": [[12, 34], ["collections.OrderedDict", "dict", "sum", "asdl.ASDLGrammar._productions[].append", "list", "len", "enumerate", "enumerate", "enumerate", "enumerate", "enumerate", "enumerate", "asdl.ASDLGrammar._productions.values"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "productions", ")", ":", "\n", "# productions are indexed by their head types", "\n", "        ", "self", ".", "_productions", "=", "OrderedDict", "(", ")", "\n", "self", ".", "_constructor_production_map", "=", "dict", "(", ")", "\n", "for", "prod", "in", "productions", ":", "\n", "            ", "if", "prod", ".", "type", "not", "in", "self", ".", "_productions", ":", "\n", "                ", "self", ".", "_productions", "[", "prod", ".", "type", "]", "=", "list", "(", ")", "\n", "", "self", ".", "_productions", "[", "prod", ".", "type", "]", ".", "append", "(", "prod", ")", "\n", "self", ".", "_constructor_production_map", "[", "prod", ".", "constructor", ".", "name", "]", "=", "prod", "\n", "\n", "", "self", ".", "root_type", "=", "productions", "[", "0", "]", ".", "type", "\n", "# number of constructors", "\n", "self", ".", "size", "=", "sum", "(", "len", "(", "head", ")", "for", "head", "in", "self", ".", "_productions", ".", "values", "(", ")", ")", "\n", "\n", "# get entities to their ids map", "\n", "self", ".", "prod2id", "=", "{", "prod", ":", "i", "for", "i", ",", "prod", "in", "enumerate", "(", "self", ".", "productions", ")", "}", "\n", "self", ".", "type2id", "=", "{", "type", ":", "i", "for", "i", ",", "type", "in", "enumerate", "(", "self", ".", "types", ")", "}", "\n", "self", ".", "field2id", "=", "{", "field", ":", "i", "for", "i", ",", "field", "in", "enumerate", "(", "self", ".", "fields", ")", "}", "\n", "\n", "self", ".", "id2prod", "=", "{", "i", ":", "prod", "for", "i", ",", "prod", "in", "enumerate", "(", "self", ".", "productions", ")", "}", "\n", "self", ".", "id2type", "=", "{", "i", ":", "type", "for", "i", ",", "type", "in", "enumerate", "(", "self", ".", "types", ")", "}", "\n", "self", ".", "id2field", "=", "{", "i", ":", "field", "for", "i", ",", "field", "in", "enumerate", "(", "self", ".", "fields", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.__len__": [[35, 37], ["None"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.productions": [[38, 41], ["sorted", "itertools.chain.from_iterable", "asdl.ASDLGrammar._productions.values", "repr"], "methods", ["None"], ["", "@", "property", "\n", "def", "productions", "(", "self", ")", ":", "\n", "        ", "return", "sorted", "(", "chain", ".", "from_iterable", "(", "self", ".", "_productions", ".", "values", "(", ")", ")", ",", "key", "=", "lambda", "x", ":", "repr", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.__getitem__": [[42, 47], ["isinstance", "isinstance", "asdl.ASDLType"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "datum", ")", ":", "\n", "        ", "if", "isinstance", "(", "datum", ",", "str", ")", ":", "\n", "            ", "return", "self", ".", "_productions", "[", "ASDLType", "(", "datum", ")", "]", "\n", "", "elif", "isinstance", "(", "datum", ",", "ASDLType", ")", ":", "\n", "            ", "return", "self", ".", "_productions", "[", "datum", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name": [[48, 50], ["None"], "methods", ["None"], ["", "", "def", "get_prod_by_ctr_name", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "self", ".", "_constructor_production_map", "[", "name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.types": [[51, 62], ["hasattr", "set", "sorted", "set.add", "set.update", "map"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.add"], ["", "@", "property", "\n", "def", "types", "(", "self", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'_types'", ")", ":", "\n", "            ", "all_types", "=", "set", "(", ")", "\n", "for", "prod", "in", "self", ".", "productions", ":", "\n", "                ", "all_types", ".", "add", "(", "prod", ".", "type", ")", "\n", "all_types", ".", "update", "(", "map", "(", "lambda", "x", ":", "x", ".", "type", ",", "prod", ".", "constructor", ".", "fields", ")", ")", "\n", "\n", "", "self", ".", "_types", "=", "sorted", "(", "all_types", ",", "key", "=", "lambda", "x", ":", "x", ".", "name", ")", "\n", "\n", "", "return", "self", ".", "_types", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.fields": [[63, 73], ["hasattr", "set", "sorted", "set.update"], "methods", ["None"], ["", "@", "property", "\n", "def", "fields", "(", "self", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "'_fields'", ")", ":", "\n", "            ", "all_fields", "=", "set", "(", ")", "\n", "for", "prod", "in", "self", ".", "productions", ":", "\n", "                ", "all_fields", ".", "update", "(", "prod", ".", "constructor", ".", "fields", ")", "\n", "\n", "", "self", ".", "_fields", "=", "sorted", "(", "all_fields", ",", "key", "=", "lambda", "x", ":", "(", "x", ".", "name", ",", "x", ".", "type", ".", "name", ",", "x", ".", "cardinality", ")", ")", "\n", "\n", "", "return", "self", ".", "_fields", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.primitive_types": [[74, 77], ["filter", "isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "primitive_types", "(", "self", ")", ":", "\n", "        ", "return", "filter", "(", "lambda", "x", ":", "isinstance", "(", "x", ",", "ASDLPrimitiveType", ")", ",", "self", ".", "types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.composite_types": [[78, 81], ["filter", "isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "composite_types", "(", "self", ")", ":", "\n", "        ", "return", "filter", "(", "lambda", "x", ":", "isinstance", "(", "x", ",", "ASDLCompositeType", ")", ",", "self", ".", "types", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type": [[82, 84], ["None"], "methods", ["None"], ["", "def", "is_composite_type", "(", "self", ",", "asdl_type", ")", ":", "\n", "        ", "return", "asdl_type", "in", "self", ".", "composite_types", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_primitive_type": [[85, 87], ["None"], "methods", ["None"], ["", "def", "is_primitive_type", "(", "self", ",", "asdl_type", ")", ":", "\n", "        ", "return", "asdl_type", "in", "self", ".", "primitive_types", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.from_text": [[88, 160], ["utils.remove_comment().split", "list", "list", "list", "list", "asdl.ASDLGrammar", "_text.strip.strip.strip().split", "d[].strip", "d[].strip", "_text.strip.strip.strip", "asdl.ASDLConstructor", "map", "filter", "map", "type_block[].strip", "type_block[].split", "filter", "map", "list", "list.extend", "asdl.Field", "asdl.Field", "_text[].split", "map", "utils.remove_comment", "lines[].split", "lines[].strip().startswith", "lines[].strip", "t[].split", "filter.extend", "asdl.ASDLPrimitiveType", "asdl.ASDLCompositeType", "map", "len", "_text.strip.strip.strip", "asdl.ASDLPrimitiveType", "asdl.ASDLCompositeType", "l.strip", "x.strip", "len", "_text.strip.strip.find", "lines[].strip", "x.strip", "asdl.ASDLProduction", "type_block.find", "_text.strip.strip.find", "type_block.find", "_text.strip.strip.find"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.utils.remove_comment"], ["", "@", "staticmethod", "\n", "def", "from_text", "(", "text", ")", ":", "\n", "        ", "def", "_parse_field_from_text", "(", "_text", ")", ":", "\n", "            ", "d", "=", "_text", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "name", "=", "d", "[", "1", "]", ".", "strip", "(", ")", "\n", "type_str", "=", "d", "[", "0", "]", ".", "strip", "(", ")", "\n", "cardinality", "=", "'single'", "\n", "if", "type_str", "[", "-", "1", "]", "==", "'*'", ":", "\n", "                ", "type_str", "=", "type_str", "[", ":", "-", "1", "]", "\n", "cardinality", "=", "'multiple'", "\n", "", "elif", "type_str", "[", "-", "1", "]", "==", "'?'", ":", "\n", "                ", "type_str", "=", "type_str", "[", ":", "-", "1", "]", "\n", "cardinality", "=", "'optional'", "\n", "\n", "", "if", "type_str", "in", "primitive_type_names", ":", "\n", "                ", "return", "Field", "(", "name", ",", "ASDLPrimitiveType", "(", "type_str", ")", ",", "cardinality", "=", "cardinality", ")", "\n", "", "else", ":", "\n", "                ", "return", "Field", "(", "name", ",", "ASDLCompositeType", "(", "type_str", ")", ",", "cardinality", "=", "cardinality", ")", "\n", "\n", "", "", "def", "_parse_constructor_from_text", "(", "_text", ")", ":", "\n", "            ", "_text", "=", "_text", ".", "strip", "(", ")", "\n", "fields", "=", "None", "\n", "if", "'('", "in", "_text", ":", "\n", "                ", "name", "=", "_text", "[", ":", "_text", ".", "find", "(", "'('", ")", "]", "\n", "field_blocks", "=", "_text", "[", "_text", ".", "find", "(", "'('", ")", "+", "1", ":", "_text", ".", "find", "(", "')'", ")", "]", ".", "split", "(", "','", ")", "\n", "fields", "=", "map", "(", "_parse_field_from_text", ",", "field_blocks", ")", "\n", "", "else", ":", "\n", "                ", "name", "=", "_text", "\n", "\n", "", "if", "name", "==", "''", ":", "name", "=", "None", "\n", "\n", "return", "ASDLConstructor", "(", "name", ",", "fields", ")", "\n", "\n", "", "lines", "=", "remove_comment", "(", "text", ")", ".", "split", "(", "'\\n'", ")", "\n", "lines", "=", "list", "(", "map", "(", "lambda", "l", ":", "l", ".", "strip", "(", ")", ",", "lines", ")", ")", "\n", "lines", "=", "list", "(", "filter", "(", "lambda", "l", ":", "l", ",", "lines", ")", ")", "\n", "line_no", "=", "0", "\n", "\n", "# first line is always the primitive types", "\n", "primitive_type_names", "=", "list", "(", "map", "(", "lambda", "x", ":", "x", ".", "strip", "(", ")", ",", "lines", "[", "line_no", "]", ".", "split", "(", "','", ")", ")", ")", "\n", "line_no", "+=", "1", "\n", "\n", "all_productions", "=", "list", "(", ")", "\n", "\n", "while", "True", ":", "\n", "            ", "type_block", "=", "lines", "[", "line_no", "]", "\n", "type_name", "=", "type_block", "[", ":", "type_block", ".", "find", "(", "'='", ")", "]", ".", "strip", "(", ")", "\n", "constructors_blocks", "=", "type_block", "[", "type_block", ".", "find", "(", "'='", ")", "+", "1", ":", "]", ".", "split", "(", "'|'", ")", "\n", "i", "=", "line_no", "+", "1", "\n", "while", "i", "<", "len", "(", "lines", ")", "and", "lines", "[", "i", "]", ".", "strip", "(", ")", ".", "startswith", "(", "'|'", ")", ":", "\n", "                ", "t", "=", "lines", "[", "i", "]", ".", "strip", "(", ")", "\n", "cont_constructors_blocks", "=", "t", "[", "1", ":", "]", ".", "split", "(", "'|'", ")", "\n", "constructors_blocks", ".", "extend", "(", "cont_constructors_blocks", ")", "\n", "\n", "i", "+=", "1", "\n", "\n", "", "constructors_blocks", "=", "filter", "(", "lambda", "x", ":", "x", "and", "x", ".", "strip", "(", ")", ",", "constructors_blocks", ")", "\n", "\n", "# parse type name", "\n", "new_type", "=", "ASDLPrimitiveType", "(", "type_name", ")", "if", "type_name", "in", "primitive_type_names", "else", "ASDLCompositeType", "(", "type_name", ")", "\n", "constructors", "=", "map", "(", "_parse_constructor_from_text", ",", "constructors_blocks", ")", "\n", "\n", "productions", "=", "list", "(", "map", "(", "lambda", "c", ":", "ASDLProduction", "(", "new_type", ",", "c", ")", ",", "constructors", ")", ")", "\n", "all_productions", ".", "extend", "(", "productions", ")", "\n", "\n", "line_no", "=", "i", "\n", "if", "line_no", "==", "len", "(", "lines", ")", ":", "\n", "                ", "break", "\n", "\n", "", "", "grammar", "=", "ASDLGrammar", "(", "all_productions", ")", "\n", "\n", "return", "grammar", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.__init__": [[163, 166], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "type", ",", "constructor", ")", ":", "\n", "        ", "self", ".", "type", "=", "type", "\n", "self", ".", "constructor", "=", "constructor", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.fields": [[167, 170], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "fields", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "constructor", ".", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.__getitem__": [[171, 173], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "field_name", ")", ":", "\n", "        ", "return", "self", ".", "constructor", "[", "field_name", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.__hash__": [[174, 178], ["hash", "hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "h", "=", "hash", "(", "self", ".", "type", ")", "^", "hash", "(", "self", ".", "constructor", ")", "\n", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.__eq__": [[179, 183], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "isinstance", "(", "other", ",", "ASDLProduction", ")", "and", "self", ".", "type", "==", "other", ".", "type", "and", "self", ".", "constructor", "==", "other", ".", "constructor", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.__ne__": [[184, 186], ["asdl.ASDLProduction.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLProduction.__repr__": [[187, 189], ["asdl.ASDLProduction.type.__repr__", "asdl.ASDLProduction.constructor.__repr__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'%s -> %s'", "%", "(", "self", ".", "type", ".", "__repr__", "(", "plain", "=", "True", ")", ",", "self", ".", "constructor", ".", "__repr__", "(", "plain", "=", "True", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLConstructor.__init__": [[192, 197], ["list"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "fields", "=", "None", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "fields", "=", "[", "]", "\n", "if", "fields", ":", "\n", "            ", "self", ".", "fields", "=", "list", "(", "fields", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLConstructor.__getitem__": [[198, 203], ["None"], "methods", ["None"], ["", "", "def", "__getitem__", "(", "self", ",", "field_name", ")", ":", "\n", "        ", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "if", "field", ".", "name", "==", "field_name", ":", "return", "field", "\n", "\n", "", "raise", "KeyError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLConstructor.__hash__": [[204, 210], ["hash", "hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "h", "=", "hash", "(", "self", ".", "name", ")", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "h", "^=", "hash", "(", "field", ")", "\n", "\n", "", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLConstructor.__eq__": [[211, 215], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "isinstance", "(", "other", ",", "ASDLConstructor", ")", "and", "self", ".", "name", "==", "other", ".", "name", "and", "self", ".", "fields", "==", "other", ".", "fields", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLConstructor.__ne__": [[216, 218], ["asdl.ASDLConstructor.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLConstructor.__repr__": [[219, 224], ["f.__repr__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__"], ["", "def", "__repr__", "(", "self", ",", "plain", "=", "False", ")", ":", "\n", "        ", "plain_repr", "=", "'%s(%s)'", "%", "(", "self", ".", "name", ",", "\n", "', '", ".", "join", "(", "f", ".", "__repr__", "(", "plain", "=", "True", ")", "for", "f", "in", "self", ".", "fields", ")", ")", "\n", "if", "plain", ":", "return", "plain_repr", "\n", "else", ":", "return", "'Constructor(%s)'", "%", "plain_repr", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.__init__": [[227, 233], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "type", ",", "cardinality", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "type", "=", "type", "\n", "\n", "assert", "cardinality", "in", "[", "'single'", ",", "'optional'", ",", "'multiple'", "]", "\n", "self", ".", "cardinality", "=", "cardinality", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.__hash__": [[234, 239], ["hash", "hash", "hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "h", "=", "hash", "(", "self", ".", "name", ")", "^", "hash", "(", "self", ".", "type", ")", "\n", "h", "^=", "hash", "(", "self", ".", "cardinality", ")", "\n", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.__eq__": [[240, 245], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "isinstance", "(", "other", ",", "Field", ")", "and", "self", ".", "name", "==", "other", ".", "name", "and", "self", ".", "type", "==", "other", ".", "type", "and", "self", ".", "cardinality", "==", "other", ".", "cardinality", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.__ne__": [[246, 248], ["asdl.Field.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.__repr__": [[249, 255], ["asdl.Field.type.__repr__", "asdl.Field.get_cardinality_repr"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.get_cardinality_repr"], ["", "def", "__repr__", "(", "self", ",", "plain", "=", "False", ")", ":", "\n", "        ", "plain_repr", "=", "'%s%s %s'", "%", "(", "self", ".", "type", ".", "__repr__", "(", "plain", "=", "True", ")", ",", "\n", "Field", ".", "get_cardinality_repr", "(", "self", ".", "cardinality", ")", ",", "\n", "self", ".", "name", ")", "\n", "if", "plain", ":", "return", "plain_repr", "\n", "else", ":", "return", "'Field(%s)'", "%", "plain_repr", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.get_cardinality_repr": [[256, 259], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "get_cardinality_repr", "(", "cardinality", ")", ":", "\n", "        ", "return", "''", "if", "cardinality", "==", "'single'", "else", "'?'", "if", "cardinality", "==", "'optional'", "else", "'*'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLType.__init__": [[262, 264], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "type_name", ")", ":", "\n", "        ", "self", ".", "name", "=", "type_name", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLType.__hash__": [[265, 267], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLType.__eq__": [[268, 270], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "isinstance", "(", "other", ",", "ASDLType", ")", "and", "self", ".", "name", "==", "other", ".", "name", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLType.__ne__": [[271, 273], ["asdl.ASDLType.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLType.__repr__": [[274, 278], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ",", "plain", "=", "False", ")", ":", "\n", "        ", "plain_repr", "=", "self", ".", "name", "\n", "if", "plain", ":", "return", "plain_repr", "\n", "else", ":", "return", "'%s(%s)'", "%", "(", "self", ".", "__class__", ".", "__name__", ",", "plain_repr", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.__init__": [[12, 32], ["len", "len", "asdl_ast.AbstractSyntaxTree.add_child", "asdl_ast.AbstractSyntaxTree.add_child", "asdl_ast.RealizedField"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.add_child", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.add_child"], ["    ", "def", "__init__", "(", "self", ",", "production", ",", "realized_fields", "=", "None", ")", ":", "\n", "        ", "self", ".", "production", "=", "production", "\n", "\n", "# a child is essentially a *realized_field*", "\n", "self", ".", "fields", "=", "[", "]", "\n", "\n", "# record its parent field to which it's attached", "\n", "self", ".", "parent_field", "=", "None", "\n", "\n", "# used in decoding, record the time step when this node was created", "\n", "self", ".", "created_time", "=", "0", "\n", "\n", "if", "realized_fields", ":", "\n", "            ", "assert", "len", "(", "realized_fields", ")", "==", "len", "(", "self", ".", "production", ".", "fields", ")", "\n", "\n", "for", "field", "in", "realized_fields", ":", "\n", "                ", "self", ".", "add_child", "(", "field", ")", "\n", "", "", "else", ":", "\n", "            ", "for", "field", "in", "self", ".", "production", ".", "fields", ":", "\n", "                ", "self", ".", "add_child", "(", "RealizedField", "(", "field", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.add_child": [[33, 38], ["asdl_ast.AbstractSyntaxTree.fields.append"], "methods", ["None"], ["", "", "", "def", "add_child", "(", "self", ",", "realized_field", ")", ":", "\n", "# if isinstance(realized_field.value, AbstractSyntaxTree):", "\n", "#     realized_field.value.parent = self", "\n", "        ", "self", ".", "fields", ".", "append", "(", "realized_field", ")", "\n", "realized_field", ".", "parent_node", "=", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.__getitem__": [[39, 43], ["None"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "field_name", ")", ":", "\n", "        ", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "if", "field", ".", "name", "==", "field_name", ":", "return", "field", "\n", "", "raise", "KeyError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.sanity_check": [[44, 53], ["zip", "len", "len", "ValueError", "isinstance", "child_val.sanity_check"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.sanity_check"], ["", "def", "sanity_check", "(", "self", ")", ":", "\n", "        ", "if", "len", "(", "self", ".", "production", ".", "fields", ")", "!=", "len", "(", "self", ".", "fields", ")", ":", "\n", "            ", "raise", "ValueError", "(", "'filed number must match'", ")", "\n", "", "for", "field", ",", "realized_field", "in", "zip", "(", "self", ".", "production", ".", "fields", ",", "self", ".", "fields", ")", ":", "\n", "            ", "assert", "field", "==", "realized_field", ".", "field", "\n", "", "for", "child", "in", "self", ".", "fields", ":", "\n", "            ", "for", "child_val", "in", "child", ".", "as_value_list", ":", "\n", "                ", "if", "isinstance", "(", "child_val", ",", "AbstractSyntaxTree", ")", ":", "\n", "                    ", "child_val", ".", "sanity_check", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.copy": [[54, 68], ["asdl_ast.AbstractSyntaxTree", "enumerate", "isinstance", "new_field.add_value", "new_field.add_value", "value.copy"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.copy"], ["", "", "", "", "def", "copy", "(", "self", ")", ":", "\n", "        ", "new_tree", "=", "AbstractSyntaxTree", "(", "self", ".", "production", ")", "\n", "new_tree", ".", "created_time", "=", "self", ".", "created_time", "\n", "for", "i", ",", "old_field", "in", "enumerate", "(", "self", ".", "fields", ")", ":", "\n", "            ", "new_field", "=", "new_tree", ".", "fields", "[", "i", "]", "\n", "new_field", ".", "_not_single_cardinality_finished", "=", "old_field", ".", "_not_single_cardinality_finished", "\n", "if", "isinstance", "(", "old_field", ".", "type", ",", "ASDLCompositeType", ")", ":", "\n", "                ", "for", "value", "in", "old_field", ".", "as_value_list", ":", "\n", "                    ", "new_field", ".", "add_value", "(", "value", ".", "copy", "(", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "value", "in", "old_field", ".", "as_value_list", ":", "\n", "                    ", "new_field", ".", "add_value", "(", "value", ")", "\n", "\n", "", "", "", "return", "new_tree", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.to_string": [[69, 100], ["StringIO.write", "StringIO.write", "StringIO.write", "StringIO", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.getvalue", "asdl.Field.get_cardinality_repr", "StringIO.write", "isinstance", "val_node.to_string", "StringIO.write", "str().replace", "str"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.Field.get_cardinality_repr", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string"], ["", "def", "to_string", "(", "self", ",", "sb", "=", "None", ")", ":", "\n", "        ", "is_root", "=", "False", "\n", "if", "sb", "is", "None", ":", "\n", "            ", "is_root", "=", "True", "\n", "sb", "=", "StringIO", "(", ")", "\n", "\n", "", "sb", ".", "write", "(", "'('", ")", "\n", "sb", ".", "write", "(", "self", ".", "production", ".", "constructor", ".", "name", ")", "\n", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "sb", ".", "write", "(", "' '", ")", "\n", "sb", ".", "write", "(", "'('", ")", "\n", "sb", ".", "write", "(", "field", ".", "type", ".", "name", ")", "\n", "sb", ".", "write", "(", "Field", ".", "get_cardinality_repr", "(", "field", ".", "cardinality", ")", ")", "\n", "sb", ".", "write", "(", "'-'", ")", "\n", "sb", ".", "write", "(", "field", ".", "name", ")", "\n", "\n", "if", "field", ".", "value", "is", "not", "None", ":", "\n", "                ", "for", "val_node", "in", "field", ".", "as_value_list", ":", "\n", "                    ", "sb", ".", "write", "(", "' '", ")", "\n", "if", "isinstance", "(", "field", ".", "type", ",", "ASDLCompositeType", ")", ":", "\n", "                        ", "val_node", ".", "to_string", "(", "sb", ")", "\n", "", "else", ":", "\n", "                        ", "sb", ".", "write", "(", "str", "(", "val_node", ")", ".", "replace", "(", "' '", ",", "'-SPACE-'", ")", ")", "\n", "\n", "", "", "", "sb", ".", "write", "(", "')'", ")", "# of field", "\n", "\n", "", "sb", ".", "write", "(", "')'", ")", "# of node", "\n", "\n", "if", "is_root", ":", "\n", "            ", "return", "sb", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.__hash__": [[101, 107], ["hash", "hash"], "methods", ["None"], ["", "", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "code", "=", "hash", "(", "self", ".", "production", ")", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "code", "=", "code", "+", "37", "*", "hash", "(", "field", ")", "\n", "\n", "", "return", "code", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.__eq__": [[108, 125], ["range", "isinstance", "len", "len", "len"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "other", ",", "self", ".", "__class__", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "self", ".", "created_time", "!=", "other", ".", "created_time", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "self", ".", "production", "!=", "other", ".", "production", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "len", "(", "self", ".", "fields", ")", "!=", "len", "(", "other", ".", "fields", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "self", ".", "fields", ")", ")", ":", "\n", "            ", "if", "self", ".", "fields", "[", "i", "]", "!=", "other", ".", "fields", "[", "i", "]", ":", "return", "False", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.__ne__": [[126, 128], ["asdl_ast.AbstractSyntaxTree.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.__repr__": [[129, 131], ["repr"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "repr", "(", "self", ".", "production", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size": [[132, 142], ["isinstance"], "methods", ["None"], ["", "@", "property", "\n", "def", "size", "(", "self", ")", ":", "\n", "        ", "node_num", "=", "1", "\n", "for", "field", "in", "self", ".", "fields", ":", "\n", "            ", "for", "val", "in", "field", ".", "as_value_list", ":", "\n", "                ", "if", "isinstance", "(", "val", ",", "AbstractSyntaxTree", ")", ":", "\n", "                    ", "node_num", "+=", "val", ".", "size", "\n", "", "else", ":", "node_num", "+=", "1", "\n", "\n", "", "", "return", "node_num", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.__init__": [[146, 169], ["asdl.Field.__init__", "asdl_ast.RealizedField.add_value", "asdl_ast.RealizedField.add_value"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value"], ["def", "__init__", "(", "self", ",", "field", ",", "value", "=", "None", ",", "parent", "=", "None", ")", ":", "\n", "        ", "super", "(", "RealizedField", ",", "self", ")", ".", "__init__", "(", "field", ".", "name", ",", "field", ".", "type", ",", "field", ".", "cardinality", ")", "\n", "\n", "# record its parent AST node", "\n", "self", ".", "parent_node", "=", "None", "\n", "\n", "# FIXME: hack, return the field as a property", "\n", "self", ".", "field", "=", "field", "\n", "\n", "# initialize value to correct type", "\n", "if", "self", ".", "cardinality", "==", "'multiple'", ":", "\n", "            ", "self", ".", "value", "=", "[", "]", "\n", "if", "value", "is", "not", "None", ":", "\n", "                ", "for", "child_node", "in", "value", ":", "\n", "                    ", "self", ".", "add_value", "(", "child_node", ")", "\n", "", "", "", "else", ":", "\n", "            ", "self", ".", "value", "=", "None", "\n", "# note the value could be 0!", "\n", "if", "value", "is", "not", "None", ":", "self", ".", "add_value", "(", "value", ")", "\n", "\n", "# properties only used in decoding, record if the field is finished generating", "\n", "# when card in [optional, multiple]", "\n", "", "self", ".", "_not_single_cardinality_finished", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value": [[170, 178], ["isinstance", "asdl_ast.RealizedField.value.append"], "methods", ["None"], ["", "def", "add_value", "(", "self", ",", "value", ")", ":", "\n", "        ", "if", "isinstance", "(", "value", ",", "AbstractSyntaxTree", ")", ":", "\n", "            ", "value", ".", "parent_field", "=", "self", "\n", "\n", "", "if", "self", ".", "cardinality", "==", "'multiple'", ":", "\n", "            ", "self", ".", "value", ".", "append", "(", "value", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "value", "=", "value", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.as_value_list": [[179, 185], ["None"], "methods", ["None"], ["", "", "@", "property", "\n", "def", "as_value_list", "(", "self", ")", ":", "\n", "        ", "\"\"\"get value as an iterable\"\"\"", "\n", "if", "self", ".", "cardinality", "==", "'multiple'", ":", "return", "self", ".", "value", "\n", "elif", "self", ".", "value", "is", "not", "None", ":", "return", "[", "self", ".", "value", "]", "\n", "else", ":", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.finished": [[186, 196], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "finished", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "cardinality", "==", "'single'", ":", "\n", "            ", "if", "self", ".", "value", "is", "None", ":", "return", "False", "\n", "else", ":", "return", "True", "\n", "", "elif", "self", ".", "cardinality", "==", "'optional'", "and", "self", ".", "value", "is", "not", "None", ":", "\n", "            ", "return", "True", "\n", "", "else", ":", "\n", "            ", "if", "self", ".", "_not_single_cardinality_finished", ":", "return", "True", "\n", "else", ":", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.set_finish": [[197, 200], ["None"], "methods", ["None"], ["", "", "def", "set_finish", "(", "self", ")", ":", "\n", "# assert self.cardinality in ('optional', 'multiple')", "\n", "        ", "self", ".", "_not_single_cardinality_finished", "=", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.__eq__": [[201, 207], ["asdl.Field.__eq__", "type"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "super", "(", "RealizedField", ",", "self", ")", ".", "__eq__", "(", "other", ")", ":", "\n", "            ", "if", "type", "(", "other", ")", "==", "Field", ":", "return", "True", "# FIXME: hack, Field and RealizedField can compare!", "\n", "if", "self", ".", "value", "==", "other", ".", "value", ":", "return", "True", "\n", "else", ":", "return", "False", "\n", "", "else", ":", "return", "False", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.utils.remove_comment": [[5, 10], ["re.sub", "re.compile", "filter", "re.sub.split"], "function", ["None"], ["    ", "\"\"\"\n    Process a raw input utterance using domain-specific procedures (e.g., stemming),\n    and post-process a generated hypothesis to the final form\n    \"\"\"", "\n", "def", "pre_process_utterance", "(", "self", ",", "utterance", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.ApplyRuleAction.__init__": [[9, 11], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "production", ")", ":", "\n", "        ", "self", ".", "production", "=", "production", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.ApplyRuleAction.__hash__": [[12, 14], ["hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "return", "hash", "(", "self", ".", "production", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.ApplyRuleAction.__eq__": [[15, 17], ["isinstance"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "isinstance", "(", "other", ",", "ApplyRuleAction", ")", "and", "self", ".", "production", "==", "other", ".", "production", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.ApplyRuleAction.__ne__": [[18, 20], ["transition_system.ApplyRuleAction.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.ApplyRuleAction.__repr__": [[21, 23], ["transition_system.ApplyRuleAction.production.__repr__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'ApplyRule[%s]'", "%", "self", ".", "production", ".", "__repr__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.GenTokenAction.__init__": [[26, 28], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "token", ")", ":", "\n", "        ", "self", ".", "token", "=", "token", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.GenTokenAction.is_stop_signal": [[29, 31], ["None"], "methods", ["None"], ["", "def", "is_stop_signal", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "token", "==", "'</primitive>'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.GenTokenAction.__repr__": [[32, 34], ["None"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'GenToken[%s]'", "%", "self", ".", "token", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.ReduceAction.__repr__": [[37, 39], ["None"], "methods", ["None"], ["   ", "def", "__repr__", "(", "self", ")", ":", "\n", "       ", "return", "'Reduce'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.__init__": [[42, 44], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "grammar", ")", ":", "\n", "        ", "self", ".", "grammar", "=", "grammar", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_actions": [[45, 85], ["transition_system.ApplyRuleAction", "actions.append", "transition_system.TransitionSystem.grammar.is_composite_type", "actions.extend", "transition_system.TransitionSystem.get_primitive_field_actions", "transition_system.TransitionSystem.get_actions", "transition_system.TransitionSystem.append", "transition_system.TransitionSystem.append", "transition_system.ReduceAction", "transition_system.ReduceAction", "transition_system.TransitionSystem.get_actions", "transition_system.TransitionSystem.extend", "transition_system.TransitionSystem.get_actions"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.get_primitive_field_actions", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_actions", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_actions", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_actions"], ["", "def", "get_actions", "(", "self", ",", "asdl_ast", ")", ":", "\n", "        ", "\"\"\"\n        generate action sequence given the ASDL Syntax Tree\n        \"\"\"", "\n", "\n", "actions", "=", "[", "]", "\n", "\n", "parent_action", "=", "ApplyRuleAction", "(", "asdl_ast", ".", "production", ")", "\n", "actions", ".", "append", "(", "parent_action", ")", "\n", "\n", "for", "field", "in", "asdl_ast", ".", "fields", ":", "\n", "# is a composite field", "\n", "            ", "if", "self", ".", "grammar", ".", "is_composite_type", "(", "field", ".", "type", ")", ":", "\n", "                ", "if", "field", ".", "cardinality", "==", "'single'", ":", "\n", "                    ", "field_actions", "=", "self", ".", "get_actions", "(", "field", ".", "value", ")", "\n", "", "else", ":", "\n", "                    ", "field_actions", "=", "[", "]", "\n", "\n", "if", "field", ".", "value", "is", "not", "None", ":", "\n", "                        ", "if", "field", ".", "cardinality", "==", "'multiple'", ":", "\n", "                            ", "for", "val", "in", "field", ".", "value", ":", "\n", "                                ", "cur_child_actions", "=", "self", ".", "get_actions", "(", "val", ")", "\n", "field_actions", ".", "extend", "(", "cur_child_actions", ")", "\n", "", "", "elif", "field", ".", "cardinality", "==", "'optional'", ":", "\n", "                            ", "field_actions", "=", "self", ".", "get_actions", "(", "field", ".", "value", ")", "\n", "\n", "# if an optional field is filled, then do not need Reduce action", "\n", "", "", "if", "field", ".", "cardinality", "==", "'multiple'", "or", "field", ".", "cardinality", "==", "'optional'", "and", "not", "field_actions", ":", "\n", "                        ", "field_actions", ".", "append", "(", "ReduceAction", "(", ")", ")", "\n", "", "", "", "else", ":", "# is a primitive field", "\n", "                ", "field_actions", "=", "self", ".", "get_primitive_field_actions", "(", "field", ")", "\n", "\n", "# if an optional field is filled, then do not need Reduce action", "\n", "if", "field", ".", "cardinality", "==", "'multiple'", "or", "field", ".", "cardinality", "==", "'optional'", "and", "not", "field_actions", ":", "\n", "# reduce action", "\n", "                    ", "field_actions", ".", "append", "(", "ReduceAction", "(", ")", ")", "\n", "\n", "", "", "actions", ".", "extend", "(", "field_actions", ")", "\n", "\n", "", "return", "actions", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.tokenize_code": [[86, 88], ["None"], "methods", ["None"], ["", "def", "tokenize_code", "(", "self", ",", "code", ",", "mode", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.compare_ast": [[89, 91], ["None"], "methods", ["None"], ["", "def", "compare_ast", "(", "self", ",", "hyp_ast", ",", "ref_ast", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.ast_to_surface_code": [[92, 94], ["None"], "methods", ["None"], ["", "def", "ast_to_surface_code", "(", "self", ",", "asdl_ast", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.surface_code_to_ast": [[95, 97], ["None"], "methods", ["None"], ["", "def", "surface_code_to_ast", "(", "self", ",", "code", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_primitive_field_actions": [[98, 100], ["None"], "methods", ["None"], ["", "def", "get_primitive_field_actions", "(", "self", ",", "realized_field", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_valid_continuation_types": [[101, 120], ["transition_system.TransitionSystem.grammar.is_composite_type"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type"], ["", "def", "get_valid_continuation_types", "(", "self", ",", "hyp", ")", ":", "\n", "        ", "if", "hyp", ".", "tree", ":", "\n", "            ", "if", "self", ".", "grammar", ".", "is_composite_type", "(", "hyp", ".", "frontier_field", ".", "type", ")", ":", "\n", "                ", "if", "hyp", ".", "frontier_field", ".", "cardinality", "==", "'single'", ":", "\n", "                    ", "return", "ApplyRuleAction", ",", "\n", "", "else", ":", "# optional, multiple", "\n", "                    ", "return", "ApplyRuleAction", ",", "ReduceAction", "\n", "", "", "else", ":", "\n", "                ", "if", "hyp", ".", "frontier_field", ".", "cardinality", "==", "'single'", ":", "\n", "                    ", "return", "GenTokenAction", ",", "\n", "", "elif", "hyp", ".", "frontier_field", ".", "cardinality", "==", "'optional'", ":", "\n", "                    ", "if", "hyp", ".", "_value_buffer", ":", "\n", "                        ", "return", "GenTokenAction", ",", "\n", "", "else", ":", "\n", "                        ", "return", "GenTokenAction", ",", "ReduceAction", "\n", "", "", "else", ":", "\n", "                    ", "return", "GenTokenAction", ",", "ReduceAction", "\n", "", "", "", "else", ":", "\n", "            ", "return", "ApplyRuleAction", ",", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_valid_continuating_productions": [[121, 129], ["transition_system.TransitionSystem.grammar.is_composite_type"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type"], ["", "", "def", "get_valid_continuating_productions", "(", "self", ",", "hyp", ")", ":", "\n", "        ", "if", "hyp", ".", "tree", ":", "\n", "            ", "if", "self", ".", "grammar", ".", "is_composite_type", "(", "hyp", ".", "frontier_field", ".", "type", ")", ":", "\n", "                ", "return", "self", ".", "grammar", "[", "hyp", ".", "frontier_field", ".", "type", "]", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "\n", "", "", "else", ":", "\n", "            ", "return", "self", ".", "grammar", "[", "self", ".", "grammar", ".", "root_type", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_class_by_lang": [[130, 146], ["ValueError"], "methods", ["None"], ["", "", "@", "staticmethod", "\n", "def", "get_class_by_lang", "(", "lang", ")", ":", "\n", "        ", "if", "lang", "==", "'python'", ":", "\n", "            ", "from", ".", "lang", ".", "py", ".", "py_transition_system", "import", "PythonTransitionSystem", "\n", "return", "PythonTransitionSystem", "\n", "", "elif", "lang", "==", "'python3'", ":", "\n", "            ", "from", ".", "lang", ".", "py3", ".", "py3_transition_system", "import", "Python3TransitionSystem", "\n", "return", "Python3TransitionSystem", "\n", "", "elif", "lang", "==", "'lambda_dcs'", ":", "\n", "            ", "from", ".", "lang", ".", "lambda_dcs", ".", "lambda_dcs_transition_system", "import", "LambdaCalculusTransitionSystem", "\n", "return", "LambdaCalculusTransitionSystem", "\n", "", "elif", "lang", "==", "'prolog'", ":", "\n", "            ", "from", ".", "lang", ".", "prolog", ".", "prolog_transition_system", "import", "PrologTransitionSystem", "\n", "return", "PrologTransitionSystem", "\n", "\n", "", "raise", "ValueError", "(", "'unknown language %s'", "%", "lang", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py3.py3_transition_system.Python3TransitionSystem.tokenize_code": [[16, 18], ["asdl.lang.py.py_utils.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["    ", "def", "tokenize_code", "(", "self", ",", "code", ",", "mode", "=", "None", ")", ":", "\n", "        ", "return", "tokenize_code", "(", "code", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py3.py3_transition_system.Python3TransitionSystem.surface_code_to_ast": [[19, 22], ["ast.parse", "asdl.lang.py.py_asdl_helper.python_ast_to_asdl_ast"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.python_ast_to_asdl_ast"], ["", "def", "surface_code_to_ast", "(", "self", ",", "code", ")", ":", "\n", "        ", "py_ast", "=", "ast", ".", "parse", "(", "code", ")", "\n", "return", "python_ast_to_asdl_ast", "(", "py_ast", ",", "self", ".", "grammar", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py3.py3_transition_system.Python3TransitionSystem.ast_to_surface_code": [[23, 36], ["asdl.lang.py.py_asdl_helper.asdl_ast_to_python_ast", "astor.to_source().strip", "astor.to_source().strip.endswith", "astor.to_source"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast"], ["", "def", "ast_to_surface_code", "(", "self", ",", "asdl_ast", ")", ":", "\n", "        ", "py_ast", "=", "asdl_ast_to_python_ast", "(", "asdl_ast", ",", "self", ".", "grammar", ")", "\n", "code", "=", "astor", ".", "to_source", "(", "py_ast", ")", ".", "strip", "(", ")", "\n", "\n", "if", "code", ".", "endswith", "(", "':'", ")", ":", "\n", "            ", "code", "+=", "' pass'", "\n", "\n", "# first make sure the hypothesis code is parsable by `ast`", "\n", "# sometimes, the parser generates syntactically invalid surface code:", "\n", "# e.g., slot_0.1()", "\n", "# ast.parse(code)", "\n", "\n", "", "return", "code", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py3.py3_transition_system.Python3TransitionSystem.compare_ast": [[37, 45], ["py3_transition_system.Python3TransitionSystem.ast_to_surface_code", "py3_transition_system.Python3TransitionSystem.ast_to_surface_code", "asdl.lang.py.py_utils.tokenize_code", "asdl.lang.py.py_utils.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "compare_ast", "(", "self", ",", "hyp_ast", ",", "ref_ast", ")", ":", "\n", "        ", "hyp_code", "=", "self", ".", "ast_to_surface_code", "(", "hyp_ast", ")", "\n", "ref_reformatted_code", "=", "self", ".", "ast_to_surface_code", "(", "ref_ast", ")", "\n", "\n", "ref_code_tokens", "=", "tokenize_code", "(", "ref_reformatted_code", ")", "\n", "hyp_code_tokens", "=", "tokenize_code", "(", "hyp_code", ")", "\n", "\n", "return", "ref_code_tokens", "==", "hyp_code_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py3.py3_transition_system.Python3TransitionSystem.get_primitive_field_actions": [[46, 69], ["actions.append", "actions.append", "tokens.extend", "tokens.append", "asdl.transition_system.GenTokenAction", "asdl.transition_system.GenTokenAction", "field_val.split"], "methods", ["None"], ["", "def", "get_primitive_field_actions", "(", "self", ",", "realized_field", ")", ":", "\n", "        ", "actions", "=", "[", "]", "\n", "if", "realized_field", ".", "value", "is", "not", "None", ":", "\n", "            ", "if", "realized_field", ".", "cardinality", "==", "'multiple'", ":", "# expr -> Global(identifier* names)", "\n", "                ", "field_values", "=", "realized_field", ".", "value", "\n", "", "else", ":", "\n", "                ", "field_values", "=", "[", "realized_field", ".", "value", "]", "\n", "\n", "", "tokens", "=", "[", "]", "\n", "if", "realized_field", ".", "type", ".", "name", "==", "'string'", ":", "\n", "                ", "for", "field_val", "in", "field_values", ":", "\n", "                    ", "tokens", ".", "extend", "(", "field_val", ".", "split", "(", "' '", ")", "+", "[", "'</primitive>'", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "field_val", "in", "field_values", ":", "\n", "                    ", "tokens", ".", "append", "(", "field_val", ")", "\n", "\n", "", "", "for", "tok", "in", "tokens", ":", "\n", "                ", "actions", ".", "append", "(", "GenTokenAction", "(", "tok", ")", ")", "\n", "", "", "elif", "realized_field", ".", "type", ".", "name", "==", "'singleton'", "and", "realized_field", ".", "value", "is", "None", ":", "\n", "# singleton can be None", "\n", "            ", "actions", ".", "append", "(", "GenTokenAction", "(", "'None'", ")", ")", "\n", "\n", "", "return", "actions", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py3.py3_transition_system.Python3TransitionSystem.is_valid_hypothesis": [[70, 78], ["py3_transition_system.Python3TransitionSystem.ast_to_surface_code", "ast.parse", "py3_transition_system.Python3TransitionSystem.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "is_valid_hypothesis", "(", "self", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "hyp_code", "=", "self", ".", "ast_to_surface_code", "(", "hyp", ".", "tree", ")", "\n", "ast", ".", "parse", "(", "hyp_code", ")", "\n", "self", ".", "tokenize_code", "(", "hyp_code", ")", "\n", "", "except", ":", "\n", "            ", "return", "False", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_utils.tokenize_code": [[13, 42], ["tokenize.generate_tokens", "StringIO", "tokens.append", "tokens.append", "tokens.append", "tokens.append", "tokens.append", "tokens.append", "tokens.append"], "function", ["None"], ["def", "tokenize_code", "(", "code", ",", "mode", "=", "None", ")", ":", "\n", "    ", "token_stream", "=", "generate_tokens", "(", "StringIO", "(", "code", ")", ".", "readline", ")", "\n", "tokens", "=", "[", "]", "\n", "for", "toknum", ",", "tokval", ",", "(", "srow", ",", "scol", ")", ",", "(", "erow", ",", "ecol", ")", ",", "_", "in", "token_stream", ":", "\n", "        ", "if", "toknum", "==", "tk", ".", "ENDMARKER", ":", "\n", "            ", "break", "\n", "\n", "", "if", "mode", "==", "'decoder'", ":", "\n", "            ", "if", "toknum", "==", "tk", ".", "STRING", ":", "\n", "                ", "quote", "=", "tokval", "[", "0", "]", "\n", "tokval", "=", "tokval", "[", "1", ":", "-", "1", "]", "\n", "tokens", ".", "append", "(", "quote", ")", "\n", "tokens", ".", "append", "(", "tokval", ")", "\n", "tokens", ".", "append", "(", "quote", ")", "\n", "", "elif", "toknum", "==", "tk", ".", "DEDENT", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "tokens", ".", "append", "(", "tokval", ")", "\n", "", "", "elif", "mode", "==", "'canonicalize'", ":", "\n", "            ", "if", "toknum", "==", "tk", ".", "STRING", ":", "\n", "                ", "tokens", ".", "append", "(", "'_STR_'", ")", "\n", "", "elif", "toknum", "==", "tk", ".", "DEDENT", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "tokens", ".", "append", "(", "tokval", ")", "\n", "", "", "else", ":", "\n", "            ", "tokens", ".", "append", "(", "tokval", ")", "\n", "\n", "", "", "return", "tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_transition_system.PythonTransitionSystem.tokenize_code": [[16, 18], ["asdl.lang.py.py_utils.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["    ", "def", "tokenize_code", "(", "self", ",", "code", ",", "mode", "=", "None", ")", ":", "\n", "        ", "return", "tokenize_code", "(", "code", ",", "mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_transition_system.PythonTransitionSystem.surface_code_to_ast": [[19, 22], ["asdl.lang.py.py_asdl_helper.python_ast_to_asdl_ast", "ast.parse"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.python_ast_to_asdl_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse"], ["", "def", "surface_code_to_ast", "(", "self", ",", "code", ")", ":", "\n", "        ", "py_ast", "=", "ast", ".", "parse", "(", "code", ")", ".", "body", "[", "0", "]", "\n", "return", "python_ast_to_asdl_ast", "(", "py_ast", ",", "self", ".", "grammar", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_transition_system.PythonTransitionSystem.ast_to_surface_code": [[23, 28], ["asdl.lang.py.py_asdl_helper.asdl_ast_to_python_ast", "astor.to_source().strip", "astor.to_source"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast"], ["", "def", "ast_to_surface_code", "(", "self", ",", "asdl_ast", ")", ":", "\n", "        ", "py_ast", "=", "asdl_ast_to_python_ast", "(", "asdl_ast", ",", "self", ".", "grammar", ")", "\n", "code", "=", "astor", ".", "to_source", "(", "py_ast", ")", ".", "strip", "(", ")", "\n", "\n", "return", "code", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_transition_system.PythonTransitionSystem.compare_ast": [[29, 37], ["py_transition_system.PythonTransitionSystem.ast_to_surface_code", "py_transition_system.PythonTransitionSystem.ast_to_surface_code", "asdl.lang.py.py_utils.tokenize_code", "asdl.lang.py.py_utils.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "compare_ast", "(", "self", ",", "hyp_ast", ",", "ref_ast", ")", ":", "\n", "        ", "hyp_code", "=", "self", ".", "ast_to_surface_code", "(", "hyp_ast", ")", "\n", "ref_reformatted_code", "=", "self", ".", "ast_to_surface_code", "(", "ref_ast", ")", "\n", "\n", "ref_code_tokens", "=", "tokenize_code", "(", "ref_reformatted_code", ")", "\n", "hyp_code_tokens", "=", "tokenize_code", "(", "hyp_code", ")", "\n", "\n", "return", "ref_code_tokens", "==", "hyp_code_tokens", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_transition_system.PythonTransitionSystem.get_primitive_field_actions": [[38, 58], ["actions.append", "tokens.extend", "tokens.append", "asdl.transition_system.GenTokenAction", "field_val.split"], "methods", ["None"], ["", "def", "get_primitive_field_actions", "(", "self", ",", "realized_field", ")", ":", "\n", "        ", "actions", "=", "[", "]", "\n", "if", "realized_field", ".", "value", "is", "not", "None", ":", "\n", "            ", "if", "realized_field", ".", "cardinality", "==", "'multiple'", ":", "# expr -> Global(identifier* names)", "\n", "                ", "field_values", "=", "realized_field", ".", "value", "\n", "", "else", ":", "\n", "                ", "field_values", "=", "[", "realized_field", ".", "value", "]", "\n", "\n", "", "tokens", "=", "[", "]", "\n", "if", "realized_field", ".", "type", ".", "name", "==", "'string'", ":", "\n", "                ", "for", "field_val", "in", "field_values", ":", "\n", "                    ", "tokens", ".", "extend", "(", "field_val", ".", "split", "(", "' '", ")", "+", "[", "'</primitive>'", "]", ")", "\n", "", "", "else", ":", "\n", "                ", "for", "field_val", "in", "field_values", ":", "\n", "                    ", "tokens", ".", "append", "(", "field_val", ")", "\n", "\n", "", "", "for", "tok", "in", "tokens", ":", "\n", "                ", "actions", ".", "append", "(", "GenTokenAction", "(", "tok", ")", ")", "\n", "\n", "", "", "return", "actions", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_transition_system.PythonTransitionSystem.is_valid_hypothesis": [[59, 67], ["py_transition_system.PythonTransitionSystem.ast_to_surface_code", "ast.parse", "py_transition_system.PythonTransitionSystem.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "is_valid_hypothesis", "(", "self", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "hyp_code", "=", "self", ".", "ast_to_surface_code", "(", "hyp", ".", "tree", ")", "\n", "ast", ".", "parse", "(", "hyp_code", ")", "\n", "self", ".", "tokenize_code", "(", "hyp_code", ")", "\n", "", "except", ":", "\n", "            ", "return", "False", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.isfloat": [[9, 16], ["float"], "function", ["None"], ["def", "isfloat", "(", "x", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "a", "=", "float", "(", "x", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.isint": [[18, 26], ["float", "int"], "function", ["None"], ["", "", "def", "isint", "(", "x", ")", ":", "\n", "    ", "try", ":", "\n", "        ", "a", "=", "float", "(", "x", ")", "\n", "b", "=", "int", "(", "a", ")", "\n", "", "except", "ValueError", ":", "\n", "        ", "return", "False", "\n", "", "else", ":", "\n", "        ", "return", "a", "==", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.python_ast_to_asdl_ast": [[28, 61], ["grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "type", "getattr", "asdl.asdl_ast.RealizedField", "fields.append", "grammar.is_composite_type", "grammar.is_composite_type", "py_asdl_helper.python_ast_to_asdl_ast", "asdl.asdl_ast.RealizedField.add_value", "asdl.asdl_ast.RealizedField.add_value", "str", "py_asdl_helper.python_ast_to_asdl_ast", "asdl.asdl_ast.RealizedField.add_value", "asdl.asdl_ast.RealizedField.add_value", "str"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.python_ast_to_asdl_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.python_ast_to_asdl_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.RealizedField.add_value"], ["", "", "def", "python_ast_to_asdl_ast", "(", "py_ast_node", ",", "grammar", ")", ":", "\n", "# node should be composite", "\n", "    ", "py_node_name", "=", "type", "(", "py_ast_node", ")", ".", "__name__", "\n", "# assert py_node_name.startswith('_ast.')", "\n", "\n", "production", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "py_node_name", ")", "\n", "\n", "fields", "=", "[", "]", "\n", "for", "field", "in", "production", ".", "fields", ":", "\n", "        ", "field_value", "=", "getattr", "(", "py_ast_node", ",", "field", ".", "name", ")", "\n", "asdl_field", "=", "RealizedField", "(", "field", ")", "\n", "if", "field", ".", "cardinality", "==", "'single'", "or", "field", ".", "cardinality", "==", "'optional'", ":", "\n", "            ", "if", "field_value", "is", "not", "None", ":", "# sometimes it could be 0", "\n", "                ", "if", "grammar", ".", "is_composite_type", "(", "field", ".", "type", ")", ":", "\n", "                    ", "child_node", "=", "python_ast_to_asdl_ast", "(", "field_value", ",", "grammar", ")", "\n", "asdl_field", ".", "add_value", "(", "child_node", ")", "\n", "", "else", ":", "\n", "                    ", "asdl_field", ".", "add_value", "(", "str", "(", "field_value", ")", ")", "\n", "# field with multiple cardinality", "\n", "", "", "", "elif", "field_value", "is", "not", "None", ":", "\n", "                ", "if", "grammar", ".", "is_composite_type", "(", "field", ".", "type", ")", ":", "\n", "                    ", "for", "val", "in", "field_value", ":", "\n", "                        ", "child_node", "=", "python_ast_to_asdl_ast", "(", "val", ",", "grammar", ")", "\n", "asdl_field", ".", "add_value", "(", "child_node", ")", "\n", "", "", "else", ":", "\n", "                    ", "for", "val", "in", "field_value", ":", "\n", "                        ", "asdl_field", ".", "add_value", "(", "str", "(", "val", ")", ")", "\n", "\n", "", "", "", "fields", ".", "append", "(", "asdl_field", ")", "\n", "\n", "", "asdl_node", "=", "AbstractSyntaxTree", "(", "production", ",", "realized_fields", "=", "fields", ")", "\n", "\n", "return", "asdl_node", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast": [[63, 104], ["getattr", "getattr.", "grammar.is_composite_type", "setattr", "list", "py_asdl_helper.asdl_ast_to_python_ast", "int.append", "py_asdl_helper.asdl_ast_to_python_ast", "float", "py_asdl_helper.isint", "int", "int", "ValueError"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.is_composite_type", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.asdl_ast_to_python_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.py.py_asdl_helper.isint"], ["", "def", "asdl_ast_to_python_ast", "(", "asdl_ast_node", ",", "grammar", ")", ":", "\n", "    ", "py_node_type", "=", "getattr", "(", "sys", ".", "modules", "[", "'ast'", "]", ",", "asdl_ast_node", ".", "production", ".", "constructor", ".", "name", ")", "\n", "py_ast_node", "=", "py_node_type", "(", ")", "\n", "\n", "for", "field", "in", "asdl_ast_node", ".", "fields", ":", "\n", "# for composite node", "\n", "        ", "field_value", "=", "None", "\n", "if", "grammar", ".", "is_composite_type", "(", "field", ".", "type", ")", ":", "\n", "            ", "if", "field", ".", "value", "and", "field", ".", "cardinality", "==", "'multiple'", ":", "\n", "                ", "field_value", "=", "[", "]", "\n", "for", "val", "in", "field", ".", "value", ":", "\n", "                    ", "node", "=", "asdl_ast_to_python_ast", "(", "val", ",", "grammar", ")", "\n", "field_value", ".", "append", "(", "node", ")", "\n", "", "", "elif", "field", ".", "value", "and", "field", ".", "cardinality", "in", "(", "'single'", ",", "'optional'", ")", ":", "\n", "                ", "field_value", "=", "asdl_ast_to_python_ast", "(", "field", ".", "value", ",", "grammar", ")", "\n", "", "", "else", ":", "\n", "# for primitive node, note that primitive field may have `None` value", "\n", "            ", "if", "field", ".", "value", "is", "not", "None", ":", "\n", "                ", "if", "field", ".", "type", ".", "name", "==", "'object'", ":", "\n", "                    ", "if", "'.'", "in", "field", ".", "value", "or", "'e'", "in", "field", ".", "value", ":", "\n", "                        ", "field_value", "=", "float", "(", "field", ".", "value", ")", "\n", "", "elif", "isint", "(", "field", ".", "value", ")", ":", "\n", "                        ", "field_value", "=", "int", "(", "field", ".", "value", ")", "\n", "", "else", ":", "\n", "                        ", "raise", "ValueError", "(", "'cannot convert [%s] to float or int'", "%", "field", ".", "value", ")", "\n", "", "", "elif", "field", ".", "type", ".", "name", "==", "'int'", ":", "\n", "                    ", "field_value", "=", "int", "(", "field", ".", "value", ")", "\n", "", "else", ":", "\n", "                    ", "field_value", "=", "field", ".", "value", "\n", "\n", "# FIXME: hack! if int? is missing value in ImportFrom(identifier? module, alias* names, int? level), fill with 0", "\n", "", "", "elif", "field", ".", "name", "==", "'level'", ":", "\n", "                ", "field_value", "=", "0", "\n", "\n", "# must set unused fields to default value...", "\n", "", "", "if", "field_value", "is", "None", "and", "field", ".", "cardinality", "==", "'multiple'", ":", "\n", "            ", "field_value", "=", "list", "(", ")", "\n", "\n", "", "setattr", "(", "py_ast_node", ",", "field", ".", "name", ",", "field_value", ")", "\n", "\n", "", "return", "py_ast_node", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.tokenize_code": [[12, 14], ["code.strip().split", "code.strip"], "methods", ["None"], ["    ", "def", "tokenize_code", "(", "self", ",", "code", ",", "mode", "=", "None", ")", ":", "\n", "        ", "return", "code", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.surface_code_to_ast": [[15, 17], ["logical_form.logical_form_to_ast", "logical_form.parse_lambda_expr"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.parse_lambda_expr"], ["", "def", "surface_code_to_ast", "(", "self", ",", "code", ")", ":", "\n", "        ", "return", "logical_form_to_ast", "(", "self", ".", "grammar", ",", "parse_lambda_expr", "(", "code", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.compare_ast": [[18, 23], ["logical_form.ast_to_logical_form", "logical_form.ast_to_logical_form"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form"], ["", "def", "compare_ast", "(", "self", ",", "hyp_ast", ",", "ref_ast", ")", ":", "\n", "        ", "ref_lf", "=", "ast_to_logical_form", "(", "ref_ast", ")", "\n", "hyp_lf", "=", "ast_to_logical_form", "(", "hyp_ast", ")", "\n", "\n", "return", "ref_lf", "==", "hyp_lf", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.ast_to_surface_code": [[24, 29], ["logical_form.ast_to_logical_form", "logical_form.ast_to_logical_form.to_string"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string"], ["", "def", "ast_to_surface_code", "(", "self", ",", "asdl_ast", ")", ":", "\n", "        ", "lf", "=", "ast_to_logical_form", "(", "asdl_ast", ")", "\n", "code", "=", "lf", ".", "to_string", "(", ")", "\n", "\n", "return", "code", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.get_primitive_field_actions": [[30, 36], ["asdl.transition_system.GenTokenAction"], "methods", ["None"], ["", "def", "get_primitive_field_actions", "(", "self", ",", "realized_field", ")", ":", "\n", "        ", "assert", "realized_field", ".", "cardinality", "==", "'single'", "\n", "if", "realized_field", ".", "value", "is", "not", "None", ":", "\n", "            ", "return", "[", "GenTokenAction", "(", "realized_field", ".", "value", ")", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.lambda_dcs_transition_system.LambdaCalculusTransitionSystem.is_valid_hypothesis": [[37, 39], ["None"], "methods", ["None"], ["", "", "def", "is_valid_hypothesis", "(", "self", ",", "hyp", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__init__": [[80, 92], ["list", "isinstance", "isinstance", "logical_form.Node.add_child", "logical_form.Node.add_child", "ValueError"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.add_child", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.add_child"], ["    ", "def", "__init__", "(", "self", ",", "name", ",", "children", "=", "None", ")", ":", "\n", "        ", "self", ".", "name", "=", "name", "\n", "self", ".", "parent", "=", "None", "\n", "self", ".", "children", "=", "list", "(", ")", "\n", "if", "children", ":", "\n", "            ", "if", "isinstance", "(", "children", ",", "Iterable", ")", ":", "\n", "                ", "for", "child", "in", "children", ":", "\n", "                    ", "self", ".", "add_child", "(", "child", ")", "\n", "", "", "elif", "isinstance", "(", "children", ",", "Node", ")", ":", "\n", "                ", "self", ".", "add_child", "(", "children", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Wrong type for child nodes'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.add_child": [[93, 96], ["logical_form.Node.children.append"], "methods", ["None"], ["", "", "", "def", "add_child", "(", "self", ",", "child", ")", ":", "\n", "        ", "child", ".", "parent", "=", "self", "\n", "self", ".", "children", ".", "append", "(", "child", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__hash__": [[97, 104], ["hash", "hash"], "methods", ["None"], ["", "def", "__hash__", "(", "self", ")", ":", "\n", "        ", "code", "=", "hash", "(", "self", ".", "name", ")", "\n", "\n", "for", "child", "in", "self", ".", "children", ":", "\n", "            ", "code", "=", "code", "*", "37", "+", "hash", "(", "child", ")", "\n", "\n", "", "return", "code", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__": [[105, 119], ["isinstance", "len", "len", "sorted", "sorted"], "methods", ["None"], ["", "def", "__eq__", "(", "self", ",", "other", ")", ":", "\n", "        ", "if", "not", "isinstance", "(", "other", ",", "self", ".", "__class__", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "self", ".", "name", "!=", "other", ".", "name", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "len", "(", "self", ".", "children", ")", "!=", "len", "(", "other", ".", "children", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "self", ".", "name", "==", "'and'", "or", "self", ".", "name", "==", "'or'", ":", "\n", "            ", "return", "sorted", "(", "self", ".", "children", ",", "key", "=", "lambda", "x", ":", "x", ".", "name", ")", "==", "sorted", "(", "other", ".", "children", ",", "key", "=", "lambda", "x", ":", "x", ".", "name", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "children", "==", "other", ".", "children", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__ne__": [[120, 122], ["logical_form.Node.__eq__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__eq__"], ["", "", "def", "__ne__", "(", "self", ",", "other", ")", ":", "\n", "        ", "return", "not", "self", ".", "__eq__", "(", "other", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__": [[123, 125], ["len"], "methods", ["None"], ["", "def", "__repr__", "(", "self", ")", ":", "\n", "        ", "return", "'Node[%s, %d children]'", "%", "(", "self", ".", "name", ",", "len", "(", "self", ".", "children", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.is_leaf": [[126, 129], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_leaf", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "children", ")", "==", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string": [[130, 150], ["StringIO", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.getvalue", "StringIO.write", "child.to_string"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string"], ["", "def", "to_string", "(", "self", ",", "sb", "=", "None", ")", ":", "\n", "        ", "is_root", "=", "False", "\n", "if", "sb", "is", "None", ":", "\n", "            ", "is_root", "=", "True", "\n", "sb", "=", "StringIO", "(", ")", "\n", "\n", "", "if", "self", ".", "is_leaf", ":", "\n", "            ", "sb", ".", "write", "(", "self", ".", "name", ")", "\n", "", "else", ":", "\n", "            ", "sb", ".", "write", "(", "'( '", ")", "\n", "sb", ".", "write", "(", "self", ".", "name", ")", "\n", "\n", "for", "child", "in", "self", ".", "children", ":", "\n", "                ", "sb", ".", "write", "(", "' '", ")", "\n", "child", ".", "to_string", "(", "sb", ")", "\n", "\n", "", "sb", ".", "write", "(", "' )'", ")", "\n", "\n", "", "if", "is_root", ":", "\n", "            ", "return", "sb", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.parse_lambda_expr_helper": [[15, 48], ["logical_form.Node", "logical_form.Node", "logical_form.Node.add_child", "len", "ValueError", "logical_form.parse_lambda_expr_helper"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.add_child", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.parse_lambda_expr_helper"], ["def", "parse_lambda_expr_helper", "(", "s", ",", "offset", ")", ":", "\n", "    ", "if", "s", "[", "offset", "]", "!=", "'('", ":", "\n", "        ", "name", "=", "''", "\n", "while", "offset", "<", "len", "(", "s", ")", "and", "s", "[", "offset", "]", "!=", "' '", ":", "\n", "            ", "name", "+=", "s", "[", "offset", "]", "\n", "offset", "+=", "1", "\n", "\n", "", "node", "=", "Node", "(", "name", ")", "\n", "return", "node", ",", "offset", "\n", "", "else", ":", "\n", "# it's a sub-tree", "\n", "        ", "offset", "+=", "2", "\n", "name", "=", "''", "\n", "while", "s", "[", "offset", "]", "!=", "' '", ":", "\n", "            ", "name", "+=", "s", "[", "offset", "]", "\n", "offset", "+=", "1", "\n", "\n", "", "node", "=", "Node", "(", "name", ")", "\n", "# extract its child nodes", "\n", "\n", "while", "True", ":", "\n", "            ", "if", "s", "[", "offset", "]", "!=", "' '", ":", "\n", "                ", "raise", "ValueError", "(", "'malformed string: node should have either had a '", "\n", "'close paren or a space at position %d'", "%", "offset", ")", "\n", "\n", "", "offset", "+=", "1", "\n", "if", "s", "[", "offset", "]", "==", "')'", ":", "\n", "                ", "offset", "+=", "1", "\n", "return", "node", ",", "offset", "\n", "", "else", ":", "\n", "                ", "child_node", ",", "offset", "=", "parse_lambda_expr_helper", "(", "s", ",", "offset", ")", "\n", "\n", "", "node", ".", "add_child", "(", "child_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.parse_lambda_expr": [[50, 52], ["logical_form.parse_lambda_expr_helper"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.parse_lambda_expr_helper"], ["", "", "", "def", "parse_lambda_expr", "(", "s", ")", ":", "\n", "    ", "return", "parse_lambda_expr_helper", "(", "s", ",", "0", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.get_canonical_order_of_logical_form": [[54, 77], ["copy.deepcopy", "logical_form.get_canonical_order_of_logical_form._order"], "function", ["None"], ["", "def", "get_canonical_order_of_logical_form", "(", "lf", ",", "order_by", "=", "'alphabet'", ",", "_get_order", "=", "None", ")", ":", "\n", "    ", "lf_copy", "=", "copy", ".", "deepcopy", "(", "lf", ")", "\n", "\n", "if", "_get_order", "is", "None", ":", "\n", "        ", "def", "_get_order", "(", "name", ")", ":", "\n", "            ", "if", "name", "==", "'flight'", ":", "\n", "                ", "return", "-", "200", "\n", "", "elif", "name", "==", "'from'", ":", "\n", "                ", "return", "-", "199", "\n", "", "elif", "name", "==", "'to'", ":", "\n", "                ", "return", "-", "198", "\n", "\n", "", "return", "name", "\n", "\n", "", "", "def", "_order", "(", "_lf", ")", ":", "\n", "        ", "if", "_lf", ".", "name", "in", "(", "'and'", ",", "'or'", ")", ":", "\n", "            ", "_lf", ".", "children", "=", "sorted", "(", "_lf", ".", "children", ",", "key", "=", "lambda", "x", ":", "_get_order", "(", "x", ".", "name", ")", ")", "\n", "", "for", "child", "in", "_lf", ".", "children", ":", "\n", "            ", "_order", "(", "child", ")", "\n", "\n", "", "", "_order", "(", "lf_copy", ")", "\n", "\n", "return", "lf_copy", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast": [[152, 304], ["grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "lf_node.name.title", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "lf_node.name.title", "logical_form.logical_form_to_ast", "arg_ast_nodes.append", "grammar.get_prod_by_ctr_name", "logical_form.logical_form_to_ast", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "lf_node.name.startswith", "grammar.get_prod_by_ctr_name", "logical_form.logical_form_to_ast", "arg_ast_nodes.append", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "lf_node.name.endswith", "lf_node.name.endswith", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "logical_form.logical_form_to_ast", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "lf_node.name.title"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.logical_form_to_ast"], ["", "", "", "def", "logical_form_to_ast", "(", "grammar", ",", "lf_node", ")", ":", "\n", "    ", "if", "lf_node", ".", "name", "==", "'lambda'", ":", "\n", "# expr -> Lambda(var variable, var_type type, expr body)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Lambda'", ")", "\n", "\n", "var_node", "=", "lf_node", ".", "children", "[", "0", "]", "\n", "var_field", "=", "RealizedField", "(", "prod", "[", "'variable'", "]", ",", "var_node", ".", "name", ")", "\n", "\n", "var_type_node", "=", "lf_node", ".", "children", "[", "1", "]", "\n", "var_type_field", "=", "RealizedField", "(", "prod", "[", "'type'", "]", ",", "var_type_node", ".", "name", ")", "\n", "\n", "body_node", "=", "lf_node", ".", "children", "[", "2", "]", "\n", "body_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "body_node", ")", "# of type expr", "\n", "body_field", "=", "RealizedField", "(", "prod", "[", "'body'", "]", ",", "body_ast_node", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "var_field", ",", "var_type_field", ",", "body_field", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "==", "'argmax'", "or", "lf_node", ".", "name", "==", "'argmin'", "or", "lf_node", ".", "name", "==", "'sum'", ":", "\n", "# expr -> Argmax|Sum(var variable, expr domain, expr body)", "\n", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "lf_node", ".", "name", ".", "title", "(", ")", ")", "\n", "\n", "var_node", "=", "lf_node", ".", "children", "[", "0", "]", "\n", "var_field", "=", "RealizedField", "(", "prod", "[", "'variable'", "]", ",", "var_node", ".", "name", ")", "\n", "\n", "domain_node", "=", "lf_node", ".", "children", "[", "1", "]", "\n", "domain_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "domain_node", ")", "\n", "domain_field", "=", "RealizedField", "(", "prod", "[", "'domain'", "]", ",", "domain_ast_node", ")", "\n", "\n", "body_node", "=", "lf_node", ".", "children", "[", "2", "]", "\n", "body_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "body_node", ")", "\n", "body_field", "=", "RealizedField", "(", "prod", "[", "'body'", "]", ",", "body_ast_node", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "var_field", ",", "domain_field", ",", "body_field", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "==", "'and'", "or", "lf_node", ".", "name", "==", "'or'", ":", "\n", "# expr -> And(expr* arguments) | Or(expr* arguments)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "lf_node", ".", "name", ".", "title", "(", ")", ")", "\n", "\n", "arg_ast_nodes", "=", "[", "]", "\n", "for", "arg_node", "in", "lf_node", ".", "children", ":", "\n", "            ", "arg_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "arg_node", ")", "\n", "arg_ast_nodes", ".", "append", "(", "arg_ast_node", ")", "\n", "\n", "", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'arguments'", "]", ",", "arg_ast_nodes", ")", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "==", "'not'", ":", "\n", "# expr -> Not(expr argument)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Not'", ")", "\n", "\n", "arg_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "lf_node", ".", "children", "[", "0", "]", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'argument'", "]", ",", "arg_ast_node", ")", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "==", "'>'", "or", "lf_node", ".", "name", "==", "'='", "or", "lf_node", ".", "name", "==", "'<'", ":", "\n", "# expr -> Compare(cmp_op op, expr left, expr right)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Compare'", ")", "\n", "op_name", "=", "'GreaterThan'", "if", "lf_node", ".", "name", "==", "'>'", "else", "'Equal'", "if", "lf_node", ".", "name", "==", "'='", "else", "'LessThan'", "\n", "op_field", "=", "RealizedField", "(", "prod", "[", "'op'", "]", ",", "AbstractSyntaxTree", "(", "grammar", ".", "get_prod_by_ctr_name", "(", "op_name", ")", ")", ")", "\n", "\n", "left_node", "=", "lf_node", ".", "children", "[", "0", "]", "\n", "left_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "left_node", ")", "\n", "left_field", "=", "RealizedField", "(", "prod", "[", "'left'", "]", ",", "left_ast_node", ")", "\n", "\n", "right_node", "=", "lf_node", ".", "children", "[", "1", "]", "\n", "right_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "right_node", ")", "\n", "right_field", "=", "RealizedField", "(", "prod", "[", "'right'", "]", ",", "right_ast_node", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "op_field", ",", "left_field", ",", "right_field", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "in", "[", "'jet'", ",", "'flight'", ",", "'from_airport'", ",", "'airport'", ",", "'airline'", ",", "'airline_name'", ",", "\n", "'class_type'", ",", "'aircraft_code'", ",", "'aircraft_code:t'", ",", "\n", "'from'", ",", "'to'", ",", "'day'", ",", "'month'", ",", "'year'", ",", "'arrival_time'", ",", "'limousine'", ",", "\n", "'departure_time'", ",", "'meal'", ",", "'meal:t'", ",", "'meal_code'", ",", "\n", "'during_day'", ",", "'tomorrow'", ",", "'daily'", ",", "'time_elapsed'", ",", "'time_zone_code'", ",", "\n", "'booking_class:t'", ",", "'booking_class'", ",", "'economy'", ",", "'ground_fare'", ",", "'class_of_service'", ",", "\n", "'capacity'", ",", "'weekday'", ",", "'today'", ",", "'turboprop'", ",", "'aircraft'", ",", "'air_taxi_operation'", ",", "\n", "'month_return'", ",", "'day_return'", ",", "'day_number_return'", ",", "'minimum_connection_time'", ",", "\n", "'during_day_arrival'", ",", "'connecting'", ",", "'minutes_distant'", ",", "\n", "'named'", ",", "'miles_distant'", ",", "'approx_arrival_time'", ",", "'approx_return_time'", ",", "\n", "'approx_departure_time'", ",", "'has_stops'", ",", "\n", "'day_after_tomorrow'", ",", "'manufacturer'", ",", "'discounted'", ",", "'overnight'", ",", "\n", "'nonstop'", ",", "'has_meal'", ",", "'round_trip'", ",", "'oneway'", ",", "'loc:t'", ",", "'ground_transport'", ",", "\n", "'to_city'", ",", "'flight_number'", ",", "'equals:t'", ",", "'abbrev'", ",", "'equals'", ",", "'rapid_transit'", ",", "\n", "'stop_arrival_time'", ",", "'arrival_month'", ",", "'cost'", ",", "\n", "'fare'", ",", "'services'", ",", "'fare_basis_code'", ",", "'rental_car'", ",", "'city'", ",", "'stop'", ",", "'day_number'", ",", "\n", "'days_from_today'", ",", "'after_day'", ",", "'before_day'", ",", "\n", "'airline:e'", ",", "'stops'", ",", "'month_arrival'", ",", "'day_number_arrival'", ",", "'day_arrival'", ",", "'taxi'", ",", "\n", "'next_days'", ",", "'restriction_code'", ",", "'tomorrow_arrival'", ",", "'tonight'", ",", "\n", "'population:i'", ",", "'state:t'", ",", "'next_to:t'", ",", "'elevation:i'", ",", "'size:i'", ",", "'capital:t'", ",", "\n", "'len:i'", ",", "'city:t'", ",", "'named:t'", ",", "'river:t'", ",", "'place:t'", ",", "'capital:c'", ",", "'major:t'", ",", "'town:t'", ",", "\n", "'mountain:t'", ",", "'lake:t'", ",", "'area:i'", ",", "'density:i'", ",", "'high_point:t'", ",", "'elevation:t'", ",", "'population:t'", ",", "\n", "'in:t'", "]", ":", "\n", "# expr -> Apply(pred predicate, expr* arguments)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Apply'", ")", "\n", "\n", "pred_field", "=", "RealizedField", "(", "prod", "[", "'predicate'", "]", ",", "value", "=", "lf_node", ".", "name", ")", "\n", "\n", "arg_ast_nodes", "=", "[", "]", "\n", "for", "arg_node", "in", "lf_node", ".", "children", ":", "\n", "            ", "arg_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "arg_node", ")", "\n", "arg_ast_nodes", ".", "append", "(", "arg_ast_node", ")", "\n", "", "arg_field", "=", "RealizedField", "(", "prod", "[", "'arguments'", "]", ",", "arg_ast_nodes", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "[", "pred_field", ",", "arg_field", "]", ")", "\n", "", "elif", "lf_node", ".", "name", ".", "startswith", "(", "'$'", ")", ":", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Variable'", ")", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'variable'", "]", ",", "value", "=", "lf_node", ".", "name", ")", "]", ")", "\n", "", "elif", "':ap'", "in", "lf_node", ".", "name", "or", "':fb'", "in", "lf_node", ".", "name", "or", "':mf'", "in", "lf_node", ".", "name", "or", "':me'", "in", "lf_node", ".", "name", "or", "':cl'", "in", "lf_node", ".", "name", "or", "':pd'", "in", "lf_node", ".", "name", "or", "':dc'", "in", "lf_node", ".", "name", "or", "':al'", "in", "lf_node", ".", "name", "or", "lf_node", ".", "name", "in", "[", "'yr0'", ",", "'do0'", ",", "'fb1'", ",", "'rc0'", ",", "'ci0'", ",", "'fn0'", ",", "'ap0'", ",", "'al1'", ",", "'al2'", ",", "'ap1'", ",", "'ci1'", ",", "\n", "'ci2'", ",", "'ci3'", ",", "'st0'", ",", "'ti0'", ",", "'ti1'", ",", "'da0'", ",", "'da1'", ",", "'da2'", ",", "'da3'", ",", "'da4'", ",", "'al0'", ",", "\n", "'fb0'", ",", "'dn0'", ",", "'dn1'", ",", "'mn0'", ",", "'ac0'", ",", "'fn1'", ",", "'st1'", ",", "'st2'", ",", "\n", "'c0'", ",", "'m0'", ",", "'s0'", ",", "'r0'", ",", "'n0'", ",", "'co0'", ",", "'usa:co'", ",", "'death_valley:lo'", ",", "'s1'", ",", "\n", "'colorado:n'", "]", ":", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Entity'", ")", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'entity'", "]", ",", "value", "=", "lf_node", ".", "name", ")", "]", ")", "\n", "", "elif", "lf_node", ".", "name", ".", "endswith", "(", "':i'", ")", "or", "lf_node", ".", "name", ".", "endswith", "(", "':hr'", ")", ":", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Number'", ")", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'number'", "]", ",", "value", "=", "lf_node", ".", "name", ")", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "==", "'the'", ":", "\n", "# expr -> The(var variable, expr body)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'The'", ")", "\n", "\n", "var_node", "=", "lf_node", ".", "children", "[", "0", "]", "\n", "var_field", "=", "RealizedField", "(", "prod", "[", "'variable'", "]", ",", "var_node", ".", "name", ")", "\n", "\n", "body_node", "=", "lf_node", ".", "children", "[", "1", "]", "\n", "body_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "body_node", ")", "\n", "body_field", "=", "RealizedField", "(", "prod", "[", "'body'", "]", ",", "body_ast_node", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "[", "var_field", ",", "body_field", "]", ")", "\n", "", "elif", "lf_node", ".", "name", "==", "'exists'", "or", "lf_node", ".", "name", "==", "'max'", "or", "lf_node", ".", "name", "==", "'min'", "or", "lf_node", ".", "name", "==", "'count'", ":", "\n", "# expr -> Exists(var variable, expr body)", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "lf_node", ".", "name", ".", "title", "(", ")", ")", "\n", "\n", "var_node", "=", "lf_node", ".", "children", "[", "0", "]", "\n", "var_field", "=", "RealizedField", "(", "prod", "[", "'variable'", "]", ",", "var_node", ".", "name", ")", "\n", "\n", "body_node", "=", "lf_node", ".", "children", "[", "1", "]", "\n", "body_ast_node", "=", "logical_form_to_ast", "(", "grammar", ",", "body_node", ")", "\n", "body_field", "=", "RealizedField", "(", "prod", "[", "'body'", "]", ",", "body_ast_node", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "[", "var_field", ",", "body_field", "]", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "ast_node", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form": [[306, 350], ["logical_form.Node", "logical_form.Node", "logical_form.ast_to_logical_form", "logical_form.Node", "logical_form.Node", "logical_form.ast_to_logical_form", "logical_form.ast_to_logical_form", "logical_form.Node", "constructor_name.lower", "logical_form.Node", "logical_form.ast_to_logical_form", "logical_form.Node", "logical_form.ast_to_logical_form", "logical_form.Node", "constructor_name.lower", "logical_form.Node", "logical_form.ast_to_logical_form", "constructor_name.lower", "logical_form.ast_to_logical_form", "logical_form.Node", "logical_form.ast_to_logical_form", "logical_form.ast_to_logical_form", "logical_form.Node", "logical_form.Node", "ValueError"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.ast_to_logical_form"], ["", "def", "ast_to_logical_form", "(", "ast_tree", ")", ":", "\n", "    ", "constructor_name", "=", "ast_tree", ".", "production", ".", "constructor", ".", "name", "\n", "if", "constructor_name", "==", "'Lambda'", ":", "\n", "        ", "var_node", "=", "Node", "(", "ast_tree", "[", "'variable'", "]", ".", "value", ")", "\n", "type_node", "=", "Node", "(", "ast_tree", "[", "'type'", "]", ".", "value", ")", "\n", "body_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'body'", "]", ".", "value", ")", "\n", "\n", "node", "=", "Node", "(", "'lambda'", ",", "[", "var_node", ",", "type_node", ",", "body_node", "]", ")", "\n", "", "elif", "constructor_name", "in", "[", "'Argmax'", ",", "'Argmin'", ",", "'Sum'", "]", ":", "\n", "        ", "var_node", "=", "Node", "(", "ast_tree", "[", "'variable'", "]", ".", "value", ")", "\n", "domain_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'domain'", "]", ".", "value", ")", "\n", "body_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'body'", "]", ".", "value", ")", "\n", "\n", "node", "=", "Node", "(", "constructor_name", ".", "lower", "(", ")", ",", "[", "var_node", ",", "domain_node", ",", "body_node", "]", ")", "\n", "", "elif", "constructor_name", "==", "'Apply'", ":", "\n", "        ", "predicate", "=", "ast_tree", "[", "'predicate'", "]", ".", "value", "\n", "arg_nodes", "=", "[", "ast_to_logical_form", "(", "tree", ")", "for", "tree", "in", "ast_tree", "[", "'arguments'", "]", ".", "value", "]", "\n", "\n", "node", "=", "Node", "(", "predicate", ",", "arg_nodes", ")", "\n", "", "elif", "constructor_name", "in", "[", "'Count'", ",", "'Exists'", ",", "'Max'", ",", "'Min'", ",", "'The'", "]", ":", "\n", "        ", "var_node", "=", "Node", "(", "ast_tree", "[", "'variable'", "]", ".", "value", ")", "\n", "body_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'body'", "]", ".", "value", ")", "\n", "\n", "node", "=", "Node", "(", "constructor_name", ".", "lower", "(", ")", ",", "[", "var_node", ",", "body_node", "]", ")", "\n", "", "elif", "constructor_name", "in", "[", "'And'", ",", "'Or'", "]", ":", "\n", "        ", "arg_nodes", "=", "[", "ast_to_logical_form", "(", "tree", ")", "for", "tree", "in", "ast_tree", "[", "'arguments'", "]", ".", "value", "]", "\n", "\n", "node", "=", "Node", "(", "constructor_name", ".", "lower", "(", ")", ",", "arg_nodes", ")", "\n", "", "elif", "constructor_name", "==", "'Not'", ":", "\n", "        ", "arg_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'argument'", "]", ".", "value", ")", "\n", "\n", "node", "=", "Node", "(", "'not'", ",", "arg_node", ")", "\n", "", "elif", "constructor_name", "==", "'Compare'", ":", "\n", "        ", "op", "=", "{", "'GreaterThan'", ":", "'>'", ",", "'Equal'", ":", "'='", ",", "'LessThan'", ":", "'<'", "}", "[", "ast_tree", "[", "'op'", "]", ".", "value", ".", "production", ".", "constructor", ".", "name", "]", "\n", "left_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'left'", "]", ".", "value", ")", "\n", "right_node", "=", "ast_to_logical_form", "(", "ast_tree", "[", "'right'", "]", ".", "value", ")", "\n", "\n", "node", "=", "Node", "(", "op", ",", "[", "left_node", ",", "right_node", "]", ")", "\n", "", "elif", "constructor_name", "in", "[", "'Variable'", ",", "'Entity'", ",", "'Number'", "]", ":", "\n", "        ", "node", "=", "Node", "(", "ast_tree", ".", "fields", "[", "0", "]", ".", "value", ")", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'unknown AST node %s'", "%", "ast_tree", ")", "\n", "\n", "", "return", "node", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.compare_ast": [[243, 245], ["prolog_transition_system.is_equal_ast"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.is_equal_ast"], ["    ", "def", "compare_ast", "(", "self", ",", "hyp_ast", ",", "ref_ast", ")", ":", "\n", "        ", "return", "is_equal_ast", "(", "hyp_ast", ",", "ref_ast", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code": [[246, 248], ["prolog_transition_system.ast_to_prolog_expr"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.ast_to_prolog_expr"], ["", "def", "ast_to_surface_code", "(", "self", ",", "asdl_ast", ")", ":", "\n", "        ", "return", "ast_to_prolog_expr", "(", "asdl_ast", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.surface_code_to_ast": [[249, 251], ["prolog_transition_system.prolog_expr_to_ast"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast"], ["", "def", "surface_code_to_ast", "(", "self", ",", "code", ")", ":", "\n", "        ", "return", "prolog_expr_to_ast", "(", "self", ".", "grammar", ",", "code", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.hyp_correct": [[252, 254], ["prolog_transition_system.is_equal_ast"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.is_equal_ast"], ["", "def", "hyp_correct", "(", "self", ",", "hyp", ",", "example", ")", ":", "\n", "        ", "return", "is_equal_ast", "(", "hyp", ".", "tree", ",", "example", ".", "tgt_ast", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.tokenize_code": [[255, 257], ["code.split"], "methods", ["None"], ["", "def", "tokenize_code", "(", "self", ",", "code", ",", "mode", ")", ":", "\n", "        ", "return", "code", ".", "split", "(", "' '", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.get_primitive_field_actions": [[258, 264], ["asdl.transition_system.GenTokenAction"], "methods", ["None"], ["", "def", "get_primitive_field_actions", "(", "self", ",", "realized_field", ")", ":", "\n", "        ", "assert", "realized_field", ".", "cardinality", "==", "'single'", "\n", "if", "realized_field", ".", "value", "is", "not", "None", ":", "\n", "            ", "return", "[", "GenTokenAction", "(", "realized_field", ".", "value", ")", "]", "\n", "", "else", ":", "\n", "            ", "return", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_node_to_ast": [[16, 63], ["grammar.get_prod_by_ctr_name", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.AbstractSyntaxTree", "prolog_transition_system.prolog_node_to_ast", "arg_ast_nodes.append", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "len", "node_name.endswith", "node_name.endswith", "node_name.endswith", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_node_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name"], ["def", "prolog_node_to_ast", "(", "grammar", ",", "prolog_tokens", ",", "start_idx", ")", ":", "\n", "    ", "node_name", "=", "prolog_tokens", "[", "start_idx", "]", "\n", "i", "=", "start_idx", "\n", "if", "node_name", "in", "[", "'job'", ",", "'language'", ",", "'loc'", ",", "'req_deg'", ",", "'application'", ",", "'area'", ",", "'company'", ",", "\n", "'des_deg'", ",", "'des_exp'", ",", "'platform'", ",", "'recruiter'", ",", "'req_exp'", ",", "'salary_greater_than'", ",", "\n", "'salary_less_than'", ",", "'title'", "]", ":", "\n", "# it's a predicate", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Apply'", ")", "\n", "pred_field", "=", "RealizedField", "(", "prod", "[", "'predicate'", "]", ",", "value", "=", "node_name", ")", "\n", "\n", "arg_ast_nodes", "=", "[", "]", "\n", "i", "+=", "1", "\n", "assert", "prolog_tokens", "[", "i", "]", "==", "'('", "\n", "while", "True", ":", "\n", "            ", "i", "+=", "1", "\n", "arg_ast_node", ",", "end_idx", "=", "prolog_node_to_ast", "(", "grammar", ",", "prolog_tokens", ",", "i", ")", "\n", "arg_ast_nodes", ".", "append", "(", "arg_ast_node", ")", "\n", "\n", "i", "=", "end_idx", "\n", "if", "i", ">=", "len", "(", "prolog_tokens", ")", ":", "break", "\n", "if", "prolog_tokens", "[", "i", "]", "==", "')'", ":", "\n", "                ", "i", "+=", "1", "\n", "break", "\n", "\n", "", "assert", "prolog_tokens", "[", "i", "]", "==", "','", "\n", "\n", "", "arg_field", "=", "RealizedField", "(", "prod", "[", "'arguments'", "]", ",", "arg_ast_nodes", ")", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "[", "pred_field", ",", "arg_field", "]", ")", "\n", "", "elif", "node_name", "in", "[", "'ANS'", ",", "'X'", ",", "'A'", ",", "'B'", ",", "'P'", ",", "'J'", "]", ":", "\n", "# it's a variable", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Variable'", ")", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'variable'", "]", ",", "value", "=", "node_name", ")", "]", ")", "\n", "\n", "i", "+=", "1", "\n", "", "elif", "node_name", ".", "endswith", "(", "'id0'", ")", "or", "node_name", ".", "endswith", "(", "'id1'", ")", "or", "node_name", ".", "endswith", "(", "'id2'", ")", "or", "node_name", "in", "[", "'20'", ",", "'hour'", ",", "'num_salary'", ",", "'year'", ",", "'year0'", ",", "'year1'", ",", "'month'", "]", ":", "\n", "# it's a literal", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Literal'", ")", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'literal'", "]", ",", "value", "=", "node_name", ")", "]", ")", "\n", "\n", "i", "+=", "1", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "return", "ast_node", ",", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast_helper": [[65, 140], ["len", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "parsed_nodes.append", "len", "prolog_transition_system.prolog_expr_to_ast_helper", "prolog_transition_system.prolog_node_to_ast", "prolog_transition_system.prolog_expr_to_ast_helper", "parsed_nodes.append", "prolog_transition_system.prolog_node_to_ast", "parsed_nodes.append", "grammar.get_prod_by_ctr_name", "prolog_transition_system.prolog_expr_to_ast_helper", "asdl.asdl_ast.AbstractSyntaxTree", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField", "len", "grammar.get_prod_by_ctr_name", "asdl.asdl_ast.AbstractSyntaxTree", "len", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField", "asdl.asdl_ast.RealizedField"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast_helper", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_node_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast_helper", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_node_to_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast_helper", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl.ASDLGrammar.get_prod_by_ctr_name"], ["", "def", "prolog_expr_to_ast_helper", "(", "grammar", ",", "prolog_tokens", ",", "start_idx", "=", "0", ")", ":", "\n", "    ", "i", "=", "start_idx", "\n", "if", "prolog_tokens", "[", "i", "]", "==", "'('", ":", "\n", "        ", "i", "+=", "1", "\n", "\n", "", "parsed_nodes", "=", "[", "]", "\n", "while", "True", ":", "\n", "        ", "if", "prolog_tokens", "[", "i", "]", "==", "'\\\\+'", ":", "\n", "# expr -> Not(expr argument)", "\n", "            ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Not'", ")", "\n", "i", "+=", "1", "\n", "if", "prolog_tokens", "[", "i", "]", "==", "'('", ":", "\n", "                ", "arg_ast_node", ",", "end_idx", "=", "prolog_expr_to_ast_helper", "(", "grammar", ",", "prolog_tokens", ",", "i", ")", "\n", "", "else", ":", "\n", "                ", "arg_ast_node", ",", "end_idx", "=", "prolog_node_to_ast", "(", "grammar", ",", "prolog_tokens", ",", "i", ")", "\n", "", "i", "=", "end_idx", "\n", "\n", "assert", "arg_ast_node", ".", "production", ".", "type", ".", "name", "==", "'expr'", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'argument'", "]", ",", "arg_ast_node", ")", "]", ")", "\n", "\n", "parsed_nodes", ".", "append", "(", "ast_node", ")", "\n", "", "elif", "prolog_tokens", "[", "i", "]", "==", "'('", ":", "\n", "            ", "ast_node", ",", "end_idx", "=", "prolog_expr_to_ast_helper", "(", "grammar", ",", "prolog_tokens", ",", "i", ")", "\n", "parsed_nodes", ".", "append", "(", "ast_node", ")", "\n", "i", "=", "end_idx", "\n", "", "else", ":", "\n", "            ", "ast_node", ",", "end_idx", "=", "prolog_node_to_ast", "(", "grammar", ",", "prolog_tokens", ",", "i", ")", "\n", "parsed_nodes", ".", "append", "(", "ast_node", ")", "\n", "i", "=", "end_idx", "\n", "\n", "", "if", "i", ">=", "len", "(", "prolog_tokens", ")", ":", "break", "\n", "if", "prolog_tokens", "[", "i", "]", "==", "')'", ":", "\n", "            ", "i", "+=", "1", "\n", "break", "\n", "\n", "", "if", "prolog_tokens", "[", "i", "]", "==", "','", ":", "\n", "# and", "\n", "            ", "i", "+=", "1", "\n", "", "elif", "prolog_tokens", "[", "i", "]", "==", "';'", ":", "\n", "# Or", "\n", "            ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'Or'", ")", "\n", "\n", "assert", "parsed_nodes", "\n", "if", "len", "(", "parsed_nodes", ")", "==", "1", ":", "\n", "                ", "left_ast_node", "=", "parsed_nodes", "[", "0", "]", "\n", "", "else", ":", "\n", "                ", "left_expr_prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'And'", ")", "\n", "left_ast_node", "=", "AbstractSyntaxTree", "(", "left_expr_prod", ",", "[", "RealizedField", "(", "left_expr_prod", "[", "'arguments'", "]", ",", "parsed_nodes", ")", "]", ")", "\n", "parsed_nodes", "=", "[", "]", "\n", "\n", "# get the right ast node", "\n", "", "i", "+=", "1", "\n", "right_ast_node", ",", "end_idx", "=", "prolog_expr_to_ast_helper", "(", "grammar", ",", "prolog_tokens", ",", "i", ")", "\n", "\n", "ast_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "\n", "[", "RealizedField", "(", "prod", "[", "'left'", "]", ",", "left_ast_node", ")", ",", "\n", "RealizedField", "(", "prod", "[", "'right'", "]", ",", "right_ast_node", ")", "]", ")", "\n", "\n", "i", "=", "end_idx", "\n", "parsed_nodes", "=", "[", "ast_node", "]", "\n", "\n", "if", "i", ">=", "len", "(", "prolog_tokens", ")", ":", "break", "\n", "if", "prolog_tokens", "[", "i", "]", "==", "')'", ":", "\n", "                ", "i", "+=", "1", "\n", "break", "\n", "\n", "", "", "", "assert", "parsed_nodes", "\n", "if", "len", "(", "parsed_nodes", ")", ">", "1", ":", "\n", "        ", "prod", "=", "grammar", ".", "get_prod_by_ctr_name", "(", "'And'", ")", "\n", "return_node", "=", "AbstractSyntaxTree", "(", "prod", ",", "[", "RealizedField", "(", "prod", "[", "'arguments'", "]", ",", "parsed_nodes", ")", "]", ")", "\n", "", "else", ":", "\n", "        ", "return_node", "=", "parsed_nodes", "[", "0", "]", "\n", "\n", "", "return", "return_node", ",", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast": [[142, 145], ["prolog_expr.strip().split", "prolog_transition_system.prolog_expr_to_ast_helper", "prolog_expr.strip"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.prolog_expr_to_ast_helper"], ["", "def", "prolog_expr_to_ast", "(", "grammar", ",", "prolog_expr", ")", ":", "\n", "    ", "prolog_tokens", "=", "prolog_expr", ".", "strip", "(", ")", ".", "split", "(", "' '", ")", "\n", "return", "prolog_expr_to_ast_helper", "(", "grammar", ",", "prolog_tokens", ",", "start_idx", "=", "0", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.ast_to_prolog_expr": [[147, 205], ["StringIO", "StringIO.getvalue", "StringIO.write", "StringIO.write", "enumerate", "StringIO.write", "StringIO.write", "enumerate", "StringIO.write", "StringIO.write", "prolog_transition_system.ast_to_prolog_expr", "prolog_transition_system.ast_to_prolog_expr", "prolog_transition_system.ast_to_prolog_expr", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write", "prolog_transition_system.ast_to_prolog_expr", "StringIO.write", "StringIO.write", "StringIO.write", "StringIO.write"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.ast_to_prolog_expr", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.ast_to_prolog_expr", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.ast_to_prolog_expr", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.ast_to_prolog_expr"], ["", "def", "ast_to_prolog_expr", "(", "asdl_ast", ")", ":", "\n", "    ", "sb", "=", "StringIO", "(", ")", "\n", "constructor_name", "=", "asdl_ast", ".", "production", ".", "constructor", ".", "name", "\n", "if", "constructor_name", "==", "'Apply'", ":", "\n", "        ", "predicate", "=", "asdl_ast", "[", "'predicate'", "]", ".", "value", "\n", "sb", ".", "write", "(", "predicate", ")", "\n", "sb", ".", "write", "(", "' ('", ")", "\n", "for", "i", ",", "arg", "in", "enumerate", "(", "asdl_ast", "[", "'arguments'", "]", ".", "value", ")", ":", "\n", "            ", "arg_val", "=", "arg", ".", "fields", "[", "0", "]", ".", "value", "\n", "if", "i", "==", "0", ":", "sb", ".", "write", "(", "' '", ")", "\n", "else", ":", "sb", ".", "write", "(", "' , '", ")", "\n", "sb", ".", "write", "(", "arg_val", ")", "\n", "\n", "", "sb", ".", "write", "(", "' )'", ")", "\n", "", "elif", "constructor_name", "==", "'And'", ":", "\n", "        ", "for", "i", ",", "arg_ast", "in", "enumerate", "(", "asdl_ast", "[", "'arguments'", "]", ".", "value", ")", ":", "\n", "            ", "arg_str", "=", "ast_to_prolog_expr", "(", "arg_ast", ")", "\n", "if", "i", ">", "0", ":", "sb", ".", "write", "(", "' , '", ")", "\n", "if", "arg_ast", ".", "production", ".", "constructor", ".", "name", "==", "'Or'", ":", "\n", "                ", "sb", ".", "write", "(", "'( '", ")", "\n", "sb", ".", "write", "(", "arg_str", ")", "\n", "sb", ".", "write", "(", "' )'", ")", "\n", "", "else", ":", "\n", "                ", "sb", ".", "write", "(", "arg_str", ")", "\n", "", "", "", "elif", "constructor_name", "==", "'Or'", ":", "\n", "        ", "left_ast", "=", "asdl_ast", "[", "'left'", "]", ".", "value", "\n", "right_ast", "=", "asdl_ast", "[", "'right'", "]", ".", "value", "\n", "\n", "left_ast_str", "=", "ast_to_prolog_expr", "(", "left_ast", ")", "\n", "right_ast_str", "=", "ast_to_prolog_expr", "(", "right_ast", ")", "\n", "\n", "if", "left_ast", ".", "production", ".", "constructor", ".", "name", "==", "'Apply'", ":", "\n", "            ", "sb", ".", "write", "(", "'( '", ")", "\n", "sb", ".", "write", "(", "left_ast_str", ")", "\n", "sb", ".", "write", "(", "' )'", ")", "\n", "", "else", ":", "\n", "            ", "sb", ".", "write", "(", "left_ast_str", ")", "\n", "\n", "", "sb", ".", "write", "(", "' ; '", ")", "\n", "\n", "if", "right_ast", ".", "production", ".", "constructor", ".", "name", "in", "(", "'Apply'", ",", "'And'", ")", ":", "\n", "            ", "sb", ".", "write", "(", "'( '", ")", "\n", "sb", ".", "write", "(", "right_ast_str", ")", "\n", "sb", ".", "write", "(", "' )'", ")", "\n", "", "else", ":", "\n", "            ", "sb", ".", "write", "(", "right_ast_str", ")", "\n", "", "", "elif", "constructor_name", "==", "'Not'", ":", "\n", "        ", "sb", ".", "write", "(", "'\\\\+ '", ")", "\n", "arg_ast", "=", "asdl_ast", "[", "'argument'", "]", ".", "value", "\n", "arg_str", "=", "ast_to_prolog_expr", "(", "arg_ast", ")", "\n", "if", "arg_ast", ".", "production", ".", "constructor", ".", "name", "in", "(", "'Or'", ",", "'And'", ")", ":", "\n", "            ", "sb", ".", "write", "(", "'( '", ")", "\n", "sb", ".", "write", "(", "arg_str", ")", "\n", "sb", ".", "write", "(", "' )'", ")", "\n", "", "else", ":", "\n", "            ", "sb", ".", "write", "(", "arg_str", ")", "\n", "\n", "", "", "return", "sb", ".", "getvalue", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.is_equal_ast": [[207, 239], ["isinstance", "isinstance", "range", "isinstance", "len", "len", "len", "range", "sorted", "sorted", "prolog_transition_system.is_equal_ast", "len", "len", "len", "prolog_transition_system.is_equal_ast", "x.to_string", "x.to_string"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.is_equal_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.is_equal_ast", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string"], ["", "def", "is_equal_ast", "(", "this_ast", ",", "other_ast", ")", ":", "\n", "    ", "if", "not", "isinstance", "(", "other_ast", ",", "this_ast", ".", "__class__", ")", ":", "\n", "        ", "return", "False", "\n", "\n", "", "if", "this_ast", "==", "other_ast", ":", "\n", "        ", "return", "True", "\n", "\n", "", "if", "isinstance", "(", "this_ast", ",", "AbstractSyntaxTree", ")", ":", "\n", "        ", "if", "this_ast", ".", "production", "!=", "other_ast", ".", "production", ":", "\n", "            ", "return", "False", "\n", "\n", "", "if", "len", "(", "this_ast", ".", "fields", ")", "!=", "len", "(", "other_ast", ".", "fields", ")", ":", "\n", "            ", "return", "False", "\n", "\n", "", "for", "i", "in", "range", "(", "len", "(", "this_ast", ".", "fields", ")", ")", ":", "\n", "            ", "if", "this_ast", ".", "production", ".", "constructor", ".", "name", "in", "(", "'And'", ",", "'Or'", ")", "and", "this_ast", ".", "fields", "[", "i", "]", ".", "name", "==", "'arguments'", ":", "\n", "                ", "this_field_val", "=", "sorted", "(", "this_ast", ".", "fields", "[", "i", "]", ".", "value", ",", "key", "=", "lambda", "x", ":", "x", ".", "to_string", "(", ")", ")", "\n", "other_field_val", "=", "sorted", "(", "other_ast", ".", "fields", "[", "i", "]", ".", "value", ",", "key", "=", "lambda", "x", ":", "x", ".", "to_string", "(", ")", ")", "\n", "", "else", ":", "\n", "                ", "this_field_val", "=", "this_ast", ".", "fields", "[", "i", "]", ".", "value", "\n", "other_field_val", "=", "other_ast", ".", "fields", "[", "i", "]", ".", "value", "\n", "\n", "", "if", "not", "is_equal_ast", "(", "this_field_val", ",", "other_field_val", ")", ":", "return", "False", "\n", "", "", "elif", "isinstance", "(", "this_ast", ",", "list", ")", ":", "\n", "        ", "if", "len", "(", "this_ast", ")", "!=", "len", "(", "other_ast", ")", ":", "return", "False", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "this_ast", ")", ")", ":", "\n", "            ", "if", "not", "is_equal_ast", "(", "this_ast", "[", "i", "]", ",", "other_ast", "[", "i", "]", ")", ":", "return", "False", "\n", "", "", "else", ":", "\n", "        ", "return", "this_ast", "==", "other_ast", "\n", "\n", "", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.server.app.init_arg_parser": [[14, 24], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], ["def", "init_arg_parser", "(", ")", ":", "\n", "    ", "arg_parser", "=", "argparse", ".", "ArgumentParser", "(", ")", "\n", "\n", "#### General configuration ####", "\n", "arg_parser", ".", "add_argument", "(", "'--cuda'", ",", "action", "=", "'store_true'", ",", "default", "=", "False", ",", "help", "=", "'Use gpu'", ")", "\n", "arg_parser", ".", "add_argument", "(", "'--config_file'", ",", "type", "=", "str", ",", "required", "=", "True", ",", "\n", "help", "=", "'Config file that specifies model to load, see online doc for an example'", ")", "\n", "arg_parser", ".", "add_argument", "(", "'--port'", ",", "type", "=", "int", ",", "required", "=", "False", ",", "default", "=", "8081", ")", "\n", "\n", "return", "arg_parser", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.server.app.default": [[26, 29], ["app.route", "flask.render_template"], "function", ["None"], ["", "@", "app", ".", "route", "(", "\"/\"", ")", "\n", "def", "default", "(", ")", ":", "\n", "    ", "return", "render_template", "(", "'default.html'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.server.app.parse": [[31, 67], ["app.route", "parser.parse", "dict", "enumerate", "flask.jsonify", "utterance.encode.encode", "print", "print", "print", "print", "print", "dict", "responses[].append", "hyp.tree.to_string", "hyp.score.item", "hyp.rerank_score.item", "action.__repr__", "hyp.tree.to_string", "hasattr", "hyp.rerank_score.item", "hyp.score.item"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.__repr__", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.lambda_dcs.logical_form.Node.to_string"], ["", "@", "app", ".", "route", "(", "'/parse/<dataset>'", ",", "methods", "=", "[", "'GET'", "]", ")", "\n", "def", "parse", "(", "dataset", ")", ":", "\n", "    ", "utterance", "=", "request", ".", "args", "[", "'q'", "]", "\n", "\n", "parser", "=", "parsers", "[", "dataset", "]", "\n", "\n", "if", "six", ".", "PY2", ":", "\n", "        ", "utterance", "=", "utterance", ".", "encode", "(", "'utf-8'", ",", "'ignore'", ")", "\n", "\n", "", "hypotheses", "=", "parser", ".", "parse", "(", "utterance", ",", "debug", "=", "True", ")", "\n", "\n", "responses", "=", "dict", "(", ")", "\n", "responses", "[", "'hypotheses'", "]", "=", "[", "]", "\n", "\n", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hypotheses", ")", ":", "\n", "        ", "print", "(", "'------------------ Hypothesis %d ------------------'", "%", "hyp_id", ")", "\n", "print", "(", "hyp", ".", "code", ")", "\n", "print", "(", "hyp", ".", "tree", ".", "to_string", "(", ")", ")", "\n", "print", "(", "hyp", ".", "score", ".", "item", "(", ")", ")", "\n", "print", "(", "hyp", ".", "rerank_score", ".", "item", "(", ")", ")", "\n", "\n", "# print('Actions:')", "\n", "# for action_t in hyp.action_infos:", "\n", "#     print(action_t)", "\n", "\n", "actions_repr", "=", "[", "action", ".", "__repr__", "(", "True", ")", "for", "action", "in", "hyp", ".", "action_infos", "]", "\n", "\n", "hyp_entry", "=", "dict", "(", "id", "=", "hyp_id", "+", "1", ",", "\n", "value", "=", "hyp", ".", "code", ",", "\n", "tree_repr", "=", "hyp", ".", "tree", ".", "to_string", "(", ")", ",", "\n", "score", "=", "hyp", ".", "rerank_score", ".", "item", "(", ")", "if", "hasattr", "(", "hyp", ",", "'rerank_score'", ")", "else", "hyp", ".", "score", ".", "item", "(", ")", ",", "\n", "actions", "=", "actions_repr", ")", "\n", "\n", "responses", "[", "'hypotheses'", "]", ".", "append", "(", "hyp_entry", ")", "\n", "\n", "", "return", "jsonify", "(", "responses", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.parenthetic_contents": [[12, 21], ["enumerate", "stack.append", "stack.pop", "len"], "function", ["None"], ["def", "parenthetic_contents", "(", "string", ")", ":", "\n", "    ", "\"\"\"Generate parenthesized contents in string as pairs (level, contents).\"\"\"", "\n", "stack", "=", "[", "]", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "string", ")", ":", "\n", "        ", "if", "c", "==", "'['", ":", "\n", "            ", "stack", ".", "append", "(", "i", ")", "\n", "", "elif", "c", "==", "']'", "and", "stack", ":", "\n", "            ", "start", "=", "stack", ".", "pop", "(", ")", "\n", "yield", "(", "len", "(", "stack", ")", ",", "string", "[", "start", "+", "1", ":", "i", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.get_func_signatures": [[22, 34], ["sigs.append", "isinstance", "text.strip", "isinstance"], "function", ["None"], ["", "", "", "def", "get_func_signatures", "(", "nodes", ")", ":", "\n", "    ", "sigs", "=", "[", "]", "\n", "for", "node", "in", "nodes", ":", "\n", "        ", "text", "=", "\"\"", "\n", "for", "n", "in", "node", ".", "children", ":", "\n", "            ", "if", "isinstance", "(", "n", ",", "element", ".", "Tag", ")", ":", "\n", "                ", "if", "'property'", "not", "in", "n", "[", "'class'", "]", "and", "n", ".", "name", "!=", "'a'", ":", "\n", "                    ", "text", "+=", "n", ".", "text", "\n", "", "", "elif", "isinstance", "(", "n", ",", "element", ".", "NavigableString", ")", ":", "\n", "                ", "text", "+=", "n", "\n", "", "", "sigs", ".", "append", "(", "text", ".", "strip", "(", ")", ")", "\n", "", "return", "sigs", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.get_class_name": [[35, 37], ["[].split", "sig.split"], "function", ["None"], ["", "def", "get_class_name", "(", "sig", ")", ":", "\n", "    ", "return", "sig", ".", "split", "(", "'('", ")", "[", "0", "]", ".", "split", "(", "'.'", ")", "[", "-", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.parse_optional_args": [[38, 70], ["sig.find", "sig.rfind", "len", "arg_str.replace().replace().split", "range", "range", "list", "pos_arg_combinations.append", "itertools.combinations", "len", "doc_parser.parenthetic_contents", "arg_str.replace().replace", "len", "kwargs.append", "all_keywords.append", "pos_args.append", "all_keywords.append", "list", "arg_str.replace", "arg.split"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.parenthetic_contents"], ["", "def", "parse_optional_args", "(", "sig", ")", ":", "\n", "    ", "if", "'('", "in", "sig", "and", "')'", "in", "sig", ":", "\n", "        ", "lidx", "=", "sig", ".", "find", "(", "'('", ")", "\n", "ridx", "=", "sig", ".", "rfind", "(", "')'", ")", "\n", "head", "=", "sig", "[", ":", "lidx", "]", "\n", "arg_str", "=", "sig", "[", "lidx", "+", "1", ":", "ridx", "]", "\n", "num_posoptarags", "=", "len", "(", "list", "(", "parenthetic_contents", "(", "arg_str", ")", ")", ")", "\n", "arg_str_list", "=", "arg_str", ".", "replace", "(", "'['", ",", "''", ")", ".", "replace", "(", "']'", ",", "''", ")", ".", "split", "(", "', '", ")", "\n", "pos_args", "=", "[", "]", "\n", "kwargs", "=", "[", "]", "\n", "all_keywords", "=", "[", "]", "\n", "for", "arg", "in", "arg_str_list", ":", "\n", "            ", "if", "arg", "in", "(", "'*'", ",", "'...'", ")", ":", "\n", "                ", "continue", "\n", "", "elif", "'='", "in", "arg", ":", "\n", "                ", "kwargs", ".", "append", "(", "arg", ")", "\n", "all_keywords", ".", "append", "(", "arg", ".", "split", "(", "'='", ")", "[", "0", "]", ")", "\n", "", "else", ":", "\n", "                ", "pos_args", ".", "append", "(", "arg", ")", "\n", "all_keywords", ".", "append", "(", "arg", ")", "\n", "", "", "pos_arg_combinations", "=", "[", "pos_args", "]", "\n", "for", "i", "in", "range", "(", "num_posoptarags", ")", ":", "\n", "            ", "pos_arg_combinations", ".", "append", "(", "pos_args", "[", ":", "-", "i", "-", "1", "]", ")", "\n", "", "kwargs_combinations", "=", "[", "]", "\n", "for", "k", "in", "range", "(", "len", "(", "kwargs", ")", "+", "1", ")", ":", "\n", "            ", "kwargs_combinations", "+=", "itertools", ".", "combinations", "(", "kwargs", ",", "k", ")", "\n", "", "if", "len", "(", "kwargs_combinations", ")", ">", "10", ":", "\n", "# kwargs_combinations = random.sample(kwargs_combinations, k=10)", "\n", "            ", "kwargs_combinations", "=", "kwargs_combinations", "[", ":", "10", "]", "\n", "", "return", "head", ",", "[", "x", "+", "list", "(", "y", ")", "for", "x", "in", "pos_arg_combinations", "for", "y", "in", "kwargs_combinations", "]", ",", "all_keywords", "\n", "", "else", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.match_doc_sents": [[71, 84], ["dict.fromkeys", "nltk.word_tokenize", "enumerate", "tokens.index"], "function", ["None"], ["", "", "def", "match_doc_sents", "(", "kws", ",", "sents", ")", ":", "\n", "    ", "k_s", "=", "dict", ".", "fromkeys", "(", "kws", ")", "\n", "toked_sents", "=", "[", "nltk", ".", "word_tokenize", "(", "sent", ")", "for", "sent", "in", "sents", "]", "\n", "for", "k", "in", "k_s", ":", "\n", "        ", "for", "idx", ",", "tokens", "in", "enumerate", "(", "toked_sents", ")", ":", "\n", "            ", "if", "k", "in", "tokens", ":", "\n", "                ", "token_idx", "=", "tokens", ".", "index", "(", "k", ")", "\n", "quoted_token", "=", "'`'", "+", "k", "+", "'`'", "\n", "toked_sents", "[", "idx", "]", "[", "token_idx", "]", "=", "quoted_token", "\n", "k_s", "[", "k", "]", "=", "idx", "\n", "break", "\n", "", "", "", "quoted_sents", "=", "[", "\" \"", ".", "join", "(", "toks", ")", "for", "toks", "in", "toked_sents", "]", "\n", "return", "k_s", ",", "quoted_sents", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.doc_parser.make_doc": [[85, 102], ["range", "ret_sents.append", "ids.append", "len", "arg.split", "args_not_mentioned.append"], "function", ["None"], ["", "def", "make_doc", "(", "args", ",", "ks", ",", "sents", ")", ":", "\n", "    ", "ids", "=", "[", "0", "]", "\n", "args_not_mentioned", "=", "[", "]", "\n", "for", "arg", "in", "args", ":", "\n", "        ", "if", "'='", "in", "arg", ":", "\n", "            ", "arg", "=", "arg", ".", "split", "(", "'='", ")", "[", "0", "]", "\n", "", "sent_id", "=", "ks", "[", "arg", "]", "\n", "if", "sent_id", "and", "sent_id", "not", "in", "ids", ":", "\n", "            ", "ids", ".", "append", "(", "sent_id", ")", "\n", "", "elif", "sent_id", "is", "None", ":", "\n", "            ", "args_not_mentioned", ".", "append", "(", "arg", ")", "\n", "", "", "ret_sents", "=", "[", "sents", "[", "idx", "]", "for", "idx", "in", "ids", "]", "\n", "if", "args_not_mentioned", "and", "args_not_mentioned", "!=", "[", "''", "]", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "args_not_mentioned", ")", ")", ":", "\n", "            ", "args_not_mentioned", "[", "i", "]", "=", "'`'", "+", "args_not_mentioned", "[", "i", "]", "+", "'`'", "\n", "", "ret_sents", ".", "append", "(", "\"With arguments \"", "+", "', '", ".", "join", "(", "args_not_mentioned", ")", "+", "'.'", ")", "\n", "", "return", "\" \"", ".", "join", "(", "ret_sents", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.ESSearcher.__init__": [[26, 29], ["elasticsearch.Elasticsearch"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "index_name", ":", "str", ")", ":", "\n", "        ", "self", ".", "es", "=", "Elasticsearch", "(", ")", "\n", "self", ".", "index_name", "=", "index_name", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.ESSearcher.query_format": [[30, 41], ["query_str.translate", "new_query_str.replace().replace.replace().replace.replace().replace", "new_query_str.replace().replace.replace().replace.replace", "new_query_str.replace().replace.replace().replace.split", "re.match"], "methods", ["None"], ["", "def", "query_format", "(", "self", ",", "query_str", ":", "str", ",", "field", ":", "str", ")", ":", "\n", "        ", "new_query_str", "=", "query_str", ".", "translate", "(", "PUNCT_TO_SPACE", ")", "\n", "new_query_str", "=", "' '", ".", "join", "(", "[", "w", "for", "w", "in", "new_query_str", ".", "split", "(", ")", "if", "re", ".", "match", "(", "'^[0-9A-Za-z]+$'", ",", "w", ")", "]", ")", "\n", "new_query_str", "=", "new_query_str", ".", "replace", "(", "' AND '", ",", "' '", ")", ".", "replace", "(", "' and '", ",", "' '", ")", "\n", "'''\n        if len(query_str) - len(new_query_str) > 10:\n            print(query_str)\n            print(new_query_str)\n            input()\n        '''", "\n", "return", "'{}:({})'", ".", "format", "(", "field", ",", "new_query_str", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.ESSearcher.get_topk": [[42, 47], ["retrieve.ESSearcher.es.search", "retrieve.ESSearcher.query_format"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.ESSearcher.query_format"], ["", "def", "get_topk", "(", "self", ",", "query_str", ":", "str", ",", "field", ":", "str", ",", "topk", ":", "int", "=", "5", ")", ":", "\n", "        ", "results", "=", "self", ".", "es", ".", "search", "(", "\n", "index", "=", "self", ".", "index_name", ",", "\n", "q", "=", "self", ".", "query_format", "(", "query_str", ",", "field", ")", ")", "[", "'hits'", "]", "[", "'hits'", "]", "[", ":", "topk", "]", "\n", "return", "[", "(", "doc", "[", "'_source'", "]", ",", "doc", "[", "'_score'", "]", ")", "for", "doc", "in", "results", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax": [[18, 21], ["numpy.exp", "np.exp.sum", "numpy.max"], "function", ["None"], ["def", "softmax", "(", "x", ")", ":", "\n", "    ", "e_x", "=", "np", ".", "exp", "(", "x", "-", "np", ".", "max", "(", "x", ")", ")", "\n", "return", "e_x", "/", "e_x", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax": [[22, 24], ["numpy.log", "retrieve.softmax"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "log_softmax", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "log", "(", "softmax", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.load_multi_files": [[48, 63], ["zip", "type", "print", "dataset.extend", "len", "json.load", "open", "len", "json.loads", "open"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load"], ["", "", "def", "load_multi_files", "(", "files", ":", "List", "[", "str", "]", ",", "max_counts", ":", "List", "[", "int", "]", "=", "None", ")", ":", "\n", "    ", "if", "type", "(", "files", ")", "is", "not", "list", ":", "\n", "        ", "files", "=", "[", "files", "]", "\n", "", "dataset", "=", "[", "]", "\n", "max_counts", "=", "max_counts", "or", "[", "None", "]", "*", "len", "(", "files", ")", "\n", "for", "file", ",", "max_count", "in", "zip", "(", "files", ",", "max_counts", ")", ":", "\n", "        ", "try", ":", "\n", "            ", "td", "=", "json", ".", "load", "(", "open", "(", "file", ",", "'r'", ")", ")", "\n", "", "except", ":", "\n", "            ", "td", "=", "[", "json", ".", "loads", "(", "l", ")", "for", "l", "in", "open", "(", "file", ",", "'r'", ")", "]", "\n", "", "if", "max_count", ":", "\n", "            ", "td", "=", "td", "[", ":", "max_count", "]", "\n", "", "print", "(", "'load {} from {}'", ".", "format", "(", "len", "(", "td", ")", ",", "file", ")", ")", "\n", "dataset", ".", "extend", "(", "td", ")", "\n", "", "return", "dataset", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.aug_iter": [[64, 80], ["enumerate", "tqdm.tqdm", "ess.get_topk"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.ESSearcher.get_topk"], ["", "def", "aug_iter", "(", "ess", ",", "dataset", ",", "field", ",", "topk", ")", ":", "\n", "    ", "'''\n    iterate over dataset and do retrieval\n    '''", "\n", "for", "i", ",", "code", "in", "enumerate", "(", "tqdm", "(", "dataset", ")", ")", ":", "\n", "        ", "if", "field", "==", "'intent'", ":", "\n", "            ", "query", "=", "(", "code", "[", "'rewritten_intent'", "]", "if", "'rewritten_intent'", "in", "code", "else", "None", ")", "or", "code", "[", "'intent'", "]", "\n", "", "elif", "field", "==", "'snippet'", ":", "\n", "            ", "query", "=", "code", "[", "'snippet'", "]", "\n", "", "try", ":", "\n", "            ", "hits", "=", "ess", ".", "get_topk", "(", "query", ",", "field", ",", "topk", "=", "topk", ")", "\n", "yield", "code", ",", "hits", "\n", "", "except", "KeyboardInterrupt", ":", "\n", "            ", "raise", "\n", "", "except", "Exception", "as", "e", ":", "\n", "            ", "pass", "# sometimes the query is empty", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.topk_aug": [[81, 104], ["retrieve.load_multi_files", "retrieve.ESSearcher", "collections.defaultdict", "retrieve.aug_iter", "print", "args.inp.split", "open", "aug_dataset.append", "fout.write", "sorted", "json.dumps", "collections.defaultdict.items"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.load_multi_files", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.aug_iter"], ["", "", "", "def", "topk_aug", "(", "args", ")", ":", "\n", "    ", "dataset", "=", "load_multi_files", "(", "args", ".", "inp", ".", "split", "(", "':'", ")", ")", "\n", "ess", "=", "ESSearcher", "(", "index_name", "=", "'python-docs'", ")", "\n", "\n", "aug_dataset", "=", "[", "]", "\n", "id2count", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "code", ",", "hits", "in", "aug_iter", "(", "ess", ",", "dataset", ",", "args", ".", "field", ",", "args", ".", "topk", ")", ":", "\n", "        ", "'''\n        if len(hits) != args.topk:\n            print('not enough for \"{}\"'.format(query))\n            print(ess.query_format(query, args.field))\n        '''", "\n", "for", "(", "rcode", ",", "score", ")", "in", "hits", ":", "\n", "            ", "rcode", "[", "'for'", "]", "=", "code", "[", "'question_id'", "]", "\n", "rcode", "[", "'retrieval_score'", "]", "=", "score", "\n", "aug_dataset", ".", "append", "(", "rcode", ")", "\n", "id2count", "[", "rcode", "[", "'question_id'", "]", "]", "+=", "1", "\n", "\n", "", "", "with", "open", "(", "args", ".", "out", ",", "'w'", ")", "as", "fout", ":", "\n", "        ", "for", "code", "in", "aug_dataset", ":", "\n", "            ", "fout", ".", "write", "(", "json", ".", "dumps", "(", "code", ")", "+", "'\\n'", ")", "\n", "\n", "", "", "print", "(", "'most commonly retrieved ids {}'", ".", "format", "(", "sorted", "(", "id2count", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "[", ":", "5", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.anneal": [[105, 110], ["numpy.log", "retrieve.softmax"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "anneal", "(", "probs", ":", "np", ".", "ndarray", ",", "temperature", "=", "1", ")", ":", "\n", "    ", "lp", "=", "np", ".", "log", "(", "probs", ")", "\n", "alp", "=", "temperature", "*", "lp", "\n", "anneal_probs", "=", "softmax", "(", "alp", ")", "\n", "return", "anneal_probs", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.get_distribution": [[111, 141], ["args.inp.split", "retrieve.load_multi_files", "retrieve.ESSearcher", "collections.defaultdict", "retrieve.aug_iter", "sorted", "numpy.array", "numpy.array", "print", "print", "collections.defaultdict.items", "list", "list", "numpy.sum", "retrieve.anneal", "aug_dataset.append", "map", "map", "len", "open", "zip", "len", "operator.itemgetter", "operator.itemgetter", "list", "fout.write", "zip"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.load_multi_files", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.aug_iter", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.anneal"], ["", "def", "get_distribution", "(", "args", ")", ":", "\n", "    ", "files", "=", "args", ".", "inp", ".", "split", "(", "':'", ")", "\n", "dataset", "=", "load_multi_files", "(", "files", ",", "max_counts", "=", "[", "args", ".", "max_count", "]", "*", "len", "(", "files", ")", ")", "\n", "ess", "=", "ESSearcher", "(", "index_name", "=", "'python-docs'", ")", "\n", "\n", "aug_dataset", "=", "[", "]", "\n", "id2count", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "for", "code", ",", "hits", "in", "aug_iter", "(", "ess", ",", "dataset", ",", "args", ".", "field", ",", "args", ".", "topk", ")", ":", "\n", "        ", "for", "(", "rcode", ",", "score", ")", "in", "hits", ":", "\n", "            ", "rcode", "[", "'for'", "]", "=", "code", "[", "'question_id'", "]", "\n", "rcode", "[", "'retrieval_score'", "]", "=", "score", "\n", "aug_dataset", ".", "append", "(", "rcode", ")", "\n", "id2count", "[", "rcode", "[", "'question_id'", "]", "]", "+=", "1", "\n", "\n", "# compute distribution", "\n", "", "", "dist", "=", "sorted", "(", "id2count", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "\n", "qids", "=", "np", ".", "array", "(", "list", "(", "map", "(", "operator", ".", "itemgetter", "(", "0", ")", ",", "dist", ")", ")", ")", "\n", "probs", "=", "np", ".", "array", "(", "list", "(", "map", "(", "operator", ".", "itemgetter", "(", "1", ")", ",", "dist", ")", ")", ")", "\n", "probs", "=", "probs", "/", "np", ".", "sum", "(", "probs", ")", "\n", "\n", "if", "args", ".", "temp", ":", "# anneal", "\n", "        ", "probs", "=", "anneal", "(", "probs", ",", "args", ".", "temp", ")", "\n", "\n", "", "print", "(", "'#retrieved code {}'", ".", "format", "(", "len", "(", "probs", ")", ")", ")", "\n", "print", "(", "'most commonly retrieved ids {}'", ".", "format", "(", "list", "(", "zip", "(", "qids", ",", "probs", ")", ")", "[", ":", "5", "]", ")", ")", "\n", "\n", "if", "args", ".", "out", ":", "\n", "        ", "with", "open", "(", "args", ".", "out", ",", "'w'", ")", "as", "fout", ":", "\n", "            ", "for", "qid", ",", "ap", "in", "zip", "(", "qids", ",", "probs", ")", ":", "\n", "                ", "fout", ".", "write", "(", "'{}\\t{}\\n'", ".", "format", "(", "qid", ",", "ap", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.sample_aug": [[142, 169], ["args.inp.split", "numpy.array", "numpy.array", "retrieve.load_multi_files", "dict", "collections.defaultdict", "print", "open", "print", "print", "retrieve.anneal", "print", "open", "numpy.random.choice", "l.strip().split", "np.array.append", "anneal.append", "len", "fout.write", "float", "str", "sorted", "l.strip", "json.dumps", "collections.defaultdict.items"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.load_multi_files", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.anneal"], ["", "", "", "", "def", "sample_aug", "(", "args", ")", ":", "\n", "    ", "dist_file", ",", "data_file", "=", "args", ".", "inp", ".", "split", "(", "':'", ")", "\n", "qids", "=", "[", "]", "\n", "probs", "=", "[", "]", "\n", "with", "open", "(", "dist_file", ",", "'r'", ")", "as", "fin", ":", "\n", "        ", "for", "l", "in", "fin", ":", "\n", "            ", "qid", ",", "prob", "=", "l", ".", "strip", "(", ")", ".", "split", "(", "'\\t'", ")", "\n", "qids", ".", "append", "(", "qid", ")", "\n", "probs", ".", "append", "(", "float", "(", "prob", ")", ")", "\n", "", "", "qids", "=", "np", ".", "array", "(", "qids", ")", "\n", "probs", "=", "np", ".", "array", "(", "probs", ")", "\n", "\n", "if", "args", ".", "temp", ":", "# anneal", "\n", "        ", "print", "(", "'annel to {}'", ".", "format", "(", "args", ".", "temp", ")", ")", "\n", "print", "(", "probs", "[", ":", "5", "]", ")", "\n", "probs", "=", "anneal", "(", "probs", ",", "args", ".", "temp", ")", "\n", "print", "(", "probs", "[", ":", "5", "]", ")", "\n", "\n", "", "dataset", "=", "load_multi_files", "(", "data_file", ")", "\n", "qid2code", "=", "dict", "(", "(", "str", "(", "code", "[", "'question_id'", "]", ")", ",", "code", ")", "for", "code", "in", "dataset", ")", "\n", "qid2count", "=", "defaultdict", "(", "lambda", ":", "0", ")", "\n", "with", "open", "(", "args", ".", "out", ",", "'w'", ")", "as", "fout", ":", "\n", "        ", "for", "sam", "in", "np", ".", "random", ".", "choice", "(", "len", "(", "probs", ")", ",", "args", ".", "max_count", ",", "p", "=", "probs", ")", ":", "\n", "            ", "fout", ".", "write", "(", "json", ".", "dumps", "(", "qid2code", "[", "qids", "[", "sam", "]", "]", ")", "+", "'\\n'", ")", "\n", "qid2count", "[", "qids", "[", "sam", "]", "]", "+=", "1", "\n", "\n", "", "", "print", "(", "'mostly sampled qids {}'", ".", "format", "(", "sorted", "(", "qid2count", ".", "items", "(", ")", ",", "key", "=", "lambda", "x", ":", "-", "x", "[", "1", "]", ")", "[", ":", "5", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.tag_code_type.tokenize_libs": [[7, 14], ["set", "open", "[].split", "json.loads", "name.split"], "function", ["None"], ["def", "tokenize_libs", "(", ")", ":", "\n", "    ", "all_names", "=", "[", "]", "\n", "with", "open", "(", "'python-docs.jsonl'", ",", "encoding", "=", "'utf-8'", ")", "as", "docs_file", ":", "\n", "        ", "for", "line", "in", "docs_file", ":", "\n", "            ", "name", "=", "json", ".", "loads", "(", "line", ")", "[", "'snippet'", "]", "\n", "all_names", "+=", "(", "name", ".", "split", "(", "'('", ")", "[", "0", "]", ".", "split", "(", "'.'", ")", ")", "\n", "", "", "return", "set", "(", "all_names", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.tag_code_type.parse": [[15, 38], ["enumerate", "len", "string_stack.append", "string_stack.pop", "range", "c.isnumeric", "keyword.iskeyword"], "function", ["None"], ["", "def", "parse", "(", "tokens", ",", "lib_names", ")", ":", "\n", "    ", "tags", "=", "[", "'NAME'", "]", "*", "len", "(", "tokens", ")", "\n", "string_stack", "=", "[", "]", "\n", "for", "i", ",", "c", "in", "enumerate", "(", "tokens", ")", ":", "\n", "        ", "if", "c", "==", "'`'", "and", "not", "string_stack", ":", "\n", "            ", "string_stack", ".", "append", "(", "i", ")", "\n", "tags", "[", "i", "]", "=", "'PUNCT'", "\n", "", "elif", "c", "==", "'`'", "and", "string_stack", ":", "\n", "            ", "start", "=", "string_stack", ".", "pop", "(", ")", "\n", "tags", "[", "i", "]", "=", "'PUNCT'", "\n", "for", "idx", "in", "range", "(", "start", "+", "1", ",", "i", ")", ":", "\n", "                ", "tags", "[", "idx", "]", "=", "\"STR\"", "\n", "", "", "elif", "c", ".", "isnumeric", "(", ")", ":", "\n", "            ", "tags", "[", "i", "]", "=", "'NUM'", "\n", "", "elif", "c", "in", "string", ".", "punctuation", ":", "\n", "            ", "tags", "[", "i", "]", "=", "'PUNCT'", "\n", "", "elif", "keyword", ".", "iskeyword", "(", "c", ")", ":", "\n", "            ", "tags", "[", "i", "]", "=", "'KEYWORD'", "\n", "", "elif", "c", "in", "lib_names", ":", "\n", "            ", "tags", "[", "i", "]", "=", "'LIB'", "\n", "", "else", ":", "\n", "            ", "tags", "[", "i", "]", "=", "'NAME'", "\n", "", "", "return", "tags", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.search_es.get_top_k": [[7, 15], ["print", "print", "print", "print", "print", "es.search"], "function", ["None"], ["def", "get_top_k", "(", "query", ",", "k", "=", "5", ")", ":", "\n", "    ", "results", "=", "es", ".", "search", "(", "index", "=", "'python-code'", ",", "params", "=", "{", "\"q\"", ":", "query", "}", ")", "[", "'hits'", "]", "[", "'hits'", "]", "[", ":", "k", "]", "\n", "for", "doc", "in", "results", ":", "\n", "        ", "print", "(", "\"Score: \"", ",", "doc", "[", "'_score'", "]", ")", "\n", "print", "(", "\"Docstring: \"", ",", "doc", "[", "'_source'", "]", "[", "'doc'", "]", "[", "'docstring'", "]", ")", "\n", "print", "(", "\"Code: \"", ",", "doc", "[", "'_source'", "]", "[", "'doc'", "]", "[", "'code'", "]", ")", "\n", "print", "(", "\"URL: \"", ",", "doc", "[", "'_source'", "]", "[", "'doc'", "]", "[", "'url'", "]", ")", "\n", "print", "(", "\"\\n\\n\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.index_es.gendata": [[13, 24], ["open", "json.loads", "json.loads.items"], "function", ["None"], ["def", "gendata", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "encoding", "=", "'utf-8'", ")", "as", "jsonl", ":", "\n", "        ", "for", "line", "in", "jsonl", ":", "\n", "            ", "doc", "=", "json", ".", "loads", "(", "line", ")", "\n", "result", "=", "{", "\n", "\"_index\"", ":", "\"python-code\"", ",", "\n", "\"_type\"", ":", "\"document\"", "\n", "}", "\n", "for", "k", ",", "v", "in", "doc", ".", "items", "(", ")", ":", "\n", "                ", "result", "[", "k", "]", "=", "v", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.__init__": [[24, 42], ["super().__init__", "model.decomposable_attention_model.DecomposableAttentionModel", "model.decomposable_attention_model.DecomposableAttentionModel"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "vocab", ",", "transition_system", ")", ":", "\n", "        ", "super", "(", "ParaphraseIdentificationModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "args", ".", "tie_embed", ":", "\n", "            ", "self", ".", "pi_model", "=", "DecomposableAttentionModel", "(", "src_vocab", "=", "vocab", ",", "tgt_vocab", "=", "vocab", ",", "\n", "embed_size", "=", "args", ".", "embed_size", ",", "\n", "dropout", "=", "args", ".", "dropout", ",", "\n", "tie_embed", "=", "True", ",", "\n", "cuda", "=", "args", ".", "cuda", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "pi_model", "=", "DecomposableAttentionModel", "(", "src_vocab", "=", "vocab", ".", "code", ",", "tgt_vocab", "=", "vocab", ".", "source", ",", "\n", "embed_size", "=", "args", ".", "embed_size", ",", "\n", "dropout", "=", "args", ".", "dropout", ",", "\n", "tie_embed", "=", "False", ",", "\n", "cuda", "=", "args", ".", "cuda", ")", "\n", "\n", "", "self", ".", "vocab", "=", "vocab", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "transition_system", "=", "transition_system", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.feature_name": [[43, 46], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'paraphrase_identifier'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.is_batched": [[47, 50], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel._score": [[51, 68], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "paraphrase.ParaphraseIdentificationModel.pi_model", "paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling().t", "paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling().t", "model.nn_utils.to_input_variable().t", "model.nn_utils.to_input_variable().t", "model.nn_utils.length_array_to_mask_tensor().float", "model.nn_utils.length_array_to_mask_tensor().float", "paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling", "paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling", "model.nn_utils.to_input_variable", "model.nn_utils.to_input_variable", "model.nn_utils.length_array_to_mask_tensor", "model.nn_utils.length_array_to_mask_tensor", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor"], ["", "def", "_score", "(", "self", ",", "src_codes", ",", "tgt_nls", ")", ":", "\n", "        ", "\"\"\"score examples sorted by code length\"\"\"", "\n", "args", "=", "self", ".", "args", "\n", "\n", "if", "args", ".", "tie_embed", ":", "\n", "            ", "src_code_var", "=", "self", ".", "to_input_variable_with_unk_handling", "(", "src_codes", ",", "cuda", "=", "args", ".", "cuda", ")", ".", "t", "(", ")", "\n", "tgt_nl_var", "=", "self", ".", "to_input_variable_with_unk_handling", "(", "tgt_nls", ",", "cuda", "=", "args", ".", "cuda", ")", ".", "t", "(", ")", "\n", "", "else", ":", "\n", "            ", "src_code_var", "=", "nn_utils", ".", "to_input_variable", "(", "src_codes", ",", "self", ".", "vocab", ".", "code", ",", "cuda", "=", "args", ".", "cuda", ")", ".", "t", "(", ")", "\n", "tgt_nl_var", "=", "nn_utils", ".", "to_input_variable", "(", "tgt_nls", ",", "self", ".", "vocab", ".", "source", ",", "cuda", "=", "args", ".", "cuda", ")", ".", "t", "(", ")", "\n", "\n", "", "src_code_mask", "=", "Variable", "(", "nn_utils", ".", "length_array_to_mask_tensor", "(", "[", "len", "(", "x", ")", "for", "x", "in", "src_codes", "]", ",", "cuda", "=", "args", ".", "cuda", ",", "valid_entry_has_mask_one", "=", "True", ")", ".", "float", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "tgt_nl_mask", "=", "Variable", "(", "nn_utils", ".", "length_array_to_mask_tensor", "(", "[", "len", "(", "x", ")", "for", "x", "in", "tgt_nls", "]", ",", "cuda", "=", "args", ".", "cuda", ",", "valid_entry_has_mask_one", "=", "True", ")", ".", "float", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n", "scores", "=", "self", ".", "pi_model", "(", "src_code_var", ",", "tgt_nl_var", ",", "src_code_mask", ",", "tgt_nl_mask", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.forward": [[69, 76], ["paraphrase.ParaphraseIdentificationModel._score", "paraphrase.ParaphraseIdentificationModel.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor._score", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "forward", "(", "self", ",", "examples", ")", ":", "\n", "        ", "tokenized_codes", "=", "[", "self", ".", "tokenize_code", "(", "e", ".", "tgt_code", ")", "for", "e", "in", "examples", "]", "\n", "tgt_nls", "=", "[", "e", ".", "src_sent", "for", "e", "in", "examples", "]", "\n", "\n", "scores", "=", "self", ".", "_score", "(", "tokenized_codes", ",", "tgt_nls", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.score": [[77, 79], ["paraphrase.ParaphraseIdentificationModel.forward"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.forward"], ["", "def", "score", "(", "self", ",", "examples", ")", ":", "\n", "        ", "return", "self", ".", "forward", "(", "examples", ")", "[", ":", ",", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.tokenize_code": [[80, 82], ["paraphrase.ParaphraseIdentificationModel.transition_system.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "tokenize_code", "(", "self", ",", "code", ")", ":", "\n", "        ", "return", "self", ".", "transition_system", ".", "tokenize_code", "(", "code", ",", "mode", "=", "'decoder'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.to_input_variable_with_unk_handling": [[83, 113], ["model.nn_utils.input_transpose", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "dict", "word_ids.append", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "sents_var.cuda.cuda.cuda", "paraphrase.ParaphraseIdentificationModel.vocab.is_unk", "seq_wids.append", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.input_transpose", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.is_unk"], ["", "def", "to_input_variable_with_unk_handling", "(", "self", ",", "sequences", ",", "cuda", "=", "False", ",", "training", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        given a list of sequences,\n        return a tensor of shape (max_sent_len, batch_size)\n        \"\"\"", "\n", "word_ids", "=", "[", "]", "\n", "for", "seq", "in", "sequences", ":", "\n", "            ", "unk_dict", "=", "dict", "(", ")", "\n", "seq_wids", "=", "[", "]", "\n", "for", "word", "in", "seq", ":", "\n", "                ", "if", "self", ".", "vocab", ".", "is_unk", "(", "word", ")", ":", "\n", "                    ", "if", "word", "in", "unk_dict", ":", "\n", "                        ", "word_id", "=", "unk_dict", "[", "word", "]", "\n", "", "else", ":", "\n", "                        ", "word_id", "=", "self", ".", "vocab", "[", "'<unk_%d>'", "%", "len", "(", "unk_dict", ")", "]", "\n", "unk_dict", "[", "word", "]", "=", "word_id", "\n", "", "", "else", ":", "\n", "                    ", "word_id", "=", "self", ".", "vocab", "[", "word", "]", "\n", "\n", "", "seq_wids", ".", "append", "(", "word_id", ")", "\n", "\n", "", "word_ids", ".", "append", "(", "seq_wids", ")", "\n", "\n", "", "sents_t", "=", "input_transpose", "(", "word_ids", ",", "self", ".", "vocab", "[", "'<pad>'", "]", ")", "\n", "\n", "sents_var", "=", "Variable", "(", "torch", ".", "LongTensor", "(", "sents_t", ")", ",", "volatile", "=", "(", "not", "training", ")", ",", "requires_grad", "=", "False", ")", "\n", "if", "cuda", ":", "\n", "            ", "sents_var", "=", "sents_var", ".", "cuda", "(", ")", "\n", "\n", "", "return", "sents_var", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.save": [[114, 127], ["os.path.dirname", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.exists", "os.makedirs", "paraphrase.ParaphraseIdentificationModel.state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "dirname", "(", "path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_name", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_name", ")", "\n", "\n", "", "params", "=", "{", "\n", "'args'", ":", "self", ".", "args", ",", "\n", "'vocab'", ":", "self", ".", "vocab", ",", "\n", "'state_dict'", ":", "self", ".", "state_dict", "(", ")", ",", "\n", "'transition_system'", ":", "self", ".", "transition_system", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "params", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.paraphrase.ParaphraseIdentificationModel.load": [[128, 142], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "common.utils.update_args", "paraphrase.ParaphraseIdentificationModel", "model.cuda.cuda.load_state_dict", "model.cuda.cuda.eval", "common.utils.init_arg_parser", "model.cuda.cuda.cuda"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.update_args", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.init_arg_parser"], ["", "@", "staticmethod", "\n", "def", "load", "(", "model_path", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "decoder_params", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "decoder_params", "[", "'args'", "]", ".", "cuda", "=", "cuda", "\n", "# update saved args", "\n", "saved_args", "=", "decoder_params", "[", "'args'", "]", "\n", "update_args", "(", "saved_args", ",", "init_arg_parser", "(", ")", ")", "\n", "model", "=", "ParaphraseIdentificationModel", "(", "saved_args", ",", "decoder_params", "[", "'vocab'", "]", ",", "decoder_params", "[", "'transition_system'", "]", ")", "\n", "model", ".", "load_state_dict", "(", "decoder_params", "[", "'state_dict'", "]", ")", "\n", "\n", "if", "cuda", ":", "model", "=", "model", ".", "cuda", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "return", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq_copy.Seq2SeqWithCopy.__init__": [[17, 33], ["model.seq2seq.Seq2SeqModel.__init__", "model.pointer_net.PointerNet", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "src_vocab", ",", "tgt_vocab", ",", "embed_size", ",", "hidden_size", ",", "\n", "dropout", "=", "0.", ",", "\n", "cuda", "=", "False", ",", "\n", "src_embed_layer", "=", "None", ",", "tgt_embed_layer", "=", "None", ")", ":", "\n", "\n", "        ", "super", "(", "Seq2SeqWithCopy", ",", "self", ")", ".", "__init__", "(", "src_vocab", ",", "tgt_vocab", ",", "\n", "embed_size", ",", "hidden_size", ",", "\n", "dropout", "=", "dropout", ",", "\n", "src_embed_layer", "=", "src_embed_layer", ",", "tgt_embed_layer", "=", "tgt_embed_layer", ",", "\n", "cuda", "=", "cuda", ")", "\n", "\n", "# pointer net to the source", "\n", "self", ".", "src_pointer_net", "=", "PointerNet", "(", "src_encoding_size", "=", "hidden_size", "*", "2", ",", "\n", "query_vec_size", "=", "hidden_size", ")", "\n", "\n", "self", ".", "tgt_token_predictor", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq_copy.Seq2SeqWithCopy.encode": [[34, 57], ["seq2seq_copy.Seq2SeqWithCopy.src_embed", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "seq2seq_copy.Seq2SeqWithCopy.encoder_lstm", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "src_encodings.permute.permute.permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "src_sents_var", ",", "src_sents_len", ")", ":", "\n", "        ", "\"\"\"\n        encode the source sequence\n        :return:\n            src_encodings: Variable(src_sent_len, batch_size, hidden_size * 2)\n            dec_init_state, dec_init_cell: Variable(batch_size, hidden_size)\n        \"\"\"", "\n", "\n", "# (tgt_query_len, batch_size, embed_size)", "\n", "src_token_embed", "=", "self", ".", "src_embed", "(", "src_sents_var", ")", "\n", "packed_src_token_embed", "=", "pack_padded_sequence", "(", "src_token_embed", ",", "src_sents_len", ")", "\n", "\n", "# src_encodings: (tgt_query_len, batch_size, hidden_size)", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encoder_lstm", "(", "packed_src_token_embed", ")", "\n", "src_encodings", ",", "_", "=", "pad_packed_sequence", "(", "src_encodings", ")", "\n", "# (batch_size, query_len, hidden_size * 2)", "\n", "src_encodings", "=", "src_encodings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "# (batch_size, hidden_size * 2)", "\n", "last_state", "=", "torch", ".", "cat", "(", "[", "last_state", "[", "0", "]", ",", "last_state", "[", "1", "]", "]", ",", "1", ")", "\n", "last_cell", "=", "torch", ".", "cat", "(", "[", "last_cell", "[", "0", "]", ",", "last_cell", "[", "1", "]", "]", ",", "1", ")", "\n", "\n", "return", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq_copy.Seq2SeqWithCopy.decode": [[58, 93], ["src_encodings.size", "seq2seq_copy.Seq2SeqWithCopy.att_src_linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "seq2seq_copy.Seq2SeqWithCopy.tgt_embed", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "new_tensor().zero_", "list", "y_tm1_embed.squeeze.squeeze.squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "seq2seq_copy.Seq2SeqWithCopy.step", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "enumerate", "new_tensor", "seq2seq_copy.Seq2SeqWithCopy.split"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step"], ["", "def", "decode", "(", "self", ",", "src_encodings", ",", "src_sent_masks", ",", "dec_init_vec", ",", "tgt_sents_var", ")", ":", "\n", "        ", "new_tensor", "=", "src_encodings", ".", "data", ".", "new", "\n", "batch_size", "=", "src_encodings", ".", "size", "(", "0", ")", "\n", "\n", "h_tm1", "=", "dec_init_vec", "\n", "\n", "# (batch_size, query_len, hidden_size)", "\n", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "# initialize the attentional vector", "\n", "att_tm1", "=", "Variable", "(", "new_tensor", "(", "batch_size", ",", "self", ".", "hidden_size", ")", ".", "zero_", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# (tgt_sent_len, batch_size, embed_size)", "\n", "tgt_token_embed", "=", "self", ".", "tgt_embed", "(", "tgt_sents_var", ")", "\n", "\n", "att_ves", "=", "[", "]", "\n", "# start from `<s>`, until y_{T-1}", "\n", "for", "t", ",", "y_tm1_embed", "in", "list", "(", "enumerate", "(", "tgt_token_embed", ".", "split", "(", "split_size", "=", "1", ")", ")", ")", "[", ":", "-", "1", "]", ":", "\n", "# input feeding: concate y_tm1 and previous attentional vector", "\n", "# split() keeps the first dim", "\n", "            ", "y_tm1_embed", "=", "y_tm1_embed", ".", "squeeze", "(", "0", ")", "\n", "x", "=", "torch", ".", "cat", "(", "[", "y_tm1_embed", ",", "att_tm1", "]", ",", "1", ")", "\n", "\n", "(", "h_t", ",", "cell_t", ")", ",", "att_t", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "\n", "src_encodings", ",", "src_encodings_att_linear", ",", "\n", "src_sent_masks", "=", "src_sent_masks", ")", "\n", "\n", "att_ves", ".", "append", "(", "att_t", ")", "\n", "\n", "att_tm1", "=", "att_t", "\n", "h_tm1", "=", "(", "h_t", ",", "cell_t", ")", "\n", "\n", "# (src_sent_len, batch_size, tgt_vocab_size)", "\n", "", "att_ves", "=", "torch", ".", "stack", "(", "att_ves", ")", "\n", "\n", "return", "att_ves", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq_copy.Seq2SeqWithCopy.forward": [[94, 141], ["seq2seq_copy.Seq2SeqWithCopy.encode", "seq2seq_copy.Seq2SeqWithCopy.init_decoder_state", "model.nn_utils.length_array_to_mask_tensor", "seq2seq_copy.Seq2SeqWithCopy.decode", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "seq2seq_copy.Seq2SeqWithCopy.src_pointer_net", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.gt().float", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log.sum", "torch.log.sum", "torch.log.sum", "torch.log.sum", "seq2seq_copy.Seq2SeqWithCopy.tgt_token_predictor", "seq2seq_copy.Seq2SeqWithCopy.readout", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gt", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "tgt_token_copy_idx_mask.sum", "tgt_token_idx.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "forward", "(", "self", ",", "src_sents_var", ",", "src_sents_len", ",", "tgt_sents_var", ",", "tgt_token_copy_idx_mask", ",", "tgt_token_gen_mask", ")", ":", "\n", "        ", "\"\"\"\n        compute log p(y|x)\n\n        :param tgt_token_copy_idx_mask: Variable(tgt_action_len, batch_size, src_seq_len)\n        :return: Variable(batch_size)\n        \"\"\"", "\n", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "src_sents_var", ",", "src_sents_len", ")", "\n", "dec_init_vec", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "\n", "# (batch_size, src_sent_len)", "\n", "src_sent_masks", "=", "nn_utils", ".", "length_array_to_mask_tensor", "(", "src_sents_len", ",", "cuda", "=", "self", ".", "cuda", ")", "\n", "\n", "# (tgt_sent_len - 1, batch_size, hidden_size)", "\n", "att_vecs", "=", "self", ".", "decode", "(", "src_encodings", ",", "src_sent_masks", ",", "dec_init_vec", ",", "tgt_sents_var", ")", "\n", "\n", "# (tgt_sent_len - 1, batch_size, 2)", "\n", "tgt_token_predictor", "=", "F", ".", "softmax", "(", "self", ".", "tgt_token_predictor", "(", "att_vecs", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# (tgt_sent_len - 1, batch_size, tgt_vocab_size)", "\n", "token_gen_prob", "=", "F", ".", "softmax", "(", "self", ".", "readout", "(", "att_vecs", ")", ",", "dim", "=", "-", "1", ")", "\n", "# (tgt_sent_len - 1, batch_size, src_sent_len)", "\n", "token_copy_prob", "=", "self", ".", "src_pointer_net", "(", "src_encodings", ",", "src_sent_masks", ",", "att_vecs", ")", "\n", "\n", "tgt_token_idx", "=", "tgt_sents_var", "[", "1", ":", "]", "# remove leading <s>", "\n", "tgt_token_gen_mask", "=", "tgt_token_gen_mask", "[", "1", ":", "]", "\n", "tgt_token_copy_idx_mask", "=", "tgt_token_copy_idx_mask", "[", "1", ":", "]", "\n", "\n", "# (tgt_sent_len - 1, batch_size)", "\n", "tgt_token_gen_prob", "=", "torch", ".", "gather", "(", "token_gen_prob", ",", "dim", "=", "2", ",", "\n", "index", "=", "tgt_token_idx", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "*", "tgt_token_gen_mask", "\n", "\n", "# (tgt_sent_len - 1, batch_size)", "\n", "tgt_token_copy_prob", "=", "torch", ".", "sum", "(", "token_copy_prob", "*", "tgt_token_copy_idx_mask", ",", "dim", "=", "-", "1", ")", "\n", "# tgt_token_copy_prob = torch.gather(token_copy_prob, dim=2, index=tgt_token_copy_pos.unsqueeze(2)).squeeze(2) * tgt_token_copy_mask", "\n", "\n", "tgt_token_mask", "=", "torch", ".", "gt", "(", "tgt_token_gen_mask", "+", "tgt_token_copy_idx_mask", ".", "sum", "(", "dim", "=", "-", "1", ")", ",", "0.", ")", ".", "float", "(", ")", "\n", "tgt_token_prob", "=", "torch", ".", "log", "(", "tgt_token_predictor", "[", ":", ",", ":", ",", "0", "]", "*", "tgt_token_gen_prob", "+", "\n", "tgt_token_predictor", "[", ":", ",", ":", ",", "1", "]", "*", "tgt_token_copy_prob", "+", "\n", "1.e-7", "*", "(", "1.", "-", "tgt_token_mask", ")", ")", "\n", "tgt_token_prob", "=", "tgt_token_prob", "*", "tgt_token_mask", "\n", "\n", "# (batch_size)", "\n", "scores", "=", "tgt_token_prob", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq_copy.Seq2SeqWithCopy.step": [[142, 157], ["seq2seq_copy.Seq2SeqWithCopy.decoder_lstm", "model.nn_utils.dot_prod_attention", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "seq2seq_copy.Seq2SeqWithCopy.dropout", "seq2seq_copy.Seq2SeqWithCopy.att_vec_linear", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.dot_prod_attention"], ["", "def", "step", "(", "self", ",", "x", ",", "h_tm1", ",", "src_encodings", ",", "src_encodings_att_linear", ",", "src_sent_masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        a single LSTM decoding step\n        \"\"\"", "\n", "# h_t: (batch_size, hidden_size)", "\n", "h_t", ",", "cell_t", "=", "self", ".", "decoder_lstm", "(", "x", ",", "h_tm1", ")", "\n", "\n", "ctx_t", ",", "alpha_t", "=", "nn_utils", ".", "dot_prod_attention", "(", "h_t", ",", "\n", "src_encodings", ",", "src_encodings_att_linear", ",", "\n", "mask", "=", "src_sent_masks", ")", "\n", "\n", "att_t", "=", "torch", ".", "tanh", "(", "self", ".", "att_vec_linear", "(", "torch", ".", "cat", "(", "[", "h_t", ",", "ctx_t", "]", ",", "1", ")", ")", ")", "# E.q. (5)", "\n", "att_t", "=", "self", ".", "dropout", "(", "att_t", ")", "\n", "\n", "return", "(", "h_t", ",", "cell_t", ")", ",", "att_t", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq_copy.Seq2SeqWithCopy.sample": [[158, 297], ["model.nn_utils.to_input_variable", "set", "enumerate", "seq2seq_copy.Seq2SeqWithCopy.encode", "seq2seq_copy.Seq2SeqWithCopy.init_decoder_state", "seq2seq_copy.Seq2SeqWithCopy.att_src_linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "new_float_tensor().zero_", "new_float_tensor().zero_", "len", "src_encodings.expand", "seq2seq_copy.Seq2SeqWithCopy.expand", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "seq2seq_copy.Seq2SeqWithCopy.tgt_embed", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "seq2seq_copy.Seq2SeqWithCopy.step", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "seq2seq_copy.Seq2SeqWithCopy.src_pointer_net().squeeze", "enumerate", "zip", "new_long_tensor", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "enumerate", "set.add", "len", "len", "src_encodings.size", "src_encodings.size", "seq2seq_copy.Seq2SeqWithCopy.size", "seq2seq_copy.Seq2SeqWithCopy.size", "new_long_tensor", "seq2seq_copy.Seq2SeqWithCopy.tgt_token_predictor", "seq2seq_copy.Seq2SeqWithCopy.readout", "tgt_token_predictor[].unsqueeze", "range", "len", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "range", "len", "new_float_tensor", "range", "range", "new_float_tensor", "new_float_tensor", "seq2seq_copy.Seq2SeqWithCopy.src_pointer_net", "[].data.cpu().numpy().argmax", "gentoken_new_hyp_unks.append", "top_new_hyp_scores.cpu", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "top_new_hyp_scores.cpu", "torch.multinomial.view().cpu", "torch.multinomial.view().cpu", "torch.multinomial.view().cpu", "torch.multinomial.view().cpu", "completed_hypotheses.append", "completed_hypothesis_scores.append", "new_hypotheses.append", "new_hypotheses_word_ids.append", "new_long_tensor.append", "new_hyp_scores.append", "len", "len", "att_t.unsqueeze", "[].data.cpu().numpy", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze().expand_as", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.multinomial.view", "torch.multinomial.view", "torch.multinomial.view", "torch.multinomial.view", "len", "len", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "[].data.cpu", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.vocab.VocabEntry.add", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "def", "sample", "(", "self", ",", "src_sent", ",", "sample_size", ",", "decode_max_time_step", ",", "cuda", "=", "False", ",", "mode", "=", "'sample'", ")", ":", "\n", "        ", "new_float_tensor", "=", "torch", ".", "cuda", ".", "FloatTensor", "if", "cuda", "else", "torch", ".", "FloatTensor", "\n", "new_long_tensor", "=", "torch", ".", "cuda", ".", "LongTensor", "if", "cuda", "else", "torch", ".", "LongTensor", "\n", "\n", "src_sent_var", "=", "nn_utils", ".", "to_input_variable", "(", "[", "src_sent", "]", ",", "self", ".", "src_vocab", ",", "\n", "cuda", "=", "cuda", ",", "training", "=", "False", ")", "\n", "\n", "# analyze which tokens can be copied from the source", "\n", "src_token_tgt_vocab_ids", "=", "[", "self", ".", "tgt_vocab", "[", "token", "]", "for", "token", "in", "src_sent", "]", "\n", "src_unk_pos_list", "=", "[", "pos", "for", "pos", ",", "token_id", "in", "enumerate", "(", "src_token_tgt_vocab_ids", ")", "if", "\n", "token_id", "==", "self", ".", "tgt_vocab", ".", "unk_id", "]", "\n", "# sometimes a word may appear multi-times in the source, in this case,", "\n", "# we just copy its first appearing position. Therefore we mask the words", "\n", "# appearing second and onwards to -1", "\n", "token_set", "=", "set", "(", ")", "\n", "for", "i", ",", "tid", "in", "enumerate", "(", "src_token_tgt_vocab_ids", ")", ":", "\n", "            ", "if", "tid", "in", "token_set", ":", "\n", "                ", "src_token_tgt_vocab_ids", "[", "i", "]", "=", "-", "1", "\n", "", "else", ":", "\n", "                ", "token_set", ".", "add", "(", "tid", ")", "\n", "\n", "", "", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "src_sent_var", ",", "[", "len", "(", "src_sent", ")", "]", ")", "\n", "h_tm1", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "\n", "# (batch_size, 1, hidden_size)", "\n", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "\n", "t", "=", "0", "\n", "eos_id", "=", "self", ".", "tgt_vocab", "[", "'</s>'", "]", "\n", "\n", "completed_hypotheses", "=", "[", "]", "\n", "completed_hypothesis_scores", "=", "[", "]", "\n", "\n", "if", "mode", "==", "'beam_search'", ":", "\n", "            ", "hypotheses", "=", "[", "[", "'<s>'", "]", "]", "\n", "hypotheses_word_ids", "=", "[", "[", "self", ".", "tgt_vocab", "[", "'<s>'", "]", "]", "]", "\n", "", "else", ":", "\n", "            ", "hypotheses", "=", "[", "[", "'<s>'", "]", "for", "_", "in", "range", "(", "sample_size", ")", "]", "\n", "hypotheses_word_ids", "=", "[", "[", "self", ".", "tgt_vocab", "[", "'<s>'", "]", "]", "for", "_", "in", "range", "(", "sample_size", ")", "]", "\n", "\n", "", "att_tm1", "=", "Variable", "(", "new_float_tensor", "(", "len", "(", "hypotheses", ")", ",", "self", ".", "hidden_size", ")", ".", "zero_", "(", ")", ",", "volatile", "=", "True", ")", "\n", "hyp_scores", "=", "Variable", "(", "new_float_tensor", "(", "len", "(", "hypotheses", ")", ")", ".", "zero_", "(", ")", ",", "volatile", "=", "True", ")", "\n", "\n", "while", "len", "(", "completed_hypotheses", ")", "<", "sample_size", "and", "t", "<", "decode_max_time_step", ":", "\n", "            ", "t", "+=", "1", "\n", "hyp_num", "=", "len", "(", "hypotheses", ")", "\n", "\n", "expanded_src_encodings", "=", "src_encodings", ".", "expand", "(", "hyp_num", ",", "src_encodings", ".", "size", "(", "1", ")", ",", "src_encodings", ".", "size", "(", "2", ")", ")", "\n", "expanded_src_encodings_att_linear", "=", "src_encodings_att_linear", ".", "expand", "(", "hyp_num", ",", "\n", "src_encodings_att_linear", ".", "size", "(", "1", ")", ",", "\n", "src_encodings_att_linear", ".", "size", "(", "2", ")", ")", "\n", "\n", "y_tm1", "=", "Variable", "(", "new_long_tensor", "(", "[", "hyp", "[", "-", "1", "]", "for", "hyp", "in", "hypotheses_word_ids", "]", ")", ",", "volatile", "=", "True", ")", "\n", "y_tm1_embed", "=", "self", ".", "tgt_embed", "(", "y_tm1", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "y_tm1_embed", ",", "att_tm1", "]", ",", "1", ")", "\n", "\n", "(", "h_t", ",", "cell_t", ")", ",", "att_t", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "\n", "expanded_src_encodings", ",", "expanded_src_encodings_att_linear", ")", "\n", "\n", "# (batch_size, 2)", "\n", "tgt_token_predictor", "=", "F", ".", "softmax", "(", "self", ".", "tgt_token_predictor", "(", "att_t", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# (batch_size, tgt_vocab_size)", "\n", "token_gen_prob", "=", "F", ".", "softmax", "(", "self", ".", "readout", "(", "att_t", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# (batch_size, src_sent_len)", "\n", "token_copy_prob", "=", "self", ".", "src_pointer_net", "(", "src_encodings", ",", "src_token_mask", "=", "None", ",", "query_vec", "=", "att_t", ".", "unsqueeze", "(", "0", ")", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# (batch_size, tgt_vocab_size)", "\n", "token_gen_prob", "=", "tgt_token_predictor", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "*", "token_gen_prob", "\n", "\n", "for", "token_pos", ",", "token_vocab_id", "in", "enumerate", "(", "src_token_tgt_vocab_ids", ")", ":", "\n", "                ", "if", "token_vocab_id", "!=", "-", "1", "and", "token_vocab_id", "!=", "self", ".", "tgt_vocab", ".", "unk_id", ":", "\n", "                    ", "p_copy", "=", "tgt_token_predictor", "[", ":", ",", "1", "]", "*", "token_copy_prob", "[", ":", ",", "token_pos", "]", "\n", "token_gen_prob", "[", ":", ",", "token_vocab_id", "]", "=", "token_gen_prob", "[", ":", ",", "token_vocab_id", "]", "+", "p_copy", "\n", "\n", "# second, add the probability of copying the most probable unk word", "\n", "", "", "gentoken_new_hyp_unks", "=", "[", "]", "\n", "if", "src_unk_pos_list", ":", "\n", "                ", "for", "hyp_id", "in", "range", "(", "hyp_num", ")", ":", "\n", "                    ", "unk_pos", "=", "token_copy_prob", "[", "hyp_id", "]", "[", "src_unk_pos_list", "]", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ".", "argmax", "(", ")", "\n", "unk_pos", "=", "src_unk_pos_list", "[", "unk_pos", "]", "\n", "token", "=", "src_sent", "[", "unk_pos", "]", "\n", "gentoken_new_hyp_unks", ".", "append", "(", "token", ")", "\n", "\n", "unk_copy_score", "=", "tgt_token_predictor", "[", "hyp_id", ",", "1", "]", "*", "token_copy_prob", "[", "hyp_id", ",", "unk_pos", "]", "\n", "token_gen_prob", "[", "hyp_id", ",", "self", ".", "tgt_vocab", ".", "unk_id", "]", "=", "unk_copy_score", "\n", "\n", "", "", "live_hyp_num", "=", "sample_size", "-", "len", "(", "completed_hypotheses", ")", "\n", "\n", "if", "mode", "==", "'beam_search'", ":", "\n", "                ", "log_token_gen_prob", "=", "torch", ".", "log", "(", "token_gen_prob", ")", "\n", "new_hyp_scores", "=", "(", "hyp_scores", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "token_gen_prob", ")", "+", "log_token_gen_prob", ")", ".", "view", "(", "-", "1", ")", "\n", "top_new_hyp_scores", ",", "top_new_hyp_pos", "=", "torch", ".", "topk", "(", "new_hyp_scores", ",", "k", "=", "live_hyp_num", ")", "\n", "prev_hyp_ids", "=", "(", "top_new_hyp_pos", "/", "len", "(", "self", ".", "tgt_vocab", ")", ")", ".", "cpu", "(", ")", ".", "data", "\n", "word_ids", "=", "(", "top_new_hyp_pos", "%", "len", "(", "self", ".", "tgt_vocab", ")", ")", ".", "cpu", "(", ")", ".", "data", "\n", "top_new_hyp_scores", "=", "top_new_hyp_scores", ".", "cpu", "(", ")", ".", "data", "\n", "", "else", ":", "\n", "                ", "word_ids", "=", "torch", ".", "multinomial", "(", "token_gen_prob", ",", "num_samples", "=", "1", ")", "\n", "prev_hyp_ids", "=", "range", "(", "live_hyp_num", ")", "\n", "top_new_hyp_scores", "=", "hyp_scores", "+", "torch", ".", "log", "(", "torch", ".", "gather", "(", "token_gen_prob", ",", "dim", "=", "1", ",", "index", "=", "word_ids", ")", ")", ".", "squeeze", "(", "1", ")", "\n", "top_new_hyp_scores", "=", "top_new_hyp_scores", ".", "cpu", "(", ")", ".", "data", "\n", "word_ids", "=", "word_ids", ".", "view", "(", "-", "1", ")", ".", "cpu", "(", ")", ".", "data", "\n", "\n", "", "new_hypotheses", "=", "[", "]", "\n", "new_hypotheses_word_ids", "=", "[", "]", "\n", "live_hyp_ids", "=", "[", "]", "\n", "new_hyp_scores", "=", "[", "]", "\n", "for", "prev_hyp_id", ",", "word_id", ",", "new_hyp_score", "in", "zip", "(", "prev_hyp_ids", ",", "word_ids", ",", "top_new_hyp_scores", ")", ":", "\n", "                ", "if", "word_id", "==", "eos_id", ":", "\n", "                    ", "hyp_tgt_words", "=", "hypotheses", "[", "prev_hyp_id", "]", "[", "1", ":", "]", "\n", "completed_hypotheses", ".", "append", "(", "hyp_tgt_words", ")", "# remove <s> and </s> in completed hypothesis", "\n", "completed_hypothesis_scores", ".", "append", "(", "new_hyp_score", ")", "\n", "", "else", ":", "\n", "                    ", "if", "word_id", "==", "self", ".", "tgt_vocab", ".", "unk_id", ":", "\n", "                        ", "if", "gentoken_new_hyp_unks", ":", "word", "=", "gentoken_new_hyp_unks", "[", "prev_hyp_id", "]", "\n", "else", ":", "word", "=", "self", ".", "tgt_vocab", ".", "id2word", "[", "self", ".", "tgt_vocab", ".", "unk_id", "]", "\n", "", "else", ":", "\n", "                        ", "word", "=", "self", ".", "tgt_vocab", ".", "id2word", "[", "word_id", "]", "\n", "\n", "", "hyp_tgt_words", "=", "hypotheses", "[", "prev_hyp_id", "]", "+", "[", "word", "]", "\n", "new_hypotheses", ".", "append", "(", "hyp_tgt_words", ")", "\n", "new_hypotheses_word_ids", ".", "append", "(", "hypotheses_word_ids", "[", "prev_hyp_id", "]", "+", "[", "word_id", "]", ")", "\n", "live_hyp_ids", ".", "append", "(", "prev_hyp_id", ")", "\n", "new_hyp_scores", ".", "append", "(", "new_hyp_score", ")", "\n", "\n", "", "", "if", "len", "(", "completed_hypotheses", ")", "==", "sample_size", ":", "\n", "                ", "break", "\n", "\n", "", "live_hyp_ids", "=", "new_long_tensor", "(", "live_hyp_ids", ")", "\n", "h_tm1", "=", "(", "h_t", "[", "live_hyp_ids", "]", ",", "cell_t", "[", "live_hyp_ids", "]", ")", "\n", "att_tm1", "=", "att_t", "[", "live_hyp_ids", "]", "\n", "\n", "hyp_scores", "=", "Variable", "(", "new_float_tensor", "(", "new_hyp_scores", ")", ",", "volatile", "=", "True", ")", "# new_hyp_scores[live_hyp_ids]", "\n", "hypotheses", "=", "new_hypotheses", "\n", "hypotheses_word_ids", "=", "new_hypotheses_word_ids", "\n", "\n", "", "return", "completed_hypotheses", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.__init__": [[23, 40], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "struct_vae.StructVAE.b.data.fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ",", "prior", ",", "args", ")", ":", "\n", "        ", "super", "(", "StructVAE", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "encoder", "=", "encoder", "\n", "self", ".", "decoder", "=", "decoder", "\n", "self", ".", "prior", "=", "prior", "\n", "\n", "self", ".", "transition_system", "=", "self", ".", "encoder", ".", "transition_system", "\n", "self", ".", "args", "=", "args", "\n", "\n", "# for baseline", "\n", "self", ".", "b_x_l1", "=", "nn", ".", "Linear", "(", "args", ".", "hidden_size", ",", "20", ")", "\n", "self", ".", "b_x_l2", "=", "nn", ".", "Linear", "(", "20", ",", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "b", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "1", ")", ")", "\n", "\n", "# initialize baseline to be a small negative number", "\n", "self", ".", "b", ".", "data", ".", "fill_", "(", "-", "20.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.get_unsupervised_loss": [[41, 79], ["struct_vae.StructVAE.infer", "struct_vae.StructVAE.decoder.score", "struct_vae.StructVAE.prior", "isinstance", "struct_vae.StructVAE.baseline", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "raw_learning_signal.detach", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "torch.lt().float", "sample_scores.data.new", "clipped_learning_signal.detach", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt", "torch.lt"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.infer", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.score", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_SrcLmAndLinearBaseline.baseline"], ["", "def", "get_unsupervised_loss", "(", "self", ",", "examples", ")", ":", "\n", "        ", "samples", ",", "sample_scores", ",", "enc_states", "=", "self", ".", "infer", "(", "examples", ")", "\n", "\n", "reconstruction_scores", "=", "self", ".", "decoder", ".", "score", "(", "samples", ")", "\n", "\n", "# compute prior probability", "\n", "prior_scores", "=", "self", ".", "prior", "(", "[", "e", ".", "tgt_code", "for", "e", "in", "samples", "]", ")", "\n", "if", "isinstance", "(", "self", ".", "prior", ",", "UniformPrior", ")", ":", "\n", "            ", "prior_scores", "=", "Variable", "(", "sample_scores", ".", "data", ".", "new", "(", "prior_scores", ")", ")", "\n", "\n", "", "kl_term", "=", "self", ".", "args", ".", "alpha", "*", "(", "sample_scores", "-", "prior_scores", ")", "\n", "raw_learning_signal", "=", "reconstruction_scores", "-", "kl_term", "\n", "baseline", "=", "self", ".", "baseline", "(", "samples", ",", "enc_states", ")", "\n", "learning_signal", "=", "raw_learning_signal", ".", "detach", "(", ")", "-", "baseline", "\n", "\n", "# clip learning signal", "\n", "if", "self", ".", "args", ".", "clip_learning_signal", "is", "not", "None", ":", "\n", "            ", "mask", "=", "torch", ".", "lt", "(", "learning_signal", ",", "self", ".", "args", ".", "clip_learning_signal", ")", ".", "float", "(", ")", "\n", "clipped_learning_signal", "=", "learning_signal", "*", "(", "1.", "-", "mask", ")", "+", "mask", "*", "self", ".", "args", ".", "clip_learning_signal", "\n", "", "else", ":", "\n", "            ", "clipped_learning_signal", "=", "learning_signal", "\n", "\n", "", "encoder_loss", "=", "-", "clipped_learning_signal", ".", "detach", "(", ")", "*", "sample_scores", "\n", "decoder_loss", "=", "-", "reconstruction_scores", "\n", "\n", "# compute baseline loss", "\n", "baseline_loss", "=", "learning_signal", "**", "2", "\n", "\n", "meta_data", "=", "{", "'samples'", ":", "samples", ",", "\n", "'reconstruction_scores'", ":", "reconstruction_scores", ",", "\n", "'encoding_scores'", ":", "sample_scores", ",", "\n", "'raw_learning_signal'", ":", "raw_learning_signal", ",", "\n", "'learning_signal'", ":", "learning_signal", ",", "\n", "'baseline'", ":", "baseline", ",", "\n", "'kl_term'", ":", "kl_term", ",", "\n", "'prior'", ":", "prior_scores", "}", "\n", "\n", "return", "encoder_loss", ",", "decoder_loss", ",", "baseline_loss", ",", "meta_data", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.baseline": [[80, 87], ["struct_vae.StructVAE.b_x_l2().view", "struct_vae.StructVAE.b_x_l2", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "struct_vae.StructVAE.b_x_l1", "enc_states.detach"], "methods", ["None"], ["", "def", "baseline", "(", "self", ",", "samples", ",", "enc_states", ")", ":", "\n", "# compute baseline, which is an MLP", "\n", "# (sample_size) FIXME: reward is log-likelihood, shall we use activation here?", "\n", "\n", "        ", "b_x", "=", "self", ".", "b_x_l2", "(", "torch", ".", "tanh", "(", "self", ".", "b_x_l1", "(", "enc_states", ".", "detach", "(", ")", ")", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "return", "b_x", "+", "self", ".", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.infer": [[88, 123], ["struct_vae.StructVAE.encoder.eval", "enumerate", "struct_vae.StructVAE.encoder.score", "struct_vae.StructVAE.encoder.parse", "len", "ValueError", "struct_vae.StructVAE.encoder.train", "zip", "enumerate", "struct_vae.StructVAE.transition_system.ast_to_surface_code", "struct_vae.StructVAE.transition_system.tokenize_code", "components.dataset.Example", "sampled_examples.append", "print", "print", "traceback.print_exc", "print"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.score", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.prolog.prolog_transition_system.PrologTransitionSystem.ast_to_surface_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "infer", "(", "self", ",", "examples", ")", ":", "\n", "# currently use beam search as sampling method", "\n", "# set model to evaluation model for beam search, make sure dropout is properly behaving!", "\n", "        ", "was_training", "=", "self", ".", "encoder", ".", "training", "\n", "self", ".", "encoder", ".", "eval", "(", ")", "\n", "\n", "hypotheses", "=", "[", "self", ".", "encoder", ".", "parse", "(", "e", ".", "src_sent", ",", "beam_size", "=", "self", ".", "args", ".", "sample_size", ")", "for", "e", "in", "examples", "]", "\n", "\n", "if", "len", "(", "hypotheses", ")", "==", "0", ":", "\n", "            ", "raise", "ValueError", "(", "'No candidate hypotheses.'", ")", "\n", "\n", "", "if", "was_training", ":", "self", ".", "encoder", ".", "train", "(", ")", "\n", "\n", "# some source may not have corresponding samples, so we only retain those that have sampled logical forms", "\n", "sampled_examples", "=", "[", "]", "\n", "for", "e_id", ",", "(", "example", ",", "hyps", ")", "in", "enumerate", "(", "zip", "(", "examples", ",", "hypotheses", ")", ")", ":", "\n", "            ", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hyps", ")", ":", "\n", "                ", "try", ":", "\n", "                    ", "code", "=", "self", ".", "transition_system", ".", "ast_to_surface_code", "(", "hyp", ".", "tree", ")", "\n", "self", ".", "transition_system", ".", "tokenize_code", "(", "code", ")", "# make sure the code is tokenizable!", "\n", "sampled_example", "=", "Example", "(", "idx", "=", "'%d-sample%d'", "%", "(", "example", ".", "idx", ",", "hyp_id", ")", ",", "\n", "src_sent", "=", "example", ".", "src_sent", ",", "\n", "tgt_code", "=", "code", ",", "\n", "tgt_actions", "=", "hyp", ".", "action_infos", ",", "\n", "tgt_ast", "=", "hyp", ".", "tree", ")", "\n", "sampled_examples", ".", "append", "(", "sampled_example", ")", "\n", "", "except", ":", "\n", "                    ", "print", "(", "\"Exception in converting tree to code:\"", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "traceback", ".", "print_exc", "(", "file", "=", "sys", ".", "stdout", ")", "\n", "print", "(", "'-'", "*", "60", ",", "file", "=", "sys", ".", "stdout", ")", "\n", "\n", "", "", "", "sample_scores", ",", "enc_states", "=", "self", ".", "encoder", ".", "score", "(", "sampled_examples", ",", "return_encode_state", "=", "True", ")", "\n", "\n", "return", "sampled_examples", ",", "sample_scores", ",", "enc_states", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.save": [[124, 136], ["os.path.splitext", "struct_vae.StructVAE.encoder.save", "struct_vae.StructVAE.decoder.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "struct_vae.StructVAE.state_dict().iteritems", "struct_vae.StructVAE.state_dict", "k.startswith", "k.startswith", "k.startswith"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "fname", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "path", ")", "\n", "self", ".", "encoder", ".", "save", "(", "fname", "+", "'.encoder'", "+", "ext", ")", "\n", "self", ".", "decoder", ".", "save", "(", "fname", "+", "'.decoder'", "+", "ext", ")", "\n", "state_dict", "=", "{", "k", ":", "v", "for", "k", ",", "v", "in", "self", ".", "state_dict", "(", ")", ".", "iteritems", "(", ")", "if", "not", "(", "k", ".", "startswith", "(", "'decoder'", ")", "or", "k", ".", "startswith", "(", "'encoder'", ")", "or", "k", ".", "startswith", "(", "'prior'", ")", ")", "}", "\n", "\n", "params", "=", "{", "\n", "'args'", ":", "self", ".", "args", ",", "\n", "'state_dict'", ":", "state_dict", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "params", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.load_parameters": [[137, 147], ["os.path.splitext", "struct_vae.StructVAE.encoder.load_state_dict", "struct_vae.StructVAE.decoder.load_state_dict", "struct_vae.StructVAE.load_state_dict", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load"], ["", "def", "load_parameters", "(", "self", ",", "path", ")", ":", "\n", "        ", "fname", ",", "ext", "=", "os", ".", "path", ".", "splitext", "(", "path", ")", "\n", "encoder_states", "=", "torch", ".", "load", "(", "fname", "+", "'.encoder'", "+", "ext", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "[", "'state_dict'", "]", "\n", "self", ".", "encoder", ".", "load_state_dict", "(", "encoder_states", ")", "\n", "\n", "decoder_states", "=", "torch", ".", "load", "(", "fname", "+", "'.decoder'", "+", "ext", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "[", "'state_dict'", "]", "\n", "self", ".", "decoder", ".", "load_state_dict", "(", "decoder_states", ")", "\n", "\n", "vae_states", "=", "torch", ".", "load", "(", "path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "[", "'state_dict'", "]", "\n", "self", ".", "load_state_dict", "(", "vae_states", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE.train": [[148, 151], ["super().train", "struct_vae.StructVAE.prior.eval"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "super", "(", "StructVAE", ",", "self", ")", ".", "train", "(", ")", "\n", "self", ".", "prior", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.__init__": [[154, 165], ["struct_vae.StructVAE.__init__", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "struct_vae.StructVAE_LMBaseline.b.data.fill_", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ",", "prior", ",", "src_lm", ",", "args", ")", ":", "\n", "        ", "super", "(", "StructVAE_LMBaseline", ",", "self", ")", ".", "__init__", "(", "encoder", ",", "decoder", ",", "prior", ",", "args", ")", "\n", "\n", "del", "self", ".", "b_x_l1", "\n", "del", "self", ".", "b_x_l2", "\n", "\n", "self", ".", "b_lm", "=", "src_lm", "\n", "self", ".", "b_lm_weight", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "[", ".5", "if", "args", ".", "lang", "==", "'python'", "else", "0.9", "]", ")", ")", "# FIXME: language dependant init", "\n", "\n", "# initialize baseline to be a small negative number", "\n", "self", ".", "b", ".", "data", ".", "fill_", "(", "-", "2.", "if", "args", ".", "lang", "==", "'python'", "else", "2.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.baseline": [[166, 173], ["nn_utils.to_input_variable", "struct_vae.StructVAE_LMBaseline.b_lm"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable"], ["", "def", "baseline", "(", "self", ",", "samples", ",", "enc_states", ")", ":", "\n", "        ", "src_sent_var", "=", "nn_utils", ".", "to_input_variable", "(", "[", "e", ".", "src_sent", "for", "e", "in", "samples", "]", ",", "\n", "self", ".", "b_lm", ".", "vocab", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ",", "\n", "append_boundary_sym", "=", "True", ")", "\n", "p_lm", "=", "-", "self", ".", "b_lm", "(", "src_sent_var", ")", "\n", "\n", "return", "self", ".", "b_lm_weight", "*", "p_lm", "-", "self", ".", "b", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train": [[174, 177], ["struct_vae.StructVAE.train", "struct_vae.StructVAE_LMBaseline.b_lm.eval"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_LMBaseline.train", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval"], ["", "def", "train", "(", "self", ")", ":", "\n", "        ", "super", "(", "StructVAE_LMBaseline", ",", "self", ")", ".", "train", "(", ")", "\n", "self", ".", "b_lm", ".", "eval", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_SrcLmAndLinearBaseline.__init__": [[180, 186], ["struct_vae.StructVAE_LMBaseline.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "encoder", ",", "decoder", ",", "prior", ",", "src_lm", ",", "args", ")", ":", "\n", "        ", "super", "(", "StructVAE_SrcLmAndLinearBaseline", ",", "self", ")", ".", "__init__", "(", "encoder", ",", "decoder", ",", "prior", ",", "src_lm", ",", "args", ")", "\n", "\n", "# For MLP baseline", "\n", "# for baseline", "\n", "self", ".", "b_x_l1", "=", "nn", ".", "Linear", "(", "args", ".", "hidden_size", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_SrcLmAndLinearBaseline.baseline": [[187, 193], ["struct_vae.StructVAE_SrcLmAndLinearBaseline.b_x_l1().view", "struct_vae.StructVAE_LMBaseline.baseline", "struct_vae.StructVAE_SrcLmAndLinearBaseline.b_x_l1", "enc_states.detach"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.struct_vae.StructVAE_SrcLmAndLinearBaseline.baseline"], ["", "def", "baseline", "(", "self", ",", "samples", ",", "enc_states", ")", ":", "\n", "        ", "b_linear", "=", "self", ".", "b_x_l1", "(", "enc_states", ".", "detach", "(", ")", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "b_lm", "=", "super", "(", "StructVAE_SrcLmAndLinearBaseline", ",", "self", ")", ".", "baseline", "(", "samples", ",", "enc_states", ")", "\n", "\n", "return", "b_linear", "+", "b_lm", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.pointer_net.PointerNet.__init__": [[12, 20], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "query_vec_size", ",", "src_encoding_size", ",", "attention_type", "=", "'affine'", ")", ":", "\n", "        ", "super", "(", "PointerNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "assert", "attention_type", "in", "(", "'affine'", ",", "'dot_prod'", ")", "\n", "if", "attention_type", "==", "'affine'", ":", "\n", "            ", "self", ".", "src_encoding_linear", "=", "nn", ".", "Linear", "(", "src_encoding_size", ",", "query_vec_size", ",", "bias", "=", "False", ")", "\n", "\n", "", "self", ".", "attention_type", "=", "attention_type", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.pointer_net.PointerNet.forward": [[21, 51], ["pointer_net.PointerNet.unsqueeze", "query_vec.permute().unsqueeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "torch.matmul().squeeze", "weights.permute.permute.permute", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "pointer_net.PointerNet.src_encoding_linear", "src_token_mask.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze().expand_as", "weights.permute.permute.data.masked_fill_", "query_vec.permute", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "torch.matmul", "src_token_mask.unsqueeze().expand_as.unsqueeze().expand_as.unsqueeze", "float"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "forward", "(", "self", ",", "src_encodings", ",", "src_token_mask", ",", "query_vec", ")", ":", "\n", "        ", "\"\"\"\n        :param src_encodings: Variable(batch_size, src_sent_len, hidden_size * 2)\n        :param src_token_mask: Variable(batch_size, src_sent_len)\n        :param query_vec: Variable(tgt_action_num, batch_size, query_vec_size)\n        :return: Variable(tgt_action_num, batch_size, src_sent_len)\n        \"\"\"", "\n", "\n", "# (batch_size, 1, src_sent_len, query_vec_size)", "\n", "if", "self", ".", "attention_type", "==", "'affine'", ":", "\n", "            ", "src_encodings", "=", "self", ".", "src_encoding_linear", "(", "src_encodings", ")", "\n", "", "src_encodings", "=", "src_encodings", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# (batch_size, tgt_action_num, query_vec_size, 1)", "\n", "q", "=", "query_vec", ".", "permute", "(", "1", ",", "0", ",", "2", ")", ".", "unsqueeze", "(", "3", ")", "\n", "\n", "# (batch_size, tgt_action_num, src_sent_len)", "\n", "weights", "=", "torch", ".", "matmul", "(", "src_encodings", ",", "q", ")", ".", "squeeze", "(", "3", ")", "\n", "\n", "# (tgt_action_num, batch_size, src_sent_len)", "\n", "weights", "=", "weights", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "if", "src_token_mask", "is", "not", "None", ":", "\n", "# (tgt_action_num, batch_size, src_sent_len)", "\n", "            ", "src_token_mask", "=", "src_token_mask", ".", "unsqueeze", "(", "0", ")", ".", "expand_as", "(", "weights", ")", "\n", "weights", ".", "data", ".", "masked_fill_", "(", "src_token_mask", ",", "-", "float", "(", "'inf'", ")", ")", "\n", "\n", "", "ptr_weights", "=", "F", ".", "softmax", "(", "weights", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "ptr_weights", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.RecurrentDropoutLSTMCell.__init__": [[17, 45], ["torch.nn.modules.rnn.RNNCellBase.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "lstm.RecurrentDropoutLSTMCell.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.ParentFeedingLSTMCell.reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ",", "dropout", "=", "0.", ")", ":", "\n", "        ", "super", "(", "RecurrentDropoutLSTMCell", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "dropout", "=", "dropout", "\n", "\n", "self", ".", "W_i", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_i", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "# self.b_i = Parameter(torch.Tensor(hidden_size))", "\n", "\n", "self", ".", "W_f", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_f", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "# self.b_f = Parameter(torch.Tensor(hidden_size))", "\n", "\n", "self", ".", "W_c", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_c", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "# self.b_c = Parameter(torch.Tensor(hidden_size))", "\n", "\n", "self", ".", "W_o", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_o", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "# self.b_o = Parameter(torch.Tensor(hidden_size))", "\n", "\n", "self", ".", "bias_ih", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "4", "*", "hidden_size", ")", ")", "\n", "self", ".", "bias_hh", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "4", "*", "hidden_size", ")", ")", "\n", "\n", "self", ".", "_input_dropout_mask", "=", "self", ".", "_h_dropout_mask", "=", "None", "\n", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.RecurrentDropoutLSTMCell.reset_parameters": [[46, 59], ["torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "lstm.RecurrentDropoutLSTMCell.bias_ih.data.fill_", "lstm.RecurrentDropoutLSTMCell.bias_ih.data[].fill_", "lstm.RecurrentDropoutLSTMCell.bias_hh.data.fill_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "init", ".", "orthogonal", "(", "self", ".", "W_i", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_i", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "W_f", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_f", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "W_c", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_c", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "W_o", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_o", ")", "\n", "self", ".", "bias_ih", ".", "data", ".", "fill_", "(", "0.", ")", "\n", "# forget gate set to 1.", "\n", "self", ".", "bias_ih", ".", "data", "[", "self", ".", "hidden_size", ":", "2", "*", "self", ".", "hidden_size", "]", ".", "fill_", "(", "1.", ")", "\n", "self", ".", "bias_hh", ".", "data", ".", "fill_", "(", "0.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.RecurrentDropoutLSTMCell.set_dropout_masks": [[60, 72], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "new_tensor().fill_", "new_tensor().fill_", "new_tensor", "new_tensor"], "methods", ["None"], ["", "def", "set_dropout_masks", "(", "self", ",", "batch_size", ")", ":", "\n", "        ", "if", "self", ".", "dropout", ":", "\n", "            ", "if", "self", ".", "training", ":", "\n", "                ", "new_tensor", "=", "self", ".", "W_i", ".", "data", ".", "new", "\n", "self", ".", "_input_dropout_mask", "=", "Variable", "(", "torch", ".", "bernoulli", "(", "\n", "new_tensor", "(", "4", ",", "batch_size", ",", "self", ".", "input_size", ")", ".", "fill_", "(", "1", "-", "self", ".", "dropout", ")", ")", ",", "requires_grad", "=", "False", ")", "\n", "self", ".", "_h_dropout_mask", "=", "Variable", "(", "torch", ".", "bernoulli", "(", "\n", "new_tensor", "(", "4", ",", "batch_size", ",", "self", ".", "hidden_size", ")", ".", "fill_", "(", "1", "-", "self", ".", "dropout", ")", ")", ",", "requires_grad", "=", "False", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "_input_dropout_mask", "=", "self", ".", "_h_dropout_mask", "=", "[", "1.", "-", "self", ".", "dropout", "]", "*", "4", "\n", "", "", "else", ":", "\n", "            ", "self", ".", "_input_dropout_mask", "=", "self", ".", "_h_dropout_mask", "=", "[", "1.", "]", "*", "4", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.RecurrentDropoutLSTMCell.forward": [[73, 106], ["torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "isinstance", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "state", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "lstm.RecurrentDropoutLSTMCell.forward.get_mask_slice"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "hidden_state", ")", ":", "\n", "        ", "def", "get_mask_slice", "(", "mask", ",", "idx", ")", ":", "\n", "            ", "if", "isinstance", "(", "mask", ",", "list", ")", ":", "return", "mask", "[", "idx", "]", "\n", "else", ":", "return", "mask", "[", "idx", "]", "[", ":", "input", ".", "size", "(", "0", ")", "]", "\n", "\n", "", "h_tm1", ",", "c_tm1", "=", "hidden_state", "\n", "\n", "# if self._input_dropout_mask is None:", "\n", "#     self.set_dropout_masks(input.size(0))", "\n", "\n", "xi_t", "=", "F", ".", "linear", "(", "input", "*", "get_mask_slice", "(", "self", ".", "_input_dropout_mask", ",", "0", ")", ",", "self", ".", "W_i", ")", "\n", "xf_t", "=", "F", ".", "linear", "(", "input", "*", "get_mask_slice", "(", "self", ".", "_input_dropout_mask", ",", "1", ")", ",", "self", ".", "W_f", ")", "\n", "xc_t", "=", "F", ".", "linear", "(", "input", "*", "get_mask_slice", "(", "self", ".", "_input_dropout_mask", ",", "2", ")", ",", "self", ".", "W_c", ")", "\n", "xo_t", "=", "F", ".", "linear", "(", "input", "*", "get_mask_slice", "(", "self", ".", "_input_dropout_mask", ",", "3", ")", ",", "self", ".", "W_o", ")", "\n", "\n", "hi_t", "=", "F", ".", "linear", "(", "h_tm1", "*", "get_mask_slice", "(", "self", ".", "_h_dropout_mask", ",", "0", ")", ",", "self", ".", "U_i", ")", "\n", "hf_t", "=", "F", ".", "linear", "(", "h_tm1", "*", "get_mask_slice", "(", "self", ".", "_h_dropout_mask", ",", "1", ")", ",", "self", ".", "U_f", ")", "\n", "hc_t", "=", "F", ".", "linear", "(", "h_tm1", "*", "get_mask_slice", "(", "self", ".", "_h_dropout_mask", ",", "2", ")", ",", "self", ".", "U_c", ")", "\n", "ho_t", "=", "F", ".", "linear", "(", "h_tm1", "*", "get_mask_slice", "(", "self", ".", "_h_dropout_mask", ",", "3", ")", ",", "self", ".", "U_o", ")", "\n", "\n", "if", "input", ".", "is_cuda", ":", "\n", "            ", "igates", "=", "torch", ".", "cat", "(", "[", "xi_t", ",", "xf_t", ",", "xc_t", ",", "xo_t", "]", ",", "dim", "=", "-", "1", ")", "\n", "hgates", "=", "torch", ".", "cat", "(", "[", "hi_t", ",", "hf_t", ",", "hc_t", ",", "ho_t", "]", ",", "dim", "=", "-", "1", ")", "\n", "state", "=", "fusedBackend", ".", "LSTMFused", ".", "apply", "\n", "return", "state", "(", "igates", ",", "hgates", ",", "c_tm1", ",", "self", ".", "bias_ih", ",", "self", ".", "bias_hh", ")", "\n", "", "else", ":", "\n", "            ", "i_t", "=", "F", ".", "sigmoid", "(", "xi_t", "+", "self", ".", "bias_ih", "[", ":", "self", ".", "hidden_size", "]", "+", "hi_t", "+", "self", ".", "bias_hh", "[", ":", "self", ".", "hidden_size", "]", ")", "\n", "f_t", "=", "F", ".", "sigmoid", "(", "xf_t", "+", "self", ".", "bias_ih", "[", "self", ".", "hidden_size", ":", "2", "*", "self", ".", "hidden_size", "]", "+", "hf_t", "+", "self", ".", "bias_hh", "[", "self", ".", "hidden_size", ":", "2", "*", "self", ".", "hidden_size", "]", ")", "\n", "c_t", "=", "f_t", "*", "c_tm1", "+", "i_t", "*", "torch", ".", "tanh", "(", "xc_t", "+", "self", ".", "bias_ih", "[", "2", "*", "self", ".", "hidden_size", ":", "3", "*", "self", ".", "hidden_size", "]", "+", "hc_t", "+", "self", ".", "bias_hh", "[", "2", "*", "self", ".", "hidden_size", ":", "3", "*", "self", ".", "hidden_size", "]", ")", "\n", "o_t", "=", "F", ".", "sigmoid", "(", "xo_t", "+", "self", ".", "bias_ih", "[", "3", "*", "self", ".", "hidden_size", ":", "4", "*", "self", ".", "hidden_size", "]", "+", "ho_t", "+", "self", ".", "bias_hh", "[", "3", "*", "self", ".", "hidden_size", ":", "4", "*", "self", ".", "hidden_size", "]", ")", "\n", "h_t", "=", "o_t", "*", "torch", ".", "tanh", "(", "c_t", ")", "\n", "\n", "", "return", "h_t", ",", "c_t", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.ParentFeedingLSTMCell.__init__": [[109, 137], ["torch.nn.modules.rnn.RNNCellBase.__init__", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "lstm.ParentFeedingLSTMCell.reset_parameters", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.ParentFeedingLSTMCell.reset_parameters"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ")", ":", "\n", "        ", "super", "(", "ParentFeedingLSTMCell", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "\n", "self", ".", "W_i", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_i", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "U_i_p", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "b_i", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ")", ")", "\n", "\n", "self", ".", "W_f", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_f", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "U_f_p", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "b_f", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ")", ")", "\n", "self", ".", "b_f_p", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ")", ")", "\n", "\n", "self", ".", "W_c", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_c", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "U_c_p", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "b_c", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ")", ")", "\n", "\n", "self", ".", "W_o", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "input_size", ")", ")", "\n", "self", ".", "U_o", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "U_o_p", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ",", "hidden_size", ")", ")", "\n", "self", ".", "b_o", "=", "Parameter", "(", "torch", ".", "Tensor", "(", "hidden_size", ")", ")", "\n", "\n", "self", ".", "reset_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.ParentFeedingLSTMCell.reset_parameters": [[138, 161], ["torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "torch.nn.init.orthogonal", "lstm.ParentFeedingLSTMCell.b_i.data.fill_", "lstm.ParentFeedingLSTMCell.b_c.data.fill_", "lstm.ParentFeedingLSTMCell.b_o.data.fill_", "lstm.ParentFeedingLSTMCell.b_f.data.fill_", "lstm.ParentFeedingLSTMCell.b_f_p.data.fill_"], "methods", ["None"], ["", "def", "reset_parameters", "(", "self", ")", ":", "\n", "        ", "init", ".", "orthogonal", "(", "self", ".", "W_i", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_i", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_i_p", ")", "\n", "\n", "init", ".", "orthogonal", "(", "self", ".", "W_f", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_f", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_f_p", ")", "\n", "\n", "init", ".", "orthogonal", "(", "self", ".", "W_c", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_c", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_c_p", ")", "\n", "\n", "init", ".", "orthogonal", "(", "self", ".", "W_o", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_o", ")", "\n", "init", ".", "orthogonal", "(", "self", ".", "U_o_p", ")", "\n", "\n", "self", ".", "b_i", ".", "data", ".", "fill_", "(", "0.", ")", "\n", "self", ".", "b_c", ".", "data", ".", "fill_", "(", "0.", ")", "\n", "self", ".", "b_o", ".", "data", ".", "fill_", "(", "0.", ")", "\n", "# forget bias set to 1.", "\n", "self", ".", "b_f", ".", "data", ".", "fill_", "(", "1.", ")", "\n", "self", ".", "b_f_p", ".", "data", ".", "fill_", "(", "1.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.ParentFeedingLSTMCell.forward": [[162, 177], ["torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ",", "hidden_states", ")", ":", "\n", "        ", "h_tm1", ",", "c_tm1", ",", "h_tm1_p", ",", "c_tm1_p", "=", "hidden_states", "\n", "i_t", "=", "F", ".", "sigmoid", "(", "F", ".", "linear", "(", "input", ",", "self", ".", "W_i", ")", "+", "F", ".", "linear", "(", "h_tm1", ",", "self", ".", "U_i", ")", "+", "F", ".", "linear", "(", "h_tm1_p", ",", "self", ".", "U_i_p", ")", "+", "self", ".", "b_i", ")", "\n", "\n", "xf_t", "=", "F", ".", "linear", "(", "input", ",", "self", ".", "W_f", ")", "\n", "f_t", "=", "F", ".", "sigmoid", "(", "xf_t", "+", "F", ".", "linear", "(", "h_tm1", ",", "self", ".", "U_f", ")", "+", "self", ".", "b_f", ")", "\n", "f_t_p", "=", "F", ".", "sigmoid", "(", "xf_t", "+", "F", ".", "linear", "(", "h_tm1_p", ",", "self", ".", "U_f_p", ")", "+", "self", ".", "b_f_p", ")", "\n", "\n", "xc_t", "=", "F", ".", "linear", "(", "input", ",", "self", ".", "W_c", ")", "+", "F", ".", "linear", "(", "h_tm1", ",", "self", ".", "U_c", ")", "+", "F", ".", "linear", "(", "h_tm1_p", ",", "self", ".", "U_c_p", ")", "+", "self", ".", "b_c", "\n", "c_t", "=", "f_t", "*", "c_tm1", "+", "f_t_p", "*", "c_tm1_p", "+", "i_t", "*", "torch", ".", "tanh", "(", "xc_t", ")", "\n", "\n", "o_t", "=", "F", ".", "sigmoid", "(", "F", ".", "linear", "(", "input", ",", "self", ".", "W_o", ")", "+", "F", ".", "linear", "(", "h_tm1", ",", "self", ".", "U_o", ")", "+", "F", ".", "linear", "(", "h_tm1_p", ",", "self", ".", "U_o_p", ")", "+", "self", ".", "b_o", ")", "\n", "h_t", "=", "o_t", "*", "torch", ".", "tanh", "(", "c_t", ")", "\n", "\n", "return", "h_t", ",", "c_t", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.LSTM.__init__": [[180, 197], ["torch.Module.__init__", "range", "cell_factory", "lstm.LSTM.lstm_cells.append", "lstm.LSTM.add_module"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_size", ",", "hidden_size", ",", "bidirectional", "=", "False", ",", "dropout", "=", "0.", ",", "cell_factory", "=", "RecurrentDropoutLSTMCell", ")", ":", "\n", "        ", "super", "(", "LSTM", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "input_size", "=", "input_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "bidirectional", "=", "bidirectional", "\n", "self", ".", "dropout", "=", "dropout", "\n", "self", ".", "cell_factory", "=", "cell_factory", "\n", "num_directions", "=", "2", "if", "bidirectional", "else", "1", "\n", "self", ".", "lstm_cells", "=", "[", "]", "\n", "\n", "for", "direction", "in", "range", "(", "num_directions", ")", ":", "\n", "            ", "cell", "=", "cell_factory", "(", "input_size", ",", "hidden_size", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "lstm_cells", ".", "append", "(", "cell", ")", "\n", "\n", "suffix", "=", "'_reverse'", "if", "direction", "==", "1", "else", "''", "\n", "cell_name", "=", "'cell{}'", ".", "format", "(", "suffix", ")", "\n", "self", ".", "add_module", "(", "cell_name", ",", "cell", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.LSTM.forward": [[198, 233], ["isinstance", "torch.nn._functions.rnn.variable_recurrent_factory", "torch.nn._functions.rnn.variable_recurrent_factory", "torch.nn._functions.rnn.variable_recurrent_factory", "torch.nn._functions.rnn.variable_recurrent_factory", "torch.nn._functions.rnn.StackedRNN", "torch.nn._functions.rnn.StackedRNN", "torch.nn._functions.rnn.StackedRNN", "torch.nn._functions.rnn.StackedRNN", "torch.nn._functions.rnn.StackedRNN.", "torch.nn._functions.rnn.StackedRNN.", "torch.nn._functions.rnn.StackedRNN.", "torch.nn._functions.rnn.StackedRNN.", "NotImplementedError", "cell.set_dropout_masks", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.nn.utils.rnn.PackedSequence", "torch.nn.utils.rnn.PackedSequence", "torch.nn.utils.rnn.PackedSequence", "torch.nn.utils.rnn.PackedSequence", "input.data.new().zero_", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "torch.nn._functions.rnn.variable_recurrent_factory.", "input.data.new", "lstm.LSTM.cell", "lstm.LSTM.cell_reverse", "lstm.LSTM.cell"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.lstm.RecurrentDropoutLSTMCell.set_dropout_masks"], ["", "", "def", "forward", "(", "self", ",", "input", ",", "hidden_state", "=", "None", ")", ":", "\n", "        ", "is_packed", "=", "isinstance", "(", "input", ",", "PackedSequence", ")", "\n", "if", "is_packed", ":", "\n", "            ", "input", ",", "batch_sizes", "=", "input", "\n", "max_batch_size", "=", "batch_sizes", "[", "0", "]", "\n", "", "else", ":", "raise", "NotImplementedError", "(", ")", "\n", "\n", "for", "cell", "in", "self", ".", "lstm_cells", ":", "\n", "            ", "cell", ".", "set_dropout_masks", "(", "max_batch_size", ")", "\n", "\n", "", "if", "hidden_state", "is", "None", ":", "\n", "            ", "num_directions", "=", "2", "if", "self", ".", "bidirectional", "else", "1", "\n", "hx", "=", "torch", ".", "autograd", ".", "Variable", "(", "input", ".", "data", ".", "new", "(", "num_directions", ",", "\n", "max_batch_size", ",", "\n", "self", ".", "hidden_size", ")", ".", "zero_", "(", ")", ")", "\n", "\n", "hidden_state", "=", "(", "hx", ",", "hx", ")", "\n", "\n", "", "rec_factory", "=", "variable_recurrent_factory", "(", "batch_sizes", ")", "\n", "if", "self", ".", "bidirectional", ":", "\n", "            ", "layer", "=", "(", "rec_factory", "(", "lambda", "x", ",", "h", ":", "self", ".", "cell", "(", "x", ",", "h", ")", ")", ",", "\n", "rec_factory", "(", "lambda", "x", ",", "h", ":", "self", ".", "cell_reverse", "(", "x", ",", "h", ")", ",", "reverse", "=", "True", ")", ")", "\n", "", "else", ":", "\n", "            ", "layer", "=", "(", "rec_factory", "(", "lambda", "x", ",", "h", ":", "self", ".", "cell", "(", "x", ",", "h", ")", ")", ",", ")", "\n", "\n", "", "func", "=", "StackedRNN", "(", "layer", ",", "\n", "num_layers", "=", "1", ",", "\n", "lstm", "=", "True", ",", "\n", "dropout", "=", "0.", ",", "\n", "train", "=", "self", ".", "training", ")", "\n", "next_hidden", ",", "output", "=", "func", "(", "input", ",", "hidden_state", ",", "weight", "=", "[", "[", "]", ",", "[", "]", "]", ")", "\n", "\n", "if", "is_packed", ":", "\n", "            ", "output", "=", "PackedSequence", "(", "output", ",", "batch_sizes", ")", "\n", "", "return", "output", ",", "next_hidden", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.__init__": [[37, 164], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.init.xavier_normal_", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Parameter", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "len", "len", "len", "len", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "model.pointer_net.PointerNet", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "model.nn_utils.LabelSmoothing", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.FloatTensor().zero_", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "len", "int", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "ParentFeedingLSTMCell", "ValueError", "len", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "torch.linear", "int", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "parser.Parser.read_out_act", "parser.Parser.read_out_act", "len", "parser.Parser.query_vec_to_action_embed", "parser.Parser.query_vec_to_primitive_embed", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["def", "__init__", "(", "self", ",", "args", ",", "vocab", ",", "transition_system", ")", ":", "\n", "        ", "super", "(", "Parser", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "vocab", "=", "vocab", "\n", "\n", "self", ".", "transition_system", "=", "transition_system", "\n", "self", ".", "grammar", "=", "self", ".", "transition_system", ".", "grammar", "\n", "\n", "# Embedding layers", "\n", "\n", "# source token embedding", "\n", "self", ".", "src_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "vocab", ".", "source", ")", ",", "args", ".", "embed_size", ")", "\n", "\n", "# embedding table of ASDL production rules (constructors), one for each ApplyConstructor action,", "\n", "# the last entry is the embedding for Reduce action", "\n", "self", ".", "production_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "transition_system", ".", "grammar", ")", "+", "1", ",", "args", ".", "action_embed_size", ")", "\n", "\n", "# embedding table for target primitive tokens", "\n", "self", ".", "primitive_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "vocab", ".", "primitive", ")", ",", "args", ".", "action_embed_size", ")", "\n", "\n", "# embedding table for ASDL fields in constructors", "\n", "self", ".", "field_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "transition_system", ".", "grammar", ".", "fields", ")", ",", "args", ".", "field_embed_size", ")", "\n", "\n", "# embedding table for ASDL types", "\n", "self", ".", "type_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "transition_system", ".", "grammar", ".", "types", ")", ",", "args", ".", "type_embed_size", ")", "\n", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "src_embed", ".", "weight", ".", "data", ")", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "production_embed", ".", "weight", ".", "data", ")", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "primitive_embed", ".", "weight", ".", "data", ")", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "field_embed", ".", "weight", ".", "data", ")", "\n", "nn", ".", "init", ".", "xavier_normal_", "(", "self", ".", "type_embed", ".", "weight", ".", "data", ")", "\n", "\n", "# LSTMs", "\n", "if", "args", ".", "lstm", "==", "'lstm'", ":", "\n", "            ", "self", ".", "encoder_lstm", "=", "nn", ".", "LSTM", "(", "args", ".", "embed_size", ",", "int", "(", "args", ".", "hidden_size", "/", "2", ")", ",", "bidirectional", "=", "True", ")", "\n", "\n", "input_dim", "=", "args", ".", "action_embed_size", "# previous action", "\n", "# frontier info", "\n", "input_dim", "+=", "args", ".", "action_embed_size", "*", "(", "not", "args", ".", "no_parent_production_embed", ")", "\n", "input_dim", "+=", "args", ".", "field_embed_size", "*", "(", "not", "args", ".", "no_parent_field_embed", ")", "\n", "input_dim", "+=", "args", ".", "type_embed_size", "*", "(", "not", "args", ".", "no_parent_field_type_embed", ")", "\n", "input_dim", "+=", "args", ".", "hidden_size", "*", "(", "not", "args", ".", "no_parent_state", ")", "\n", "\n", "input_dim", "+=", "args", ".", "att_vec_size", "*", "(", "not", "args", ".", "no_input_feed", ")", "# input feeding", "\n", "\n", "self", ".", "decoder_lstm", "=", "nn", ".", "LSTMCell", "(", "input_dim", ",", "args", ".", "hidden_size", ")", "\n", "", "elif", "args", ".", "lstm", "==", "'parent_feed'", ":", "\n", "            ", "self", ".", "encoder_lstm", "=", "nn", ".", "LSTM", "(", "args", ".", "embed_size", ",", "int", "(", "args", ".", "hidden_size", "/", "2", ")", ",", "bidirectional", "=", "True", ")", "\n", "from", ".", "lstm", "import", "ParentFeedingLSTMCell", "\n", "\n", "input_dim", "=", "args", ".", "action_embed_size", "# previous action", "\n", "# frontier info", "\n", "input_dim", "+=", "args", ".", "action_embed_size", "*", "(", "not", "args", ".", "no_parent_production_embed", ")", "\n", "input_dim", "+=", "args", ".", "field_embed_size", "*", "(", "not", "args", ".", "no_parent_field_embed", ")", "\n", "input_dim", "+=", "args", ".", "type_embed_size", "*", "(", "not", "args", ".", "no_parent_field_type_embed", ")", "\n", "input_dim", "+=", "args", ".", "att_vec_size", "*", "(", "not", "args", ".", "no_input_feed", ")", "# input feeding", "\n", "\n", "self", ".", "decoder_lstm", "=", "ParentFeedingLSTMCell", "(", "input_dim", ",", "args", ".", "hidden_size", ")", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Unknown LSTM type %s'", "%", "args", ".", "lstm", ")", "\n", "\n", "", "if", "args", ".", "no_copy", "is", "False", ":", "\n", "# pointer net for copying tokens from source side", "\n", "            ", "self", ".", "src_pointer_net", "=", "PointerNet", "(", "query_vec_size", "=", "args", ".", "att_vec_size", ",", "src_encoding_size", "=", "args", ".", "hidden_size", ")", "\n", "\n", "# given the decoder's hidden state, predict whether to copy or generate a target primitive token", "\n", "# output: [p(gen(token)) | s_t, p(copy(token)) | s_t]", "\n", "\n", "self", ".", "primitive_predictor", "=", "nn", ".", "Linear", "(", "args", ".", "att_vec_size", ",", "2", ")", "\n", "\n", "", "if", "args", ".", "primitive_token_label_smoothing", ":", "\n", "            ", "self", ".", "label_smoothing", "=", "LabelSmoothing", "(", "args", ".", "primitive_token_label_smoothing", ",", "len", "(", "self", ".", "vocab", ".", "primitive", ")", ",", "ignore_indices", "=", "[", "0", ",", "1", ",", "2", "]", ")", "\n", "\n", "# initialize the decoder's state and cells with encoder hidden states", "\n", "", "self", ".", "decoder_cell_init", "=", "nn", ".", "Linear", "(", "args", ".", "hidden_size", ",", "args", ".", "hidden_size", ")", "\n", "\n", "# attention: dot product attention", "\n", "# project source encoding to decoder rnn's hidden space", "\n", "\n", "self", ".", "att_src_linear", "=", "nn", ".", "Linear", "(", "args", ".", "hidden_size", ",", "args", ".", "hidden_size", ",", "bias", "=", "False", ")", "\n", "\n", "# transformation of decoder hidden states and context vectors before reading out target words", "\n", "# this produces the `attentional vector` in (Luong et al., 2015)", "\n", "\n", "self", ".", "att_vec_linear", "=", "nn", ".", "Linear", "(", "args", ".", "hidden_size", "+", "args", ".", "hidden_size", ",", "args", ".", "att_vec_size", ",", "bias", "=", "False", ")", "\n", "\n", "# bias for predicting ApplyConstructor and GenToken actions", "\n", "self", ".", "production_readout_b", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "len", "(", "transition_system", ".", "grammar", ")", "+", "1", ")", ".", "zero_", "(", ")", ")", "\n", "self", ".", "tgt_token_readout_b", "=", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "len", "(", "vocab", ".", "primitive", ")", ")", ".", "zero_", "(", ")", ")", "\n", "\n", "if", "args", ".", "no_query_vec_to_action_map", ":", "\n", "# if there is no additional linear layer between the attentional vector (i.e., the query vector)", "\n", "# and the final softmax layer over target actions, we use the attentional vector to compute action", "\n", "# probabilities", "\n", "\n", "            ", "assert", "args", ".", "att_vec_size", "==", "args", ".", "action_embed_size", "\n", "self", ".", "production_readout", "=", "lambda", "q", ":", "F", ".", "linear", "(", "q", ",", "self", ".", "production_embed", ".", "weight", ",", "self", ".", "production_readout_b", ")", "\n", "self", ".", "tgt_token_readout", "=", "lambda", "q", ":", "F", ".", "linear", "(", "q", ",", "self", ".", "primitive_embed", ".", "weight", ",", "self", ".", "tgt_token_readout_b", ")", "\n", "", "else", ":", "\n", "# by default, we feed the attentional vector (i.e., the query vector) into a linear layer without bias, and", "\n", "# compute action probabilities by dot-producting the resulting vector and (GenToken, ApplyConstructor) action embeddings", "\n", "# i.e., p(action) = query_vec^T \\cdot W \\cdot embedding", "\n", "\n", "            ", "self", ".", "query_vec_to_action_embed", "=", "nn", ".", "Linear", "(", "args", ".", "att_vec_size", ",", "args", ".", "embed_size", ",", "bias", "=", "args", ".", "readout", "==", "'non_linear'", ")", "\n", "if", "args", ".", "query_vec_to_action_diff_map", ":", "\n", "# use different linear transformations for GenToken and ApplyConstructor actions", "\n", "                ", "self", ".", "query_vec_to_primitive_embed", "=", "nn", ".", "Linear", "(", "args", ".", "att_vec_size", ",", "args", ".", "embed_size", ",", "bias", "=", "args", ".", "readout", "==", "'non_linear'", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "query_vec_to_primitive_embed", "=", "self", ".", "query_vec_to_action_embed", "\n", "\n", "", "self", ".", "read_out_act", "=", "torch", ".", "tanh", "if", "args", ".", "readout", "==", "'non_linear'", "else", "nn_utils", ".", "identity", "\n", "\n", "self", ".", "production_readout", "=", "lambda", "q", ":", "F", ".", "linear", "(", "self", ".", "read_out_act", "(", "self", ".", "query_vec_to_action_embed", "(", "q", ")", ")", ",", "\n", "self", ".", "production_embed", ".", "weight", ",", "self", ".", "production_readout_b", ")", "\n", "self", ".", "tgt_token_readout", "=", "lambda", "q", ":", "F", ".", "linear", "(", "self", ".", "read_out_act", "(", "self", ".", "query_vec_to_primitive_embed", "(", "q", ")", ")", ",", "\n", "self", ".", "primitive_embed", ".", "weight", ",", "self", ".", "tgt_token_readout_b", ")", "\n", "\n", "# dropout layer", "\n", "", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "args", ".", "dropout", ")", "\n", "\n", "if", "args", ".", "cuda", ":", "\n", "            ", "self", ".", "new_long_tensor", "=", "torch", ".", "cuda", ".", "LongTensor", "\n", "self", ".", "new_tensor", "=", "torch", ".", "cuda", ".", "FloatTensor", "\n", "", "else", ":", "\n", "            ", "self", ".", "new_long_tensor", "=", "torch", ".", "LongTensor", "\n", "self", ".", "new_tensor", "=", "torch", ".", "FloatTensor", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.encode": [[165, 198], ["parser.Parser.src_embed", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "parser.Parser.encoder_lstm", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "src_encodings.permute.permute.permute", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "parser.Parser.new_tensor().fill_().bernoulli().long", "parser.Parser.new_tensor().fill_().bernoulli", "parser.Parser.new_tensor().fill_", "parser.Parser.new_tensor", "src_sents_var.size"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "", "def", "encode", "(", "self", ",", "src_sents_var", ",", "src_sents_len", ")", ":", "\n", "        ", "\"\"\"Encode the input natural language utterance\n\n        Args:\n            src_sents_var: a variable of shape (src_sent_len, batch_size), representing word ids of the input\n            src_sents_len: a list of lengths of input source sentences, sorted by descending order\n\n        Returns:\n            src_encodings: source encodings of shape (batch_size, src_sent_len, hidden_size * 2)\n            last_state, last_cell: the last hidden state and cell state of the encoder,\n                                   of shape (batch_size, hidden_size)\n        \"\"\"", "\n", "\n", "# (tgt_query_len, batch_size, embed_size)", "\n", "# apply word dropout", "\n", "if", "self", ".", "training", "and", "self", ".", "args", ".", "word_dropout", ":", "\n", "            ", "mask", "=", "Variable", "(", "self", ".", "new_tensor", "(", "src_sents_var", ".", "size", "(", ")", ")", ".", "fill_", "(", "1.", "-", "self", ".", "args", ".", "word_dropout", ")", ".", "bernoulli", "(", ")", ".", "long", "(", ")", ")", "\n", "src_sents_var", "=", "src_sents_var", "*", "mask", "+", "(", "1", "-", "mask", ")", "*", "self", ".", "vocab", ".", "source", ".", "unk_id", "\n", "\n", "", "src_token_embed", "=", "self", ".", "src_embed", "(", "src_sents_var", ")", "\n", "packed_src_token_embed", "=", "pack_padded_sequence", "(", "src_token_embed", ",", "src_sents_len", ")", "\n", "\n", "# src_encodings: (tgt_query_len, batch_size, hidden_size)", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encoder_lstm", "(", "packed_src_token_embed", ")", "\n", "src_encodings", ",", "_", "=", "pad_packed_sequence", "(", "src_encodings", ")", "\n", "# src_encodings: (batch_size, tgt_query_len, hidden_size)", "\n", "src_encodings", "=", "src_encodings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "\n", "# (batch_size, hidden_size * 2)", "\n", "last_state", "=", "torch", ".", "cat", "(", "[", "last_state", "[", "0", "]", ",", "last_state", "[", "1", "]", "]", ",", "1", ")", "\n", "last_cell", "=", "torch", ".", "cat", "(", "[", "last_cell", "[", "0", "]", ",", "last_cell", "[", "1", "]", "]", ",", "1", ")", "\n", "\n", "return", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.init_decoder_state": [[199, 206], ["parser.Parser.decoder_cell_init", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "parser.Parser.new_tensor().zero_", "parser.Parser.new_tensor", "torch.tanh.size", "torch.tanh.size", "torch.tanh.size", "torch.tanh.size"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "def", "init_decoder_state", "(", "self", ",", "enc_last_state", ",", "enc_last_cell", ")", ":", "\n", "        ", "\"\"\"Compute the initial decoder hidden state and cell state\"\"\"", "\n", "\n", "h_0", "=", "self", ".", "decoder_cell_init", "(", "enc_last_cell", ")", "\n", "h_0", "=", "torch", ".", "tanh", "(", "h_0", ")", "\n", "\n", "return", "h_0", ",", "Variable", "(", "self", ".", "new_tensor", "(", "h_0", ".", "size", "(", ")", ")", ".", "zero_", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.score": [[207, 305], ["components.dataset.Batch", "parser.Parser.encode", "parser.Parser.init_decoder_state", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "parser.Parser.decode", "parser.Parser.decode", "parser.Parser.production_readout", "parser.Parser.tgt_token_readout", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "parser.Parser.src_pointer_net", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.sum", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "action_prob.data.masked_fill_", "returns.append", "returns.append", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather().squeeze.log", "torch.gather().squeeze.log", "torch.gather().squeeze.log", "torch.gather().squeeze.log", "parser.Parser.primitive_predictor", "torch.eq.float", "torch.eq.float", "torch.eq.float", "torch.eq.float", "action_prob.log", "parser.Parser.label_smoothing", "torch.gather().squeeze.log", "torch.gather().squeeze.log", "torch.gather().squeeze.log", "torch.gather().squeeze.log", "components.dataset.Batch.apply_rule_idx_matrix.unsqueeze", "components.dataset.Batch.primitive_idx_matrix.unsqueeze", "torch.softmax.log"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "score", "(", "self", ",", "examples", ",", "return_encode_state", "=", "False", ")", ":", "\n", "        ", "\"\"\"Given a list of examples, compute the log-likelihood of generating the target AST\n\n        Args:\n            examples: a batch of examples\n            return_encode_state: return encoding states of input utterances\n        output: score for each training example: Variable(batch_size)\n        \"\"\"", "\n", "\n", "batch", "=", "Batch", "(", "examples", ",", "self", ".", "grammar", ",", "self", ".", "vocab", ",", "copy", "=", "self", ".", "args", ".", "no_copy", "is", "False", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "\n", "\n", "# src_encodings: (batch_size, src_sent_len, hidden_size * 2)", "\n", "# (last_state, last_cell, dec_init_vec): (batch_size, hidden_size)", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "batch", ".", "src_sents_var", ",", "batch", ".", "src_sents_len", ")", "\n", "dec_init_vec", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "\n", "# query vectors are sufficient statistics used to compute action probabilities", "\n", "# query_vectors: (tgt_action_len, batch_size, hidden_size)", "\n", "\n", "# if use supervised attention", "\n", "if", "self", ".", "args", ".", "sup_attention", ":", "\n", "            ", "query_vectors", ",", "att_prob", "=", "self", ".", "decode", "(", "batch", ",", "src_encodings", ",", "dec_init_vec", ")", "\n", "", "else", ":", "\n", "            ", "query_vectors", "=", "self", ".", "decode", "(", "batch", ",", "src_encodings", ",", "dec_init_vec", ")", "\n", "\n", "# ApplyRule (i.e., ApplyConstructor) action probabilities", "\n", "# (tgt_action_len, batch_size, grammar_size)", "\n", "", "apply_rule_prob", "=", "F", ".", "softmax", "(", "self", ".", "production_readout", "(", "query_vectors", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# probabilities of target (gold-standard) ApplyRule actions", "\n", "# (tgt_action_len, batch_size)", "\n", "tgt_apply_rule_prob", "=", "torch", ".", "gather", "(", "apply_rule_prob", ",", "dim", "=", "2", ",", "\n", "index", "=", "batch", ".", "apply_rule_idx_matrix", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "\n", "#### compute generation and copying probabilities", "\n", "\n", "# (tgt_action_len, batch_size, primitive_vocab_size)", "\n", "gen_from_vocab_prob", "=", "F", ".", "softmax", "(", "self", ".", "tgt_token_readout", "(", "query_vectors", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# (tgt_action_len, batch_size)", "\n", "tgt_primitive_gen_from_vocab_prob", "=", "torch", ".", "gather", "(", "gen_from_vocab_prob", ",", "dim", "=", "2", ",", "\n", "index", "=", "batch", ".", "primitive_idx_matrix", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "\n", "if", "self", ".", "args", ".", "no_copy", ":", "\n", "# mask positions in action_prob that are not used", "\n", "\n", "            ", "if", "self", ".", "training", "and", "self", ".", "args", ".", "primitive_token_label_smoothing", ":", "\n", "# (tgt_action_len, batch_size)", "\n", "# this is actually the negative KL divergence size we will flip the sign later", "\n", "# tgt_primitive_gen_from_vocab_log_prob = -self.label_smoothing(", "\n", "#     gen_from_vocab_prob.view(-1, gen_from_vocab_prob.size(-1)).log(),", "\n", "#     batch.primitive_idx_matrix.view(-1)).view(-1, len(batch))", "\n", "\n", "                ", "tgt_primitive_gen_from_vocab_log_prob", "=", "-", "self", ".", "label_smoothing", "(", "\n", "gen_from_vocab_prob", ".", "log", "(", ")", ",", "\n", "batch", ".", "primitive_idx_matrix", ")", "\n", "", "else", ":", "\n", "                ", "tgt_primitive_gen_from_vocab_log_prob", "=", "tgt_primitive_gen_from_vocab_prob", ".", "log", "(", ")", "\n", "\n", "# (tgt_action_len, batch_size)", "\n", "", "action_prob", "=", "tgt_apply_rule_prob", ".", "log", "(", ")", "*", "batch", ".", "apply_rule_mask", "+", "tgt_primitive_gen_from_vocab_log_prob", "*", "batch", ".", "gen_token_mask", "\n", "", "else", ":", "\n", "# binary gating probabilities between generating or copying a primitive token", "\n", "# (tgt_action_len, batch_size, 2)", "\n", "            ", "primitive_predictor", "=", "F", ".", "softmax", "(", "self", ".", "primitive_predictor", "(", "query_vectors", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# pointer network copying scores over source tokens", "\n", "# (tgt_action_len, batch_size, src_sent_len)", "\n", "primitive_copy_prob", "=", "self", ".", "src_pointer_net", "(", "src_encodings", ",", "batch", ".", "src_token_mask", ",", "query_vectors", ")", "\n", "\n", "# marginalize over the copy probabilities of tokens that are same", "\n", "# (tgt_action_len, batch_size)", "\n", "tgt_primitive_copy_prob", "=", "torch", ".", "sum", "(", "primitive_copy_prob", "*", "batch", ".", "primitive_copy_token_idx_mask", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# mask positions in action_prob that are not used", "\n", "# (tgt_action_len, batch_size)", "\n", "action_mask_pad", "=", "torch", ".", "eq", "(", "batch", ".", "apply_rule_mask", "+", "batch", ".", "gen_token_mask", "+", "batch", ".", "primitive_copy_mask", ",", "0.", ")", "\n", "action_mask", "=", "1.", "-", "action_mask_pad", ".", "float", "(", ")", "\n", "\n", "# (tgt_action_len, batch_size)", "\n", "action_prob", "=", "tgt_apply_rule_prob", "*", "batch", ".", "apply_rule_mask", "+", "primitive_predictor", "[", ":", ",", ":", ",", "0", "]", "*", "tgt_primitive_gen_from_vocab_prob", "*", "batch", ".", "gen_token_mask", "+", "primitive_predictor", "[", ":", ",", ":", ",", "1", "]", "*", "tgt_primitive_copy_prob", "*", "batch", ".", "primitive_copy_mask", "\n", "\n", "# avoid nan in log", "\n", "action_prob", ".", "data", ".", "masked_fill_", "(", "action_mask_pad", ".", "data", ",", "1.e-7", ")", "\n", "\n", "action_prob", "=", "action_prob", ".", "log", "(", ")", "*", "action_mask", "\n", "\n", "", "scores", "=", "torch", ".", "sum", "(", "action_prob", ",", "dim", "=", "0", ")", "\n", "\n", "returns", "=", "[", "scores", "]", "\n", "if", "self", ".", "args", ".", "sup_attention", ":", "\n", "            ", "returns", ".", "append", "(", "att_prob", ")", "\n", "", "if", "return_encode_state", ":", "returns", ".", "append", "(", "last_state", ")", "\n", "\n", "return", "returns", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.step": [[306, 335], ["parser.Parser.decoder_lstm", "model.nn_utils.dot_prod_attention", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "parser.Parser.dropout", "parser.Parser.att_vec_linear", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.dot_prod_attention"], ["", "def", "step", "(", "self", ",", "x", ",", "h_tm1", ",", "src_encodings", ",", "src_encodings_att_linear", ",", "src_token_mask", "=", "None", ",", "return_att_weight", "=", "False", ")", ":", "\n", "        ", "\"\"\"Perform a single time-step of computation in decoder LSTM\n\n        Args:\n            x: variable of shape (batch_size, hidden_size), input\n            h_tm1: Tuple[Variable(batch_size, hidden_size), Variable(batch_size, hidden_size)], previous\n                   hidden and cell states\n            src_encodings: variable of shape (batch_size, src_sent_len, hidden_size * 2), encodings of source utterances\n            src_encodings_att_linear: linearly transformed source encodings\n            src_token_mask: mask over source tokens (Note: unused entries are masked to **one**)\n            return_att_weight: return attention weights\n\n        Returns:\n            The new LSTM hidden state and cell state\n        \"\"\"", "\n", "\n", "# h_t: (batch_size, hidden_size)", "\n", "h_t", ",", "cell_t", "=", "self", ".", "decoder_lstm", "(", "x", ",", "h_tm1", ")", "\n", "\n", "ctx_t", ",", "alpha_t", "=", "nn_utils", ".", "dot_prod_attention", "(", "h_t", ",", "\n", "src_encodings", ",", "src_encodings_att_linear", ",", "\n", "mask", "=", "src_token_mask", ")", "\n", "\n", "att_t", "=", "torch", ".", "tanh", "(", "self", ".", "att_vec_linear", "(", "torch", ".", "cat", "(", "[", "h_t", ",", "ctx_t", "]", ",", "1", ")", ")", ")", "# E.q. (5)", "\n", "att_t", "=", "self", ".", "dropout", "(", "att_t", ")", "\n", "\n", "if", "return_att_weight", ":", "\n", "            ", "return", "(", "h_t", ",", "cell_t", ")", ",", "att_t", ",", "alpha_t", "\n", "", "else", ":", "return", "(", "h_t", ",", "cell_t", ")", ",", "att_t", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.decode": [[336, 472], ["len", "parser.Parser.att_src_linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "six.moves.xrange", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "parser.Parser.new_tensor().zero_", "parser.Parser.step", "history_states.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "att_weights.append", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "enumerate", "parser.Parser.new_tensor().zero_", "parser.Parser.new_tensor().zero_", "parser.Parser.new_tensor", "parser.Parser.new_tensor().zero_", "parser.Parser.type_embed", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "inputs.append", "parser.Parser.production_embed", "inputs.append", "parser.Parser.field_embed", "inputs.append", "parser.Parser.type_embed", "inputs.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "len", "isinstance", "batch.get_frontier_prod_idx", "batch.get_frontier_field_idx", "batch.get_frontier_field_type_idx", "inputs.append", "len", "model.attention_util.AttentionUtil.get_candidate_tokens_to_attend", "parser.Parser.new_tensor", "parser.Parser.new_tensor", "parser.Parser.new_tensor", "parser.Parser.new_long_tensor", "isinstance", "len", "att_probs.append", "enumerate", "enumerate", "len", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "torch.cat().sum", "len", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.get_frontier_prod_idx", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.get_frontier_field_idx", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.dataset.Batch.get_frontier_field_type_idx", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.attention_util.AttentionUtil.get_candidate_tokens_to_attend"], ["", "def", "decode", "(", "self", ",", "batch", ",", "src_encodings", ",", "dec_init_vec", ")", ":", "\n", "        ", "\"\"\"Given a batch of examples and their encodings of input utterances,\n        compute query vectors at each decoding time step, which are used to compute\n        action probabilities\n\n        Args:\n            batch: a `Batch` object storing input examples\n            src_encodings: variable of shape (batch_size, src_sent_len, hidden_size * 2), encodings of source utterances\n            dec_init_vec: a tuple of variables representing initial decoder states\n\n        Returns:\n            Query vectors, a variable of shape (tgt_action_len, batch_size, hidden_size)\n            Also return the attention weights over candidate tokens if using supervised attention\n        \"\"\"", "\n", "\n", "batch_size", "=", "len", "(", "batch", ")", "\n", "args", "=", "self", ".", "args", "\n", "\n", "if", "args", ".", "lstm", "==", "'parent_feed'", ":", "\n", "            ", "h_tm1", "=", "dec_init_vec", "[", "0", "]", ",", "dec_init_vec", "[", "1", "]", ",", "Variable", "(", "self", ".", "new_tensor", "(", "batch_size", ",", "args", ".", "hidden_size", ")", ".", "zero_", "(", ")", ")", ",", "Variable", "(", "self", ".", "new_tensor", "(", "batch_size", ",", "args", ".", "hidden_size", ")", ".", "zero_", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "h_tm1", "=", "dec_init_vec", "\n", "\n", "# (batch_size, query_len, hidden_size)", "\n", "", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "\n", "zero_action_embed", "=", "Variable", "(", "self", ".", "new_tensor", "(", "args", ".", "action_embed_size", ")", ".", "zero_", "(", ")", ")", "\n", "\n", "att_vecs", "=", "[", "]", "\n", "history_states", "=", "[", "]", "\n", "att_probs", "=", "[", "]", "\n", "att_weights", "=", "[", "]", "\n", "\n", "for", "t", "in", "range", "(", "batch", ".", "max_action_num", ")", ":", "\n", "# the input to the decoder LSTM is a concatenation of multiple signals", "\n", "# [", "\n", "#   embedding of previous action -> `a_tm1_embed`,", "\n", "#   previous attentional vector -> `att_tm1`,", "\n", "#   embedding of the current frontier (parent) constructor (rule) -> `parent_production_embed`,", "\n", "#   embedding of the frontier (parent) field -> `parent_field_embed`,", "\n", "#   embedding of the ASDL type of the frontier field -> `parent_field_type_embed`,", "\n", "#   LSTM state of the parent action -> `parent_states`", "\n", "# ]", "\n", "\n", "            ", "if", "t", "==", "0", ":", "\n", "                ", "x", "=", "Variable", "(", "self", ".", "new_tensor", "(", "batch_size", ",", "self", ".", "decoder_lstm", ".", "input_size", ")", ".", "zero_", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "\n", "# initialize using the root type embedding", "\n", "if", "args", ".", "no_parent_field_type_embed", "is", "False", ":", "\n", "                    ", "offset", "=", "args", ".", "action_embed_size", "# prev_action", "\n", "offset", "+=", "args", ".", "att_vec_size", "*", "(", "not", "args", ".", "no_input_feed", ")", "\n", "offset", "+=", "args", ".", "action_embed_size", "*", "(", "not", "args", ".", "no_parent_production_embed", ")", "\n", "offset", "+=", "args", ".", "field_embed_size", "*", "(", "not", "args", ".", "no_parent_field_embed", ")", "\n", "\n", "x", "[", ":", ",", "offset", ":", "offset", "+", "args", ".", "type_embed_size", "]", "=", "self", ".", "type_embed", "(", "Variable", "(", "self", ".", "new_long_tensor", "(", "\n", "[", "self", ".", "grammar", ".", "type2id", "[", "self", ".", "grammar", ".", "root_type", "]", "for", "e", "in", "batch", ".", "examples", "]", ")", ")", ")", "\n", "", "", "else", ":", "\n", "                ", "a_tm1_embeds", "=", "[", "]", "\n", "for", "example", "in", "batch", ".", "examples", ":", "\n", "# action t - 1", "\n", "                    ", "if", "t", "<", "len", "(", "example", ".", "tgt_actions", ")", ":", "\n", "                        ", "a_tm1", "=", "example", ".", "tgt_actions", "[", "t", "-", "1", "]", "\n", "if", "isinstance", "(", "a_tm1", ".", "action", ",", "ApplyRuleAction", ")", ":", "\n", "                            ", "a_tm1_embed", "=", "self", ".", "production_embed", ".", "weight", "[", "self", ".", "grammar", ".", "prod2id", "[", "a_tm1", ".", "action", ".", "production", "]", "]", "\n", "", "elif", "isinstance", "(", "a_tm1", ".", "action", ",", "ReduceAction", ")", ":", "\n", "                            ", "a_tm1_embed", "=", "self", ".", "production_embed", ".", "weight", "[", "len", "(", "self", ".", "grammar", ")", "]", "\n", "", "else", ":", "\n", "                            ", "a_tm1_embed", "=", "self", ".", "primitive_embed", ".", "weight", "[", "self", ".", "vocab", ".", "primitive", "[", "a_tm1", ".", "action", ".", "token", "]", "]", "\n", "", "", "else", ":", "\n", "                        ", "a_tm1_embed", "=", "zero_action_embed", "\n", "\n", "", "a_tm1_embeds", ".", "append", "(", "a_tm1_embed", ")", "\n", "\n", "", "a_tm1_embeds", "=", "torch", ".", "stack", "(", "a_tm1_embeds", ")", "\n", "\n", "inputs", "=", "[", "a_tm1_embeds", "]", "\n", "if", "args", ".", "no_input_feed", "is", "False", ":", "\n", "                    ", "inputs", ".", "append", "(", "att_tm1", ")", "\n", "", "if", "args", ".", "no_parent_production_embed", "is", "False", ":", "\n", "                    ", "parent_production_embed", "=", "self", ".", "production_embed", "(", "batch", ".", "get_frontier_prod_idx", "(", "t", ")", ")", "\n", "inputs", ".", "append", "(", "parent_production_embed", ")", "\n", "", "if", "args", ".", "no_parent_field_embed", "is", "False", ":", "\n", "                    ", "parent_field_embed", "=", "self", ".", "field_embed", "(", "batch", ".", "get_frontier_field_idx", "(", "t", ")", ")", "\n", "inputs", ".", "append", "(", "parent_field_embed", ")", "\n", "", "if", "args", ".", "no_parent_field_type_embed", "is", "False", ":", "\n", "                    ", "parent_field_type_embed", "=", "self", ".", "type_embed", "(", "batch", ".", "get_frontier_field_type_idx", "(", "t", ")", ")", "\n", "inputs", ".", "append", "(", "parent_field_type_embed", ")", "\n", "\n", "# append history states", "\n", "", "actions_t", "=", "[", "e", ".", "tgt_actions", "[", "t", "]", "if", "t", "<", "len", "(", "e", ".", "tgt_actions", ")", "else", "None", "for", "e", "in", "batch", ".", "examples", "]", "\n", "if", "args", ".", "no_parent_state", "is", "False", ":", "\n", "                    ", "parent_states", "=", "torch", ".", "stack", "(", "[", "history_states", "[", "p_t", "]", "[", "0", "]", "[", "batch_id", "]", "\n", "for", "batch_id", ",", "p_t", "in", "\n", "enumerate", "(", "a_t", ".", "parent_t", "if", "a_t", "else", "0", "for", "a_t", "in", "actions_t", ")", "]", ")", "\n", "\n", "parent_cells", "=", "torch", ".", "stack", "(", "[", "history_states", "[", "p_t", "]", "[", "1", "]", "[", "batch_id", "]", "\n", "for", "batch_id", ",", "p_t", "in", "\n", "enumerate", "(", "a_t", ".", "parent_t", "if", "a_t", "else", "0", "for", "a_t", "in", "actions_t", ")", "]", ")", "\n", "\n", "if", "args", ".", "lstm", "==", "'parent_feed'", ":", "\n", "                        ", "h_tm1", "=", "(", "h_tm1", "[", "0", "]", ",", "h_tm1", "[", "1", "]", ",", "parent_states", ",", "parent_cells", ")", "\n", "", "else", ":", "\n", "                        ", "inputs", ".", "append", "(", "parent_states", ")", "\n", "\n", "", "", "x", "=", "torch", ".", "cat", "(", "inputs", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "(", "h_t", ",", "cell_t", ")", ",", "att_t", ",", "att_weight", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "src_encodings", ",", "\n", "src_encodings_att_linear", ",", "\n", "src_token_mask", "=", "batch", ".", "src_token_mask", ",", "\n", "return_att_weight", "=", "True", ")", "\n", "\n", "# if use supervised attention", "\n", "if", "args", ".", "sup_attention", ":", "\n", "                ", "for", "e_id", ",", "example", "in", "enumerate", "(", "batch", ".", "examples", ")", ":", "\n", "                    ", "if", "t", "<", "len", "(", "example", ".", "tgt_actions", ")", ":", "\n", "                        ", "action_t", "=", "example", ".", "tgt_actions", "[", "t", "]", ".", "action", "\n", "cand_src_tokens", "=", "AttentionUtil", ".", "get_candidate_tokens_to_attend", "(", "example", ".", "src_sent", ",", "action_t", ")", "\n", "if", "cand_src_tokens", ":", "\n", "                            ", "att_prob", "=", "[", "att_weight", "[", "e_id", ",", "token_id", "]", "for", "token_id", "in", "cand_src_tokens", "]", "\n", "if", "len", "(", "att_prob", ")", ">", "1", ":", "att_prob", "=", "torch", ".", "cat", "(", "att_prob", ")", ".", "sum", "(", ")", "\n", "else", ":", "att_prob", "=", "att_prob", "[", "0", "]", "\n", "att_probs", ".", "append", "(", "att_prob", ")", "\n", "\n", "", "", "", "", "history_states", ".", "append", "(", "(", "h_t", ",", "cell_t", ")", ")", "\n", "att_vecs", ".", "append", "(", "att_t", ")", "\n", "att_weights", ".", "append", "(", "att_weight", ")", "\n", "\n", "h_tm1", "=", "(", "h_t", ",", "cell_t", ")", "\n", "att_tm1", "=", "att_t", "\n", "\n", "", "att_vecs", "=", "torch", ".", "stack", "(", "att_vecs", ",", "dim", "=", "0", ")", "\n", "if", "args", ".", "sup_attention", ":", "\n", "            ", "return", "att_vecs", ",", "att_probs", "\n", "", "else", ":", "return", "att_vecs", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.parse": [[473, 788], ["model.nn_utils.to_input_variable", "parser.Parser.encode", "parser.Parser.att_src_linear", "parser.Parser.init_decoder_state", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "collections.OrderedDict", "enumerate", "completed_hypotheses.sort", "parser.Parser.new_tensor().zero_", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "collections.OrderedDict.setdefault().append", "components.decode_hypothesis.DecodeHypothesis", "len", "src_encodings.expand", "parser.Parser.expand", "parser.Parser.step", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "enumerate", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "zip", "len", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "parser.Parser.new_tensor", "len", "src_encodings.size", "src_encodings.size", "parser.Parser.size", "parser.Parser.size", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "parser.Parser.production_readout", "parser.Parser.tgt_token_readout", "parser.Parser.src_pointer_net().squeeze", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "parser.Parser.transition_system.get_valid_continuation_types", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "top_new_hyp_scores.data.cpu", "top_new_hyp_pos.data.cpu", "components.action_info.ActionInfo", "prev_hyp.clone_and_apply_action_info", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "parser.Parser.new_tensor().zero_", "parser.Parser.new_tensor().zero_", "parser.Parser.new_tensor", "collections.OrderedDict.setdefault", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "inputs.append", "parser.Parser.production_embed", "inputs.append", "parser.Parser.field_embed", "inputs.append", "parser.Parser.type_embed", "inputs.append", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "parser.Parser.primitive_predictor", "primitive_predictor_prob[].unsqueeze", "parser.Parser.new_tensor", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "min", "len", "asdl.hypothesis.GenTokenAction", "completed_hypotheses.append", "new_hypotheses.append", "live_hyp_ids.append", "parser.Parser.new_tensor", "parser.Parser.new_tensor().zero_", "isinstance", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "inputs.append", "parser.Parser.src_pointer_net", "parser.Parser.transition_system.get_valid_continuating_productions", "torch.cat.size", "torch.cat.size", "torch.cat.size", "torch.cat.size", "len", "asdl.transition_system.ApplyRuleAction", "asdl.transition_system.ReduceAction", "primitive_prob.size", "primitive_prob.size", "parser.Parser.new_tensor", "parser.Parser.new_tensor", "isinstance", "parser.Parser.new_long_tensor", "parser.Parser.new_long_tensor", "parser.Parser.new_long_tensor", "att_t.unsqueeze", "apply_rule_log_prob[].data.item", "applyrule_new_hyp_scores.append", "applyrule_new_hyp_prod_ids.append", "applyrule_prev_hyp_ids.append", "apply_rule_log_prob[].data.item", "applyrule_new_hyp_scores.append", "applyrule_new_hyp_prod_ids.append", "applyrule_prev_hyp_ids.append", "gentoken_prev_hyp_ids.append", "dict", "hyp_scores[].unsqueeze", "len", "len", "len", "primitive_predictor_prob[].log().cpu().data.numpy", "gen_from_vocab_prob[].log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "torch.gather().sum().log().cpu().data.item", "parser.Parser.new_tensor", "enumerate", "enumerate", "len", "collections.OrderedDict.items", "numpy.array().argmax", "gentoken_new_hyp_unks.append", "token_id.item", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "len", "len", "hyp_unk_copy_info.append", "numpy.array", "primitive_predictor_prob[].log().cpu", "gen_from_vocab_prob[].log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather().sum().log().cpu", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "gated_copy_prob.data.item", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "gated_copy_prob.data.item", "primitive_predictor_prob[].log", "gen_from_vocab_prob[].log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "torch.gather().sum().log", "len", "T.LongTensor", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather().sum", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "T.LongTensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_valid_continuation_types", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.components.decode_hypothesis.DecodeHypothesis.clone_and_apply_action_info", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.transition_system.TransitionSystem.get_valid_continuating_productions", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "def", "parse", "(", "self", ",", "src_sent", ",", "context", "=", "None", ",", "beam_size", "=", "5", ",", "debug", "=", "False", ")", ":", "\n", "        ", "\"\"\"Perform beam search to infer the target AST given a source utterance\n\n        Args:\n            src_sent: list of source utterance tokens\n            context: other context used for prediction\n            beam_size: beam size\n\n        Returns:\n            A list of `DecodeHypothesis`, each representing an AST\n        \"\"\"", "\n", "\n", "args", "=", "self", ".", "args", "\n", "primitive_vocab", "=", "self", ".", "vocab", ".", "primitive", "\n", "T", "=", "torch", ".", "cuda", "if", "args", ".", "cuda", "else", "torch", "\n", "\n", "src_sent_var", "=", "nn_utils", ".", "to_input_variable", "(", "[", "src_sent", "]", ",", "self", ".", "vocab", ".", "source", ",", "cuda", "=", "args", ".", "cuda", ",", "training", "=", "False", ")", "\n", "\n", "# Variable(1, src_sent_len, hidden_size * 2)", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "src_sent_var", ",", "[", "len", "(", "src_sent", ")", "]", ")", "\n", "# (1, src_sent_len, hidden_size)", "\n", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "\n", "dec_init_vec", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "if", "args", ".", "lstm", "==", "'parent_feed'", ":", "\n", "            ", "h_tm1", "=", "dec_init_vec", "[", "0", "]", ",", "dec_init_vec", "[", "1", "]", ",", "Variable", "(", "self", ".", "new_tensor", "(", "args", ".", "hidden_size", ")", ".", "zero_", "(", ")", ")", ",", "Variable", "(", "self", ".", "new_tensor", "(", "args", ".", "hidden_size", ")", ".", "zero_", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "h_tm1", "=", "dec_init_vec", "\n", "\n", "", "zero_action_embed", "=", "Variable", "(", "self", ".", "new_tensor", "(", "args", ".", "action_embed_size", ")", ".", "zero_", "(", ")", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "hyp_scores", "=", "Variable", "(", "self", ".", "new_tensor", "(", "[", "0.", "]", ")", ")", "\n", "\n", "# For computing copy probabilities, we marginalize over tokens with the same surface form", "\n", "# `aggregated_primitive_tokens` stores the position of occurrence of each source token", "\n", "", "aggregated_primitive_tokens", "=", "OrderedDict", "(", ")", "\n", "for", "token_pos", ",", "token", "in", "enumerate", "(", "src_sent", ")", ":", "\n", "            ", "aggregated_primitive_tokens", ".", "setdefault", "(", "token", ",", "[", "]", ")", ".", "append", "(", "token_pos", ")", "\n", "\n", "", "t", "=", "0", "\n", "hypotheses", "=", "[", "DecodeHypothesis", "(", ")", "]", "\n", "hyp_states", "=", "[", "[", "]", "]", "\n", "completed_hypotheses", "=", "[", "]", "\n", "\n", "while", "len", "(", "completed_hypotheses", ")", "<", "beam_size", "and", "t", "<", "args", ".", "decode_max_time_step", ":", "\n", "            ", "hyp_num", "=", "len", "(", "hypotheses", ")", "\n", "\n", "# (hyp_num, src_sent_len, hidden_size * 2)", "\n", "exp_src_encodings", "=", "src_encodings", ".", "expand", "(", "hyp_num", ",", "src_encodings", ".", "size", "(", "1", ")", ",", "src_encodings", ".", "size", "(", "2", ")", ")", "\n", "# (hyp_num, src_sent_len, hidden_size)", "\n", "exp_src_encodings_att_linear", "=", "src_encodings_att_linear", ".", "expand", "(", "hyp_num", ",", "src_encodings_att_linear", ".", "size", "(", "1", ")", ",", "src_encodings_att_linear", ".", "size", "(", "2", ")", ")", "\n", "\n", "if", "t", "==", "0", ":", "\n", "                ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "                    ", "x", "=", "Variable", "(", "self", ".", "new_tensor", "(", "1", ",", "self", ".", "decoder_lstm", ".", "input_size", ")", ".", "zero_", "(", ")", ")", "\n", "", "if", "args", ".", "no_parent_field_type_embed", "is", "False", ":", "\n", "                    ", "offset", "=", "args", ".", "action_embed_size", "# prev_action", "\n", "offset", "+=", "args", ".", "att_vec_size", "*", "(", "not", "args", ".", "no_input_feed", ")", "\n", "offset", "+=", "args", ".", "action_embed_size", "*", "(", "not", "args", ".", "no_parent_production_embed", ")", "\n", "offset", "+=", "args", ".", "field_embed_size", "*", "(", "not", "args", ".", "no_parent_field_embed", ")", "\n", "\n", "x", "[", "0", ",", "offset", ":", "offset", "+", "args", ".", "type_embed_size", "]", "=", "self", ".", "type_embed", ".", "weight", "[", "self", ".", "grammar", ".", "type2id", "[", "self", ".", "grammar", ".", "root_type", "]", "]", "\n", "", "", "else", ":", "\n", "                ", "actions_tm1", "=", "[", "hyp", ".", "actions", "[", "-", "1", "]", "for", "hyp", "in", "hypotheses", "]", "\n", "\n", "a_tm1_embeds", "=", "[", "]", "\n", "for", "a_tm1", "in", "actions_tm1", ":", "\n", "                    ", "if", "a_tm1", ":", "\n", "                        ", "if", "isinstance", "(", "a_tm1", ",", "ApplyRuleAction", ")", ":", "\n", "                            ", "a_tm1_embed", "=", "self", ".", "production_embed", ".", "weight", "[", "self", ".", "grammar", ".", "prod2id", "[", "a_tm1", ".", "production", "]", "]", "\n", "", "elif", "isinstance", "(", "a_tm1", ",", "ReduceAction", ")", ":", "\n", "                            ", "a_tm1_embed", "=", "self", ".", "production_embed", ".", "weight", "[", "len", "(", "self", ".", "grammar", ")", "]", "\n", "", "else", ":", "\n", "                            ", "a_tm1_embed", "=", "self", ".", "primitive_embed", ".", "weight", "[", "self", ".", "vocab", ".", "primitive", "[", "a_tm1", ".", "token", "]", "]", "\n", "\n", "", "a_tm1_embeds", ".", "append", "(", "a_tm1_embed", ")", "\n", "", "else", ":", "\n", "                        ", "a_tm1_embeds", ".", "append", "(", "zero_action_embed", ")", "\n", "", "", "a_tm1_embeds", "=", "torch", ".", "stack", "(", "a_tm1_embeds", ")", "\n", "\n", "inputs", "=", "[", "a_tm1_embeds", "]", "\n", "if", "args", ".", "no_input_feed", "is", "False", ":", "\n", "                    ", "inputs", ".", "append", "(", "att_tm1", ")", "\n", "", "if", "args", ".", "no_parent_production_embed", "is", "False", ":", "\n", "# frontier production", "\n", "                    ", "frontier_prods", "=", "[", "hyp", ".", "frontier_node", ".", "production", "for", "hyp", "in", "hypotheses", "]", "\n", "frontier_prod_embeds", "=", "self", ".", "production_embed", "(", "Variable", "(", "self", ".", "new_long_tensor", "(", "\n", "[", "self", ".", "grammar", ".", "prod2id", "[", "prod", "]", "for", "prod", "in", "frontier_prods", "]", ")", ")", ")", "\n", "inputs", ".", "append", "(", "frontier_prod_embeds", ")", "\n", "", "if", "args", ".", "no_parent_field_embed", "is", "False", ":", "\n", "# frontier field", "\n", "                    ", "frontier_fields", "=", "[", "hyp", ".", "frontier_field", ".", "field", "for", "hyp", "in", "hypotheses", "]", "\n", "frontier_field_embeds", "=", "self", ".", "field_embed", "(", "Variable", "(", "self", ".", "new_long_tensor", "(", "[", "\n", "self", ".", "grammar", ".", "field2id", "[", "field", "]", "for", "field", "in", "frontier_fields", "]", ")", ")", ")", "\n", "\n", "inputs", ".", "append", "(", "frontier_field_embeds", ")", "\n", "", "if", "args", ".", "no_parent_field_type_embed", "is", "False", ":", "\n", "# frontier field type", "\n", "                    ", "frontier_field_types", "=", "[", "hyp", ".", "frontier_field", ".", "type", "for", "hyp", "in", "hypotheses", "]", "\n", "frontier_field_type_embeds", "=", "self", ".", "type_embed", "(", "Variable", "(", "self", ".", "new_long_tensor", "(", "[", "\n", "self", ".", "grammar", ".", "type2id", "[", "type", "]", "for", "type", "in", "frontier_field_types", "]", ")", ")", ")", "\n", "inputs", ".", "append", "(", "frontier_field_type_embeds", ")", "\n", "\n", "# parent states", "\n", "", "if", "args", ".", "no_parent_state", "is", "False", ":", "\n", "                    ", "p_ts", "=", "[", "hyp", ".", "frontier_node", ".", "created_time", "for", "hyp", "in", "hypotheses", "]", "\n", "parent_states", "=", "torch", ".", "stack", "(", "[", "hyp_states", "[", "hyp_id", "]", "[", "p_t", "]", "[", "0", "]", "for", "hyp_id", ",", "p_t", "in", "enumerate", "(", "p_ts", ")", "]", ")", "\n", "parent_cells", "=", "torch", ".", "stack", "(", "[", "hyp_states", "[", "hyp_id", "]", "[", "p_t", "]", "[", "1", "]", "for", "hyp_id", ",", "p_t", "in", "enumerate", "(", "p_ts", ")", "]", ")", "\n", "\n", "if", "args", ".", "lstm", "==", "'parent_feed'", ":", "\n", "                        ", "h_tm1", "=", "(", "h_tm1", "[", "0", "]", ",", "h_tm1", "[", "1", "]", ",", "parent_states", ",", "parent_cells", ")", "\n", "", "else", ":", "\n", "                        ", "inputs", ".", "append", "(", "parent_states", ")", "\n", "\n", "", "", "x", "=", "torch", ".", "cat", "(", "inputs", ",", "dim", "=", "-", "1", ")", "\n", "\n", "", "(", "h_t", ",", "cell_t", ")", ",", "att_t", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "exp_src_encodings", ",", "\n", "exp_src_encodings_att_linear", ",", "\n", "src_token_mask", "=", "None", ")", "\n", "\n", "# Variable(batch_size, grammar_size)", "\n", "# apply_rule_log_prob = torch.log(F.softmax(self.production_readout(att_t), dim=-1))", "\n", "apply_rule_log_prob", "=", "F", ".", "log_softmax", "(", "self", ".", "production_readout", "(", "att_t", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Variable(batch_size, primitive_vocab_size)", "\n", "gen_from_vocab_prob", "=", "F", ".", "softmax", "(", "self", ".", "tgt_token_readout", "(", "att_t", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "if", "args", ".", "no_copy", ":", "\n", "                ", "primitive_prob", "=", "gen_from_vocab_prob", "\n", "", "else", ":", "\n", "# Variable(batch_size, src_sent_len)", "\n", "                ", "primitive_copy_prob", "=", "self", ".", "src_pointer_net", "(", "src_encodings", ",", "None", ",", "att_t", ".", "unsqueeze", "(", "0", ")", ")", ".", "squeeze", "(", "0", ")", "\n", "\n", "# Variable(batch_size, 2)", "\n", "primitive_predictor_prob", "=", "F", ".", "softmax", "(", "self", ".", "primitive_predictor", "(", "att_t", ")", ",", "dim", "=", "-", "1", ")", "\n", "\n", "# Variable(batch_size, primitive_vocab_size)", "\n", "primitive_prob", "=", "primitive_predictor_prob", "[", ":", ",", "0", "]", ".", "unsqueeze", "(", "1", ")", "*", "gen_from_vocab_prob", "\n", "\n", "# if src_unk_pos_list:", "\n", "#     primitive_prob[:, primitive_vocab.unk_id] = 1.e-10", "\n", "\n", "", "gentoken_prev_hyp_ids", "=", "[", "]", "\n", "gentoken_new_hyp_unks", "=", "[", "]", "\n", "applyrule_new_hyp_scores", "=", "[", "]", "\n", "applyrule_new_hyp_prod_ids", "=", "[", "]", "\n", "applyrule_prev_hyp_ids", "=", "[", "]", "\n", "\n", "for", "hyp_id", ",", "hyp", "in", "enumerate", "(", "hypotheses", ")", ":", "\n", "# generate new continuations", "\n", "                ", "action_types", "=", "self", ".", "transition_system", ".", "get_valid_continuation_types", "(", "hyp", ")", "\n", "\n", "for", "action_type", "in", "action_types", ":", "\n", "                    ", "if", "action_type", "==", "ApplyRuleAction", ":", "\n", "                        ", "productions", "=", "self", ".", "transition_system", ".", "get_valid_continuating_productions", "(", "hyp", ")", "\n", "for", "production", "in", "productions", ":", "\n", "                            ", "prod_id", "=", "self", ".", "grammar", ".", "prod2id", "[", "production", "]", "\n", "prod_score", "=", "apply_rule_log_prob", "[", "hyp_id", ",", "prod_id", "]", ".", "data", ".", "item", "(", ")", "\n", "new_hyp_score", "=", "hyp", ".", "score", "+", "prod_score", "\n", "\n", "applyrule_new_hyp_scores", ".", "append", "(", "new_hyp_score", ")", "\n", "applyrule_new_hyp_prod_ids", ".", "append", "(", "prod_id", ")", "\n", "applyrule_prev_hyp_ids", ".", "append", "(", "hyp_id", ")", "\n", "", "", "elif", "action_type", "==", "ReduceAction", ":", "\n", "                        ", "action_score", "=", "apply_rule_log_prob", "[", "hyp_id", ",", "len", "(", "self", ".", "grammar", ")", "]", ".", "data", ".", "item", "(", ")", "\n", "new_hyp_score", "=", "hyp", ".", "score", "+", "action_score", "\n", "\n", "applyrule_new_hyp_scores", ".", "append", "(", "new_hyp_score", ")", "\n", "applyrule_new_hyp_prod_ids", ".", "append", "(", "len", "(", "self", ".", "grammar", ")", ")", "\n", "applyrule_prev_hyp_ids", ".", "append", "(", "hyp_id", ")", "\n", "", "else", ":", "\n", "# GenToken action", "\n", "                        ", "gentoken_prev_hyp_ids", ".", "append", "(", "hyp_id", ")", "\n", "hyp_copy_info", "=", "dict", "(", ")", "# of (token_pos, copy_prob)", "\n", "hyp_unk_copy_info", "=", "[", "]", "\n", "\n", "if", "args", ".", "no_copy", "is", "False", ":", "\n", "                            ", "for", "token", ",", "token_pos_list", "in", "aggregated_primitive_tokens", ".", "items", "(", ")", ":", "\n", "                                ", "sum_copy_prob", "=", "torch", ".", "gather", "(", "primitive_copy_prob", "[", "hyp_id", "]", ",", "0", ",", "Variable", "(", "T", ".", "LongTensor", "(", "token_pos_list", ")", ")", ")", ".", "sum", "(", ")", "\n", "gated_copy_prob", "=", "primitive_predictor_prob", "[", "hyp_id", ",", "1", "]", "*", "sum_copy_prob", "\n", "\n", "if", "token", "in", "primitive_vocab", ":", "\n", "                                    ", "token_id", "=", "primitive_vocab", "[", "token", "]", "\n", "primitive_prob", "[", "hyp_id", ",", "token_id", "]", "=", "primitive_prob", "[", "hyp_id", ",", "token_id", "]", "+", "gated_copy_prob", "\n", "\n", "hyp_copy_info", "[", "token", "]", "=", "(", "token_pos_list", ",", "gated_copy_prob", ".", "data", ".", "item", "(", ")", ")", "\n", "", "else", ":", "\n", "                                    ", "hyp_unk_copy_info", ".", "append", "(", "{", "'token'", ":", "token", ",", "'token_pos_list'", ":", "token_pos_list", ",", "\n", "'copy_prob'", ":", "gated_copy_prob", ".", "data", ".", "item", "(", ")", "}", ")", "\n", "\n", "", "", "", "if", "args", ".", "no_copy", "is", "False", "and", "len", "(", "hyp_unk_copy_info", ")", ">", "0", ":", "\n", "                            ", "unk_i", "=", "np", ".", "array", "(", "[", "x", "[", "'copy_prob'", "]", "for", "x", "in", "hyp_unk_copy_info", "]", ")", ".", "argmax", "(", ")", "\n", "token", "=", "hyp_unk_copy_info", "[", "unk_i", "]", "[", "'token'", "]", "\n", "primitive_prob", "[", "hyp_id", ",", "primitive_vocab", ".", "unk_id", "]", "=", "hyp_unk_copy_info", "[", "unk_i", "]", "[", "'copy_prob'", "]", "\n", "gentoken_new_hyp_unks", ".", "append", "(", "token", ")", "\n", "\n", "hyp_copy_info", "[", "token", "]", "=", "(", "hyp_unk_copy_info", "[", "unk_i", "]", "[", "'token_pos_list'", "]", ",", "hyp_unk_copy_info", "[", "unk_i", "]", "[", "'copy_prob'", "]", ")", "\n", "\n", "", "", "", "", "new_hyp_scores", "=", "None", "\n", "if", "applyrule_new_hyp_scores", ":", "\n", "                ", "new_hyp_scores", "=", "Variable", "(", "self", ".", "new_tensor", "(", "applyrule_new_hyp_scores", ")", ")", "\n", "", "if", "gentoken_prev_hyp_ids", ":", "\n", "                ", "primitive_log_prob", "=", "torch", ".", "log", "(", "primitive_prob", ")", "\n", "gen_token_new_hyp_scores", "=", "(", "hyp_scores", "[", "gentoken_prev_hyp_ids", "]", ".", "unsqueeze", "(", "1", ")", "+", "primitive_log_prob", "[", "gentoken_prev_hyp_ids", ",", ":", "]", ")", ".", "view", "(", "-", "1", ")", "\n", "\n", "if", "new_hyp_scores", "is", "None", ":", "new_hyp_scores", "=", "gen_token_new_hyp_scores", "\n", "else", ":", "new_hyp_scores", "=", "torch", ".", "cat", "(", "[", "new_hyp_scores", ",", "gen_token_new_hyp_scores", "]", ")", "\n", "", "top_new_hyp_scores", ",", "top_new_hyp_pos", "=", "torch", ".", "topk", "(", "new_hyp_scores", ",", "\n", "k", "=", "min", "(", "new_hyp_scores", ".", "size", "(", "0", ")", ",", "beam_size", "-", "len", "(", "completed_hypotheses", ")", ")", ")", "\n", "\n", "live_hyp_ids", "=", "[", "]", "\n", "new_hypotheses", "=", "[", "]", "\n", "for", "new_hyp_score", ",", "new_hyp_pos", "in", "zip", "(", "top_new_hyp_scores", ".", "data", ".", "cpu", "(", ")", ",", "top_new_hyp_pos", ".", "data", ".", "cpu", "(", ")", ")", ":", "\n", "                ", "action_info", "=", "ActionInfo", "(", ")", "\n", "if", "new_hyp_pos", "<", "len", "(", "applyrule_new_hyp_scores", ")", ":", "\n", "# it's an ApplyRule or Reduce action", "\n", "                    ", "prev_hyp_id", "=", "applyrule_prev_hyp_ids", "[", "new_hyp_pos", "]", "\n", "prev_hyp", "=", "hypotheses", "[", "prev_hyp_id", "]", "\n", "\n", "prod_id", "=", "applyrule_new_hyp_prod_ids", "[", "new_hyp_pos", "]", "\n", "# ApplyRule action", "\n", "if", "prod_id", "<", "len", "(", "self", ".", "grammar", ")", ":", "\n", "                        ", "production", "=", "self", ".", "grammar", ".", "id2prod", "[", "prod_id", "]", "\n", "action", "=", "ApplyRuleAction", "(", "production", ")", "\n", "# Reduce action", "\n", "", "else", ":", "\n", "                        ", "action", "=", "ReduceAction", "(", ")", "\n", "", "", "else", ":", "\n", "# it's a GenToken action", "\n", "                    ", "token_id", "=", "(", "new_hyp_pos", "-", "len", "(", "applyrule_new_hyp_scores", ")", ")", "%", "primitive_prob", ".", "size", "(", "1", ")", "\n", "\n", "k", "=", "(", "new_hyp_pos", "-", "len", "(", "applyrule_new_hyp_scores", ")", ")", "//", "primitive_prob", ".", "size", "(", "1", ")", "\n", "# try:", "\n", "# copy_info = gentoken_copy_infos[k]", "\n", "prev_hyp_id", "=", "gentoken_prev_hyp_ids", "[", "k", "]", "\n", "prev_hyp", "=", "hypotheses", "[", "prev_hyp_id", "]", "\n", "# except:", "\n", "#     print('k=%d' % k, file=sys.stderr)", "\n", "#     print('primitive_prob.size(1)=%d' % primitive_prob.size(1), file=sys.stderr)", "\n", "#     print('len copy_info=%d' % len(gentoken_copy_infos), file=sys.stderr)", "\n", "#     print('prev_hyp_id=%s' % ', '.join(str(i) for i in gentoken_prev_hyp_ids), file=sys.stderr)", "\n", "#     print('len applyrule_new_hyp_scores=%d' % len(applyrule_new_hyp_scores), file=sys.stderr)", "\n", "#     print('len gentoken_prev_hyp_ids=%d' % len(gentoken_prev_hyp_ids), file=sys.stderr)", "\n", "#     print('top_new_hyp_pos=%s' % top_new_hyp_pos, file=sys.stderr)", "\n", "#     print('applyrule_new_hyp_scores=%s' % applyrule_new_hyp_scores, file=sys.stderr)", "\n", "#     print('new_hyp_scores=%s' % new_hyp_scores, file=sys.stderr)", "\n", "#     print('top_new_hyp_scores=%s' % top_new_hyp_scores, file=sys.stderr)", "\n", "#", "\n", "#     torch.save((applyrule_new_hyp_scores, primitive_prob), 'data.bin')", "\n", "#", "\n", "#     # exit(-1)", "\n", "#     raise ValueError()", "\n", "\n", "if", "token_id", "==", "primitive_vocab", ".", "unk_id", ":", "\n", "                        ", "if", "gentoken_new_hyp_unks", ":", "\n", "                            ", "token", "=", "gentoken_new_hyp_unks", "[", "k", "]", "\n", "", "else", ":", "\n", "                            ", "token", "=", "primitive_vocab", ".", "id2word", "[", "primitive_vocab", ".", "unk_id", "]", "\n", "", "", "else", ":", "\n", "                        ", "token", "=", "primitive_vocab", ".", "id2word", "[", "token_id", ".", "item", "(", ")", "]", "\n", "\n", "", "action", "=", "GenTokenAction", "(", "token", ")", "\n", "\n", "if", "token", "in", "aggregated_primitive_tokens", ":", "\n", "                        ", "action_info", ".", "copy_from_src", "=", "True", "\n", "action_info", ".", "src_token_position", "=", "aggregated_primitive_tokens", "[", "token", "]", "\n", "\n", "", "if", "debug", ":", "\n", "                        ", "action_info", ".", "gen_copy_switch", "=", "'n/a'", "if", "args", ".", "no_copy", "else", "primitive_predictor_prob", "[", "prev_hyp_id", ",", ":", "]", ".", "log", "(", ")", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", "\n", "action_info", ".", "in_vocab", "=", "token", "in", "primitive_vocab", "\n", "action_info", ".", "gen_token_prob", "=", "gen_from_vocab_prob", "[", "prev_hyp_id", ",", "token_id", "]", ".", "log", "(", ")", ".", "cpu", "(", ")", ".", "data", ".", "item", "(", ")", "if", "token", "in", "primitive_vocab", "else", "'n/a'", "\n", "action_info", ".", "copy_token_prob", "=", "torch", ".", "gather", "(", "primitive_copy_prob", "[", "prev_hyp_id", "]", ",", "\n", "0", ",", "\n", "Variable", "(", "T", ".", "LongTensor", "(", "action_info", ".", "src_token_position", ")", ")", ")", ".", "sum", "(", ")", ".", "log", "(", ")", ".", "cpu", "(", ")", ".", "data", ".", "item", "(", ")", "if", "args", ".", "no_copy", "is", "False", "and", "action_info", ".", "copy_from_src", "else", "'n/a'", "\n", "\n", "", "", "action_info", ".", "action", "=", "action", "\n", "action_info", ".", "t", "=", "t", "\n", "if", "t", ">", "0", ":", "\n", "                    ", "action_info", ".", "parent_t", "=", "prev_hyp", ".", "frontier_node", ".", "created_time", "\n", "action_info", ".", "frontier_prod", "=", "prev_hyp", ".", "frontier_node", ".", "production", "\n", "action_info", ".", "frontier_field", "=", "prev_hyp", ".", "frontier_field", ".", "field", "\n", "\n", "", "if", "debug", ":", "\n", "                    ", "action_info", ".", "action_prob", "=", "new_hyp_score", "-", "prev_hyp", ".", "score", "\n", "\n", "", "new_hyp", "=", "prev_hyp", ".", "clone_and_apply_action_info", "(", "action_info", ")", "\n", "new_hyp", ".", "score", "=", "new_hyp_score", "\n", "\n", "if", "new_hyp", ".", "completed", ":", "\n", "# add length normalization", "\n", "                    ", "new_hyp", ".", "score", "/=", "(", "t", "+", "1", ")", "\n", "completed_hypotheses", ".", "append", "(", "new_hyp", ")", "\n", "", "else", ":", "\n", "                    ", "new_hypotheses", ".", "append", "(", "new_hyp", ")", "\n", "live_hyp_ids", ".", "append", "(", "prev_hyp_id", ")", "\n", "\n", "", "", "if", "live_hyp_ids", ":", "\n", "                ", "hyp_states", "=", "[", "hyp_states", "[", "i", "]", "+", "[", "(", "h_t", "[", "i", "]", ",", "cell_t", "[", "i", "]", ")", "]", "for", "i", "in", "live_hyp_ids", "]", "\n", "h_tm1", "=", "(", "h_t", "[", "live_hyp_ids", "]", ",", "cell_t", "[", "live_hyp_ids", "]", ")", "\n", "att_tm1", "=", "att_t", "[", "live_hyp_ids", "]", "\n", "hypotheses", "=", "new_hypotheses", "\n", "hyp_scores", "=", "Variable", "(", "self", ".", "new_tensor", "(", "[", "hyp", ".", "score", "for", "hyp", "in", "hypotheses", "]", ")", ")", "\n", "t", "+=", "1", "\n", "", "else", ":", "\n", "                ", "break", "\n", "\n", "", "", "completed_hypotheses", ".", "sort", "(", "key", "=", "lambda", "hyp", ":", "-", "hyp", ".", "score", ")", "\n", "\n", "return", "completed_hypotheses", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.save": [[789, 801], ["os.path.dirname", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.exists", "os.makedirs", "parser.Parser.state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "dirname", "(", "path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_name", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_name", ")", "\n", "\n", "", "params", "=", "{", "\n", "'args'", ":", "self", ".", "args", ",", "\n", "'transition_system'", ":", "self", ".", "transition_system", ",", "\n", "'vocab'", ":", "self", ".", "vocab", ",", "\n", "'state_dict'", ":", "self", ".", "state_dict", "(", ")", "\n", "}", "\n", "torch", ".", "save", "(", "params", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.parser.Parser.load": [[802, 821], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "common.utils.update_args", "cls", "parser.cuda.cuda.load_state_dict", "parser.cuda.cuda.eval", "common.utils.init_arg_parser", "parser.cuda.cuda.cuda"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.update_args", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.init_arg_parser"], ["", "@", "classmethod", "\n", "def", "load", "(", "cls", ",", "model_path", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "params", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "vocab", "=", "params", "[", "'vocab'", "]", "\n", "transition_system", "=", "params", "[", "'transition_system'", "]", "\n", "saved_args", "=", "params", "[", "'args'", "]", "\n", "# update saved args", "\n", "update_args", "(", "saved_args", ",", "init_arg_parser", "(", ")", ")", "\n", "saved_state", "=", "params", "[", "'state_dict'", "]", "\n", "saved_args", ".", "cuda", "=", "cuda", "\n", "\n", "parser", "=", "cls", "(", "saved_args", ",", "vocab", ",", "transition_system", ")", "\n", "\n", "parser", ".", "load_state_dict", "(", "saved_state", ")", "\n", "\n", "if", "cuda", ":", "parser", "=", "parser", ".", "cuda", "(", ")", "\n", "parser", ".", "eval", "(", ")", "\n", "\n", "return", "parser", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.__init__": [[18, 68], ["torch.Module.__init__", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.LSTMCell", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "len", "model.nn_utils.LabelSmoothing", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["def", "__init__", "(", "self", ",", "src_vocab", ",", "tgt_vocab", ",", "embed_size", ",", "hidden_size", ",", "\n", "decoder_word_dropout", "=", "0.", ",", "dropout", "=", "0.", ",", "\n", "label_smoothing", "=", "0.", ",", "\n", "cuda", "=", "False", ",", "\n", "src_embed_layer", "=", "None", ",", "tgt_embed_layer", "=", "None", ")", ":", "\n", "        ", "super", "(", "Seq2SeqModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "embed_size", "=", "embed_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "\n", "if", "src_embed_layer", ":", "\n", "            ", "self", ".", "src_embed", "=", "src_embed_layer", "\n", "", "else", ":", "\n", "            ", "self", ".", "src_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "src_vocab", ")", ",", "embed_size", ")", "\n", "\n", "", "if", "tgt_embed_layer", ":", "\n", "            ", "self", ".", "tgt_embed", "=", "tgt_embed_layer", "\n", "", "else", ":", "\n", "            ", "self", ".", "tgt_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "tgt_vocab", ")", ",", "embed_size", ")", "\n", "\n", "", "self", ".", "src_vocab", "=", "src_vocab", "\n", "self", ".", "tgt_vocab", "=", "tgt_vocab", "\n", "\n", "self", ".", "encoder_lstm", "=", "nn", ".", "LSTM", "(", "embed_size", ",", "hidden_size", ",", "bidirectional", "=", "True", ")", "\n", "self", ".", "decoder_lstm", "=", "nn", ".", "LSTMCell", "(", "embed_size", "+", "hidden_size", ",", "hidden_size", ")", "\n", "\n", "# initialize the decoder's state and cells with encoder hidden states", "\n", "self", ".", "decoder_cell_init", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "2", ",", "hidden_size", ")", "\n", "\n", "# attention: dot product attention", "\n", "# project source encoding to decoder rnn's h space", "\n", "self", ".", "att_src_linear", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "2", ",", "hidden_size", ",", "bias", "=", "False", ")", "\n", "\n", "# transformation of decoder hidden states and context vectors before reading out target words", "\n", "# this produces the `attentional vector` in (Luong et al., 2015)", "\n", "self", ".", "att_vec_linear", "=", "nn", ".", "Linear", "(", "hidden_size", "*", "2", "+", "hidden_size", ",", "hidden_size", ",", "bias", "=", "False", ")", "\n", "\n", "# prediction layer of the target vocabulary", "\n", "self", ".", "readout", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "len", "(", "tgt_vocab", ")", ",", "bias", "=", "False", ")", "\n", "\n", "# dropout layer", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "self", ".", "decoder_word_dropout", "=", "decoder_word_dropout", "\n", "\n", "# label smoothing", "\n", "self", ".", "label_smoothing", "=", "label_smoothing", "\n", "if", "label_smoothing", ":", "\n", "            ", "self", ".", "label_smoothing_layer", "=", "nn_utils", ".", "LabelSmoothing", "(", "label_smoothing", ",", "len", "(", "tgt_vocab", ")", ",", "ignore_indices", "=", "[", "0", "]", ")", "\n", "\n", "", "self", ".", "cuda", "=", "cuda", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode": [[69, 90], ["seq2seq.Seq2SeqModel.src_embed", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "torch.nn.utils.rnn.pack_padded_sequence", "seq2seq.Seq2SeqModel.encoder_lstm", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.nn.utils.rnn.pad_packed_sequence", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["None"], ["", "def", "encode", "(", "self", ",", "src_sents_var", ",", "src_sents_len", ")", ":", "\n", "        ", "\"\"\"\n        encode the source sequence\n        :return:\n            src_encodings: Variable(src_sent_len, batch_size, hidden_size * 2)\n            dec_init_state, dec_init_cell: Variable(batch_size, hidden_size)\n        \"\"\"", "\n", "\n", "# (tgt_query_len, batch_size, embed_size)", "\n", "src_token_embed", "=", "self", ".", "src_embed", "(", "src_sents_var", ")", "\n", "packed_src_token_embed", "=", "pack_padded_sequence", "(", "src_token_embed", ",", "src_sents_len", ")", "\n", "\n", "# src_encodings: (tgt_query_len, batch_size, hidden_size)", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encoder_lstm", "(", "packed_src_token_embed", ")", "\n", "src_encodings", ",", "_", "=", "pad_packed_sequence", "(", "src_encodings", ")", "\n", "\n", "# (batch_size, hidden_size * 2)", "\n", "last_state", "=", "torch", ".", "cat", "(", "[", "last_state", "[", "0", "]", ",", "last_state", "[", "1", "]", "]", ",", "1", ")", "\n", "last_cell", "=", "torch", ".", "cat", "(", "[", "last_cell", "[", "0", "]", ",", "last_cell", "[", "1", "]", "]", ",", "1", ")", "\n", "\n", "return", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state": [[91, 96], ["seq2seq.Seq2SeqModel.decoder_cell_init", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh"], "methods", ["None"], ["", "def", "init_decoder_state", "(", "self", ",", "enc_last_state", ",", "enc_last_cell", ")", ":", "\n", "        ", "dec_init_cell", "=", "self", ".", "decoder_cell_init", "(", "enc_last_cell", ")", "\n", "dec_init_state", "=", "torch", ".", "tanh", "(", "dec_init_cell", ")", "\n", "\n", "return", "dec_init_state", ",", "dec_init_cell", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode": [[97, 149], ["src_encodings.permute.permute.size", "src_encodings.permute.permute.permute", "seq2seq.Seq2SeqModel.att_src_linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "model.nn_utils.length_array_to_mask_tensor", "seq2seq.Seq2SeqModel.tgt_embed", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "new_tensor().zero_", "list", "y_tm1_embed.squeeze.squeeze.squeeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "seq2seq.Seq2SeqModel.step", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "enumerate", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "new_tensor", "seq2seq.Seq2SeqModel.split", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.bernoulli", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "new_tensor().fill_", "new_tensor"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step"], ["", "def", "decode", "(", "self", ",", "src_encodings", ",", "src_sents_len", ",", "dec_init_vec", ",", "tgt_sents_var", ")", ":", "\n", "        ", "\"\"\"\n        compute the final softmax layer at each decoding step\n        :param src_encodings: Variable(src_sent_len, batch_size, hidden_size * 2)\n        :param src_sents_len: list[int]\n        :param dec_init_vec: tuple((batch_size, hidden_size))\n        :param tgt_sents_var: Variable(tgt_sent_len, batch_size)\n        :return:\n            scores: Variable(src_sent_len, batch_size, src_vocab_size)\n        \"\"\"", "\n", "new_tensor", "=", "src_encodings", ".", "data", ".", "new", "\n", "batch_size", "=", "src_encodings", ".", "size", "(", "1", ")", "\n", "\n", "h_tm1", "=", "dec_init_vec", "\n", "# (batch_size, query_len, hidden_size * 2)", "\n", "src_encodings", "=", "src_encodings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "# (batch_size, query_len, hidden_size)", "\n", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "# initialize the attentional vector", "\n", "att_tm1", "=", "Variable", "(", "new_tensor", "(", "batch_size", ",", "self", ".", "hidden_size", ")", ".", "zero_", "(", ")", ",", "requires_grad", "=", "False", ")", "\n", "# (batch_size, src_sent_len)", "\n", "src_sent_masks", "=", "nn_utils", ".", "length_array_to_mask_tensor", "(", "src_sents_len", ",", "cuda", "=", "self", ".", "cuda", ")", "\n", "\n", "# (tgt_sent_len, batch_size, embed_size)", "\n", "tgt_token_embed", "=", "self", ".", "tgt_embed", "(", "tgt_sents_var", ")", "\n", "\n", "scores", "=", "[", "]", "\n", "# start from `<s>`, until y_{T-1}", "\n", "for", "t", ",", "y_tm1_embed", "in", "list", "(", "enumerate", "(", "tgt_token_embed", ".", "split", "(", "split_size", "=", "1", ")", ")", ")", "[", ":", "-", "1", "]", ":", "\n", "# input feeding: concate y_tm1 and previous attentional vector", "\n", "# split() keeps the first dim", "\n", "            ", "y_tm1_embed", "=", "y_tm1_embed", ".", "squeeze", "(", "0", ")", "\n", "if", "t", ">", "0", "and", "self", ".", "decoder_word_dropout", ":", "\n", "# (batch_size)", "\n", "                ", "y_tm1_mask", "=", "Variable", "(", "torch", ".", "bernoulli", "(", "new_tensor", "(", "batch_size", ")", ".", "fill_", "(", "1", "-", "self", ".", "decoder_word_dropout", ")", ")", ")", "\n", "y_tm1_embed", "=", "y_tm1_embed", "*", "y_tm1_mask", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "", "x", "=", "torch", ".", "cat", "(", "[", "y_tm1_embed", ",", "att_tm1", "]", ",", "1", ")", "\n", "\n", "(", "h_t", ",", "cell_t", ")", ",", "att_t", ",", "score_t", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "\n", "src_encodings", ",", "src_encodings_att_linear", ",", "\n", "src_sent_masks", "=", "src_sent_masks", ")", "\n", "\n", "scores", ".", "append", "(", "score_t", ")", "\n", "\n", "att_tm1", "=", "att_t", "\n", "h_tm1", "=", "(", "h_t", ",", "cell_t", ")", "\n", "\n", "# (src_sent_len, batch_size, tgt_vocab_size)", "\n", "", "scores", "=", "torch", ".", "stack", "(", "scores", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.score_decoding_results": [[150, 176], ["scores.size", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.gather().squeeze.sum", "torch.gather().squeeze.sum", "torch.gather().squeeze.sum", "torch.gather().squeeze.sum", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "torch.gather().squeeze", "seq2seq.Seq2SeqModel.label_smoothing_layer", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.eq().float", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "tgt_sents_var_sos_omitted.unsqueeze", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq", "torch.eq"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax"], ["", "def", "score_decoding_results", "(", "self", ",", "scores", ",", "tgt_sents_var", ")", ":", "\n", "        ", "\"\"\"\n        :param scores: Variable(src_sent_len, batch_size, tgt_vocab_size)\n        :param tgt_sents_var: Variable(src_sent_len, batch_size)\n        :return:\n            tgt_sent_log_scores: Variable(batch_size)\n        \"\"\"", "\n", "batch_size", "=", "scores", ".", "size", "(", "1", ")", "\n", "\n", "# (tgt_sent_len, batch_size, tgt_vocab_size)", "\n", "log_scores", "=", "F", ".", "log_softmax", "(", "scores", ",", "dim", "=", "-", "1", ")", "\n", "tgt_sents_var_sos_omitted", "=", "tgt_sents_var", "[", "1", ":", "]", "# remove leading <s> in tgt sent, which is not used as the target", "\n", "\n", "if", "self", ".", "training", "and", "self", ".", "label_smoothing", ":", "\n", "# (tgt_sent_len, batch_size)", "\n", "            ", "tgt_sent_log_scores", "=", "-", "self", ".", "label_smoothing_layer", "(", "log_scores", ",", "tgt_sents_var_sos_omitted", ")", "\n", "", "else", ":", "\n", "# (tgt_sent_len, batch_size)", "\n", "            ", "tgt_sent_log_scores", "=", "torch", ".", "gather", "(", "log_scores", ",", "-", "1", ",", "tgt_sents_var_sos_omitted", ".", "unsqueeze", "(", "-", "1", ")", ")", ".", "squeeze", "(", "-", "1", ")", "\n", "\n", "", "tgt_sent_log_scores", "=", "tgt_sent_log_scores", "*", "(", "1.", "-", "torch", ".", "eq", "(", "tgt_sents_var_sos_omitted", ",", "0", ")", ".", "float", "(", ")", ")", "# 0 is pad", "\n", "\n", "# (batch_size)", "\n", "tgt_sent_log_scores", "=", "tgt_sent_log_scores", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n", "return", "tgt_sent_log_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step": [[177, 195], ["seq2seq.Seq2SeqModel.decoder_lstm", "seq2seq.Seq2SeqModel.dot_prod_attention", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "torch.tanh", "seq2seq.Seq2SeqModel.dropout", "seq2seq.Seq2SeqModel.readout", "seq2seq.Seq2SeqModel.att_vec_linear", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.dot_prod_attention"], ["", "def", "step", "(", "self", ",", "x", ",", "h_tm1", ",", "src_encodings", ",", "src_encodings_att_linear", ",", "src_sent_masks", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        a single LSTM decoding step\n        \"\"\"", "\n", "# h_t: (batch_size, hidden_size)", "\n", "h_t", ",", "cell_t", "=", "self", ".", "decoder_lstm", "(", "x", ",", "h_tm1", ")", "\n", "\n", "ctx_t", ",", "alpha_t", "=", "Seq2SeqModel", ".", "dot_prod_attention", "(", "h_t", ",", "\n", "src_encodings", ",", "src_encodings_att_linear", ",", "\n", "mask", "=", "src_sent_masks", ")", "\n", "\n", "att_t", "=", "torch", ".", "tanh", "(", "self", ".", "att_vec_linear", "(", "torch", ".", "cat", "(", "[", "h_t", ",", "ctx_t", "]", ",", "1", ")", ")", ")", "# E.q. (5)", "\n", "att_t", "=", "self", ".", "dropout", "(", "att_t", ")", "\n", "\n", "# (batch_size, tgt_vocab_size)", "\n", "score_t", "=", "self", ".", "readout", "(", "att_t", ")", "# E.q. (6)", "\n", "\n", "return", "(", "h_t", ",", "cell_t", ")", ",", "att_t", ",", "score_t", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.forward": [[196, 212], ["seq2seq.Seq2SeqModel.encode", "seq2seq.Seq2SeqModel.init_decoder_state", "seq2seq.Seq2SeqModel.decode", "seq2seq.Seq2SeqModel.score_decoding_results"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.decode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.score_decoding_results"], ["", "def", "forward", "(", "self", ",", "src_sents_var", ",", "src_sents_len", ",", "tgt_sents_var", ")", ":", "\n", "        ", "\"\"\"\n        encode source sequence and compute the decoding log likelihood\n        :param src_sents_var: Variable(src_sent_len, batch_size)\n        :param src_sents_len: list[int]\n        :param tgt_sents_var: Variable(tgt_sent_len, batch_size)\n        :return:\n            tgt_token_scores: Variable(tgt_sent_len, batch_size, tgt_vocab_size)\n        \"\"\"", "\n", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "src_sents_var", ",", "src_sents_len", ")", "\n", "dec_init_vec", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "tgt_token_logits", "=", "self", ".", "decode", "(", "src_encodings", ",", "src_sents_len", ",", "dec_init_vec", ",", "tgt_sents_var", ")", "\n", "tgt_sent_log_scores", "=", "self", ".", "score_decoding_results", "(", "tgt_token_logits", ",", "tgt_sents_var", ")", "\n", "\n", "return", "tgt_sent_log_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.dot_prod_attention": [[213, 232], ["torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.softmax.data.masked_fill_", "torch.softmax.size", "torch.softmax.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "h_t.unsqueeze", "float", "torch.softmax.view"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "@", "staticmethod", "\n", "def", "dot_prod_attention", "(", "h_t", ",", "src_encoding", ",", "src_encoding_att_linear", ",", "mask", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        :param h_t: (batch_size, hidden_size)\n        :param src_encoding: (batch_size, src_sent_len, hidden_size * 2)\n        :param src_encoding_att_linear: (batch_size, src_sent_len, hidden_size)\n        :param mask: (batch_size, src_sent_len)\n        \"\"\"", "\n", "# (batch_size, src_sent_len)", "\n", "att_weight", "=", "torch", ".", "bmm", "(", "src_encoding_att_linear", ",", "h_t", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "            ", "att_weight", ".", "data", ".", "masked_fill_", "(", "mask", ",", "-", "float", "(", "'inf'", ")", ")", "\n", "", "att_weight", "=", "F", ".", "softmax", "(", "att_weight", ",", "dim", "=", "-", "1", ")", "\n", "\n", "att_view", "=", "(", "att_weight", ".", "size", "(", "0", ")", ",", "1", ",", "att_weight", ".", "size", "(", "1", ")", ")", "\n", "# (batch_size, hidden_size)", "\n", "ctx_vec", "=", "torch", ".", "bmm", "(", "att_weight", ".", "view", "(", "*", "att_view", ")", ",", "src_encoding", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "return", "ctx_vec", ",", "att_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.sample": [[233, 239], ["model.nn_utils.to_input_variable", "seq2seq.Seq2SeqModel.sample_from_variable", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable"], ["", "def", "sample", "(", "self", ",", "src_sents", ",", "sample_size", ")", ":", "\n", "        ", "src_sents_len", "=", "[", "len", "(", "src_sent", ")", "for", "src_sent", "in", "src_sents", "]", "\n", "# Variable: (src_sent_len, batch_size)", "\n", "src_sents_var", "=", "nn_utils", ".", "to_input_variable", "(", "src_sents", ",", "self", ".", "vocab", ".", "src", ",", "\n", "cuda", "=", "self", ".", "cuda", ",", "training", "=", "False", ")", "\n", "return", "self", ".", "sample_from_variable", "(", "src_sents_var", ",", "src_sents_len", ",", "sample_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.sample_from_src_variable": [[240, 250], ["model.nn_utils.length_array_to_mask_tensor", "seq2seq.Seq2SeqModel.encode", "seq2seq.Seq2SeqModel.init_decoder_state", "seq2seq.Seq2SeqModel.sample_from_src_encoding", "list", "itertools.chain.from_iterable"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.sample_from_src_encoding"], ["", "def", "sample_from_src_variable", "(", "self", ",", "src_sents_var", ",", "src_sents_len", ",", "sample_size", ")", ":", "\n", "# (batch_size * sample_size, src_sent_len)", "\n", "        ", "src_sent_masks", "=", "nn_utils", ".", "length_array_to_mask_tensor", "(", "\n", "list", "(", "chain", ".", "from_iterable", "(", "[", "l", "]", "*", "sample_size", "for", "l", "in", "src_sents_len", ")", ")", ",", "\n", "cuda", "=", "self", ".", "cuda", ")", "\n", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "src_sents_var", ",", "src_sents_len", ")", "\n", "dec_init_vec", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "\n", "return", "self", ".", "sample_from_src_encoding", "(", "src_encodings", ",", "dec_init_vec", ",", "sample_size", ",", "src_sent_masks", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.sample_from_src_encoding": [[251, 343], ["dec_init_state.repeat().view.repeat().view.repeat().view", "dec_init_cell.repeat().view.repeat().view.repeat().view", "src_encodings.permute.permute.repeat().view", "src_encodings.permute.permute.permute", "seq2seq.Seq2SeqModel.att_src_linear", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "torch.stack", "dec_init_vec[].size", "src_encodings.permute.permute.size", "src_encodings.permute.permute.size", "new_float_tensor().zero_", "new_long_tensor", "seq2seq.Seq2SeqModel.tgt_embed", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "seq2seq.Seq2SeqModel.step", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.multinomial().detach", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.gather", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "torch.log().squeeze", "y_t.squeeze.squeeze.squeeze", "enumerate", "samples_var.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "torch.stack.append", "all", "dec_init_state.repeat().view.repeat().view.repeat", "dec_init_cell.repeat().view.repeat().view.repeat", "src_encodings.permute.permute.repeat", "xrange", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "new_float_tensor", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "torch.log", "y_t.squeeze.squeeze.cpu", "torch.autograd.Variable.append", "torch.autograd.Variable.append", "torch.autograd.Variable.append", "torch.autograd.Variable.append", "samples[].append", "torch.autograd.Variable.append", "torch.autograd.Variable.append", "torch.autograd.Variable.append", "torch.autograd.Variable.append", "new_float_tensor", "xrange"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "sample_from_src_encoding", "(", "self", ",", "src_encodings", ",", "dec_init_vec", ",", "sample_size", ",", "decode_max_time_step", ",", "src_sent_masks", "=", "None", ")", ":", "\n", "        ", "src_sents_num", "=", "dec_init_vec", "[", "0", "]", ".", "size", "(", "0", ")", "*", "sample_size", "\n", "\n", "# tensor constructors", "\n", "new_float_tensor", "=", "src_encodings", ".", "data", ".", "new", "\n", "if", "self", ".", "cuda", ":", "\n", "            ", "new_long_tensor", "=", "torch", ".", "cuda", ".", "LongTensor", "\n", "", "else", ":", "\n", "            ", "new_long_tensor", "=", "torch", ".", "LongTensor", "\n", "\n", "# (batch_size * sample_size, hidden_size * 2)", "\n", "", "dec_init_state", ",", "dec_init_cell", "=", "dec_init_vec", "\n", "dec_init_state", "=", "dec_init_state", ".", "repeat", "(", "1", ",", "sample_size", ")", ".", "view", "(", "src_sents_num", ",", "-", "1", ")", "\n", "dec_init_cell", "=", "dec_init_cell", ".", "repeat", "(", "1", ",", "sample_size", ")", ".", "view", "(", "src_sents_num", ",", "-", "1", ")", "\n", "h_tm1", "=", "(", "dec_init_state", ",", "dec_init_cell", ")", "\n", "\n", "# (query_len, batch_size * sample_size, hidden_size * 2)", "\n", "src_encodings", "=", "src_encodings", ".", "repeat", "(", "1", ",", "1", ",", "sample_size", ")", ".", "view", "(", "src_encodings", ".", "size", "(", "0", ")", ",", "src_sents_num", ",", "\n", "src_encodings", ".", "size", "(", "2", ")", ")", "\n", "# (batch_size * sample_size, query_len, hidden_size * 2)", "\n", "src_encodings", "=", "src_encodings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "\n", "att_tm1", "=", "Variable", "(", "new_float_tensor", "(", "src_sents_num", ",", "self", ".", "hidden_size", ")", ".", "zero_", "(", ")", ")", "\n", "y_0", "=", "Variable", "(", "new_long_tensor", "(", "[", "self", ".", "tgt_vocab", "[", "'<s>'", "]", "for", "_", "in", "xrange", "(", "src_sents_num", ")", "]", ")", ")", "\n", "\n", "eos_wid", "=", "self", ".", "tgt_vocab", "[", "'</s>'", "]", "\n", "\n", "samples_var", "=", "[", "y_0", "]", "\n", "samples", "=", "[", "[", "'<s>'", "]", "for", "_", "in", "xrange", "(", "src_sents_num", ")", "]", "\n", "samples_len", "=", "[", "0", "]", "*", "src_sents_num", "\n", "sample_scores", "=", "[", "]", "\n", "t", "=", "0", "\n", "while", "t", "<", "decode_max_time_step", ":", "\n", "            ", "t", "+=", "1", "\n", "\n", "# (sample_size)", "\n", "y_tm1", "=", "samples_var", "[", "-", "1", "]", "\n", "\n", "y_tm1_embed", "=", "self", ".", "tgt_embed", "(", "y_tm1", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "y_tm1_embed", ",", "att_tm1", "]", ",", "1", ")", "\n", "\n", "# h_t: (batch_size * sample_size, hidden_size)", "\n", "(", "h_t", ",", "cell_t", ")", ",", "att_t", ",", "score_t", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "\n", "src_encodings", ",", "src_encodings_att_linear", ",", "\n", "src_sent_masks", "=", "src_sent_masks", ")", "\n", "\n", "# (batch_size * sample_size, tgt_vocab_size)", "\n", "p_t", "=", "F", ".", "softmax", "(", "score_t", ")", "\n", "# (batch_size * sample_size, 1)", "\n", "y_t", "=", "torch", ".", "multinomial", "(", "p_t", ",", "num_samples", "=", "1", ")", ".", "detach", "(", ")", "\n", "# (batch_size * sample_size, 1)", "\n", "p_y_t", "=", "torch", ".", "gather", "(", "p_t", ",", "1", ",", "y_t", ")", "\n", "log_y_t", "=", "torch", ".", "log", "(", "p_y_t", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "y_t", "=", "y_t", ".", "squeeze", "(", "1", ")", "\n", "\n", "# generate loss mask", "\n", "mask_t", "=", "[", "]", "\n", "is_valid_mask", "=", "False", "\n", "for", "sample_id", ",", "y", "in", "enumerate", "(", "y_t", ".", "cpu", "(", ")", ".", "data", ")", ":", "\n", "                ", "if", "samples_len", "[", "sample_id", "]", "==", "0", ":", "\n", "                    ", "mask_t", ".", "append", "(", "1.", ")", "\n", "word", "=", "self", ".", "tgt_vocab", ".", "id2word", "[", "y", "]", "\n", "samples", "[", "sample_id", "]", ".", "append", "(", "word", ")", "\n", "if", "y", "==", "eos_wid", ":", "\n", "                        ", "samples_len", "[", "sample_id", "]", "=", "t", "+", "1", "\n", "", "", "else", ":", "\n", "                    ", "mask_t", ".", "append", "(", "0.", ")", "\n", "is_valid_mask", "=", "True", "\n", "\n", "", "", "if", "is_valid_mask", ":", "\n", "                ", "mask_t", "=", "Variable", "(", "new_float_tensor", "(", "mask_t", ")", ")", "\n", "log_y_t", "=", "log_y_t", "*", "mask_t", "\n", "\n", "", "samples_var", ".", "append", "(", "y_t", ")", "\n", "sample_scores", ".", "append", "(", "log_y_t", ")", "\n", "\n", "if", "all", "(", "l", ">", "0", "for", "l", "in", "samples_len", ")", ":", "\n", "                ", "break", "\n", "\n", "", "att_tm1", "=", "att_t", "\n", "h_tm1", "=", "h_t", ",", "cell_t", "\n", "\n", "# (max_sample_len, batch_size * sample_size)", "\n", "", "sample_scores", "=", "torch", ".", "stack", "(", "sample_scores", ")", "\n", "\n", "# finally, let's remove <s> and </s> from the samples!", "\n", "samples", "=", "[", "sample", "[", "1", ":", "-", "1", "]", "for", "sample", "in", "samples", "]", "\n", "\n", "return", "samples", ",", "sample_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.beam_search": [[344, 442], ["model.nn_utils.to_input_variable", "seq2seq.Seq2SeqModel.encode", "src_encodings.permute.permute.permute", "seq2seq.Seq2SeqModel.att_src_linear", "seq2seq.Seq2SeqModel.init_decoder_state", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "len", "sorted", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "att_tm1.cuda.cuda.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "torch.autograd.Variable.cuda", "len", "src_encodings.permute.permute.expand", "seq2seq.Seq2SeqModel.expand", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "seq2seq.Seq2SeqModel.tgt_embed", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "seq2seq.Seq2SeqModel.step", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "torch.topk", "zip", "new_long_tensor", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "len", "enumerate", "zip", "len", "len", "src_encodings.permute.permute.size", "src_encodings.permute.permute.size", "seq2seq.Seq2SeqModel.size", "seq2seq.Seq2SeqModel.size", "new_long_tensor", "len", "len", "new_float_tensor", "prev_hyp_ids.cpu", "word_ids.cpu", "top_new_hyp_scores.cpu", "completed_hypotheses.append", "completed_hypothesis_scores.append", "new_hypotheses.append", "new_long_tensor.append", "new_hyp_scores.append", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze().expand_as", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze", "torch.autograd.Variable.unsqueeze"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.encode", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.init_decoder_state", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.seq2seq.Seq2SeqModel.step", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "def", "beam_search", "(", "self", ",", "src_sents", ",", "decode_max_time_step", ",", "beam_size", "=", "5", ",", "to_word", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        given a not-batched source, sentence perform beam search to find the n-best\n        :param src_sent: List[word_id], encoded source sentence\n        :return: list[list[word_id]] top-k predicted natural language sentence in the beam\n        \"\"\"", "\n", "src_sents_var", "=", "nn_utils", ".", "to_input_variable", "(", "src_sents", ",", "self", ".", "src_vocab", ",", "\n", "cuda", "=", "self", ".", "cuda", ",", "training", "=", "False", ",", "append_boundary_sym", "=", "False", ")", "\n", "\n", "#TODO(junxian): check if src_sents_var(src_seq_length, embed_size) is ok", "\n", "src_encodings", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "encode", "(", "src_sents_var", ",", "[", "len", "(", "src_sents", "[", "0", "]", ")", "]", ")", "\n", "# (1, query_len, hidden_size * 2)", "\n", "src_encodings", "=", "src_encodings", ".", "permute", "(", "1", ",", "0", ",", "2", ")", "\n", "src_encodings_att_linear", "=", "self", ".", "att_src_linear", "(", "src_encodings", ")", "\n", "h_tm1", "=", "self", ".", "init_decoder_state", "(", "last_state", ",", "last_cell", ")", "\n", "\n", "# tensor constructors", "\n", "new_float_tensor", "=", "src_encodings", ".", "data", ".", "new", "\n", "if", "self", ".", "cuda", ":", "\n", "            ", "new_long_tensor", "=", "torch", ".", "cuda", ".", "LongTensor", "\n", "", "else", ":", "\n", "            ", "new_long_tensor", "=", "torch", ".", "LongTensor", "\n", "\n", "", "att_tm1", "=", "Variable", "(", "torch", ".", "zeros", "(", "1", ",", "self", ".", "hidden_size", ")", ",", "volatile", "=", "True", ")", "\n", "hyp_scores", "=", "Variable", "(", "torch", ".", "zeros", "(", "1", ")", ",", "volatile", "=", "True", ")", "\n", "if", "self", ".", "cuda", ":", "\n", "            ", "att_tm1", "=", "att_tm1", ".", "cuda", "(", ")", "\n", "hyp_scores", "=", "hyp_scores", ".", "cuda", "(", ")", "\n", "\n", "", "eos_id", "=", "self", ".", "tgt_vocab", "[", "'</s>'", "]", "\n", "bos_id", "=", "self", ".", "tgt_vocab", "[", "'<s>'", "]", "\n", "tgt_vocab_size", "=", "len", "(", "self", ".", "tgt_vocab", ")", "\n", "\n", "hypotheses", "=", "[", "[", "bos_id", "]", "]", "\n", "completed_hypotheses", "=", "[", "]", "\n", "completed_hypothesis_scores", "=", "[", "]", "\n", "\n", "t", "=", "0", "\n", "while", "len", "(", "completed_hypotheses", ")", "<", "beam_size", "and", "t", "<", "decode_max_time_step", ":", "\n", "            ", "t", "+=", "1", "\n", "hyp_num", "=", "len", "(", "hypotheses", ")", "\n", "\n", "expanded_src_encodings", "=", "src_encodings", ".", "expand", "(", "hyp_num", ",", "src_encodings", ".", "size", "(", "1", ")", ",", "src_encodings", ".", "size", "(", "2", ")", ")", "\n", "expanded_src_encodings_att_linear", "=", "src_encodings_att_linear", ".", "expand", "(", "hyp_num", ",", "src_encodings_att_linear", ".", "size", "(", "1", ")", ",", "src_encodings_att_linear", ".", "size", "(", "2", ")", ")", "\n", "\n", "y_tm1", "=", "Variable", "(", "new_long_tensor", "(", "[", "hyp", "[", "-", "1", "]", "for", "hyp", "in", "hypotheses", "]", ")", ",", "volatile", "=", "True", ")", "\n", "y_tm1_embed", "=", "self", ".", "tgt_embed", "(", "y_tm1", ")", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "[", "y_tm1_embed", ",", "att_tm1", "]", ",", "1", ")", "\n", "\n", "# h_t: (hyp_num, hidden_size)", "\n", "(", "h_t", ",", "cell_t", ")", ",", "att_t", ",", "score_t", "=", "self", ".", "step", "(", "x", ",", "h_tm1", ",", "\n", "expanded_src_encodings", ",", "expanded_src_encodings_att_linear", ",", "\n", "src_sent_masks", "=", "None", ")", "\n", "\n", "p_t", "=", "F", ".", "log_softmax", "(", "score_t", ")", "\n", "\n", "live_hyp_num", "=", "beam_size", "-", "len", "(", "completed_hypotheses", ")", "\n", "new_hyp_scores", "=", "(", "hyp_scores", ".", "unsqueeze", "(", "1", ")", ".", "expand_as", "(", "p_t", ")", "+", "p_t", ")", ".", "view", "(", "-", "1", ")", "\n", "top_new_hyp_scores", ",", "top_new_hyp_pos", "=", "torch", ".", "topk", "(", "new_hyp_scores", ",", "k", "=", "live_hyp_num", ")", "\n", "prev_hyp_ids", "=", "top_new_hyp_pos", "/", "tgt_vocab_size", "\n", "word_ids", "=", "top_new_hyp_pos", "%", "tgt_vocab_size", "\n", "\n", "new_hypotheses", "=", "[", "]", "\n", "\n", "live_hyp_ids", "=", "[", "]", "\n", "new_hyp_scores", "=", "[", "]", "\n", "for", "prev_hyp_id", ",", "word_id", ",", "new_hyp_score", "in", "zip", "(", "prev_hyp_ids", ".", "cpu", "(", ")", ".", "data", ",", "word_ids", ".", "cpu", "(", ")", ".", "data", ",", "top_new_hyp_scores", ".", "cpu", "(", ")", ".", "data", ")", ":", "\n", "                ", "hyp_tgt_words", "=", "hypotheses", "[", "prev_hyp_id", "]", "+", "[", "word_id", "]", "\n", "if", "word_id", "==", "eos_id", ":", "\n", "                    ", "completed_hypotheses", ".", "append", "(", "hyp_tgt_words", "[", "1", ":", "-", "1", "]", ")", "# remove <s> and </s> in completed hypothesis", "\n", "completed_hypothesis_scores", ".", "append", "(", "new_hyp_score", ")", "\n", "", "else", ":", "\n", "                    ", "new_hypotheses", ".", "append", "(", "hyp_tgt_words", ")", "\n", "live_hyp_ids", ".", "append", "(", "prev_hyp_id", ")", "\n", "new_hyp_scores", ".", "append", "(", "new_hyp_score", ")", "\n", "\n", "", "", "if", "len", "(", "completed_hypotheses", ")", "==", "beam_size", ":", "\n", "                ", "break", "\n", "\n", "", "live_hyp_ids", "=", "new_long_tensor", "(", "live_hyp_ids", ")", "\n", "h_tm1", "=", "(", "h_t", "[", "live_hyp_ids", "]", ",", "cell_t", "[", "live_hyp_ids", "]", ")", "\n", "att_tm1", "=", "att_t", "[", "live_hyp_ids", "]", "\n", "\n", "hyp_scores", "=", "Variable", "(", "new_float_tensor", "(", "new_hyp_scores", ")", ",", "volatile", "=", "True", ")", "# new_hyp_scores[live_hyp_ids]", "\n", "hypotheses", "=", "new_hypotheses", "\n", "\n", "", "if", "len", "(", "completed_hypotheses", ")", "==", "0", ":", "\n", "            ", "completed_hypotheses", "=", "[", "hypotheses", "[", "0", "]", "[", "1", ":", "-", "1", "]", "]", "# remove <s> and </s> in completed hypothesis", "\n", "completed_hypothesis_scores", "=", "[", "0.0", "]", "\n", "\n", "", "if", "to_word", ":", "\n", "            ", "for", "i", ",", "hyp", "in", "enumerate", "(", "completed_hypotheses", ")", ":", "\n", "                ", "completed_hypotheses", "[", "i", "]", "=", "[", "self", ".", "tgt_vocab", ".", "id2word", "[", "w", "]", "for", "w", "in", "hyp", "]", "\n", "\n", "", "", "ranked_hypotheses", "=", "sorted", "(", "zip", "(", "completed_hypotheses", ",", "completed_hypothesis_scores", ")", ",", "key", "=", "lambda", "x", ":", "x", "[", "1", "]", ",", "reverse", "=", "True", ")", "\n", "\n", "return", "[", "hyp", "for", "hyp", ",", "score", "in", "ranked_hypotheses", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.__init__": [[11, 13], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.__call__": [[14, 16], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "code_list", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval": [[17, 19], ["None"], "methods", ["None"], ["", "def", "eval", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.UniformPrior.__init__": [[22, 24], ["prior.Prior.__init__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "**", "kwargs", ")", ":", "\n", "        ", "super", "(", "UniformPrior", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.UniformPrior.__call__": [[25, 27], ["None"], "methods", ["None"], ["", "def", "__call__", "(", "self", ",", "code_list", ")", ":", "\n", "        ", "return", "[", "0.", "for", "code", "in", "code_list", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.LSTMPrior.__init__": [[30, 35], ["model.neural_lm.LSTMLanguageModel.__init__"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "vocab", ",", "transition_system", ")", ":", "\n", "        ", "super", "(", "LSTMPrior", ",", "self", ")", ".", "__init__", "(", "vocab", ",", "args", ".", "embed_size", ",", "args", ".", "hidden_size", ",", "args", ".", "dropout", ")", "\n", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "transition_system", "=", "transition_system", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.LSTMPrior.__call__": [[36, 43], ["model.nn_utils.to_input_variable", "prior.LSTMPrior.transition_system.tokenize_code", "prior.LSTMPrior.forward"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.forward"], ["", "def", "__call__", "(", "self", ",", "code_list", ")", ":", "\n", "# we assume the code is generated from astor and therefore has an astor style!", "\n", "        ", "code_tokens", "=", "[", "self", ".", "transition_system", ".", "tokenize_code", "(", "code", ",", "mode", "=", "'canonicalize'", ")", "for", "code", "in", "code_list", "]", "\n", "code_var", "=", "nn_utils", ".", "to_input_variable", "(", "code_tokens", ",", "self", ".", "vocab", ",", "\n", "cuda", "=", "self", ".", "args", ".", "cuda", ",", "append_boundary_sym", "=", "True", ")", "\n", "\n", "return", "-", "self", ".", "forward", "(", "code_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.LSTMPrior.load": [[44, 53], ["torch.load", "prior.LSTMPrior", "LSTMPrior.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load"], ["", "@", "classmethod", "\n", "def", "load", "(", "self", ",", "model_path", ",", "transition_system", "=", "None", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "params", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "params", "[", "'args'", "]", ".", "cuda", "=", "cuda", "\n", "model", "=", "LSTMPrior", "(", "params", "[", "'args'", "]", ",", "params", "[", "'vocab'", "]", ",", "\n", "transition_system", "if", "transition_system", "else", "params", "[", "'transition_system'", "]", ")", "\n", "model", ".", "load_state_dict", "(", "params", "[", "'state_dict'", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.LSTMPrior.save": [[54, 67], ["os.path.dirname", "torch.save", "os.path.exists", "os.makedirs", "prior.LSTMPrior.state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "dirname", "(", "file_path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_name", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_name", ")", "\n", "\n", "", "params", "=", "{", "\n", "'args'", ":", "self", ".", "args", ",", "\n", "'vocab'", ":", "self", ".", "vocab", ",", "\n", "'state_dict'", ":", "self", ".", "state_dict", "(", ")", ",", "\n", "'transition_system'", ":", "self", ".", "transition_system", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "params", ",", "file_path", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.LabelSmoothing.__init__": [[168, 181], ["torch.Module.__init__", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.KLDivLoss", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "torch.zeros().fill_", "nn_utils.LabelSmoothing.register_buffer", "float", "torch.zeros().fill_.unsqueeze", "torch.zeros().fill_.unsqueeze", "torch.zeros().fill_.unsqueeze", "torch.zeros().fill_.unsqueeze", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "torch.zeros", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["def", "__init__", "(", "self", ",", "smoothing", ",", "tgt_vocab_size", ",", "ignore_indices", "=", "None", ")", ":", "\n", "        ", "if", "ignore_indices", "is", "None", ":", "ignore_indices", "=", "[", "]", "\n", "\n", "super", "(", "LabelSmoothing", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "criterion", "=", "nn", ".", "KLDivLoss", "(", "reduction", "=", "'none'", ")", "\n", "smoothing_value", "=", "smoothing", "/", "float", "(", "tgt_vocab_size", "-", "1", "-", "len", "(", "ignore_indices", ")", ")", "\n", "one_hot", "=", "torch", ".", "zeros", "(", "(", "tgt_vocab_size", ",", ")", ")", ".", "fill_", "(", "smoothing_value", ")", "\n", "for", "idx", "in", "ignore_indices", ":", "\n", "            ", "one_hot", "[", "idx", "]", "=", "0.", "\n", "\n", "", "self", ".", "confidence", "=", "1.0", "-", "smoothing", "\n", "self", ".", "register_buffer", "(", "'one_hot'", ",", "one_hot", ".", "unsqueeze", "(", "0", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.LabelSmoothing.forward": [[182, 192], ["torch.autograd.Variable().repeat", "torch.autograd.Variable().repeat", "torch.autograd.Variable().repeat", "torch.autograd.Variable().repeat", "torch.autograd.Variable().repeat.scatter_", "nn_utils.LabelSmoothing.criterion().sum", "target.unsqueeze", "list", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "nn_utils.LabelSmoothing.criterion", "model_prob.size"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "def", "forward", "(", "self", ",", "model_prob", ",", "target", ")", ":", "\n", "# (batch_size, *, tgt_vocab_size)", "\n", "        ", "dim", "=", "list", "(", "model_prob", ".", "size", "(", ")", ")", "[", ":", "-", "1", "]", "+", "[", "1", "]", "\n", "true_dist", "=", "Variable", "(", "self", ".", "one_hot", ",", "requires_grad", "=", "False", ")", ".", "repeat", "(", "*", "dim", ")", "\n", "true_dist", ".", "scatter_", "(", "-", "1", ",", "target", ".", "unsqueeze", "(", "-", "1", ")", ",", "self", ".", "confidence", ")", "\n", "# true_dist = model_prob.data.clone()", "\n", "# true_dist.fill_(self.smoothing / (model_prob.size(1) - 1))  # FIXME: no label smoothing for <pad> <s> and </s>", "\n", "# true_dist.scatter_(1, target.data.unsqueeze(1), self.confidence)", "\n", "\n", "return", "self", ".", "criterion", "(", "model_prob", ",", "true_dist", ")", ".", "sum", "(", "dim", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.FeedForward.__init__": [[197, 218], ["torch.Module.__init__", "zip", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "torch.ModuleList", "isinstance", "isinstance", "isinstance", "linear_layers.append", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["def", "__init__", "(", "self", ",", "input_dim", ",", "num_layers", ",", "hidden_dims", ",", "activations", ",", "dropout", ")", ":", "\n", "        ", "super", "(", "FeedForward", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "not", "isinstance", "(", "hidden_dims", ",", "list", ")", ":", "\n", "            ", "hidden_dims", "=", "[", "hidden_dims", "]", "*", "num_layers", "# type: ignore", "\n", "", "if", "not", "isinstance", "(", "activations", ",", "list", ")", ":", "\n", "            ", "activations", "=", "[", "activations", "]", "*", "num_layers", "# type: ignore", "\n", "", "if", "not", "isinstance", "(", "dropout", ",", "list", ")", ":", "\n", "            ", "dropout", "=", "[", "dropout", "]", "*", "num_layers", "# type: ignore", "\n", "\n", "", "self", ".", "activations", "=", "activations", "\n", "input_dims", "=", "[", "input_dim", "]", "+", "hidden_dims", "[", ":", "-", "1", "]", "\n", "linear_layers", "=", "[", "]", "\n", "for", "layer_input_dim", ",", "layer_output_dim", "in", "zip", "(", "input_dims", ",", "hidden_dims", ")", ":", "\n", "            ", "linear_layers", ".", "append", "(", "nn", ".", "Linear", "(", "layer_input_dim", ",", "layer_output_dim", ")", ")", "\n", "\n", "", "self", ".", "linear_layers", "=", "nn", ".", "ModuleList", "(", "linear_layers", ")", "\n", "dropout_layers", "=", "[", "nn", ".", "Dropout", "(", "p", "=", "value", ")", "for", "value", "in", "dropout", "]", "\n", "self", ".", "dropout", "=", "nn", ".", "ModuleList", "(", "dropout_layers", ")", "\n", "self", ".", "output_dim", "=", "hidden_dims", "[", "-", "1", "]", "\n", "self", ".", "input_dim", "=", "input_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.FeedForward.forward": [[219, 224], ["zip", "dropout", "activation", "layer"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "output", "=", "x", "\n", "for", "layer", ",", "activation", ",", "dropout", "in", "zip", "(", "self", ".", "linear_layers", ",", "self", ".", "activations", ",", "self", ".", "dropout", ")", ":", "\n", "            ", "output", "=", "dropout", "(", "activation", "(", "layer", "(", "output", ")", ")", ")", "\n", "", "return", "output", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.dot_prod_attention": [[14, 32], ["torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.softmax", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "torch.bmm().squeeze", "F.softmax.data.masked_fill_", "F.softmax.size", "F.softmax.size", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "h_t.unsqueeze", "float", "F.softmax.view"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["def", "dot_prod_attention", "(", "h_t", ",", "src_encoding", ",", "src_encoding_att_linear", ",", "mask", "=", "None", ")", ":", "\n", "    ", "\"\"\"\n    :param h_t: (batch_size, hidden_size)\n    :param src_encoding: (batch_size, src_sent_len, hidden_size * 2)\n    :param src_encoding_att_linear: (batch_size, src_sent_len, hidden_size)\n    :param mask: (batch_size, src_sent_len)\n    \"\"\"", "\n", "# (batch_size, src_sent_len)", "\n", "att_weight", "=", "torch", ".", "bmm", "(", "src_encoding_att_linear", ",", "h_t", ".", "unsqueeze", "(", "2", ")", ")", ".", "squeeze", "(", "2", ")", "\n", "if", "mask", "is", "not", "None", ":", "\n", "        ", "att_weight", ".", "data", ".", "masked_fill_", "(", "mask", ",", "-", "float", "(", "'inf'", ")", ")", "\n", "", "att_weight", "=", "F", ".", "softmax", "(", "att_weight", ",", "dim", "=", "-", "1", ")", "\n", "\n", "att_view", "=", "(", "att_weight", ".", "size", "(", "0", ")", ",", "1", ",", "att_weight", ".", "size", "(", "1", ")", ")", "\n", "# (batch_size, hidden_size)", "\n", "ctx_vec", "=", "torch", ".", "bmm", "(", "att_weight", ".", "view", "(", "*", "att_view", ")", ",", "src_encoding", ")", ".", "squeeze", "(", "1", ")", "\n", "\n", "return", "ctx_vec", ",", "att_weight", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.length_array_to_mask_tensor": [[34, 47], ["max", "len", "numpy.zeros", "enumerate", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor", "torch.ByteTensor.cuda"], "function", ["None"], ["", "def", "length_array_to_mask_tensor", "(", "length_array", ",", "cuda", "=", "False", ",", "valid_entry_has_mask_one", "=", "False", ")", ":", "\n", "    ", "max_len", "=", "max", "(", "length_array", ")", "\n", "batch_size", "=", "len", "(", "length_array", ")", "\n", "\n", "mask", "=", "np", ".", "zeros", "(", "(", "batch_size", ",", "max_len", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "for", "i", ",", "seq_len", "in", "enumerate", "(", "length_array", ")", ":", "\n", "        ", "if", "valid_entry_has_mask_one", ":", "\n", "            ", "mask", "[", "i", "]", "[", ":", "seq_len", "]", "=", "1", "\n", "", "else", ":", "\n", "            ", "mask", "[", "i", "]", "[", "seq_len", ":", "]", "=", "1", "\n", "\n", "", "", "mask", "=", "torch", ".", "ByteTensor", "(", "mask", ")", "\n", "return", "mask", ".", "cuda", "(", ")", "if", "cuda", "else", "mask", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.input_transpose": [[49, 62], ["max", "len", "six.moves.xrange", "sents_t.append", "len", "six.moves.xrange", "len"], "function", ["None"], ["", "def", "input_transpose", "(", "sents", ",", "pad_token", ")", ":", "\n", "    ", "\"\"\"\n    transform the input List[sequence] of size (batch_size, max_sent_len)\n    into a list of size (max_sent_len, batch_size), with proper padding\n    \"\"\"", "\n", "max_len", "=", "max", "(", "len", "(", "s", ")", "for", "s", "in", "sents", ")", "\n", "batch_size", "=", "len", "(", "sents", ")", "\n", "\n", "sents_t", "=", "[", "]", "\n", "for", "i", "in", "xrange", "(", "max_len", ")", ":", "\n", "        ", "sents_t", ".", "append", "(", "[", "sents", "[", "k", "]", "[", "i", "]", "if", "len", "(", "sents", "[", "k", "]", ")", ">", "i", "else", "pad_token", "for", "k", "in", "xrange", "(", "batch_size", ")", "]", ")", "\n", "\n", "", "return", "sents_t", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.word2id": [[64, 69], ["type"], "function", ["None"], ["", "def", "word2id", "(", "sents", ",", "vocab", ")", ":", "\n", "    ", "if", "type", "(", "sents", "[", "0", "]", ")", "==", "list", ":", "\n", "        ", "return", "[", "[", "vocab", "[", "w", "]", "for", "w", "in", "s", "]", "for", "s", "in", "sents", "]", "\n", "", "else", ":", "\n", "        ", "return", "[", "vocab", "[", "w", "]", "for", "w", "in", "sents", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.id2word": [[71, 76], ["type"], "function", ["None"], ["", "", "def", "id2word", "(", "sents", ",", "vocab", ")", ":", "\n", "    ", "if", "type", "(", "sents", "[", "0", "]", ")", "==", "list", ":", "\n", "        ", "return", "[", "[", "vocab", ".", "id2word", "[", "w", "]", "for", "w", "in", "s", "]", "for", "s", "in", "sents", "]", "\n", "", "else", ":", "\n", "        ", "return", "[", "vocab", ".", "id2word", "[", "w", "]", "for", "w", "in", "sents", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable": [[78, 97], ["nn_utils.word2id", "nn_utils.input_transpose", "torch.autograd.Variable", "torch.autograd.Variable.cuda", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.autograd.Variable", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.word2id", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.input_transpose"], ["", "", "def", "to_input_variable", "(", "sequences", ",", "vocab", ",", "cuda", "=", "False", ",", "training", "=", "True", ",", "append_boundary_sym", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    given a list of sequences,\n    return a tensor of shape (max_sent_len, batch_size)\n    \"\"\"", "\n", "if", "append_boundary_sym", ":", "\n", "        ", "sequences", "=", "[", "[", "'<s>'", "]", "+", "seq", "+", "[", "'</s>'", "]", "for", "seq", "in", "sequences", "]", "\n", "\n", "", "word_ids", "=", "word2id", "(", "sequences", ",", "vocab", ")", "\n", "sents_t", "=", "input_transpose", "(", "word_ids", ",", "vocab", "[", "'<pad>'", "]", ")", "\n", "if", "training", ":", "\n", "        ", "sents_var", "=", "Variable", "(", "torch", ".", "LongTensor", "(", "sents_t", ")", ",", "requires_grad", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "sents_var", "=", "Variable", "(", "torch", ".", "LongTensor", "(", "sents_t", ")", ",", "requires_grad", "=", "False", ")", "\n", "", "", "if", "cuda", ":", "\n", "        ", "sents_var", "=", "sents_var", ".", "cuda", "(", ")", "\n", "\n", "", "return", "sents_var", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.variable_constr": [[99, 101], ["torch.autograd.Variable", "torch.autograd.Variable", "torch.cuda.x", "torch.cuda.x", "torch.cuda.x", "torch.cuda.x", "torch.x", "torch.x", "torch.x", "torch.x"], "function", ["None"], ["", "def", "variable_constr", "(", "x", ",", "v", ",", "cuda", "=", "False", ")", ":", "\n", "    ", "return", "Variable", "(", "torch", ".", "cuda", ".", "x", "(", "v", ")", ")", "if", "cuda", "else", "Variable", "(", "torch", ".", "x", "(", "v", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.batch_iter": [[103, 114], ["numpy.arange", "int", "six.moves.xrange", "len", "numpy.random.shuffle", "numpy.ceil", "len", "float"], "function", ["None"], ["", "def", "batch_iter", "(", "examples", ",", "batch_size", ",", "shuffle", "=", "False", ")", ":", "\n", "    ", "index_arr", "=", "np", ".", "arange", "(", "len", "(", "examples", ")", ")", "\n", "if", "shuffle", ":", "\n", "        ", "np", ".", "random", ".", "shuffle", "(", "index_arr", ")", "\n", "\n", "", "batch_num", "=", "int", "(", "np", ".", "ceil", "(", "len", "(", "examples", ")", "/", "float", "(", "batch_size", ")", ")", ")", "\n", "for", "batch_id", "in", "xrange", "(", "batch_num", ")", ":", "\n", "        ", "batch_ids", "=", "index_arr", "[", "batch_size", "*", "batch_id", ":", "batch_size", "*", "(", "batch_id", "+", "1", ")", "]", "\n", "batch_examples", "=", "[", "examples", "[", "i", "]", "for", "i", "in", "batch_ids", "]", "\n", "\n", "yield", "batch_examples", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.isnan": [[116, 119], ["data.cpu().numpy.cpu().numpy", "numpy.isnan().any", "numpy.isinf().any", "data.cpu().numpy.cpu", "numpy.isnan", "numpy.isinf"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.isnan"], ["", "", "def", "isnan", "(", "data", ")", ":", "\n", "    ", "data", "=", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "return", "np", ".", "isnan", "(", "data", ")", ".", "any", "(", ")", "or", "np", ".", "isinf", "(", "data", ")", ".", "any", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.log_sum_exp": [[121, 145], ["torch.max", "torch.max", "torch.max", "torch.max", "inputs.view.view", "outputs.squeeze.squeeze"], "function", ["None"], ["", "def", "log_sum_exp", "(", "inputs", ",", "dim", "=", "None", ",", "keepdim", "=", "False", ")", ":", "\n", "    ", "\"\"\"Numerically stable logsumexp.\n       source: https://github.com/pytorch/pytorch/issues/2591\n\n    Args:\n        inputs: A Variable with any shape.\n        dim: An integer.\n        keepdim: A boolean.\n\n    Returns:\n        Equivalent of log(sum(exp(inputs), dim=dim, keepdim=keepdim)).\n    \"\"\"", "\n", "# For a 1-D array x (any array along a single dimension),", "\n", "# log sum exp(x) = s + log sum exp(x - s)", "\n", "# with s = max(x) being a common choice.", "\n", "\n", "if", "dim", "is", "None", ":", "\n", "        ", "inputs", "=", "inputs", ".", "view", "(", "-", "1", ")", "\n", "dim", "=", "0", "\n", "", "s", ",", "_", "=", "torch", ".", "max", "(", "inputs", ",", "dim", "=", "dim", ",", "keepdim", "=", "True", ")", "\n", "outputs", "=", "s", "+", "(", "inputs", "-", "s", ")", ".", "exp", "(", ")", ".", "sum", "(", "dim", "=", "dim", ",", "keepdim", "=", "True", ")", ".", "log", "(", ")", "\n", "if", "not", "keepdim", ":", "\n", "        ", "outputs", "=", "outputs", ".", "squeeze", "(", "dim", ")", "\n", "", "return", "outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.uniform_init": [[147, 150], ["p.data.uniform_"], "function", ["None"], ["", "def", "uniform_init", "(", "lower", ",", "upper", ",", "params", ")", ":", "\n", "    ", "for", "p", "in", "params", ":", "\n", "        ", "p", ".", "data", ".", "uniform_", "(", "lower", ",", "upper", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.glorot_init": [[152, 156], ["len", "torch.xavier_normal_", "p.data.size"], "function", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "", "def", "glorot_init", "(", "params", ")", ":", "\n", "    ", "for", "p", "in", "params", ":", "\n", "        ", "if", "len", "(", "p", ".", "data", ".", "size", "(", ")", ")", ">", "1", ":", "\n", "            ", "init", ".", "xavier_normal_", "(", "p", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.identity": [[158, 160], ["None"], "function", ["None"], ["", "", "", "def", "identity", "(", "x", ")", ":", "\n", "    ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.neural_lm.LSTMLanguageModel.__init__": [[16, 32], ["torch.Module.__init__", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.init.xavier_normal", "torch.init.xavier_normal", "torch.init.xavier_normal", "torch.init.xavier_normal", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.LSTM", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "torch.CrossEntropyLoss", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "vocab", ",", "embed_size", ",", "hidden_size", ",", "dropout", "=", "0.", ")", ":", "\n", "        ", "super", "(", "LSTMLanguageModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "vocab", "=", "vocab", "\n", "self", ".", "embed_size", "=", "embed_size", "\n", "self", ".", "hidden_size", "=", "hidden_size", "\n", "self", ".", "dropout_rate", "=", "dropout", "\n", "\n", "self", ".", "embed", "=", "nn", ".", "Embedding", "(", "len", "(", "vocab", ")", ",", "embed_size", ")", "\n", "nn", ".", "init", ".", "xavier_normal", "(", "self", ".", "embed", ".", "weight", ")", "\n", "\n", "self", ".", "lstm", "=", "nn", ".", "LSTM", "(", "embed_size", ",", "hidden_size", ")", "\n", "self", ".", "read_out", "=", "nn", ".", "Linear", "(", "hidden_size", ",", "len", "(", "vocab", ")", ")", "\n", "self", ".", "dropout", "=", "nn", ".", "Dropout", "(", "dropout", ")", "\n", "\n", "self", ".", "cross_entropy_loss", "=", "nn", ".", "CrossEntropyLoss", "(", "ignore_index", "=", "vocab", "[", "'<pad>'", "]", ",", "reduction", "=", "'none'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.neural_lm.LSTMLanguageModel.forward": [[33, 57], ["neural_lm.LSTMLanguageModel.embed", "neural_lm.LSTMLanguageModel.lstm", "neural_lm.LSTMLanguageModel.dropout", "neural_lm.LSTMLanguageModel.read_out", "neural_lm.LSTMLanguageModel.size", "neural_lm.LSTMLanguageModel.size", "neural_lm.LSTMLanguageModel.size", "neural_lm.LSTMLanguageModel.cross_entropy_loss().view", "scores.sum.sum.sum", "neural_lm.LSTMLanguageModel.cross_entropy_loss", "neural_lm.LSTMLanguageModel.view", "sent_var[].view"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.asdl.asdl_ast.AbstractSyntaxTree.size"], ["", "def", "forward", "(", "self", ",", "sent_var", ")", ":", "\n", "        ", "\"\"\"\n        :param sent_var: (sent_len, batch_size)\n        :return:\n        \"\"\"", "\n", "\n", "# (sent_len, batch_size, embed_size)", "\n", "token_embed", "=", "self", ".", "embed", "(", "sent_var", ")", "\n", "\n", "# (sent_len, batch_size, hidden_size)", "\n", "states", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "lstm", "(", "token_embed", "[", ":", "-", "1", "]", ")", "\n", "\n", "states", "=", "self", ".", "dropout", "(", "states", ")", "\n", "\n", "# (sent_len, batch_size, vocab_size)", "\n", "logits", "=", "self", ".", "read_out", "(", "states", ")", "\n", "sent_len", "=", "logits", ".", "size", "(", "0", ")", "\n", "batch_size", "=", "logits", ".", "size", "(", "1", ")", "\n", "vocab_size", "=", "logits", ".", "size", "(", "2", ")", "\n", "\n", "scores", "=", "self", ".", "cross_entropy_loss", "(", "logits", ".", "view", "(", "-", "1", ",", "vocab_size", ")", ",", "sent_var", "[", "1", ":", "]", ".", "view", "(", "-", "1", ")", ")", ".", "view", "(", "sent_len", ",", "batch_size", ")", "\n", "scores", "=", "scores", ".", "sum", "(", "dim", "=", "0", ")", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.neural_lm.LSTMLanguageModel.sample": [[58, 77], ["xrange", "neural_lm.LSTMLanguageModel.embed", "x_tm1_embed.unsqueeze.unsqueeze.unsqueeze", "neural_lm.LSTMLanguageModel.lstm", "neural_lm.LSTMLanguageModel.dropout", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "neural_lm.LSTMLanguageModel.view", "neural_lm.LSTMLanguageModel.read_out", "sample_words.append", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.LongTensor", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial", "torch.multinomial"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "sample", "(", "self", ",", "max_time_step", "=", "200", ")", ":", "\n", "        ", "\"\"\"generate one sample\"\"\"", "\n", "sample_words", "=", "[", "self", ".", "vocab", "[", "'<s>'", "]", "]", "\n", "h_tm1", "=", "None", "\n", "for", "t", "in", "xrange", "(", "max_time_step", ")", ":", "\n", "            ", "x_tm1_embed", "=", "self", ".", "embed", "(", "Variable", "(", "torch", ".", "LongTensor", "(", "[", "sample_words", "[", "-", "1", "]", "]", ")", ")", ")", "\n", "x_tm1_embed", "=", "x_tm1_embed", ".", "unsqueeze", "(", "0", ")", "\n", "h_t", ",", "(", "last_state", ",", "last_cell", ")", "=", "self", ".", "lstm", "(", "x_tm1_embed", ",", "h_tm1", ")", "\n", "h_t", "=", "self", ".", "dropout", "(", "h_t", ".", "view", "(", "-", "1", ")", ")", "\n", "p_t", "=", "F", ".", "softmax", "(", "self", ".", "read_out", "(", "h_t", ")", ",", "dim", "=", "-", "1", ")", "\n", "x_t_wid", "=", "torch", ".", "multinomial", "(", "p_t", ")", ".", "data", "[", "0", "]", "\n", "x_t", "=", "self", ".", "vocab", ".", "id2word", "[", "x_t_wid", "]", "\n", "\n", "if", "x_t", "==", "'</s>'", ":", "\n", "                ", "return", "[", "self", ".", "vocab", ".", "id2word", "[", "wid", "]", "for", "wid", "in", "sample_words", "[", "1", ":", "]", "]", "\n", "", "else", ":", "\n", "                ", "sample_words", ".", "append", "(", "x_t_wid", ")", "\n", "\n", "", "h_tm1", "=", "last_state", ",", "last_cell", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.neural_lm.LSTMLanguageModel.load": [[78, 85], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "neural_lm.LSTMLanguageModel", "LSTMLanguageModel.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load"], ["", "", "@", "classmethod", "\n", "def", "load", "(", "self", ",", "model_path", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "params", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "model", "=", "LSTMLanguageModel", "(", "params", "[", "'vocab'", "]", ",", "*", "params", "[", "'args'", "]", ")", "\n", "model", ".", "load_state_dict", "(", "params", "[", "'state_dict'", "]", ")", "\n", "\n", "return", "model", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.neural_lm.LSTMLanguageModel.save": [[86, 98], ["os.path.dirname", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.exists", "os.makedirs", "neural_lm.LSTMLanguageModel.state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "dirname", "(", "path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_name", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_name", ")", "\n", "\n", "", "params", "=", "{", "\n", "'args'", ":", "(", "self", ".", "embed_size", ",", "self", ".", "hidden_size", ",", "self", ".", "dropout_rate", ")", ",", "\n", "'vocab'", ":", "self", ".", "vocab", ",", "\n", "'state_dict'", ":", "self", ".", "state_dict", "(", ")", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "params", ",", "path", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.__init__": [[18, 31], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "model.nn_utils.FeedForward", "model.nn_utils.FeedForward", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "torch.Embedding", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["def", "__init__", "(", "self", ",", "src_vocab", ",", "tgt_vocab", ",", "embed_size", ",", "dropout", "=", "0.", ",", "tie_embed", "=", "False", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "super", "(", "DecomposableAttentionModel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "if", "tie_embed", ":", "\n", "            ", "self", ".", "src_embed", "=", "self", ".", "tgt_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "src_vocab", ")", ",", "embed_size", ",", "padding_idx", "=", "src_vocab", "[", "'<pad>'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "src_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "src_vocab", ")", ",", "embed_size", ",", "padding_idx", "=", "src_vocab", "[", "'<pad>'", "]", ")", "\n", "self", ".", "tgt_embed", "=", "nn", ".", "Embedding", "(", "len", "(", "tgt_vocab", ")", ",", "embed_size", ",", "padding_idx", "=", "tgt_vocab", "[", "'<pad>'", "]", ")", "\n", "\n", "", "self", ".", "att_linear", "=", "nn", ".", "Linear", "(", "embed_size", ",", "embed_size", ",", "bias", "=", "False", ")", "\n", "\n", "self", ".", "fuse_func", "=", "FeedForward", "(", "2", "*", "embed_size", ",", "num_layers", "=", "2", ",", "hidden_dims", "=", "embed_size", ",", "activations", "=", "F", ".", "relu", ",", "dropout", "=", "dropout", ")", "\n", "self", ".", "aggregate_ff", "=", "FeedForward", "(", "2", "*", "embed_size", ",", "num_layers", "=", "2", ",", "hidden_dims", "=", "[", "embed_size", ",", "3", "]", ",", "activations", "=", "[", "F", ".", "relu", ",", "nn_utils", ".", "identity", "]", ",", "dropout", "=", "[", "dropout", ",", "0.", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.forward": [[32, 47], ["decomposable_attention_model.DecomposableAttentionModel.encode_sentence", "decomposable_attention_model.DecomposableAttentionModel.encode_sentence", "decomposable_attention_model.DecomposableAttentionModel.get_soft_alignments", "decomposable_attention_model.DecomposableAttentionModel.aggregate_and_predict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.encode_sentence", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.encode_sentence", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.get_soft_alignments", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.aggregate_and_predict"], ["", "def", "forward", "(", "self", ",", "src_sents_var", ",", "tgt_sents_var", ",", "src_sents_mask", ",", "tgt_sents_mask", ")", ":", "\n", "# get input representation", "\n", "# (batch_size, src_sent_len, embed_size)", "\n", "        ", "src_sents_embed", "=", "self", ".", "encode_sentence", "(", "src_sents_var", ",", "type", "=", "'src'", ")", "\n", "# (batch_size, tgt_sent_len, embed_size)", "\n", "tgt_sents_embed", "=", "self", ".", "encode_sentence", "(", "tgt_sents_var", ",", "type", "=", "'tgt'", ")", "\n", "\n", "# (batch_size, src_sent_len, embed_size), (batch_size, tgt_sent_len, embed_size)", "\n", "src_aligned_phrases", ",", "tgt_aligned_phrases", "=", "self", ".", "get_soft_alignments", "(", "src_sents_embed", ",", "tgt_sents_embed", ",", "src_sents_mask", ",", "tgt_sents_mask", ")", "\n", "\n", "# (batch_size)", "\n", "prob", "=", "self", ".", "aggregate_and_predict", "(", "src_sents_embed", ",", "src_aligned_phrases", ",", "src_sents_mask", ",", "\n", "tgt_sents_embed", ",", "tgt_aligned_phrases", ",", "tgt_sents_mask", ")", "\n", "\n", "return", "prob", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.encode_sentence": [[48, 53], ["embed_layer"], "methods", ["None"], ["", "def", "encode_sentence", "(", "self", ",", "src_sents_var", ",", "type", "=", "'src'", ")", ":", "\n", "        ", "embed_layer", "=", "self", ".", "src_embed", "if", "type", "==", "'src'", "else", "self", ".", "tgt_embed", "\n", "sents_embed", "=", "embed_layer", "(", "src_sents_var", ")", "\n", "\n", "return", "sents_embed", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.get_soft_alignments": [[54, 66], ["decomposable_attention_model.DecomposableAttentionModel.attention", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.attention"], ["", "def", "get_soft_alignments", "(", "self", ",", "src_sents_embed", ",", "tgt_sents_embed", ",", "src_sents_mask", "=", "None", ",", "tgt_sents_mask", "=", "None", ")", ":", "\n", "# (batch_size, src_sent_len, tgt_sent_len)", "\n", "# (batch_size, tgt_sent_len, src_sent_len)", "\n", "        ", "src_to_tgt_att_prob", ",", "tgt_to_src_att_prob", "=", "self", ".", "attention", "(", "src_sents_embed", ",", "tgt_sents_embed", ",", "src_sents_mask", ",", "tgt_sents_mask", ")", "\n", "\n", "# (batch_size, src_sent_len, embed_size)", "\n", "betas", "=", "torch", ".", "bmm", "(", "src_to_tgt_att_prob", ",", "tgt_sents_embed", ")", "\n", "\n", "# (batch_size, tgt_sent_len, embed_size)", "\n", "alphas", "=", "torch", ".", "bmm", "(", "tgt_to_src_att_prob", ",", "src_sents_embed", ")", "\n", "\n", "return", "betas", ",", "alphas", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.attention": [[67, 95], ["decomposable_attention_model.DecomposableAttentionModel.att_linear", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "torch.bmm", "tgt_sents_embed.permute", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.bmm.permute", "torch.bmm.permute", "torch.bmm.permute", "torch.bmm.permute", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "src_sents_mask.unsqueeze.unsqueeze.unsqueeze", "tgt_sents_mask.unsqueeze.unsqueeze.unsqueeze", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.bmm.permute", "torch.bmm.permute", "torch.bmm.permute", "torch.bmm.permute", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax", "torch.softmax.sum", "torch.softmax.sum"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.softmax"], ["", "def", "attention", "(", "self", ",", "src_sents_embed", ",", "tgt_sents_embed", ",", "src_sents_mask", "=", "None", ",", "tgt_sents_mask", "=", "None", ")", ":", "\n", "# (batch_size, src_sent_len, embed_size)", "\n", "        ", "src_embed_att_linear", "=", "self", ".", "att_linear", "(", "src_sents_embed", ")", "\n", "\n", "# (batch_size, src_sent_len, tgt_sent_len)", "\n", "att_weights", "=", "torch", ".", "bmm", "(", "src_embed_att_linear", ",", "tgt_sents_embed", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ")", "\n", "\n", "if", "src_sents_mask", "is", "None", ":", "\n", "            ", "src_to_tgt_att_prob", "=", "F", ".", "softmax", "(", "att_weights", ",", "dim", "=", "-", "1", ")", "\n", "# (batch_size, tgt_sent_len, src_sent_len)", "\n", "tgt_to_src_att_weights", "=", "att_weights", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "tgt_to_src_att_prob", "=", "F", ".", "softmax", "(", "tgt_to_src_att_weights", ",", "dim", "=", "-", "1", ")", "\n", "", "else", ":", "\n", "            ", "src_sents_mask", "=", "src_sents_mask", ".", "unsqueeze", "(", "1", ")", "\n", "tgt_sents_mask", "=", "tgt_sents_mask", ".", "unsqueeze", "(", "1", ")", "\n", "\n", "# (batch_size, src_sent_len, tgt_sent_len)", "\n", "src_to_tgt_att_prob", "=", "F", ".", "softmax", "(", "att_weights", "*", "tgt_sents_mask", ",", "dim", "=", "-", "1", ")", "\n", "src_to_tgt_att_prob", "=", "src_to_tgt_att_prob", "*", "tgt_sents_mask", "\n", "src_to_tgt_att_prob", "=", "src_to_tgt_att_prob", "/", "(", "src_to_tgt_att_prob", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "+", "1e-13", ")", "\n", "\n", "# (batch_size, tgt_sent_len, src_sent_len)", "\n", "att_weights_t", "=", "att_weights", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "tgt_to_src_att_prob", "=", "F", ".", "softmax", "(", "att_weights_t", "*", "src_sents_mask", ",", "dim", "=", "-", "1", ")", "\n", "tgt_to_src_att_prob", "=", "tgt_to_src_att_prob", "*", "src_sents_mask", "\n", "tgt_to_src_att_prob", "=", "tgt_to_src_att_prob", "/", "(", "tgt_to_src_att_prob", ".", "sum", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "True", ")", "+", "1e-13", ")", "\n", "\n", "", "return", "src_to_tgt_att_prob", ",", "tgt_to_src_att_prob", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.decomposable_attention_model.DecomposableAttentionModel.aggregate_and_predict": [[96, 114], ["decomposable_attention_model.DecomposableAttentionModel.fuse_func", "decomposable_attention_model.DecomposableAttentionModel.fuse_func", "v_src.sum.sum.sum", "v_tgt.sum.sum.sum", "decomposable_attention_model.DecomposableAttentionModel.aggregate_ff", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.log_softmax", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "src_sents_mask.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "tgt_sents_mask.unsqueeze", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.apidocs.retrieve.log_softmax"], ["", "def", "aggregate_and_predict", "(", "self", ",", "\n", "src_sents_embed", ",", "src_aligned_phrases", ",", "src_sents_mask", ",", "\n", "tgt_sents_embed", ",", "tgt_aligned_phrases", ",", "tgt_sents_mask", ")", ":", "\n", "# (batch_size, [src_sent_len, tgt_sent_len], embed_size)", "\n", "        ", "v_src", "=", "self", ".", "fuse_func", "(", "torch", ".", "cat", "(", "[", "src_sents_embed", ",", "src_aligned_phrases", "]", ",", "dim", "=", "-", "1", ")", ")", "\n", "v_src", "=", "v_src", "*", "src_sents_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "v_tgt", "=", "self", ".", "fuse_func", "(", "torch", ".", "cat", "(", "[", "tgt_sents_embed", ",", "tgt_aligned_phrases", "]", ",", "dim", "=", "-", "1", ")", ")", "\n", "v_tgt", "=", "v_tgt", "*", "tgt_sents_mask", ".", "unsqueeze", "(", "-", "1", ")", "\n", "\n", "v_src", "=", "v_src", ".", "sum", "(", "dim", "=", "1", ")", "\n", "v_tgt", "=", "v_tgt", ".", "sum", "(", "dim", "=", "1", ")", "\n", "\n", "# (batch_size)", "\n", "label_logits", "=", "self", ".", "aggregate_ff", "(", "torch", ".", "cat", "(", "[", "v_src", ",", "v_tgt", "]", ",", "dim", "=", "-", "1", ")", ")", "\n", "prob", "=", "F", ".", "log_softmax", "(", "label_logits", ",", "dim", "=", "-", "1", ")", "\n", "\n", "return", "prob", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.attention_util.AttentionUtil.get_candidate_tokens_to_attend": [[12, 25], ["dict", "isinstance", "enumerate", "tgt_token.startswith", "LOGICAL_FORM_LEXICON.get", "len"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "get_candidate_tokens_to_attend", "(", "src_tokens", ",", "action", ")", ":", "\n", "        ", "tokens_to_attend", "=", "dict", "(", ")", "\n", "if", "isinstance", "(", "action", ",", "GenTokenAction", ")", ":", "\n", "            ", "tgt_token", "=", "action", ".", "token", "\n", "for", "src_idx", ",", "src_token", "in", "enumerate", "(", "src_tokens", ")", ":", "\n", "# match lemma", "\n", "                ", "if", "len", "(", "src_token", ")", ">=", "3", "and", "tgt_token", ".", "startswith", "(", "src_token", ")", "or", "src_token", "in", "LOGICAL_FORM_LEXICON", ".", "get", "(", "tgt_token", ",", "[", "]", ")", ":", "\n", "                    ", "tokens_to_attend", "[", "src_idx", "]", "=", "src_token", "\n", "\n", "# print(tokens_to_attend, tgt_token)", "\n", "", "", "", "return", "tokens_to_attend", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.__init__": [[10, 19], ["numpy.zeros", "enumerate", "numpy.mean", "numpy.std"], "methods", ["None"], ["        ", "raise", "NotImplementedError", "\n", "\n", "", "def", "post_process_hypothesis", "(", "self", ",", "hyp", ",", "meta_info", ",", "**", "kwargs", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "\n", "", "", "def", "get_example_processor_cls", "(", "dataset", ")", ":", "\n", "    ", "if", "dataset", "==", "'conala'", ":", "\n", "        ", "from", "datasets", ".", "conala", ".", "example_processor", "import", "ConalaExampleProcessor", "\n", "return", "ConalaExampleProcessor", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.embeddings": [[20, 27], ["open", "line.split", "numpy.array", "float"], "methods", ["None"], ["", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.emulate_embeddings": [[28, 32], ["numpy.random.normal"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.load_to": [[33, 44], ["set", "list", "new_tensor", "range", "utils.GloveHelper.emulate_embeddings", "list.remove", "new_tensor", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.emulate_embeddings"], []], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.GloveHelper.words": [[45, 51], ["open", "line.split"], "methods", ["None"], []], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.batch_iter": [[53, 65], ["int", "list", "range", "math.ceil", "range", "numpy.random.shuffle", "len", "len", "float"], "function", ["None"], []], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.utils.get_parser_class": [[67, 73], ["ValueError"], "function", ["None"], []], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.__init__": [[28, 45], ["super().__init__", "model.seq2seq.Seq2SeqModel", "model.seq2seq_copy.Seq2SeqWithCopy"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "vocab", ",", "transition_system", ")", ":", "\n", "        ", "super", "(", "Reconstructor", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "args", ".", "no_copy", ":", "\n", "            ", "self", ".", "seq2seq", "=", "Seq2SeqModel", "(", "src_vocab", "=", "vocab", ".", "code", ",", "tgt_vocab", "=", "vocab", ".", "source", ",", "\n", "embed_size", "=", "args", ".", "embed_size", ",", "hidden_size", "=", "args", ".", "hidden_size", ",", "\n", "dropout", "=", "args", ".", "dropout", ",", "\n", "label_smoothing", "=", "args", ".", "src_token_label_smoothing", ",", "\n", "cuda", "=", "args", ".", "cuda", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "seq2seq", "=", "Seq2SeqWithCopy", "(", "src_vocab", "=", "vocab", ".", "code", ",", "tgt_vocab", "=", "vocab", ".", "source", ",", "\n", "embed_size", "=", "args", ".", "embed_size", ",", "hidden_size", "=", "args", ".", "hidden_size", ",", "\n", "dropout", "=", "args", ".", "dropout", ",", "\n", "cuda", "=", "args", ".", "cuda", ")", "\n", "\n", "", "self", ".", "vocab", "=", "vocab", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "transition_system", "=", "transition_system", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.feature_name": [[46, 49], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "feature_name", "(", "self", ")", ":", "\n", "        ", "return", "'reconstructor'", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.is_batched": [[50, 53], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "is_batched", "(", "self", ")", ":", "\n", "        ", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor._score": [[54, 77], ["model.nn_utils.to_input_variable", "model.nn_utils.to_input_variable", "reconstruction_model.Reconstructor.get_generate_and_copy_meta_tensor", "isinstance", "reconstruction_model.Reconstructor.seq2seq", "reconstruction_model.Reconstructor.seq2seq", "len", "len"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.nn_utils.to_input_variable", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.get_generate_and_copy_meta_tensor"], ["", "def", "_score", "(", "self", ",", "src_codes", ",", "tgt_nls", ")", ":", "\n", "        ", "\"\"\"score examples sorted by code length\"\"\"", "\n", "args", "=", "self", ".", "args", "\n", "\n", "# src_code = [self.tokenize_code(e.tgt_code) for e in examples]", "\n", "# tgt_nl = [e.src_sent for e in examples]", "\n", "\n", "src_code_var", "=", "nn_utils", ".", "to_input_variable", "(", "src_codes", ",", "self", ".", "vocab", ".", "code", ",", "cuda", "=", "args", ".", "cuda", ")", "\n", "tgt_nl_var", "=", "nn_utils", ".", "to_input_variable", "(", "tgt_nls", ",", "self", ".", "vocab", ".", "source", ",", "cuda", "=", "args", ".", "cuda", ",", "append_boundary_sym", "=", "True", ")", "\n", "\n", "tgt_token_copy_idx_mask", ",", "tgt_token_gen_mask", "=", "self", ".", "get_generate_and_copy_meta_tensor", "(", "src_codes", ",", "tgt_nls", ")", "\n", "\n", "if", "isinstance", "(", "self", ".", "seq2seq", ",", "Seq2SeqWithCopy", ")", ":", "\n", "            ", "scores", "=", "self", ".", "seq2seq", "(", "src_code_var", ",", "\n", "[", "len", "(", "c", ")", "for", "c", "in", "src_codes", "]", ",", "\n", "tgt_nl_var", ",", "\n", "tgt_token_copy_idx_mask", ",", "tgt_token_gen_mask", ")", "\n", "", "else", ":", "\n", "            ", "scores", "=", "self", ".", "seq2seq", "(", "src_code_var", ",", "\n", "[", "len", "(", "c", ")", "for", "c", "in", "src_codes", "]", ",", "\n", "tgt_nl_var", ")", "\n", "\n", "", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.score": [[78, 97], ["len", "sorted", "enumerate", "reconstruction_model.Reconstructor._score", "reconstruction_model.Reconstructor.tokenize_code", "len", "six.moves.range"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor._score", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "score", "(", "self", ",", "examples", ")", ":", "\n", "        ", "batch_size", "=", "len", "(", "examples", ")", "\n", "\n", "tokenized_codes", "=", "[", "self", ".", "tokenize_code", "(", "e", ".", "tgt_code", ")", "for", "e", "in", "examples", "]", "\n", "\n", "code_lens", "=", "[", "len", "(", "code", ")", "for", "code", "in", "tokenized_codes", "]", "\n", "sorted_example_ids", "=", "sorted", "(", "range", "(", "batch_size", ")", ",", "key", "=", "lambda", "x", ":", "-", "code_lens", "[", "x", "]", ")", "\n", "\n", "example_old_pos_map", "=", "[", "-", "1", "]", "*", "batch_size", "\n", "for", "new_pos", ",", "old_pos", "in", "enumerate", "(", "sorted_example_ids", ")", ":", "\n", "            ", "example_old_pos_map", "[", "old_pos", "]", "=", "new_pos", "\n", "\n", "", "sorted_src_codes", "=", "[", "tokenized_codes", "[", "i", "]", "for", "i", "in", "sorted_example_ids", "]", "\n", "sorted_tgt_nls", "=", "[", "examples", "[", "i", "]", ".", "src_sent", "for", "i", "in", "sorted_example_ids", "]", "\n", "sorted_scores", "=", "self", ".", "_score", "(", "sorted_src_codes", ",", "sorted_tgt_nls", ")", "\n", "\n", "scores", "=", "sorted_scores", "[", "example_old_pos_map", "]", "\n", "\n", "return", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.forward": [[98, 100], ["reconstruction_model.Reconstructor.score"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.score"], ["", "def", "forward", "(", "self", ",", "examples", ")", ":", "\n", "        ", "return", "self", ".", "score", "(", "examples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.sample": [[101, 106], ["reconstruction_model.Reconstructor.tokenize_code", "reconstruction_model.Reconstructor.seq2seq.sample"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.sample"], ["", "def", "sample", "(", "self", ",", "code", ",", "sample_size", "=", "5", ")", ":", "\n", "        ", "tokenized_code", "=", "self", ".", "tokenize_code", "(", "code", ")", "\n", "samples", "=", "self", ".", "seq2seq", ".", "sample", "(", "tokenized_code", ",", "sample_size", "=", "sample_size", ",", "decode_max_time_step", "=", "self", ".", "args", ".", "decode_max_time_step", ")", "\n", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code": [[107, 109], ["reconstruction_model.Reconstructor.transition_system.tokenize_code"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.tokenize_code"], ["", "def", "tokenize_code", "(", "self", ",", "code", ")", ":", "\n", "        ", "return", "self", ".", "transition_system", ".", "tokenize_code", "(", "code", ",", "mode", "=", "'decoder'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.get_generate_and_copy_meta_tensor": [[110, 144], ["max", "max", "len", "numpy.zeros", "numpy.zeros", "six.moves.range", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "enumerate", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "torch.from_numpy", "tgt_token_copy_idx_mask.cuda.cuda.cuda", "tgt_token_gen_mask.cuda.cuda.cuda", "len", "len", "zip", "len", "enumerate", "len"], "methods", ["None"], ["", "def", "get_generate_and_copy_meta_tensor", "(", "self", ",", "src_codes", ",", "tgt_nls", ")", ":", "\n", "        ", "tgt_nls", "=", "[", "[", "'<s>'", "]", "+", "x", "+", "[", "'</s>'", "]", "for", "x", "in", "tgt_nls", "]", "\n", "max_time_step", "=", "max", "(", "len", "(", "tgt_nl", ")", "for", "tgt_nl", "in", "tgt_nls", ")", "\n", "max_src_len", "=", "max", "(", "len", "(", "src_code", ")", "for", "src_code", "in", "src_codes", ")", "\n", "batch_size", "=", "len", "(", "src_codes", ")", "\n", "\n", "tgt_token_copy_idx_mask", "=", "np", ".", "zeros", "(", "(", "max_time_step", ",", "batch_size", ",", "max_src_len", ")", ",", "dtype", "=", "'float32'", ")", "\n", "tgt_token_gen_mask", "=", "np", ".", "zeros", "(", "(", "max_time_step", ",", "batch_size", ")", ",", "dtype", "=", "'float32'", ")", "\n", "\n", "for", "t", "in", "range", "(", "max_time_step", ")", ":", "\n", "            ", "for", "example_id", ",", "(", "src_code", ",", "tgt_nl", ")", "in", "enumerate", "(", "zip", "(", "src_codes", ",", "tgt_nls", ")", ")", ":", "\n", "                ", "copy_pos", "=", "copy_mask", "=", "gen_mask", "=", "0", "\n", "if", "t", "<", "len", "(", "tgt_nl", ")", ":", "\n", "                    ", "tgt_token", "=", "tgt_nl", "[", "t", "]", "\n", "copy_pos_list", "=", "[", "_i", "for", "_i", ",", "_token", "in", "enumerate", "(", "src_code", ")", "if", "_token", "==", "tgt_token", "]", "\n", "tgt_token_copy_idx_mask", "[", "t", ",", "example_id", ",", "copy_pos_list", "]", "=", "1", "\n", "\n", "gen_mask", "=", "0", "\n", "# we need to generate this token if (1) it's defined in the dictionary,", "\n", "# or (2) it is an unknown word and not appear in the source side", "\n", "if", "tgt_token", "in", "self", ".", "vocab", ".", "code", ":", "\n", "                        ", "gen_mask", "=", "1", "\n", "", "elif", "len", "(", "copy_pos_list", ")", "==", "0", ":", "\n", "                        ", "gen_mask", "=", "1", "\n", "\n", "", "tgt_token_gen_mask", "[", "t", ",", "example_id", "]", "=", "gen_mask", "\n", "\n", "", "", "", "tgt_token_copy_idx_mask", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "tgt_token_copy_idx_mask", ")", ")", "\n", "tgt_token_gen_mask", "=", "Variable", "(", "torch", ".", "from_numpy", "(", "tgt_token_gen_mask", ")", ")", "\n", "if", "self", ".", "args", ".", "cuda", ":", "\n", "            ", "tgt_token_copy_idx_mask", "=", "tgt_token_copy_idx_mask", ".", "cuda", "(", ")", "\n", "tgt_token_gen_mask", "=", "tgt_token_gen_mask", ".", "cuda", "(", ")", "\n", "\n", "", "return", "tgt_token_copy_idx_mask", ",", "tgt_token_gen_mask", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.save": [[145, 158], ["os.path.dirname", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "torch.save", "os.path.exists", "os.makedirs", "reconstruction_model.Reconstructor.state_dict"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save"], ["", "def", "save", "(", "self", ",", "path", ")", ":", "\n", "        ", "dir_name", "=", "os", ".", "path", ".", "dirname", "(", "path", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "dir_name", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "dir_name", ")", "\n", "\n", "", "params", "=", "{", "\n", "'args'", ":", "self", ".", "args", ",", "\n", "'vocab'", ":", "self", ".", "vocab", ",", "\n", "'state_dict'", ":", "self", ".", "state_dict", "(", ")", ",", "\n", "'transition_system'", ":", "self", ".", "transition_system", "\n", "}", "\n", "\n", "torch", ".", "save", "(", "params", ",", "path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.reconstruction_model.Reconstructor.load": [[159, 171], ["torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "torch.load", "reconstruction_model.Reconstructor", "model.cuda.cuda.load_state_dict", "model.cuda.cuda.eval", "model.cuda.cuda.cuda"], "methods", ["home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load", "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.model.prior.Prior.eval"], ["", "@", "staticmethod", "\n", "def", "load", "(", "model_path", ",", "cuda", "=", "False", ")", ":", "\n", "        ", "decoder_params", "=", "torch", ".", "load", "(", "model_path", ",", "map_location", "=", "lambda", "storage", ",", "loc", ":", "storage", ")", "\n", "decoder_params", "[", "'args'", "]", ".", "cuda", "=", "cuda", "\n", "\n", "model", "=", "Reconstructor", "(", "decoder_params", "[", "'args'", "]", ",", "decoder_params", "[", "'vocab'", "]", ",", "decoder_params", "[", "'transition_system'", "]", ")", "\n", "model", ".", "load_state_dict", "(", "decoder_params", "[", "'state_dict'", "]", ")", "\n", "\n", "if", "cuda", ":", "model", "=", "model", ".", "cuda", "(", ")", "\n", "model", ".", "eval", "(", ")", "\n", "\n", "return", "model", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.register": [[8, 18], ["RuntimeError"], "methods", ["None"], ["@", "staticmethod", "\n", "def", "register", "(", "name", ")", ":", "\n", "        ", "def", "register_class", "(", "cls", ")", ":", "\n", "            ", "if", "name", "in", "Registrable", ".", "registered_components", ":", "\n", "                ", "raise", "RuntimeError", "(", "'class %s already registered'", "%", "name", ")", "\n", "\n", "", "Registrable", ".", "registered_components", "[", "name", "]", "=", "cls", "\n", "return", "cls", "\n", "\n", "", "return", "register_class", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.registerable.Registrable.by_name": [[19, 22], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "by_name", "(", "name", ")", ":", "\n", "        ", "return", "Registrable", ".", "registered_components", "[", "name", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.load": [[2, 5], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "load", "(", "model_path", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.savable.Savable.save": [[6, 9], ["None"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "save", "(", "model_path", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "pass", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__init__": [[13, 16], ["getattr"], "methods", ["None"], ["        ", "raise", "NotImplementedError", "\n", "\n", "\n", "", "", "def", "get_example_processor_cls", "(", "dataset", ")", ":", "\n"]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.cached_property.__get__": [[17, 22], ["utils.cached_property.func"], "methods", ["None"], ["    ", "if", "dataset", "==", "'conala'", ":", "\n", "        ", "from", "datasets", ".", "conala", ".", "example_processor", "import", "ConalaExampleProcessor", "\n", "return", "ConalaExampleProcessor", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.init_arg_parser": [[24, 154], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument"], "function", ["None"], []], "home.repos.pwc.inspect_result.neulab_external-knowledge-codegen.common.utils.update_args": [[156, 162], ["isinstance", "isinstance", "isinstance", "hasattr", "setattr"], "function", ["None"], []]}