{"home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.__init__": [[8, 27], ["object.__init__", "map.Map._compute_map_dimensions", "map.Map._get_row_pass_indices", "numpy.arange", "numpy.arange", "map.Map._set_occupancy_grid"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map._compute_map_dimensions", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map._get_row_pass_indices", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map._set_occupancy_grid"], ["    ", "def", "__init__", "(", "self", ",", "num_gp_rows", "=", "15", ",", "num_gp_cols", "=", "37", ",", "num_row_passes", "=", "2", ",", "row_pass_width", "=", "1", ")", ":", "\n", "\n", "        ", "super", "(", "Map", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "num_gp_rows", "=", "num_gp_rows", "\n", "self", ".", "num_gp_cols", "=", "num_gp_cols", "\n", "self", ".", "num_row_passes", "=", "num_row_passes", "\n", "self", ".", "row_pass_width", "=", "row_pass_width", "\n", "\n", "assert", "self", ".", "num_gp_rows", "%", "(", "self", ".", "num_row_passes", "+", "1", ")", "==", "0", ",", "'Infeasible row setting'", "\n", "\n", "self", ".", "_shape", "=", "self", ".", "_compute_map_dimensions", "(", ")", "\n", "self", ".", "corridor_len", "=", "self", ".", "num_gp_rows", "//", "(", "self", ".", "num_row_passes", "+", "1", ")", "\n", "self", ".", "row_pass_indices", "=", "self", ".", "_get_row_pass_indices", "(", ")", "\n", "self", ".", "free_cols", "=", "np", ".", "arange", "(", "0", ",", "self", ".", "shape", "[", "1", "]", ",", "2", ")", "\n", "self", ".", "obstacle_cols", "=", "np", ".", "arange", "(", "1", ",", "self", ".", "shape", "[", "1", "]", ",", "2", ")", "\n", "\n", "# 1 if obstacle 0 otherwise", "\n", "self", ".", "occupied", "=", "self", ".", "_set_occupancy_grid", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.shape": [[28, 31], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map._set_occupancy_grid": [[32, 38], ["numpy.full"], "methods", ["None"], ["", "def", "_set_occupancy_grid", "(", "self", ")", ":", "\n", "# returns the occupancy grid of the map", "\n", "        ", "grid", "=", "np", ".", "full", "(", "self", ".", "_shape", ",", "False", ")", "\n", "grid", "[", ":", ",", "self", ".", "obstacle_cols", "]", "=", "True", "\n", "grid", "[", "self", ".", "row_pass_indices", ",", ":", "]", "=", "False", "\n", "return", "grid", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map._compute_map_dimensions": [[39, 44], ["None"], "methods", ["None"], ["", "def", "_compute_map_dimensions", "(", "self", ")", ":", "\n", "# extra row at top and bottom", "\n", "        ", "total_rows", "=", "self", ".", "num_gp_rows", "+", "(", "self", ".", "num_row_passes", "+", "2", ")", "*", "self", ".", "row_pass_width", "\n", "total_cols", "=", "self", ".", "num_gp_cols", "*", "2", "-", "1", "\n", "return", "total_rows", ",", "total_cols", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map._get_row_pass_indices": [[45, 55], ["numpy.array", "list", "range"], "methods", ["None"], ["", "def", "_get_row_pass_indices", "(", "self", ")", ":", "\n", "# return indices of all the row pass", "\n", "        ", "ind", "=", "[", "]", "\n", "t", "=", "0", "\n", "last", "=", "0", "\n", "while", "t", "<", "self", ".", "num_row_passes", "+", "2", ":", "\n", "            ", "ind", "+=", "list", "(", "range", "(", "last", ",", "last", "+", "self", ".", "row_pass_width", ")", ")", "\n", "t", "+=", "1", "\n", "last", "=", "last", "+", "self", ".", "row_pass_width", "+", "self", ".", "corridor_len", "\n", "", "return", "np", ".", "array", "(", "ind", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.distance_between_nodes": [[56, 128], ["NotImplementedError", "NotImplementedError", "graph_utils.get_heading", "graph_utils.opposite_headings", "map.Map.get_junction", "map.Map.get_junction", "map.Map.get_junction", "graph_utils.get_heading", "utils.manhattan_distance", "map.Map.get_junction", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "graph_utils.get_heading", "map.Map.get_up_junction", "map.Map.get_down_junction", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "graph_utils.get_heading", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.opposite_headings", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_up_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_down_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance"], ["", "def", "distance_between_nodes", "(", "self", ",", "start", ",", "goal", ",", "heading", ")", ":", "\n", "# return distance between start and goal and final heading on reaching goal", "\n", "        ", "if", "start", "==", "goal", ":", "\n", "            ", "return", "0", ",", "heading", "\n", "\n", "# these cases should never occur", "\n", "", "if", "start", "[", "0", "]", "not", "in", "self", ".", "row_pass_indices", "and", "heading", "not", "in", "[", "(", "1", ",", "0", ")", ",", "(", "-", "1", ",", "0", ")", "]", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Starting location has infeasible heading'", ")", "\n", "", "if", "goal", "[", "0", "]", "in", "self", ".", "row_pass_indices", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'Goal location is a junction'", ")", "\n", "\n", "# if start and goal are in the same column", "\n", "", "if", "start", "[", "1", "]", "==", "goal", "[", "1", "]", ":", "\n", "            ", "final_heading", "=", "get_heading", "(", "start", ",", "goal", ")", "\n", "\n", "# if headings align, move to the goal directly", "\n", "if", "not", "opposite_headings", "(", "heading", ",", "final_heading", ")", ":", "\n", "                ", "return", "manhattan_distance", "(", "start", ",", "goal", ")", ",", "final_heading", "\n", "\n", "# if not, move to the junction, then move to the adjacent column (and come back later) and proceed to the goal", "\n", "", "else", ":", "\n", "                ", "sj", "=", "self", ".", "get_junction", "(", "start", ",", "heading", ")", "\n", "gj", "=", "self", ".", "get_junction", "(", "goal", ",", "heading", ")", "\n", "\n", "# start and goal are in different blocks", "\n", "if", "sj", "!=", "gj", ":", "\n", "                    ", "total_dist", "=", "manhattan_distance", "(", "start", ",", "sj", ")", "+", "2", "*", "2", "+", "manhattan_distance", "(", "sj", ",", "goal", ")", "\n", "return", "total_dist", ",", "(", "-", "heading", "[", "0", "]", ",", "0", ")", "\n", "\n", "# start and goal are in the same block, need to come back in this block ", "\n", "", "else", ":", "\n", "                    ", "node", "=", "self", ".", "get_junction", "(", "goal", ",", "(", "-", "heading", "[", "0", "]", ",", "0", ")", ")", "\n", "total_dist", "=", "manhattan_distance", "(", "start", ",", "sj", ")", "+", "2", "*", "2", "+", "manhattan_distance", "(", "sj", ",", "node", ")", "+", "manhattan_distance", "(", "node", ",", "goal", ")", "\n", "return", "total_dist", ",", "heading", "\n", "\n", "# start and goal are in different columns", "\n", "", "", "", "else", ":", "\n", "# move to the junction and then proceed to the goal", "\n", "            ", "if", "heading", "in", "[", "(", "1", ",", "0", ")", ",", "(", "-", "1", ",", "0", ")", "]", ":", "\n", "                ", "node", "=", "self", ".", "get_junction", "(", "start", ",", "heading", ")", "\n", "total_dist", "=", "manhattan_distance", "(", "start", ",", "node", ")", "+", "manhattan_distance", "(", "node", ",", "goal", ")", "\n", "# shift to the goal column to compute final heading", "\n", "final_heading", "=", "get_heading", "(", "(", "node", "[", "0", "]", ",", "goal", "[", "1", "]", ")", ",", "goal", ")", "\n", "final_heading", "=", "heading", "if", "final_heading", "is", "None", "else", "final_heading", "\n", "return", "total_dist", ",", "final_heading", "\n", "\n", "# start location is a junction and heading is either east or west ", "\n", "", "else", ":", "\n", "# if heading points towards the goal direction, just move there ", "\n", "                ", "if", "(", "goal", "[", "1", "]", ">=", "start", "[", "1", "]", "and", "heading", "[", "1", "]", ">", "0", ")", "or", "(", "goal", "[", "1", "]", "<=", "start", "[", "1", "]", "and", "heading", "[", "1", "]", "<", "0", ")", ":", "\n", "                    ", "total_dist", "=", "manhattan_distance", "(", "start", ",", "goal", ")", "\n", "# shift to the goal column to compute final heading", "\n", "final_heading", "=", "get_heading", "(", "(", "start", "[", "0", "]", ",", "goal", "[", "1", "]", ")", ",", "goal", ")", "\n", "return", "total_dist", ",", "final_heading", "\n", "\n", "# if heading points in the opposite direction of goal", "\n", "", "else", ":", "\n", "                    ", "up_node", "=", "self", ".", "get_up_junction", "(", "goal", ")", "\n", "down_node", "=", "self", ".", "get_down_junction", "(", "goal", ")", "\n", "\n", "# go to down node if up node lies in the same row as start", "\n", "if", "start", "[", "0", "]", "==", "up_node", "[", "0", "]", ":", "\n", "                        ", "total_dist", "=", "manhattan_distance", "(", "start", ",", "down_node", ")", "+", "manhattan_distance", "(", "down_node", ",", "goal", ")", "\n", "final_heading", "=", "(", "-", "1", ",", "0", ")", "\n", "# go to up node if down node lies in the same row as start", "\n", "", "elif", "start", "[", "0", "]", "==", "down_node", "[", "0", "]", ":", "\n", "                        ", "total_dist", "=", "manhattan_distance", "(", "start", ",", "up_node", ")", "+", "manhattan_distance", "(", "up_node", ",", "goal", ")", "\n", "final_heading", "=", "(", "1", ",", "0", ")", "\n", "", "else", ":", "\n", "                        ", "total_dist", "=", "manhattan_distance", "(", "start", ",", "goal", ")", "\n", "final_heading", "=", "get_heading", "(", "(", "start", "[", "0", "]", ",", "goal", "[", "1", "]", ")", ",", "goal", ")", "\n", "", "return", "total_dist", ",", "final_heading", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.distance_between_nodes_with_headings": [[129, 170], ["map.Map.distance_between_nodes", "graph_utils.opposite_headings", "map.Map.get_junction", "map.Map.get_junction", "map.Map.get_junction", "utils.manhattan_distance", "utils.manhattan_distance", "utils.manhattan_distance", "abs"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.distance_between_nodes", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.opposite_headings", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance"], ["", "", "", "", "def", "distance_between_nodes_with_headings", "(", "self", ",", "start", ",", "start_heading", ",", "goal", ",", "goal_heading", ")", ":", "\n", "        ", "dist", ",", "final_heading", "=", "self", ".", "distance_between_nodes", "(", "start", ",", "goal", ",", "start_heading", ")", "\n", "if", "not", "opposite_headings", "(", "final_heading", ",", "goal_heading", ")", ":", "\n", "            ", "return", "dist", "\n", "\n", "# Goal heading is opposite of final_heading", "\n", "", "perimeter", "=", "4", "+", "2", "*", "(", "self", ".", "corridor_len", "+", "1", ")", "\n", "\n", "if", "start_heading", "in", "[", "(", "1", ",", "0", ")", ",", "(", "-", "1", ",", "0", ")", "]", ":", "\n", "            ", "start_junc", "=", "self", ".", "get_junction", "(", "start", ",", "start_heading", ")", "\n", "gj", "=", "self", ".", "get_junction", "(", "goal", ",", "start_heading", ")", "\n", "goal_junc", "=", "self", ".", "get_junction", "(", "goal", ",", "(", "-", "goal_heading", "[", "0", "]", ",", "goal_heading", "[", "1", "]", ")", ")", "\n", "# the agent has to move atleast this distance ", "\n", "min_dist", "=", "manhattan_distance", "(", "start", ",", "start_junc", ")", "+", "manhattan_distance", "(", "start_junc", ",", "goal_junc", ")", "+", "manhattan_distance", "(", "goal_junc", ",", "goal", ")", "\n", "\n", "# if start and goal are in the same column", "\n", "if", "start", "[", "1", "]", "==", "goal", "[", "1", "]", ":", "\n", "# same block", "\n", "                ", "if", "start_junc", "[", "0", "]", "==", "gj", "[", "0", "]", ":", "\n", "# top or bottom block", "\n", "                    ", "if", "start_junc", "[", "0", "]", "==", "0", "or", "start_junc", "[", "0", "]", "==", "self", ".", "shape", "[", "0", "]", "-", "1", ":", "\n", "                        ", "extra", "=", "perimeter", "+", "4", "\n", "", "else", ":", "\n", "                        ", "extra", "=", "perimeter", "\n", "# different blocks", "\n", "", "", "else", ":", "\n", "                    ", "extra", "=", "4", "\n", "\n", "# start and goal are in adjacent sampling columns        ", "\n", "", "", "elif", "abs", "(", "start", "[", "1", "]", "-", "goal", "[", "1", "]", ")", "==", "2", ":", "\n", "                ", "if", "start_heading", "==", "goal_heading", ":", "\n", "                    ", "extra", "=", "4", "\n", "", "else", ":", "\n", "                    ", "extra", "=", "0", "\n", "\n", "", "", "else", ":", "\n", "                ", "extra", "=", "0", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "return", "min_dist", "+", "extra", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction": [[171, 179], ["map.Map.get_down_junction", "map.Map.get_up_junction"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_down_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_up_junction"], ["", "def", "get_junction", "(", "self", ",", "pose", ",", "heading", ")", ":", "\n", "# return junction in the heading direction", "\n", "        ", "if", "heading", "==", "(", "1", ",", "0", ")", ":", "\n", "            ", "return", "self", ".", "get_down_junction", "(", "pose", ")", "\n", "", "elif", "heading", "==", "(", "-", "1", ",", "0", ")", ":", "\n", "            ", "return", "self", ".", "get_up_junction", "(", "pose", ")", "\n", "", "else", ":", "\n", "            ", "return", "pose", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_up_junction": [[180, 184], ["max"], "methods", ["None"], ["", "", "def", "get_up_junction", "(", "self", ",", "pose", ")", ":", "\n", "# return up junction (in decreasing x direction)", "\n", "        ", "up", "=", "max", "(", "[", "x", "for", "x", "in", "self", ".", "row_pass_indices", "if", "x", "<=", "pose", "[", "0", "]", "]", ")", "\n", "return", "(", "up", ",", "pose", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_down_junction": [[185, 189], ["min"], "methods", ["None"], ["", "def", "get_down_junction", "(", "self", ",", "pose", ")", ":", "\n", "# return down junction (in increasing x direction)", "\n", "        ", "down", "=", "min", "(", "[", "x", "for", "x", "in", "self", ".", "row_pass_indices", "if", "x", ">=", "pose", "[", "0", "]", "]", ")", "\n", "return", "(", "down", ",", "pose", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.nearest_waypoint_path_cost": [[190, 228], ["len", "sum", "range", "numpy.argmin", "map.Map.distance_between_nodes", "costs.append", "seq.append"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.distance_between_nodes"], ["", "def", "nearest_waypoint_path_cost", "(", "self", ",", "start", ",", "start_heading", ",", "waypoints", ",", "return_seq", "=", "False", ")", ":", "\n", "# return cost of the path formed by always moving to the nearest waypoint", "\n", "        ", "nw", "=", "len", "(", "waypoints", ")", "\n", "visited", "=", "[", "False", "]", "*", "nw", "\n", "total_cost", "=", "0", "\n", "\n", "node", "=", "start", "\n", "heading", "=", "start_heading", "\n", "if", "return_seq", ":", "\n", "            ", "seq", "=", "[", "]", "\n", "costs", "=", "[", "]", "\n", "# final_headings = []", "\n", "\n", "", "while", "sum", "(", "visited", ")", "!=", "nw", ":", "\n", "# find the nearest waypoint from the current node", "\n", "            ", "all_dists", "=", "[", "np", ".", "inf", "]", "*", "nw", "\n", "all_final_headings", "=", "[", "(", "0", ",", "0", ")", "]", "*", "nw", "\n", "for", "i", "in", "range", "(", "nw", ")", ":", "\n", "                ", "if", "visited", "[", "i", "]", ":", "\n", "                    ", "continue", "\n", "", "dist", ",", "final_heading", "=", "self", ".", "distance_between_nodes", "(", "node", ",", "waypoints", "[", "i", "]", ",", "heading", ")", "\n", "all_dists", "[", "i", "]", "=", "dist", "\n", "all_final_headings", "[", "i", "]", "=", "final_heading", "\n", "\n", "", "idx", "=", "np", ".", "argmin", "(", "all_dists", ")", "\n", "total_cost", "+=", "all_dists", "[", "idx", "]", "\n", "node", "=", "waypoints", "[", "idx", "]", "\n", "heading", "=", "all_final_headings", "[", "idx", "]", "\n", "visited", "[", "idx", "]", "=", "True", "\n", "if", "return_seq", ":", "\n", "                ", "costs", ".", "append", "(", "all_dists", "[", "idx", "]", ")", "\n", "seq", ".", "append", "(", "idx", ")", "\n", "# final_headings.append(heading)", "\n", "\n", "", "", "if", "return_seq", ":", "\n", "# return costs, seq, final_headings", "\n", "            ", "return", "costs", ",", "seq", "\n", "", "return", "total_cost", "\n", "", "", ""]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.IdentityLatentFunction.__init__": [[16, 19], ["torch.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "        ", "super", "(", "IdentityLatentFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "embed_dim", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.IdentityLatentFunction.forward": [[20, 22], ["None"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.LinearLatentFunction.__init__": [[25, 29], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_dim", ",", "embed_dim", ")", ":", "\n", "        ", "super", "(", "LinearLatentFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc", "=", "nn", ".", "Linear", "(", "input_dim", ",", "embed_dim", ")", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.LinearLatentFunction.forward": [[30, 32], ["models.LinearLatentFunction.fc"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "fc", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.NonLinearLatentFunction.__init__": [[35, 40], ["torch.Module.__init__", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__"], ["    ", "def", "__init__", "(", "self", ",", "input_dim", ",", "f1_dim", ",", "embed_dim", ")", ":", "\n", "        ", "super", "(", "NonLinearLatentFunction", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "fc1", "=", "nn", ".", "Linear", "(", "input_dim", ",", "f1_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "fc2", "=", "nn", ".", "Linear", "(", "f1_dim", ",", "embed_dim", ",", "bias", "=", "False", ")", "\n", "self", ".", "embed_dim", "=", "embed_dim", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.NonLinearLatentFunction.forward": [[41, 45], ["torch.tanh", "torch.tanh", "torch.tanh", "models.NonLinearLatentFunction.fc2", "models.NonLinearLatentFunction.fc1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "x", "=", "F", ".", "tanh", "(", "self", ".", "fc1", "(", "inp", ")", ")", "\n", "x", "=", "self", ".", "fc2", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.__init__": [[87, 102], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "latent", "=", "None", ",", "lr", "=", ".01", ",", "max_iterations", "=", "200", ",", "kernel_params", "=", "None", ",", "latent_params", "=", "None", ",", "learn_likelihood_noise", "=", "True", ")", ":", "\n", "        ", "self", ".", "_train_x", "=", "None", "\n", "self", ".", "_train_y", "=", "None", "\n", "self", ".", "_train_y_mean", "=", "None", "\n", "self", ".", "_train_var", "=", "None", "\n", "self", ".", "likelihood", "=", "None", "\n", "self", ".", "model", "=", "None", "\n", "self", ".", "optimizer", "=", "None", "\n", "self", ".", "mll", "=", "None", "\n", "self", ".", "lr", "=", "lr", "\n", "self", ".", "latent", "=", "latent", "\n", "self", ".", "kernel_params", "=", "kernel_params", "\n", "self", ".", "latent_params", "=", "latent_params", "\n", "self", ".", "max_iter", "=", "max_iterations", "\n", "self", ".", "learn_likelihood_noise", "=", "learn_likelihood_noise", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.train_x": [[103, 106], ["models.GPR._train_x.cpu().numpy", "models.GPR._train_x.cpu"], "methods", ["None"], ["", "@", "property", "\n", "def", "train_x", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_train_x", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.train_y": [[107, 110], ["models.GPR._train_y.cpu().numpy", "models.GPR._train_y.cpu"], "methods", ["None"], ["", "@", "property", "\n", "def", "train_y", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "_train_y", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.train_var": [[111, 116], ["models.GPR._train_var.cpu().numpy", "models.GPR._train_var.cpu"], "methods", ["None"], ["", "@", "property", "\n", "def", "train_var", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "_train_var", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "return", "self", ".", "_train_var", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.reset": [[117, 125], ["models.GPR.set_train_data", "gpytorch.likelihoods.GaussianLikelihood", "models.ExactGPModel", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "gpytorch.mlls.ExactMarginalLogLikelihood", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "torch.optim.lr_scheduler.ReduceLROnPlateau", "models.GPR.model.parameters"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.set_train_data"], ["", "def", "reset", "(", "self", ",", "x", ",", "y", ",", "var", ")", ":", "\n", "        ", "self", ".", "set_train_data", "(", "x", ",", "y", ",", "var", ")", "\n", "# self.likelihood = GaussianLikelihood(learn_noise=self.learn_likelihood_noise)", "\n", "self", ".", "likelihood", "=", "GaussianLikelihood", "(", ")", "\n", "self", ".", "model", "=", "ExactGPModel", "(", "self", ".", "_train_x", ",", "self", ".", "_zero_mean_train_y", ",", "self", ".", "likelihood", ",", "self", ".", "_train_var", ",", "self", ".", "latent", ",", "self", ".", "kernel_params", ",", "self", ".", "latent_params", ")", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "[", "{", "'params'", ":", "self", ".", "model", ".", "parameters", "(", ")", "}", ",", "]", ",", "lr", "=", "self", ".", "lr", ")", "\n", "self", ".", "mll", "=", "gpytorch", ".", "mlls", ".", "ExactMarginalLogLikelihood", "(", "self", ".", "likelihood", ",", "self", ".", "model", ")", "\n", "self", ".", "lr_scheduler", "=", "torch", ".", "optim", ".", "lr_scheduler", ".", "ReduceLROnPlateau", "(", "self", ".", "optimizer", ",", "mode", "=", "'min'", ",", "patience", "=", "50", ",", "verbose", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.set_train_data": [[126, 136], ["utils.to_torch", "utils.to_torch", "models.GPR._train_y.mean", "utils.to_torch", "models.GPR.model.set_train_data"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch", "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.set_train_data"], ["", "def", "set_train_data", "(", "self", ",", "x", ",", "y", ",", "var", "=", "None", ")", ":", "\n", "        ", "self", ".", "_train_x", "=", "to_torch", "(", "x", ")", "\n", "self", ".", "_train_y", "=", "to_torch", "(", "y", ")", "\n", "self", ".", "_train_y_mean", "=", "self", ".", "_train_y", ".", "mean", "(", ")", "\n", "self", ".", "_zero_mean_train_y", "=", "self", ".", "_train_y", "-", "self", ".", "_train_y_mean", "\n", "if", "var", "is", "not", "None", ":", "\n", "            ", "self", ".", "_train_var", "=", "to_torch", "(", "var", ")", "\n", "\n", "", "if", "self", ".", "model", "is", "not", "None", ":", "\n", "            ", "self", ".", "model", ".", "set_train_data", "(", "inputs", "=", "self", ".", "_train_x", ",", "targets", "=", "self", ".", "_zero_mean_train_y", ",", "strict", "=", "False", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.fit": [[137, 160], ["models.GPR.reset", "models.GPR.model.train", "models.GPR.likelihood.train", "range", "print", "numpy.full", "models.GPR.optimizer.zero_grad", "models.GPR.model", "loss.backward", "models.GPR.optimizer.step", "models.GPR.lr_scheduler.step", "losses.append", "len", "models.GPR.mll", "print", "loss.item", "loss.item", "loss.item", "loss.item"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset"], ["", "", "def", "fit", "(", "self", ",", "x", ",", "y", ",", "var", "=", "None", ",", "disp", "=", "False", ")", ":", "\n", "        ", "if", "var", "is", "None", ":", "\n", "            ", "var", "=", "np", ".", "full", "(", "len", "(", "y", ")", ",", "1e-5", ")", "\n", "", "self", ".", "reset", "(", "x", ",", "y", ",", "var", ")", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "likelihood", ".", "train", "(", ")", "\n", "\n", "losses", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "max_iter", ")", ":", "\n", "            ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "output", "=", "self", ".", "model", "(", "self", ".", "_train_x", ")", "\n", "loss", "=", "-", "self", ".", "mll", "(", "output", ",", "self", ".", "_zero_mean_train_y", ")", "\n", "loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "lr_scheduler", ".", "step", "(", "loss", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "i", ",", "loss", ".", "item", "(", ")", ")", "\n", "", "if", "i", "==", "0", ":", "\n", "                ", "initial_ll", "=", "-", "loss", ".", "item", "(", ")", "\n", "", "elif", "i", "==", "self", ".", "max_iter", "-", "1", ":", "\n", "                ", "final_ll", "=", "-", "loss", ".", "item", "(", ")", "\n", "", "losses", ".", "append", "(", "loss", ".", "item", "(", ")", ")", "\n", "", "print", "(", "'Initial LogLikelihood {:.3f} Final LogLikelihood {:.3f}'", ".", "format", "(", "initial_ll", ",", "final_ll", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.cov_mat": [[161, 182], ["utils.to_torch", "utils.to_torch", "models.GPR.model.eval", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "models.GPR.model.latent_func", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "torch.equal", "models.GPR.model.kernel_covar_module().evaluate().cpu().numpy", "models.GPR.model.latent_func", "models.GPR.model.kernel_covar_module().evaluate().cpu().numpy", "numpy.diag", "models.GPR.likelihood.log_noise.exp().item", "numpy.eye", "models.GPR.model.kernel_covar_module().evaluate().cpu", "models.GPR.model.kernel_covar_module().evaluate().cpu", "len", "models.GPR.likelihood.log_noise.exp", "models.GPR.model.kernel_covar_module().evaluate", "models.GPR.model.kernel_covar_module().evaluate", "models.GPR.model.kernel_covar_module", "models.GPR.model.kernel_covar_module"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch"], ["", "def", "cov_mat", "(", "self", ",", "x1", ",", "x2", "=", "None", ",", "white_noise_var", "=", "None", ",", "add_likelihood_var", "=", "False", ")", ":", "\n", "# white_noise_var needs to be passed explicitly", "\n", "        ", "x1_", "=", "to_torch", "(", "x1", ")", "\n", "x2_", "=", "to_torch", "(", "x2", ")", "\n", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x1_", "=", "self", ".", "model", ".", "latent_func", "(", "x1_", ")", "\n", "if", "x2_", "is", "None", "or", "torch", ".", "equal", "(", "x1_", ",", "x2_", ")", ":", "\n", "                ", "cov", "=", "self", ".", "model", ".", "kernel_covar_module", "(", "x1_", ")", ".", "evaluate", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "else", ":", "\n", "                ", "x2_", "=", "self", ".", "model", ".", "latent_func", "(", "x2_", ")", "\n", "cov", "=", "self", ".", "model", ".", "kernel_covar_module", "(", "x1_", ",", "x2_", ")", ".", "evaluate", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "\n", "", "if", "white_noise_var", "is", "not", "None", ":", "\n", "                ", "cov", "+=", "np", ".", "diag", "(", "white_noise_var", ")", "\n", "\n", "# for training data, add likelihood variance", "\n", "", "if", "add_likelihood_var", ":", "\n", "                ", "cov", "+=", "self", ".", "likelihood", ".", "log_noise", ".", "exp", "(", ")", ".", "item", "(", ")", "*", "np", ".", "eye", "(", "len", "(", "cov", ")", ")", "\n", "", "", "return", "cov", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.predict": [[183, 198], ["models.GPR.model.eval", "models.GPR.likelihood.eval", "utils.to_torch", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "models.GPR.likelihood", "models.GPR.model", "models.GPR.covar().diag().cpu().numpy", "models.GPR.covar().evaluate().cpu().numpy", "models.GPR.covar().diag().cpu", "models.GPR.mean", "models.GPR.covar().evaluate().cpu", "models.GPR.covar().diag", "models.GPR.covar().evaluate", "models.GPR.covar", "models.GPR.covar"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch"], ["", "def", "predict", "(", "self", ",", "x", ",", "return_cov", "=", "False", ",", "return_std", "=", "False", ")", ":", "\n", "# returns posterior distribution conditioned on training data", "\n", "# call set_train_data method to set a different training data", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "likelihood", ".", "eval", "(", ")", "\n", "x_", "=", "to_torch", "(", "x", ")", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "pred", "=", "self", ".", "likelihood", "(", "self", ".", "model", "(", "x_", ")", ")", "\n", "pred_mean", "=", "(", "pred", ".", "mean", "(", ")", "+", "self", ".", "_train_y_mean", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "if", "return_std", ":", "\n", "                ", "return", "pred_mean", ",", "pred", ".", "covar", "(", ")", ".", "diag", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "elif", "return_cov", ":", "\n", "                ", "return", "pred_mean", ",", "pred", ".", "covar", "(", ")", ".", "evaluate", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "return", "pred_mean", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.get_embeddings": [[199, 204], ["torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "torch.no_grad", "utils.to_torch", "models.GPR.model.latent_func", "utils.to_numpy"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_numpy"], ["", "", "def", "get_embeddings", "(", "self", ",", "x", ")", ":", "\n", "        ", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "x_", "=", "to_torch", "(", "x", ")", "\n", "embeds", "=", "self", ".", "model", ".", "latent_func", "(", "x_", ")", "\n", "return", "to_numpy", "(", "embeds", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.ExactGPModel.__init__": [[207, 235], ["super().__init__", "models.ExactGPModel._set_latent_function", "gpytorch.means.ZeroMean", "train_x.size", "gpytorch.kernels.ScaleKernel", "gpytorch.kernels.WhiteNoiseKernel", "train_x.size", "gpytorch.kernels.RBFKernel", "gpytorch.kernels.ScaleKernel", "gpytorch.kernels.MaternKernel", "gpytorch.kernels.SpectralMixtureKernel", "models.ExactGPModel.kernel_covar_module.initialize_from_data", "train_x.size"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__", "home.repos.pwc.inspect_result.sumitsk_algp.None.models.ExactGPModel._set_latent_function"], ["    ", "def", "__init__", "(", "self", ",", "train_x", ",", "train_y", ",", "likelihood", ",", "var", "=", "None", ",", "latent", "=", "None", ",", "kernel_params", "=", "None", ",", "latent_params", "=", "None", ")", ":", "\n", "        ", "super", "(", "ExactGPModel", ",", "self", ")", ".", "__init__", "(", "train_x", ",", "train_y", ",", "likelihood", ")", "\n", "if", "latent_params", "is", "None", ":", "\n", "            ", "latent_params", "=", "{", "'input_dim'", ":", "train_x", ".", "size", "(", "-", "1", ")", "}", "\n", "", "self", ".", "_set_latent_function", "(", "latent", ",", "latent_params", ")", "\n", "\n", "self", ".", "mean_module", "=", "ZeroMean", "(", ")", "\n", "ard_num_dims", "=", "self", ".", "latent_func", ".", "embed_dim", "if", "self", ".", "latent_func", ".", "embed_dim", "is", "not", "None", "else", "train_x", ".", "size", "(", "-", "1", ")", "\n", "\n", "kernel", "=", "kernel_params", "[", "'type'", "]", "if", "kernel_params", "is", "not", "None", "else", "'rbf'", "\n", "if", "kernel", "is", "None", "or", "kernel", "==", "'rbf'", ":", "\n", "            ", "self", ".", "kernel_covar_module", "=", "ScaleKernel", "(", "RBFKernel", "(", "ard_num_dims", "=", "ard_num_dims", ")", ")", "\n", "", "elif", "kernel", "==", "'matern'", ":", "\n", "            ", "self", ".", "kernel_covar_module", "=", "ScaleKernel", "(", "MaternKernel", "(", "nu", "=", "1.5", ",", "ard_num_dims", "=", "ard_num_dims", ")", ")", "\n", "# without scale kernel: very poor performance", "\n", "# matern 0.5, 1.5 and 2.5 all have similar performance", "\n", "", "elif", "kernel", "==", "'spectral_mixture'", ":", "\n", "            ", "self", ".", "kernel_covar_module", "=", "SpectralMixtureKernel", "(", "num_mixtures", "=", "kernel_params", "[", "'n_mixtures'", "]", ",", "ard_num_dims", "=", "train_x", ".", "size", "(", "-", "1", ")", ")", "\n", "self", ".", "kernel_covar_module", ".", "initialize_from_data", "(", "train_x", ",", "train_y", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "# set covariance module", "\n", "", "if", "var", "is", "not", "None", ":", "\n", "            ", "self", ".", "noise_covar_module", "=", "WhiteNoiseKernel", "(", "var", ")", "\n", "self", ".", "covar_module", "=", "self", ".", "kernel_covar_module", "+", "self", ".", "noise_covar_module", "\n", "", "else", ":", "\n", "            ", "self", ".", "covar_module", "=", "self", ".", "kernel_covar_module", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.ExactGPModel._set_latent_function": [[236, 249], ["models.IdentityLatentFunction", "models.LinearLatentFunction", "models.NonLinearLatentFunction"], "methods", ["None"], ["", "", "def", "_set_latent_function", "(", "self", ",", "latent", ",", "latent_params", ")", ":", "\n", "        ", "if", "latent", "is", "None", "or", "latent", "==", "'identity'", ":", "\n", "            ", "self", ".", "latent_func", "=", "IdentityLatentFunction", "(", ")", "\n", "", "elif", "latent", "==", "'linear'", ":", "\n", "            ", "if", "'embed_dim'", "not", "in", "latent_params", ":", "\n", "                ", "latent_params", "[", "'embed_dim'", "]", "=", "6", "\n", "", "self", ".", "latent_func", "=", "LinearLatentFunction", "(", "latent_params", "[", "'input_dim'", "]", ",", "latent_params", "[", "'embed_dim'", "]", ")", "\n", "", "elif", "latent", "==", "'non_linear'", ":", "\n", "            ", "if", "'embed_dim'", "not", "in", "latent_params", ":", "\n", "                ", "latent_params", "[", "'embed_dim'", "]", "=", "6", "\n", "", "self", ".", "latent_func", "=", "NonLinearLatentFunction", "(", "latent_params", "[", "'input_dim'", "]", ",", "latent_params", "[", "'embed_dim'", "]", ",", "latent_params", "[", "'embed_dim'", "]", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.models.ExactGPModel.forward": [[250, 255], ["models.ExactGPModel.latent_func", "models.ExactGPModel.mean_module", "models.ExactGPModel.covar_module", "gpytorch.distributions.MultivariateNormal"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "x", "=", "self", ".", "latent_func", "(", "inp", ")", "\n", "mean_x", "=", "self", ".", "mean_module", "(", "x", ")", "\n", "covar_x", "=", "self", ".", "covar_module", "(", "x", ")", "\n", "return", "MultivariateNormal", "(", "mean_x", ",", "covar_x", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.edge_cost": [[7, 13], ["graph_utils.get_heading", "graph_utils.opposite_headings", "utils.manhattan_distance"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.opposite_headings", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance"], ["def", "edge_cost", "(", "node", ",", "heading", ",", "next_node", ")", ":", "\n", "# heading must be one from {(0,1), (0,-1), (1,0), (-1,0)}", "\n", "    ", "next_heading", "=", "get_heading", "(", "node", ",", "next_node", ")", "\n", "if", "opposite_headings", "(", "heading", ",", "next_heading", ")", ":", "\n", "        ", "return", "np", ".", "inf", "\n", "", "return", "manhattan_distance", "(", "node", ",", "next_node", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading": [[15, 26], ["abs", "abs"], "function", ["None"], ["", "def", "get_heading", "(", "node", ",", "next_node", ")", ":", "\n", "# return heading when robot moves from_node to next_node", "\n", "    ", "diff", "=", "(", "next_node", "[", "0", "]", "-", "node", "[", "0", "]", ",", "next_node", "[", "1", "]", "-", "node", "[", "1", "]", ")", "\n", "# return None if both nodes overlap", "\n", "if", "diff", "==", "(", "0", ",", "0", ")", ":", "\n", "        ", "return", "None", "\n", "\n", "", "if", "diff", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "(", "0", ",", "diff", "[", "1", "]", "//", "abs", "(", "diff", "[", "1", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "return", "(", "diff", "[", "0", "]", "//", "abs", "(", "diff", "[", "0", "]", ")", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_down_and_up_nodes": [[28, 39], ["graph_utils.in_between", "graph_utils.in_between"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.in_between", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.in_between"], ["", "", "def", "get_down_and_up_nodes", "(", "node", ",", "others", ",", "down_junction", ",", "up_junction", ")", ":", "\n", "# find nodes just above and below the current node", "\n", "    ", "down_node", ",", "up_node", "=", "down_junction", ",", "up_junction", "\n", "for", "nd", "in", "others", ":", "\n", "        ", "if", "nd", "==", "node", ":", "\n", "            ", "continue", "\n", "", "if", "in_between", "(", "nd", ",", "down_node", ",", "node", ")", ":", "\n", "            ", "down_node", "=", "nd", "\n", "", "if", "in_between", "(", "nd", ",", "node", ",", "up_node", ")", ":", "\n", "            ", "up_node", "=", "nd", "\n", "", "", "return", "down_node", ",", "up_node", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.in_between": [[41, 47], ["None"], "function", ["None"], ["", "def", "in_between", "(", "node", ",", "down_node", ",", "up_node", ")", ":", "\n", "# check if node lies between down and up", "\n", "    ", "if", "node", "[", "1", "]", "==", "down_node", "[", "1", "]", "and", "node", "[", "1", "]", "==", "up_node", "[", "1", "]", ":", "\n", "        ", "if", "down_node", "[", "0", "]", ">", "node", "[", "0", "]", ">", "up_node", "[", "0", "]", ":", "\n", "            ", "return", "True", "\n", "", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.lower_bound_path_cost": [[49, 64], ["numpy.vstack", "numpy.min", "numpy.max", "numpy.array", "min", "min", "sum", "sum"], "function", ["None"], ["", "def", "lower_bound_path_cost", "(", "pose", ",", "waypoints", ")", ":", "\n", "# return minimum cost of traversal to all the unvisited waypoints", "\n", "\n", "# boundaries of the bounding box", "\n", "    ", "all_locs", "=", "np", ".", "vstack", "(", "waypoints", "+", "[", "pose", "]", ")", "\n", "# TODO: this can be further tightened :", "\n", "# 1. if only one waypoint left (find the exact distance to go)", "\n", "# 2. if there are waypoints in columns other than the robot's, then use nearest junction for bounding box computation", "\n", "mins", "=", "np", ".", "min", "(", "all_locs", ",", "axis", "=", "0", ")", "\n", "maxs", "=", "np", ".", "max", "(", "all_locs", ",", "axis", "=", "0", ")", "\n", "t", "=", "np", ".", "array", "(", "pose", ")", "\n", "a", "=", "t", "-", "mins", "\n", "b", "=", "maxs", "-", "t", "\n", "dist", "=", "sum", "(", "a", ")", "+", "sum", "(", "b", ")", "+", "min", "(", "a", "[", "0", "]", ",", "b", "[", "0", "]", ")", "+", "min", "(", "a", "[", "1", "]", ",", "b", "[", "1", "]", ")", "\n", "return", "dist", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.opposite_headings": [[66, 72], ["None"], "function", ["None"], ["", "def", "opposite_headings", "(", "h0", ",", "h1", ")", ":", "\n", "# headings should be one from {(0,1), (0,-1), (1,0), (1,-1)}", "\n", "    ", "temp", "=", "h0", "[", "0", "]", "*", "h1", "[", "0", "]", "+", "h0", "[", "1", "]", "*", "h1", "[", "1", "]", "\n", "if", "temp", "==", "-", "1", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.path_cost": [[119, 126], ["range", "utils.manhattan_distance", "len"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance"], ["", "def", "path_cost", "(", "path", ")", ":", "\n", "# return total path length ", "\n", "# consecutive nodes of the path are either along x-axis or y-axis so distance = manhattan distance", "\n", "    ", "cost", "=", "0", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "        ", "cost", "+=", "manhattan_distance", "(", "path", "[", "i", "]", ",", "path", "[", "i", "+", "1", "]", ")", "\n", "", "return", "cost", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.find_merge_to_node": [[128, 136], ["len", "tree.nodes"], "function", ["None"], ["", "def", "find_merge_to_node", "(", "tree", ",", "node", ")", ":", "\n", "# all nodes in the graph with same attributes as node", "\n", "    ", "all_nodes", "=", "[", "n", "for", "n", "in", "tree", ".", "nodes", "(", ")", "if", "tree", ".", "node", "[", "n", "]", "==", "node", "]", "\n", "# if len(all_nodes) > 1:", "\n", "#     ipdb.set_trace()", "\n", "if", "len", "(", "all_nodes", ")", ">", "0", ":", "\n", "        ", "return", "all_nodes", "[", "0", "]", "\n", "", "return", "None", "", "", ""]], "home.repos.pwc.inspect_result.sumitsk_algp.None.arguments.get_args": [[7, 53], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "os.path.join", "str", "os.path.exists", "os.makedirs", "warnings.warn", "input", "sys.exit", "os.rename"], "function", ["None"], ["def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Adaptive Sampling and Informative Planning'", ")", "\n", "\n", "# gp model ", "\n", "parser", ".", "add_argument", "(", "'--lr'", ",", "default", "=", ".1", ",", "type", "=", "float", ",", "help", "=", "'learning rate of GP model'", ")", "\n", "parser", ".", "add_argument", "(", "'--max_iterations'", ",", "default", "=", "200", ",", "type", "=", "int", ",", "help", "=", "'number of training iterations for GP model'", ")", "\n", "parser", ".", "add_argument", "(", "'--data_file'", ",", "default", "=", "None", ",", "help", "=", "'pickle file to load data from'", ")", "\n", "parser", ".", "add_argument", "(", "'--phenotype'", ",", "default", "=", "'plant_height'", ",", "help", "=", "'target feature'", ")", "\n", "parser", ".", "add_argument", "(", "'--kernel'", ",", "default", "=", "'matern'", ",", "help", "=", "'kernel of GP model {rbf, matern}'", ")", "\n", "# parser.add_argument('--n_mixtures', default=4, help='number of spectral mixture components')", "\n", "parser", ".", "add_argument", "(", "'--latent'", ",", "default", "=", "None", ",", "help", "=", "'latent function in GP model'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--num_sims'", ",", "default", "=", "10", ",", "type", "=", "int", ",", "help", "=", "'number of simulations'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_runs'", ",", "default", "=", "6", ",", "type", "=", "int", ",", "help", "=", "'number of batches'", ")", "\n", "parser", ".", "add_argument", "(", "'--fraction_pretrain'", ",", "default", "=", ".75", ",", "type", "=", "float", ",", "help", "=", "'fraction of all training data used for learning hyperparameters'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_samples_per_batch'", ",", "default", "=", "4", ",", "type", "=", "int", ",", "help", "=", "'number of static samples collected in each batch'", ")", "\n", "parser", ".", "add_argument", "(", "'--slack'", ",", "default", "=", "0", ",", "type", "=", "int", ",", "help", "=", "'budget = shortest path length + slack'", ")", "\n", "parser", ".", "add_argument", "(", "'--num_test'", ",", "default", "=", "40", ",", "type", "=", "int", ",", "help", "=", "'number of test samples'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--update'", ",", "action", "=", "'store_true'", ",", "help", "=", "'update gp model'", ")", "\n", "parser", ".", "add_argument", "(", "'--update_every'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'update gp model every ... batch'", ")", "\n", "parser", ".", "add_argument", "(", "'--criterion'", ",", "default", "=", "'entropy'", ",", "help", "=", "'one from {mutual_information, entropy}'", ")", "\n", "# parser.add_argument('--mobile_std', default=.5, type=float, help='standard deviation of mobile measurements')", "\n", "parser", ".", "add_argument", "(", "'--static_std'", ",", "default", "=", ".1", ",", "type", "=", "float", ",", "help", "=", "'standard deviation of static measurements'", ")", "\n", "\n", "parser", ".", "add_argument", "(", "'--render'", ",", "action", "=", "'store_true'", ")", "\n", "parser", ".", "add_argument", "(", "'--seed'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'random seed'", ")", "\n", "parser", ".", "add_argument", "(", "'--id'", ",", "default", "=", "1", ",", "type", "=", "int", ",", "help", "=", "'unique id of every instance'", ")", "\n", "parser", ".", "add_argument", "(", "'--save_dir'", ",", "default", "=", "'results'", ",", "help", "=", "'save directory'", ")", "\n", "parser", ".", "add_argument", "(", "'--eval_only'", ",", "action", "=", "'store_true'", ",", "help", "=", "'will not save anything in this setting'", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "args", ".", "save_dir", "=", "os", ".", "path", ".", "join", "(", "args", ".", "save_dir", ",", "str", "(", "args", ".", "id", ")", ")", "\n", "if", "not", "args", ".", "eval_only", ":", "\n", "        ", "if", "os", ".", "path", ".", "exists", "(", "args", ".", "save_dir", ")", ":", "\n", "            ", "warnings", ".", "warn", "(", "'SAVE DIRECTORY ALREADY EXISTS!'", ")", "\n", "ch", "=", "input", "(", "'Press c to continue and s to stop: '", ")", "\n", "if", "ch", "==", "'s'", ":", "\n", "                ", "sys", ".", "exit", "(", "0", ")", "\n", "", "elif", "ch", "==", "'c'", ":", "\n", "                ", "os", ".", "rename", "(", "args", ".", "save_dir", ",", "args", ".", "save_dir", "+", "'_old'", ")", "\n", "", "elif", "ch", "!=", "'c'", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "\n", "", "", "os", ".", "makedirs", "(", "args", ".", "save_dir", ")", "\n", "", "return", "args", "", "", ""]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.__init__": [[13, 33], ["agent.Agent._init_model", "agent.Agent.reset", "int", "agent.Agent._pre_train", "agent.Agent.load_model", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._init_model", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._pre_train", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.load_model"], ["    ", "def", "__init__", "(", "self", ",", "env", ",", "args", ",", "parent_agent", "=", "None", ",", "learn_likelihood_noise", "=", "True", ",", "mobile_std", "=", "None", ",", "static_std", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", "\n", "self", ".", "env", "=", "env", "\n", "self", ".", "learn_likelihood_noise", "=", "learn_likelihood_noise", "\n", "self", ".", "_init_model", "(", "args", ")", "\n", "\n", "self", ".", "static_std", "=", "args", ".", "static_std", "if", "static_std", "is", "None", "else", "static_std", "\n", "self", ".", "mobile_std", "=", "10", "*", "self", ".", "static_std", "if", "mobile_std", "is", "None", "else", "mobile_std", "\n", "self", ".", "num_samples_per_batch", "=", "args", ".", "num_samples_per_batch", "\n", "self", ".", "update_every", "=", "args", ".", "update_every", "\n", "\n", "self", ".", "reset", "(", ")", "\n", "if", "parent_agent", "is", "None", ":", "\n", "            ", "num_pretrain", "=", "int", "(", "args", ".", "fraction_pretrain", "*", "self", ".", "env", ".", "num_samples", ")", "\n", "self", ".", "_pre_train", "(", "num_samples", "=", "num_pretrain", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "load_model", "(", "parent_agent", ")", "\n", "self", ".", "static_data", "=", "deepcopy", "(", "parent_agent", ".", "static_data", ")", "\n", "self", ".", "mobile_data", "=", "deepcopy", "(", "parent_agent", ".", "mobile_data", ")", "\n", "self", ".", "collected", "=", "deepcopy", "(", "parent_agent", ".", "collected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._init_model": [[34, 38], ["models.GPR"], "methods", ["None"], ["", "", "def", "_init_model", "(", "self", ",", "args", ")", ":", "\n", "        ", "kernel_params", "=", "{", "'type'", ":", "args", ".", "kernel", "}", "\n", "self", ".", "gp", "=", "GPR", "(", "latent", "=", "args", ".", "latent", ",", "lr", "=", "args", ".", "lr", ",", "max_iterations", "=", "args", ".", "max_iterations", ",", "kernel_params", "=", "kernel_params", ",", "\n", "learn_likelihood_noise", "=", "self", ".", "learn_likelihood_noise", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.load_model": [[39, 42], ["agent.Agent.gp.reset", "agent.Agent.gp.model.load_state_dict", "parent_agent.gp.model.state_dict"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset"], ["", "def", "load_model", "(", "self", ",", "parent_agent", ")", ":", "\n", "        ", "self", ".", "gp", ".", "reset", "(", "parent_agent", ".", "gp", ".", "train_x", ",", "parent_agent", ".", "gp", ".", "train_y", ",", "parent_agent", ".", "gp", ".", "train_var", ")", "\n", "self", ".", "gp", ".", "model", ".", "load_state_dict", "(", "parent_agent", ".", "gp", ".", "model", ".", "state_dict", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.save_model": [[43, 46], ["torch.save", "agent.Agent.gp.model.state_dict"], "methods", ["None"], ["", "def", "save_model", "(", "self", ",", "filename", ")", ":", "\n", "        ", "state", "=", "{", "'state_dict'", ":", "self", ".", "gp", ".", "model", ".", "state_dict", "(", ")", "}", "\n", "torch", ".", "save", "(", "state", ",", "filename", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset": [[47, 55], ["numpy.copy().reshape", "numpy.empty", "numpy.copy", "range", "range"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "        ", "self", ".", "pose", "=", "(", "0", ",", "0", ")", "\n", "self", ".", "heading", "=", "(", "1", ",", "0", ")", "\n", "self", ".", "path", "=", "np", ".", "copy", "(", "self", ".", "pose", ")", ".", "reshape", "(", "-", "1", ",", "2", ")", "\n", "self", ".", "collected", "=", "{", "'ind'", ":", "[", "]", ",", "'std'", ":", "[", "]", ",", "'y'", ":", "[", "]", "}", "\n", "self", ".", "static_locations", "=", "np", ".", "empty", "(", "(", "0", ",", "2", ")", ")", "\n", "self", ".", "static_data", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "env", ".", "num_samples", ")", "]", "\n", "self", ".", "mobile_data", "=", "[", "[", "]", "for", "_", "in", "range", "(", "self", ".", "env", ".", "num_samples", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._pre_train": [[56, 61], ["print", "print", "agent.Agent.pilot_survey", "agent.Agent.update_model"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.pilot_survey", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.update_model"], ["", "def", "_pre_train", "(", "self", ",", "num_samples", ")", ":", "\n", "        ", "print", "(", "'===================================================='", ")", "\n", "print", "(", "'--- Pretraining ---'", ")", "\n", "self", ".", "pilot_survey", "(", "num_samples", ",", "self", ".", "static_std", ")", "\n", "self", ".", "update_model", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.pilot_survey": [[62, 65], ["agent.Agent._add_samples", "numpy.random.permutation"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._add_samples"], ["", "def", "pilot_survey", "(", "self", ",", "num_samples", ",", "std", ")", ":", "\n", "        ", "ind", "=", "np", ".", "random", ".", "permutation", "(", "self", ".", "env", ".", "num_samples", ")", "[", ":", "num_samples", "]", "\n", "self", ".", "_add_samples", "(", "ind", ",", "stds", "=", "[", "std", "]", "*", "num_samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._add_samples": [[66, 83], ["range", "list", "list", "len", "len", "agent.Agent.env.collect_samples", "agent.Agent.static_data[].append", "agent.Agent.mobile_data[].append"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.collect_samples"], ["", "def", "_add_samples", "(", "self", ",", "indices", ",", "stds", ")", ":", "\n", "        ", "all_y", "=", "[", "None", "]", "*", "len", "(", "indices", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "indices", ")", ")", ":", "\n", "            ", "idx", "=", "indices", "[", "i", "]", "\n", "if", "idx", "==", "-", "1", ":", "\n", "                ", "continue", "\n", "", "y", "=", "self", ".", "env", ".", "collect_samples", "(", "idx", ",", "stds", "[", "i", "]", ")", "\n", "all_y", "[", "i", "]", "=", "y", "\n", "if", "stds", "[", "i", "]", "==", "self", ".", "static_std", ":", "\n", "                ", "self", ".", "static_data", "[", "idx", "]", ".", "append", "(", "y", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "mobile_data", "[", "idx", "]", ".", "append", "(", "y", ")", "\n", "\n", "# update collected", "\n", "", "", "self", ".", "collected", "[", "'ind'", "]", "+=", "list", "(", "indices", ")", "\n", "self", ".", "collected", "[", "'std'", "]", "+=", "list", "(", "stds", ")", "\n", "self", ".", "collected", "[", "'y'", "]", "+=", "all_y", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.update_model": [[84, 88], ["agent.Agent.get_sampled_dataset", "agent.Agent.gp.fit"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.get_sampled_dataset", "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.fit"], ["", "def", "update_model", "(", "self", ")", ":", "\n", "        ", "indices", ",", "y", ",", "var", "=", "self", ".", "get_sampled_dataset", "(", ")", "\n", "x", "=", "self", ".", "env", ".", "X", "[", "indices", "]", "\n", "self", ".", "gp", ".", "fit", "(", "x", ",", "y", ",", "var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._post_update": [[89, 91], ["agent.Agent.gp.cov_mat"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.cov_mat"], ["", "def", "_post_update", "(", "self", ")", ":", "\n", "        ", "self", ".", "cov_matrix", "=", "self", ".", "gp", ".", "cov_mat", "(", "x1", "=", "self", ".", "env", ".", "X", ",", "add_likelihood_var", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.get_sampled_dataset": [[92, 118], ["range", "all_y.append", "all_var.append", "indices.append", "numpy.array", "numpy.array", "numpy.mean", "numpy.mean", "len", "len", "len", "numpy.mean", "len", "numpy.mean"], "methods", ["None"], ["", "def", "get_sampled_dataset", "(", "self", ")", ":", "\n", "        ", "all_y", "=", "[", "]", "\n", "all_var", "=", "[", "]", "\n", "indices", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "self", ".", "env", ".", "num_samples", ")", ":", "\n", "            ", "if", "len", "(", "self", ".", "mobile_data", "[", "i", "]", ")", ">", "0", "and", "len", "(", "self", ".", "static_data", "[", "i", "]", ")", ">", "0", ":", "\n", "                ", "yc", "=", "np", ".", "mean", "(", "self", ".", "mobile_data", "[", "i", "]", ")", "\n", "ys", "=", "np", ".", "mean", "(", "self", ".", "static_data", "[", "i", "]", ")", "\n", "yeq", "=", "(", "self", ".", "mobile_std", "**", "2", "*", "ys", "+", "self", ".", "static_std", "**", "2", "*", "yc", ")", "/", "(", "self", ".", "mobile_std", "**", "2", "+", "self", ".", "static_std", "**", "2", ")", "\n", "var", "=", "1", "/", "(", "1", "/", "(", "self", ".", "static_std", "**", "2", ")", "+", "1", "/", "(", "self", ".", "mobile_std", "**", "2", ")", ")", "\n", "\n", "", "elif", "len", "(", "self", ".", "static_data", "[", "i", "]", ")", ">", "0", ":", "\n", "                ", "yeq", "=", "np", ".", "mean", "(", "self", ".", "static_data", "[", "i", "]", ")", "\n", "var", "=", "self", ".", "static_std", "**", "2", "\n", "\n", "", "elif", "len", "(", "self", ".", "mobile_data", "[", "i", "]", ")", ">", "0", ":", "\n", "                ", "yeq", "=", "np", ".", "mean", "(", "self", ".", "mobile_data", "[", "i", "]", ")", "\n", "var", "=", "self", ".", "mobile_std", "**", "2", "\n", "\n", "", "else", ":", "\n", "                ", "continue", "\n", "", "all_y", ".", "append", "(", "yeq", ")", "\n", "all_var", ".", "append", "(", "var", ")", "\n", "indices", ".", "append", "(", "i", ")", "\n", "\n", "", "return", "indices", ",", "np", ".", "array", "(", "all_y", ")", ",", "np", ".", "array", "(", "all_var", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._setup_ipp": [[119, 124], ["agent.Agent._post_update"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._post_update"], ["", "def", "_setup_ipp", "(", "self", ",", "criterion", ",", "update", "=", "False", ")", ":", "\n", "        ", "self", ".", "criterion", "=", "criterion", "\n", "# if not update:", "\n", "#     self.reset()", "\n", "self", ".", "_post_update", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_ipp": [[125, 230], ["agent.Agent._setup_ipp", "range", "print", "print", "print", "print", "print", "time.time", "agent.Agent.greedy", "numpy.stack", "numpy.concatenate().astype", "time.time", "agent.Agent.env.get_heuristic_cost", "agent.Agent.env.get_all_paths", "time.time", "time.time", "time.time", "agent.Agent.get_samples_sequence_from_path", "numpy.concatenate().astype", "tuple", "graph_utils.get_heading", "agent.Agent._add_samples", "time.time", "agent.Agent.predict", "utils.compute_mae", "test_error.append", "time.time", "time.time", "print", "print", "tuple", "print", "print", "print", "print", "print", "print", "utils.find_shortest_path", "agent.Agent.best_path", "min", "print", "print", "numpy.stack", "agent.Agent.predict().reshape", "agent.Agent.env.render", "time.time", "agent.Agent.update_model", "agent.Agent._post_update", "time.time", "print", "print", "print", "print", "print", "var.max", "var.min", "var.mean", "agent.Agent.env.gp_index_to_map_pose", "numpy.concatenate", "len", "utils.find_equi_sample_path", "agent.Agent.env.get_path_from_checkpoints", "numpy.concatenate", "print", "print", "agent.Agent.predict", "var.max", "var.min", "var.mean"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._setup_ipp", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.greedy", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_heuristic_cost", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_all_paths", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.get_samples_sequence_from_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._add_samples", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.find_shortest_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.best_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.update_model", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._post_update", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_index_to_map_pose", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.find_equi_sample_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_path_from_checkpoints", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict"], ["", "def", "run_ipp", "(", "self", ",", "render", "=", "False", ",", "num_runs", "=", "10", ",", "criterion", "=", "'entropy'", ",", "update", "=", "False", ",", "slack", "=", "0", ",", "strategy", "=", "'MaxEnt'", ",", "disp", "=", "True", ")", ":", "\n", "# informative path planner", "\n", "        ", "assert", "strategy", "in", "[", "'MaxEnt'", ",", "'Shortest'", ",", "'Equi-Sample'", "]", ",", "'Unknown strategy!!'", "\n", "assert", "criterion", "in", "[", "'entropy'", ",", "'mutual_information'", "]", ",", "'Unknown criterion!!'", "\n", "self", ".", "_setup_ipp", "(", "criterion", ",", "update", ")", "\n", "\n", "test_error", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_runs", ")", ":", "\n", "            ", "if", "disp", ":", "\n", "                ", "print", "(", "'\\n=================================================================================================='", ")", "\n", "print", "(", "'Run {}/{}'", ".", "format", "(", "i", "+", "1", ",", "num_runs", ")", ")", "\n", "\n", "", "run_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# greedily select static samples", "\n", "new_gp_indices", "=", "self", ".", "greedy", "(", "self", ".", "num_samples_per_batch", ")", "\n", "waypoints", "=", "[", "tuple", "(", "self", ".", "env", ".", "gp_index_to_map_pose", "(", "x", ")", ")", "for", "x", "in", "new_gp_indices", "]", "\n", "next_static_locations", "=", "np", ".", "stack", "(", "waypoints", ")", "\n", "self", ".", "static_locations", "=", "np", ".", "concatenate", "(", "[", "self", ".", "static_locations", ",", "next_static_locations", "]", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Gather data along path ", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'------ Finding valid paths ---------'", ")", "\n", "print", "(", "'Pose:'", ",", "self", ".", "pose", ",", "'Heading:'", ",", "self", ".", "heading", ",", "'Waypoints:'", ",", "waypoints", ")", "\n", "\n", "# find all paths ", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "least_cost_ub", "=", "self", ".", "env", ".", "get_heuristic_cost", "(", "self", ".", "pose", ",", "self", ".", "heading", ",", "waypoints", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'Least cost upper bound:'", ",", "least_cost_ub", ")", "\n", "", "paths_checkpoints", ",", "paths_indices", ",", "paths_cost", "=", "self", ".", "env", ".", "get_all_paths", "(", "self", ".", "pose", ",", "self", ".", "heading", ",", "waypoints", ",", "least_cost_ub", ",", "slack", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'Number of feasible paths: '", ",", "len", "(", "paths_indices", ")", ")", "\n", "print", "(", "'Time consumed {:.4f}'", ".", "format", "(", "end", "-", "start", ")", ")", "\n", "print", "(", "'\\n------ Finding best path ----------'", ")", "\n", "\n", "# find optimal path", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "if", "strategy", "==", "'Shortest'", ":", "\n", "                ", "best_idx", "=", "find_shortest_path", "(", "paths_cost", ")", "\n", "", "else", ":", "\n", "                ", "best_idx", "=", "self", ".", "best_path", "(", "paths_indices", ",", "new_gp_indices", ")", "\n", "if", "strategy", "==", "'Equi-Sample'", ":", "\n", "                    ", "best_idx", "=", "find_equi_sample_path", "(", "paths_indices", ",", "best_idx", ")", "\n", "", "", "end", "=", "time", ".", "time", "(", ")", "\n", "\n", "if", "disp", ":", "\n", "                ", "least_cost", "=", "min", "(", "paths_cost", ")", "\n", "print", "(", "'Least cost: {} Best path cost: {}'", ".", "format", "(", "least_cost", ",", "paths_cost", "[", "best_idx", "]", ")", ")", "\n", "print", "(", "'Time consumed {:.4f}'", ".", "format", "(", "end", "-", "start", ")", ")", "\n", "\n", "# update agent's record", "\n", "", "next_path", "=", "np", ".", "stack", "(", "self", ".", "env", ".", "get_path_from_checkpoints", "(", "paths_checkpoints", "[", "best_idx", "]", ")", ")", "[", "1", ":", "]", "\n", "next_path_indices", ",", "stds", "=", "self", ".", "get_samples_sequence_from_path", "(", "next_path", ",", "waypoints", ")", "\n", "self", ".", "path", "=", "np", ".", "concatenate", "(", "[", "self", ".", "path", ",", "next_path", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "pose", "=", "tuple", "(", "self", ".", "path", "[", "-", "1", "]", ")", "\n", "self", ".", "heading", "=", "get_heading", "(", "self", ".", "path", "[", "-", "2", "]", ",", "self", ".", "path", "[", "-", "1", "]", ")", "\n", "\n", "if", "render", ":", "\n", "                ", "pred", "=", "self", ".", "predict", "(", "self", ".", "env", ".", "all_x", ")", ".", "reshape", "(", "self", ".", "env", ".", "shape", ")", "\n", "# true = self.env.all_y.reshape(self.env.shape)", "\n", "# self.env.render(paths_checkpoints[best_idx], self.path, next_static_locations, self.static_locations, true, pred)", "\n", "self", ".", "env", ".", "render", "(", "paths_checkpoints", "[", "best_idx", "]", ",", "self", ".", "path", ",", "next_static_locations", ",", "self", ".", "static_locations", ")", "\n", "\n", "# gather samples", "\n", "", "self", ".", "_add_samples", "(", "next_path_indices", ",", "stds", ")", "\n", "\n", "# update hyperparameters of GP model", "\n", "# TODO: this may not work properly right now", "\n", "if", "update", "and", "(", "i", "+", "1", ")", "%", "self", ".", "update_every", "==", "0", ":", "\n", "                ", "if", "disp", ":", "\n", "                    ", "print", "(", "'\\n---------- Updating model --------------'", ")", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "update_model", "(", ")", "\n", "self", ".", "_post_update", "(", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "if", "disp", ":", "\n", "                    ", "print", "(", "'Time consumed {:.4f}'", ".", "format", "(", "end", "-", "start", ")", ")", "\n", "\n", "# predict on test set", "\n", "", "", "if", "disp", ":", "\n", "                ", "print", "(", "'\\n-------- Prediction -------------- '", ")", "\n", "", "start", "=", "time", ".", "time", "(", ")", "\n", "pred", ",", "var", "=", "self", ".", "predict", "(", "return_var", "=", "True", ")", "\n", "error", "=", "compute_mae", "(", "self", ".", "env", ".", "test_Y", ",", "pred", ")", "\n", "test_error", ".", "append", "(", "error", ")", "\n", "end", "=", "time", ".", "time", "(", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'Test ERROR: {:.4f}'", ".", "format", "(", "error", ")", ")", "\n", "print", "(", "'Predictive Variance Max: {:.3f} Min: {:.3f} Mean: {:.3f}'", ".", "format", "(", "var", ".", "max", "(", ")", ",", "var", ".", "min", "(", ")", ",", "var", ".", "mean", "(", ")", ")", ")", "\n", "print", "(", "'Time consumed {:.4f}'", ".", "format", "(", "end", "-", "start", ")", ")", "\n", "\n", "", "run_end", "=", "time", ".", "time", "(", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'\\nTotal Time consumed in run {}: {:.4f}'", ".", "format", "(", "i", "+", "1", ",", "run_end", "-", "run_start", ")", ")", "\n", "\n", "", "", "print", "(", "'=========================================================='", ")", "\n", "print", "(", "'Strategy: {:s}'", ".", "format", "(", "strategy", ")", ")", "\n", "print", "(", "'--- Final statistics --- '", ")", "\n", "print", "(", "'Test ERROR: {:.4f}'", ".", "format", "(", "error", ")", ")", "\n", "print", "(", "'Predictive Variance Max: {:.3f} Min: {:.3f} Mean: {:.3f}'", ".", "format", "(", "var", ".", "max", "(", ")", ",", "var", ".", "min", "(", ")", ",", "var", ".", "mean", "(", ")", ")", ")", "\n", "results", "=", "{", "'mean'", ":", "pred", ",", "'error'", ":", "test_error", "}", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_greedy_ipp": [[231, 288], ["agent.Agent._setup_ipp", "range", "agent.Agent.predict", "utils.compute_mae", "print", "print", "print", "print", "print", "print", "time.time", "agent.Agent.greedy", "numpy.stack", "numpy.concatenate().astype", "agent.Agent.env.map.nearest_waypoint_path_cost", "range", "time.time", "print", "print", "tuple", "print", "print", "len", "agent.Agent.env.get_all_paths", "agent.Agent.get_samples_sequence_from_path", "numpy.concatenate().astype", "tuple", "graph_utils.get_heading", "agent.Agent._add_samples", "print", "var.max", "var.min", "var.mean", "agent.Agent.env.gp_index_to_map_pose", "numpy.concatenate", "utils.find_shortest_path", "agent.Agent.best_path", "numpy.stack", "utils.find_equi_sample_path", "agent.Agent.env.get_path_from_checkpoints", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._setup_ipp", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.greedy", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.nearest_waypoint_path_cost", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_all_paths", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.get_samples_sequence_from_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._add_samples", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_index_to_map_pose", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.find_shortest_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.best_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.find_equi_sample_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_path_from_checkpoints"], ["", "def", "run_greedy_ipp", "(", "self", ",", "num_runs", "=", "10", ",", "criterion", "=", "'entropy'", ",", "strategy", "=", "'MaxEnt'", ",", "disp", "=", "True", ")", ":", "\n", "        ", "self", ".", "_setup_ipp", "(", "criterion", ")", "\n", "\n", "for", "i", "in", "range", "(", "num_runs", ")", ":", "\n", "            ", "print", "(", "i", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'\\n=================================================================================================='", ")", "\n", "print", "(", "'Run {}/{}'", ".", "format", "(", "i", "+", "1", ",", "num_runs", ")", ")", "\n", "\n", "", "run_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "# greedily select static samples", "\n", "new_gp_indices", "=", "self", ".", "greedy", "(", "self", ".", "num_samples_per_batch", ")", "\n", "waypoints", "=", "[", "tuple", "(", "self", ".", "env", ".", "gp_index_to_map_pose", "(", "x", ")", ")", "for", "x", "in", "new_gp_indices", "]", "\n", "next_static_locations", "=", "np", ".", "stack", "(", "waypoints", ")", "\n", "self", ".", "static_locations", "=", "np", ".", "concatenate", "(", "[", "self", ".", "static_locations", ",", "next_static_locations", "]", ")", ".", "astype", "(", "int", ")", "\n", "\n", "# Gather data along path ", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'------ Finding valid paths ---------'", ")", "\n", "print", "(", "'Pose:'", ",", "self", ".", "pose", ",", "'Heading:'", ",", "self", ".", "heading", ",", "'Waypoints:'", ",", "waypoints", ")", "\n", "\n", "# move to the nearest waypoint", "\n", "", "costs", ",", "seq", "=", "self", ".", "env", ".", "map", ".", "nearest_waypoint_path_cost", "(", "self", ".", "pose", ",", "self", ".", "heading", ",", "waypoints", ",", "return_seq", "=", "True", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "seq", ")", ")", ":", "\n", "                ", "paths_checkpoints", ",", "paths_indices", ",", "paths_cost", "=", "self", ".", "env", ".", "get_all_paths", "(", "self", ".", "pose", ",", "self", ".", "heading", ",", "\n", "[", "waypoints", "[", "seq", "[", "i", "]", "]", "]", ",", "costs", "[", "i", "]", ",", "slack", "=", "0", ")", "\n", "assert", "costs", "[", "i", "]", "==", "paths_cost", "[", "0", "]", ",", "'path costs do not match'", "\n", "\n", "# find optimal path", "\n", "if", "strategy", "==", "'Shortest'", ":", "\n", "                    ", "best_idx", "=", "find_shortest_path", "(", "paths_cost", ")", "\n", "", "else", ":", "\n", "                    ", "best_idx", "=", "self", ".", "best_path", "(", "paths_indices", ",", "[", "new_gp_indices", "[", "seq", "[", "i", "]", "]", "]", ")", "\n", "if", "strategy", "==", "'Equi-Sample'", ":", "\n", "                        ", "best_idx", "=", "find_equi_sample_path", "(", "paths_indices", ",", "best_idx", ")", "\n", "\n", "", "", "next_path", "=", "np", ".", "stack", "(", "self", ".", "env", ".", "get_path_from_checkpoints", "(", "paths_checkpoints", "[", "best_idx", "]", ")", ")", "[", "1", ":", "]", "\n", "next_path_indices", ",", "stds", "=", "self", ".", "get_samples_sequence_from_path", "(", "next_path", ",", "waypoints", ")", "\n", "self", ".", "path", "=", "np", ".", "concatenate", "(", "[", "self", ".", "path", ",", "next_path", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "pose", "=", "tuple", "(", "self", ".", "path", "[", "-", "1", "]", ")", "\n", "self", ".", "heading", "=", "get_heading", "(", "self", ".", "path", "[", "-", "2", "]", ",", "self", ".", "path", "[", "-", "1", "]", ")", "\n", "\n", "# gather samples", "\n", "self", ".", "_add_samples", "(", "next_path_indices", ",", "stds", ")", "\n", "\n", "", "run_end", "=", "time", ".", "time", "(", ")", "\n", "if", "disp", ":", "\n", "                ", "print", "(", "'\\nTotal Time consumed in run {}: {:.4f}'", ".", "format", "(", "i", "+", "1", ",", "run_end", "-", "run_start", ")", ")", "\n", "\n", "", "", "pred", ",", "var", "=", "self", ".", "predict", "(", "return_var", "=", "True", ")", "\n", "error", "=", "compute_mae", "(", "self", ".", "env", ".", "test_Y", ",", "pred", ")", "\n", "print", "(", "'=========================================================='", ")", "\n", "print", "(", "'Strategy: {:s}'", ".", "format", "(", "strategy", ")", ")", "\n", "print", "(", "'--- Final statistics --- '", ")", "\n", "print", "(", "'Test ERROR: {:.4f}'", ".", "format", "(", "error", ")", ")", "\n", "print", "(", "'Predictive Variance Max: {:.3f} Min: {:.3f} Mean: {:.3f}'", ".", "format", "(", "var", ".", "max", "(", ")", ",", "var", ".", "min", "(", ")", ",", "var", ".", "mean", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict": [[289, 294], ["agent.Agent.get_sampled_dataset", "utils.predictive_distribution"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.get_sampled_dataset", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.predictive_distribution"], ["", "def", "predict", "(", "self", ",", "x", "=", "None", ",", "return_var", "=", "False", ",", "return_cov", "=", "False", ",", "return_mi", "=", "False", ")", ":", "\n", "        ", "x", "=", "self", ".", "env", ".", "test_X", "if", "x", "is", "None", "else", "x", "\n", "train_ind", ",", "train_y", ",", "train_var", "=", "self", ".", "get_sampled_dataset", "(", ")", "\n", "train_x", "=", "self", ".", "env", ".", "X", "[", "train_ind", "]", "\n", "return", "predictive_distribution", "(", "self", ".", "gp", ",", "train_x", ",", "train_y", ",", "x", ",", "train_var", ",", "return_var", "=", "return_var", ",", "return_cov", "=", "return_cov", ",", "return_mi", "=", "return_mi", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.greedy": [[295, 357], ["numpy.array", "numpy.full", "numpy.array", "numpy.full", "utils.entropy_from_cov", "range", "numpy.diag", "numpy.full", "range", "numpy.argmax", "cumm_utilities.append", "new_samples.append", "sum", "utils.entropy_from_cov", "numpy.diag", "utils.entropy_from_cov", "utils.entropy_from_cov", "len", "len", "numpy.diag"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov"], ["", "def", "greedy", "(", "self", ",", "num_samples", ")", ":", "\n", "# select most informative samples in a greedy manner", "\n", "        ", "n", "=", "self", ".", "env", ".", "num_samples", "\n", "mobile_sampled", "=", "np", ".", "array", "(", "[", "False", "if", "len", "(", "x", ")", "==", "0", "else", "True", "for", "x", "in", "self", ".", "mobile_data", "]", ")", "\n", "mobile_var", "=", "np", ".", "full", "(", "n", ",", "np", ".", "inf", ")", "\n", "mobile_var", "[", "mobile_sampled", "]", "=", "self", ".", "mobile_std", "**", "2", "\n", "\n", "static_sampled", "=", "np", ".", "array", "(", "[", "False", "if", "len", "(", "x", ")", "==", "0", "else", "True", "for", "x", "in", "self", ".", "static_data", "]", ")", "\n", "static_var", "=", "np", ".", "full", "(", "n", ",", "np", ".", "inf", ")", "\n", "static_var", "[", "static_sampled", "]", "=", "self", ".", "static_std", "**", "2", "\n", "\n", "sampled", "=", "static_sampled", "|", "mobile_sampled", "\n", "var", "=", "1.0", "/", "(", "1.0", "/", "static_var", "[", "sampled", "]", "+", "1.0", "/", "mobile_var", "[", "sampled", "]", ")", "\n", "cov_v", "=", "self", ".", "cov_matrix", "[", "sampled", "]", ".", "T", "[", "sampled", "]", ".", "T", "+", "np", ".", "diag", "(", "var", ")", "\n", "ent_v", "=", "entropy_from_cov", "(", "cov_v", ")", "\n", "\n", "cumm_utilities", "=", "[", "]", "\n", "new_samples", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_samples", ")", ":", "\n", "            ", "utilities", "=", "np", ".", "full", "(", "n", ",", "-", "np", ".", "inf", ")", "\n", "cond", "=", "ent_v", "+", "sum", "(", "cumm_utilities", ")", "\n", "\n", "for", "i", "in", "range", "(", "n", ")", ":", "\n", "                ", "if", "static_sampled", "[", "i", "]", ":", "\n", "                    ", "continue", "\n", "\n", "# modify sampled (temporarily)", "\n", "", "static_sampled", "[", "i", "]", "=", "True", "\n", "static_var", "[", "i", "]", "=", "self", ".", "static_std", "**", "2", "\n", "sampled", "=", "static_sampled", "|", "mobile_sampled", "\n", "var", "=", "1.0", "/", "(", "1.0", "/", "static_var", "[", "sampled", "]", "+", "1.0", "/", "mobile_var", "[", "sampled", "]", ")", "\n", "\n", "# a - set of all sampled locations ", "\n", "cov_a", "=", "self", ".", "cov_matrix", "[", "sampled", "]", ".", "T", "[", "sampled", "]", ".", "T", "+", "np", ".", "diag", "(", "var", ")", "\n", "ent_a", "=", "entropy_from_cov", "(", "cov_a", ")", "\n", "if", "self", ".", "criterion", "==", "'mutual_information'", ":", "\n", "                    ", "cov_abar", "=", "self", ".", "cov_matrix", "[", "~", "sampled", "]", ".", "T", "[", "~", "sampled", "]", ".", "T", "\n", "ent_abar", "=", "entropy_from_cov", "(", "cov_abar", ")", "\n", "\n", "precision", "=", "1.0", "/", "static_var", "+", "1.0", "/", "mobile_var", "\n", "precision", "[", "precision", "==", "0", "]", "=", "np", ".", "inf", "\n", "var", "=", "1.0", "/", "precision", "\n", "cov_all", "=", "self", ".", "cov_matrix", "+", "np", ".", "diag", "(", "var", ")", "\n", "ent_all", "=", "entropy_from_cov", "(", "cov_all", ")", "\n", "ut", "=", "ent_a", "+", "ent_abar", "-", "ent_all", "\n", "", "else", ":", "\n", "                    ", "ut", "=", "ent_a", "-", "cond", "\n", "\n", "", "utilities", "[", "i", "]", "=", "ut", "\n", "\n", "# reset sampled", "\n", "static_sampled", "[", "i", "]", "=", "False", "\n", "static_var", "[", "i", "]", "=", "np", ".", "inf", "\n", "\n", "", "best_sample", "=", "np", ".", "argmax", "(", "utilities", ")", "\n", "cumm_utilities", ".", "append", "(", "utilities", "[", "best_sample", "]", ")", "\n", "new_samples", ".", "append", "(", "best_sample", ")", "\n", "# update sampled", "\n", "static_sampled", "[", "best_sample", "]", "=", "True", "\n", "static_var", "[", "best_sample", "]", "=", "self", ".", "static_std", "**", "2", "\n", "\n", "", "return", "new_samples", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.best_path": [[358, 404], ["numpy.array", "numpy.array", "numpy.full", "range", "numpy.argmax", "len", "len", "numpy.copy", "numpy.full", "utils.entropy_from_cov", "all_ut.append", "numpy.diag", "utils.entropy_from_cov", "utils.entropy_from_cov", "numpy.diag", "len", "len"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov"], ["", "def", "best_path", "(", "self", ",", "paths_mobile_indices", ",", "static_indices", ")", ":", "\n", "# paths_indices contains mobile sensing indices on the path", "\n", "# static_indices is the set of static sensing indices ", "\n", "\n", "        ", "if", "len", "(", "paths_mobile_indices", ")", "==", "1", ":", "\n", "            ", "return", "0", "\n", "\n", "", "n", "=", "self", ".", "env", ".", "num_samples", "\n", "org_mobile_sampled", "=", "np", ".", "array", "(", "[", "False", "if", "len", "(", "x", ")", "==", "0", "else", "True", "for", "x", "in", "self", ".", "mobile_data", "]", ")", "\n", "\n", "static_sampled", "=", "np", ".", "array", "(", "[", "False", "if", "len", "(", "x", ")", "==", "0", "else", "True", "for", "x", "in", "self", ".", "static_data", "]", ")", "\n", "static_sampled", "[", "static_indices", "]", "=", "True", "\n", "static_var", "=", "np", ".", "full", "(", "n", ",", "np", ".", "inf", ")", "\n", "static_var", "[", "static_sampled", "]", "=", "self", ".", "static_std", "**", "2", "\n", "\n", "all_ut", "=", "[", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "paths_mobile_indices", ")", ")", ":", "\n", "            ", "mobile_sampled", "=", "np", ".", "copy", "(", "org_mobile_sampled", ")", "\n", "mobile_indices", "=", "paths_mobile_indices", "[", "i", "]", "\n", "mobile_sampled", "[", "mobile_indices", "]", "=", "True", "\n", "\n", "mobile_var", "=", "np", ".", "full", "(", "n", ",", "np", ".", "inf", ")", "\n", "mobile_var", "[", "mobile_sampled", "]", "=", "self", ".", "mobile_std", "**", "2", "\n", "\n", "sampled", "=", "static_sampled", "|", "mobile_sampled", "\n", "var", "=", "1.0", "/", "(", "1.0", "/", "static_var", "[", "sampled", "]", "+", "1.0", "/", "mobile_var", "[", "sampled", "]", ")", "\n", "\n", "# a - set of all sampled locations ", "\n", "cov_a", "=", "self", ".", "cov_matrix", "[", "sampled", "]", ".", "T", "[", "sampled", "]", ".", "T", "+", "np", ".", "diag", "(", "var", ")", "\n", "ent_a", "=", "entropy_from_cov", "(", "cov_a", ")", "\n", "if", "self", ".", "criterion", "==", "'mutual_information'", ":", "\n", "                ", "cov_abar", "=", "self", ".", "cov_matrix", "[", "~", "sampled", "]", ".", "T", "[", "~", "sampled", "]", ".", "T", "\n", "ent_abar", "=", "entropy_from_cov", "(", "cov_abar", ")", "\n", "\n", "precision", "=", "1.0", "/", "static_var", "+", "1.0", "/", "mobile_var", "\n", "precision", "[", "precision", "==", "0", "]", "=", "np", ".", "inf", "\n", "var", "=", "1.0", "/", "precision", "\n", "cov_all", "=", "self", ".", "cov_matrix", "+", "np", ".", "diag", "(", "var", ")", "\n", "ent_all", "=", "entropy_from_cov", "(", "cov_all", ")", "\n", "ut", "=", "ent_a", "+", "ent_abar", "-", "ent_all", "\n", "", "else", ":", "\n", "                ", "ut", "=", "ent_a", "\n", "", "all_ut", ".", "append", "(", "ut", ")", "\n", "\n", "", "idx", "=", "np", ".", "argmax", "(", "all_ut", ")", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_naive": [[405, 474], ["numpy.diag", "print", "print", "print", "print", "print", "agent.Agent._add_samples", "agent.Agent.predict", "utils.compute_mae", "test_error.append", "all_mi.append", "all_var.append", "numpy.diag().mean", "numpy.diag.max", "numpy.diag.min", "numpy.diag.mean", "inds.append", "len", "numpy.concatenate().astype", "len", "numpy.concatenate().astype", "numpy.diag", "numpy.concatenate().astype", "numpy.concatenate().astype", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent._add_samples", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae"], ["", "def", "run_naive", "(", "self", ",", "std", ",", "counts", ",", "metric", "=", "'distance'", ")", ":", "\n", "# traverse each row from start to end in a naive manner", "\n", "# counts should be list of ints", "\n", "# metric - either distance or sample", "\n", "\n", "        ", "test_error", "=", "[", "]", "\n", "all_mi", "=", "[", "]", "\n", "all_var", "=", "[", "]", "\n", "\n", "for", "ns", "in", "counts", ":", "\n", "            ", "inds", "=", "[", "]", "\n", "c", "=", "0", "\n", "done", "=", "False", "\n", "while", "not", "done", ":", "\n", "# keep moving in the heading direction till you reach the end and need to shift to the next array", "\n", "                ", "next_pose", "=", "(", "self", ".", "pose", "[", "0", "]", "+", "self", ".", "heading", "[", "0", "]", ",", "self", ".", "pose", "[", "1", "]", "+", "self", ".", "heading", "[", "1", "]", ")", "\n", "ind", "=", "self", ".", "env", ".", "map_pose_to_gp_index_matrix", "[", "next_pose", "]", "\n", "if", "ind", "is", "not", "None", ":", "\n", "                    ", "inds", ".", "append", "(", "ind", ")", "\n", "\n", "", "if", "metric", "==", "'samples'", ":", "\n", "                    ", "if", "next_pose", "[", "0", "]", "==", "self", ".", "env", ".", "map", ".", "shape", "[", "0", "]", "-", "1", ":", "\n", "                        ", "poses", "=", "[", "next_pose", ",", "(", "next_pose", "[", "0", "]", ",", "next_pose", "[", "1", "]", "+", "1", ")", ",", "(", "next_pose", "[", "0", "]", ",", "next_pose", "[", "1", "]", "+", "2", ")", ",", "(", "next_pose", "[", "0", "]", "-", "1", ",", "next_pose", "[", "1", "]", "+", "2", ")", "]", "\n", "self", ".", "path", "=", "np", ".", "concatenate", "(", "[", "self", ".", "path", ",", "poses", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "heading", "=", "(", "-", "self", ".", "heading", "[", "0", "]", ",", "0", ")", "\n", "self", ".", "pose", "=", "poses", "[", "-", "1", "]", "\n", "\n", "", "elif", "next_pose", "[", "0", "]", "==", "0", ":", "\n", "                        ", "poses", "=", "[", "next_pose", ",", "(", "next_pose", "[", "0", "]", ",", "next_pose", "[", "1", "]", "+", "1", ")", ",", "(", "next_pose", "[", "0", "]", ",", "next_pose", "[", "1", "]", "+", "2", ")", ",", "(", "next_pose", "[", "0", "]", "+", "1", ",", "next_pose", "[", "1", "]", "+", "2", ")", "]", "\n", "self", ".", "path", "=", "np", ".", "concatenate", "(", "[", "self", ".", "path", ",", "poses", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "heading", "=", "(", "-", "self", ".", "heading", "[", "0", "]", ",", "0", ")", "\n", "self", ".", "pose", "=", "poses", "[", "-", "1", "]", "\n", "\n", "", "else", ":", "\n", "                        ", "self", ".", "path", "=", "np", ".", "concatenate", "(", "[", "self", ".", "path", ",", "[", "next_pose", "]", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "self", ".", "pose", "=", "next_pose", "\n", "\n", "", "done", "=", "len", "(", "inds", ")", "==", "ns", "\n", "\n", "", "elif", "metric", "==", "'distance'", ":", "\n", "                    ", "c", "+=", "1", "\n", "self", ".", "path", "=", "np", ".", "concatenate", "(", "[", "self", ".", "path", ",", "[", "next_pose", "]", "]", ",", "axis", "=", "0", ")", ".", "astype", "(", "int", ")", "\n", "if", "next_pose", "[", "0", "]", "==", "0", "and", "next_pose", "[", "1", "]", "%", "2", "==", "0", ":", "\n", "                        ", "self", ".", "heading", "=", "(", "0", ",", "1", ")", "if", "self", ".", "heading", "==", "(", "-", "1", ",", "0", ")", "else", "(", "1", ",", "0", ")", "\n", "", "elif", "next_pose", "[", "0", "]", "==", "self", ".", "env", ".", "map", ".", "shape", "[", "0", "]", "-", "1", "and", "next_pose", "[", "1", "]", "%", "2", "==", "0", ":", "\n", "                        ", "self", ".", "heading", "=", "(", "0", ",", "1", ")", "if", "self", ".", "heading", "==", "(", "1", ",", "0", ")", "else", "(", "-", "1", ",", "0", ")", "\n", "", "self", ".", "pose", "=", "next_pose", "\n", "done", "=", "c", "==", "ns", "\n", "", "else", ":", "\n", "                    ", "raise", "NotImplementedError", "\n", "\n", "", "", "self", ".", "_add_samples", "(", "inds", ",", "[", "std", "]", "*", "len", "(", "inds", ")", ")", "\n", "mu", ",", "cov", ",", "mi", "=", "self", ".", "predict", "(", "return_cov", "=", "True", ",", "return_mi", "=", "True", ")", "\n", "error", "=", "compute_mae", "(", "self", ".", "env", ".", "test_Y", ",", "mu", ")", "\n", "test_error", ".", "append", "(", "error", ")", "\n", "all_mi", ".", "append", "(", "mi", ")", "\n", "all_var", ".", "append", "(", "np", ".", "diag", "(", "cov", ")", ".", "mean", "(", ")", ")", "\n", "\n", "# TODO: implement simulation rendering ", "\n", "\n", "", "var", "=", "np", ".", "diag", "(", "cov", ")", "\n", "strategy", "=", "'Naive Static'", "if", "std", "==", "self", ".", "static_std", "else", "'Naive Mobile'", "\n", "print", "(", "'=========================================================='", ")", "\n", "print", "(", "'Strategy: '", ",", "strategy", ")", "\n", "print", "(", "'--- Final statistics --- '", ")", "\n", "print", "(", "'Test ERROR: {:.4f}'", ".", "format", "(", "error", ")", ")", "\n", "print", "(", "'Predictive Variance Max: {:.3f} Min: {:.3f} Mean: {:.3f}'", ".", "format", "(", "var", ".", "max", "(", ")", ",", "var", ".", "min", "(", ")", ",", "var", ".", "mean", "(", ")", ")", ")", "\n", "results", "=", "{", "'mean'", ":", "mu", ",", "'error'", ":", "test_error", ",", "'mi'", ":", "all_mi", ",", "'mean_var'", ":", "all_var", "}", "\n", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.get_samples_sequence_from_path": [[475, 496], ["len", "tuple", "indices.append", "std.append", "waypoints.index", "std.append", "std.append", "std.append"], "methods", ["None"], ["", "def", "get_samples_sequence_from_path", "(", "self", ",", "path", ",", "waypoints", ")", ":", "\n", "        ", "indices", "=", "[", "]", "\n", "std", "=", "[", "]", "\n", "sampled", "=", "[", "False", "]", "*", "len", "(", "waypoints", ")", "\n", "for", "loc", "in", "path", ":", "\n", "            ", "loc", "=", "tuple", "(", "loc", ")", "\n", "gp_index", "=", "self", ".", "env", ".", "map_pose_to_gp_index_matrix", "[", "loc", "]", "\n", "indices", ".", "append", "(", "gp_index", "if", "gp_index", "is", "not", "None", "else", "-", "1", ")", "\n", "if", "gp_index", "is", "not", "None", ":", "\n", "                ", "if", "loc", "in", "waypoints", ":", "\n", "                    ", "idx", "=", "waypoints", ".", "index", "(", "loc", ")", "\n", "if", "not", "sampled", "[", "idx", "]", ":", "\n", "                        ", "std", ".", "append", "(", "self", ".", "static_std", ")", "\n", "sampled", "[", "idx", "]", "=", "True", "\n", "", "else", ":", "\n", "                        ", "std", ".", "append", "(", "self", ".", "mobile_std", ")", "\n", "", "", "else", ":", "\n", "                    ", "std", ".", "append", "(", "self", ".", "mobile_std", ")", "\n", "", "", "else", ":", "\n", "                ", "std", ".", "append", "(", "-", "1", ")", "\n", "", "", "return", "indices", ",", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.prediction_vs_distance": [[497, 519], ["numpy.array", "utils.predictive_distribution", "utils.compute_mae", "all_error.append", "all_mi.append", "all_var.append", "numpy.diag().mean", "numpy.array", "numpy.array", "numpy.diag"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.predictive_distribution", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae"], ["", "def", "prediction_vs_distance", "(", "self", ",", "test_every", ",", "num_runs", ")", ":", "\n", "        ", "count", "=", "0", "\n", "all_error", "=", "[", "]", "\n", "all_mi", "=", "[", "]", "\n", "all_var", "=", "[", "]", "\n", "\n", "while", "count", "<", "test_every", "*", "num_runs", ":", "\n", "            ", "count", "+=", "test_every", "\n", "inds", "=", "np", ".", "array", "(", "self", ".", "collected", "[", "'ind'", "]", "[", ":", "count", "]", ")", "\n", "valid", "=", "inds", "!=", "-", "1", "\n", "\n", "x", "=", "self", ".", "env", ".", "X", "[", "inds", "[", "valid", "]", "]", "\n", "var", "=", "np", ".", "array", "(", "self", ".", "collected", "[", "'std'", "]", ")", "[", ":", "count", "]", "[", "valid", "]", "**", "2", "\n", "y", "=", "np", ".", "array", "(", "self", ".", "collected", "[", "'y'", "]", ")", "[", ":", "count", "]", "[", "valid", "]", "\n", "mu", ",", "cov", ",", "mi", "=", "predictive_distribution", "(", "self", ".", "gp", ",", "x", ",", "y", ",", "self", ".", "env", ".", "test_X", ",", "var", ",", "return_mi", "=", "True", ",", "return_cov", "=", "True", ")", "\n", "\n", "error", "=", "compute_mae", "(", "self", ".", "env", ".", "test_Y", ",", "mu", ")", "\n", "all_error", ".", "append", "(", "error", ")", "\n", "all_mi", ".", "append", "(", "mi", ")", "\n", "all_var", ".", "append", "(", "np", ".", "diag", "(", "cov", ")", ".", "mean", "(", ")", ")", "\n", "", "results", "=", "{", "'mean'", ":", "mu", ",", "'error'", ":", "all_error", ",", "'mi'", ":", "all_mi", ",", "'mean_var'", ":", "all_var", "}", "\n", "return", "results", "", "", "", ""]], "home.repos.pwc.inspect_result.sumitsk_algp.None.run.path_to_sample_count": [[16, 24], ["numpy.full", "range", "numpy.array", "len", "len", "tuple"], "function", ["None"], ["def", "path_to_sample_count", "(", "env", ",", "path", ")", ":", "\n", "    ", "indices", "=", "[", "env", ".", "map_pose_to_gp_index_matrix", "[", "tuple", "(", "p", ")", "]", "for", "p", "in", "path", "]", "\n", "is_sample", "=", "np", ".", "array", "(", "indices", ")", "!=", "None", "\n", "sample_count", "=", "np", ".", "full", "(", "len", "(", "path", ")", ",", "0", ")", "\n", "sample_count", "[", "0", "]", "=", "is_sample", "[", "0", "]", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "path", ")", ")", ":", "\n", "        ", "sample_count", "[", "i", "]", "=", "sample_count", "[", "i", "-", "1", "]", "+", "is_sample", "[", "i", "]", "\n", "", "return", "sample_count", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.run.snr_test": [[26, 41], ["range", "env.FieldEnv", "agent.Agent", "dict", "numpy.exp", "numpy.exp", "all_rho.append", "agent.Agent.gp.model.named_parameters", "params[].item", "params[].item"], "function", ["None"], ["", "def", "snr_test", "(", "args", ")", ":", "\n", "# compute signal-to-noise ratio as computed from the fitted GP model", "\n", "    ", "nsims", "=", "5", "\n", "all_rho", "=", "[", "]", "\n", "extra_features", "=", "[", "]", "\n", "\n", "for", "i", "in", "range", "(", "nsims", ")", ":", "\n", "        ", "env", "=", "FieldEnv", "(", "data_file", "=", "args", ".", "data_file", ",", "phenotype", "=", "args", ".", "phenotype", ",", "extra_features", "=", "extra_features", ",", "num_test", "=", "args", ".", "num_test", ")", "\n", "master", "=", "Agent", "(", "env", ",", "args", ")", "\n", "params", "=", "dict", "(", "master", ".", "gp", ".", "model", ".", "named_parameters", "(", ")", ")", "\n", "ss", "=", "np", ".", "exp", "(", "params", "[", "'kernel_covar_module.log_outputscale'", "]", ".", "item", "(", ")", ")", "\n", "sn", "=", "np", ".", "exp", "(", "params", "[", "'likelihood.log_noise'", "]", ".", "item", "(", ")", ")", "\n", "rho", "=", "ss", "**", "2", "/", "sn", "**", "2", "\n", "all_rho", ".", "append", "(", "rho", ")", "\n", "", "return", "all_rho", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.run.compare_all_strategies": [[43, 118], ["len", "range", "numpy.tile", "zip", "pandas.DataFrame.from_dict", "utils.generate_lineplots", "numpy.tile", "zip", "pandas.DataFrame.from_dict", "utils.generate_lineplots", "ipdb.set_trace", "env.FieldEnv", "agent.Agent", "agent.Agent.reset", "agent.Agent.pilot_survey", "agent.Agent.predict", "utils.compute_mae", "numpy.diag().mean", "range", "list", "numpy.stack().flatten", "numpy.stack().flatten", "numpy.arange", "range", "range", "range", "range", "agent.Agent", "error_results[].append", "mi_results[].append", "var_results[].append", "sample_count[].append", "numpy.arange", "numpy.diag", "range", "agents[].run_greedy_ipp", "agents[].prediction_vs_distance", "numpy.stack", "numpy.stack", "agents[].run_naive", "run.path_to_sample_count"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_lineplots", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_lineplots", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.pilot_survey", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_greedy_ipp", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.prediction_vs_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_naive", "home.repos.pwc.inspect_result.sumitsk_algp.None.run.path_to_sample_count"], ["", "def", "compare_all_strategies", "(", "args", ")", ":", "\n", "# compare all 5 strategies on the same environment ", "\n", "    ", "strategies", "=", "[", "'MaxEnt'", ",", "'Shortest'", ",", "'Equi-Sample'", ",", "'Naive Static'", ",", "'Naive Mobile'", "]", "\n", "ipp_strategies", "=", "[", "'MaxEnt'", ",", "'Shortest'", ",", "'Equi-Sample'", "]", "\n", "naive_strategies", "=", "[", "'Naive Static'", ",", "'Naive Mobile'", "]", "\n", "num_strategies", "=", "len", "(", "strategies", ")", "\n", "\n", "nsims", "=", "10", "\n", "test_every", "=", "10", "\n", "num_naive_runs", "=", "20", "\n", "max_dist", "=", "test_every", "*", "num_naive_runs", "\n", "disp", "=", "False", "\n", "# set some initial samples", "\n", "initial_samples", "=", "5", "\n", "\n", "error_results", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_strategies", ")", "]", "\n", "mi_results", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_strategies", ")", "]", "\n", "var_results", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_strategies", ")", "]", "\n", "sample_count", "=", "[", "[", "]", "for", "_", "in", "range", "(", "num_strategies", ")", "]", "\n", "noise_ratio", "=", "5", "\n", "for", "t", "in", "range", "(", "nsims", ")", ":", "\n", "        ", "env", "=", "FieldEnv", "(", "data_file", "=", "args", ".", "data_file", ",", "phenotype", "=", "args", ".", "phenotype", ",", "num_test", "=", "args", ".", "num_test", ")", "\n", "master", "=", "Agent", "(", "env", ",", "args", ",", "static_std", "=", "args", ".", "static_std", ")", "\n", "master", ".", "reset", "(", ")", "\n", "master", ".", "pilot_survey", "(", "num_samples", "=", "initial_samples", ",", "std", "=", "master", ".", "static_std", ")", "\n", "mu", ",", "cov", ",", "zero_mi", "=", "master", ".", "predict", "(", "x", "=", "env", ".", "test_X", ",", "return_cov", "=", "True", ",", "return_mi", "=", "True", ")", "\n", "zero_error", "=", "compute_mae", "(", "mu", ",", "env", ".", "test_Y", ")", "\n", "zero_mean_var", "=", "np", ".", "diag", "(", "cov", ")", ".", "mean", "(", ")", "\n", "\n", "# It is not necessary to make separate agents but is useful for debugging purposes", "\n", "agents", "=", "[", "Agent", "(", "env", ",", "args", ",", "parent_agent", "=", "master", ",", "static_std", "=", "args", ".", "static_std", ",", "mobile_std", "=", "noise_ratio", "*", "args", ".", "static_std", ")", "for", "_", "in", "range", "(", "num_strategies", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "num_strategies", ")", ":", "\n", "            ", "if", "strategies", "[", "i", "]", "in", "ipp_strategies", ":", "\n", "# res = agents[i].run_ipp(num_runs=args.num_runs, strategy=strategies[i], disp=disp)", "\n", "                ", "res", "=", "agents", "[", "i", "]", ".", "run_greedy_ipp", "(", "num_runs", "=", "args", ".", "num_runs", ",", "strategy", "=", "strategies", "[", "i", "]", ",", "disp", "=", "disp", ")", "\n", "res", "=", "agents", "[", "i", "]", ".", "prediction_vs_distance", "(", "test_every", "=", "test_every", ",", "num_runs", "=", "num_naive_runs", ")", "\n", "", "elif", "strategies", "[", "i", "]", "in", "naive_strategies", ":", "\n", "                ", "std", "=", "master", ".", "static_std", "if", "'Static'", "in", "strategies", "[", "i", "]", "else", "master", ".", "mobile_std", "\n", "res", "=", "agents", "[", "i", "]", ".", "run_naive", "(", "std", "=", "std", ",", "counts", "=", "[", "test_every", "]", "*", "num_naive_runs", ",", "metric", "=", "'distance'", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "error_results", "[", "i", "]", ".", "append", "(", "[", "zero_error", "]", "+", "res", "[", "'error'", "]", ")", "\n", "mi_results", "[", "i", "]", ".", "append", "(", "[", "zero_mi", "]", "+", "res", "[", "'mi'", "]", ")", "\n", "var_results", "[", "i", "]", ".", "append", "(", "[", "zero_mean_var", "]", "+", "res", "[", "'mean_var'", "]", ")", "\n", "sample_count", "[", "i", "]", ".", "append", "(", "path_to_sample_count", "(", "env", ",", "agents", "[", "i", "]", ".", "path", ")", "[", ":", "max_dist", "]", ")", "\n", "", "", "start", "=", "test_every", "\n", "x", "=", "[", "initial_samples", "]", "+", "list", "(", "np", ".", "arange", "(", "start", ",", "start", "+", "test_every", "*", "num_naive_runs", ",", "test_every", ")", ")", "\n", "# x = np.stack([x for _ in range(nsims)]).flatten()", "\n", "x", "=", "np", ".", "tile", "(", "x", ",", "nsims", ")", "\n", "xlabel", "=", "'Distance travelled'", "\n", "ci", "=", "50", "\n", "\n", "# test error", "\n", "errors", "=", "[", "np", ".", "stack", "(", "res", ")", ".", "flatten", "(", ")", "for", "res", "in", "error_results", "]", "\n", "dct_err", "=", "{", "'x'", ":", "x", "}", "\n", "for", "y", ",", "lbl", "in", "zip", "(", "errors", ",", "strategies", ")", ":", "\n", "        ", "dct_err", "[", "lbl", "]", "=", "y", "\n", "", "df_err", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "dct_err", ")", "\n", "\n", "ylabel", "=", "'Test MAE'", "\n", "generate_lineplots", "(", "df_err", ",", "x", "=", "'x'", ",", "xlabel", "=", "xlabel", ",", "ylabel", "=", "ylabel", ",", "legends", "=", "strategies", ",", "ci", "=", "ci", ")", "\n", "\n", "# sample_count vs distance", "\n", "all_sample_count", "=", "[", "np", ".", "stack", "(", "sc", ")", ".", "flatten", "(", ")", "for", "sc", "in", "sample_count", "]", "\n", "dist", "=", "np", ".", "tile", "(", "np", ".", "arange", "(", "1", ",", "1", "+", "max_dist", ")", ",", "nsims", ")", "\n", "dct_sc", "=", "{", "'x'", ":", "dist", "}", "\n", "for", "y", ",", "lbl", "in", "zip", "(", "all_sample_count", ",", "strategies", ")", ":", "\n", "        ", "dct_sc", "[", "lbl", "]", "=", "y", "\n", "", "df_sc", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "dct_sc", ")", "\n", "\n", "ylabel_sc", "=", "'Number of samples'", "\n", "generate_lineplots", "(", "df_sc", ",", "x", "=", "'x'", ",", "xlabel", "=", "xlabel", ",", "ylabel", "=", "ylabel_sc", ",", "legends", "=", "strategies", ",", "ci", "=", "ci", ")", "\n", "\n", "ipdb", ".", "set_trace", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.run.compare_maxent": [[141, 206], ["len", "range", "numpy.stack().flatten", "zip", "pandas.DataFrame.from_dict", "utils.generate_lineplots", "zip", "pandas.DataFrame.from_dict", "utils.generate_lineplots", "ipdb.set_trace", "env.FieldEnv", "agent.Agent", "agent.Agent.reset", "agent.Agent.pilot_survey", "agent.Agent.predict", "utils.compute_mae", "numpy.diag().mean", "range", "list", "numpy.stack().flatten", "numpy.stack().flatten", "str", "range", "range", "range", "agent.Agent", "agents[].run_ipp", "agents[].prediction_vs_distance", "error_results[].append", "mi_results[].append", "var_results[].append", "numpy.arange", "numpy.stack", "numpy.diag", "range", "numpy.stack", "numpy.stack", "range"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_lineplots", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_lineplots", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.pilot_survey", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.predict", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_ipp", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.prediction_vs_distance"], ["", "def", "compare_maxent", "(", "args", ")", ":", "\n", "    ", "nsims", "=", "10", "\n", "\n", "test_every", "=", "10", "\n", "num_naive_runs", "=", "25", "\n", "disp", "=", "False", "\n", "# set some initial samples", "\n", "initial_samples", "=", "5", "\n", "# noise_ratios = [1,2,5,10]", "\n", "# variants = ['test_every = ' + str(n) for n in noise_ratios]", "\n", "\n", "slacks", "=", "[", "0", ",", "5", ",", "10", ",", "15", "]", "\n", "variants", "=", "[", "'slack = '", "+", "str", "(", "s", ")", "for", "s", "in", "slacks", "]", "\n", "\n", "nv", "=", "len", "(", "variants", ")", "\n", "error_results", "=", "[", "[", "]", "for", "_", "in", "range", "(", "nv", ")", "]", "\n", "mi_results", "=", "[", "[", "]", "for", "_", "in", "range", "(", "nv", ")", "]", "\n", "var_results", "=", "[", "[", "]", "for", "_", "in", "range", "(", "nv", ")", "]", "\n", "\n", "for", "t", "in", "range", "(", "nsims", ")", ":", "\n", "        ", "env", "=", "FieldEnv", "(", "data_file", "=", "args", ".", "data_file", ",", "phenotype", "=", "args", ".", "phenotype", ",", "num_test", "=", "args", ".", "num_test", ")", "\n", "master", "=", "Agent", "(", "env", ",", "args", ",", "static_std", "=", "args", ".", "static_std", ")", "\n", "master", ".", "reset", "(", ")", "\n", "master", ".", "pilot_survey", "(", "num_samples", "=", "initial_samples", ",", "std", "=", "master", ".", "static_std", ")", "\n", "mu", ",", "cov", ",", "zero_mi", "=", "master", ".", "predict", "(", "x", "=", "env", ".", "test_X", ",", "return_cov", "=", "True", ",", "return_mi", "=", "True", ")", "\n", "zero_error", "=", "compute_mae", "(", "mu", ",", "env", ".", "test_Y", ")", "\n", "zero_mean_var", "=", "np", ".", "diag", "(", "cov", ")", ".", "mean", "(", ")", "\n", "\n", "# It is not necessary to make separate agents but is useful for debugging purposes", "\n", "# agents = [Agent(env, args, parent_agent=master, static_std=args.static_std, mobile_std=kappa*args.static_std) for kappa in noise_ratios]", "\n", "agents", "=", "[", "Agent", "(", "env", ",", "args", ",", "parent_agent", "=", "master", ",", "static_std", "=", "args", ".", "static_std", ",", "mobile_std", "=", "5", "*", "args", ".", "static_std", ")", "for", "_", "in", "range", "(", "nv", ")", "]", "\n", "\n", "for", "i", "in", "range", "(", "nv", ")", ":", "\n", "            ", "res", "=", "agents", "[", "i", "]", ".", "run_ipp", "(", "num_runs", "=", "args", ".", "num_runs", ",", "strategy", "=", "'MaxEnt'", ",", "disp", "=", "disp", ",", "slack", "=", "slacks", "[", "i", "]", ")", "\n", "# res = agents[i].run_ipp(num_runs=args.num_runs, strategy='MaxEnt', disp=disp, slack=0)", "\n", "res", "=", "agents", "[", "i", "]", ".", "prediction_vs_distance", "(", "test_every", "=", "test_every", ",", "num_runs", "=", "num_naive_runs", ")", "\n", "error_results", "[", "i", "]", ".", "append", "(", "[", "zero_error", "]", "+", "res", "[", "'error'", "]", ")", "\n", "mi_results", "[", "i", "]", ".", "append", "(", "[", "zero_mi", "]", "+", "res", "[", "'mi'", "]", ")", "\n", "var_results", "[", "i", "]", ".", "append", "(", "[", "zero_mean_var", "]", "+", "res", "[", "'mean_var'", "]", ")", "\n", "\n", "", "", "start", "=", "test_every", "\n", "x", "=", "[", "initial_samples", "]", "+", "list", "(", "np", ".", "arange", "(", "start", ",", "start", "+", "test_every", "*", "num_naive_runs", ",", "test_every", ")", ")", "\n", "x", "=", "np", ".", "stack", "(", "[", "x", "for", "_", "in", "range", "(", "nsims", ")", "]", ")", ".", "flatten", "(", ")", "\n", "xlabel", "=", "'Distance travelled'", "\n", "ci", "=", "50", "\n", "\n", "# test error", "\n", "errors", "=", "[", "np", ".", "stack", "(", "res", ")", ".", "flatten", "(", ")", "for", "res", "in", "error_results", "]", "\n", "dct_err", "=", "{", "'x'", ":", "x", "}", "\n", "for", "y", ",", "lbl", "in", "zip", "(", "errors", ",", "variants", ")", ":", "\n", "        ", "dct_err", "[", "lbl", "]", "=", "y", "\n", "", "df_err", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "dct_err", ")", "\n", "\n", "ylabel", "=", "'Test MAE'", "\n", "generate_lineplots", "(", "df_err", ",", "x", "=", "'x'", ",", "xlabel", "=", "xlabel", ",", "ylabel", "=", "ylabel", ",", "legends", "=", "variants", ",", "ci", "=", "ci", ")", "\n", "\n", "# test variance", "\n", "dct_var", "=", "{", "'x'", ":", "x", "}", "\n", "varss", "=", "[", "np", ".", "stack", "(", "res", ")", ".", "flatten", "(", ")", "for", "res", "in", "var_results", "]", "\n", "for", "y", ",", "lbl", "in", "zip", "(", "varss", ",", "variants", ")", ":", "\n", "        ", "dct_var", "[", "lbl", "]", "=", "y", "\n", "", "df_var", "=", "pd", ".", "DataFrame", ".", "from_dict", "(", "dct_var", ")", "\n", "ylabel_var", "=", "'Test Mean Variance'", "\n", "generate_lineplots", "(", "df_var", ",", "x", "=", "'x'", ",", "xlabel", "=", "xlabel", ",", "ylabel", "=", "ylabel_var", ",", "legends", "=", "variants", ",", "ci", "=", "ci", ")", "\n", "ipdb", ".", "set_trace", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.run.run_demo": [[207, 219], ["env.FieldEnv", "agent.Agent", "agent.Agent.reset", "agent.Agent.run_ipp"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.reset", "home.repos.pwc.inspect_result.sumitsk_algp.None.agent.Agent.run_ipp"], ["", "def", "run_demo", "(", "args", ")", ":", "\n", "    ", "env", "=", "FieldEnv", "(", "data_file", "=", "args", ".", "data_file", ",", "phenotype", "=", "args", ".", "phenotype", ",", "num_test", "=", "args", ".", "num_test", ")", "\n", "agent", "=", "Agent", "(", "env", ",", "args", ",", "static_std", "=", "args", ".", "static_std", ",", "mobile_std", "=", "10", "*", "args", ".", "static_std", ")", "\n", "# Reset the agent before execution", "\n", "agent", ".", "reset", "(", ")", "\n", "\n", "# Informative strategies", "\n", "# ipp_strategies = ['MaxEnt', 'Shortest', 'Equi-Sample']", "\n", "# Naive strategies", "\n", "# naive_strategies = ['Naive Static', 'Naive Mobile']", "\n", "\n", "agent", ".", "run_ipp", "(", "render", "=", "args", ".", "render", ",", "num_runs", "=", "args", ".", "num_runs", ",", "strategy", "=", "'MaxEnt'", ")", "\n", "# agent.run_greedy_ipp(num_runs=args.num_runs, strategy='MaxEnt')", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.run.render_naive_strategy": [[222, 225], ["env.FieldEnv", "env.FieldEnv.render_naive"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render_naive"], ["", "def", "render_naive_strategy", "(", "args", ")", ":", "\n", "    ", "env", "=", "FieldEnv", "(", "data_file", "=", "args", ".", "data_file", ",", "phenotype", "=", "args", ".", "phenotype", ",", "num_test", "=", "args", ".", "num_test", ")", "\n", "env", ".", "render_naive", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_torch": [[13, 21], ["torch.FloatTensor"], "function", ["None"], ["def", "to_torch", "(", "arr", ")", ":", "\n", "    ", "if", "arr", "is", "None", ":", "\n", "        ", "return", "None", "\n", "", "if", "arr", ".", "__class__", ".", "__module__", "==", "'torch'", ":", "\n", "        ", "return", "arr", "\n", "", "if", "arr", ".", "__class__", ".", "__module__", "==", "'numpy'", ":", "\n", "        ", "return", "torch", ".", "FloatTensor", "(", "arr", ")", "\n", "", "return", "arr", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.to_numpy": [[23, 31], ["numpy.array", "x.detach().cpu().numpy", "x.detach().cpu", "x.detach"], "function", ["None"], ["", "def", "to_numpy", "(", "x", ")", ":", "\n", "    ", "if", "x", "is", "None", ":", "\n", "        ", "return", "None", "\n", "", "if", "x", ".", "__class__", ".", "__module__", "==", "'torch'", ":", "\n", "        ", "return", "x", ".", "detach", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "if", "x", ".", "__class__", ".", "__module__", "==", "'numpy'", ":", "\n", "        ", "return", "x", "\n", "", "return", "np", ".", "array", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.load_data": [[33, 42], ["data_dict[].squeeze", "data_dict[].squeeze", "open", "pickle.load"], "function", ["None"], ["", "def", "load_data", "(", "filename", ")", ":", "\n", "    ", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "fn", ":", "\n", "        ", "data_dict", "=", "pickle", ".", "load", "(", "fn", ")", "\n", "", "num_rows", "=", "data_dict", "[", "'num_rows'", "]", "\n", "num_cols", "=", "data_dict", "[", "'num_cols'", "]", "\n", "X", "=", "data_dict", "[", "'X'", "]", "\n", "Y", "=", "data_dict", "[", "'Y'", "]", ".", "squeeze", "(", ")", "\n", "valid", "=", "data_dict", "[", "'valid'", "]", ".", "squeeze", "(", ")", "\n", "return", "num_rows", ",", "num_cols", ",", "X", "[", "valid", "]", ",", "Y", "[", "valid", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.load_dataframe": [[44, 62], ["pandas.read_pickle", "numpy.vstack", "int", "len", "df[].values.squeeze", "df[].values.squeeze", "df[].values.squeeze", "X[].max", "numpy.hstack", "numpy.concatenate", "numpy.concatenate"], "function", ["None"], ["", "def", "load_dataframe", "(", "filename", ",", "target_feature", ",", "extra_input_features", "=", "[", "]", ",", "add_gene", "=", "True", ")", ":", "\n", "    ", "df", "=", "pd", ".", "read_pickle", "(", "filename", ")", "\n", "X", "=", "np", ".", "vstack", "(", "df", "[", "[", "'X'", "]", "]", ".", "values", ".", "squeeze", "(", ")", ")", "\n", "row_range", "=", "X", "[", ":", ",", ":", "2", "]", "\n", "num_rows", "=", "15", "\n", "num_cols", "=", "int", "(", "X", "[", ":", ",", "1", "]", ".", "max", "(", ")", ")", "\n", "\n", "final_x", "=", "row_range", "\n", "if", "len", "(", "extra_input_features", ")", ":", "\n", "        ", "ph_vals", "=", "np", ".", "hstack", "(", "[", "df", "[", "[", "f", "]", "]", ".", "values", "for", "f", "in", "extra_input_features", "]", ")", "\n", "final_x", "=", "np", ".", "concatenate", "(", "[", "row_range", ",", "ph_vals", "]", ",", "axis", "=", "1", ")", "\n", "", "if", "add_gene", ":", "\n", "        ", "gene", "=", "X", "[", ":", ",", "2", ":", "]", "\n", "final_x", "=", "np", ".", "concatenate", "(", "[", "final_x", ",", "gene", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "y", "=", "df", "[", "[", "target_feature", "]", "]", ".", "values", ".", "squeeze", "(", ")", "\n", "genotype", "=", "df", "[", "[", "'category'", "]", "]", ".", "values", ".", "squeeze", "(", ")", "\n", "return", "num_rows", ",", "num_cols", ",", "final_x", ",", "y", ",", "genotype", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.load_data_from_pickle": [[64, 88], ["pandas.read_pickle", "df[].values.squeeze", "len", "len", "len", "numpy.hstack", "numpy.concatenate", "numpy.unique", "numpy.unique", "[].flatten", "numpy.arange().reshape", "numpy.arange", "len"], "function", ["None"], ["", "def", "load_data_from_pickle", "(", "filename", ",", "target_feature", ",", "extra_input_features", "=", "[", "]", ",", "max_range", "=", "None", ")", ":", "\n", "    ", "df", "=", "pd", ".", "read_pickle", "(", "filename", ")", "\n", "x", "=", "df", "[", "[", "'Row'", ",", "'Range'", "]", "]", ".", "values", "\n", "y", "=", "df", "[", "[", "target_feature", "]", "]", ".", "values", ".", "squeeze", "(", ")", "\n", "\n", "if", "len", "(", "extra_input_features", ")", ":", "\n", "        ", "ph_vals", "=", "np", ".", "hstack", "(", "[", "df", "[", "[", "f", "]", "]", ".", "values", "for", "f", "in", "extra_input_features", "]", ")", "\n", "x", "=", "np", ".", "concatenate", "(", "[", "x", ",", "ph_vals", "]", ",", "axis", "=", "1", ")", "\n", "\n", "# truncate extra ranges from the dataset", "\n", "", "num_rows", "=", "len", "(", "np", ".", "unique", "(", "x", "[", ":", ",", "0", "]", ")", ")", "\n", "num_ranges", "=", "len", "(", "np", ".", "unique", "(", "x", "[", ":", ",", "1", "]", ")", ")", "\n", "if", "max_range", "is", "not", "None", ":", "\n", "        ", "ind", "=", "np", ".", "arange", "(", "len", "(", "x", ")", ")", ".", "reshape", "(", "num_ranges", ",", "num_rows", ")", "[", ":", "max_range", "]", ".", "flatten", "(", ")", "\n", "x", "=", "x", "[", "ind", "]", "\n", "y", "=", "y", "[", "ind", "]", "\n", "", "else", ":", "\n", "        ", "max_range", "=", "num_ranges", "\n", "\n", "# # mask out some plots", "\n", "# retain_frac = .8", "\n", "# retain = np.random.randint(0, len(x), int(retain_frac*len(x)))", "\n", "# x, y = x[retain], y[retain]", "\n", "", "return", "max_range", ",", "num_rows", ",", "x", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_gaussian_data": [[90, 109], ["numpy.meshgrid", "numpy.vstack().transpose", "numpy.random.uniform", "numpy.random.uniform", "numpy.vstack().transpose", "numpy.random.uniform", "numpy.zeros", "range", "numpy.arange", "numpy.arange", "numpy.sum", "numpy.exp", "numpy.vstack", "numpy.vstack", "numpy.square", "numpy.maximum", "np.maximum.flatten", "x.flatten", "means[].reshape"], "function", ["None"], ["", "def", "generate_gaussian_data", "(", "num_rows", ",", "num_cols", ",", "k", "=", "5", ",", "min_var", "=", "10", ",", "max_var", "=", "100", ",", "algo", "=", "'sum'", ")", ":", "\n", "    ", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "arange", "(", "num_cols", ")", ",", "np", ".", "arange", "(", "num_rows", ")", ")", "\n", "grid", "=", "np", ".", "vstack", "(", "[", "y", ".", "flatten", "(", ")", ",", "x", ".", "flatten", "(", ")", "]", ")", ".", "transpose", "(", ")", "\n", "\n", "means_x", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "num_rows", ",", "size", "=", "k", ")", "\n", "means_y", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "num_cols", ",", "size", "=", "k", ")", "\n", "means", "=", "np", ".", "vstack", "(", "[", "means_x", ",", "means_y", "]", ")", ".", "transpose", "(", ")", "\n", "variances", "=", "np", ".", "random", ".", "uniform", "(", "min_var", ",", "max_var", ",", "size", "=", "k", ")", "\n", "\n", "y", "=", "np", ".", "zeros", "(", "num_rows", "*", "num_cols", ")", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "dist_sq", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "grid", "-", "means", "[", "i", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "tmp", "=", "np", ".", "exp", "(", "-", "dist_sq", "/", "variances", "[", "i", "]", ")", "\n", "if", "algo", "==", "'max'", ":", "\n", "            ", "y", "=", "np", ".", "maximum", "(", "y", ",", "tmp", ")", "\n", "", "elif", "algo", "==", "'sum'", ":", "\n", "            ", "y", "+=", "tmp", "\n", "\n", "", "", "return", "grid", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_mixed_data": [[111, 141], ["numpy.meshgrid", "numpy.vstack().transpose", "numpy.random.randint", "numpy.zeros", "numpy.concatenate", "numpy.random.randint", "numpy.zeros", "numpy.vstack().transpose", "numpy.concatenate", "numpy.random.uniform", "numpy.zeros", "range", "numpy.arange", "numpy.arange", "grid[].max", "grid[].max", "numpy.random.uniform", "numpy.random.uniform", "numpy.sum", "numpy.exp", "numpy.vstack", "numpy.vstack", "numpy.square", "numpy.maximum", "numpy.arange", "numpy.arange", "np.maximum.flatten", "x.flatten", "means[].reshape"], "function", ["None"], ["", "def", "generate_mixed_data", "(", "num_rows", ",", "num_cols", ",", "num_zs", "=", "4", ",", "k", "=", "4", ",", "min_var", "=", ".1", ",", "max_var", "=", "2", ",", "algo", "=", "'sum'", ")", ":", "\n", "    ", "x", ",", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "arange", "(", "num_cols", ")", ",", "np", ".", "arange", "(", "num_rows", ")", ")", "\n", "grid", "=", "np", ".", "vstack", "(", "[", "y", ".", "flatten", "(", ")", ",", "x", ".", "flatten", "(", ")", "]", ")", ".", "transpose", "(", ")", "\n", "n", "=", "num_rows", "*", "num_cols", "\n", "z_ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "num_zs", ",", "n", ")", "\n", "z", "=", "np", ".", "zeros", "(", "(", "n", ",", "num_zs", ")", ")", "\n", "z", "[", "np", ".", "arange", "(", "n", ")", ",", "z_ind", "]", "=", "1", "\n", "grid", "=", "np", ".", "concatenate", "(", "[", "grid", ",", "z", "]", ",", "axis", "=", "1", ")", "\n", "a", ",", "b", "=", "grid", "[", ":", ",", "0", "]", ".", "max", "(", ")", ",", "grid", "[", ":", ",", "1", "]", ".", "max", "(", ")", "\n", "grid", "[", ":", ",", "0", "]", "/=", "a", "\n", "grid", "[", ":", ",", "1", "]", "/=", "b", "\n", "\n", "means_x", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "num_rows", ",", "size", "=", "k", ")", "/", "a", "\n", "means_y", "=", "np", ".", "random", ".", "uniform", "(", "0", ",", "num_cols", ",", "size", "=", "k", ")", "/", "b", "\n", "means_z_ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "num_zs", ",", "size", "=", "k", ")", "\n", "means_z", "=", "np", ".", "zeros", "(", "(", "k", ",", "num_zs", ")", ")", "\n", "means_z", "[", "np", ".", "arange", "(", "k", ")", ",", "means_z_ind", "]", "=", "1", "\n", "means", "=", "np", ".", "vstack", "(", "[", "means_x", ",", "means_y", "]", ")", ".", "transpose", "(", ")", "\n", "means", "=", "np", ".", "concatenate", "(", "[", "means", ",", "means_z", "]", ",", "axis", "=", "1", ")", "\n", "variances", "=", "np", ".", "random", ".", "uniform", "(", "min_var", ",", "max_var", ",", "size", "=", "k", ")", "\n", "\n", "y", "=", "np", ".", "zeros", "(", "n", ")", "\n", "for", "i", "in", "range", "(", "k", ")", ":", "\n", "        ", "dist_sq", "=", "np", ".", "sum", "(", "np", ".", "square", "(", "grid", "-", "means", "[", "i", "]", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "tmp", "=", "np", ".", "exp", "(", "-", "dist_sq", "/", "variances", "[", "i", "]", ")", "\n", "if", "algo", "==", "'max'", ":", "\n", "            ", "y", "=", "np", ".", "maximum", "(", "y", ",", "tmp", ")", "\n", "", "elif", "algo", "==", "'sum'", ":", "\n", "            ", "y", "+=", "tmp", "\n", "", "", "return", "grid", ",", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_phenotype_data": [[143, 186], ["range", "numpy.random.randint", "numpy.zeros", "numpy.concatenate", "numpy.sum", "utils.generate_gaussian_data", "all_y.append", "numpy.vstack", "numpy.arange"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_gaussian_data"], ["", "def", "generate_phenotype_data", "(", "num_rows", "=", "20", ",", "num_cols", "=", "15", ",", "num_zs", "=", "4", ",", "min_var", "=", "1", ",", "max_var", "=", "10", ",", "algo", "=", "'sum'", ")", ":", "\n", "    ", "all_y", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "num_zs", ")", ":", "\n", "        ", "grid", ",", "y", "=", "generate_gaussian_data", "(", "num_rows", ",", "num_cols", ",", "k", "=", "5", ",", "min_var", "=", "10", ",", "max_var", "=", "100", ",", "algo", "=", "'sum'", ")", "\n", "all_y", ".", "append", "(", "y", ")", "\n", "", "n", "=", "num_rows", "*", "num_cols", "\n", "z_ind", "=", "np", ".", "random", ".", "randint", "(", "0", ",", "num_zs", ",", "n", ")", "\n", "z", "=", "np", ".", "zeros", "(", "(", "n", ",", "num_zs", ")", ")", "\n", "z", "[", "np", ".", "arange", "(", "n", ")", ",", "z_ind", "]", "=", "1", "\n", "grid", "=", "np", ".", "concatenate", "(", "[", "grid", ",", "z", "]", ",", "axis", "=", "1", ")", "\n", "stacked_y", "=", "np", ".", "vstack", "(", "all_y", ")", ".", "T", "\n", "final_y", "=", "np", ".", "sum", "(", "z", "*", "stacked_y", ",", "axis", "=", "1", ")", "\n", "\n", "# render the distribution of all phenotypes", "\n", "# fig, ax = plt.subplots(2,3)", "\n", "# ax = ax.flatten()", "\n", "# cmap = 'ocean'", "\n", "# vmin = stacked_y.min()", "\n", "# vmax = stacked_y.max()", "\n", "# sz = 15", "\n", "# ax[0].set_title('Gene 1 Phenotype distribution', fontsize=sz)", "\n", "# sns.heatmap(all_y[0].reshape(num_rows, num_cols), ax=ax[0], cmap=cmap, vmin=vmin, vmax=vmax)", "\n", "# ax[1].set_title('Gene 2 Phenotype distribution', fontsize=sz)", "\n", "# sns.heatmap(all_y[1].reshape(num_rows, num_cols), ax=ax[1], cmap=cmap, vmin=vmin, vmax=vmax)", "\n", "# ax[3].set_title('Gene 3 Phenotype distribution', fontsize=sz)", "\n", "# sns.heatmap(all_y[2].reshape(num_rows, num_cols), ax=ax[3], cmap=cmap, vmin=vmin, vmax=vmax)", "\n", "# ax[4].set_title('Gene 4 Phenotype distribution', fontsize=sz)", "\n", "# sns.heatmap(all_y[3].reshape(num_rows, num_cols), ax=ax[4], cmap=cmap, vmin=vmin, vmax=vmax)", "\n", "\n", "# sz = 15", "\n", "# ax[2].set_title('Genotype distribution in field', fontsize=sz)", "\n", "# colors = [\"red\", \"amber\", \"faded green\", \"purple\"]", "\n", "# cmap2 = sns.xkcd_palette(colors)", "\n", "# sns.heatmap((z_ind+1).reshape(num_rows, num_cols), ax=ax[2], cmap=cmap2, cbar_kws={'ticks':np.arange(1,num_zs+1)})", "\n", "# ax[5].set_title('Phenotype distribution in field', fontsize=sz)", "\n", "# sns.heatmap(final_y.reshape(num_rows, num_cols), ax=ax[5], cmap=cmap, vmin=vmin, vmax=vmax)", "\n", "\n", "# for ax_ in ax:", "\n", "#     ax_.set_xticks([])", "\n", "#     ax_.set_yticks([])", "\n", "# plt.show()", "\n", "\n", "return", "grid", ",", "final_y", ",", "all_y", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov": [[188, 195], ["[].item", "numpy.linalg.slogdet"], "function", ["None"], ["", "def", "entropy_from_cov", "(", "cov", ",", "constant", "=", "CONST", ")", ":", "\n", "# constant is the first term in entropy calculation", "\n", "# H = constant * k + 1/2 * log(det(cov))", "\n", "    ", "if", "constant", "is", "None", ":", "\n", "        ", "constant", "=", "CONST", "\n", "", "ent", "=", "cov", ".", "shape", "[", "0", "]", "*", "constant", "+", ".5", "*", "np", ".", "linalg", ".", "slogdet", "(", "cov", ")", "[", "1", "]", ".", "item", "(", ")", "\n", "return", "ent", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.is_valid_cell": [[197, 202], ["None"], "function", ["None"], ["", "def", "is_valid_cell", "(", "cell", ",", "grid_shape", ")", ":", "\n", "# check if cell lies inside the grid or not", "\n", "    ", "if", "0", "<=", "cell", "[", "0", "]", "<", "grid_shape", "[", "0", "]", "and", "0", "<=", "cell", "[", "1", "]", "<", "grid_shape", "[", "1", "]", ":", "\n", "        ", "return", "True", "\n", "", "return", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.vec_to_one_hot_matrix": [[204, 210], ["numpy.zeros", "numpy.max", "len", "numpy.arange", "len"], "function", ["None"], ["", "def", "vec_to_one_hot_matrix", "(", "vec", ",", "max_val", "=", "None", ")", ":", "\n", "    ", "if", "max_val", "is", "None", ":", "\n", "        ", "max_val", "=", "np", ".", "max", "(", "vec", ")", "\n", "", "mat", "=", "np", ".", "zeros", "(", "(", "len", "(", "vec", ")", ",", "max_val", "+", "1", ")", ")", "\n", "mat", "[", "np", ".", "arange", "(", "len", "(", "vec", ")", ")", ",", "vec", "]", "=", "1", "\n", "return", "mat", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.zero_mean_unit_variance": [[212, 219], ["data.mean", "data.std"], "function", ["None"], ["", "def", "zero_mean_unit_variance", "(", "data", ",", "mean", "=", "None", ",", "std", "=", "None", ")", ":", "\n", "# zero mean unit variance normalization", "\n", "    ", "if", "mean", "is", "None", ":", "\n", "        ", "mean", "=", "data", ".", "mean", "(", "axis", "=", "0", ")", "\n", "", "if", "std", "is", "None", ":", "\n", "        ", "std", "=", "data", ".", "std", "(", "axis", "=", "0", ")", "\n", "", "return", "(", "data", "-", "mean", ")", "/", "std", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.normalize": [[221, 225], ["data.max"], "function", ["None"], ["", "def", "normalize", "(", "data", ",", "col_max", "=", "None", ")", ":", "\n", "# divide each column with the corresponding max value", "\n", "    ", "col_max", "=", "data", ".", "max", "(", "0", ")", "if", "col_max", "is", "None", "else", "col_max", "\n", "return", "data", "/", "col_max", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mae": [[227, 229], ["numpy.mean", "numpy.abs"], "function", ["None"], ["", "def", "compute_mae", "(", "true", ",", "pred", ")", ":", "\n", "    ", "return", "np", ".", "mean", "(", "np", ".", "abs", "(", "true", "-", "pred", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_rmse": [[231, 234], ["numpy.linalg.norm", "numpy.sqrt", "len", "true.squeeze", "pred.squeeze"], "function", ["None"], ["", "def", "compute_rmse", "(", "true", ",", "pred", ")", ":", "\n", "# return root mean square error betwee true values and predictions", "\n", "    ", "return", "np", ".", "linalg", ".", "norm", "(", "true", ".", "squeeze", "(", ")", "-", "pred", ".", "squeeze", "(", ")", ")", "/", "np", ".", "sqrt", "(", "len", "(", "true", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mean_normalized_rmse": [[236, 239], ["utils.compute_rmse", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_rmse"], ["", "def", "compute_mean_normalized_rmse", "(", "true", ",", "pred", ")", ":", "\n", "    ", "rmse", "=", "compute_rmse", "(", "true", ",", "pred", ")", "\n", "return", "rmse", "/", "np", ".", "mean", "(", "true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_range_normalized_rmse": [[241, 244], ["utils.compute_rmse", "max", "min"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_rmse"], ["", "def", "compute_range_normalized_rmse", "(", "true", ",", "pred", ")", ":", "\n", "    ", "rmse", "=", "compute_rmse", "(", "true", ",", "pred", ")", "\n", "return", "rmse", "/", "(", "max", "(", "true", ")", "-", "min", "(", "true", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_iqr": [[246, 248], ["numpy.subtract", "numpy.percentile"], "function", ["None"], ["", "def", "compute_iqr", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "subtract", "(", "*", "np", ".", "percentile", "(", "x", ",", "[", "75", ",", "25", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_iqr_normalized_rmse": [[250, 253], ["utils.compute_rmse", "utils.compute_iqr"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_rmse", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_iqr"], ["", "def", "compute_iqr_normalized_rmse", "(", "true", ",", "pred", ")", ":", "\n", "    ", "rmse", "=", "compute_rmse", "(", "true", ",", "pred", ")", "\n", "return", "rmse", "/", "compute_iqr", "(", "true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_metric": [[255, 268], ["utils.compute_rmse", "utils.compute_range_normalized_rmse", "utils.compute_mean_normalized_rmse", "utils.compute_iqr_normalized_rmse"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_rmse", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_range_normalized_rmse", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_mean_normalized_rmse", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.compute_iqr_normalized_rmse"], ["", "def", "compute_metric", "(", "true", ",", "preds", ",", "metric", ")", ":", "\n", "# preds is a list of predictions", "\n", "    ", "if", "metric", "==", "'rmse'", ":", "\n", "        ", "results", "=", "[", "compute_rmse", "(", "true", ",", "x", ")", "for", "x", "in", "preds", "]", "\n", "", "elif", "metric", "==", "'range_normalized_rmse'", ":", "\n", "        ", "results", "=", "[", "compute_range_normalized_rmse", "(", "true", ",", "x", ")", "for", "x", "in", "preds", "]", "\n", "", "elif", "metric", "==", "'mean_normalized_rmse'", ":", "\n", "        ", "results", "=", "[", "compute_mean_normalized_rmse", "(", "true", ",", "x", ")", "for", "x", "in", "preds", "]", "\n", "", "elif", "metric", "==", "'iqr_normalized_rmse'", ":", "\n", "        ", "results", "=", "[", "compute_iqr_normalized_rmse", "(", "true", ",", "x", ")", "for", "x", "in", "preds", "]", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "return", "results", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.normal_dist_kldiv": [[270, 281], ["numpy.linalg.inv", "numpy.dot", "numpy.trace", "len", "numpy.dot", "numpy.linalg.slogdet", "numpy.linalg.slogdet", "numpy.dot"], "function", ["None"], ["", "def", "normal_dist_kldiv", "(", "mu1", ",", "cov1", ",", "mu2", ",", "cov2", ")", ":", "\n", "# return kL(f1, f2)", "\n", "# f2 \\sim N(mu1,cov1); f2 \\sim N(mu2,sim2)", "\n", "\n", "    ", "cov2_inv", "=", "np", ".", "linalg", ".", "inv", "(", "cov2", ")", "\n", "diff", "=", "mu2", "-", "mu1", "\n", "t1", "=", "np", ".", "linalg", ".", "slogdet", "(", "cov2", ")", "[", "1", "]", "-", "np", ".", "linalg", ".", "slogdet", "(", "cov1", ")", "[", "1", "]", "\n", "t2", "=", "np", ".", "trace", "(", "np", ".", "dot", "(", "cov2_inv", ",", "cov1", ")", ")", "-", "len", "(", "mu1", ")", "\n", "t3", "=", "np", ".", "dot", "(", "diff", ".", "T", ",", "np", ".", "dot", "(", "cov2_inv", ",", "diff", ")", ")", "\n", "kldiv", "=", ".5", "*", "(", "t1", "+", "t2", "+", "t3", ")", "\n", "return", "kldiv", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.euclidean_distance": [[283, 286], ["None"], "function", ["None"], ["", "def", "euclidean_distance", "(", "p0", ",", "p1", ")", ":", "\n", "# return euclidean distance between p0 and p1", "\n", "    ", "return", "(", "(", "p0", "[", "0", "]", "-", "p1", "[", "0", "]", ")", "**", "2", "+", "(", "p0", "[", "1", "]", "-", "p1", "[", "1", "]", ")", "**", "2", ")", "**", ".5", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance": [[288, 291], ["abs", "abs"], "function", ["None"], ["", "def", "manhattan_distance", "(", "p0", ",", "p1", ")", ":", "\n", "# return manhattan distance between p0 and p1", "\n", "    ", "return", "abs", "(", "p0", "[", "0", "]", "-", "p1", "[", "0", "]", ")", "+", "abs", "(", "p0", "[", "1", "]", "-", "p1", "[", "1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.predictive_distribution": [[293, 320], ["numpy.mean", "gp.cov_mat", "gp.cov_mat", "gp.cov_mat", "numpy.dot", "numpy.linalg.inv", "numpy.dot", "numpy.dot", "numpy.diag", "utils.entropy_from_cov", "utils.entropy_from_cov"], "function", ["home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.cov_mat", "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.cov_mat", "home.repos.pwc.inspect_result.sumitsk_algp.None.models.GPR.cov_mat", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.entropy_from_cov"], ["", "def", "predictive_distribution", "(", "gp", ",", "train_x", ",", "train_y", ",", "test_x", ",", "train_var", "=", "None", ",", "test_var", "=", "None", ",", "return_var", "=", "False", ",", "return_cov", "=", "False", ",", "return_mi", "=", "False", ")", ":", "\n", "    ", "train_y_mean", "=", "np", ".", "mean", "(", "train_y", ")", "\n", "\n", "cov_aa", "=", "gp", ".", "cov_mat", "(", "x1", "=", "train_x", ",", "white_noise_var", "=", "train_var", ",", "add_likelihood_var", "=", "True", ")", "\n", "cov_xx", "=", "gp", ".", "cov_mat", "(", "x1", "=", "test_x", ",", "white_noise_var", "=", "test_var", ")", "\n", "cov_xa", "=", "gp", ".", "cov_mat", "(", "x1", "=", "test_x", ",", "x2", "=", "train_x", ")", "\n", "\n", "mat1", "=", "np", ".", "dot", "(", "cov_xa", ",", "np", ".", "linalg", ".", "inv", "(", "cov_aa", ")", ")", "\n", "mu", "=", "np", ".", "dot", "(", "mat1", ",", "(", "train_y", "-", "train_y_mean", ")", ")", "+", "train_y_mean", "\n", "if", "not", "(", "return_var", "or", "return_cov", "or", "return_mi", ")", ":", "\n", "        ", "return", "mu", "\n", "\n", "", "cov", "=", "cov_xx", "-", "np", ".", "dot", "(", "mat1", ",", "cov_xa", ".", "T", ")", "\n", "\n", "if", "return_var", ":", "\n", "        ", "res", "=", "(", "mu", ",", "np", ".", "diag", "(", "cov", ")", ")", "\n", "\n", "", "if", "return_cov", ":", "\n", "        ", "res", "=", "(", "mu", ",", "cov", ")", "\n", "\n", "", "if", "return_mi", ":", "\n", "        ", "mi", "=", "entropy_from_cov", "(", "cov_xx", ")", "-", "entropy_from_cov", "(", "cov", ")", "\n", "res", "=", "(", "mu", ",", "mi", ")", "\n", "\n", "", "if", "return_cov", "and", "return_mi", ":", "\n", "        ", "res", "=", "(", "mu", ",", "cov", ",", "mi", ")", "\n", "", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.draw_path": [[322, 345], ["range", "ax.arrow", "len", "abs", "abs", "abs", "abs"], "function", ["None"], ["", "def", "draw_path", "(", "ax", ",", "path", ",", "head_width", "=", "None", ",", "head_length", "=", "None", ",", "linewidth", "=", "None", ",", "delta", "=", "None", ",", "color", "=", "None", ")", ":", "\n", "    ", "head_width", "=", ".05", "if", "head_width", "is", "None", "else", "head_width", "\n", "head_length", "=", ".1", "if", "head_length", "is", "None", "else", "head_length", "\n", "linewidth", "=", "2", "if", "linewidth", "is", "None", "else", "linewidth", "\n", "delta", "=", "head_length", "*", "2", "if", "delta", "is", "None", "else", "delta", "\n", "arrow_color", "=", "'red'", "if", "color", "is", "None", "else", "color", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", ":", "\n", "        ", "source", "=", "path", "[", "i", "]", "\n", "sink", "=", "path", "[", "i", "+", "1", "]", "\n", "dxdy", "=", "(", "sink", "[", "0", "]", "-", "source", "[", "0", "]", ",", "sink", "[", "1", "]", "-", "source", "[", "1", "]", ")", "\n", "dx", "=", "dxdy", "[", "0", "]", "\n", "dy", "=", "dxdy", "[", "1", "]", "\n", "if", "dx", "==", "0", ":", "\n", "            ", "sign", "=", "dy", "//", "abs", "(", "dy", ")", "\n", "dy", "=", "sign", "*", "(", "abs", "(", "dy", ")", "-", "delta", ")", "\n", "", "else", ":", "\n", "            ", "sign", "=", "dx", "//", "abs", "(", "dx", ")", "\n", "dx", "=", "sign", "*", "(", "abs", "(", "dx", ")", "-", "delta", ")", "\n", "\n", "", "ax", ".", "arrow", "(", "source", "[", "0", "]", ",", "source", "[", "1", "]", ",", "dx", ",", "dy", ",", "\n", "head_width", "=", "head_width", ",", "head_length", "=", "head_length", ",", "\n", "linewidth", "=", "linewidth", ",", "color", "=", "arrow_color", ",", "alpha", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_lineplots": [[347, 363], ["matplotlib.subplots", "matplotlib.xlabel", "matplotlib.ylabel", "matplotlib.legend", "df[].values.squeeze", "sns.lineplot.set_xlim", "matplotlib.show", "seaborn.lineplot", "df[].values.squeeze.min", "df[].values.squeeze.max", "str", "range", "len"], "function", ["None"], ["", "", "def", "generate_lineplots", "(", "df", ",", "x", ",", "xlabel", "=", "None", ",", "ylabel", "=", "None", ",", "legends", "=", "None", ",", "ci", "=", "95", ")", ":", "\n", "# geneate a seaborn lineplot with confidence interval ", "\n", "# ys - list of y values", "\n", "    ", "xlabel", "=", "'x'", "if", "xlabel", "is", "None", "else", "xlabel", "\n", "ylabel", "=", "'y'", "if", "ylabel", "is", "None", "else", "ylabel", "\n", "legends", "=", "[", "'y'", "+", "str", "(", "i", ")", "for", "i", "in", "range", "(", "1", ",", "len", "(", "df", ")", ")", "]", "if", "legends", "is", "None", "else", "legends", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ")", "\n", "for", "lbl", "in", "legends", ":", "\n", "        ", "ax", "=", "sns", ".", "lineplot", "(", "x", "=", "x", ",", "y", "=", "lbl", ",", "data", "=", "df", ",", "label", "=", "lbl", ",", "ax", "=", "ax", ",", "ci", "=", "ci", ",", "markers", "=", "True", ")", "\n", "", "plt", ".", "xlabel", "(", "xlabel", ")", "\n", "plt", ".", "ylabel", "(", "ylabel", ")", "\n", "plt", ".", "legend", "(", ")", "\n", "xvals", "=", "df", "[", "[", "'x'", "]", "]", ".", "values", ".", "squeeze", "(", ")", "\n", "ax", ".", "set_xlim", "(", "[", "xvals", ".", "min", "(", ")", ",", "xvals", ".", "max", "(", ")", "]", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.find_shortest_path": [[365, 369], ["min", "numpy.random.choice", "numpy.where", "numpy.array"], "function", ["None"], ["", "def", "find_shortest_path", "(", "paths_cost", ")", ":", "\n", "    ", "least_cost", "=", "min", "(", "paths_cost", ")", "\n", "indices", "=", "np", ".", "where", "(", "np", ".", "array", "(", "paths_cost", ")", "==", "least_cost", ")", "[", "0", "]", "\n", "return", "np", ".", "random", ".", "choice", "(", "indices", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.find_equi_sample_path": [[371, 374], ["numpy.array", "numpy.random.choice", "len", "numpy.where"], "function", ["None"], ["", "def", "find_equi_sample_path", "(", "paths_indices", ",", "idx", ")", ":", "\n", "    ", "num_samples", "=", "np", ".", "array", "(", "[", "len", "(", "x", ")", "for", "x", "in", "paths_indices", "]", ")", "\n", "return", "np", ".", "random", ".", "choice", "(", "np", ".", "where", "(", "num_samples", "==", "num_samples", "[", "idx", "]", ")", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__": [[17, 57], ["object.__init__", "numpy.copy", "numpy.copy", "env.FieldEnv._setup_graph", "utils.generate_phenotype_data", "env.FieldEnv._setup", "env.FieldEnv._place_samples_others", "scipy.io.loadmat", "mat[].squeeze", "env.FieldEnv._setup", "env.FieldEnv._place_samples_others", "utils.load_data_from_pickle", "env.FieldEnv._setup", "env.FieldEnv._place_samples_pheno"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.__init__", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup_graph", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.generate_phenotype_data", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._place_samples_others", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._place_samples_others", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.load_data_from_pickle", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._place_samples_pheno"], ["    ", "def", "__init__", "(", "self", ",", "data_file", "=", "None", ",", "phenotype", "=", "'plant_count'", ",", "num_test", "=", "40", ")", ":", "\n", "        ", "super", "(", "FieldEnv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "data_file", "is", "None", ":", "\n", "            ", "self", ".", "num_rows", "=", "30", "\n", "self", ".", "num_cols", "=", "30", "\n", "x", ",", "y", ",", "self", ".", "y_category", "=", "generate_phenotype_data", "(", "num_rows", "=", "self", ".", "num_rows", ",", "num_cols", "=", "self", ".", "num_cols", ",", "num_zs", "=", "4", ")", "\n", "x", "[", ":", ",", "1", "]", "*=", "2", "\n", "self", ".", "_setup", "(", "x", ",", "y", ",", "num_test", ")", "\n", "self", ".", "_place_samples_others", "(", "row_start", "=", "0", ",", "row_inc", "=", "1", ")", "\n", "\n", "", "else", ":", "\n", "# NOTE: will deprecate this soon", "\n", "# for intel dataset", "\n", "            ", "if", "'intel'", "in", "data_file", ":", "\n", "                ", "import", "scipy", ".", "io", "\n", "mat", "=", "scipy", ".", "io", ".", "loadmat", "(", "data_file", ")", "\n", "x", "=", "mat", "[", "'Xss'", "]", "\n", "y", "=", "mat", "[", "'Fss'", "]", ".", "squeeze", "(", ")", "\n", "self", ".", "num_rows", "=", "15", "\n", "self", ".", "num_cols", "=", "17", "\n", "self", ".", "_setup", "(", "x", ",", "y", ",", "num_test", ")", "\n", "self", ".", "_place_samples_others", "(", "row_start", "=", "0", ",", "row_inc", "=", "3", ")", "\n", "\n", "# for sorghum dataset", "\n", "", "else", ":", "\n", "                ", "extra_features", "=", "[", "'leaf_fill'", ",", "'grvi'", "]", "\n", "max_range", "=", "35", "\n", "self", ".", "num_rows", ",", "self", ".", "num_cols", ",", "x", ",", "y", "=", "load_data_from_pickle", "(", "data_file", ",", "target_feature", "=", "phenotype", ",", "\n", "max_range", "=", "max_range", ",", "\n", "extra_input_features", "=", "extra_features", ")", "\n", "self", ".", "_setup", "(", "x", ",", "y", ",", "num_test", ")", "\n", "self", ".", "_place_samples_pheno", "(", ")", "\n", "\n", "", "", "self", ".", "all_x", "=", "np", ".", "copy", "(", "x", ")", "\n", "self", ".", "all_y", "=", "np", ".", "copy", "(", "y", ")", "\n", "\n", "self", ".", "_setup_graph", "(", ")", "\n", "# for rendering", "\n", "self", ".", "fig", "=", "None", "\n", "self", ".", "ax", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup": [[58, 74], ["len", "numpy.random.permutation", "map.Map", "numpy.full", "numpy.full", "len"], "methods", ["None"], ["", "def", "_setup", "(", "self", ",", "x", ",", "y", ",", "num_test", ")", ":", "\n", "# split into training and testing data", "\n", "        ", "n", "=", "len", "(", "x", ")", "\n", "perm", "=", "np", ".", "random", ".", "permutation", "(", "n", ")", "\n", "test_ind", "=", "perm", "[", ":", "num_test", "]", "\n", "train_ind", "=", "perm", "[", "num_test", ":", "]", "\n", "\n", "self", ".", "X", "=", "x", "[", "train_ind", "]", "\n", "self", ".", "Y", "=", "y", "[", "train_ind", "]", "\n", "self", ".", "test_X", "=", "x", "[", "test_ind", "]", "\n", "self", ".", "test_Y", "=", "y", "[", "test_ind", "]", "\n", "\n", "# setup map and pose-index and index-pose lookup tables", "\n", "self", ".", "map", "=", "Map", "(", "self", ".", "num_rows", ",", "self", ".", "num_cols", ",", "num_row_passes", "=", "4", ")", "\n", "self", ".", "map_pose_to_gp_index_matrix", "=", "np", ".", "full", "(", "self", ".", "map", ".", "shape", ",", "None", ")", "\n", "self", ".", "gp_index_to_map_pose_array", "=", "np", ".", "full", "(", "len", "(", "self", ".", "X", ")", ",", "None", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._place_samples_others": [[76, 90], ["numpy.arange", "range", "len", "int"], "methods", ["None"], ["", "def", "_place_samples_others", "(", "self", ",", "row_start", "=", "0", ",", "row_inc", "=", "1", ")", ":", "\n", "# assign samples to grid cells", "\n", "        ", "x", "=", "self", ".", "X", "[", ":", ",", ":", "2", "]", "\n", "indices", "=", "np", ".", "arange", "(", "len", "(", "x", ")", ")", "\n", "row", "=", "row_start", "\n", "for", "i", "in", "range", "(", "self", ".", "map", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "if", "i", "in", "self", ".", "map", ".", "row_pass_indices", ":", "\n", "                ", "continue", "\n", "", "row_indices", "=", "indices", "[", "x", "[", ":", ",", "0", "]", "==", "row", "]", "\n", "for", "ind", "in", "row_indices", ":", "\n", "                ", "map_pose", "=", "(", "i", ",", "int", "(", "x", "[", "ind", ",", "1", "]", ")", ")", "\n", "self", ".", "map_pose_to_gp_index_matrix", "[", "map_pose", "]", "=", "ind", "\n", "self", ".", "gp_index_to_map_pose_array", "[", "ind", "]", "=", "map_pose", "\n", "", "row", "+=", "row_inc", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._place_samples_pheno": [[91, 107], ["numpy.arange", "range", "len", "int"], "methods", ["None"], ["", "", "def", "_place_samples_pheno", "(", "self", ")", ":", "\n", "# assign samples to grid cells", "\n", "        ", "row", "=", "2", "\n", "row_inc", "=", "2", "\n", "x", "=", "self", ".", "X", "[", ":", ",", ":", "2", "]", "\n", "indices", "=", "np", ".", "arange", "(", "len", "(", "x", ")", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "map", ".", "shape", "[", "1", "]", ")", ":", "\n", "            ", "if", "i", "%", "2", "==", "1", ":", "\n", "                ", "continue", "\n", "", "row_indices", "=", "indices", "[", "x", "[", ":", ",", "0", "]", "==", "row", "]", "\n", "for", "ind", "in", "row_indices", ":", "\n", "                ", "t", "=", "x", "[", "ind", ",", "1", "]", "+", "(", "x", "[", "ind", ",", "1", "]", "-", "1", ")", "//", "self", ".", "map", ".", "corridor_len", "\n", "map_pose", "=", "(", "int", "(", "t", ")", ",", "row", "-", "2", ")", "\n", "self", ".", "map_pose_to_gp_index_matrix", "[", "map_pose", "]", "=", "ind", "\n", "self", ".", "gp_index_to_map_pose_array", "[", "ind", "]", "=", "map_pose", "\n", "", "row", "+=", "row_inc", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.collect_samples": [[108, 114], ["max", "numpy.random.normal"], "methods", ["None"], ["", "", "def", "collect_samples", "(", "self", ",", "indices", ",", "noise_std", ")", ":", "\n", "# draw measurement for the given sampling index and noise", "\n", "        ", "y", "=", "self", ".", "Y", "[", "indices", "]", "+", "np", ".", "random", ".", "normal", "(", "0", ",", "noise_std", ")", "\n", "# truncating negative values to 0", "\n", "y", "=", "max", "(", "0", ",", "y", ")", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup_graph": [[115, 137], ["networkx.nx.Graph", "env.FieldEnv.graph.nodes", "copy.deepcopy", "env.FieldEnv.graph.add_node", "utils.is_valid_cell", "env.FieldEnv.gp_indices_between", "env.FieldEnv.graph.add_edge"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.is_valid_cell", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_between"], ["", "def", "_setup_graph", "(", "self", ")", ":", "\n", "# initialize graph for path planning", "\n", "        ", "self", ".", "graph", "=", "nx", ".", "Graph", "(", ")", "\n", "# add all intersections as nodes", "\n", "for", "r", "in", "self", ".", "map", ".", "row_pass_indices", ":", "\n", "            ", "for", "c", "in", "self", ".", "map", ".", "free_cols", ":", "\n", "                ", "self", ".", "graph", ".", "add_node", "(", "(", "r", ",", "c", ")", ",", "pose", "=", "(", "c", ",", "self", ".", "map", ".", "shape", "[", "0", "]", "-", "r", ")", ",", "new", "=", "'False'", ")", "\n", "\n", "", "", "delta_x", "=", "self", ".", "map", ".", "corridor_len", "+", "1", "\n", "# x-axis is row or the first element of the tuple", "\n", "dx_dy", "=", "[", "(", "0", ",", "2", ")", ",", "(", "0", ",", "-", "2", ")", ",", "(", "delta_x", ",", "0", ")", ",", "(", "-", "delta_x", ",", "0", ")", "]", "\n", "\n", "# add all edges", "\n", "for", "node", "in", "self", ".", "graph", ".", "nodes", "(", ")", ":", "\n", "            ", "for", "dx", ",", "dy", "in", "dx_dy", ":", "\n", "                ", "neighbor", "=", "(", "node", "[", "0", "]", "+", "dx", ",", "node", "[", "1", "]", "+", "dy", ")", "\n", "if", "is_valid_cell", "(", "neighbor", ",", "self", ".", "map", ".", "shape", ")", ":", "\n", "                    ", "indices", "=", "self", ".", "gp_indices_between", "(", "node", ",", "neighbor", ")", "\n", "self", ".", "graph", ".", "add_edge", "(", "node", ",", "neighbor", ",", "indices", "=", "indices", ")", "\n", "\n", "# store a backup graph (or restore point)", "\n", "", "", "", "self", ".", "backup_graph", "=", "deepcopy", "(", "self", ".", "graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._pre_search": [[138, 152], ["env.FieldEnv.get_new_nodes_and_edges", "zip", "env.FieldEnv.graph.remove_edges_from", "env.FieldEnv.graph.add_node", "env.FieldEnv.graph.add_edge"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_new_nodes_and_edges"], ["", "def", "_pre_search", "(", "self", ",", "start", ",", "waypoints", ")", ":", "\n", "# nodes and edges to be added to the graph and the edges to be removed from the graph", "\n", "        ", "new_nodes", ",", "new_edges", ",", "new_edges_indices", ",", "remove_edges", "=", "self", ".", "get_new_nodes_and_edges", "(", "[", "start", "]", "+", "waypoints", ")", "\n", "\n", "# add start and waypoint nodes to the graph", "\n", "for", "node", "in", "new_nodes", ":", "\n", "            ", "self", ".", "graph", ".", "add_node", "(", "node", ",", "pose", "=", "(", "node", "[", "1", "]", ",", "self", ".", "map", ".", "shape", "[", "0", "]", "-", "node", "[", "0", "]", ")", ",", "new", "=", "'True'", ")", "\n", "\n", "# add edges", "\n", "", "for", "edge", ",", "indices", "in", "zip", "(", "new_edges", ",", "new_edges_indices", ")", ":", "\n", "            ", "self", ".", "graph", ".", "add_edge", "(", "edge", "[", "0", "]", ",", "edge", "[", "1", "]", ",", "indices", "=", "indices", ")", "\n", "\n", "# remove redundant edges (these edges have been replaced by edges between waypoints and map junctions)", "\n", "", "self", ".", "graph", ".", "remove_edges_from", "(", "remove_edges", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_new_nodes_and_edges": [[164, 193], ["env.FieldEnv.map.get_down_junction", "env.FieldEnv.map.get_up_junction", "graph_utils.get_down_and_up_nodes", "env.FieldEnv.gp_indices_between", "env.FieldEnv.gp_indices_between", "new_edges.append", "new_edges.append", "new_edges_indices.append", "new_edges_indices.append", "remove_edges.append", "env.FieldEnv.pop", "env.FieldEnv.pop", "env.FieldEnv.graph.nodes"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_down_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_up_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_down_and_up_nodes", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_between", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_between"], ["", "def", "get_new_nodes_and_edges", "(", "self", ",", "new_nodes", ")", ":", "\n", "# return nodes and edges to be added to the graph and the edges to be removed from the graph", "\n", "\n", "# nodes not present in the graph already", "\n", "        ", "new_nodes", "=", "[", "n", "for", "n", "in", "new_nodes", "if", "n", "not", "in", "self", ".", "graph", ".", "nodes", "(", ")", "]", "\n", "new_edges", "=", "[", "]", "\n", "new_edges_indices", "=", "[", "]", "\n", "remove_edges", "=", "[", "]", "\n", "\n", "# for each node find edges to be added and to be removed from the graph", "\n", "for", "node", "in", "new_nodes", ":", "\n", "            ", "down_junc", "=", "self", ".", "map", ".", "get_down_junction", "(", "node", ")", "\n", "up_junc", "=", "self", ".", "map", ".", "get_up_junction", "(", "node", ")", "\n", "down_node", ",", "up_node", "=", "get_down_and_up_nodes", "(", "node", ",", "new_nodes", ",", "down_junc", ",", "up_junc", ")", "\n", "\n", "down_indices", "=", "self", ".", "gp_indices_between", "(", "down_node", ",", "node", ")", "\n", "if", "self", ".", "map_pose_to_gp_index_matrix", "[", "down_node", "]", "is", "not", "None", ":", "\n", "                ", "down_indices", ".", "pop", "(", "0", ")", "\n", "", "up_indices", "=", "self", ".", "gp_indices_between", "(", "up_node", ",", "node", ")", "\n", "if", "self", ".", "map_pose_to_gp_index_matrix", "[", "up_node", "]", "is", "not", "None", ":", "\n", "                ", "up_indices", ".", "pop", "(", "0", ")", "\n", "\n", "", "new_edges", ".", "append", "(", "(", "down_node", ",", "node", ")", ")", "\n", "new_edges", ".", "append", "(", "(", "node", ",", "up_node", ")", ")", "\n", "new_edges_indices", ".", "append", "(", "down_indices", ")", "\n", "new_edges_indices", ".", "append", "(", "up_indices", ")", "\n", "\n", "remove_edges", ".", "append", "(", "(", "down_junc", ",", "up_junc", ")", ")", "\n", "", "return", "new_nodes", ",", "new_edges", ",", "new_edges_indices", ",", "remove_edges", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._post_search": [[194, 196], ["copy.deepcopy"], "methods", ["None"], ["", "def", "_post_search", "(", "self", ")", ":", "\n", "        ", "self", ".", "graph", "=", "deepcopy", "(", "self", ".", "backup_graph", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_all_paths": [[197, 311], ["env.FieldEnv._pre_search", "len", "networkx.nx.DiGraph", "networkx.nx.DiGraph.add_node", "env.FieldEnv._post_search", "env.FieldEnv.get_heuristic_cost", "len", "open_list.pop", "env.FieldEnv.graph.neighbors", "networkx.nx.all_shortest_paths", "enumerate", "graph_utils.edge_cost", "graph_utils.get_heading", "copy.deepcopy", "graph_utils.lower_bound_path_cost", "dict", "graph_utils.find_merge_to_node", "networkx.nx.DiGraph.add_node", "networkx.nx.DiGraph.add_edge", "all_paths_cost.append", "all_paths_indices.append", "all_paths.append", "networkx.nx.DiGraph.add_edge", "sum", "min", "closed_list.append", "open_list.append", "enumerate", "env.FieldEnv.graph.get_edge_data", "range", "waypoints.index", "len"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._pre_search", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._post_search", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_heuristic_cost", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.edge_cost", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.lower_bound_path_cost", "home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.find_merge_to_node"], ["", "def", "get_all_paths", "(", "self", ",", "start", ",", "heading", ",", "waypoints", ",", "heuristic_cost", "=", "None", ",", "slack", "=", "0", ")", ":", "\n", "        ", "self", ".", "_pre_search", "(", "start", ",", "waypoints", ")", "\n", "\n", "# start_time = time.time()", "\n", "nw", "=", "len", "(", "waypoints", ")", "\n", "# expansion tree", "\n", "tree", "=", "nx", ".", "DiGraph", "(", ")", "\n", "# node attributes = {pos, gval, visited, heading}", "\n", "\n", "root", "=", "0", "\n", "tree", ".", "add_node", "(", "root", ",", "pose", "=", "start", ",", "heading", "=", "heading", ",", "visited", "=", "[", "False", "]", "*", "nw", ",", "gval", "=", "0", ")", "\n", "open_list", "=", "[", "root", "]", "\n", "closed_list", "=", "[", "]", "\n", "\n", "least_cost", "=", "self", ".", "get_heuristic_cost", "(", "start", ",", "heading", ",", "waypoints", ")", "if", "heuristic_cost", "is", "None", "else", "heuristic_cost", "\n", "\n", "# for efficieny, it will be beneficial if nodes are expanded in increasing order of gval", "\n", "idx", "=", "root", "\n", "count_merged", "=", "0", "\n", "# count_skipped = 0", "\n", "while", "len", "(", "open_list", ")", ">", "0", ":", "\n", "            ", "parent_idx", "=", "open_list", ".", "pop", "(", "0", ")", "\n", "tree_node", "=", "tree", ".", "node", "[", "parent_idx", "]", "\n", "pose", "=", "tree_node", "[", "'pose'", "]", "\n", "gval", "=", "tree_node", "[", "'gval'", "]", "\n", "\n", "ngh", "=", "self", ".", "graph", ".", "neighbors", "(", "pose", ")", "\n", "for", "new_pose", "in", "ngh", ":", "\n", "                ", "cost", "=", "edge_cost", "(", "pose", ",", "tree_node", "[", "'heading'", "]", ",", "new_pose", ")", "\n", "# can't move back to its parent node (or can't take a u-turn)", "\n", "if", "cost", "==", "np", ".", "inf", ":", "\n", "                    ", "continue", "\n", "", "new_gval", "=", "gval", "+", "cost", "\n", "\n", "new_heading", "=", "get_heading", "(", "pose", ",", "new_pose", ")", "\n", "new_visited", "=", "deepcopy", "(", "tree_node", "[", "'visited'", "]", ")", "\n", "if", "new_pose", "in", "waypoints", ":", "\n", "                    ", "new_visited", "[", "waypoints", ".", "index", "(", "new_pose", ")", "]", "=", "True", "\n", "\n", "", "remaining_waypoints", "=", "[", "w", "for", "i", ",", "w", "in", "enumerate", "(", "waypoints", ")", "if", "not", "new_visited", "[", "i", "]", "]", "\n", "# min_dist_to_go = self.get_heuristic_cost(new_pose, new_heading, remaining_waypoints, least_cost)", "\n", "min_dist_to_go", "=", "lower_bound_path_cost", "(", "new_pose", ",", "remaining_waypoints", ")", "\n", "if", "new_gval", "+", "min_dist_to_go", ">", "least_cost", "+", "slack", ":", "\n", "# print('Skipping!')", "\n", "                    ", "continue", "\n", "\n", "", "new_tree_node", "=", "dict", "(", "pose", "=", "new_pose", ",", "heading", "=", "new_heading", ",", "visited", "=", "new_visited", ",", "gval", "=", "new_gval", ")", "\n", "merge_to", "=", "find_merge_to_node", "(", "tree", ",", "new_tree_node", ")", "\n", "if", "merge_to", "is", "not", "None", ":", "\n", "                    ", "tree", ".", "add_edge", "(", "parent_idx", ",", "merge_to", ",", "weight", "=", "cost", ")", "\n", "count_merged", "+=", "1", "\n", "# print('Merging')", "\n", "continue", "\n", "\n", "# NOTE: because of gp_indices computation, this is slow", "\n", "# with the new method, this can be uncommented for further tree pruning", "\n", "# action = self.node_action(tree, new_tree_node, tree_node, parent_idx)", "\n", "# if action == 'continue':", "\n", "#     count_skipped += 1", "\n", "#     continue", "\n", "\n", "# if action is not None:", "\n", "#     tree.add_edge(parent_idx, action, weight=cost)", "\n", "#     count_merged += 1", "\n", "#     continue", "\n", "\n", "# add new node to tree", "\n", "", "idx", "=", "idx", "+", "1", "\n", "tree", ".", "add_node", "(", "idx", ",", "**", "new_tree_node", ")", "\n", "tree", ".", "add_edge", "(", "parent_idx", ",", "idx", ",", "weight", "=", "cost", ")", "\n", "\n", "if", "sum", "(", "new_visited", ")", "==", "nw", ":", "\n", "                    ", "least_cost", "=", "min", "(", "new_gval", ",", "least_cost", ")", "\n", "closed_list", ".", "append", "(", "idx", ")", "\n", "", "else", ":", "\n", "                    ", "open_list", ".", "append", "(", "idx", ")", "\n", "\n", "# end_time = time.time()", "\n", "# print('Time {:4f}'.format(end_time-start_time))", "\n", "\n", "# start_time = time.time()", "\n", "", "", "", "all_paths_gen", "=", "[", "nx", ".", "all_shortest_paths", "(", "tree", ",", "root", ",", "t", ",", "weight", "=", "'weight'", ")", "for", "t", "in", "closed_list", "]", "\n", "# end_time = time.time()", "\n", "# print('Time {:4f}'.format(end_time-start_time))", "\n", "\n", "# start_time = time.time()", "\n", "all_paths", "=", "[", "]", "\n", "all_paths_indices", "=", "[", "]", "\n", "all_paths_cost", "=", "[", "]", "\n", "for", "path_gen", "in", "all_paths_gen", ":", "\n", "            ", "for", "i", ",", "path", "in", "enumerate", "(", "path_gen", ")", ":", "\n", "                ", "path_cost", "=", "tree", ".", "node", "[", "path", "[", "-", "1", "]", "]", "[", "'gval'", "]", "\n", "if", "path_cost", ">", "least_cost", "+", "slack", ":", "\n", "                    ", "continue", "\n", "\n", "", "all_paths_cost", ".", "append", "(", "path_cost", ")", "\n", "locs", "=", "[", "tree", ".", "node", "[", "p", "]", "[", "'pose'", "]", "for", "p", "in", "path", "]", "\n", "# gp_indices contains only mobile sensing locations", "\n", "gp_indices", "=", "[", "self", ".", "graph", ".", "get_edge_data", "(", "locs", "[", "t", "]", ",", "locs", "[", "t", "+", "1", "]", ")", "[", "'indices'", "]", "for", "t", "in", "range", "(", "len", "(", "locs", ")", "-", "1", ")", "]", "\n", "# gp_indices = [self.gp_indices_between(locs[t],locs[t+1]) for t in range(len(path)-1)]", "\n", "\n", "gp_indices", "=", "[", "item", "for", "sublist", "in", "gp_indices", "for", "item", "in", "sublist", "]", "\n", "all_paths_indices", ".", "append", "(", "gp_indices", ")", "\n", "\n", "all_paths", ".", "append", "(", "locs", ")", "\n", "\n", "# end_time = time.time()", "\n", "# print('Time {:4f}'.format(end_time-start_time))", "\n", "\n", "# print(count_merged)", "\n", "# print(count_skipped)", "\n", "# print(len(all_paths))", "\n", "", "", "self", ".", "_post_search", "(", ")", "\n", "return", "all_paths", ",", "all_paths_indices", ",", "all_paths_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_heuristic_cost": [[312, 383], ["len", "networkx.nx.DiGraph", "networkx.nx.DiGraph.add_node", "len", "env.FieldEnv.map.nearest_waypoint_path_cost", "env.FieldEnv.map.get_junction", "utils.manhattan_distance", "len", "open_list.pop", "range", "ipdb.set_trace", "ValueError", "len", "len", "len", "max", "env.FieldEnv.map.distance_between_nodes", "numpy.copy", "dict", "networkx.nx.DiGraph.add_node", "networkx.nx.DiGraph.add_edge", "waypoints.index", "abs", "enumerate", "sum", "closed_list.append", "open_list.append"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.nearest_waypoint_path_cost", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.get_junction", "home.repos.pwc.inspect_result.sumitsk_algp.None.utils.manhattan_distance", "home.repos.pwc.inspect_result.sumitsk_algp.None.map.Map.distance_between_nodes"], ["", "def", "get_heuristic_cost", "(", "self", ",", "start", ",", "heading", ",", "waypoints", ",", "least_cost_ub", "=", "None", ",", "return_seq", "=", "False", ")", ":", "\n", "        ", "if", "len", "(", "waypoints", ")", "==", "0", ":", "\n", "            ", "return", "0", "\n", "\n", "", "least_cost", "=", "self", ".", "map", ".", "nearest_waypoint_path_cost", "(", "start", ",", "heading", ",", "waypoints", ")", "if", "least_cost_ub", "is", "None", "else", "least_cost_ub", "\n", "\n", "gval", "=", "0", "\n", "if", "start", "[", "0", "]", "not", "in", "self", ".", "map", ".", "row_pass_indices", ":", "\n", "            ", "if", "heading", "not", "in", "[", "(", "1", ",", "0", ")", ",", "(", "-", "1", ",", "0", ")", "]", ":", "\n", "                ", "raise", "ValueError", "(", "'Impossible setting encountered!!'", ")", "\n", "", "", "else", ":", "\n", "# move to the first junction ", "\n", "            ", "junc", "=", "self", ".", "map", ".", "get_junction", "(", "start", ",", "heading", ")", "\n", "x", "=", "start", "[", "0", "]", "\n", "covered", "=", "[", "False", "]", "*", "len", "(", "waypoints", ")", "\n", "costs", "=", "[", "-", "1", "]", "*", "len", "(", "waypoints", ")", "\n", "while", "x", "!=", "junc", "[", "0", "]", ":", "\n", "                ", "pose", "=", "(", "x", ",", "start", "[", "1", "]", ")", "\n", "if", "pose", "in", "waypoints", ":", "\n", "                    ", "itr", "=", "waypoints", ".", "index", "(", "pose", ")", "\n", "covered", "[", "itr", "]", "=", "True", "\n", "costs", "[", "itr", "]", "=", "abs", "(", "start", "[", "0", "]", "-", "x", ")", "\n", "", "x", "=", "x", "+", "heading", "[", "0", "]", "\n", "", "waypoints", "=", "[", "w", "for", "i", ",", "w", "in", "enumerate", "(", "waypoints", ")", "if", "not", "covered", "[", "i", "]", "]", "\n", "if", "len", "(", "waypoints", ")", "==", "0", ":", "\n", "                ", "return", "max", "(", "costs", ")", "\n", "", "gval", "=", "manhattan_distance", "(", "start", ",", "junc", ")", "\n", "start", "=", "junc", "\n", "\n", "", "nw", "=", "len", "(", "waypoints", ")", "\n", "tree", "=", "nx", ".", "DiGraph", "(", ")", "\n", "# node attributes = {pos, gval, visited, heading}", "\n", "\n", "root", "=", "0", "\n", "tree", ".", "add_node", "(", "root", ",", "pose", "=", "start", ",", "heading", "=", "heading", ",", "visited", "=", "[", "False", "]", "*", "nw", ",", "gval", "=", "gval", ")", "\n", "open_list", "=", "[", "root", "]", "\n", "closed_list", "=", "[", "]", "\n", "idx", "=", "root", "\n", "\n", "while", "len", "(", "open_list", ")", ">", "0", ":", "\n", "            ", "parent_idx", "=", "open_list", ".", "pop", "(", "0", ")", "\n", "parent_node", "=", "tree", ".", "node", "[", "parent_idx", "]", "\n", "\n", "# neighbors are all the waypoints which haven't been visited yet", "\n", "for", "i", "in", "range", "(", "nw", ")", ":", "\n", "                ", "if", "parent_node", "[", "'visited'", "]", "[", "i", "]", ":", "\n", "                    ", "continue", "\n", "\n", "", "cost", ",", "final_heading", "=", "self", ".", "map", ".", "distance_between_nodes", "(", "parent_node", "[", "'pose'", "]", ",", "waypoints", "[", "i", "]", ",", "parent_node", "[", "'heading'", "]", ")", "\n", "new_gval", "=", "parent_node", "[", "'gval'", "]", "+", "cost", "\n", "if", "new_gval", ">", "least_cost", ":", "\n", "                    ", "continue", "\n", "\n", "", "new_visited", "=", "np", ".", "copy", "(", "parent_node", "[", "'visited'", "]", ")", "\n", "new_visited", "[", "i", "]", "=", "True", "\n", "child_node", "=", "dict", "(", "pose", "=", "waypoints", "[", "i", "]", ",", "heading", "=", "final_heading", ",", "visited", "=", "new_visited", ",", "gval", "=", "new_gval", ")", "\n", "\n", "idx", "+=", "1", "\n", "tree", ".", "add_node", "(", "idx", ",", "**", "child_node", ")", "\n", "tree", ".", "add_edge", "(", "parent_idx", ",", "idx", ",", "weight", "=", "cost", ")", "\n", "if", "sum", "(", "new_visited", ")", "==", "nw", ":", "\n", "                    ", "if", "new_gval", "<=", "least_cost", ":", "\n", "                        ", "least_cost", "=", "new_gval", "\n", "best_idx", "=", "idx", "\n", "\n", "", "closed_list", ".", "append", "(", "idx", ")", "\n", "", "else", ":", "\n", "                    ", "open_list", ".", "append", "(", "idx", ")", "\n", "", "", "", "if", "return_seq", ":", "\n", "            ", "ipdb", ".", "set_trace", "(", ")", "\n", "", "return", "least_cost", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_on_path": [[384, 389], ["env.FieldEnv.graph.get_edge_data", "range", "len"], "methods", ["None"], ["", "def", "gp_indices_on_path", "(", "self", ",", "path", ")", ":", "\n", "# all gp indices lying on the path", "\n", "        ", "gp_indices", "=", "[", "self", ".", "graph", ".", "get_edge_data", "(", "path", "[", "t", "]", ",", "path", "[", "t", "+", "1", "]", ")", "[", "'indices'", "]", "for", "t", "in", "range", "(", "len", "(", "path", ")", "-", "1", ")", "]", "\n", "gp_indices", "=", "[", "item", "for", "sublist", "in", "gp_indices", "for", "item", "in", "sublist", "]", "\n", "return", "gp_indices", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.node_action": [[390, 412], ["len", "networkx.nx.all_shortest_paths", "env.FieldEnv.gp_indices_on_path", "networkx.nx.all_shortest_paths", "env.FieldEnv.gp_indices_on_path", "set().issubset", "tree.nodes", "len", "set", "set"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_on_path", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_on_path"], ["", "def", "node_action", "(", "self", ",", "tree", ",", "node", ",", "parent_node", ",", "parent_idx", ")", ":", "\n", "# all nodes in the graph with same attributes as node", "\n", "        ", "all_idx", "=", "[", "n", "for", "n", "in", "tree", ".", "nodes", "(", ")", "if", "tree", ".", "node", "[", "n", "]", "==", "node", "]", "\n", "if", "len", "(", "all_idx", ")", ">", "0", ":", "\n", "            ", "assert", "len", "(", "all_idx", ")", "==", "1", ",", "'More than one path found!!!'", "\n", "sim_idx", "=", "all_idx", "[", "0", "]", "\n", "# find gp indices along sim_node", "\n", "gen", "=", "nx", ".", "all_shortest_paths", "(", "tree", ",", "0", ",", "sim_idx", ",", "weight", "=", "'weight'", ")", "\n", "sim_path", "=", "[", "p", "for", "p", "in", "gen", "]", "\n", "sim_locs", "=", "[", "tree", ".", "node", "[", "p", "]", "[", "'pose'", "]", "for", "p", "in", "sim_path", "[", "0", "]", "]", "\n", "sim_gp_ind", "=", "self", ".", "gp_indices_on_path", "(", "sim_locs", ")", "\n", "\n", "gen", "=", "nx", ".", "all_shortest_paths", "(", "tree", ",", "0", ",", "parent_idx", ")", "\n", "parent_path", "=", "[", "p", "for", "p", "in", "gen", "]", "\n", "locs", "=", "[", "tree", ".", "node", "[", "p", "]", "[", "'pose'", "]", "for", "p", "in", "parent_path", "[", "0", "]", "]", "+", "[", "node", "[", "'pose'", "]", "]", "\n", "gp_ind", "=", "self", ".", "gp_indices_on_path", "(", "locs", ")", "\n", "\n", "# do not add node to tree", "\n", "if", "set", "(", "gp_ind", ")", ".", "issubset", "(", "set", "(", "sim_gp_ind", ")", ")", ":", "\n", "                ", "return", "'continue'", "\n", "", "return", "all_idx", "[", "0", "]", "\n", "", "return", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.get_path_from_checkpoints": [[413, 421], ["range", "graph_utils.get_heading", "len", "path.append"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.graph_utils.get_heading"], ["", "def", "get_path_from_checkpoints", "(", "self", ",", "checkpoints", ")", ":", "\n", "# consecutive checkpoints are always aligned along either x-axis or y-axis", "\n", "        ", "path", "=", "[", "checkpoints", "[", "0", "]", "]", "\n", "for", "i", "in", "range", "(", "len", "(", "checkpoints", ")", "-", "1", ")", ":", "\n", "            ", "heading", "=", "get_heading", "(", "path", "[", "-", "1", "]", ",", "checkpoints", "[", "i", "+", "1", "]", ")", "\n", "while", "path", "[", "-", "1", "]", "!=", "checkpoints", "[", "i", "+", "1", "]", ":", "\n", "                ", "path", ".", "append", "(", "(", "path", "[", "-", "1", "]", "[", "0", "]", "+", "heading", "[", "0", "]", ",", "path", "[", "-", "1", "]", "[", "1", "]", "+", "heading", "[", "1", "]", ")", ")", "\n", "", "", "return", "path", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.shape": [[422, 425], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "shape", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "num_rows", ",", "self", ".", "num_cols", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.num_samples": [[426, 429], ["len"], "methods", ["None"], ["", "@", "property", "\n", "def", "num_samples", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "X", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_indices_between": [[430, 440], ["abs"], "methods", ["None"], ["", "def", "gp_indices_between", "(", "self", ",", "map_pose0", ",", "map_pose1", ")", ":", "\n", "# returns list of gp indices between map_pose0 and map_pose1 \"excluding\" map_pose1 location", "\n", "        ", "diff", "=", "(", "map_pose1", "[", "0", "]", "-", "map_pose0", "[", "0", "]", ",", "map_pose1", "[", "1", "]", "-", "map_pose0", "[", "1", "]", ")", "\n", "if", "diff", "[", "0", "]", "==", "0", ":", "\n", "            ", "return", "[", "]", "\n", "", "if", "diff", "[", "1", "]", "==", "0", ":", "\n", "            ", "inc", "=", "diff", "[", "0", "]", "//", "abs", "(", "diff", "[", "0", "]", ")", "\n", "indices", "=", "self", ".", "map_pose_to_gp_index_matrix", "[", "map_pose0", "[", "0", "]", ":", "map_pose1", "[", "0", "]", ":", "inc", ",", "map_pose0", "[", "1", "]", "]", "\n", "indices", "=", "[", "ind", "for", "ind", "in", "indices", "if", "ind", "is", "not", "None", "]", "\n", "return", "indices", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.gp_index_to_map_pose": [[441, 443], ["None"], "methods", ["None"], ["", "", "def", "gp_index_to_map_pose", "(", "self", ",", "gp_index", ")", ":", "\n", "        ", "return", "self", ".", "gp_index_to_map_pose_array", "[", "gp_index", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.map_pose_to_gp_index": [[444, 447], ["isinstance"], "methods", ["None"], ["", "def", "map_pose_to_gp_index", "(", "self", ",", "map_pose", ")", ":", "\n", "        ", "assert", "isinstance", "(", "map_pose", ",", "tuple", ")", ",", "'Map pose must be a tuple'", "\n", "return", "self", ".", "map_pose_to_gp_index_matrix", "[", "map_pose", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render_map": [[448, 482], ["range", "numpy.array", "utils.draw_path", "ax.imshow", "numpy.array", "numpy.repeat", "range", "numpy.array", "numpy.array", "numpy.array", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.utils.draw_path"], ["", "def", "render_map", "(", "self", ",", "ax", ",", "next_path_waypoints", ",", "all_paths", ",", "next_static_locations", ",", "all_static_locations", ")", ":", "\n", "# ax.set_title('Environment')", "\n", "        ", "sample_color", "=", "np", ".", "array", "(", "[", "255", ",", "218", ",", "185", "]", ")", "/", "255", "\n", "plot", "=", "1.0", "-", "np", ".", "repeat", "(", "self", ".", "map", ".", "occupied", "[", ":", ",", ":", ",", "np", ".", "newaxis", "]", ",", "3", ",", "axis", "=", "2", ")", "\n", "for", "i", "in", "range", "(", "plot", ".", "shape", "[", "0", "]", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "plot", ".", "shape", "[", "1", "]", ")", ":", "\n", "                ", "if", "self", ".", "map_pose_to_gp_index_matrix", "[", "i", ",", "j", "]", "is", "not", "None", ":", "\n", "                    ", "plot", "[", "i", ",", "j", "]", "=", "sample_color", "\n", "\n", "", "", "", "all_paths_color", "=", "np", ".", "array", "(", "[", "244", ",", "164", ",", "96", "]", ")", "/", "255", "\n", "all_static_locations_color", "=", "np", ".", "array", "(", "[", "127", ",", "255", ",", "0", "]", ")", "/", "255", "\n", "next_static_locations_color", "=", "np", ".", "array", "(", "[", "0", ",", "100", ",", "0", "]", ")", "/", "255", "\n", "pose_color", "=", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", "\n", "\n", "# highlight all mobile samples locations ", "\n", "if", "len", "(", "all_paths", ")", ">", "0", ":", "\n", "            ", "plot", "[", "all_paths", "[", ":", ",", "0", "]", ",", "all_paths", "[", ":", ",", "1", "]", ",", ":", "]", "=", "all_paths_color", "\n", "\n", "# highlight all static samples locations", "\n", "", "if", "len", "(", "all_static_locations", ")", ">", "0", ":", "\n", "            ", "plot", "[", "all_static_locations", "[", ":", ",", "0", "]", ",", "all_static_locations", "[", ":", ",", "1", "]", ",", ":", "]", "=", "all_static_locations_color", "\n", "\n", "# highlight next static samples", "\n", "", "if", "len", "(", "next_static_locations", ")", ">", "0", ":", "\n", "            ", "plot", "[", "next_static_locations", "[", ":", ",", "0", "]", ",", "next_static_locations", "[", ":", ",", "1", "]", ",", ":", "]", "=", "next_static_locations_color", "\n", "\n", "# show the next path", "\n", "", "waypoints", "=", "[", "x", "[", ":", ":", "-", "1", "]", "for", "x", "in", "next_path_waypoints", "]", "\n", "draw_path", "(", "ax", ",", "waypoints", ",", "head_width", "=", "0.25", ",", "head_length", "=", ".2", ",", "linewidth", "=", "3.0", ",", "delta", "=", "None", ",", "color", "=", "'green'", ")", "\n", "\n", "# highlight robot pose", "\n", "pose", "=", "next_path_waypoints", "[", "0", "]", "\n", "plot", "[", "pose", "[", "0", "]", ",", "pose", "[", "1", "]", ",", ":", "]", "=", "pose_color", "\n", "ax", ".", "imshow", "(", "plot", ")", "\n", "# sns.heatmap(plot, ax=ax, cbar=False)", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render": [[484, 504], ["env.FieldEnv._setup_render", "env.FieldEnv.render_map", "matplotlib.pause", "env.FieldEnv.ax[].set_title", "env.FieldEnv.ax[].set_title", "env.FieldEnv.ax[].set_title", "true.min", "true.max", "seaborn.heatmap", "seaborn.heatmap"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup_render", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render_map"], ["", "def", "render", "(", "self", ",", "next_path_waypoints", ",", "all_paths", ",", "next_static_locations", ",", "all_static_locations", ",", "true", "=", "None", ",", "pred", "=", "None", ")", ":", "\n", "        ", "if", "true", "is", "not", "None", "and", "pred", "is", "not", "None", ":", "\n", "            ", "num_axes", "=", "3", "\n", "", "else", ":", "\n", "            ", "num_axes", "=", "1", "\n", "\n", "", "self", ".", "_setup_render", "(", "num_axes", "=", "num_axes", ")", "\n", "\n", "self", ".", "render_map", "(", "self", ".", "ax", "[", "0", "]", ",", "next_path_waypoints", ",", "all_paths", ",", "next_static_locations", ",", "all_static_locations", ")", "\n", "if", "num_axes", "==", "3", ":", "\n", "            ", "sz", "=", "15", "\n", "self", ".", "ax", "[", "0", "]", ".", "set_title", "(", "'Field Environment'", ",", "fontsize", "=", "sz", ")", "\n", "self", ".", "ax", "[", "1", "]", ".", "set_title", "(", "'Predicted Phenotype distribution'", ",", "fontsize", "=", "sz", ")", "\n", "self", ".", "ax", "[", "2", "]", ".", "set_title", "(", "'Actual Phenotype distribution'", ",", "fontsize", "=", "sz", ")", "\n", "vmin", "=", "true", ".", "min", "(", ")", "\n", "vmax", "=", "true", ".", "max", "(", ")", "\n", "# TODO: colorbar is not cleared when .cla() is called", "\n", "sns", ".", "heatmap", "(", "pred", ",", "ax", "=", "self", ".", "ax", "[", "1", "]", ",", "cmap", "=", "'ocean'", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ",", "cbar", "=", "False", ",", "square", "=", "True", ")", "\n", "sns", ".", "heatmap", "(", "true", ",", "ax", "=", "self", ".", "ax", "[", "2", "]", ",", "cmap", "=", "'ocean'", ",", "vmin", "=", "vmin", ",", "vmax", "=", "vmax", ",", "cbar", "=", "False", ",", "square", "=", "True", ")", "\n", "", "plt", ".", "pause", "(", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup_render": [[505, 518], ["matplotlib.ion", "matplotlib.subplots", "env.FieldEnv.ax.flatten", "ax_.get_xaxis().set_visible", "ax_.get_yaxis().set_visible", "ax_.cla", "ax_.get_xaxis", "ax_.get_yaxis"], "methods", ["None"], ["", "def", "_setup_render", "(", "self", ",", "num_axes", ")", ":", "\n", "        ", "if", "self", ".", "fig", "is", "None", ":", "\n", "            ", "plt", ".", "ion", "(", ")", "\n", "self", ".", "fig", ",", "self", ".", "ax", "=", "plt", ".", "subplots", "(", "ncols", "=", "num_axes", ",", "figsize", "=", "(", "4", "*", "num_axes", ",", "4", ")", ")", "\n", "self", ".", "ax", "=", "[", "self", ".", "ax", "]", "if", "num_axes", "==", "1", "else", "self", ".", "ax", ".", "flatten", "(", ")", "\n", "# clear all ticks", "\n", "for", "ax_", "in", "self", ".", "ax", ":", "\n", "                ", "ax_", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "ax_", ".", "get_yaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "", "", "else", ":", "\n", "# clear all axes", "\n", "            ", "for", "ax_", "in", "self", ".", "ax", ":", "\n", "                ", "ax_", ".", "cla", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render_naive": [[519, 536], ["env.FieldEnv._setup_render", "env.FieldEnv.render_map", "matplotlib.pause", "ipdb.set_trace", "range", "reversed", "range", "range"], "methods", ["home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv._setup_render", "home.repos.pwc.inspect_result.sumitsk_algp.None.env.FieldEnv.render_map"], ["", "", "", "def", "render_naive", "(", "self", ")", ":", "\n", "        ", "num_axes", "=", "1", "\n", "self", ".", "_setup_render", "(", "num_axes", ")", "\n", "\n", "# waypoints", "\n", "first_array", "=", "[", "(", "i", ",", "0", ")", "for", "i", "in", "range", "(", "self", ".", "map", ".", "shape", "[", "0", "]", ")", "]", "\n", "second_array", "=", "[", "(", "i", ",", "2", ")", "for", "i", "in", "reversed", "(", "range", "(", "self", ".", "map", ".", "shape", "[", "0", "]", ")", ")", "]", "\n", "third_array", "=", "[", "(", "i", ",", "4", ")", "for", "i", "in", "range", "(", "self", ".", "map", ".", "shape", "[", "0", "]", ")", "]", "\n", "\n", "\n", "all_paths", "=", "[", "]", "\n", "next_path_waypoints", "=", "first_array", "+", "[", "(", "self", ".", "map", ".", "shape", "[", "0", "]", "-", "1", ",", "1", ")", "]", "+", "second_array", "+", "[", "(", "0", ",", "3", ")", "]", "+", "third_array", "\n", "next_static_locations", "=", "[", "]", "\n", "all_static_locations", "=", "[", "]", "\n", "self", ".", "render_map", "(", "self", ".", "ax", "[", "0", "]", ",", "next_path_waypoints", ",", "all_paths", ",", "next_static_locations", ",", "all_static_locations", ")", "\n", "plt", ".", "pause", "(", "1", ")", "\n", "ipdb", ".", "set_trace", "(", ")", "\n", "\n"]]}