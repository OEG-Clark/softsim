{"home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.Caratheodory": [[41, 76], ["numpy.count_nonzero", "numpy.nonzero", "numpy.outer", "numpy.linalg.svd", "numpy.insert", "numpy.nonzero", "numpy.min", "numpy.zeros", "numpy.ones", "numpy.sum", "numpy.argmin", "numpy.argmin"], "function", ["None"], ["def", "Caratheodory", "(", "P", ",", "u", ",", "dtype", "=", "'float64'", ")", ":", "\n", "    ", "\"\"\"\n    Implementation of the Caratheodory Theorem(1907)\n    input: a numpy array P containing n rows (points), each of size d, and a positive vector of weights u (that sums to 1)\n    output:a new vector of weights new_u that satisfies :\n                1. new_u is positive and sums to 1\n                2. new_u has at most d+1 non zero entries\n                3. the weighted sum of P and u (input) is the same as the weighted sum of P and new_u (output)\n    computation time: O(n^2d^2)\n    \"\"\"", "\n", "while", "1", ":", "\n", "        ", "n", "=", "np", ".", "count_nonzero", "(", "u", ")", "\n", "d", "=", "P", ".", "shape", "[", "1", "]", "\n", "u_non_zero", "=", "np", ".", "nonzero", "(", "u", ")", "\n", "\n", "if", "n", "<=", "d", "+", "1", ":", "\n", "            ", "return", "u", "\n", "\n", "", "A", "=", "P", "[", "u_non_zero", "]", "\n", "reduced_vec", "=", "np", ".", "outer", "(", "A", "[", "0", "]", ",", "np", ".", "ones", "(", "A", ".", "shape", "[", "0", "]", "-", "1", ",", "dtype", "=", "dtype", ")", ")", "\n", "A", "=", "A", "[", "1", ":", "]", ".", "T", "-", "reduced_vec", "\n", "\n", "_", ",", "_", ",", "V", "=", "np", ".", "linalg", ".", "svd", "(", "A", ",", "full_matrices", "=", "True", ")", "\n", "v", "=", "V", "[", "-", "1", "]", "\n", "v", "=", "np", ".", "insert", "(", "v", ",", "[", "0", "]", ",", "-", "1", "*", "np", ".", "sum", "(", "v", ")", ")", "\n", "\n", "idx_good_alpha", "=", "np", ".", "nonzero", "(", "v", ">", "0", ")", "\n", "alpha", "=", "np", ".", "min", "(", "u", "[", "u_non_zero", "]", "[", "idx_good_alpha", "]", "/", "v", "[", "idx_good_alpha", "]", ")", "\n", "\n", "w", "=", "np", ".", "zeros", "(", "u", ".", "shape", "[", "0", "]", ",", "dtype", "=", "dtype", ")", "\n", "tmp_w", "=", "u", "[", "u_non_zero", "]", "-", "alpha", "*", "v", "\n", "tmp_w", "[", "np", ".", "argmin", "(", "tmp_w", ")", "]", "=", "0.0", "\n", "w", "[", "u_non_zero", "]", "=", "tmp_w", "\n", "w", "[", "u_non_zero", "]", "[", "np", ".", "argmin", "(", "w", "[", "u_non_zero", "]", ")", "]", "=", "0", "\n", "u", "=", "w", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.Fast_Caratheodory": [[77, 148], ["numpy.sum", "math.ceil", "math.ceil", "np.concatenate.reshape", "numpy.array", "np.concatenate.reshape", "np.concatenate.reshape", "np.array.reshape", "numpy.count_nonzero", "numpy.zeros", "new_idx_array[].reshape().astype", "np.concatenate.reshape", "int", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "numpy.concatenate", "range", "numpy.einsum", "Booster.Caratheodory", "numpy.nonzero", "p_groups[].reshape", "idx_group[].reshape", "numpy.count_nonzero", "math.ceil", "math.ceil", "np.concatenate.reshape", "np.concatenate.reshape", "np.concatenate.reshape", "int", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "new_idx_array[].reshape", "numpy.ones", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.Caratheodory"], ["", "", "def", "Fast_Caratheodory", "(", "P", ",", "u", ",", "coreset_size", ",", "dtype", "=", "'float64'", ")", ":", "\n", "    ", "\"\"\"\n    Our fast and accurate implementation of Caratheodory's Theorem\n    Input: a numpy array P containing n rows (points), each of size d, and a positive vector of weights u (if u does not\n    sum to 1, we first normalize u by its sum, then multiply u back by its original sum before returning it)\n    Output: a new vector of positive weights new_u that satisfies :\n                 1. new_u has at most d+1 non zero entries\n                 2. the weighted sum of P and u (input) is the same as the weighted sum of P and new_u (output)\n    Computation time: O(nd+logn*d^4)\n    \"\"\"", "\n", "d", "=", "P", ".", "shape", "[", "1", "]", "\n", "n", "=", "P", ".", "shape", "[", "0", "]", "\n", "m", "=", "2", "*", "d", "+", "2", "\n", "if", "n", "<=", "d", "+", "1", ":", "\n", "        ", "return", "u", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "", "u_sum", "=", "np", ".", "sum", "(", "u", ")", "\n", "u", "=", "u", "/", "u_sum", "\n", "chunk_size", "=", "math", ".", "ceil", "(", "n", "/", "m", ")", "\n", "current_m", "=", "math", ".", "ceil", "(", "n", "/", "chunk_size", ")", "\n", "\n", "add_z", "=", "chunk_size", "-", "int", "(", "n", "%", "chunk_size", ")", "\n", "u", "=", "u", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "if", "add_z", "!=", "chunk_size", ":", "\n", "        ", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ",", "P", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "P", "=", "np", ".", "concatenate", "(", "(", "P", ",", "zeros", ")", ")", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ",", "u", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "u", "=", "np", ".", "concatenate", "(", "(", "u", ",", "zeros", ")", ")", "\n", "\n", "", "idxarray", "=", "np", ".", "array", "(", "range", "(", "P", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "p_groups", "=", "P", ".", "reshape", "(", "current_m", ",", "chunk_size", ",", "P", ".", "shape", "[", "1", "]", ")", "\n", "u_groups", "=", "u", ".", "reshape", "(", "current_m", ",", "chunk_size", ")", "\n", "idx_group", "=", "idxarray", ".", "reshape", "(", "current_m", ",", "chunk_size", ")", "\n", "u_nonzero", "=", "np", ".", "count_nonzero", "(", "u", ")", "\n", "\n", "if", "not", "coreset_size", ":", "\n", "        ", "coreset_size", "=", "d", "+", "1", "\n", "", "while", "u_nonzero", ">", "coreset_size", ":", "\n", "\n", "        ", "groups_means", "=", "np", ".", "einsum", "(", "'ijk,ij->ik'", ",", "p_groups", ",", "u_groups", ")", "\n", "group_weigts", "=", "np", ".", "ones", "(", "groups_means", ".", "shape", "[", "0", "]", ",", "dtype", "=", "dtype", ")", "*", "1", "/", "current_m", "\n", "\n", "Cara_u_idx", "=", "Caratheodory", "(", "groups_means", ",", "group_weigts", ",", "dtype", "=", "dtype", ")", "\n", "\n", "IDX", "=", "np", ".", "nonzero", "(", "Cara_u_idx", ")", "\n", "\n", "new_P", "=", "p_groups", "[", "IDX", "]", ".", "reshape", "(", "-", "1", ",", "d", ")", "\n", "\n", "subset_u", "=", "(", "current_m", "*", "u_groups", "[", "IDX", "]", "*", "Cara_u_idx", "[", "IDX", "]", "[", ":", ",", "np", ".", "newaxis", "]", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "new_idx_array", "=", "idx_group", "[", "IDX", "]", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "##############################################################################3", "\n", "u_nonzero", "=", "np", ".", "count_nonzero", "(", "subset_u", ")", "\n", "chunk_size", "=", "math", ".", "ceil", "(", "new_P", ".", "shape", "[", "0", "]", "/", "m", ")", "\n", "current_m", "=", "math", ".", "ceil", "(", "new_P", ".", "shape", "[", "0", "]", "/", "chunk_size", ")", "\n", "\n", "add_z", "=", "chunk_size", "-", "int", "(", "new_P", ".", "shape", "[", "0", "]", "%", "chunk_size", ")", "\n", "if", "add_z", "!=", "chunk_size", ":", "\n", "            ", "new_P", "=", "np", ".", "concatenate", "(", "(", "new_P", ",", "np", ".", "zeros", "(", "(", "add_z", ",", "new_P", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", ")", ")", "\n", "subset_u", "=", "np", ".", "concatenate", "(", "(", "subset_u", ",", "np", ".", "zeros", "(", "(", "add_z", ",", "subset_u", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", ")", ")", "\n", "new_idx_array", "=", "np", ".", "concatenate", "(", "(", "new_idx_array", ",", "np", ".", "zeros", "(", "(", "add_z", ",", "new_idx_array", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", ")", ")", "\n", "", "p_groups", "=", "new_P", ".", "reshape", "(", "current_m", ",", "chunk_size", ",", "new_P", ".", "shape", "[", "1", "]", ")", "\n", "u_groups", "=", "subset_u", ".", "reshape", "(", "current_m", ",", "chunk_size", ")", "\n", "idx_group", "=", "new_idx_array", ".", "reshape", "(", "current_m", ",", "chunk_size", ")", "\n", "###########################################################", "\n", "\n", "", "new_u", "=", "np", ".", "zeros", "(", "n", ")", "\n", "subset_u", "=", "subset_u", "[", "(", "new_idx_array", "<", "n", ")", "]", "\n", "new_idx_array", "=", "new_idx_array", "[", "(", "new_idx_array", "<", "n", ")", "]", ".", "reshape", "(", "-", "1", ")", ".", "astype", "(", "int", ")", "\n", "new_u", "[", "new_idx_array", "]", "=", "subset_u", "\n", "return", "u_sum", "*", "new_u", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.linregcoreset": [[150, 181], ["np.append.reshape", "numpy.einsum", "np.append.reshape", "Booster.Fast_Caratheodory", "numpy.nonzero", "numpy.append", "np.append.reshape", "Fast_Caratheodory.reshape", "Fast_Caratheodory.reshape"], "function", ["home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.Fast_Caratheodory"], ["", "def", "linregcoreset", "(", "P", ",", "u", ",", "b", "=", "None", ",", "c_size", "=", "None", ",", "dtype", "=", "'float64'", ")", ":", "\n", "    ", "\"\"\"\n    This function computes a coreset for linear regression.\n    Input: a numpy array P containing n rows (points), each of size d, a positive vector of weights u of size n, a labels\n           vector b of size n, coreset size c_size (not required).\n    Output: a new numpy array new_P containing the coreset points in its rows and a new vector new_u of positive weights,\n            and a new vector of labels new_b for the coreset. The output satisfies for every vector x that:\n                 ||sqrt(u.transpose())*(Px-b)||^2 = ||sqrt(new_u.transpose())*(new_Px-new_b)||^2\n                 i.e., the output of a call to linearRegression with the original input or with the coreset is the same.\n    Computation time: O(nd^2+logn*d^8)\n    \"\"\"", "\n", "if", "b", "is", "not", "None", ":", "\n", "        ", "P_tag", "=", "np", ".", "append", "(", "P", ",", "b", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "P_tag", "=", "P", "\n", "\n", "", "n_tag", "=", "P_tag", ".", "shape", "[", "0", "]", ";", "d_tag", "=", "P_tag", ".", "shape", "[", "1", "]", "\n", "P_tag", "=", "P_tag", ".", "reshape", "(", "n_tag", ",", "d_tag", ",", "1", ")", "\n", "\n", "P_tag", "=", "np", ".", "einsum", "(", "\"ikj,ijk->ijk\"", ",", "P_tag", ",", "P_tag", ")", "\n", "P_tag", "=", "P_tag", ".", "reshape", "(", "n_tag", ",", "-", "1", ")", "\n", "n_tag", "=", "P_tag", ".", "shape", "[", "0", "]", ";", "d_tag", "=", "P_tag", ".", "shape", "[", "1", "]", "\n", "\n", "coreset_weigts", "=", "Fast_Caratheodory", "(", "P_tag", ".", "reshape", "(", "n_tag", ",", "-", "1", ")", ",", "u", ",", "c_size", ",", "dtype", "=", "dtype", ")", "\n", "new_idx_array", "=", "np", ".", "nonzero", "(", "coreset_weigts", ")", "\n", "coreset_weigts", "=", "coreset_weigts", "[", "new_idx_array", "]", "\n", "\n", "if", "b", "is", "not", "None", ":", "\n", "        ", "return", "P", "[", "new_idx_array", "]", ",", "coreset_weigts", ".", "reshape", "(", "-", "1", ")", ",", "b", "[", "new_idx_array", "]", "\n", "", "else", ":", "\n", "        ", "return", "P", "[", "new_idx_array", "]", ",", "coreset_weigts", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.stream_coreset": [[183, 229], ["int", "Booster.linregcoreset", "range", "Booster.linregcoreset", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "numpy.concatenate", "Booster.linregcoreset", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "numpy.concatenate", "numpy.zeros", "numpy.concatenate"], "function", ["home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.linregcoreset", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.linregcoreset", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.linregcoreset"], ["", "", "def", "stream_coreset", "(", "P", ",", "u", ",", "b", ",", "folds", "=", "None", ",", "dtype", "=", "'float64'", ")", ":", "\n", "    ", "\"\"\"\n    This function computes a coreset for LMS solvers that use k-fold cross validation. It partitions the data into \"folds\"\n    parts, and computes a coreset for every part using the function linregcoreset.\n    Input: a numpy array P containing n rows (points), each of size d, a positive vector of weights u of size n, a labels\n           vector b of size n, and the number of folds used in the cross validation.\n    Output: a new numpy array new_P containing the coreset points in its rows and a new vector new_u of positive weights,\n            and a new vector of labels new_b for the coreset. The output satisfies for every vector x that:\n                 ||sqrt(u.transpose())*(Px-b)||^2 = ||sqrt(new_u.transpose())*(new_Px-new_b)||^2\n                 i.e., the output of a call to linearRegression with the original input or with the coreset is the same.\n    Computation time: O(nd^2+logn*d^8)\n    \"\"\"", "\n", "if", "folds", "is", "None", ":", "\n", "        ", "return", "linregcoreset", "(", "P", ",", "u", ",", "b", ",", "dtype", "=", "dtype", ")", "\n", "", "m", "=", "int", "(", "P", ".", "shape", "[", "0", "]", "/", "folds", ")", "\n", "\n", "d", "=", "P", ".", "shape", "[", "1", "]", "\n", "size_of_coreset", "=", "(", "(", "d", "+", "1", ")", "*", "(", "d", "+", "1", ")", "+", "1", ")", "\n", "\n", "batches", "=", "folds", "\n", "cc", ",", "uc", ",", "bc", "=", "linregcoreset", "(", "P", "[", "0", ":", "m", "]", ",", "u", "[", "0", ":", "m", "]", ",", "b", "[", "0", ":", "m", "]", ",", "dtype", "=", "dtype", ")", "\n", "\n", "if", "cc", ".", "shape", "[", "0", "]", "<", "size_of_coreset", "and", "folds", ":", "\n", "            ", "add_z", "=", "size_of_coreset", "-", "cc", ".", "shape", "[", "0", "]", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ",", "cc", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "cc", "=", "np", ".", "concatenate", "(", "(", "cc", ",", "zeros", ")", ")", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ")", ",", "dtype", "=", "dtype", ")", "\n", "uc", "=", "np", ".", "concatenate", "(", "(", "uc", ",", "zeros", ")", ")", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ",", "bc", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "bc", "=", "np", ".", "concatenate", "(", "(", "bc", ",", "zeros", ")", ")", "\n", "\n", "", "for", "batch", "in", "range", "(", "1", ",", "batches", ")", ":", "\n", "        ", "coreset", ",", "new_u", ",", "new_b", "=", "linregcoreset", "(", "P", "[", "batch", "*", "m", ":", "(", "batch", "+", "1", ")", "*", "m", "]", ",", "u", "[", "batch", "*", "m", ":", "(", "batch", "+", "1", ")", "*", "m", "]", ",", "b", "[", "batch", "*", "m", ":", "(", "batch", "+", "1", ")", "*", "m", "]", ",", "dtype", "=", "dtype", ")", "\n", "\n", "if", "coreset", ".", "shape", "[", "0", "]", "<", "size_of_coreset", "and", "folds", ":", "\n", "            ", "add_z", "=", "size_of_coreset", "-", "coreset", ".", "shape", "[", "0", "]", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ",", "coreset", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "coreset", "=", "np", ".", "concatenate", "(", "(", "coreset", ",", "zeros", ")", ")", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ")", ",", "dtype", "=", "dtype", ")", "\n", "new_u", "=", "np", ".", "concatenate", "(", "(", "new_u", ",", "zeros", ")", ")", "\n", "zeros", "=", "np", ".", "zeros", "(", "(", "add_z", ",", "new_b", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "new_b", "=", "np", ".", "concatenate", "(", "(", "new_b", ",", "zeros", ")", ")", "\n", "", "bc", "=", "np", ".", "concatenate", "(", "(", "bc", ",", "new_b", ")", ")", "\n", "cc", "=", "np", ".", "concatenate", "(", "(", "cc", ",", "coreset", ")", ")", "\n", "uc", "=", "np", ".", "concatenate", "(", "(", "uc", ",", "new_u", ")", ")", "\n", "", "return", "cc", ",", "uc", ",", "bc", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.test_model": [[233, 238], ["clf.score", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "test_model", "(", "test_data", ",", "test_labels", ",", "test_weights", ",", "clf", ")", ":", "\n", "    ", "weighted_test_data", "=", "test_data", "*", "np", ".", "sqrt", "(", "test_weights", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "weighted_test_labels", "=", "test_labels", "*", "np", ".", "sqrt", "(", "test_weights", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "score", "=", "clf", ".", "score", "(", "weighted_test_data", ",", "weighted_test_labels", ")", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.train_model": [[240, 248], ["time.time", "clf.fit", "time.time", "numpy.sqrt", "numpy.sqrt"], "function", ["None"], ["", "def", "train_model", "(", "data", ",", "labels", ",", "weights", ",", "clf", ")", ":", "\n", "    ", "time_start", "=", "time", ".", "time", "(", ")", "\n", "weighted_data", "=", "data", "*", "np", ".", "sqrt", "(", "weights", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "weighted_labels", "=", "(", "labels", "*", "np", ".", "sqrt", "(", "weights", "[", ":", ",", "np", ".", "newaxis", "]", ")", ")", ".", "ravel", "(", ")", "\n", "clf", ".", "fit", "(", "weighted_data", ",", "weighted_labels", ")", "\n", "time_end", "=", "time", ".", "time", "(", ")", "\n", "\n", "return", "time_end", "-", "time_start", ",", "clf", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.coreset_train_model": [[250, 265], ["time.time", "Booster.stream_coreset", "time.time", "numpy.sqrt", "numpy.sqrt", "clf.fit", "clf.fit", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.stream_coreset"], ["", "def", "coreset_train_model", "(", "data", ",", "labels", ",", "weights", ",", "clf", ",", "folds", "=", "None", ",", "solver", "=", "'ridge'", ")", ":", "\n", "    ", "time_start", "=", "time", ".", "time", "(", ")", "\n", "\n", "coreset", ",", "coreset_weights", ",", "coreset_labels", "=", "stream_coreset", "(", "data", ",", "weights", ",", "labels", ",", "folds", "=", "folds", ")", "\n", "weighted_coreset", "=", "coreset", "*", "np", ".", "sqrt", "(", "coreset_weights", "[", ":", ",", "np", ".", "newaxis", "]", ")", "\n", "weighted_coreset_labels", "=", "(", "coreset_labels", "*", "np", ".", "sqrt", "(", "coreset_weights", "[", ":", ",", "np", ".", "newaxis", "]", ")", ")", ".", "ravel", "(", ")", "\n", "\n", "if", "solver", "in", "[", "'lasso'", ",", "'elastic'", "]", ":", "\n", "        ", "const", "=", "np", ".", "sqrt", "(", "coreset", ".", "shape", "[", "0", "]", "/", "data", ".", "shape", "[", "0", "]", ")", "\n", "clf", ".", "fit", "(", "const", "*", "weighted_coreset", ",", "const", "*", "weighted_coreset_labels", ")", "\n", "", "else", ":", "\n", "        ", "clf", ".", "fit", "(", "weighted_coreset", ",", "weighted_coreset_labels", ")", "\n", "", "time_end", "=", "time", ".", "time", "(", ")", "\n", "\n", "return", "time_end", "-", "time_start", ",", "clf", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.get_new_clf": [[267, 279], ["sklearn.model_selection.KFold", "sklearn.linear_model.LinearRegression", "numpy.arange", "sklearn.linear_model.RidgeCV", "sklearn.linear_model.LassoCV", "sklearn.linear_model.ElasticNetCV"], "function", ["None"], ["", "def", "get_new_clf", "(", "solver", ",", "folds", "=", "3", ",", "alphas", "=", "100", ")", ":", "\n", "    ", "kf", "=", "KFold", "(", "n_splits", "=", "folds", ",", "shuffle", "=", "False", ")", "\n", "if", "\"linear\"", "==", "solver", ":", "\n", "        ", "clf", "=", "linear_model", ".", "LinearRegression", "(", "fit_intercept", "=", "False", ")", "\n", "", "if", "\"ridge\"", "==", "solver", ":", "\n", "        ", "alphas", "=", "np", ".", "arange", "(", "1", "/", "alphas", ",", "10", "+", "1", "/", "alphas", ",", "10", "/", "alphas", ")", "\n", "clf", "=", "linear_model", ".", "RidgeCV", "(", "alphas", "=", "alphas", ",", "fit_intercept", "=", "False", ",", "cv", "=", "kf", ")", "\n", "", "elif", "\"lasso\"", "==", "solver", ":", "\n", "        ", "clf", "=", "linear_model", ".", "LassoCV", "(", "n_alphas", "=", "alphas", ",", "fit_intercept", "=", "False", ",", "cv", "=", "kf", ")", "\n", "", "elif", "\"elastic\"", "==", "solver", ":", "\n", "        ", "clf", "=", "linear_model", ".", "ElasticNetCV", "(", "n_alphas", "=", "alphas", ",", "fit_intercept", "=", "False", ",", "cv", "=", "kf", ")", "\n", "", "return", "clf", "\n", "\n"]], "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.main": [[281, 308], ["numpy.floor", "numpy.floor", "numpy.ones", "Booster.get_new_clf", "Booster.coreset_train_model", "Booster.test_model", "Booster.get_new_clf", "Booster.train_model", "Booster.test_model", "print", "numpy.random.rand", "numpy.random.rand", "numpy.abs", "numpy.sum", "numpy.abs"], "function", ["home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.get_new_clf", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.coreset_train_model", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.test_model", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.get_new_clf", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.train_model", "home.repos.pwc.inspect_result.ibramjub_Fast-and-Accurate-Least-Mean-Squares-Solvers.None.Booster.test_model"], ["", "def", "main", "(", ")", ":", "\n", "    ", "n", "=", "240000", "\n", "d", "=", "3", "\n", "data_range", "=", "100", "\n", "num_of_alphas", "=", "300", "\n", "folds", "=", "3", "\n", "data", "=", "np", ".", "floor", "(", "np", ".", "random", ".", "rand", "(", "n", ",", "d", ")", "*", "data_range", ")", "\n", "labels", "=", "np", ".", "floor", "(", "np", ".", "random", ".", "rand", "(", "n", ",", "1", ")", "*", "data_range", ")", "\n", "weights", "=", "np", ".", "ones", "(", "n", ")", "\n", "\n", "for", "solver", "in", "[", "\"lasso\"", ",", "\"ridge\"", ",", "\"elastic\"", "]", ":", "\n", "#########RIDGE REGRESSION#############", "\n", "        ", "clf", "=", "get_new_clf", "(", "solver", ",", "folds", "=", "folds", ",", "alphas", "=", "num_of_alphas", ")", "\n", "time_coreset", ",", "clf_coreset", "=", "coreset_train_model", "(", "data", ",", "labels", ",", "weights", ",", "clf", ",", "folds", "=", "folds", ",", "solver", "=", "solver", ")", "\n", "score_coreset", "=", "test_model", "(", "data", ",", "labels", ",", "weights", ",", "clf", ")", "\n", "\n", "clf", "=", "get_new_clf", "(", "solver", ",", "folds", "=", "folds", ",", "alphas", "=", "num_of_alphas", ")", "\n", "time_real", ",", "clf_real", "=", "train_model", "(", "data", ",", "labels", ",", "weights", ",", "clf", ")", "\n", "score_real", "=", "test_model", "(", "data", ",", "labels", ",", "weights", ",", "clf", ")", "\n", "\n", "print", "(", "\" solver: {}\\n number_of_alphas: {}, \\nscore_diff = {}\\n---->coef diff = {}\\n---->coreset_time = {}\\n---->data time = {}\"", ".", "format", "(", "\n", "solver", ",", "\n", "num_of_alphas", ",", "\n", "np", ".", "abs", "(", "score_coreset", "-", "score_real", ")", ",", "\n", "np", ".", "sum", "(", "np", ".", "abs", "(", "clf_real", ".", "coef_", "-", "clf_coreset", ".", "coef_", ")", ")", ",", "\n", "time_coreset", ",", "\n", "time_real", ")", ")", "\n", "############################################", "\n"]]}