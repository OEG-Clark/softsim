{"home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.__init__": [[4, 35], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ")", ":", "\n", "#common", "\n", "        ", "self", ".", "model", "=", "\"\"", "\n", "self", ".", "graph_pairs_dir", "=", "\"/dir_of_graph_pairs\"", "\n", "self", ".", "p_thresh", "=", "3", "\n", "self", ".", "batch_size", "=", "128", "\n", "self", ".", "pair_list_dir", "=", "''", "\n", "#arch", "\n", "self", ".", "keep_node", "=", "1", "\n", "self", ".", "filters_1", "=", "64", "\n", "self", ".", "filters_2", "=", "64", "\n", "self", ".", "filters_3", "=", "32", "\n", "self", ".", "tensor_neurons", "=", "16", "\n", "self", ".", "bottle_neck_neurons", "=", "16", "\n", "self", ".", "K", "=", "10", "\n", "#train", "\n", "self", ".", "epochs", "=", "500", "\n", "self", ".", "train_sequences", "=", "[", "]", "\n", "self", ".", "eval_sequences", "=", "[", "]", "\n", "self", ".", "dropout", "=", "0", "\n", "self", ".", "learning_rate", "=", "1e-3", "\n", "self", ".", "weight_decay", "=", "5e-4", "\n", "self", ".", "gpu", "=", "0", "\n", "self", ".", "logdir", "=", "\"./logs\"", "\n", "self", ".", "node_num", "=", "100", "\n", "#eva_batch", "\n", "self", ".", "sequences", "=", "[", "]", "\n", "self", ".", "output_path", "=", "\"./eva\"", "\n", "self", ".", "show", "=", "False", "\n", "#eva_pair", "\n", "self", ".", "pair_file", "=", "\"\"", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load": [[36, 69], ["yaml.load", "open", "os.path.abspath"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load"], ["", "def", "load", "(", "self", ",", "config_file", ")", ":", "\n", "        ", "config_args", "=", "yaml", ".", "load", "(", "open", "(", "os", ".", "path", ".", "abspath", "(", "config_file", ")", ")", ")", "\n", "#arch", "\n", "self", ".", "keep_node", "=", "config_args", "[", "'arch'", "]", "[", "'keep_node'", "]", "\n", "self", ".", "filters_1", "=", "config_args", "[", "'arch'", "]", "[", "'filters_1'", "]", "\n", "self", ".", "filters_2", "=", "config_args", "[", "'arch'", "]", "[", "'filters_2'", "]", "\n", "self", ".", "filters_3", "=", "config_args", "[", "'arch'", "]", "[", "'filters_3'", "]", "\n", "self", ".", "tensor_neurons", "=", "config_args", "[", "'arch'", "]", "[", "'tensor_neurons'", "]", "\n", "self", ".", "bottle_neck_neurons", "=", "config_args", "[", "'arch'", "]", "[", "'bottle_neck_neurons'", "]", "\n", "self", ".", "K", "=", "config_args", "[", "'arch'", "]", "[", "'K'", "]", "\n", "#train", "\n", "self", ".", "epochs", "=", "config_args", "[", "'train'", "]", "[", "'epochs'", "]", "\n", "self", ".", "train_sequences", "=", "config_args", "[", "'train'", "]", "[", "'train_sequences'", "]", "\n", "self", ".", "eval_sequences", "=", "config_args", "[", "'train'", "]", "[", "'eval_sequences'", "]", "\n", "self", ".", "dropout", "=", "config_args", "[", "'train'", "]", "[", "'dropout'", "]", "\n", "self", ".", "learning_rate", "=", "config_args", "[", "'train'", "]", "[", "'learning_rate'", "]", "\n", "self", ".", "weight_decay", "=", "config_args", "[", "'train'", "]", "[", "'weight_decay'", "]", "\n", "self", ".", "gpu", "=", "config_args", "[", "'train'", "]", "[", "'gpu'", "]", "\n", "self", ".", "logdir", "=", "config_args", "[", "'train'", "]", "[", "'logdir'", "]", "\n", "self", ".", "node_num", "=", "config_args", "[", "'train'", "]", "[", "'node_num'", "]", "\n", "#common", "\n", "self", ".", "model", "=", "config_args", "[", "'common'", "]", "[", "'model'", "]", "\n", "self", ".", "cuda", "=", "config_args", "[", "'common'", "]", "[", "'cuda'", "]", "\n", "self", ".", "batch_size", "=", "config_args", "[", "'common'", "]", "[", "'batch_size'", "]", "\n", "self", ".", "p_thresh", "=", "config_args", "[", "'common'", "]", "[", "'p_thresh'", "]", "\n", "self", ".", "graph_pairs_dir", "=", "config_args", "[", "'common'", "]", "[", "'graph_pairs_dir'", "]", "\n", "self", ".", "pair_list_dir", "=", "config_args", "[", "'common'", "]", "[", "'pair_list_dir'", "]", "\n", "#eva_batch", "\n", "self", ".", "sequences", "=", "config_args", "[", "'eva_batch'", "]", "[", "'sequences'", "]", "\n", "self", ".", "output_path", "=", "config_args", "[", "'eva_batch'", "]", "[", "'output_path'", "]", "\n", "self", ".", "show", "=", "config_args", "[", "'eva_batch'", "]", "[", "'show'", "]", "\n", "#eva_pair", "\n", "self", ".", "pair_file", "=", "config_args", "[", "'eva_pair'", "]", "[", "'pair_file'", "]", "", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.eval_pair.main": [[6, 14], ["parser_sg.sgpr_args", "parser_sg.sgpr_args.load", "utils.tab_printer", "sg_net.SGTrainer", "sg_net.SGTrainer.model.eval", "sg_net.SGTrainer.eval_batch_pair", "print"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.tab_printer", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.eval_batch_pair"], ["def", "main", "(", ")", ":", "\n", "    ", "args", "=", "sgpr_args", "(", ")", "\n", "args", ".", "load", "(", "'./config/config.yml'", ")", "\n", "tab_printer", "(", "args", ")", "\n", "trainer", "=", "SGTrainer", "(", "args", ",", "False", ")", "\n", "trainer", ".", "model", ".", "eval", "(", ")", "\n", "pred", ",", "gt", "=", "trainer", ".", "eval_batch_pair", "(", "[", "args", ".", "pair_file", ",", "]", ")", "\n", "print", "(", "\"Score:\"", ",", "pred", "[", "0", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.AttentionModule.__init__": [[7, 15], ["super().__init__", "layers_batch.AttentionModule.setup_weights", "layers_batch.AttentionModule.init_parameters"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.setup_weights", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.init_parameters"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "\"\"\"\n        :param args: Arguments object.\n        \"\"\"", "\n", "super", "(", "AttentionModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "setup_weights", "(", ")", "\n", "self", ".", "init_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.AttentionModule.setup_weights": [[16, 21], ["torch.nn.Parameter", "torch.Tensor"], "methods", ["None"], ["", "def", "setup_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Defining weights.\n        \"\"\"", "\n", "self", ".", "weight_matrix", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "args", ".", "filters_3", ",", "self", ".", "args", ".", "filters_3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.AttentionModule.init_parameters": [[22, 27], ["torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "init_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initializing weights.\n        \"\"\"", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_matrix", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.AttentionModule.forward": [[28, 40], ["torch.mean", "torch.tanh", "torch.sigmoid", "torch.matmul", "torch.matmul", "torch.matmul", "embedding.permute", "torch.tanh.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "embedding", ")", ":", "\n", "        ", "\"\"\"\n        Making a forward propagation pass to create a graph level representation.\n        :param embedding: Result of the GCN.\n        :return representation: A graph level representation vector. \n        \"\"\"", "\n", "batch_size", "=", "embedding", ".", "shape", "[", "0", "]", "\n", "global_context", "=", "torch", ".", "mean", "(", "torch", ".", "matmul", "(", "embedding", ",", "self", ".", "weight_matrix", ")", ",", "dim", "=", "1", ")", "# 0 # nxf -> f  bxnxf->bxf", "\n", "transformed_global", "=", "torch", ".", "tanh", "(", "global_context", ")", "# f  bxf", "\n", "sigmoid_scores", "=", "torch", ".", "sigmoid", "(", "torch", ".", "matmul", "(", "embedding", ",", "transformed_global", ".", "view", "(", "batch_size", ",", "-", "1", ",", "1", ")", ")", ")", "#weights      nxf fx1  bxnxf bxfx1 bxnx1", "\n", "representation", "=", "torch", ".", "matmul", "(", "embedding", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ",", "sigmoid_scores", ")", "# bxnxf bxfxn bxnx1 bxfx1", "\n", "return", "representation", ",", "sigmoid_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.__init__": [[45, 53], ["super().__init__", "layers_batch.TenorNetworkModule.setup_weights", "layers_batch.TenorNetworkModule.init_parameters"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.setup_weights", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.init_parameters"], ["def", "__init__", "(", "self", ",", "args", ")", ":", "\n", "        ", "\"\"\"\n        :param args: Arguments object.\n        \"\"\"", "\n", "super", "(", "TenorNetworkModule", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "setup_weights", "(", ")", "\n", "self", ".", "init_parameters", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.setup_weights": [[54, 61], ["torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.Tensor", "torch.Tensor", "torch.Tensor"], "methods", ["None"], ["", "def", "setup_weights", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Defining weights.\n        \"\"\"", "\n", "self", ".", "weight_matrix", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "args", ".", "filters_3", ",", "self", ".", "args", ".", "filters_3", ",", "self", ".", "args", ".", "tensor_neurons", ")", ")", "\n", "self", ".", "weight_matrix_block", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "args", ".", "tensor_neurons", ",", "2", "*", "self", ".", "args", ".", "filters_3", ")", ")", "\n", "self", ".", "bias", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "Tensor", "(", "self", ".", "args", ".", "tensor_neurons", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.init_parameters": [[62, 69], ["torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_", "torch.nn.init.xavier_uniform_"], "methods", ["None"], ["", "def", "init_parameters", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Initializing weights.\n        \"\"\"", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_matrix", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "weight_matrix_block", ")", "\n", "torch", ".", "nn", ".", "init", ".", "xavier_uniform_", "(", "self", ".", "bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.layers_batch.TenorNetworkModule.forward": [[70, 84], ["torch.matmul().view", "torch.matmul", "torch.cat", "torch.matmul", "torch.nn.functional.relu", "torch.matmul.permute", "torch.matmul", "embedding_1.permute", "layers_batch.TenorNetworkModule.weight_matrix.view"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "embedding_1", ",", "embedding_2", ")", ":", "\n", "        ", "\"\"\"\n        Making a forward propagation pass to create a similarity vector.\n        :param embedding_1: Result of the 1st embedding after attention.    bxfx1\n        :param embedding_2: Result of the 2nd embedding after attention.\n        :return scores: A similarity score vector.\n        \"\"\"", "\n", "batch_size", "=", "embedding_1", ".", "shape", "[", "0", "]", "\n", "scoring", "=", "torch", ".", "matmul", "(", "embedding_1", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ",", "self", ".", "weight_matrix", ".", "view", "(", "self", ".", "args", ".", "filters_3", ",", "-", "1", ")", ")", ".", "view", "(", "batch_size", ",", "self", ".", "args", ".", "filters_3", ",", "self", ".", "args", ".", "tensor_neurons", ")", "\n", "scoring", "=", "torch", ".", "matmul", "(", "scoring", ".", "permute", "(", "0", ",", "2", ",", "1", ")", ",", "embedding_2", ")", "# bxfx1", "\n", "combined_representation", "=", "torch", ".", "cat", "(", "(", "embedding_1", ",", "embedding_2", ")", ",", "dim", "=", "1", ")", "# bx2fx1", "\n", "block_scoring", "=", "torch", ".", "matmul", "(", "self", ".", "weight_matrix_block", ",", "combined_representation", ")", "# bxtensor_neuronsx1", "\n", "scores", "=", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "scoring", "+", "block_scoring", "+", "self", ".", "bias", ")", "\n", "return", "scores", "\n", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.eval_batch.main": [[14, 92], ["parser_sg.sgpr_args", "parser_sg.sgpr_args.load", "utils.tab_printer", "sg_net.SGTrainer", "sg_net.SGTrainer.model.eval", "tqdm.tqdm", "len", "parser_sg.sgpr_args.load", "parser_sg.sgpr_args.load", "os.path.abspath", "os.path.exists", "os.makedirs", "print", "utils.load_paires", "tqdm.tqdm", "numpy.array", "numpy.array", "os.path.join", "os.path.join", "numpy.save", "numpy.save", "sklearn.metrics.roc_curve", "sklearn.metrics.auc", "print", "print", "print", "print", "matplotlib.pyplot.figure", "matplotlib.pyplot.plot", "matplotlib.pyplot.plot", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.legend", "os.path.join", "matplotlib.pyplot.savefig", "sklearn.metrics.precision_recall_curve", "matplotlib.pyplot.figure", "matplotlib.pyplot.plot", "matplotlib.pyplot.axis", "matplotlib.pyplot.xlabel", "matplotlib.pyplot.ylabel", "matplotlib.pyplot.title", "matplotlib.pyplot.legend", "os.path.join", "matplotlib.pyplot.savefig", "numpy.nan_to_num", "numpy.max", "os.path.join", "print", "os.path.join", "sg_net.SGTrainer.eval_batch_pair", "np.array.extend", "np.array.extend", "len", "len", "numpy.sum", "matplotlib.pyplot.show", "open", "out.write", "range", "str", "len"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.tab_printer", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.load_paires", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.eval_batch_pair"], ["def", "main", "(", ")", ":", "\n", "    ", "args", "=", "sgpr_args", "(", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", ">", "1", ":", "\n", "        ", "args", ".", "load", "(", "sys", ".", "argv", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "args", ".", "load", "(", "'./config/config.yml'", ")", "\n", "", "args", ".", "load", "(", "os", ".", "path", ".", "abspath", "(", "'./config/config.yml'", ")", ")", "\n", "tab_printer", "(", "args", ")", "\n", "trainer", "=", "SGTrainer", "(", "args", ",", "False", ")", "\n", "trainer", ".", "model", ".", "eval", "(", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "args", ".", "output_path", ")", ":", "\n", "            ", "os", ".", "makedirs", "(", "args", ".", "output_path", ")", "\n", "", "for", "sequence", "in", "tqdm", "(", "args", ".", "sequences", ")", ":", "\n", "        ", "print", "(", "\"sequence: \"", ",", "sequence", ")", "\n", "gt_db", "=", "[", "]", "\n", "pred_db", "=", "[", "]", "\n", "graph_pairs", "=", "load_paires", "(", "os", ".", "path", ".", "join", "(", "args", ".", "pair_list_dir", ",", "sequence", "+", "\".txt\"", ")", ",", "args", ".", "graph_pairs_dir", ")", "\n", "batches", "=", "[", "graph_pairs", "[", "graph", ":", "graph", "+", "args", ".", "batch_size", "]", "for", "graph", "in", "\n", "range", "(", "0", ",", "len", "(", "graph_pairs", ")", ",", "args", ".", "batch_size", ")", "]", "\n", "for", "batch", "in", "tqdm", "(", "batches", ")", ":", "\n", "            ", "pred", ",", "gt", "=", "trainer", ".", "eval_batch_pair", "(", "batch", ")", "\n", "pred_db", ".", "extend", "(", "pred", ")", "\n", "gt_db", ".", "extend", "(", "gt", ")", "\n", "", "assert", "len", "(", "pred_db", ")", "==", "len", "(", "gt_db", ")", "\n", "assert", "np", ".", "sum", "(", "gt_db", ")", ">", "0", "# gt_db should have positive samples", "\n", "# calc metrics", "\n", "pred_db", "=", "np", ".", "array", "(", "pred_db", ")", "\n", "gt_db", "=", "np", ".", "array", "(", "gt_db", ")", "\n", "# save results", "\n", "gt_db_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_path", ",", "sequence", "+", "\"_gt_db.npy\"", ")", "\n", "pred_db_path", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_path", ",", "sequence", "+", "\"_DL_db.npy\"", ")", "\n", "np", ".", "save", "(", "gt_db_path", ",", "gt_db", ")", "\n", "np", ".", "save", "(", "pred_db_path", ",", "pred_db", ")", "\n", "#####ROC", "\n", "fpr", ",", "tpr", ",", "roc_thresholds", "=", "metrics", ".", "roc_curve", "(", "gt_db", ",", "pred_db", ")", "\n", "roc_auc", "=", "metrics", ".", "auc", "(", "fpr", ",", "tpr", ")", "\n", "print", "(", "\"fpr: \"", ",", "fpr", ")", "\n", "print", "(", "\"tpr: \"", ",", "tpr", ")", "\n", "print", "(", "\"thresholds: \"", ",", "roc_thresholds", ")", "\n", "print", "(", "\"roc_auc: \"", ",", "roc_auc", ")", "\n", "\n", "# plot ROC Curve", "\n", "plt", ".", "figure", "(", "0", ")", "\n", "lw", "=", "2", "\n", "plt", ".", "plot", "(", "fpr", ",", "tpr", ",", "color", "=", "'darkorange'", ",", "\n", "lw", "=", "lw", ",", "label", "=", "'ROC curve (area = %0.2f)'", "%", "roc_auc", ")", "\n", "plt", ".", "plot", "(", "[", "0", ",", "1", "]", ",", "[", "0", ",", "1", "]", ",", "color", "=", "'navy'", ",", "lw", "=", "lw", ",", "linestyle", "=", "'--'", ")", "\n", "plt", ".", "xlabel", "(", "'False Positive Rate'", ")", "\n", "plt", ".", "ylabel", "(", "'True Positive Rate'", ")", "\n", "plt", ".", "title", "(", "'DL ROC Curve'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "roc_out", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_path", ",", "sequence", "+", "\"_DL_roc_curve.png\"", ")", "\n", "plt", ".", "savefig", "(", "roc_out", ")", "\n", "\n", "#### P-R", "\n", "precision", ",", "recall", ",", "pr_thresholds", "=", "metrics", ".", "precision_recall_curve", "(", "gt_db", ",", "pred_db", ")", "\n", "# plot p-r curve", "\n", "plt", ".", "figure", "(", "1", ")", "\n", "lw", "=", "2", "\n", "plt", ".", "plot", "(", "recall", ",", "precision", ",", "color", "=", "'darkorange'", ",", "\n", "lw", "=", "lw", ",", "label", "=", "'P-R curve'", ")", "\n", "plt", ".", "axis", "(", "[", "0", ",", "1", ",", "0", ",", "1", "]", ")", "\n", "plt", ".", "xlabel", "(", "'Recall'", ")", "\n", "plt", ".", "ylabel", "(", "'Precision'", ")", "\n", "plt", ".", "title", "(", "'DL Precision-Recall Curve'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "\"lower right\"", ")", "\n", "pr_out", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_path", ",", "sequence", "+", "\"_DL_pr_curve.png\"", ")", "\n", "plt", ".", "savefig", "(", "pr_out", ")", "\n", "if", "args", ".", "show", ":", "\n", "            ", "plt", ".", "show", "(", ")", "\n", "# calc F1-score", "\n", "", "F1_score", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", "\n", "F1_score", "=", "np", ".", "nan_to_num", "(", "F1_score", ")", "\n", "F1_max_score", "=", "np", ".", "max", "(", "F1_score", ")", "\n", "f1_out", "=", "os", ".", "path", ".", "join", "(", "args", ".", "output_path", ",", "sequence", "+", "\"_DL_F1_max.txt\"", ")", "\n", "print", "(", "'F1 max score'", ",", "F1_max_score", ")", "\n", "with", "open", "(", "f1_out", ",", "\"w\"", ")", "as", "out", ":", "\n", "            ", "out", ".", "write", "(", "str", "(", "F1_max_score", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.main_sg.main": [[6, 19], ["parser_sg.sgpr_args", "utils.tab_printer", "sg_net.SGTrainer", "sg_net.SGTrainer.fit", "sg_net.SGTrainer.score", "len", "parser_sg.sgpr_args.load", "parser_sg.sgpr_args.load"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.tab_printer", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.fit", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.score", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load"], ["def", "main", "(", ")", ":", "\n", "    ", "\"\"\"\n    Parsing command line parameters, reading data, fitting and scoring a SimGNN model.\n    \"\"\"", "\n", "args", "=", "sgpr_args", "(", ")", "\n", "if", "len", "(", "sys", ".", "argv", ")", ">", "1", ":", "\n", "        ", "args", ".", "load", "(", "sys", ".", "argv", "[", "1", "]", ")", "\n", "", "else", ":", "\n", "        ", "args", ".", "load", "(", "'./config/config.yml'", ")", "\n", "", "tab_printer", "(", "args", ")", "\n", "trainer", "=", "SGTrainer", "(", "args", ",", "True", ")", "\n", "trainer", ".", "fit", "(", ")", "\n", "trainer", ".", "score", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.__init__": [[24, 33], ["super().__init__", "sg_net.SG.setup_layers"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.setup_layers"], ["def", "__init__", "(", "self", ",", "args", ",", "number_of_labels", ")", ":", "\n", "        ", "\"\"\"\n        :param args: Arguments object.\n        :param number_of_labels: Number of node labels.\n        \"\"\"", "\n", "super", "(", "SG", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "number_labels", "=", "number_of_labels", "\n", "self", ".", "setup_layers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.calculate_bottleneck_features": [[34, 39], ["None"], "methods", ["None"], ["", "def", "calculate_bottleneck_features", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Deciding the shape of the bottleneck layer.\n        \"\"\"", "\n", "self", ".", "feature_count", "=", "self", ".", "args", ".", "tensor_neurons", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.setup_layers": [[40, 77], ["sg_net.SG.calculate_bottleneck_features", "layers_batch.AttentionModule", "layers_batch.TenorNetworkModule", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.calculate_bottleneck_features"], ["", "def", "setup_layers", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Creating the layers.\n        \"\"\"", "\n", "self", ".", "calculate_bottleneck_features", "(", ")", "\n", "self", ".", "attention", "=", "AttentionModule", "(", "self", ".", "args", ")", "\n", "self", ".", "tensor_network", "=", "TenorNetworkModule", "(", "self", ".", "args", ")", "\n", "self", ".", "fully_connected_first", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "feature_count", ",", "self", ".", "args", ".", "bottle_neck_neurons", ")", "\n", "self", ".", "scoring_layer", "=", "torch", ".", "nn", ".", "Linear", "(", "self", ".", "args", ".", "bottle_neck_neurons", ",", "1", ")", "\n", "bias_bool", "=", "False", "# TODO", "\n", "self", ".", "dgcnn_s_conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "3", "*", "2", ",", "self", ".", "args", ".", "filters_1", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "args", ".", "filters_1", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "dgcnn_f_conv1", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "number_labels", "*", "2", ",", "self", ".", "args", ".", "filters_1", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "args", ".", "filters_1", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "dgcnn_s_conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "args", ".", "filters_1", "*", "2", ",", "self", ".", "args", ".", "filters_2", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "args", ".", "filters_2", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "dgcnn_f_conv2", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "args", ".", "filters_1", "*", "2", ",", "self", ".", "args", ".", "filters_2", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "args", ".", "filters_2", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "dgcnn_s_conv3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "args", ".", "filters_2", "*", "2", ",", "self", ".", "args", ".", "filters_3", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "args", ".", "filters_3", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "dgcnn_f_conv3", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "self", ".", "args", ".", "filters_2", "*", "2", ",", "self", ".", "args", ".", "filters_3", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "self", ".", "args", ".", "filters_3", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "dgcnn_conv_end", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv1d", "(", "self", ".", "args", ".", "filters_3", "*", "2", ",", "\n", "self", ".", "args", ".", "filters_3", ",", "kernel_size", "=", "1", ",", "bias", "=", "bias_bool", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "self", ".", "args", ".", "filters_3", ")", ",", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.dgcnn_conv_pass": [[79, 111], ["dgcnn.get_graph_feature", "sg_net.SG.dgcnn_s_conv1", "dgcnn.get_graph_feature", "sg_net.SG.dgcnn_s_conv2", "dgcnn.get_graph_feature", "sg_net.SG.dgcnn_s_conv3", "dgcnn.get_graph_feature", "sg_net.SG.dgcnn_f_conv1", "dgcnn.get_graph_feature", "sg_net.SG.dgcnn_f_conv2", "dgcnn.get_graph_feature", "sg_net.SG.dgcnn_f_conv3", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "sg_net.SG.dgcnn_conv_end", "x.permute.permute.permute", "sg_net.SG.max", "sg_net.SG.max", "sg_net.SG.max", "sg_net.SG.max", "sg_net.SG.max", "sg_net.SG.max"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature"], ["", "def", "dgcnn_conv_pass", "(", "self", ",", "x", ")", ":", "\n", "        ", "self", ".", "k", "=", "self", ".", "args", ".", "K", "\n", "xyz", "=", "x", "[", ":", ",", ":", "3", ",", ":", "]", "# Bx3xN", "\n", "sem", "=", "x", "[", ":", ",", "3", ":", ",", ":", "]", "# BxfxN", "\n", "\n", "xyz", "=", "dgcnn", ".", "get_graph_feature", "(", "xyz", ",", "k", "=", "self", ".", "k", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "#Bx6xNxk", "\n", "xyz", "=", "self", ".", "dgcnn_s_conv1", "(", "xyz", ")", "\n", "xyz1", "=", "xyz", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "xyz", "=", "dgcnn", ".", "get_graph_feature", "(", "xyz1", ",", "k", "=", "self", ".", "k", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "\n", "xyz", "=", "self", ".", "dgcnn_s_conv2", "(", "xyz", ")", "\n", "xyz2", "=", "xyz", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "xyz", "=", "dgcnn", ".", "get_graph_feature", "(", "xyz2", ",", "k", "=", "self", ".", "k", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "\n", "xyz", "=", "self", ".", "dgcnn_s_conv3", "(", "xyz", ")", "\n", "xyz3", "=", "xyz", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "\n", "sem", "=", "dgcnn", ".", "get_graph_feature", "(", "sem", ",", "k", "=", "self", ".", "k", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "# Bx2fxNxk", "\n", "sem", "=", "self", ".", "dgcnn_f_conv1", "(", "sem", ")", "\n", "sem1", "=", "sem", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "sem", "=", "dgcnn", ".", "get_graph_feature", "(", "sem1", ",", "k", "=", "self", ".", "k", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "\n", "sem", "=", "self", ".", "dgcnn_f_conv2", "(", "sem", ")", "\n", "sem2", "=", "sem", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "sem", "=", "dgcnn", ".", "get_graph_feature", "(", "sem2", ",", "k", "=", "self", ".", "k", ",", "cuda", "=", "self", ".", "args", ".", "cuda", ")", "\n", "sem", "=", "self", ".", "dgcnn_f_conv3", "(", "sem", ")", "\n", "sem3", "=", "sem", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "(", "xyz3", ",", "sem3", ")", ",", "dim", "=", "1", ")", "\n", "# x = self.dgcnn_conv_all(x)", "\n", "x", "=", "self", ".", "dgcnn_conv_end", "(", "x", ")", "\n", "# print(x.shape)", "\n", "\n", "x", "=", "x", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "# [node_num, 32]", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.forward": [[112, 139], ["data[].cuda", "data[].cuda", "sg_net.SG.dgcnn_conv_pass", "sg_net.SG.dgcnn_conv_pass", "sg_net.SG.attention", "sg_net.SG.attention", "sg_net.SG.tensor_network", "torch.nn.functional.relu.permute", "torch.nn.functional.relu.permute", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.sigmoid().reshape", "torch.sigmoid().reshape", "torch.sigmoid().reshape", "torch.sigmoid().reshape", "sg_net.SG.fully_connected_first", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "torch.sigmoid", "sg_net.SG.scoring_layer"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.dgcnn_conv_pass", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SG.dgcnn_conv_pass"], ["", "def", "forward", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"\n        Forward pass with graphs.\n        :param data: Data dictionary.\n        :return score: Similarity score.\n        \"\"\"", "\n", "\n", "features_1", "=", "data", "[", "\"features_1\"", "]", ".", "cuda", "(", "self", ".", "args", ".", "gpu", ")", "\n", "features_2", "=", "data", "[", "\"features_2\"", "]", ".", "cuda", "(", "self", ".", "args", ".", "gpu", ")", "\n", "\n", "# features B x (3+label_num) x node_num", "\n", "abstract_features_1", "=", "self", ".", "dgcnn_conv_pass", "(", "features_1", ")", "# node_num x feature_size(filters-3)", "\n", "abstract_features_2", "=", "self", ".", "dgcnn_conv_pass", "(", "features_2", ")", "#BXNXF", "\n", "# print(\"abstract feature: \", abstract_features_1.shape)", "\n", "pooled_features_1", ",", "attention_scores_1", "=", "self", ".", "attention", "(", "abstract_features_1", ")", "# bxfx1", "\n", "pooled_features_2", ",", "attention_scores_2", "=", "self", ".", "attention", "(", "abstract_features_2", ")", "\n", "# print(\"pooled_features_1: \", pooled_features_1.shape)", "\n", "scores", "=", "self", ".", "tensor_network", "(", "pooled_features_1", ",", "pooled_features_2", ")", "\n", "# print(\"scores: \", scores.shape)", "\n", "scores", "=", "scores", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "# bx1xf", "\n", "# print(\"scores: \", scores.shape)", "\n", "\n", "scores", "=", "torch", ".", "nn", ".", "functional", ".", "relu", "(", "self", ".", "fully_connected_first", "(", "scores", ")", ")", "\n", "# print(\"scores: \", scores.shape)", "\n", "score", "=", "torch", ".", "sigmoid", "(", "self", ".", "scoring_layer", "(", "scores", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "# print(\"scores: \", score.shape)", "\n", "return", "score", ",", "attention_scores_1", ",", "attention_scores_2", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.__init__": [[146, 156], ["sg_net.SGTrainer.initial_label_enumeration", "sg_net.SGTrainer.setup_model", "tensorboardX.SummaryWriter"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.initial_label_enumeration", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.setup_model"], ["def", "__init__", "(", "self", ",", "args", ",", "train", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        :param args: Arguments object.\n        \"\"\"", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "model_pth", "=", "self", ".", "args", ".", "model", "\n", "\n", "self", ".", "initial_label_enumeration", "(", "train", ")", "\n", "self", ".", "setup_model", "(", "train", ")", "\n", "self", ".", "writer", "=", "SummaryWriter", "(", "logdir", "=", "self", ".", "args", ".", "logdir", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.setup_model": [[158, 177], ["sg_net.SG", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "torch.nn.DataParallel", "sg_net.SGTrainer.model.cuda", "print", "torch.load", "torch.load", "torch.load", "torch.load", "collections.OrderedDict", "torch.load.items", "torch.load.items", "sg_net.SGTrainer.model.load_state_dict", "str"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load"], ["", "def", "setup_model", "(", "self", ",", "train", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Creating a SG Net.\n        \"\"\"", "\n", "self", ".", "model", "=", "SG", "(", "self", ".", "args", ",", "self", ".", "number_of_labels", ")", "\n", "\n", "if", "(", "not", "train", ")", "and", "self", ".", "model_pth", "!=", "\"\"", ":", "\n", "            ", "print", "(", "\"loading model: \"", ",", "self", ".", "model_pth", ")", "\n", "# original saved file with dataparallel", "\n", "state_dict", "=", "torch", ".", "load", "(", "self", ".", "model_pth", ",", "map_location", "=", "'cuda:'", "+", "str", "(", "self", ".", "args", ".", "gpu", ")", ")", "#'cuda:0'", "\n", "# create new dict that does not contain 'module'", "\n", "new_state_dict", "=", "OrderedDict", "(", ")", "\n", "for", "k", ",", "v", "in", "state_dict", ".", "items", "(", ")", ":", "\n", "                ", "name", "=", "k", "[", "7", ":", "]", "# remove 'module'", "\n", "new_state_dict", "[", "name", "]", "=", "v", "\n", "# load params", "\n", "", "self", ".", "model", ".", "load_state_dict", "(", "new_state_dict", ")", "\n", "", "self", ".", "model", "=", "torch", ".", "nn", ".", "DataParallel", "(", "self", ".", "model", ",", "device_ids", "=", "[", "self", ".", "args", ".", "gpu", "]", ")", "\n", "self", ".", "model", ".", "cuda", "(", "self", ".", "args", ".", "gpu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.initial_label_enumeration": [[178, 207], ["print", "len", "print", "print", "print", "print", "utils.load_paires", "sg_net.SGTrainer.training_graphs.extend", "utils.load_paires", "len", "len", "range", "enumerate", "os.path.join", "os.path.join"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.load_paires", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.load_paires"], ["", "def", "initial_label_enumeration", "(", "self", ",", "train", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Collecting the unique node idsentifiers.\n        \"\"\"", "\n", "print", "(", "\"\\nEnumerating unique labels.\\n\"", ")", "\n", "if", "train", ":", "\n", "            ", "self", ".", "training_graphs", "=", "[", "]", "\n", "self", ".", "testing_graphs", "=", "[", "]", "\n", "self", ".", "evaling_graphs", "=", "[", "]", "\n", "train_sequences", "=", "self", ".", "args", ".", "train_sequences", "\n", "eval_sequences", "=", "self", ".", "args", ".", "eval_sequences", "\n", "print", "(", "\"Train sequences: \"", ",", "train_sequences", ")", "\n", "print", "(", "\"evaling sequences: \"", ",", "eval_sequences", ")", "\n", "graph_pairs_dir", "=", "self", ".", "args", ".", "graph_pairs_dir", "\n", "for", "sq", "in", "train_sequences", ":", "\n", "                ", "train_graphs", "=", "load_paires", "(", "os", ".", "path", ".", "join", "(", "self", ".", "args", ".", "pair_list_dir", ",", "sq", "+", "\".txt\"", ")", ",", "graph_pairs_dir", ")", "\n", "self", ".", "training_graphs", ".", "extend", "(", "train_graphs", ")", "\n", "", "for", "sq", "in", "eval_sequences", ":", "\n", "                ", "self", ".", "evaling_graphs", "=", "load_paires", "(", "os", ".", "path", ".", "join", "(", "self", ".", "args", ".", "pair_list_dir", ",", "sq", "+", "\".txt\"", ")", ",", "graph_pairs_dir", ")", "\n", "", "self", ".", "testing_graphs", "=", "self", ".", "evaling_graphs", "\n", "assert", "len", "(", "self", ".", "evaling_graphs", ")", "!=", "0", "\n", "assert", "len", "(", "self", ".", "training_graphs", ")", "!=", "0", "\n", "", "self", ".", "global_labels", "=", "[", "i", "for", "i", "in", "range", "(", "12", ")", "]", "# 20", "\n", "self", ".", "global_labels", "=", "{", "val", ":", "index", "for", "index", ",", "val", "in", "enumerate", "(", "self", ".", "global_labels", ")", "}", "\n", "self", ".", "number_of_labels", "=", "len", "(", "self", ".", "global_labels", ")", "\n", "self", ".", "keepnode", "=", "self", ".", "args", ".", "keep_node", "\n", "\n", "print", "(", "self", ".", "global_labels", ")", "\n", "print", "(", "self", ".", "number_of_labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.create_batches": [[208, 222], ["random.shuffle", "random.shuffle", "range", "range", "len", "len"], "methods", ["None"], ["", "def", "create_batches", "(", "self", ",", "split", "=", "\"train\"", ")", ":", "\n", "        ", "\"\"\"\n        Creating batches from the training graph list.\n        :return batches: List of lists with batches.\n        \"\"\"", "\n", "if", "split", "==", "\"train\"", ":", "\n", "            ", "random", ".", "shuffle", "(", "self", ".", "training_graphs", ")", "\n", "batches", "=", "[", "self", ".", "training_graphs", "[", "graph", ":", "graph", "+", "self", ".", "args", ".", "batch_size", "]", "for", "graph", "in", "\n", "range", "(", "0", ",", "len", "(", "self", ".", "training_graphs", ")", ",", "self", ".", "args", ".", "batch_size", ")", "]", "\n", "", "else", ":", "\n", "            ", "random", ".", "shuffle", "(", "self", ".", "evaling_graphs", ")", "\n", "batches", "=", "[", "self", ".", "evaling_graphs", "[", "graph", ":", "graph", "+", "self", ".", "args", ".", "batch_size", "]", "for", "graph", "in", "\n", "range", "(", "0", ",", "len", "(", "self", ".", "evaling_graphs", ")", ",", "self", ".", "args", ".", "batch_size", ")", "]", "\n", "", "return", "batches", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.augment_data": [[223, 231], ["utils.rotate_point_cloud", "utils.jitter_point_cloud", "utils.random_scale_point_cloud", "utils.rotate_perturbation_point_cloud", "utils.shift_point_cloud"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.rotate_point_cloud", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.jitter_point_cloud", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.random_scale_point_cloud", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.rotate_perturbation_point_cloud", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.shift_point_cloud"], ["", "def", "augment_data", "(", "self", ",", "batch_xyz_1", ")", ":", "\n", "# batch_xyz_1 = flip_point_cloud(batch_xyz_1)", "\n", "        ", "batch_xyz_1", "=", "rotate_point_cloud", "(", "batch_xyz_1", ")", "\n", "batch_xyz_1", "=", "jitter_point_cloud", "(", "batch_xyz_1", ")", "\n", "batch_xyz_1", "=", "random_scale_point_cloud", "(", "batch_xyz_1", ")", "\n", "batch_xyz_1", "=", "rotate_perturbation_point_cloud", "(", "batch_xyz_1", ")", "\n", "batch_xyz_1", "=", "shift_point_cloud", "(", "batch_xyz_1", ")", "\n", "return", "batch_xyz_1", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.pc_normalize": [[232, 240], ["numpy.mean", "numpy.max", "numpy.sqrt", "numpy.sum"], "methods", ["None"], ["", "def", "pc_normalize", "(", "self", ",", "pc", ")", ":", "\n", "        ", "\"\"\" pc: NxC, return NxC \"\"\"", "\n", "l", "=", "pc", ".", "shape", "[", "0", "]", "\n", "centroid", "=", "np", ".", "mean", "(", "pc", ",", "axis", "=", "0", ")", "\n", "pc", "=", "pc", "-", "centroid", "\n", "m", "=", "np", ".", "max", "(", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "pc", "**", "2", ",", "axis", "=", "1", ")", ")", ")", "\n", "pc", "=", "pc", "/", "m", "\n", "return", "pc", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.transfer_to_torch": [[241, 311], ["len", "len", "dict", "numpy.expand_dims", "numpy.expand_dims", "numpy.expand_dims", "numpy.expand_dims", "numpy.concatenate().transpose", "numpy.concatenate().transpose", "numpy.squeeze", "numpy.squeeze", "numpy.random.choice", "numpy.random.choice.sort", "[].tolist", "numpy.random.choice", "numpy.random.choice.sort", "[].tolist", "numpy.array", "numpy.array", "sg_net.SGTrainer.augment_data", "sg_net.SGTrainer.augment_data", "numpy.array", "numpy.concatenate().tolist", "numpy.concatenate", "numpy.array", "numpy.concatenate().tolist", "numpy.concatenate", "random.random", "numpy.concatenate", "numpy.concatenate", "print", "exit", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.zeros", "numpy.array", "numpy.concatenate", "numpy.array", "numpy.zeros", "numpy.zeros().tolist", "numpy.zeros().tolist", "numpy.array", "numpy.array", "numpy.zeros", "sg_net.SGTrainer.global_labels.values", "numpy.zeros", "sg_net.SGTrainer.global_labels.values", "numpy.ones", "numpy.ones"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.augment_data", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.augment_data"], ["", "def", "transfer_to_torch", "(", "self", ",", "data", ",", "training", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Transferring the data to torch and creating a hash table with the indices, features and target.\n        :param data: Data dictionary.\n        :return new_data: Dictionary of Torch Tensors.\n        \"\"\"", "\n", "# data_ori = data.copy()", "\n", "# print(\"data[edge1]: \", data[\"edges_1\"])  # debug", "\n", "\n", "node_num_1", "=", "len", "(", "data", "[", "\"nodes_1\"", "]", ")", "\n", "node_num_2", "=", "len", "(", "data", "[", "\"nodes_2\"", "]", ")", "\n", "if", "node_num_1", ">", "self", ".", "args", ".", "node_num", ":", "\n", "            ", "sampled_index_1", "=", "np", ".", "random", ".", "choice", "(", "node_num_1", ",", "self", ".", "args", ".", "node_num", ",", "replace", "=", "False", ")", "\n", "sampled_index_1", ".", "sort", "(", ")", "\n", "data", "[", "\"nodes_1\"", "]", "=", "np", ".", "array", "(", "data", "[", "\"nodes_1\"", "]", ")", "[", "sampled_index_1", "]", ".", "tolist", "(", ")", "\n", "data", "[", "\"centers_1\"", "]", "=", "np", ".", "array", "(", "data", "[", "\"centers_1\"", "]", ")", "[", "sampled_index_1", "]", "\n", "\n", "", "elif", "node_num_1", "<", "self", ".", "args", ".", "node_num", ":", "\n", "            ", "data", "[", "\"nodes_1\"", "]", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "array", "(", "data", "[", "\"nodes_1\"", "]", ")", ",", "-", "np", ".", "ones", "(", "self", ".", "args", ".", "node_num", "-", "node_num_1", ")", ")", ")", ".", "tolist", "(", ")", "# padding 0", "\n", "data", "[", "\"centers_1\"", "]", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "array", "(", "data", "[", "\"centers_1\"", "]", ")", ",", "np", ".", "zeros", "(", "(", "self", ".", "args", ".", "node_num", "-", "node_num_1", ",", "3", ")", ")", ")", ")", "# padding 0", "\n", "\n", "", "if", "node_num_2", ">", "self", ".", "args", ".", "node_num", ":", "\n", "            ", "sampled_index_2", "=", "np", ".", "random", ".", "choice", "(", "node_num_2", ",", "self", ".", "args", ".", "node_num", ",", "replace", "=", "False", ")", "\n", "sampled_index_2", ".", "sort", "(", ")", "\n", "data", "[", "\"nodes_2\"", "]", "=", "np", ".", "array", "(", "data", "[", "\"nodes_2\"", "]", ")", "[", "sampled_index_2", "]", ".", "tolist", "(", ")", "\n", "data", "[", "\"centers_2\"", "]", "=", "np", ".", "array", "(", "data", "[", "\"centers_2\"", "]", ")", "[", "sampled_index_2", "]", "# node_num x 3", "\n", "", "elif", "node_num_2", "<", "self", ".", "args", ".", "node_num", ":", "\n", "            ", "data", "[", "\"nodes_2\"", "]", "=", "np", ".", "concatenate", "(", "(", "np", ".", "array", "(", "data", "[", "\"nodes_2\"", "]", ")", ",", "-", "np", ".", "ones", "(", "self", ".", "args", ".", "node_num", "-", "node_num_2", ")", ")", ")", ".", "tolist", "(", ")", "\n", "data", "[", "\"centers_2\"", "]", "=", "np", ".", "concatenate", "(", "\n", "(", "np", ".", "array", "(", "data", "[", "\"centers_2\"", "]", ")", ",", "np", ".", "zeros", "(", "(", "self", ".", "args", ".", "node_num", "-", "node_num_2", ",", "3", ")", ")", ")", ")", "# padding 0", "\n", "\n", "", "new_data", "=", "dict", "(", ")", "\n", "features_1", "=", "np", ".", "expand_dims", "(", "np", ".", "array", "(", "\n", "[", "np", ".", "zeros", "(", "self", ".", "number_of_labels", ")", ".", "tolist", "(", ")", "if", "node", "==", "-", "1", "else", "[", "\n", "1.0", "if", "self", ".", "global_labels", "[", "node", "]", "==", "label_index", "else", "0", "for", "label_index", "in", "self", ".", "global_labels", ".", "values", "(", ")", "]", "\n", "for", "node", "in", "data", "[", "\"nodes_1\"", "]", "]", ")", ",", "axis", "=", "0", ")", "\n", "features_2", "=", "np", ".", "expand_dims", "(", "np", ".", "array", "(", "\n", "[", "np", ".", "zeros", "(", "self", ".", "number_of_labels", ")", ".", "tolist", "(", ")", "if", "node", "==", "-", "1", "else", "[", "\n", "1.0", "if", "self", ".", "global_labels", "[", "node", "]", "==", "label_index", "else", "0", "for", "label_index", "in", "self", ".", "global_labels", ".", "values", "(", ")", "]", "\n", "for", "node", "in", "data", "[", "\"nodes_2\"", "]", "]", ")", ",", "axis", "=", "0", ")", "\n", "\n", "\n", "# 1xnode_numx3", "\n", "batch_xyz_1", "=", "np", ".", "expand_dims", "(", "data", "[", "\"centers_1\"", "]", ",", "axis", "=", "0", ")", "\n", "batch_xyz_2", "=", "np", ".", "expand_dims", "(", "data", "[", "\"centers_2\"", "]", ",", "axis", "=", "0", ")", "\n", "if", "training", ":", "\n", "# random flip data", "\n", "            ", "if", "random", ".", "random", "(", ")", ">", "0.5", ":", "\n", "                ", "batch_xyz_1", "[", ":", ",", ":", ",", "0", "]", "=", "-", "batch_xyz_1", "[", ":", ",", ":", ",", "0", "]", "\n", "batch_xyz_2", "[", ":", ",", ":", ",", "0", "]", "=", "-", "batch_xyz_2", "[", ":", ",", ":", ",", "0", "]", "\n", "", "batch_xyz_1", "=", "self", ".", "augment_data", "(", "batch_xyz_1", ")", "\n", "batch_xyz_2", "=", "self", ".", "augment_data", "(", "batch_xyz_2", ")", "\n", "#  Bxnum_nodex(3+num_label) -> Bx(3+num_label)xnum_node", "\n", "", "xyz_feature_1", "=", "np", ".", "concatenate", "(", "(", "batch_xyz_1", ",", "features_1", ")", ",", "axis", "=", "2", ")", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", "\n", "xyz_feature_2", "=", "np", ".", "concatenate", "(", "(", "batch_xyz_2", ",", "features_2", ")", ",", "axis", "=", "2", ")", ".", "transpose", "(", "0", ",", "2", ",", "1", ")", "\n", "new_data", "[", "\"features_1\"", "]", "=", "np", ".", "squeeze", "(", "xyz_feature_1", ")", "\n", "new_data", "[", "\"features_2\"", "]", "=", "np", ".", "squeeze", "(", "xyz_feature_2", ")", "\n", "\n", "\n", "if", "data", "[", "\"distance\"", "]", "<=", "self", ".", "args", ".", "p_thresh", ":", "# TODO", "\n", "            ", "new_data", "[", "\"target\"", "]", "=", "1.0", "\n", "", "elif", "data", "[", "\"distance\"", "]", ">=", "20", ":", "\n", "            ", "new_data", "[", "\"target\"", "]", "=", "0.0", "\n", "", "else", ":", "\n", "            ", "new_data", "[", "\"target\"", "]", "=", "-", "100.0", "\n", "print", "(", "\"distance error: \"", ",", "data", "[", "\"distance\"", "]", ")", "\n", "exit", "(", "-", "1", ")", "\n", "", "return", "new_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.process_batch": [[312, 346], ["sg_net.SGTrainer.optimizer.zero_grad", "dict", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "sg_net.SGTrainer.model", "torch.mean", "torch.mean", "torch.mean", "torch.mean", "torch.mean.item", "torch.mean.item", "prediction.cpu().detach().numpy().reshape", "data[].cpu().detach().numpy().reshape", "utils.process_pair", "sg_net.SGTrainer.transfer_to_torch", "batch_feature_1.append", "batch_feature_2.append", "batch_feature_1.append", "batch_feature_2.append", "batch_target.append", "batch_target.append", "numpy.array", "numpy.array", "numpy.array", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.nn.functional.binary_cross_entropy", "torch.mean.backward", "torch.mean.backward", "sg_net.SGTrainer.optimizer.step", "data[].cuda", "prediction.cpu().detach().numpy", "data[].cpu().detach().numpy", "prediction.cpu().detach", "data[].cpu().detach", "prediction.cpu", "data[].cpu"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.process_pair", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.transfer_to_torch"], ["", "def", "process_batch", "(", "self", ",", "batch", ",", "training", "=", "True", ")", ":", "\n", "        ", "\"\"\"\n        Forward pass with a batch of data.\n        :param batch: Batch of graph pair locations.\n        :return loss: Loss on the batch.\n        \"\"\"", "\n", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", "=", "0", "\n", "batch_target", "=", "[", "]", "\n", "batch_feature_1", "=", "[", "]", "\n", "batch_feature_2", "=", "[", "]", "\n", "for", "graph_pair", "in", "batch", ":", "\n", "            ", "data", "=", "process_pair", "(", "graph_pair", ")", "\n", "data", "=", "self", ".", "transfer_to_torch", "(", "data", ",", "training", ")", "\n", "batch_feature_1", ".", "append", "(", "data", "[", "\"features_1\"", "]", ")", "\n", "batch_feature_2", ".", "append", "(", "data", "[", "\"features_2\"", "]", ")", "\n", "batch_feature_1", ".", "append", "(", "data", "[", "\"features_2\"", "]", ")", "\n", "batch_feature_2", ".", "append", "(", "data", "[", "\"features_1\"", "]", ")", "\n", "target", "=", "data", "[", "\"target\"", "]", "\n", "batch_target", ".", "append", "(", "target", ")", "\n", "batch_target", ".", "append", "(", "target", ")", "\n", "", "data", "=", "dict", "(", ")", "\n", "data", "[", "\"features_1\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_1", ")", ")", "\n", "data", "[", "\"features_2\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_2", ")", ")", "\n", "data", "[", "\"target\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_target", ")", ")", "\n", "prediction", ",", "_", ",", "_", "=", "self", ".", "model", "(", "data", ")", "\n", "losses", "=", "torch", ".", "mean", "(", "torch", ".", "nn", ".", "functional", ".", "binary_cross_entropy", "(", "prediction", ",", "data", "[", "\"target\"", "]", ".", "cuda", "(", "self", ".", "args", ".", "gpu", ")", ")", ")", "\n", "if", "training", ":", "\n", "            ", "losses", ".", "backward", "(", "retain_graph", "=", "True", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "", "loss", "=", "losses", ".", "item", "(", ")", "\n", "pred_batch", "=", "prediction", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "gt_batch", "=", "data", "[", "\"target\"", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "loss", ",", "pred_batch", ",", "gt_batch", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.fit": [[347, 385], ["print", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "sg_net.SGTrainer.model.train", "tqdm.tqdm.trange", "sg_net.SGTrainer.model.parameters", "sg_net.SGTrainer.create_batches", "sg_net.SGTrainer.model.train", "tqdm.tqdm.tqdm", "enumerate", "time.time", "sg_net.SGTrainer.process_batch", "tqdm.tqdm.trange.set_description", "sg_net.SGTrainer.writer.add_scalar", "sg_net.SGTrainer.writer.add_scalar", "print", "sg_net.SGTrainer.score", "sg_net.SGTrainer.writer.add_scalar", "sg_net.SGTrainer.writer.add_scalar", "torch.save", "torch.save", "torch.save", "torch.save", "print", "len", "len", "sg_net.SGTrainer.model.state_dict", "torch.save", "torch.save", "torch.save", "torch.save", "print", "len", "round", "int", "int", "str", "sg_net.SGTrainer.model.state_dict", "int", "int", "int", "len", "int", "len", "int", "len", "int", "len", "str"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.create_batches", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.process_batch", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.score"], ["", "def", "fit", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Fitting a model.\n        \"\"\"", "\n", "print", "(", "\"\\nModel training.\\n\"", ")", "\n", "self", ".", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "model", ".", "parameters", "(", ")", ",", "lr", "=", "self", ".", "args", ".", "learning_rate", ",", "\n", "weight_decay", "=", "self", ".", "args", ".", "weight_decay", ")", "\n", "f1_max_his", "=", "0", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "epochs", "=", "trange", "(", "self", ".", "args", ".", "epochs", ",", "leave", "=", "True", ",", "desc", "=", "\"Epoch\"", ")", "\n", "for", "epoch", "in", "epochs", ":", "\n", "            ", "batches", "=", "self", ".", "create_batches", "(", ")", "\n", "self", ".", "model", ".", "train", "(", ")", "\n", "self", ".", "loss_sum", "=", "0", "\n", "main_index", "=", "0", "\n", "for", "index", ",", "batch", "in", "tqdm", "(", "enumerate", "(", "batches", ")", ",", "total", "=", "len", "(", "batches", ")", ",", "desc", "=", "\"Batches\"", ")", ":", "\n", "                ", "a", "=", "time", ".", "time", "(", ")", "\n", "loss_score", ",", "_", ",", "_", "=", "self", ".", "process_batch", "(", "batch", ")", "\n", "main_index", "=", "main_index", "+", "len", "(", "batch", ")", "\n", "self", ".", "loss_sum", "=", "self", ".", "loss_sum", "+", "loss_score", "*", "len", "(", "batch", ")", "\n", "loss", "=", "self", ".", "loss_sum", "/", "main_index", "\n", "epochs", ".", "set_description", "(", "\"Epoch (Loss=%g)\"", "%", "round", "(", "loss", ",", "5", ")", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Train_sum'", ",", "loss", ",", "int", "(", "epoch", ")", "*", "len", "(", "batches", ")", "*", "int", "(", "self", ".", "args", ".", "batch_size", ")", "+", "main_index", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "'Train loss'", ",", "loss_score", ",", "int", "(", "epoch", ")", "*", "len", "(", "batches", ")", "*", "int", "(", "self", ".", "args", ".", "batch_size", ")", "+", "main_index", ")", "\n", "\n", "", "if", "epoch", "%", "2", "==", "0", ":", "\n", "                ", "print", "(", "\"\\nModel saving.\\n\"", ")", "\n", "loss", ",", "f1_max", "=", "self", ".", "score", "(", "\"eval\"", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "\"eval_loss\"", ",", "loss", ",", "int", "(", "epoch", ")", "*", "len", "(", "batches", ")", "*", "int", "(", "self", ".", "args", ".", "batch_size", ")", ")", "\n", "self", ".", "writer", ".", "add_scalar", "(", "\"f1_max_score\"", ",", "f1_max", ",", "int", "(", "epoch", ")", "*", "len", "(", "batches", ")", "*", "int", "(", "self", ".", "args", ".", "batch_size", ")", ")", "\n", "dict_name", "=", "self", ".", "args", ".", "logdir", "+", "\"/\"", "+", "str", "(", "epoch", ")", "+", "'.pth'", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "dict_name", ")", "\n", "if", "f1_max_his", "<=", "f1_max", ":", "\n", "                    ", "f1_max_his", "=", "f1_max", "\n", "dict_name", "=", "self", ".", "args", ".", "logdir", "+", "\"/\"", "+", "str", "(", "epoch", ")", "+", "\"_best\"", "+", "'.pth'", "\n", "torch", ".", "save", "(", "self", ".", "model", ".", "state_dict", "(", ")", ",", "dict_name", ")", "\n", "print", "(", "\"\\n best model saved \"", ",", "dict_name", ")", "\n", "", "print", "(", "\"------------------------------\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.score": [[386, 423], ["print", "sg_net.SGTrainer.model.eval", "sg_net.SGTrainer.create_batches", "tqdm.tqdm.tqdm", "sklearn.metrics.precision_recall_curve", "numpy.nan_to_num", "numpy.max", "print", "print", "enumerate", "sg_net.SGTrainer.process_batch", "pred_db.extend", "gt_db.extend", "len", "print", "exit", "len", "str", "str"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.create_batches", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.process_batch"], ["", "", "", "def", "score", "(", "self", ",", "split", "=", "'test'", ")", ":", "\n", "        ", "\"\"\"\n        Scoring on the test set.\n        \"\"\"", "\n", "print", "(", "\"\\n\\nModel evaluation.\\n\"", ")", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "self", ".", "scores", "=", "[", "]", "\n", "self", ".", "ground_truth", "=", "[", "]", "\n", "\n", "if", "split", "==", "\"test\"", ":", "\n", "            ", "splits", "=", "self", ".", "testing_graphs", "\n", "", "elif", "split", "==", "\"eval\"", ":", "\n", "            ", "splits", "=", "self", ".", "evaling_graphs", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Check split: \"", ",", "split", ")", "\n", "splits", "=", "[", "]", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "losses", "=", "0", "\n", "pred_db", "=", "[", "]", "\n", "gt_db", "=", "[", "]", "\n", "batches", "=", "self", ".", "create_batches", "(", "split", "=", "\"eval\"", ")", "\n", "for", "index", ",", "batch", "in", "tqdm", "(", "enumerate", "(", "batches", ")", ",", "total", "=", "len", "(", "batches", ")", ",", "desc", "=", "\"Eval Batches\"", ")", ":", "\n", "            ", "loss_score", ",", "pred_b", ",", "gt_b", "=", "self", ".", "process_batch", "(", "batch", ",", "False", ")", "\n", "losses", "+=", "loss_score", "\n", "pred_db", ".", "extend", "(", "pred_b", ")", "\n", "gt_db", ".", "extend", "(", "gt_b", ")", "\n", "\n", "", "precision", ",", "recall", ",", "pr_thresholds", "=", "metrics", ".", "precision_recall_curve", "(", "gt_db", ",", "pred_db", ")", "\n", "# calc F1-score", "\n", "F1_score", "=", "2", "*", "precision", "*", "recall", "/", "(", "precision", "+", "recall", ")", "\n", "F1_score", "=", "np", ".", "nan_to_num", "(", "F1_score", ")", "\n", "F1_max_score", "=", "np", ".", "max", "(", "F1_score", ")", "\n", "print", "(", "\"\\nModel \"", "+", "split", "+", "\" F1_max_score: \"", "+", "str", "(", "F1_max_score", ")", "+", "\".\"", ")", "\n", "model_loss", "=", "losses", "/", "len", "(", "batches", ")", "\n", "print", "(", "\"\\nModel \"", "+", "split", "+", "\" loss: \"", "+", "str", "(", "model_loss", ")", "+", "\".\"", ")", "\n", "return", "model_loss", ",", "F1_max_score", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.print_evaluation": [[424, 433], ["numpy.mean", "numpy.mean", "numpy.mean", "print", "print", "str", "str", "round", "round"], "methods", ["None"], ["", "def", "print_evaluation", "(", "self", ")", ":", "\n", "        ", "\"\"\"\n        Printing the error rates.\n        \"\"\"", "\n", "norm_ged_mean", "=", "np", ".", "mean", "(", "self", ".", "ground_truth", ")", "\n", "base_error", "=", "np", ".", "mean", "(", "[", "(", "n", "-", "norm_ged_mean", ")", "**", "2", "for", "n", "in", "self", ".", "ground_truth", "]", ")", "\n", "model_error", "=", "np", ".", "mean", "(", "self", ".", "scores", ")", "\n", "print", "(", "\"\\nBaseline error: \"", "+", "str", "(", "round", "(", "base_error", ",", "5", ")", ")", "+", "\".\"", ")", "\n", "print", "(", "\"\\nModel test error: \"", "+", "str", "(", "round", "(", "model_error", ",", "5", ")", ")", "+", "\".\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.eval_pair": [[434, 458], ["sg_net.SGTrainer.transfer_to_torch", "batch_feature_1.append", "batch_feature_2.append", "batch_target.append", "dict", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "sg_net.SGTrainer.model.eval", "sg_net.SGTrainer.model", "result_1.cpu().detach().numpy().reshape", "result_2.cpu().detach().numpy().reshape", "result_3.cpu().detach().numpy().reshape", "numpy.array", "numpy.array", "numpy.array", "result_1.cpu().detach().numpy", "result_2.cpu().detach().numpy", "result_3.cpu().detach().numpy", "result_1.cpu().detach", "result_2.cpu().detach", "result_3.cpu().detach", "result_1.cpu", "result_2.cpu", "result_3.cpu"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.transfer_to_torch"], ["", "def", "eval_pair", "(", "self", ",", "pair_file", ")", ":", "\n", "        ", "data", "=", "(", "pair_file", ")", "\n", "data", "=", "self", ".", "transfer_to_torch", "(", "data", ",", "False", ")", "\n", "target", "=", "data", "[", "\"target\"", "]", "\n", "\n", "batch_target", "=", "[", "]", "\n", "batch_feature_1", "=", "[", "]", "\n", "batch_feature_2", "=", "[", "]", "\n", "batch_feature_1", ".", "append", "(", "data", "[", "\"features_1\"", "]", ")", "\n", "batch_feature_2", ".", "append", "(", "data", "[", "\"features_2\"", "]", ")", "\n", "batch_target", ".", "append", "(", "target", ")", "\n", "\n", "data_torch", "=", "dict", "(", ")", "\n", "data_torch", "[", "\"features_1\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_1", ")", ")", "\n", "data_torch", "[", "\"features_2\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_2", ")", ")", "\n", "data_torch", "[", "\"target\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_target", ")", ")", "\n", "self", ".", "model", ".", "eval", "(", ")", "\n", "result_1", ",", "result_2", ",", "result_3", "=", "self", ".", "model", "(", "data_torch", ")", "\n", "prediction", "=", "result_1", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "att_weights_1", "=", "result_2", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "att_weights_2", "=", "result_3", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# print(\"prediction shape: \", prediction.shape)", "\n", "return", "prediction", ",", "att_weights_1", ",", "att_weights_2", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.eval_batch_pair": [[503, 526], ["sg_net.SGTrainer.model.eval", "dict", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "sg_net.SGTrainer.model", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape", "numpy.array().reshape", "utils.process_pair", "sg_net.SGTrainer.transfer_to_torch", "batch_feature_1.append", "batch_feature_2.append", "batch_target.append", "numpy.array", "numpy.array", "numpy.array", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu().detach().numpy", "numpy.array", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu().detach", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.process_pair", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.transfer_to_torch"], ["", "def", "eval_batch_pair", "(", "self", ",", "batch", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "batch_target", "=", "[", "]", "\n", "batch_feature_1", "=", "[", "]", "\n", "batch_feature_2", "=", "[", "]", "\n", "for", "graph_pair", "in", "batch", ":", "\n", "            ", "data", "=", "process_pair", "(", "graph_pair", ")", "\n", "data", "=", "self", ".", "transfer_to_torch", "(", "data", ",", "False", ")", "\n", "batch_feature_1", ".", "append", "(", "data", "[", "\"features_1\"", "]", ")", "\n", "batch_feature_2", ".", "append", "(", "data", "[", "\"features_2\"", "]", ")", "\n", "target", "=", "data", "[", "\"target\"", "]", "\n", "batch_target", ".", "append", "(", "target", ")", "\n", "", "data", "=", "dict", "(", ")", "\n", "data", "[", "\"features_1\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_1", ")", ")", "\n", "data", "[", "\"features_2\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_2", ")", ")", "\n", "data", "[", "\"target\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_target", ")", ")", "\n", "# forward_t = time.time()", "\n", "prediction", ",", "_", ",", "_", "=", "self", ".", "model", "(", "data", ")", "\n", "# print(\"forward time: \", time.time() - forward_t)", "\n", "prediction", "=", "prediction", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "gt", "=", "np", ".", "array", "(", "batch_target", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "prediction", ",", "gt", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.eval_batch_pair_data": [[480, 502], ["sg_net.SGTrainer.model.eval", "dict", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "time.time", "sg_net.SGTrainer.model", "print", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape", "numpy.array().reshape", "sg_net.SGTrainer.transfer_to_torch", "batch_feature_1.append", "batch_feature_2.append", "batch_target.append", "numpy.array", "numpy.array", "numpy.array", "time.time", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu().detach().numpy", "numpy.array", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu().detach", "prediction.cpu().detach().numpy().reshape.cpu().detach().numpy().reshape.cpu"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.transfer_to_torch"], ["", "def", "eval_batch_pair_data", "(", "self", ",", "batch", ")", ":", "\n", "        ", "self", ".", "model", ".", "eval", "(", ")", "\n", "\n", "batch_target", "=", "[", "]", "\n", "batch_feature_1", "=", "[", "]", "\n", "batch_feature_2", "=", "[", "]", "\n", "for", "graph_pair", "in", "batch", ":", "\n", "            ", "data", "=", "self", ".", "transfer_to_torch", "(", "graph_pair", ",", "False", ")", "\n", "batch_feature_1", ".", "append", "(", "data", "[", "\"features_1\"", "]", ")", "\n", "batch_feature_2", ".", "append", "(", "data", "[", "\"features_2\"", "]", ")", "\n", "target", "=", "data", "[", "\"target\"", "]", "\n", "batch_target", ".", "append", "(", "target", ")", "\n", "", "data", "=", "dict", "(", ")", "\n", "data", "[", "\"features_1\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_1", ")", ")", "\n", "data", "[", "\"features_2\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_feature_2", ")", ")", "\n", "data", "[", "\"target\"", "]", "=", "torch", ".", "FloatTensor", "(", "np", ".", "array", "(", "batch_target", ")", ")", "\n", "forward_t", "=", "time", ".", "time", "(", ")", "\n", "prediction", ",", "_", ",", "_", "=", "self", ".", "model", "(", "data", ")", "\n", "print", "(", "\"forward time: \"", ",", "time", ".", "time", "(", ")", "-", "forward_t", ")", "\n", "prediction", "=", "prediction", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "gt", "=", "np", ".", "array", "(", "batch_target", ")", ".", "reshape", "(", "-", "1", ")", "\n", "return", "prediction", ",", "gt", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.write_soft_label": [[528, 565], ["utils.listDir", "range", "print", "print", "print", "len", "json.load", "sg_net.SGTrainer.eval_pair", "os.path.join", "print", "open", "open", "json.dump", "pair_file.split"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.listDir", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.sg_net.SGTrainer.eval_pair"], ["", "def", "write_soft_label", "(", "self", ",", "data_dir", ")", ":", "\n", "        ", "eval_graphs", "=", "[", "]", "\n", "listDir", "(", "data_dir", ",", "eval_graphs", ")", "\n", "TP", "=", "0", "\n", "TN", "=", "0", "\n", "FP", "=", "0", "\n", "FN", "=", "0", "\n", "thresh", "=", "0.5", "\n", "for", "i", "in", "range", "(", "len", "(", "eval_graphs", ")", ")", ":", "\n", "            ", "pair_file", "=", "eval_graphs", "[", "i", "]", "\n", "data", "=", "json", ".", "load", "(", "open", "(", "pair_file", ")", ")", "\n", "pred", ",", "_", ",", "_", "=", "self", ".", "eval_pair", "(", "data", ")", "\n", "\n", "if", "pred", "<=", "thresh", ":", "\n", "                ", "if", "data", "[", "\"distance\"", "]", "<=", "10", ":", "\n", "                    ", "TN", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "FN", "+=", "1", "\n", "", "data", "[", "\"distance\"", "]", "=", "100", "\n", "", "else", ":", "\n", "                ", "if", "data", "[", "\"distance\"", "]", "<=", "10", ":", "\n", "                    ", "TP", "+=", "1", "\n", "", "else", ":", "\n", "                    ", "FP", "+=", "1", "\n", "", "data", "[", "\"distance\"", "]", "=", "0", "\n", "\n", "", "file_name", "=", "os", ".", "path", ".", "join", "(", "\"/media/work/data/kitti/odometry/semantic-kitti/DGCNN_graph_pairs_3_20/pred_label/05\"", ",", "\n", "pair_file", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ")", "\n", "print", "(", "\"write pred label: \"", ",", "file_name", ")", "\n", "with", "open", "(", "file_name", ",", "\"w\"", ",", "encoding", "=", "\"utf-8\"", ")", "as", "file", ":", "\n", "                ", "json", ".", "dump", "(", "data", ",", "file", ")", "\n", "\n", "", "", "precesion", "=", "TP", "/", "(", "TP", "+", "FP", ")", "\n", "recall", "=", "TP", "/", "(", "TP", "+", "FN", ")", "\n", "print", "(", "\"thresh: \"", ",", "thresh", ")", "\n", "print", "(", "\"precision: \"", ",", "precesion", ")", "\n", "print", "(", "\"recall:\"", ",", "recall", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.PointNet.__init__": [[53, 70], ["torch.Module.__init__", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "output_channels", "=", "40", ")", ":", "\n", "        ", "super", "(", "PointNet", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv1d", "(", "3", ",", "64", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv1d", "(", "64", ",", "64", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv1d", "(", "64", ",", "64", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Conv1d", "(", "64", ",", "128", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Conv1d", "(", "128", ",", "args", ".", "emb_dims", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm1d", "(", "64", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm1d", "(", "64", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm1d", "(", "64", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm1d", "(", "128", ")", "\n", "self", ".", "bn5", "=", "nn", ".", "BatchNorm1d", "(", "args", ".", "emb_dims", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "args", ".", "emb_dims", ",", "512", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn6", "=", "nn", ".", "BatchNorm1d", "(", "512", ")", "\n", "self", ".", "dp1", "=", "nn", ".", "Dropout", "(", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "512", ",", "output_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.PointNet.forward": [[71, 82], ["torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.relu", "torch.adaptive_max_pool1d().squeeze", "torch.adaptive_max_pool1d().squeeze", "torch.adaptive_max_pool1d().squeeze", "torch.relu", "torch.relu", "torch.relu", "dgcnn.PointNet.dp1", "dgcnn.PointNet.linear2", "dgcnn.PointNet.bn1", "dgcnn.PointNet.bn2", "dgcnn.PointNet.bn3", "dgcnn.PointNet.bn4", "dgcnn.PointNet.bn5", "dgcnn.PointNet.bn6", "dgcnn.PointNet.conv1", "dgcnn.PointNet.conv2", "dgcnn.PointNet.conv3", "dgcnn.PointNet.conv4", "dgcnn.PointNet.conv5", "torch.adaptive_max_pool1d", "torch.adaptive_max_pool1d", "torch.adaptive_max_pool1d", "dgcnn.PointNet.linear1"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "conv1", "(", "x", ")", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn2", "(", "self", ".", "conv2", "(", "x", ")", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn3", "(", "self", ".", "conv3", "(", "x", ")", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn4", "(", "self", ".", "conv4", "(", "x", ")", ")", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn5", "(", "self", ".", "conv5", "(", "x", ")", ")", ")", "\n", "x", "=", "F", ".", "adaptive_max_pool1d", "(", "x", ",", "1", ")", ".", "squeeze", "(", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn6", "(", "self", ".", "linear1", "(", "x", ")", ")", ")", "\n", "x", "=", "self", ".", "dp1", "(", "x", ")", "\n", "x", "=", "self", ".", "linear2", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.DGCNN.__init__": [[85, 118], ["torch.Module.__init__", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.BatchNorm1d", "torch.Dropout", "torch.Dropout", "torch.Dropout", "torch.Linear", "torch.Linear", "torch.Linear", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv1d", "torch.Conv1d", "torch.Conv1d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__"], ["    ", "def", "__init__", "(", "self", ",", "args", ",", "output_channels", "=", "40", ")", ":", "\n", "        ", "super", "(", "DGCNN", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "args", "=", "args", "\n", "self", ".", "k", "=", "args", ".", "k", "\n", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm2d", "(", "64", ")", "\n", "self", ".", "bn3", "=", "nn", ".", "BatchNorm2d", "(", "128", ")", "\n", "self", ".", "bn4", "=", "nn", ".", "BatchNorm2d", "(", "256", ")", "\n", "self", ".", "bn5", "=", "nn", ".", "BatchNorm1d", "(", "args", ".", "emb_dims", ")", "\n", "\n", "self", ".", "conv1", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "6", ",", "64", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "self", ".", "bn1", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "64", "*", "2", ",", "64", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "self", ".", "bn2", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "64", "*", "2", ",", "128", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "self", ".", "bn3", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "conv4", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv2d", "(", "128", "*", "2", ",", "256", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "self", ".", "bn4", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "conv5", "=", "nn", ".", "Sequential", "(", "nn", ".", "Conv1d", "(", "512", ",", "args", ".", "emb_dims", ",", "kernel_size", "=", "1", ",", "bias", "=", "False", ")", ",", "\n", "self", ".", "bn5", ",", "\n", "nn", ".", "LeakyReLU", "(", "negative_slope", "=", "0.2", ")", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "args", ".", "emb_dims", "*", "2", ",", "512", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn6", "=", "nn", ".", "BatchNorm1d", "(", "512", ")", "\n", "self", ".", "dp1", "=", "nn", ".", "Dropout", "(", "p", "=", "args", ".", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "512", ",", "256", ")", "\n", "self", ".", "bn7", "=", "nn", ".", "BatchNorm1d", "(", "256", ")", "\n", "self", ".", "dp2", "=", "nn", ".", "Dropout", "(", "p", "=", "args", ".", "dropout", ")", "\n", "self", ".", "linear3", "=", "nn", ".", "Linear", "(", "256", ",", "output_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.DGCNN.forward": [[119, 150], ["dgcnn.DGCNN.size", "dgcnn.get_graph_feature", "dgcnn.DGCNN.conv1", "dgcnn.get_graph_feature", "dgcnn.DGCNN.conv2", "dgcnn.get_graph_feature", "dgcnn.DGCNN.conv3", "dgcnn.get_graph_feature", "dgcnn.DGCNN.conv4", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "dgcnn.DGCNN.conv5", "torch.adaptive_max_pool1d().view", "torch.adaptive_max_pool1d().view", "torch.adaptive_max_pool1d().view", "torch.adaptive_avg_pool1d().view", "torch.adaptive_avg_pool1d().view", "torch.adaptive_avg_pool1d().view", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.leaky_relu", "torch.leaky_relu", "torch.leaky_relu", "dgcnn.DGCNN.dp1", "torch.leaky_relu", "torch.leaky_relu", "torch.leaky_relu", "dgcnn.DGCNN.dp2", "dgcnn.DGCNN.linear3", "dgcnn.DGCNN.max", "dgcnn.DGCNN.max", "dgcnn.DGCNN.max", "dgcnn.DGCNN.max", "dgcnn.DGCNN.bn6", "dgcnn.DGCNN.bn7", "torch.adaptive_max_pool1d", "torch.adaptive_max_pool1d", "torch.adaptive_max_pool1d", "torch.adaptive_avg_pool1d", "torch.adaptive_avg_pool1d", "torch.adaptive_avg_pool1d", "dgcnn.DGCNN.linear1", "dgcnn.DGCNN.linear2"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.size", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "x", "=", "get_graph_feature", "(", "x", ",", "k", "=", "self", ".", "k", ",", "xyz", "=", "True", ")", "# only using xyz feature find knn", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x1", "=", "x", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "\n", "x", "=", "get_graph_feature", "(", "x1", ",", "k", "=", "self", ".", "k", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x2", "=", "x", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "\n", "x", "=", "get_graph_feature", "(", "x2", ",", "k", "=", "self", ".", "k", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x3", "=", "x", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "\n", "x", "=", "get_graph_feature", "(", "x3", ",", "k", "=", "self", ".", "k", ")", "\n", "x", "=", "self", ".", "conv4", "(", "x", ")", "\n", "x4", "=", "x", ".", "max", "(", "dim", "=", "-", "1", ",", "keepdim", "=", "False", ")", "[", "0", "]", "\n", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x1", ",", "x2", ",", "x3", ",", "x4", ")", ",", "dim", "=", "1", ")", "\n", "\n", "x", "=", "self", ".", "conv5", "(", "x", ")", "\n", "x1", "=", "F", ".", "adaptive_max_pool1d", "(", "x", ",", "1", ")", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "x2", "=", "F", ".", "adaptive_avg_pool1d", "(", "x", ",", "1", ")", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "x", "=", "torch", ".", "cat", "(", "(", "x1", ",", "x2", ")", ",", "1", ")", "\n", "\n", "x", "=", "F", ".", "leaky_relu", "(", "self", ".", "bn6", "(", "self", ".", "linear1", "(", "x", ")", ")", ",", "negative_slope", "=", "0.2", ")", "\n", "x", "=", "self", ".", "dp1", "(", "x", ")", "\n", "x", "=", "F", ".", "leaky_relu", "(", "self", ".", "bn7", "(", "self", ".", "linear2", "(", "x", ")", ")", ",", "negative_slope", "=", "0.2", ")", "\n", "x", "=", "self", ".", "dp2", "(", "x", ")", "\n", "x", "=", "self", ".", "linear3", "(", "x", ")", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.knn": [[14, 21], ["torch.sum", "torch.sum", "torch.sum", "torch.matmul", "torch.matmul", "torch.matmul", "torch.sum.transpose", "pairwise_distance.topk", "x.transpose"], "function", ["None"], ["def", "knn", "(", "x", ",", "k", ")", ":", "\n", "    ", "inner", "=", "-", "2", "*", "torch", ".", "matmul", "(", "x", ".", "transpose", "(", "2", ",", "1", ")", ",", "x", ")", "\n", "xx", "=", "torch", ".", "sum", "(", "x", "**", "2", ",", "dim", "=", "1", ",", "keepdim", "=", "True", ")", "\n", "pairwise_distance", "=", "-", "xx", "-", "inner", "-", "xx", ".", "transpose", "(", "2", ",", "1", ")", "\n", "\n", "idx", "=", "pairwise_distance", ".", "topk", "(", "k", "=", "k", ",", "dim", "=", "-", "1", ")", "[", "1", "]", "# (batch_size, num_points, k)", "\n", "return", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.get_graph_feature": [[23, 50], ["x.view().repeat.size", "x.view().repeat.size", "x.view().repeat.view", "torch.device", "torch.device", "torch.device", "knn.view", "x.view().repeat.size", "x.view().repeat.transpose().contiguous", "torch.cat().permute.view", "x.view().repeat.view().repeat", "torch.cat().permute", "torch.cat().permute", "torch.cat().permute", "torch.arange().view", "torch.arange().view", "torch.arange().view", "x.view().repeat.view", "dgcnn.knn", "dgcnn.knn", "str", "x.view().repeat.transpose", "x.view().repeat.view", "torch.cat", "torch.cat", "torch.cat", "torch.arange", "torch.arange", "torch.arange"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.size", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.size", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.size", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.knn", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.dgcnn.knn"], ["", "def", "get_graph_feature", "(", "x", ",", "k", "=", "20", ",", "cuda", "=", "0", ",", "idx", "=", "None", ",", "xyz", "=", "False", ")", ":", "\n", "    ", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "num_points", "=", "x", ".", "size", "(", "2", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "-", "1", ",", "num_points", ")", "\n", "if", "idx", "is", "None", ":", "\n", "        ", "if", "xyz", ":", "\n", "            ", "idx", "=", "knn", "(", "x", "[", ":", ",", ":", "3", ",", ":", "]", ",", "k", "=", "k", ")", "# (batch_size, num_points, k)", "\n", "", "else", ":", "\n", "            ", "idx", "=", "knn", "(", "x", ",", "k", "=", "k", ")", "# (batch_size, num_points, k)", "\n", "", "", "device", "=", "torch", ".", "device", "(", "'cuda:'", "+", "str", "(", "cuda", ")", ")", "# 'cuda'", "\n", "\n", "idx_base", "=", "torch", ".", "arange", "(", "0", ",", "batch_size", ",", "device", "=", "device", ")", ".", "view", "(", "-", "1", ",", "1", ",", "1", ")", "*", "num_points", "\n", "\n", "idx", "=", "idx", "+", "idx_base", "\n", "\n", "idx", "=", "idx", ".", "view", "(", "-", "1", ")", "\n", "\n", "_", ",", "num_dims", ",", "_", "=", "x", ".", "size", "(", ")", "\n", "\n", "x", "=", "x", ".", "transpose", "(", "2", ",", "1", ")", ".", "contiguous", "(", ")", "# (batch_size, num_points, num_dims)  -> (batch_size*num_points, num_dims) #   batch_size * num_points * k + range(0, batch_size*num_points)", "\n", "feature", "=", "x", ".", "view", "(", "batch_size", "*", "num_points", ",", "-", "1", ")", "[", "idx", ",", ":", "]", "\n", "feature", "=", "feature", ".", "view", "(", "batch_size", ",", "num_points", ",", "k", ",", "num_dims", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "num_points", ",", "1", ",", "num_dims", ")", ".", "repeat", "(", "1", ",", "1", ",", "k", ",", "1", ")", "\n", "\n", "feature", "=", "torch", ".", "cat", "(", "(", "feature", "-", "x", ",", "x", ")", ",", "dim", "=", "3", ")", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "\n", "return", "feature", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.tab_printer": [[10, 20], ["vars", "sorted", "texttable.Texttable", "texttable.Texttable.add_rows", "print", "vars.keys", "texttable.Texttable.draw", "k.replace().capitalize", "k.replace"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.draw"], ["def", "tab_printer", "(", "args", ")", ":", "\n", "    ", "\"\"\"\n    Function to print the logs in a nice tabular format.\n    :param args: Parameters used for the model.\n    \"\"\"", "\n", "args", "=", "vars", "(", "args", ")", "\n", "keys", "=", "sorted", "(", "args", ".", "keys", "(", ")", ")", "\n", "t", "=", "Texttable", "(", ")", "\n", "t", ".", "add_rows", "(", "[", "[", "\"Parameter\"", ",", "\"Value\"", "]", "]", "+", "[", "[", "k", ".", "replace", "(", "\"_\"", ",", "\" \"", ")", ".", "capitalize", "(", ")", ",", "args", "[", "k", "]", "]", "for", "k", "in", "keys", "]", ")", "\n", "print", "(", "t", ".", "draw", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.process_pair": [[21, 39], ["json.load", "json.load", "math.sqrt", "open", "open"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load", "home.repos.pwc.inspect_result.kxhit_SG_PR.None.parser_sg.sgpr_args.load"], ["", "def", "process_pair", "(", "path", ")", ":", "\n", "    ", "\"\"\"\n    Reading a json file with a pair of graphs.\n    :param path: Path to a JSON file.\n    :return data: Dictionary with data.\n    \"\"\"", "\n", "data1", "=", "json", ".", "load", "(", "open", "(", "path", "[", "0", "]", ")", ")", "\n", "data2", "=", "json", ".", "load", "(", "open", "(", "path", "[", "1", "]", ")", ")", "\n", "data", "=", "{", "}", "\n", "data", "[", "\"centers_1\"", "]", "=", "data1", "[", "\"centers\"", "]", "\n", "data", "[", "\"nodes_1\"", "]", "=", "data1", "[", "\"nodes\"", "]", "\n", "data", "[", "\"centers_2\"", "]", "=", "data2", "[", "\"centers\"", "]", "\n", "data", "[", "\"nodes_2\"", "]", "=", "data2", "[", "\"nodes\"", "]", "\n", "pose1", "=", "data1", "[", "\"pose\"", "]", "\n", "pose2", "=", "data2", "[", "\"pose\"", "]", "\n", "dis", "=", "math", ".", "sqrt", "(", "(", "pose1", "[", "3", "]", "-", "pose2", "[", "3", "]", ")", "**", "2", "+", "(", "pose1", "[", "11", "]", "-", "pose2", "[", "11", "]", ")", "**", "2", ")", "\n", "data", "[", "\"distance\"", "]", "=", "dis", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.calculate_loss": [[40, 51], ["math.log", "math.log"], "function", ["None"], ["", "def", "calculate_loss", "(", "prediction", ",", "target", ")", ":", "\n", "    ", "\"\"\"\n    Calculating the squared loss on the normalized GED.\n    :param prediction: Predicted log value of GED.\n    :param target: Factual log transofmed GED.\n    :return score: Squared error.\n    \"\"\"", "\n", "prediction", "=", "-", "math", ".", "log", "(", "prediction", ")", "\n", "target", "=", "-", "math", ".", "log", "(", "target", ")", "\n", "score", "=", "(", "prediction", "-", "target", ")", "**", "2", "\n", "return", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.calculate_normalized_ged": [[52, 60], ["len", "len"], "function", ["None"], ["", "def", "calculate_normalized_ged", "(", "data", ")", ":", "\n", "    ", "\"\"\"\n    Calculating the normalized GED for a pair of graphs.\n    :param data: Data table.\n    :return norm_ged: Normalized GED score.\n    \"\"\"", "\n", "norm_ged", "=", "data", "[", "\"ged\"", "]", "/", "(", "0.5", "*", "(", "len", "(", "data", "[", "\"labels_1\"", "]", ")", "+", "len", "(", "data", "[", "\"labels_2\"", "]", ")", ")", ")", "\n", "return", "norm_ged", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.load_paires": [[61, 71], ["open", "f.readline", "line.strip().split.strip().split", "paires.append", "line.strip().split.strip", "os.path.join", "os.path.join"], "function", ["None"], ["", "def", "load_paires", "(", "file", ",", "graph_pairs_dir", ")", ":", "\n", "  ", "paires", "=", "[", "]", "\n", "with", "open", "(", "file", ")", "as", "f", ":", "\n", "    ", "while", "True", ":", "\n", "      ", "line", "=", "f", ".", "readline", "(", ")", "\n", "if", "not", "line", ":", "\n", "        ", "break", "\n", "", "line", "=", "line", ".", "strip", "(", ")", ".", "split", "(", "\" \"", ")", "\n", "paires", ".", "append", "(", "[", "os", ".", "path", ".", "join", "(", "graph_pairs_dir", ",", "line", "[", "0", "]", ")", ",", "os", ".", "path", ".", "join", "(", "graph_pairs_dir", ",", "line", "[", "1", "]", ")", "]", ")", "\n", "", "", "return", "paires", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.listDir": [[73, 85], ["os.listdir", "os.path.join", "os.path.isdir", "utils.listDir", "list_name.append"], "function", ["home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.listDir"], ["", "def", "listDir", "(", "path", ",", "list_name", ")", ":", "\n", "    ", "\"\"\"\n    :param path: root_dir\n    :param list_name: abs paths of all files under the root_dir\n    :return:\n    \"\"\"", "\n", "for", "file", "in", "os", ".", "listdir", "(", "path", ")", ":", "\n", "        ", "file_path", "=", "os", ".", "path", ".", "join", "(", "path", ",", "file", ")", "\n", "if", "os", ".", "path", ".", "isdir", "(", "file_path", ")", ":", "\n", "            ", "listDir", "(", "file_path", ",", "list_name", ")", "\n", "", "else", ":", "\n", "            ", "list_name", ".", "append", "(", "file_path", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.flip_point_cloud": [[86, 90], ["random.random"], "function", ["None"], ["", "", "", "def", "flip_point_cloud", "(", "batch_data", ")", ":", "\n", "    ", "if", "random", ".", "random", "(", ")", ">", "0.5", ":", "\n", "        ", "batch_data", "[", ":", ",", ":", ",", "0", "]", "=", "-", "batch_data", "[", ":", ",", ":", ",", "0", "]", "\n", "", "return", "batch_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.rotate_point_cloud": [[91, 116], ["numpy.zeros", "range", "numpy.cos", "numpy.sin", "numpy.array", "numpy.dot", "shape_pc.reshape", "numpy.random.uniform"], "function", ["None"], ["", "def", "rotate_point_cloud", "(", "batch_data", ")", ":", "\n", "  ", "\"\"\" Randomly rotate the point clouds to augument the dataset\n    rotation is per shape based along up direction\n    Input:\n      BxNx3 array, original batch of point clouds\n    Return:\n      BxNx3 array, rotated batch of point clouds\n  \"\"\"", "\n", "rotated_data", "=", "np", ".", "zeros", "(", "batch_data", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "k", "in", "range", "(", "batch_data", ".", "shape", "[", "0", "]", ")", ":", "\n", "    ", "rotation_angle", "=", "np", ".", "random", ".", "uniform", "(", ")", "*", "2", "*", "np", ".", "pi", "\n", "cosval", "=", "np", ".", "cos", "(", "rotation_angle", ")", "\n", "sinval", "=", "np", ".", "sin", "(", "rotation_angle", ")", "\n", "# along y", "\n", "# rotation_matrix = np.array([[cosval, 0, sinval],", "\n", "#               [0, 1, 0],", "\n", "#               [-sinval, 0, cosval]])", "\n", "# shape_pc = batch_data[k, ...]", "\n", "# along z", "\n", "rotation_matrix", "=", "np", ".", "array", "(", "[", "[", "cosval", ",", "-", "sinval", ",", "0", "]", ",", "\n", "[", "sinval", ",", "cosval", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "shape_pc", "=", "batch_data", "[", "k", ",", "...", "]", "\n", "rotated_data", "[", "k", ",", "...", "]", "=", "np", ".", "dot", "(", "shape_pc", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", ",", "rotation_matrix", ")", "\n", "", "return", "rotated_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.jitter_point_cloud": [[117, 129], ["numpy.clip", "numpy.random.randn"], "function", ["None"], ["", "def", "jitter_point_cloud", "(", "batch_data", ",", "sigma", "=", "0.01", ",", "clip", "=", "0.05", ")", ":", "\n", "  ", "\"\"\" Randomly jitter points. jittering is per point.\n    Input:\n      BxNx3 array, original batch of point clouds\n    Return:\n      BxNx3 array, jittered batch of point clouds\n  \"\"\"", "\n", "B", ",", "N", ",", "C", "=", "batch_data", ".", "shape", "\n", "assert", "(", "clip", ">", "0", ")", "\n", "jittered_data", "=", "np", ".", "clip", "(", "sigma", "*", "np", ".", "random", ".", "randn", "(", "B", ",", "N", ",", "C", ")", ",", "-", "1", "*", "clip", ",", "clip", ")", "\n", "jittered_data", "+=", "batch_data", "\n", "return", "jittered_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.random_scale_point_cloud": [[130, 142], ["numpy.random.uniform", "range"], "function", ["None"], ["", "def", "random_scale_point_cloud", "(", "batch_data", ",", "scale_low", "=", "0.8", ",", "scale_high", "=", "1.25", ")", ":", "\n", "  ", "\"\"\" Randomly scale the point cloud. Scale is per point cloud.\n    Input:\n      BxNx3 array, original batch of point clouds\n    Return:\n      BxNx3 array, scaled batch of point clouds\n  \"\"\"", "\n", "B", ",", "N", ",", "C", "=", "batch_data", ".", "shape", "\n", "scales", "=", "np", ".", "random", ".", "uniform", "(", "scale_low", ",", "scale_high", ",", "B", ")", "\n", "for", "batch_index", "in", "range", "(", "B", ")", ":", "\n", "    ", "batch_data", "[", "batch_index", ",", ":", ",", ":", "]", "*=", "scales", "[", "batch_index", "]", "\n", "", "return", "batch_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.rotate_perturbation_point_cloud": [[143, 166], ["numpy.zeros", "range", "numpy.clip", "numpy.array", "numpy.array", "numpy.array", "numpy.dot", "numpy.dot", "numpy.dot", "shape_pc.reshape", "numpy.random.randn", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.cos", "numpy.sin", "numpy.cos", "numpy.sin", "numpy.sin", "numpy.sin"], "function", ["None"], ["", "def", "rotate_perturbation_point_cloud", "(", "batch_data", ",", "angle_sigma", "=", "0.015", ",", "angle_clip", "=", "0.045", ")", ":", "# angle_sigma=0.06, angle_clip=0.18", "\n", "  ", "\"\"\" Randomly perturb the point clouds by small rotations\n    Input:\n      BxNx3 array, original batch of point clouds\n    Return:\n      BxNx3 array, rotated batch of point clouds\n  \"\"\"", "\n", "rotated_data", "=", "np", ".", "zeros", "(", "batch_data", ".", "shape", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "k", "in", "range", "(", "batch_data", ".", "shape", "[", "0", "]", ")", ":", "\n", "    ", "angles", "=", "np", ".", "clip", "(", "angle_sigma", "*", "np", ".", "random", ".", "randn", "(", "3", ")", ",", "-", "angle_clip", ",", "angle_clip", ")", "\n", "Rx", "=", "np", ".", "array", "(", "[", "[", "1", ",", "0", ",", "0", "]", ",", "\n", "[", "0", ",", "np", ".", "cos", "(", "angles", "[", "0", "]", ")", ",", "-", "np", ".", "sin", "(", "angles", "[", "0", "]", ")", "]", ",", "\n", "[", "0", ",", "np", ".", "sin", "(", "angles", "[", "0", "]", ")", ",", "np", ".", "cos", "(", "angles", "[", "0", "]", ")", "]", "]", ")", "\n", "Ry", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "angles", "[", "1", "]", ")", ",", "0", ",", "np", ".", "sin", "(", "angles", "[", "1", "]", ")", "]", ",", "\n", "[", "0", ",", "1", ",", "0", "]", ",", "\n", "[", "-", "np", ".", "sin", "(", "angles", "[", "1", "]", ")", ",", "0", ",", "np", ".", "cos", "(", "angles", "[", "1", "]", ")", "]", "]", ")", "\n", "Rz", "=", "np", ".", "array", "(", "[", "[", "np", ".", "cos", "(", "angles", "[", "2", "]", ")", ",", "-", "np", ".", "sin", "(", "angles", "[", "2", "]", ")", ",", "0", "]", ",", "\n", "[", "np", ".", "sin", "(", "angles", "[", "2", "]", ")", ",", "np", ".", "cos", "(", "angles", "[", "2", "]", ")", ",", "0", "]", ",", "\n", "[", "0", ",", "0", ",", "1", "]", "]", ")", "\n", "R", "=", "np", ".", "dot", "(", "Rz", ",", "np", ".", "dot", "(", "Ry", ",", "Rx", ")", ")", "\n", "shape_pc", "=", "batch_data", "[", "k", ",", "...", "]", "\n", "rotated_data", "[", "k", ",", "...", "]", "=", "np", ".", "dot", "(", "shape_pc", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", ",", "R", ")", "\n", "", "return", "rotated_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.shift_point_cloud": [[167, 179], ["numpy.random.uniform", "range"], "function", ["None"], ["", "def", "shift_point_cloud", "(", "batch_data", ",", "shift_range", "=", "0.3", ")", ":", "# 0.1", "\n", "  ", "\"\"\" Randomly shift point cloud. Shift is per point cloud.\n    Input:\n      BxNx3 array, original batch of point clouds\n    Return:\n      BxNx3 array, shifted batch of point clouds\n  \"\"\"", "\n", "B", ",", "N", ",", "C", "=", "batch_data", ".", "shape", "\n", "shifts", "=", "np", ".", "random", ".", "uniform", "(", "-", "shift_range", ",", "shift_range", ",", "(", "B", ",", "3", ")", ")", "\n", "for", "batch_index", "in", "range", "(", "B", ")", ":", "\n", "    ", "batch_data", "[", "batch_index", ",", ":", ",", ":", "]", "+=", "shifts", "[", "batch_index", ",", ":", "]", "\n", "", "return", "batch_data", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.None.utils.vis_point_cloud": [[180, 191], ["matplotlib.figure", "mpl_toolkits.mplot3d.Axes3D", "mpl_toolkits.mplot3d.Axes3D.scatter3D", "matplotlib.show"], "function", ["None"], ["", "def", "vis_point_cloud", "(", "pc", ")", ":", "\n", "    ", "pc", "=", "pc", "[", "0", ",", ":", ",", ":", "]", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "Axes3D", "(", "fig", ")", "\n", "\n", "x", "=", "pc", "[", ":", ",", "0", "]", "\n", "y", "=", "pc", "[", ":", ",", "1", "]", "\n", "z", "=", "pc", "[", ":", ",", "2", "]", "\n", "ax", ".", "scatter3D", "(", "x", ",", "y", ",", "z", ",", "c", "=", "'b'", ",", "marker", "=", "'.'", ",", "s", "=", "10", ",", "linewidth", "=", "0", ",", "alpha", "=", "1", ",", "cmap", "=", "'spectral'", ")", "\n", "# ax.axis('square')", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph.Semantic_kitti_node.__init__": [[174, 195], ["rospy.Publisher", "rospy.Publisher", "rospy.init_node", "rospy.loginfo", "std_msgs.msg.Header", "rospy.Time", "std_msgs.msg.Header", "rospy.Time"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "pub_rate", "=", "10", ",", "label_topic", "=", "''", ",", "graph_topic", "=", "''", ")", ":", "\n", "        ", "\"\"\"\n        ros node spin in init function\n        :param pub_rate:\n        :param pub_topic:\n        \"\"\"", "\n", "self", ".", "_pub_rate", "=", "pub_rate", "\n", "# publisher", "\n", "self", ".", "_labels_pub", "=", "rospy", ".", "Publisher", "(", "label_topic", ",", "PointCloud2", ",", "queue_size", "=", "10", ")", "\n", "self", ".", "_graph_pub", "=", "rospy", ".", "Publisher", "(", "graph_topic", ",", "PointCloud2", ",", "queue_size", "=", "10", ")", "\n", "# ros node init", "\n", "rospy", ".", "init_node", "(", "'node'", ",", "anonymous", "=", "True", ")", "\n", "rospy", ".", "loginfo", "(", "\"node started.\"", ")", "\n", "\n", "self", ".", "header1", "=", "Header", "(", ")", "\n", "self", ".", "header1", ".", "stamp", "=", "rospy", ".", "Time", "(", ")", "\n", "self", ".", "header1", ".", "frame_id", "=", "\"velodyne\"", "\n", "\n", "self", ".", "header2", "=", "Header", "(", ")", "\n", "self", ".", "header2", ".", "stamp", "=", "rospy", ".", "Time", "(", ")", "\n", "self", ".", "header2", ".", "frame_id", "=", "\"velodyne\"", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph.Semantic_kitti_node.gen_labels": [[196, 331], ["numpy.fromfile", "scan.reshape.reshape.reshape", "numpy.fromfile", "label.reshape.reshape.reshape", "list", "list.sort", "enumerate", "numpy.array", "numpy.random.random", "numpy.arctan2", "print", "print", "ValueError", "set", "numpy.argwhere", "index.reshape.reshape.reshape", "list", "list.sort", "numpy.save", "sensor_msgs.create_cloud", "gen_label_graph.Semantic_kitti_node._labels_pub.publish", "numpy.argwhere().reshape", "numpy.append", "numpy.argwhere().reshape", "set", "numpy.concatenate", "numpy.concatenate", "numpy.array.extend", "numpy.argwhere().reshape", "gen_label_graph._make_point_field", "numpy.argwhere", "numpy.argwhere", "numpy.full", "numpy.full", "enumerate", "pcl.PointCloud", "pcl.PointCloud.make_kdtree", "pcl.PointCloud.make_EuclideanClusterExtraction", "pcl.PointCloud.make_EuclideanClusterExtraction.set_ClusterTolerance", "pcl.PointCloud.make_EuclideanClusterExtraction.set_MinClusterSize", "pcl.PointCloud.make_EuclideanClusterExtraction.set_MaxClusterSize", "pcl.PointCloud.make_EuclideanClusterExtraction.set_SearchMethod", "pcl.PointCloud.make_EuclideanClusterExtraction.Extract", "enumerate", "numpy.argwhere", "len", "numpy.argwhere", "points_index.reshape.reshape.reshape", "numpy.concatenate", "numpy.concatenate", "numpy.array.extend", "numpy.zeros", "numpy.concatenate", "numpy.concatenate", "numpy.array.extend", "[].split", "len", "len", "numpy.full", "numpy.full", "len", "numpy.full", "numpy.full", "numpy.array", "label_name.split"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph._make_point_field"], ["", "def", "gen_labels", "(", "self", ",", "FLAGS", ",", "scan_name", ",", "label_name", ",", "label_output_dir", ")", ":", "\n", "# start = time.time()", "\n", "# open scan", "\n", "# TODO(yxm): downsampling", "\n", "        ", "scan", "=", "np", ".", "fromfile", "(", "scan_name", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "scan", "=", "scan", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "# put in attribute", "\n", "points", "=", "scan", "[", ":", ",", "0", ":", "4", "]", "# get xyzr", "\n", "remissions", "=", "scan", "[", ":", ",", "3", "]", "# get remission", "\n", "\n", "label", "=", "np", ".", "fromfile", "(", "label_name", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "label", "=", "label", ".", "reshape", "(", "(", "-", "1", ")", ")", "\n", "\n", "# demolition or not", "\n", "if", "FLAGS", ".", "demolition", "==", "True", ":", "\n", "            ", "start_angle", "=", "np", ".", "random", ".", "random", "(", ")", "\n", "start_angle", "*=", "360", "\n", "end_angle", "=", "(", "start_angle", "+", "drop_angle", ")", "%", "360", "\n", "\n", "angle", "=", "np", ".", "arctan2", "(", "points", "[", ":", ",", "1", "]", ",", "points", "[", ":", ",", "0", "]", ")", "\n", "angle", "=", "angle", "*", "180", "/", "np", ".", "pi", "\n", "angle", "+=", "180", "\n", "# print(\"angle:\", angle)", "\n", "if", "end_angle", ">", "start_angle", ":", "\n", "                ", "remain_id", "=", "np", ".", "argwhere", "(", "angle", "<", "start_angle", ")", ".", "reshape", "(", "-", "1", ")", "\n", "remain_id", "=", "np", ".", "append", "(", "remain_id", ",", "np", ".", "argwhere", "(", "angle", ">", "end_angle", ")", ".", "reshape", "(", "-", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "remain_id", "=", "np", ".", "argwhere", "(", "(", "angle", ">", "end_angle", ")", "&", "(", "angle", "<", "start_angle", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "", "points", "=", "points", "[", "remain_id", ",", ":", "]", "\n", "label", "=", "label", "[", "remain_id", "]", "\n", "\n", "", "if", "label", ".", "shape", "[", "0", "]", "==", "points", ".", "shape", "[", "0", "]", ":", "\n", "            ", "sem_label", "=", "label", "&", "0xFFFF", "# semantic label in lower half", "\n", "inst_label", "=", "label", ">>", "16", "# instance id in upper half", "\n", "assert", "(", "(", "sem_label", "+", "(", "inst_label", "<<", "16", ")", "==", "label", ")", ".", "all", "(", ")", ")", "\n", "", "else", ":", "\n", "            ", "print", "(", "\"Points shape: \"", ",", "points", ".", "shape", ")", "\n", "print", "(", "\"Label shape: \"", ",", "label", ".", "shape", ")", "\n", "raise", "ValueError", "(", "\"Scan and Label don't contain same number of points\"", ")", "\n", "\n", "", "sem_label", "=", "remap_lut", "[", "sem_label", "]", "\n", "sem_label_set", "=", "list", "(", "set", "(", "sem_label", ")", ")", "\n", "sem_label_set", ".", "sort", "(", ")", "\n", "\n", "# Start clustering", "\n", "cluster", "=", "[", "]", "\n", "inst_id", "=", "0", "\n", "for", "id_i", ",", "label_i", "in", "enumerate", "(", "sem_label_set", ")", ":", "\n", "# print('sem_label:', label_i)", "\n", "            ", "index", "=", "np", ".", "argwhere", "(", "sem_label", "==", "label_i", ")", "\n", "index", "=", "index", ".", "reshape", "(", "index", ".", "shape", "[", "0", "]", ")", "\n", "sem_cluster", "=", "points", "[", "index", ",", ":", "]", "\n", "# print(\"sem_cluster_shape:\",sem_cluster.shape[0])", "\n", "\n", "tmp_inst_label", "=", "inst_label", "[", "index", "]", "\n", "tmp_inst_set", "=", "list", "(", "set", "(", "tmp_inst_label", ")", ")", "\n", "tmp_inst_set", ".", "sort", "(", ")", "\n", "# print(tmp_inst_set)", "\n", "\n", "if", "label_i", "in", "[", "9", ",", "10", "]", ":", "# road/parking, dont need to cluster", "\n", "                ", "inst_cluster", "=", "sem_cluster", "\n", "inst_cluster", "=", "np", ".", "concatenate", "(", "(", "inst_cluster", ",", "np", ".", "full", "(", "(", "inst_cluster", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "label_i", ",", "dtype", "=", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "# inst_cluster = np.insert(inst_cluster, 4, label_i, axis=1)", "\n", "inst_cluster", "=", "np", ".", "concatenate", "(", "(", "inst_cluster", ",", "np", ".", "full", "(", "(", "inst_cluster", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "inst_id", ",", "dtype", "=", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "inst_id", "=", "inst_id", "+", "1", "\n", "cluster", ".", "extend", "(", "inst_cluster", ")", "# Nx6                ", "\n", "continue", "\n", "\n", "", "elif", "label_i", "in", "[", "0", ",", "2", ",", "3", ",", "6", ",", "7", ",", "8", "]", ":", "# discard", "\n", "                ", "continue", "\n", "\n", "", "elif", "len", "(", "tmp_inst_set", ")", ">", "1", "or", "(", "len", "(", "tmp_inst_set", ")", "==", "1", "and", "tmp_inst_set", "[", "0", "]", "!=", "0", ")", ":", "# have instance labels", "\n", "                ", "for", "id_j", ",", "label_j", "in", "enumerate", "(", "tmp_inst_set", ")", ":", "\n", "                    ", "points_index", "=", "np", ".", "argwhere", "(", "tmp_inst_label", "==", "label_j", ")", "\n", "points_index", "=", "points_index", ".", "reshape", "(", "points_index", ".", "shape", "[", "0", "]", ")", "\n", "# print(id_j, 'inst_size:', len(points_index))", "\n", "if", "len", "(", "points_index", ")", "<=", "20", ":", "\n", "                        ", "continue", "\n", "", "inst_cluster", "=", "sem_cluster", "[", "points_index", ",", ":", "]", "\n", "inst_cluster", "=", "np", ".", "concatenate", "(", "(", "inst_cluster", ",", "np", ".", "full", "(", "(", "inst_cluster", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "label_i", ",", "dtype", "=", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "# inst_cluster = np.insert(inst_cluster, 4, label_i, axis=1)", "\n", "inst_cluster", "=", "np", ".", "concatenate", "(", "(", "inst_cluster", ",", "np", ".", "full", "(", "(", "inst_cluster", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "inst_id", ",", "dtype", "=", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "inst_id", "=", "inst_id", "+", "1", "\n", "cluster", ".", "extend", "(", "inst_cluster", ")", "\n", "", "", "else", ":", "# Euclidean cluster", "\n", "# time_start = time.time()", "\n", "                ", "if", "label_i", "in", "[", "1", ",", "4", ",", "5", ",", "14", "]", ":", "# car truck other-vehicle fence", "\n", "                    ", "cluster_tolerance", "=", "0.5", "\n", "", "elif", "label_i", "in", "[", "11", ",", "12", ",", "13", ",", "15", ",", "17", "]", ":", "# sidewalk other-ground building vegetation terrain", "\n", "                    ", "cluster_tolerance", "=", "2", "\n", "", "else", ":", "\n", "                    ", "cluster_tolerance", "=", "0.2", "\n", "\n", "", "if", "label_i", "in", "[", "16", ",", "19", "]", ":", "# trunk traffic-sign", "\n", "                    ", "min_size", "=", "50", "\n", "", "elif", "label_i", "==", "15", ":", "# vegetation", "\n", "                    ", "min_size", "=", "200", "\n", "", "elif", "label_i", "in", "[", "11", ",", "12", ",", "13", ",", "17", "]", ":", "# sidewalk other-ground building terrain", "\n", "                    ", "min_size", "=", "300", "\n", "", "else", ":", "\n", "                    ", "min_size", "=", "100", "\n", "\n", "# print(cluster_tolerance, min_size)", "\n", "", "cloud", "=", "pcl", ".", "PointCloud", "(", "sem_cluster", "[", ":", ",", "0", ":", "3", "]", ")", "\n", "tree", "=", "cloud", ".", "make_kdtree", "(", ")", "\n", "ec", "=", "cloud", ".", "make_EuclideanClusterExtraction", "(", ")", "\n", "ec", ".", "set_ClusterTolerance", "(", "cluster_tolerance", ")", "\n", "ec", ".", "set_MinClusterSize", "(", "min_size", ")", "\n", "ec", ".", "set_MaxClusterSize", "(", "50000", ")", "\n", "ec", ".", "set_SearchMethod", "(", "tree", ")", "\n", "cluster_indices", "=", "ec", ".", "Extract", "(", ")", "\n", "# time_end = time.time()", "\n", "# print(time_end - time_start)", "\n", "for", "j", ",", "indices", "in", "enumerate", "(", "cluster_indices", ")", ":", "\n", "# print('j = ', j, ', indices = ' + str(len(indices)))", "\n", "                    ", "inst_cluster", "=", "np", ".", "zeros", "(", "(", "len", "(", "indices", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "inst_cluster", "=", "sem_cluster", "[", "np", ".", "array", "(", "indices", ")", ",", "0", ":", "4", "]", "\n", "inst_cluster", "=", "np", ".", "concatenate", "(", "(", "inst_cluster", ",", "np", ".", "full", "(", "(", "inst_cluster", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "label_i", ",", "dtype", "=", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "# inst_cluster = np.insert(inst_cluster, 4, label_i, axis=1)", "\n", "inst_cluster", "=", "np", ".", "concatenate", "(", "(", "inst_cluster", ",", "np", ".", "full", "(", "(", "inst_cluster", ".", "shape", "[", "0", "]", ",", "1", ")", ",", "inst_id", ",", "dtype", "=", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "inst_id", "=", "inst_id", "+", "1", "\n", "cluster", ".", "extend", "(", "inst_cluster", ")", "# Nx6", "\n", "\n", "# print(time.time()-start)", "\n", "# print('*'*80)", "\n", "", "", "", "cluster", "=", "np", ".", "array", "(", "cluster", ")", "\n", "if", "'path'", "in", "FLAGS", ".", "pub_or_path", ":", "\n", "            ", "np", ".", "save", "(", "label_output_dir", "+", "'/'", "+", "label_name", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "\".npy\"", ",", "cluster", ")", "\n", "", "if", "'pub'", "in", "FLAGS", ".", "pub_or_path", ":", "\n", "# print(cluster[11100:11110])", "\n", "            ", "msg_points", "=", "pc2", ".", "create_cloud", "(", "header", "=", "self", ".", "header1", ",", "fields", "=", "_make_point_field", "(", "cluster", ".", "shape", "[", "1", "]", ")", ",", "points", "=", "cluster", ")", "\n", "self", ".", "_labels_pub", ".", "publish", "(", "msg_points", ")", "\n", "\n", "", "return", "cluster", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph.Semantic_kitti_node.gen_graphs": [[332, 399], ["list", "list.sort", "range", "range", "set", "len", "numpy.argwhere", "index.reshape.reshape.reshape", "list", "range", "os.path.join", "numpy.array", "numpy.array", "numpy.concatenate", "sensor_msgs.create_cloud", "gen_label_graph.Semantic_kitti_node._graph_pub.publish", "set", "len", "int", "node_map.keys", "cluster.append", "numpy.array.append", "numpy.mean", "numpy.array.append", "len", "len", "numpy.mean", "numpy.mean", "numpy.mean", "numpy.argmin", "numpy.argmin", "numpy.linalg.norm", "open", "json.dump", "int", "numpy.mean.tolist", "print", "exit", "numpy.linalg.norm", "numpy.linalg.norm", "edges.append", "float", "weights.append", "numpy.array.reshape().astype", "gen_label_graph._make_point_field", "int", "int", "int", "[].split", "numpy.array.reshape", "scan_name.split"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph._make_point_field"], ["", "def", "gen_graphs", "(", "self", ",", "FLAGS", ",", "scan_name", ",", "scan", ",", "graph_output_dir", ")", ":", "\n", "        ", "inst", "=", "scan", "[", ":", ",", "-", "1", "]", "# get instance label", "\n", "inst_label_set", "=", "list", "(", "set", "(", "inst", ")", ")", "# get nums of inst", "\n", "inst_label_set", ".", "sort", "(", ")", "\n", "# print(\"inst set: \", inst_label_set)", "\n", "nodes", "=", "[", "]", "# graph node", "\n", "edges", "=", "[", "]", "# graph edge", "\n", "weights", "=", "[", "]", "# graph edge weights", "\n", "cluster", "=", "[", "]", "# cluster -> node", "\n", "centers", "=", "[", "]", "\n", "for", "id_i", "in", "range", "(", "len", "(", "inst_label_set", ")", ")", ":", "\n", "            ", "index", "=", "np", ".", "argwhere", "(", "inst_label_set", "[", "id_i", "]", "==", "inst", ")", "# query cluster by instance label", "\n", "index", "=", "index", ".", "reshape", "(", "index", ".", "shape", "[", "0", "]", ")", "\n", "inst_cluster", "=", "scan", "[", "index", ",", ":", "]", "\n", "sem_label", "=", "list", "(", "set", "(", "inst_cluster", "[", ":", ",", "-", "2", "]", ")", ")", "# get semantic label", "\n", "assert", "len", "(", "sem_label", ")", "==", "1", "# one instance cluster should have only one semantic label", "\n", "if", "int", "(", "sem_label", "[", "0", "]", ")", "in", "node_map", ".", "keys", "(", ")", ":", "\n", "                ", "cluster", ".", "append", "(", "inst_cluster", "[", ":", ",", ":", "3", "]", ")", "\n", "node_label", "=", "node_map", "[", "int", "(", "sem_label", "[", "0", "]", ")", "]", "# add node", "\n", "nodes", ".", "append", "(", "int", "(", "node_label", ")", ")", "\n", "cluster_center", "=", "np", ".", "mean", "(", "inst_cluster", "[", ":", ",", ":", "3", "]", ",", "axis", "=", "0", ")", "\n", "centers", ".", "append", "(", "(", "cluster_center", ".", "tolist", "(", ")", ")", ")", "\n", "", "elif", "int", "(", "sem_label", "[", "0", "]", ")", "==", "9", "or", "int", "(", "sem_label", "[", "0", "]", ")", "==", "10", ":", "# ignore \"road\" and \"parking\"", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "print", "(", "\"wrong semantic label: \"", ",", "sem_label", "[", "0", "]", ")", "\n", "exit", "(", "-", "1", ")", "\n", "\n", "", "", "dist_thresh", "=", "5", "# less than thresh, add an edge between nodes", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "cluster", ")", "-", "1", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "i", "+", "1", ",", "len", "(", "cluster", ")", ")", ":", "\n", "                ", "pc_i", "=", "cluster", "[", "i", "]", "\n", "pc_j", "=", "cluster", "[", "j", "]", "\n", "center_i", "=", "np", ".", "mean", "(", "pc_i", ",", "axis", "=", "0", ")", "\n", "center_j", "=", "np", ".", "mean", "(", "pc_j", ",", "axis", "=", "0", ")", "\n", "center", "=", "np", ".", "mean", "(", "[", "center_i", ",", "center_j", "]", ",", "axis", "=", "0", ")", "# centroid of the cluster", "\n", "\n", "index1", "=", "np", ".", "argmin", "(", "np", ".", "linalg", ".", "norm", "(", "center", "-", "pc_i", "[", ":", ",", "None", "]", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "0", ")", "\n", "index2", "=", "np", ".", "argmin", "(", "np", ".", "linalg", ".", "norm", "(", "center", "-", "pc_j", "[", ":", ",", "None", "]", ",", "axis", "=", "-", "1", ")", ",", "axis", "=", "0", ")", "\n", "min_dis", "=", "np", ".", "linalg", ".", "norm", "(", "pc_i", "[", "index1", "]", "-", "pc_j", "[", "index2", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n", "if", "min_dis", "<=", "dist_thresh", ":", "\n", "                    ", "edges", ".", "append", "(", "[", "i", ",", "j", "]", ")", "# add edge", "\n", "weight", "=", "float", "(", "1", "-", "min_dis", "/", "dist_thresh", ")", "#  w = 1 - d/d_thresh [0~5m] -> [1~0]", "\n", "weights", ".", "append", "(", "weight", ")", "# add edge_weight", "\n", "", "else", ":", "\n", "                    ", "pass", "\n", "\n", "# generate graph", "\n", "", "", "", "graph", "=", "{", "\"nodes\"", ":", "nodes", ",", "\n", "\"edges\"", ":", "edges", ",", "\n", "\"weights\"", ":", "weights", ",", "\n", "\"centers\"", ":", "centers", "\n", "}", "\n", "\n", "# print(graph)", "\n", "if", "'path'", "in", "FLAGS", ".", "pub_or_path", ":", "\n", "            ", "file_name", "=", "os", ".", "path", ".", "join", "(", "graph_output_dir", ",", "scan_name", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", ".", "split", "(", "'.'", ")", "[", "0", "]", "+", "\".json\"", ")", "\n", "# print(\"output json: \", file_name)", "\n", "with", "open", "(", "file_name", ",", "\"w\"", ",", "encoding", "=", "\"utf-8\"", ")", "as", "file", ":", "json", ".", "dump", "(", "graph", ",", "file", ")", "\n", "", "if", "'pub'", "in", "FLAGS", ".", "pub_or_path", ":", "\n", "            ", "centers", "=", "np", ".", "array", "(", "centers", ")", "\n", "nodes", "=", "np", ".", "array", "(", "nodes", ")", "\n", "pub_nodes", "=", "np", ".", "concatenate", "(", "(", "centers", ",", "nodes", ".", "reshape", "(", "-", "1", ",", "1", ")", ".", "astype", "(", "np", ".", "uint32", ")", ")", ",", "axis", "=", "1", ")", "\n", "msg_points", "=", "pc2", ".", "create_cloud", "(", "header", "=", "self", ".", "header2", ",", "fields", "=", "_make_point_field", "(", "pub_nodes", ".", "shape", "[", "1", "]", ")", ",", "points", "=", "pub_nodes", ")", "\n", "self", ".", "_graph_pub", ".", "publish", "(", "msg_points", ")", "\n", "# rospy.loginfo(scan_names[frame])", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph.open3d_color": [[78, 83], ["random.random", "random.random", "random.random"], "function", ["None"], ["def", "open3d_color", "(", ")", ":", "\n", "    ", "i", "=", "random", ".", "random", "(", ")", "\n", "j", "=", "random", ".", "random", "(", ")", "\n", "k", "=", "random", ".", "random", "(", ")", "\n", "return", "(", "i", ",", "j", ",", "k", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph.Visualize": [[84, 104], ["open3d.PointCloud", "open3d.PointCloud", "enumerate", "print", "numpy.argwhere", "index.reshape.reshape", "open3d.Vector3dVector", "open3d.PointCloud.paint_uniform_color", "open3d.draw_geometries", "str"], "function", ["None"], ["", "def", "Visualize", "(", ")", ":", "\n", "    ", "viz_point", "=", "open3d", ".", "PointCloud", "(", ")", "\n", "point_cloud", "=", "open3d", ".", "PointCloud", "(", ")", "\n", "\n", "for", "id_i", ",", "label_i", "in", "enumerate", "(", "sem_label_set", ")", ":", "\n", "        ", "print", "(", "'sem_label:'", ",", "label_i", ")", "\n", "\n", "index", "=", "np", ".", "argwhere", "(", "sem_label", "==", "label_i", ")", "\n", "index", "=", "index", ".", "reshape", "(", "index", ".", "shape", "[", "0", "]", ")", "\n", "sem_cluster", "=", "points", "[", "index", ",", ":", "]", "\n", "\n", "point_cloud", ".", "points", "=", "open3d", ".", "Vector3dVector", "(", "sem_cluster", "[", ":", ",", "0", ":", "3", "]", ")", "\n", "color", "=", "color_map", "[", "learning_map_inv", "[", "label_i", "]", "]", "\n", "color", "=", "(", "color", "[", "0", "]", "/", "255", ",", "color", "[", "1", "]", "/", "255", ",", "color", "[", "2", "]", "/", "255", ")", "\n", "# print(color)", "\n", "point_cloud", ".", "paint_uniform_color", "(", "color", ")", "\n", "viz_point", "+=", "point_cloud", "\n", "\n", "open3d", ".", "draw_geometries", "(", "[", "point_cloud", "]", ",", "window_name", "=", "'semantic label:'", "+", "str", "(", "111", ")", ",", "\n", "width", "=", "1920", ",", "height", "=", "1080", ",", "left", "=", "50", ",", "top", "=", "50", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.data_process.gen_label_graph._make_point_field": [[105, 171], ["sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "sensor_msgs.PointField", "numpy.str", "numpy.uint32", "numpy.uint8", "numpy.uint32", "ValueError"], "function", ["None"], ["", "", "def", "_make_point_field", "(", "num_field", ")", ":", "\n", "    ", "msg_pf1", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf1", ".", "name", "=", "np", ".", "str", "(", "'x'", ")", "\n", "msg_pf1", ".", "offset", "=", "np", ".", "uint32", "(", "0", ")", "\n", "msg_pf1", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "\n", "msg_pf1", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "\n", "msg_pf2", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf2", ".", "name", "=", "np", ".", "str", "(", "'y'", ")", "\n", "msg_pf2", ".", "offset", "=", "np", ".", "uint32", "(", "4", ")", "\n", "msg_pf2", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "\n", "msg_pf2", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "\n", "msg_pf3", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf3", ".", "name", "=", "np", ".", "str", "(", "'z'", ")", "\n", "msg_pf3", ".", "offset", "=", "np", ".", "uint32", "(", "8", ")", "\n", "msg_pf3", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "\n", "msg_pf3", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "\n", "if", "num_field", "==", "4", ":", "\n", "        ", "msg_pf4", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf4", ".", "name", "=", "np", ".", "str", "(", "'node'", ")", "\n", "msg_pf4", ".", "offset", "=", "np", ".", "uint32", "(", "16", ")", "\n", "msg_pf4", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "\n", "msg_pf4", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "return", "[", "msg_pf1", ",", "msg_pf2", ",", "msg_pf3", ",", "msg_pf4", "]", "\n", "\n", "", "elif", "num_field", "==", "6", ":", "\n", "        ", "msg_pf4", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf4", ".", "name", "=", "np", ".", "str", "(", "'intensity'", ")", "\n", "msg_pf4", ".", "offset", "=", "np", ".", "uint32", "(", "16", ")", "\n", "msg_pf4", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "#float64", "\n", "msg_pf4", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "\n", "msg_pf5", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf5", ".", "name", "=", "np", ".", "str", "(", "'sem_label'", ")", "\n", "msg_pf5", ".", "offset", "=", "np", ".", "uint32", "(", "20", ")", "\n", "msg_pf5", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "# 4 int16", "\n", "msg_pf5", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "\n", "msg_pf6", "=", "pc2", ".", "PointField", "(", ")", "\n", "msg_pf6", ".", "name", "=", "np", ".", "str", "(", "'inst_label'", ")", "\n", "msg_pf6", ".", "offset", "=", "np", ".", "uint32", "(", "24", ")", "\n", "msg_pf6", ".", "datatype", "=", "np", ".", "uint8", "(", "7", ")", "# 4 int16", "\n", "msg_pf6", ".", "count", "=", "np", ".", "uint32", "(", "1", ")", "\n", "\n", "return", "[", "msg_pf1", ",", "msg_pf2", ",", "msg_pf3", ",", "msg_pf4", ",", "msg_pf5", ",", "msg_pf6", "]", "\n", "# if num_field == 4:", "\n", "#     fields = [PointField('x', 0, PointField.FLOAT32, 1),", "\n", "#       PointField('y', 4, PointField.FLOAT32, 1),", "\n", "#       PointField('z', 8, PointField.FLOAT32, 1),", "\n", "#       PointField('node', 16, PointField.UINT32, 1),", "\n", "#       ]", "\n", "#     return fields", "\n", "# elif num_field == 6:", "\n", "#     fields = [PointField('x', 0, PointField.FLOAT32, 1),", "\n", "#       PointField('y', 4, PointField.FLOAT32, 1),", "\n", "#       PointField('z', 8, PointField.FLOAT32, 1),", "\n", "#       PointField('intensity', 12, PointField.FLOAT32, 1),", "\n", "#       PointField('sem_label', 16, PointField.UINT32, 1),", "\n", "#       PointField('inst_label', 20, PointField.UINT32, 1),", "\n", "#       ]", "\n", "\n", "#     return fields", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"wrong num_field.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.SSCDataset.SSCDataset.__init__": [[38, 67], ["len", "SSCDataset.SSCDataset.files.items", "os.path.join", "os.listdir", "SSCDataset.SSCDataset.filenames.extend", "print", "os.path.exists", "RuntimeError", "sorted", "SSCDataset.SSCDataset.files[].extend", "sorted", "len", "len", "len", "RuntimeError", "os.path.join", "f.endswith", "f.endswith", "os.path.splitext"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "directory", ",", "split", "=", "\"train\"", ")", ":", "\n", "    ", "\"\"\" Load data from given dataset directory. \"\"\"", "\n", "\n", "self", ".", "files", "=", "{", "}", "\n", "self", ".", "filenames", "=", "[", "]", "\n", "\n", "for", "ext", "in", "SPLIT_FILES", "[", "split", "]", ":", "\n", "      ", "self", ".", "files", "[", "EXT_TO_NAME", "[", "ext", "]", "]", "=", "[", "]", "\n", "\n", "", "for", "sequence", "in", "SPLIT_SEQUENCES", "[", "split", "]", ":", "\n", "      ", "complete_path", "=", "os", ".", "path", ".", "join", "(", "directory", ",", "\"sequences\"", ",", "sequence", ",", "\"voxels\"", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "complete_path", ")", ":", "raise", "RuntimeError", "(", "\"Voxel directory missing: \"", "+", "complete_path", ")", "\n", "\n", "files", "=", "os", ".", "listdir", "(", "complete_path", ")", "\n", "for", "ext", "in", "SPLIT_FILES", "[", "split", "]", ":", "\n", "        ", "data", "=", "sorted", "(", "[", "os", ".", "path", ".", "join", "(", "complete_path", ",", "f", ")", "for", "f", "in", "files", "if", "f", ".", "endswith", "(", "ext", ")", "]", ")", "\n", "if", "len", "(", "data", ")", "==", "0", ":", "raise", "RuntimeError", "(", "\"Missing data for \"", "+", "EXT_TO_NAME", "[", "ext", "]", ")", "\n", "self", ".", "files", "[", "EXT_TO_NAME", "[", "ext", "]", "]", ".", "extend", "(", "data", ")", "\n", "\n", "# this information is handy for saving the data later, since you need to provide sequences/XX/predictions/000000.label:", "\n", "", "self", ".", "filenames", ".", "extend", "(", "\n", "sorted", "(", "[", "(", "sequence", ",", "os", ".", "path", ".", "splitext", "(", "f", ")", "[", "0", "]", ")", "for", "f", "in", "files", "if", "f", ".", "endswith", "(", "SPLIT_FILES", "[", "split", "]", "[", "0", "]", ")", "]", ")", ")", "\n", "\n", "", "self", ".", "num_files", "=", "len", "(", "self", ".", "filenames", ")", "\n", "\n", "# sanity check:", "\n", "for", "k", ",", "v", "in", "self", ".", "files", ".", "items", "(", ")", ":", "\n", "      ", "print", "(", "k", ",", "len", "(", "v", ")", ")", "\n", "assert", "(", "len", "(", "v", ")", "==", "self", ".", "num_files", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.SSCDataset.SSCDataset.__len__": [[68, 70], ["None"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "num_files", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.SSCDataset.SSCDataset.__getitem__": [[71, 87], ["SSCDataset.SSCDataset.files.keys", "unpack.reshape", "numpy.fromfile", "SSCDataset.unpack", "numpy.fromfile"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.SSCDataset.unpack"], ["", "def", "__getitem__", "(", "self", ",", "t", ")", ":", "\n", "    ", "\"\"\" fill dictionary with available data for given index . \"\"\"", "\n", "collection", "=", "{", "}", "\n", "\n", "# read raw data and unpack (if necessary)", "\n", "for", "typ", "in", "self", ".", "files", ".", "keys", "(", ")", ":", "\n", "      ", "scan_data", "=", "None", "\n", "if", "typ", "==", "\"label\"", ":", "\n", "        ", "scan_data", "=", "np", ".", "fromfile", "(", "self", ".", "files", "[", "typ", "]", "[", "t", "]", ",", "dtype", "=", "np", ".", "uint16", ")", "\n", "", "else", ":", "\n", "        ", "scan_data", "=", "unpack", "(", "np", ".", "fromfile", "(", "self", ".", "files", "[", "typ", "]", "[", "t", "]", ",", "dtype", "=", "np", ".", "uint8", ")", ")", "\n", "\n", "# turn in actual voxel grid representation.", "\n", "", "collection", "[", "typ", "]", "=", "scan_data", ".", "reshape", "(", "VOXEL_DIMS", ")", "\n", "\n", "", "return", "self", ".", "filenames", "[", "t", "]", ",", "collection", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.SSCDataset.unpack": [[5, 18], ["numpy.zeros"], "function", ["None"], ["def", "unpack", "(", "compressed", ")", ":", "\n", "  ", "''' given a bit encoded voxel grid, make a normal voxel grid out of it.  '''", "\n", "uncompressed", "=", "np", ".", "zeros", "(", "compressed", ".", "shape", "[", "0", "]", "*", "8", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "uncompressed", "[", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "7", "&", "1", "\n", "uncompressed", "[", "1", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "6", "&", "1", "\n", "uncompressed", "[", "2", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "5", "&", "1", "\n", "uncompressed", "[", "3", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "4", "&", "1", "\n", "uncompressed", "[", "4", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "3", "&", "1", "\n", "uncompressed", "[", "5", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "2", "&", "1", "\n", "uncompressed", "[", "6", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", ">>", "1", "&", "1", "\n", "uncompressed", "[", "7", ":", ":", "8", "]", "=", "compressed", "[", ":", "]", "&", "1", "\n", "\n", "return", "uncompressed", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.__init__": [[9, 22], ["numpy.array", "numpy.array", "print", "print", "np_ioueval.iouEval.reset", "range"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset"], ["  ", "def", "__init__", "(", "self", ",", "n_classes", ",", "ignore", "=", "None", ")", ":", "\n", "# classes", "\n", "    ", "self", ".", "n_classes", "=", "n_classes", "\n", "\n", "# What to include and ignore from the means", "\n", "self", ".", "ignore", "=", "np", ".", "array", "(", "ignore", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "include", "=", "np", ".", "array", "(", "\n", "[", "n", "for", "n", "in", "range", "(", "self", ".", "n_classes", ")", "if", "n", "not", "in", "self", ".", "ignore", "]", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "print", "(", "\"[IOU EVAL] IGNORE: \"", ",", "self", ".", "ignore", ")", "\n", "print", "(", "\"[IOU EVAL] INCLUDE: \"", ",", "self", ".", "include", ")", "\n", "\n", "# reset the class counters", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.num_classes": [[23, 25], ["None"], "methods", ["None"], ["", "def", "num_classes", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.reset": [[26, 30], ["numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "    ", "self", ".", "conf_matrix", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_classes", ",", "\n", "self", ".", "n_classes", ")", ",", "\n", "dtype", "=", "np", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.addBatch": [[31, 44], ["x.reshape", "y.reshape", "tuple", "numpy.add.at", "numpy.stack"], "methods", ["None"], ["", "def", "addBatch", "(", "self", ",", "x", ",", "y", ")", ":", "# x=preds, y=targets", "\n", "# sizes should be matching", "\n", "    ", "x_row", "=", "x", ".", "reshape", "(", "-", "1", ")", "# de-batchify", "\n", "y_row", "=", "y", ".", "reshape", "(", "-", "1", ")", "# de-batchify", "\n", "\n", "# check", "\n", "assert", "(", "x_row", ".", "shape", "==", "x_row", ".", "shape", ")", "\n", "\n", "# create indexes", "\n", "idxs", "=", "tuple", "(", "np", ".", "stack", "(", "(", "x_row", ",", "y_row", ")", ",", "axis", "=", "0", ")", ")", "\n", "\n", "# make confusion matrix (cols = gt, rows = pred)", "\n", "np", ".", "add", ".", "at", "(", "self", ".", "conf_matrix", ",", "idxs", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.getStats": [[45, 55], ["np_ioueval.iouEval.conf_matrix.copy", "numpy.diag", "np_ioueval.iouEval.sum", "np_ioueval.iouEval.sum"], "methods", ["None"], ["", "def", "getStats", "(", "self", ")", ":", "\n", "# remove fp from confusion on the ignore classes cols", "\n", "    ", "conf", "=", "self", ".", "conf_matrix", ".", "copy", "(", ")", "\n", "conf", "[", ":", ",", "self", ".", "ignore", "]", "=", "0", "\n", "\n", "# get the clean stats", "\n", "tp", "=", "np", ".", "diag", "(", "conf", ")", "\n", "fp", "=", "conf", ".", "sum", "(", "axis", "=", "1", ")", "-", "tp", "\n", "fn", "=", "conf", ".", "sum", "(", "axis", "=", "0", ")", "-", "tp", "\n", "return", "tp", ",", "fp", ",", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.getIoU": [[56, 63], ["np_ioueval.iouEval.getStats"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getStats"], ["", "def", "getIoU", "(", "self", ")", ":", "\n", "    ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getStats", "(", ")", "\n", "intersection", "=", "tp", "\n", "union", "=", "tp", "+", "fp", "+", "fn", "+", "1e-15", "\n", "iou", "=", "intersection", "/", "union", "\n", "iou_mean", "=", "(", "intersection", "[", "self", ".", "include", "]", "/", "union", "[", "self", ".", "include", "]", ")", ".", "mean", "(", ")", "\n", "return", "iou_mean", ",", "iou", "# returns \"iou mean\", \"iou per class\" ALL CLASSES", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.getacc": [[64, 70], ["np_ioueval.iouEval.getStats", "tp.sum", "tp[].sum", "fp[].sum"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getStats"], ["", "def", "getacc", "(", "self", ")", ":", "\n", "    ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getStats", "(", ")", "\n", "total_tp", "=", "tp", ".", "sum", "(", ")", "\n", "total", "=", "tp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "+", "fp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "+", "1e-15", "\n", "acc_mean", "=", "total_tp", "/", "total", "\n", "return", "acc_mean", "# returns \"acc mean\"", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.np_ioueval.iouEval.get_confusion": [[71, 73], ["np_ioueval.iouEval.conf_matrix.copy"], "methods", ["None"], ["", "def", "get_confusion", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "conf_matrix", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.__init__": [[27, 44], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "x_", "=", "self", ".", "y_", "=", "self", ".", "z_", "=", "0.0", "\n", "self", ".", "pitch_", "=", "0.0", "\n", "self", ".", "yaw_", "=", "0.0", "\n", "\n", "self", ".", "startdrag_", "=", "False", "\n", "self", ".", "startTime_", "=", "0", "\n", "self", ".", "startx_", "=", "0", "\n", "self", ".", "starty_", "=", "0", "\n", "self", ".", "startyaw_", "=", "0", "\n", "self", ".", "startpitch_", "=", "0", "\n", "\n", "self", ".", "forwardVel_", "=", "0.0", "\n", "self", ".", "upVel_", "=", "0.0", "\n", "self", ".", "sideVel_", "=", "0.0", "\n", "self", ".", "turnVel_", "=", "0.0", "\n", "self", ".", "startdrag_", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.lookAt": [[45, 59], ["math.sqrt", "math.asin", "math.atan2"], "methods", ["None"], ["", "def", "lookAt", "(", "self", ",", "x_cam", ",", "y_cam", ",", "z_cam", ",", "x_ref", ",", "y_ref", ",", "z_ref", ")", ":", "\n", "    ", "self", ".", "x_", "=", "x_cam", "\n", "self", ".", "y_", "=", "y_cam", "\n", "self", ".", "z_", "=", "z_cam", "\n", "\n", "x", "=", "x_ref", "-", "self", ".", "x_", "\n", "y", "=", "y_ref", "-", "self", ".", "y_", "\n", "z", "=", "z_ref", "-", "self", ".", "z_", "\n", "length", "=", "math", ".", "sqrt", "(", "x", "*", "x", "+", "y", "*", "y", "+", "z", "*", "z", ")", "\n", "\n", "self", ".", "pitch_", "=", "math", ".", "asin", "(", "y", "/", "length", ")", "# = std: : acos(-dir.y()) - M_PI_2 in [-pi/2, pi/2]", "\n", "self", ".", "yaw_", "=", "math", ".", "atan2", "(", "-", "x", ",", "-", "z", ")", "\n", "\n", "self", ".", "startdrag_", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.matrix": [[60, 79], ["time.time", "camera.RotX", "camera.Camera.rotate", "camera.Camera.translate", "camera.RotY", "camera.Trans"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.RotX", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.rotate", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.translate", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.RotY", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Trans"], ["", "@", "property", "\n", "def", "matrix", "(", "self", ")", ":", "\n", "# current time.", "\n", "    ", "end", "=", "time", ".", "time", "(", ")", "\n", "dt", "=", "end", "-", "self", ".", "startTime_", "\n", "\n", "if", "dt", ">", "0", "and", "self", ".", "startdrag_", ":", "\n", "# apply velocity & reset timer...", "\n", "      ", "self", ".", "rotate", "(", "self", ".", "turnVel_", "*", "dt", ",", "0.0", ")", "\n", "self", ".", "translate", "(", "self", ".", "forwardVel_", "*", "dt", ",", "self", ".", "upVel_", "*", "dt", ",", "self", ".", "sideVel_", "*", "dt", ")", "\n", "self", ".", "startTime_", "=", "end", "\n", "\n", "# recompute the view matrix (Euler angles) Remember: Inv(AB) = Inv(B)*Inv(A)", "\n", "# Inv(translate*rotateYaw*rotatePitch) = Inv(rotatePitch)*Inv(rotateYaw)*Inv(translate)", "\n", "", "view_", "=", "RotX", "(", "-", "self", ".", "pitch_", ")", "\n", "view_", "=", "view_", "@", "RotY", "(", "-", "self", ".", "yaw_", ")", "\n", "view_", "=", "view_", "@", "Trans", "(", "-", "self", ".", "x_", ",", "-", "self", ".", "y_", ",", "-", "self", ".", "z_", ")", "\n", "\n", "return", "view_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.mousePressed": [[80, 89], ["time.time"], "methods", ["None"], ["", "def", "mousePressed", "(", "self", ",", "x", ",", "y", ",", "btn", ",", "modifier", ")", ":", "\n", "    ", "self", ".", "startx_", "=", "x", "\n", "self", ".", "starty_", "=", "y", "\n", "self", ".", "startyaw_", "=", "self", ".", "yaw_", "\n", "self", ".", "startpitch_", "=", "self", ".", "pitch_", "\n", "self", ".", "startTime_", "=", "time", ".", "time", "(", ")", "\n", "self", ".", "startdrag_", "=", "True", "\n", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.mouseReleased": [[90, 98], ["None"], "methods", ["None"], ["", "def", "mouseReleased", "(", "self", ",", "x", ",", "y", ",", "btn", ",", "modifier", ")", ":", "\n", "    ", "self", ".", "forwardVel_", "=", "0.0", "\n", "self", ".", "upVel_", "=", "0.0", "\n", "self", ".", "sideVel_", "=", "0.0", "\n", "self", ".", "turnVel_", "=", "0.0", "\n", "self", ".", "startdrag_", "=", "False", "\n", "\n", "return", "True", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.translate": [[99, 111], ["math.sin", "math.cos"], "methods", ["None"], ["", "def", "translate", "(", "self", ",", "forward", ",", "up", ",", "sideways", ")", ":", "\n", "# forward = -z, sideways = x , up = y. Remember: inverse of yaw is applied, i.e., we have to apply yaw (?)", "\n", "# Also keep in mind: sin(-alpha) = -sin(alpha) and cos(-alpha) = -cos(alpha)", "\n", "# We only apply the yaw to move along the yaw direction;", "\n", "#  x' = x*cos(yaw) - z*sin(yaw)", "\n", "#  z' = x*sin(yaw) + z*cos(yaw)", "\n", "    ", "s", "=", "math", ".", "sin", "(", "self", ".", "yaw_", ")", "\n", "c", "=", "math", ".", "cos", "(", "self", ".", "yaw_", ")", "\n", "\n", "self", ".", "x_", "=", "self", ".", "x_", "+", "sideways", "*", "c", "-", "forward", "*", "s", "\n", "self", ".", "y_", "=", "self", ".", "y_", "+", "up", "\n", "self", ".", "z_", "=", "self", ".", "z_", "-", "(", "sideways", "*", "s", "+", "forward", "*", "c", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.rotate": [[112, 119], ["None"], "methods", ["None"], ["", "def", "rotate", "(", "self", ",", "yaw", ",", "pitch", ")", ":", "\n", "    ", "self", ".", "yaw_", "+=", "yaw", "\n", "self", ".", "pitch_", "+=", "pitch", "\n", "if", "self", ".", "pitch_", "<", "-", "0.5", "*", "math", ".", "pi", ":", "\n", "      ", "self", ".", "pitch_", "=", "-", "0.5", "*", "math", ".", "pi", "\n", "", "if", "self", ".", "pitch_", ">", "0.5", "*", "math", ".", "pi", ":", "\n", "      ", "self", ".", "pitch_", "=", "0.5", "*", "math", ".", "pi", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.mouseMoved": [[120, 197], ["max", "min", "max", "min", "time.time", "camera.Camera.rotate", "camera.Camera.translate", "time.time", "camera.Camera.rotate", "camera.Camera.translate"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.rotate", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.translate", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.rotate", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Camera.translate"], ["", "", "def", "mouseMoved", "(", "self", ",", "x", ",", "y", ",", "btn", ",", "modifier", ")", ":", "\n", "# some constants.", "\n", "    ", "MIN_MOVE", "=", "0", "\n", "WALK_SENSITIVITY", "=", "0.5", "\n", "TURN_SENSITIVITY", "=", "0.01", "\n", "SLIDE_SENSITIVITY", "=", "0.5", "\n", "RAISE_SENSITIVITY", "=", "0.5", "\n", "\n", "LOOK_SENSITIVITY", "=", "0.01", "\n", "FREE_TURN_SENSITIVITY", "=", "0.01", "\n", "\n", "dx", "=", "x", "-", "self", ".", "startx_", "\n", "dy", "=", "y", "-", "self", ".", "starty_", "\n", "\n", "if", "dx", ">", "0.0", ":", "\n", "      ", "dx", "=", "max", "(", "0.0", ",", "dx", "-", "MIN_MOVE", ")", "\n", "", "if", "dx", "<", "0.0", ":", "\n", "      ", "dx", "=", "min", "(", "0.0", ",", "dx", "+", "MIN_MOVE", ")", "\n", "", "if", "dy", ">", "0.0", ":", "\n", "      ", "dy", "=", "max", "(", "0.0", ",", "dy", "-", "MIN_MOVE", ")", "\n", "", "if", "dy", "<", "0.0", ":", "\n", "      ", "dy", "=", "min", "(", "0.0", ",", "dy", "+", "MIN_MOVE", ")", "\n", "\n", "# idea: if the velocity changes, we have to reset the start_time and update the camera parameters.", "\n", "\n", "", "if", "btn", "==", "glfw", ".", "MOUSE_BUTTON_RIGHT", ":", "\n", "\n", "      ", "self", ".", "forwardVel_", "=", "0", "\n", "self", ".", "upVel_", "=", "0", "\n", "self", ".", "sideVel_", "=", "0", "\n", "self", ".", "turnVel_", "=", "0", "\n", "\n", "self", ".", "yaw_", "=", "self", ".", "startyaw_", "-", "FREE_TURN_SENSITIVITY", "*", "dx", "\n", "self", ".", "pitch_", "=", "self", ".", "startpitch_", "-", "LOOK_SENSITIVITY", "*", "dy", "\n", "\n", "# ensure valid values.", "\n", "if", "self", ".", "pitch_", "<", "-", "0.5", "*", "math", ".", "pi", ":", "\n", "        ", "self", ".", "pitch_", "=", "-", "0.5", "*", "math", ".", "pi", "\n", "", "if", "self", ".", "pitch_", ">", "0.5", "*", "math", ".", "pi", ":", "\n", "        ", "self", ".", "pitch_", "=", "0.5", "*", "math", ".", "pi", "\n", "\n", "", "", "elif", "btn", "==", "glfw", ".", "MOUSE_BUTTON_LEFT", ":", "\n", "\n", "# apply transformation:", "\n", "      ", "end", "=", "time", ".", "time", "(", ")", "\n", "dt", "=", "end", "-", "self", ".", "startTime_", "\n", "\n", "if", "dt", ">", "0.0", ":", "\n", "        ", "self", ".", "rotate", "(", "self", ".", "turnVel_", "*", "dt", ",", "0.0", ")", "\n", "self", ".", "translate", "(", "self", ".", "forwardVel_", "*", "dt", ",", "self", ".", "upVel_", "*", "dt", ",", "self", ".", "sideVel_", "*", "dt", ")", "\n", "\n", "self", ".", "startTime_", "=", "end", "\n", "# reset timer.", "\n", "\n", "", "self", ".", "forwardVel_", "=", "-", "WALK_SENSITIVITY", "*", "dy", "\n", "self", ".", "upVel_", "=", "0", "\n", "self", ".", "sideVel_", "=", "0", "\n", "self", ".", "turnVel_", "=", "-", "(", "TURN_SENSITIVITY", "*", "dx", ")", "\n", "", "elif", "btn", "==", "glfw", ".", "MOUSE_BUTTON_MIDDLE", ":", "\n", "\n", "# apply transformation:", "\n", "      ", "end", "=", "time", ".", "time", "(", ")", "\n", "dt", "=", "end", "-", "self", ".", "startTime_", "\n", "\n", "if", "dt", ">", "0.0", ":", "\n", "        ", "self", ".", "rotate", "(", "self", ".", "turnVel_", "*", "dt", ",", "0.0", ")", "\n", "self", ".", "translate", "(", "self", ".", "forwardVel_", "*", "dt", ",", "self", ".", "upVel_", "*", "dt", ",", "self", ".", "sideVel_", "*", "dt", ")", "\n", "\n", "self", ".", "startTime_", "=", "end", "\n", "# reset timer.", "\n", "\n", "", "self", ".", "forwardVel_", "=", "0", "\n", "self", ".", "upVel_", "=", "-", "RAISE_SENSITIVITY", "*", "dy", "\n", "self", ".", "sideVel_", "=", "SLIDE_SENSITIVITY", "*", "dx", "\n", "self", ".", "turnVel_", "=", "0", "\n", "\n", "", "return", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.RotX": [[6, 11], ["math.sin", "math.cos", "numpy.array().reshape", "numpy.array"], "function", ["None"], ["def", "RotX", "(", "angle", ")", ":", "\n", "  ", "sin_t", "=", "math", ".", "sin", "(", "angle", ")", "\n", "cos_t", "=", "math", ".", "cos", "(", "angle", ")", "\n", "\n", "return", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "cos_t", ",", "-", "sin_t", ",", "0", ",", "0", ",", "sin_t", ",", "cos_t", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "4", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.RotY": [[13, 18], ["math.sin", "math.cos", "numpy.array().reshape", "numpy.array"], "function", ["None"], ["", "def", "RotY", "(", "angle", ")", ":", "\n", "  ", "sin_t", "=", "math", ".", "sin", "(", "angle", ")", "\n", "cos_t", "=", "math", ".", "cos", "(", "angle", ")", "\n", "\n", "return", "np", ".", "array", "(", "[", "cos_t", ",", "0", ",", "sin_t", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "-", "sin_t", ",", "0", ",", "cos_t", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "4", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.camera.Trans": [[20, 22], ["numpy.array().reshape", "numpy.array"], "function", ["None"], ["", "def", "Trans", "(", "x", ",", "y", ",", "z", ")", ":", "\n", "  ", "return", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", ",", "x", ",", "0", ",", "1", ",", "0", ",", "y", ",", "0", ",", "0", ",", "1", ",", "z", ",", "0", ",", "0", ",", "0", ",", "1", "]", ",", "dtype", "=", "np", ".", "float32", ")", ".", "reshape", "(", "4", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.__init__": [[14, 30], ["len", "laserscanvis.LaserScanVis.reset", "laserscanvis.LaserScanVis.update_scan", "print"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.update_scan"], ["def", "__init__", "(", "self", ",", "scan", ",", "scan_names", ",", "label_names", ",", "offset", "=", "0", ",", "\n", "semantics", "=", "True", ",", "instances", "=", "False", ")", ":", "\n", "    ", "self", ".", "scan", "=", "scan", "\n", "self", ".", "scan_names", "=", "scan_names", "\n", "self", ".", "label_names", "=", "label_names", "\n", "self", ".", "offset", "=", "offset", "\n", "self", ".", "total", "=", "len", "(", "self", ".", "scan_names", ")", "\n", "self", ".", "semantics", "=", "semantics", "\n", "self", ".", "instances", "=", "instances", "\n", "# sanity check", "\n", "if", "not", "self", ".", "semantics", "and", "self", ".", "instances", ":", "\n", "      ", "print", "(", "\"Instances are only allowed in when semantics=True\"", ")", "\n", "raise", "ValueError", "\n", "\n", "", "self", ".", "reset", "(", ")", "\n", "self", ".", "update_scan", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.reset": [[31, 116], ["vispy.scene.SceneCanvas", "laserscanvis.LaserScanVis.canvas.events.key_press.connect", "laserscanvis.LaserScanVis.canvas.events.draw.connect", "laserscanvis.LaserScanVis.canvas.central_widget.add_grid", "vispy.scene.widgets.ViewBox", "laserscanvis.LaserScanVis.grid.add_widget", "vispy.scene.visuals.Markers", "laserscanvis.LaserScanVis.scan_view.add", "vispy.scene.visuals.XYZAxis", "vispy.scene.SceneCanvas", "laserscanvis.LaserScanVis.img_canvas.central_widget.add_grid", "laserscanvis.LaserScanVis.img_canvas.events.key_press.connect", "laserscanvis.LaserScanVis.img_canvas.events.draw.connect", "vispy.scene.widgets.ViewBox", "laserscanvis.LaserScanVis.img_grid.add_widget", "vispy.scene.visuals.Image", "laserscanvis.LaserScanVis.img_view.add", "print", "vispy.scene.widgets.ViewBox", "laserscanvis.LaserScanVis.grid.add_widget", "vispy.scene.visuals.Markers", "laserscanvis.LaserScanVis.sem_view.add", "vispy.scene.visuals.XYZAxis", "print", "vispy.scene.widgets.ViewBox", "laserscanvis.LaserScanVis.grid.add_widget", "vispy.scene.visuals.Markers", "laserscanvis.LaserScanVis.inst_view.add", "vispy.scene.visuals.XYZAxis", "vispy.scene.widgets.ViewBox", "laserscanvis.LaserScanVis.img_grid.add_widget", "vispy.scene.visuals.Image", "laserscanvis.LaserScanVis.sem_img_view.add", "vispy.scene.widgets.ViewBox", "laserscanvis.LaserScanVis.img_grid.add_widget", "vispy.scene.visuals.Image", "laserscanvis.LaserScanVis.inst_img_view.add"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "    ", "\"\"\" Reset. \"\"\"", "\n", "# last key press (it should have a mutex, but visualization is not", "\n", "# safety critical, so let's do things wrong)", "\n", "self", ".", "action", "=", "\"no\"", "# no, next, back, quit are the possibilities", "\n", "\n", "# new canvas prepared for visualizing data", "\n", "self", ".", "canvas", "=", "SceneCanvas", "(", "keys", "=", "'interactive'", ",", "show", "=", "True", ")", "\n", "# interface (n next, b back, q quit, very simple)", "\n", "self", ".", "canvas", ".", "events", ".", "key_press", ".", "connect", "(", "self", ".", "key_press", ")", "\n", "self", ".", "canvas", ".", "events", ".", "draw", ".", "connect", "(", "self", ".", "draw", ")", "\n", "# grid", "\n", "self", ".", "grid", "=", "self", ".", "canvas", ".", "central_widget", ".", "add_grid", "(", ")", "\n", "\n", "# laserscan part", "\n", "self", ".", "scan_view", "=", "vispy", ".", "scene", ".", "widgets", ".", "ViewBox", "(", "\n", "border_color", "=", "'white'", ",", "parent", "=", "self", ".", "canvas", ".", "scene", ")", "\n", "self", ".", "grid", ".", "add_widget", "(", "self", ".", "scan_view", ",", "0", ",", "0", ")", "\n", "self", ".", "scan_vis", "=", "visuals", ".", "Markers", "(", ")", "\n", "self", ".", "scan_view", ".", "camera", "=", "'turntable'", "\n", "self", ".", "scan_view", ".", "add", "(", "self", ".", "scan_vis", ")", "\n", "visuals", ".", "XYZAxis", "(", "parent", "=", "self", ".", "scan_view", ".", "scene", ")", "\n", "# add semantics", "\n", "if", "self", ".", "semantics", ":", "\n", "      ", "print", "(", "\"Using semantics in visualizer\"", ")", "\n", "self", ".", "sem_view", "=", "vispy", ".", "scene", ".", "widgets", ".", "ViewBox", "(", "\n", "border_color", "=", "'white'", ",", "parent", "=", "self", ".", "canvas", ".", "scene", ")", "\n", "self", ".", "grid", ".", "add_widget", "(", "self", ".", "sem_view", ",", "0", ",", "1", ")", "\n", "self", ".", "sem_vis", "=", "visuals", ".", "Markers", "(", ")", "\n", "self", ".", "sem_view", ".", "camera", "=", "'turntable'", "\n", "self", ".", "sem_view", ".", "add", "(", "self", ".", "sem_vis", ")", "\n", "visuals", ".", "XYZAxis", "(", "parent", "=", "self", ".", "sem_view", ".", "scene", ")", "\n", "# self.sem_view.camera.link(self.scan_view.camera)", "\n", "\n", "", "if", "self", ".", "instances", ":", "\n", "      ", "print", "(", "\"Using instances in visualizer\"", ")", "\n", "self", ".", "inst_view", "=", "vispy", ".", "scene", ".", "widgets", ".", "ViewBox", "(", "\n", "border_color", "=", "'white'", ",", "parent", "=", "self", ".", "canvas", ".", "scene", ")", "\n", "self", ".", "grid", ".", "add_widget", "(", "self", ".", "inst_view", ",", "0", ",", "2", ")", "\n", "self", ".", "inst_vis", "=", "visuals", ".", "Markers", "(", ")", "\n", "self", ".", "inst_view", ".", "camera", "=", "'turntable'", "\n", "self", ".", "inst_view", ".", "add", "(", "self", ".", "inst_vis", ")", "\n", "visuals", ".", "XYZAxis", "(", "parent", "=", "self", ".", "inst_view", ".", "scene", ")", "\n", "# self.inst_view.camera.link(self.scan_view.camera)", "\n", "\n", "# img canvas size", "\n", "", "self", ".", "multiplier", "=", "1", "\n", "self", ".", "canvas_W", "=", "1024", "\n", "self", ".", "canvas_H", "=", "64", "\n", "if", "self", ".", "semantics", ":", "\n", "      ", "self", ".", "multiplier", "+=", "1", "\n", "", "if", "self", ".", "instances", ":", "\n", "      ", "self", ".", "multiplier", "+=", "1", "\n", "\n", "# new canvas for img", "\n", "", "self", ".", "img_canvas", "=", "SceneCanvas", "(", "keys", "=", "'interactive'", ",", "show", "=", "True", ",", "\n", "size", "=", "(", "self", ".", "canvas_W", ",", "self", ".", "canvas_H", "*", "self", ".", "multiplier", ")", ")", "\n", "# grid", "\n", "self", ".", "img_grid", "=", "self", ".", "img_canvas", ".", "central_widget", ".", "add_grid", "(", ")", "\n", "# interface (n next, b back, q quit, very simple)", "\n", "self", ".", "img_canvas", ".", "events", ".", "key_press", ".", "connect", "(", "self", ".", "key_press", ")", "\n", "self", ".", "img_canvas", ".", "events", ".", "draw", ".", "connect", "(", "self", ".", "draw", ")", "\n", "\n", "# add a view for the depth", "\n", "self", ".", "img_view", "=", "vispy", ".", "scene", ".", "widgets", ".", "ViewBox", "(", "\n", "border_color", "=", "'white'", ",", "parent", "=", "self", ".", "img_canvas", ".", "scene", ")", "\n", "self", ".", "img_grid", ".", "add_widget", "(", "self", ".", "img_view", ",", "0", ",", "0", ")", "\n", "self", ".", "img_vis", "=", "visuals", ".", "Image", "(", "cmap", "=", "'viridis'", ")", "\n", "self", ".", "img_view", ".", "add", "(", "self", ".", "img_vis", ")", "\n", "\n", "# add semantics", "\n", "if", "self", ".", "semantics", ":", "\n", "      ", "self", ".", "sem_img_view", "=", "vispy", ".", "scene", ".", "widgets", ".", "ViewBox", "(", "\n", "border_color", "=", "'white'", ",", "parent", "=", "self", ".", "img_canvas", ".", "scene", ")", "\n", "self", ".", "img_grid", ".", "add_widget", "(", "self", ".", "sem_img_view", ",", "1", ",", "0", ")", "\n", "self", ".", "sem_img_vis", "=", "visuals", ".", "Image", "(", "cmap", "=", "'viridis'", ")", "\n", "self", ".", "sem_img_view", ".", "add", "(", "self", ".", "sem_img_vis", ")", "\n", "\n", "# add instances", "\n", "", "if", "self", ".", "instances", ":", "\n", "      ", "self", ".", "inst_img_view", "=", "vispy", ".", "scene", ".", "widgets", ".", "ViewBox", "(", "\n", "border_color", "=", "'white'", ",", "parent", "=", "self", ".", "img_canvas", ".", "scene", ")", "\n", "self", ".", "img_grid", ".", "add_widget", "(", "self", ".", "inst_img_view", ",", "2", ",", "0", ")", "\n", "self", ".", "inst_img_vis", "=", "visuals", ".", "Image", "(", "cmap", "=", "'viridis'", ")", "\n", "self", ".", "inst_img_view", ".", "add", "(", "self", ".", "inst_img_vis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.get_mpl_colormap": [[117, 127], ["matplotlib.pyplot.get_cmap", "matplotlib.pyplot.cm.ScalarMappable", "matplotlib.pyplot.cm.ScalarMappable.to_rgba", "color_range.reshape().astype", "numpy.linspace", "color_range.reshape"], "methods", ["None"], ["", "", "def", "get_mpl_colormap", "(", "self", ",", "cmap_name", ")", ":", "\n", "    ", "cmap", "=", "plt", ".", "get_cmap", "(", "cmap_name", ")", "\n", "\n", "# Initialize the matplotlib color map", "\n", "sm", "=", "plt", ".", "cm", ".", "ScalarMappable", "(", "cmap", "=", "cmap", ")", "\n", "\n", "# Obtain linear color range", "\n", "color_range", "=", "sm", ".", "to_rgba", "(", "np", ".", "linspace", "(", "0", ",", "1", ",", "256", ")", ",", "bytes", "=", "True", ")", "[", ":", ",", "2", ":", ":", "-", "1", "]", "\n", "\n", "return", "color_range", ".", "reshape", "(", "256", ",", "3", ")", ".", "astype", "(", "np", ".", "float32", ")", "/", "255.0", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.update_scan": [[128, 193], ["laserscanvis.LaserScanVis.scan.open_scan", "numpy.copy", "laserscanvis.LaserScanVis.get_mpl_colormap", "laserscanvis.LaserScanVis.scan_vis.set_data", "numpy.copy", "data[].min", "laserscanvis.LaserScanVis.img_vis.set_data", "laserscanvis.LaserScanVis.img_vis.update", "laserscanvis.LaserScanVis.scan.open_label", "laserscanvis.LaserScanVis.scan.colorize", "str", "laserscanvis.LaserScanVis.sem_vis.set_data", "laserscanvis.LaserScanVis.inst_vis.set_data", "laserscanvis.LaserScanVis.sem_img_vis.set_data", "laserscanvis.LaserScanVis.sem_img_vis.update", "laserscanvis.LaserScanVis.inst_img_vis.set_data", "laserscanvis.LaserScanVis.inst_img_vis.update", "data[].min", "numpy.copy.max", "data[].min", "numpy.copy.min", "numpy.copy.max", "numpy.copy.min"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.open_scan", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.get_mpl_colormap", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.open_label", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.colorize"], ["", "def", "update_scan", "(", "self", ")", ":", "\n", "# first open data", "\n", "    ", "self", ".", "scan", ".", "open_scan", "(", "self", ".", "scan_names", "[", "self", ".", "offset", "]", ")", "\n", "if", "self", ".", "semantics", ":", "\n", "      ", "self", ".", "scan", ".", "open_label", "(", "self", ".", "label_names", "[", "self", ".", "offset", "]", ")", "\n", "self", ".", "scan", ".", "colorize", "(", ")", "\n", "\n", "# then change names", "\n", "", "title", "=", "\"scan \"", "+", "str", "(", "self", ".", "offset", ")", "\n", "self", ".", "canvas", ".", "title", "=", "title", "\n", "self", ".", "img_canvas", ".", "title", "=", "title", "\n", "\n", "# then do all the point cloud stuff", "\n", "\n", "# plot scan", "\n", "power", "=", "16", "\n", "# print()", "\n", "range_data", "=", "np", ".", "copy", "(", "self", ".", "scan", ".", "unproj_range", ")", "\n", "# print(range_data.max(), range_data.min())", "\n", "range_data", "=", "range_data", "**", "(", "1", "/", "power", ")", "\n", "# print(range_data.max(), range_data.min())", "\n", "viridis_range", "=", "(", "(", "range_data", "-", "range_data", ".", "min", "(", ")", ")", "/", "\n", "(", "range_data", ".", "max", "(", ")", "-", "range_data", ".", "min", "(", ")", ")", "*", "\n", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "viridis_map", "=", "self", ".", "get_mpl_colormap", "(", "\"viridis\"", ")", "\n", "viridis_colors", "=", "viridis_map", "[", "viridis_range", "]", "\n", "self", ".", "scan_vis", ".", "set_data", "(", "self", ".", "scan", ".", "points", ",", "\n", "face_color", "=", "viridis_colors", "[", "...", ",", ":", ":", "-", "1", "]", ",", "\n", "edge_color", "=", "viridis_colors", "[", "...", ",", ":", ":", "-", "1", "]", ",", "\n", "size", "=", "1", ")", "\n", "\n", "# plot semantics", "\n", "if", "self", ".", "semantics", ":", "\n", "      ", "self", ".", "sem_vis", ".", "set_data", "(", "self", ".", "scan", ".", "points", ",", "\n", "face_color", "=", "self", ".", "scan", ".", "sem_label_color", "[", "...", ",", ":", ":", "-", "1", "]", ",", "\n", "edge_color", "=", "self", ".", "scan", ".", "sem_label_color", "[", "...", ",", ":", ":", "-", "1", "]", ",", "\n", "size", "=", "1", ")", "\n", "\n", "# plot instances", "\n", "", "if", "self", ".", "instances", ":", "\n", "      ", "self", ".", "inst_vis", ".", "set_data", "(", "self", ".", "scan", ".", "points", ",", "\n", "face_color", "=", "self", ".", "scan", ".", "inst_label_color", "[", "...", ",", ":", ":", "-", "1", "]", ",", "\n", "edge_color", "=", "self", ".", "scan", ".", "inst_label_color", "[", "...", ",", ":", ":", "-", "1", "]", ",", "\n", "size", "=", "1", ")", "\n", "\n", "# now do all the range image stuff", "\n", "# plot range image", "\n", "", "data", "=", "np", ".", "copy", "(", "self", ".", "scan", ".", "proj_range", ")", "\n", "# print(data[data > 0].max(), data[data > 0].min())", "\n", "data", "[", "data", ">", "0", "]", "=", "data", "[", "data", ">", "0", "]", "**", "(", "1", "/", "power", ")", "\n", "data", "[", "data", "<", "0", "]", "=", "data", "[", "data", ">", "0", "]", ".", "min", "(", ")", "\n", "# print(data.max(), data.min())", "\n", "data", "=", "(", "data", "-", "data", "[", "data", ">", "0", "]", ".", "min", "(", ")", ")", "/", "(", "data", ".", "max", "(", ")", "-", "data", "[", "data", ">", "0", "]", ".", "min", "(", ")", ")", "\n", "# print(data.max(), data.min())", "\n", "self", ".", "img_vis", ".", "set_data", "(", "data", ")", "\n", "self", ".", "img_vis", ".", "update", "(", ")", "\n", "\n", "if", "self", ".", "semantics", ":", "\n", "      ", "self", ".", "sem_img_vis", ".", "set_data", "(", "self", ".", "scan", ".", "proj_sem_color", "[", "...", ",", ":", ":", "-", "1", "]", ")", "\n", "self", ".", "sem_img_vis", ".", "update", "(", ")", "\n", "\n", "", "if", "self", ".", "instances", ":", "\n", "      ", "self", ".", "inst_img_vis", ".", "set_data", "(", "self", ".", "scan", ".", "proj_inst_color", "[", "...", ",", ":", ":", "-", "1", "]", ")", "\n", "self", ".", "inst_img_vis", ".", "update", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.key_press": [[195, 210], ["laserscanvis.LaserScanVis.canvas.events.key_press.block", "laserscanvis.LaserScanVis.img_canvas.events.key_press.block", "laserscanvis.LaserScanVis.update_scan", "laserscanvis.LaserScanVis.update_scan", "laserscanvis.LaserScanVis.destroy"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.update_scan", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.update_scan", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.destroy"], ["", "", "def", "key_press", "(", "self", ",", "event", ")", ":", "\n", "    ", "self", ".", "canvas", ".", "events", ".", "key_press", ".", "block", "(", ")", "\n", "self", ".", "img_canvas", ".", "events", ".", "key_press", ".", "block", "(", ")", "\n", "if", "event", ".", "key", "==", "'N'", ":", "\n", "      ", "self", ".", "offset", "+=", "1", "\n", "if", "self", ".", "offset", ">=", "self", ".", "total", ":", "\n", "        ", "self", ".", "offset", "=", "0", "\n", "", "self", ".", "update_scan", "(", ")", "\n", "", "elif", "event", ".", "key", "==", "'B'", ":", "\n", "      ", "self", ".", "offset", "-=", "1", "\n", "if", "self", ".", "offset", "<", "0", ":", "\n", "        ", "self", ".", "offset", "=", "self", ".", "total", "-", "1", "\n", "", "self", ".", "update_scan", "(", ")", "\n", "", "elif", "event", ".", "key", "==", "'Q'", "or", "event", ".", "key", "==", "'Escape'", ":", "\n", "      ", "self", ".", "destroy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.draw": [[211, 216], ["laserscanvis.LaserScanVis.canvas.events.key_press.blocked", "laserscanvis.LaserScanVis.img_canvas.events.key_press.blocked", "laserscanvis.LaserScanVis.canvas.events.key_press.unblock", "laserscanvis.LaserScanVis.img_canvas.events.key_press.unblock"], "methods", ["None"], ["", "", "def", "draw", "(", "self", ",", "event", ")", ":", "\n", "    ", "if", "self", ".", "canvas", ".", "events", ".", "key_press", ".", "blocked", "(", ")", ":", "\n", "      ", "self", ".", "canvas", ".", "events", ".", "key_press", ".", "unblock", "(", ")", "\n", "", "if", "self", ".", "img_canvas", ".", "events", ".", "key_press", ".", "blocked", "(", ")", ":", "\n", "      ", "self", ".", "img_canvas", ".", "events", ".", "key_press", ".", "unblock", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.destroy": [[217, 222], ["laserscanvis.LaserScanVis.canvas.close", "laserscanvis.LaserScanVis.img_canvas.close", "vispy.app.quit"], "methods", ["None"], ["", "", "def", "destroy", "(", "self", ")", ":", "\n", "# destroy the visualization", "\n", "    ", "self", ".", "canvas", ".", "close", "(", ")", "\n", "self", ".", "img_canvas", ".", "close", "(", ")", "\n", "vispy", ".", "app", ".", "quit", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.run": [[223, 225], ["vispy.app.run"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscanvis.LaserScanVis.run"], ["", "def", "run", "(", "self", ")", ":", "\n", "    ", "vispy", ".", "app", ".", "run", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.__init__": [[67, 71], ["OpenGL.glGenBuffers"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "target", "=", "gl", ".", "GL_ARRAY_BUFFER", ",", "usage", "=", "gl", ".", "GL_STATIC_DRAW", ")", ":", "\n", "    ", "self", ".", "id_", "=", "gl", ".", "glGenBuffers", "(", "1", ")", "\n", "self", ".", "target_", "=", "target", "\n", "self", ".", "usage_", "=", "usage", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.assign": [[75, 79], ["OpenGL.glBindBuffer", "OpenGL.glBufferData", "OpenGL.glBindBuffer"], "methods", ["None"], ["", "def", "assign", "(", "self", ",", "array", ")", ":", "\n", "    ", "gl", ".", "glBindBuffer", "(", "self", ".", "target_", ",", "self", ".", "id_", ")", "\n", "gl", ".", "glBufferData", "(", "self", ".", "target_", ",", "array", ",", "self", ".", "usage_", ")", "\n", "gl", ".", "glBindBuffer", "(", "self", ".", "target_", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.bind": [[80, 82], ["OpenGL.glBindBuffer"], "methods", ["None"], ["", "def", "bind", "(", "self", ")", ":", "\n", "    ", "gl", ".", "glBindBuffer", "(", "self", ".", "target_", ",", "self", ".", "id_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.release": [[83, 85], ["OpenGL.glBindBuffer"], "methods", ["None"], ["", "def", "release", "(", "self", ")", ":", "\n", "    ", "gl", ".", "glBindBuffer", "(", "self", ".", "target_", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.id": [[86, 89], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "id", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "id_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.usage": [[90, 93], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "usage", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "usage_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlBuffer.target": [[94, 97], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "target", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "target_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlTextureRectangle.__init__": [[100, 114], ["OpenGL.glGenTextures", "OpenGL.glBindTexture", "OpenGL.glTexParameteri", "OpenGL.glTexParameteri", "OpenGL.glTexParameteri", "OpenGL.glTexParameteri", "OpenGL.glBindTexture"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "width", ",", "height", ",", "internalFormat", "=", "gl", ".", "GL_RGBA", ",", "format", "=", "gl", ".", "GL_RGBA", ")", ":", "\n", "    ", "self", ".", "id_", "=", "gl", ".", "glGenTextures", "(", "1", ")", "\n", "self", ".", "internalFormat_", "=", "internalFormat", "# gl.GL_RGB_FLOAT, gl.GL_RGB_UNSIGNED, ...", "\n", "self", ".", "format", "=", "format", "# GL_RG. GL_RG_INTEGER, ...", "\n", "\n", "self", ".", "width_", "=", "width", "\n", "self", ".", "height_", "=", "height", "\n", "\n", "gl", ".", "glBindTexture", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "self", ".", "id_", ")", "\n", "gl", ".", "glTexParameteri", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "gl", ".", "GL_TEXTURE_MIN_FILTER", ",", "gl", ".", "GL_NEAREST", ")", "\n", "gl", ".", "glTexParameteri", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "gl", ".", "GL_TEXTURE_MAG_FILTER", ",", "gl", ".", "GL_NEAREST", ")", "\n", "gl", ".", "glTexParameteri", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "gl", ".", "GL_TEXTURE_WRAP_S", ",", "gl", ".", "GL_CLAMP_TO_BORDER", ")", "\n", "gl", ".", "glTexParameteri", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "gl", ".", "GL_TEXTURE_WRAP_T", ",", "gl", ".", "GL_CLAMP_TO_BORDER", ")", "\n", "gl", ".", "glBindTexture", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlTextureRectangle.bind": [[115, 118], ["OpenGL.glActiveTexture", "OpenGL.glBindTexture", "int"], "methods", ["None"], ["", "def", "bind", "(", "self", ",", "textureUnitId", ")", ":", "\n", "    ", "gl", ".", "glActiveTexture", "(", "gl", ".", "GL_TEXTURE0", "+", "int", "(", "textureUnitId", ")", ")", "\n", "gl", ".", "glBindTexture", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "self", ".", "id_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlTextureRectangle.release": [[119, 122], ["OpenGL.glActiveTexture", "OpenGL.glBindTexture", "int"], "methods", ["None"], ["", "def", "release", "(", "self", ",", "textureUnitId", ")", ":", "\n", "    ", "gl", ".", "glActiveTexture", "(", "gl", ".", "GL_TEXTURE0", "+", "int", "(", "textureUnitId", ")", ")", "\n", "gl", ".", "glBindTexture", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlTextureRectangle.assign": [[123, 136], ["OpenGL.glBindTexture", "OpenGL.glBindTexture", "OpenGL.glTexImage2D", "OpenGL.glTexImage2D", "NotImplementedError"], "methods", ["None"], ["", "def", "assign", "(", "self", ",", "array", ")", ":", "\n", "    ", "gl", ".", "glBindTexture", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "self", ".", "id_", ")", "\n", "\n", "if", "array", ".", "dtype", "==", "np", ".", "uint8", ":", "\n", "      ", "gl", ".", "glTexImage2D", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "0", ",", "self", ".", "internalFormat_", ",", "self", ".", "width_", ",", "self", ".", "height_", ",", "0", ",", "self", ".", "format", ",", "\n", "gl", ".", "GL_UNSIGNED_BYTE", ",", "array", ")", "\n", "", "elif", "array", ".", "dtype", "==", "np", ".", "float32", ":", "\n", "      ", "gl", ".", "glTexImage2D", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "0", ",", "self", ".", "internalFormat_", ",", "self", ".", "width_", ",", "self", ".", "height_", ",", "0", ",", "self", ".", "format", ",", "\n", "gl", ".", "GL_FLOAT", ",", "array", ")", "\n", "", "else", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"pixel type not implemented.\"", ")", "\n", "\n", "", "gl", ".", "glBindTexture", "(", "gl", ".", "GL_TEXTURE_RECTANGLE", ",", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlTextureRectangle.id": [[137, 140], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "id", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "id_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.__init__": [[143, 156], ["OpenGL.glCreateShader", "OpenGL.glShaderSource", "OpenGL.glCompileShader", "OpenGL.glGetShaderiv", "OpenGL.glGetShaderInfoLog().decode", "RuntimeError", "OpenGL.glGetShaderInfoLog"], "methods", ["None"], ["  ", "def", "__init__", "(", "self", ",", "shader_type", ",", "source", ")", ":", "\n", "    ", "self", ".", "code_", "=", "source", "\n", "self", ".", "shader_type_", "=", "shader_type", "\n", "\n", "self", ".", "id_", "=", "gl", ".", "glCreateShader", "(", "self", ".", "shader_type_", ")", "\n", "gl", ".", "glShaderSource", "(", "self", ".", "id_", ",", "source", ")", "\n", "\n", "gl", ".", "glCompileShader", "(", "self", ".", "id_", ")", "\n", "\n", "success", "=", "gl", ".", "glGetShaderiv", "(", "self", ".", "id_", ",", "gl", ".", "GL_COMPILE_STATUS", ")", "\n", "if", "success", "==", "gl", ".", "GL_FALSE", ":", "\n", "      ", "error_string", "=", "gl", ".", "glGetShaderInfoLog", "(", "self", ".", "id_", ")", ".", "decode", "(", "\"utf-8\"", ")", "\n", "raise", "RuntimeError", "(", "error_string", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.__del__": [[157, 159], ["OpenGL.glDeleteShader"], "methods", ["None"], ["", "", "def", "__del__", "(", "self", ")", ":", "\n", "    ", "gl", ".", "glDeleteShader", "(", "self", ".", "id_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.type": [[160, 163], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "type", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "shader_type_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.id": [[164, 167], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "id", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "id_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.code": [[168, 171], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "code", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "code_", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.fromFile": [[172, 180], ["open", "open.close", "glow.GlShader", "open.readlines"], "methods", ["None"], ["", "@", "staticmethod", "\n", "def", "fromFile", "(", "shader_type", ",", "filename", ")", ":", "\n", "    ", "f", "=", "open", "(", "filename", ")", "\n", "source", "=", "\"\\n\"", ".", "join", "(", "f", ".", "readlines", "(", ")", ")", "\n", "# todo: preprocess.", "\n", "f", ".", "close", "(", ")", "\n", "\n", "return", "GlShader", "(", "shader_type", ",", "source", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.__init__": [[185, 190], ["OpenGL.glCreateProgram"], "methods", ["None"], ["def", "__init__", "(", "self", ")", ":", "\n", "    ", "self", ".", "id_", "=", "gl", ".", "glCreateProgram", "(", ")", "\n", "self", ".", "shaders_", "=", "{", "}", "\n", "self", ".", "uniform_types_", "=", "{", "}", "\n", "self", ".", "is_linked", "=", "False", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.__del__": [[191, 193], ["OpenGL.glDeleteProgram"], "methods", ["None"], ["", "def", "__del__", "(", "self", ")", ":", "\n", "    ", "gl", ".", "glDeleteProgram", "(", "self", ".", "id_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.bind": [[194, 198], ["OpenGL.glUseProgram", "RuntimeError"], "methods", ["None"], ["", "def", "bind", "(", "self", ")", ":", "\n", "    ", "if", "not", "self", ".", "is_linked", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"Program must be linked before usage.\"", ")", "\n", "", "gl", ".", "glUseProgram", "(", "self", ".", "id_", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.release": [[199, 201], ["OpenGL.glUseProgram"], "methods", ["None"], ["", "def", "release", "(", "self", ")", ":", "\n", "    ", "gl", ".", "glUseProgram", "(", "0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.attach": [[202, 204], ["None"], "methods", ["None"], ["", "def", "attach", "(", "self", ",", "shader", ")", ":", "\n", "    ", "self", ".", "shaders_", "[", "shader", ".", "type", "]", "=", "shader", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.__setitem__": [[205, 249], ["OpenGL.glGetUniformLocation", "OpenGL.glUniform1i", "OpenGL.glUniform1ui", "print", "numpy.int32", "numpy.uint32", "OpenGL.glUniform1f", "numpy.float32", "OpenGL.glUniform1f", "OpenGL.glUniform2fv", "OpenGL.glUniform3fv", "OpenGL.glUniform4fv", "OpenGL.glUniform2iv", "OpenGL.glUniform3iv", "OpenGL.glUniform4iv", "OpenGL.glUniform2uiv", "OpenGL.glUniform3uiv", "OpenGL.glUniform4uiv", "OpenGL.glUniformMatrix4fv", "value.astype", "OpenGL.glUniform1i", "numpy.int32", "OpenGL.glUniform1i", "NotImplementedError", "numpy.int32"], "methods", ["None"], ["", "def", "__setitem__", "(", "self", ",", "name", ",", "value", ")", ":", "\n", "# quitely ignore", "\n", "    ", "if", "name", "not", "in", "self", ".", "uniform_types_", ":", "\n", "      ", "if", "WARN_INVALID_UNIFORMS", ":", "print", "(", "\"No uniform with name '{}' available.\"", ".", "format", "(", "name", ")", ")", "\n", "return", "\n", "\n", "", "loc", "=", "gl", ".", "glGetUniformLocation", "(", "self", ".", "id_", ",", "name", ")", "\n", "T", "=", "self", ".", "uniform_types_", "[", "name", "]", "\n", "\n", "if", "T", "==", "\"int\"", ":", "\n", "      ", "gl", ".", "glUniform1i", "(", "loc", ",", "np", ".", "int32", "(", "value", ")", ")", "\n", "", "if", "T", "==", "\"uint\"", ":", "\n", "      ", "gl", ".", "glUniform1ui", "(", "loc", ",", "np", ".", "uint32", "(", "value", ")", ")", "\n", "", "elif", "T", "==", "\"float\"", ":", "\n", "      ", "gl", ".", "glUniform1f", "(", "loc", ",", "np", ".", "float32", "(", "value", ")", ")", "\n", "", "elif", "T", "==", "\"bool\"", ":", "\n", "      ", "gl", ".", "glUniform1f", "(", "loc", ",", "value", ")", "\n", "", "elif", "T", "==", "\"vec2\"", ":", "\n", "      ", "gl", ".", "glUniform2fv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"vec3\"", ":", "\n", "      ", "gl", ".", "glUniform3fv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"vec4\"", ":", "\n", "      ", "gl", ".", "glUniform4fv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"ivec2\"", ":", "\n", "      ", "gl", ".", "glUniform2iv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"ivec3\"", ":", "\n", "      ", "gl", ".", "glUniform3iv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"ivec4\"", ":", "\n", "      ", "gl", ".", "glUniform4iv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"uivec2\"", ":", "\n", "      ", "gl", ".", "glUniform2uiv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"uivec3\"", ":", "\n", "      ", "gl", ".", "glUniform3uiv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"uivec4\"", ":", "\n", "      ", "gl", ".", "glUniform4uiv", "(", "loc", ",", "1", ",", "value", ")", "\n", "", "elif", "T", "==", "\"mat4\"", ":", "\n", "#print(\"set matrix: \", value)", "\n", "      ", "gl", ".", "glUniformMatrix4fv", "(", "loc", ",", "1", ",", "False", ",", "value", ".", "astype", "(", "np", ".", "float32", ")", ")", "\n", "", "elif", "T", "==", "\"sampler2D\"", ":", "\n", "      ", "gl", ".", "glUniform1i", "(", "loc", ",", "np", ".", "int32", "(", "value", ")", ")", "\n", "", "elif", "T", "==", "\"sampler2DRect\"", ":", "\n", "      ", "gl", ".", "glUniform1i", "(", "loc", ",", "np", ".", "int32", "(", "value", ")", ")", "\n", "", "else", ":", "\n", "      ", "raise", "NotImplementedError", "(", "\"uniform type {} not implemented. :(\"", ".", "format", "(", "T", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlProgram.link": [[250, 271], ["glow.GlProgram.shaders_.values", "OpenGL.glLinkProgram", "bool", "RuntimeError", "OpenGL.glAttachShader", "shader.code.split", "OpenGL.glGetProgramiv", "OpenGL.glGetProgramInfoLog", "RuntimeError", "re.search", "str", "re.search.group", "OpenGL.glGetProgramInfoLog.decode", "re.search.group"], "methods", ["None"], ["", "", "def", "link", "(", "self", ")", ":", "\n", "    ", "if", "gl", ".", "GL_VERTEX_SHADER", "not", "in", "self", ".", "shaders_", "or", "gl", ".", "GL_FRAGMENT_SHADER", "not", "in", "self", ".", "shaders_", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"program needs at least vertex and fragment shader\"", ")", "\n", "\n", "", "for", "shader", "in", "self", ".", "shaders_", ".", "values", "(", ")", ":", "\n", "      ", "gl", ".", "glAttachShader", "(", "self", ".", "id_", ",", "shader", ".", "id", ")", "\n", "for", "line", "in", "shader", ".", "code", ".", "split", "(", "\"\\n\"", ")", ":", "\n", "        ", "match", "=", "re", ".", "search", "(", "r\"uniform\\s+(\\S+)\\s+(\\S+)\\s*;\"", ",", "line", ")", "\n", "if", "match", ":", "\n", "          ", "self", ".", "uniform_types_", "[", "match", ".", "group", "(", "2", ")", "]", "=", "match", ".", "group", "(", "1", ")", "\n", "\n", "", "", "", "gl", ".", "glLinkProgram", "(", "self", ".", "id_", ")", "\n", "isLinked", "=", "bool", "(", "gl", ".", "glGetProgramiv", "(", "self", ".", "id_", ",", "gl", ".", "GL_LINK_STATUS", ")", ")", "\n", "if", "not", "isLinked", ":", "\n", "      ", "msg", "=", "gl", ".", "glGetProgramInfoLog", "(", "self", ".", "id_", ")", "\n", "\n", "raise", "RuntimeError", "(", "str", "(", "msg", ".", "decode", "(", "\"utf-8\"", ")", ")", ")", "\n", "\n", "# after linking we don't need the source code anymore.", "\n", "", "self", ".", "shaders_", "=", "{", "}", "\n", "self", ".", "is_linked", "=", "True", "\n", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.vec2": [[17, 20], ["numpy.array"], "function", ["None"], ["def", "vec2", "(", "x", ",", "y", ")", ":", "\n", "  ", "\"\"\" returns an vec2-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.vec3": [[22, 25], ["numpy.array"], "function", ["None"], ["", "def", "vec3", "(", "x", ",", "y", ",", "z", ")", ":", "\n", "  ", "\"\"\" returns an vec3-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", ",", "z", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.vec4": [[27, 30], ["numpy.array"], "function", ["None"], ["", "def", "vec4", "(", "x", ",", "y", ",", "z", ",", "w", ")", ":", "\n", "  ", "\"\"\" returns an vec4-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", ",", "z", ",", "w", "]", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.ivec2": [[32, 35], ["numpy.array"], "function", ["None"], ["", "def", "ivec2", "(", "x", ",", "y", ")", ":", "\n", "  ", "\"\"\" returns an ivec2-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.ivec3": [[37, 40], ["numpy.array"], "function", ["None"], ["", "def", "ivec3", "(", "x", ",", "y", ",", "z", ")", ":", "\n", "  ", "\"\"\" returns an ivec3-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", ",", "z", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.ivec4": [[42, 45], ["numpy.array"], "function", ["None"], ["", "def", "ivec4", "(", "x", ",", "y", ",", "z", ",", "w", ")", ":", "\n", "  ", "\"\"\" returns an ivec4-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", ",", "z", ",", "w", "]", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.uivec2": [[47, 50], ["numpy.array"], "function", ["None"], ["", "def", "uivec2", "(", "x", ",", "y", ")", ":", "\n", "  ", "\"\"\" returns an ivec2-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", "]", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.uivec3": [[52, 55], ["numpy.array"], "function", ["None"], ["", "def", "uivec3", "(", "x", ",", "y", ",", "z", ")", ":", "\n", "  ", "\"\"\" returns an ivec3-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", ",", "z", "]", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.uivec4": [[57, 60], ["numpy.array"], "function", ["None"], ["", "def", "uivec4", "(", "x", ",", "y", ",", "z", ",", "w", ")", ":", "\n", "  ", "\"\"\" returns an ivec4-compatible numpy array \"\"\"", "\n", "return", "np", ".", "array", "(", "[", "x", ",", "y", ",", "z", ",", "w", "]", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.__init__": [[10, 28], ["torch.tensor().long", "torch.tensor().long", "print", "print", "torch.device", "torch.cuda.is_available", "torch_ioueval.iouEval.reset", "torch.device", "torch.tensor", "torch.tensor", "range"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset"], ["  ", "def", "__init__", "(", "self", ",", "n_classes", ",", "ignore", "=", "None", ")", ":", "\n", "# classes", "\n", "    ", "self", ".", "n_classes", "=", "n_classes", "\n", "\n", "# What to include and ignore from the means", "\n", "self", ".", "ignore", "=", "torch", ".", "tensor", "(", "ignore", ")", ".", "long", "(", ")", "\n", "self", ".", "include", "=", "torch", ".", "tensor", "(", "\n", "[", "n", "for", "n", "in", "range", "(", "self", ".", "n_classes", ")", "if", "n", "not", "in", "self", ".", "ignore", "]", ")", ".", "long", "(", ")", "\n", "print", "(", "\"[IOU EVAL] IGNORE: \"", ",", "self", ".", "ignore", ")", "\n", "print", "(", "\"[IOU EVAL] INCLUDE: \"", ",", "self", ".", "include", ")", "\n", "\n", "# get device", "\n", "self", ".", "device", "=", "torch", ".", "device", "(", "'cpu'", ")", "\n", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", ":", "\n", "      ", "self", ".", "device", "=", "torch", ".", "device", "(", "'cuda'", ")", "\n", "\n", "# reset the class counters", "\n", "", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.num_classes": [[29, 31], ["None"], "methods", ["None"], ["", "def", "num_classes", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.reset": [[32, 35], ["torch.zeros().long", "torch.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "    ", "self", ".", "conf_matrix", "=", "torch", ".", "zeros", "(", "\n", "(", "self", ".", "n_classes", ",", "self", ".", "n_classes", ")", ",", "device", "=", "self", ".", "device", ")", ".", "long", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.addBatch": [[36, 57], ["torch.from_numpy().to().long", "torch.from_numpy().to().long", "x_row.reshape.reshape.reshape", "y_row.reshape.reshape.reshape", "torch.stack", "torch.ones().long", "torch_ioueval.iouEval.conf_matrix.index_put_", "tuple", "torch.from_numpy().to", "torch.from_numpy().to", "torch.ones", "torch.from_numpy", "torch.from_numpy"], "methods", ["None"], ["", "def", "addBatch", "(", "self", ",", "x", ",", "y", ")", ":", "# x=preds, y=targets", "\n", "# to tensor", "\n", "    ", "x_row", "=", "torch", ".", "from_numpy", "(", "x", ")", ".", "to", "(", "self", ".", "device", ")", ".", "long", "(", ")", "\n", "y_row", "=", "torch", ".", "from_numpy", "(", "y", ")", ".", "to", "(", "self", ".", "device", ")", ".", "long", "(", ")", "\n", "\n", "# sizes should be matching", "\n", "x_row", "=", "x_row", ".", "reshape", "(", "-", "1", ")", "# de-batchify", "\n", "y_row", "=", "y_row", ".", "reshape", "(", "-", "1", ")", "# de-batchify", "\n", "\n", "# check", "\n", "assert", "(", "x_row", ".", "shape", "==", "x_row", ".", "shape", ")", "\n", "\n", "# idxs are labels and predictions", "\n", "idxs", "=", "torch", ".", "stack", "(", "[", "x_row", ",", "y_row", "]", ",", "dim", "=", "0", ")", "\n", "\n", "# ones is what I want to add to conf when I", "\n", "ones", "=", "torch", ".", "ones", "(", "(", "idxs", ".", "shape", "[", "-", "1", "]", ")", ",", "device", "=", "self", ".", "device", ")", ".", "long", "(", ")", "\n", "\n", "# make confusion matrix (cols = gt, rows = pred)", "\n", "self", ".", "conf_matrix", "=", "self", ".", "conf_matrix", ".", "index_put_", "(", "\n", "tuple", "(", "idxs", ")", ",", "ones", ",", "accumulate", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getStats": [[58, 68], ["torch_ioueval.iouEval.conf_matrix.clone().double", "torch_ioueval.iouEval.diag", "torch_ioueval.iouEval.sum", "torch_ioueval.iouEval.sum", "torch_ioueval.iouEval.conf_matrix.clone"], "methods", ["None"], ["", "def", "getStats", "(", "self", ")", ":", "\n", "# remove fp from confusion on the ignore classes cols", "\n", "    ", "conf", "=", "self", ".", "conf_matrix", ".", "clone", "(", ")", ".", "double", "(", ")", "\n", "conf", "[", ":", ",", "self", ".", "ignore", "]", "=", "0", "\n", "\n", "# get the clean stats", "\n", "tp", "=", "conf", ".", "diag", "(", ")", "\n", "fp", "=", "conf", ".", "sum", "(", "dim", "=", "1", ")", "-", "tp", "\n", "fn", "=", "conf", ".", "sum", "(", "dim", "=", "0", ")", "-", "tp", "\n", "return", "tp", ",", "fp", ",", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getIoU": [[69, 76], ["torch_ioueval.iouEval.getStats"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getStats"], ["", "def", "getIoU", "(", "self", ")", ":", "\n", "    ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getStats", "(", ")", "\n", "intersection", "=", "tp", "\n", "union", "=", "tp", "+", "fp", "+", "fn", "+", "1e-15", "\n", "iou", "=", "intersection", "/", "union", "\n", "iou_mean", "=", "(", "intersection", "[", "self", ".", "include", "]", "/", "union", "[", "self", ".", "include", "]", ")", ".", "mean", "(", ")", "\n", "return", "iou_mean", ",", "iou", "# returns \"iou mean\", \"iou per class\" ALL CLASSES", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getacc": [[77, 83], ["torch_ioueval.iouEval.getStats", "tp.sum", "tp[].sum", "fp[].sum"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.torch_ioueval.iouEval.getStats"], ["", "def", "getacc", "(", "self", ")", ":", "\n", "    ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getStats", "(", ")", "\n", "total_tp", "=", "tp", ".", "sum", "(", ")", "\n", "total", "=", "tp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "+", "fp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "+", "1e-15", "\n", "acc_mean", "=", "total_tp", "/", "total", "\n", "return", "acc_mean", "# returns \"acc mean\"", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.__init__": [[9, 16], ["laserscan.LaserScan.reset"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset"], ["def", "__init__", "(", "self", ",", "project", "=", "False", ",", "H", "=", "64", ",", "W", "=", "1024", ",", "fov_up", "=", "3.0", ",", "fov_down", "=", "-", "25.0", ")", ":", "\n", "    ", "self", ".", "project", "=", "project", "\n", "self", ".", "proj_H", "=", "H", "\n", "self", ".", "proj_W", "=", "W", "\n", "self", ".", "proj_fov_up", "=", "fov_up", "\n", "self", ".", "proj_fov_down", "=", "fov_down", "\n", "self", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.reset": [[17, 49], ["numpy.zeros", "numpy.zeros", "numpy.full", "numpy.zeros", "numpy.full", "numpy.full", "numpy.full", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "    ", "\"\"\" Reset scan members. \"\"\"", "\n", "self", ".", "points", "=", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# [m, 3]: x, y, z", "\n", "self", ".", "remissions", "=", "np", ".", "zeros", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# [m ,1]: remission", "\n", "\n", "# projected range image - [H,W] range (-1 is no data)", "\n", "self", ".", "proj_range", "=", "np", ".", "full", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ")", ",", "-", "1", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# unprojected range (list of depths for each point)", "\n", "self", ".", "unproj_range", "=", "np", ".", "zeros", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# projected point cloud xyz - [H,W,3] xyz coord (-1 is no data)", "\n", "self", ".", "proj_xyz", "=", "np", ".", "full", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ",", "3", ")", ",", "-", "1", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# projected remission - [H,W] intensity (-1 is no data)", "\n", "self", ".", "proj_remission", "=", "np", ".", "full", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ")", ",", "-", "1", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# projected index (for each pixel, what I am in the pointcloud)", "\n", "# [H,W] index (-1 is no data)", "\n", "self", ".", "proj_idx", "=", "np", ".", "full", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ")", ",", "-", "1", ",", "\n", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "# for each point, where it is in the range image", "\n", "self", ".", "proj_x", "=", "np", ".", "zeros", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# [m, 1]: x", "\n", "self", ".", "proj_y", "=", "np", ".", "zeros", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# [m, 1]: y", "\n", "\n", "# mask containing for each pixel, if it contains a point or not", "\n", "self", ".", "proj_mask", "=", "np", ".", "zeros", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ")", ",", "\n", "dtype", "=", "np", ".", "int32", ")", "# [H,W] mask", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.size": [[50, 53], ["None"], "methods", ["None"], ["", "def", "size", "(", "self", ")", ":", "\n", "    ", "\"\"\" Return the size of the point cloud. \"\"\"", "\n", "return", "self", ".", "points", ".", "shape", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.__len__": [[54, 56], ["laserscan.LaserScan.size"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.size"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "    ", "return", "self", ".", "size", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.open_scan": [[57, 80], ["laserscan.LaserScan.reset", "numpy.fromfile", "scan.reshape.reshape.reshape", "laserscan.LaserScan.set_points", "isinstance", "TypeError", "any", "RuntimeError", "filename.endswith", "str", "type"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.set_points", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.type"], ["", "def", "open_scan", "(", "self", ",", "filename", ")", ":", "\n", "    ", "\"\"\" Open raw scan and fill in attributes\n    \"\"\"", "\n", "# reset just in case there was an open structure", "\n", "self", ".", "reset", "(", ")", "\n", "\n", "# check filename is string", "\n", "if", "not", "isinstance", "(", "filename", ",", "str", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"Filename should be string type, \"", "\n", "\"but was {type}\"", ".", "format", "(", "type", "=", "str", "(", "type", "(", "filename", ")", ")", ")", ")", "\n", "\n", "# check extension is a laserscan", "\n", "", "if", "not", "any", "(", "filename", ".", "endswith", "(", "ext", ")", "for", "ext", "in", "self", ".", "EXTENSIONS_SCAN", ")", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"Filename extension is not valid scan file.\"", ")", "\n", "\n", "# if all goes well, open pointcloud", "\n", "", "scan", "=", "np", ".", "fromfile", "(", "filename", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "scan", "=", "scan", ".", "reshape", "(", "(", "-", "1", ",", "4", ")", ")", "\n", "\n", "# put in attribute", "\n", "points", "=", "scan", "[", ":", ",", "0", ":", "3", "]", "# get xyz", "\n", "remissions", "=", "scan", "[", ":", ",", "3", "]", "# get remission", "\n", "self", ".", "set_points", "(", "points", ",", "remissions", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.set_points": [[81, 105], ["laserscan.LaserScan.reset", "isinstance", "TypeError", "TypeError", "numpy.zeros", "laserscan.LaserScan.do_range_projection", "isinstance"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.do_range_projection"], ["", "def", "set_points", "(", "self", ",", "points", ",", "remissions", "=", "None", ")", ":", "\n", "    ", "\"\"\" Set scan attributes (instead of opening from file)\n    \"\"\"", "\n", "# reset just in case there was an open structure", "\n", "self", ".", "reset", "(", ")", "\n", "\n", "# check scan makes sense", "\n", "if", "not", "isinstance", "(", "points", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"Scan should be numpy array\"", ")", "\n", "\n", "# check remission makes sense", "\n", "", "if", "remissions", "is", "not", "None", "and", "not", "isinstance", "(", "remissions", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"Remissions should be numpy array\"", ")", "\n", "\n", "# put in attribute", "\n", "", "self", ".", "points", "=", "points", "# get xyz", "\n", "if", "remissions", "is", "not", "None", ":", "\n", "      ", "self", ".", "remissions", "=", "remissions", "# get remission", "\n", "", "else", ":", "\n", "      ", "self", ".", "remissions", "=", "np", ".", "zeros", "(", "(", "points", ".", "shape", "[", "0", "]", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "# if projection is wanted, then do it and fill in the structure", "\n", "", "if", "self", ".", "project", ":", "\n", "      ", "self", ".", "do_range_projection", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.LaserScan.do_range_projection": [[106, 167], ["numpy.linalg.norm", "numpy.arcsin", "numpy.floor", "numpy.minimum", "numpy.maximum().astype", "numpy.copy", "numpy.floor", "numpy.minimum", "numpy.maximum().astype", "numpy.copy", "numpy.copy", "numpy.arange", "abs", "abs", "numpy.arctan2", "numpy.argsort", "numpy.maximum", "numpy.maximum", "abs"], "methods", ["None"], ["", "", "def", "do_range_projection", "(", "self", ")", ":", "\n", "    ", "\"\"\" Project a pointcloud into a spherical projection image.projection.\n        Function takes no arguments because it can be also called externally\n        if the value of the constructor was not set (in case you change your\n        mind about wanting the projection)\n    \"\"\"", "\n", "# laser parameters", "\n", "fov_up", "=", "self", ".", "proj_fov_up", "/", "180.0", "*", "np", ".", "pi", "# field of view up in rad", "\n", "fov_down", "=", "self", ".", "proj_fov_down", "/", "180.0", "*", "np", ".", "pi", "# field of view down in rad", "\n", "fov", "=", "abs", "(", "fov_down", ")", "+", "abs", "(", "fov_up", ")", "# get field of view total in rad", "\n", "\n", "# get depth of all points", "\n", "depth", "=", "np", ".", "linalg", ".", "norm", "(", "self", ".", "points", ",", "2", ",", "axis", "=", "1", ")", "\n", "\n", "# get scan components", "\n", "scan_x", "=", "self", ".", "points", "[", ":", ",", "0", "]", "\n", "scan_y", "=", "self", ".", "points", "[", ":", ",", "1", "]", "\n", "scan_z", "=", "self", ".", "points", "[", ":", ",", "2", "]", "\n", "\n", "# get angles of all points", "\n", "yaw", "=", "-", "np", ".", "arctan2", "(", "scan_y", ",", "scan_x", ")", "\n", "pitch", "=", "np", ".", "arcsin", "(", "scan_z", "/", "depth", ")", "\n", "\n", "# get projections in image coords", "\n", "proj_x", "=", "0.5", "*", "(", "yaw", "/", "np", ".", "pi", "+", "1.0", ")", "# in [0.0, 1.0]", "\n", "proj_y", "=", "1.0", "-", "(", "pitch", "+", "abs", "(", "fov_down", ")", ")", "/", "fov", "# in [0.0, 1.0]", "\n", "\n", "# scale to image size using angular resolution", "\n", "proj_x", "*=", "self", ".", "proj_W", "# in [0.0, W]", "\n", "proj_y", "*=", "self", ".", "proj_H", "# in [0.0, H]", "\n", "\n", "# round and clamp for use as index", "\n", "proj_x", "=", "np", ".", "floor", "(", "proj_x", ")", "\n", "proj_x", "=", "np", ".", "minimum", "(", "self", ".", "proj_W", "-", "1", ",", "proj_x", ")", "\n", "proj_x", "=", "np", ".", "maximum", "(", "0", ",", "proj_x", ")", ".", "astype", "(", "np", ".", "int32", ")", "# in [0,W-1]", "\n", "self", ".", "proj_x", "=", "np", ".", "copy", "(", "proj_x", ")", "# store a copy in orig order", "\n", "\n", "proj_y", "=", "np", ".", "floor", "(", "proj_y", ")", "\n", "proj_y", "=", "np", ".", "minimum", "(", "self", ".", "proj_H", "-", "1", ",", "proj_y", ")", "\n", "proj_y", "=", "np", ".", "maximum", "(", "0", ",", "proj_y", ")", ".", "astype", "(", "np", ".", "int32", ")", "# in [0,H-1]", "\n", "self", ".", "proj_y", "=", "np", ".", "copy", "(", "proj_y", ")", "# stope a copy in original order", "\n", "\n", "# copy of depth in original order", "\n", "self", ".", "unproj_range", "=", "np", ".", "copy", "(", "depth", ")", "\n", "\n", "# order in decreasing depth", "\n", "indices", "=", "np", ".", "arange", "(", "depth", ".", "shape", "[", "0", "]", ")", "\n", "order", "=", "np", ".", "argsort", "(", "depth", ")", "[", ":", ":", "-", "1", "]", "\n", "depth", "=", "depth", "[", "order", "]", "\n", "indices", "=", "indices", "[", "order", "]", "\n", "points", "=", "self", ".", "points", "[", "order", "]", "\n", "remission", "=", "self", ".", "remissions", "[", "order", "]", "\n", "proj_y", "=", "proj_y", "[", "order", "]", "\n", "proj_x", "=", "proj_x", "[", "order", "]", "\n", "\n", "# assing to images", "\n", "self", ".", "proj_range", "[", "proj_y", ",", "proj_x", "]", "=", "depth", "\n", "self", ".", "proj_xyz", "[", "proj_y", ",", "proj_x", "]", "=", "points", "\n", "self", ".", "proj_remission", "[", "proj_y", ",", "proj_x", "]", "=", "remission", "\n", "self", ".", "proj_idx", "[", "proj_y", ",", "proj_x", "]", "=", "indices", "\n", "self", ".", "proj_mask", "=", "(", "self", ".", "proj_idx", ">", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.__init__": [[173, 194], ["laserscan.LaserScan.__init__", "laserscan.SemLaserScan.reset", "sem_color_dict.items", "numpy.zeros", "sem_color_dict.items", "numpy.random.uniform", "numpy.full", "numpy.array"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset"], ["def", "__init__", "(", "self", ",", "nclasses", ",", "sem_color_dict", "=", "None", ",", "project", "=", "False", ",", "H", "=", "64", ",", "W", "=", "1024", ",", "fov_up", "=", "3.0", ",", "fov_down", "=", "-", "25.0", ")", ":", "\n", "    ", "super", "(", "SemLaserScan", ",", "self", ")", ".", "__init__", "(", "project", ",", "H", ",", "W", ",", "fov_up", ",", "fov_down", ")", "\n", "self", ".", "reset", "(", ")", "\n", "self", ".", "nclasses", "=", "nclasses", "# number of classes", "\n", "\n", "# make semantic colors", "\n", "max_sem_key", "=", "0", "\n", "for", "key", ",", "data", "in", "sem_color_dict", ".", "items", "(", ")", ":", "\n", "      ", "if", "key", "+", "1", ">", "max_sem_key", ":", "\n", "        ", "max_sem_key", "=", "key", "+", "1", "\n", "", "", "self", ".", "sem_color_lut", "=", "np", ".", "zeros", "(", "(", "max_sem_key", "+", "100", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "for", "key", ",", "value", "in", "sem_color_dict", ".", "items", "(", ")", ":", "\n", "      ", "self", ".", "sem_color_lut", "[", "key", "]", "=", "np", ".", "array", "(", "value", ",", "np", ".", "float32", ")", "/", "255.0", "\n", "\n", "# make instance colors", "\n", "", "max_inst_id", "=", "100000", "\n", "self", ".", "inst_color_lut", "=", "np", ".", "random", ".", "uniform", "(", "low", "=", "0.0", ",", "\n", "high", "=", "1.0", ",", "\n", "size", "=", "(", "max_inst_id", ",", "3", ")", ")", "\n", "# force zero to a gray-ish color", "\n", "self", ".", "inst_color_lut", "[", "0", "]", "=", "np", ".", "full", "(", "(", "3", ")", ",", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.reset": [[195, 218], ["laserscan.LaserScan.reset", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset"], ["", "def", "reset", "(", "self", ")", ":", "\n", "    ", "\"\"\" Reset scan members. \"\"\"", "\n", "super", "(", "SemLaserScan", ",", "self", ")", ".", "reset", "(", ")", "\n", "\n", "# semantic labels", "\n", "self", ".", "sem_label", "=", "np", ".", "zeros", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "# [m, 1]: label", "\n", "self", ".", "sem_label_color", "=", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# [m ,3]: color", "\n", "\n", "# instance labels", "\n", "self", ".", "inst_label", "=", "np", ".", "zeros", "(", "(", "0", ",", "1", ")", ",", "dtype", "=", "np", ".", "uint32", ")", "# [m, 1]: label", "\n", "self", ".", "inst_label_color", "=", "np", ".", "zeros", "(", "(", "0", ",", "3", ")", ",", "dtype", "=", "np", ".", "float32", ")", "# [m ,3]: color", "\n", "\n", "# projection color with semantic labels", "\n", "self", ".", "proj_sem_label", "=", "np", ".", "zeros", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ")", ",", "\n", "dtype", "=", "np", ".", "int32", ")", "# [H,W]  label", "\n", "self", ".", "proj_sem_color", "=", "np", ".", "zeros", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ",", "3", ")", ",", "\n", "dtype", "=", "np", ".", "float", ")", "# [H,W,3] color", "\n", "\n", "# projection color with instance labels", "\n", "self", ".", "proj_inst_label", "=", "np", ".", "zeros", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ")", ",", "\n", "dtype", "=", "np", ".", "int32", ")", "# [H,W]  label", "\n", "self", ".", "proj_inst_color", "=", "np", ".", "zeros", "(", "(", "self", ".", "proj_H", ",", "self", ".", "proj_W", ",", "3", ")", ",", "\n", "dtype", "=", "np", ".", "float", ")", "# [H,W,3] color", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.open_label": [[219, 237], ["numpy.fromfile", "label.reshape.reshape.reshape", "laserscan.SemLaserScan.set_label", "isinstance", "TypeError", "any", "RuntimeError", "filename.endswith", "str", "type"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.set_label", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.glow.GlShader.type"], ["", "def", "open_label", "(", "self", ",", "filename", ")", ":", "\n", "    ", "\"\"\" Open raw scan and fill in attributes\n    \"\"\"", "\n", "# check filename is string", "\n", "if", "not", "isinstance", "(", "filename", ",", "str", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"Filename should be string type, \"", "\n", "\"but was {type}\"", ".", "format", "(", "type", "=", "str", "(", "type", "(", "filename", ")", ")", ")", ")", "\n", "\n", "# check extension is a laserscan", "\n", "", "if", "not", "any", "(", "filename", ".", "endswith", "(", "ext", ")", "for", "ext", "in", "self", ".", "EXTENSIONS_LABEL", ")", ":", "\n", "      ", "raise", "RuntimeError", "(", "\"Filename extension is not valid label file.\"", ")", "\n", "\n", "# if all goes well, open label", "\n", "", "label", "=", "np", ".", "fromfile", "(", "filename", ",", "dtype", "=", "np", ".", "uint32", ")", "\n", "label", "=", "label", ".", "reshape", "(", "(", "-", "1", ")", ")", "\n", "\n", "# set it", "\n", "self", ".", "set_label", "(", "label", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.set_label": [[238, 259], ["isinstance", "TypeError", "print", "print", "ValueError", "laserscan.SemLaserScan.do_label_projection"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.do_label_projection"], ["", "def", "set_label", "(", "self", ",", "label", ")", ":", "\n", "    ", "\"\"\" Set points for label not from file but from np\n    \"\"\"", "\n", "# check label makes sense", "\n", "if", "not", "isinstance", "(", "label", ",", "np", ".", "ndarray", ")", ":", "\n", "      ", "raise", "TypeError", "(", "\"Label should be numpy array\"", ")", "\n", "\n", "# only fill in attribute if the right size", "\n", "", "if", "label", ".", "shape", "[", "0", "]", "==", "self", ".", "points", ".", "shape", "[", "0", "]", ":", "\n", "      ", "self", ".", "sem_label", "=", "label", "&", "0xFFFF", "# semantic label in lower half", "\n", "self", ".", "inst_label", "=", "label", ">>", "16", "# instance id in upper half", "\n", "", "else", ":", "\n", "      ", "print", "(", "\"Points shape: \"", ",", "self", ".", "points", ".", "shape", ")", "\n", "print", "(", "\"Label shape: \"", ",", "label", ".", "shape", ")", "\n", "raise", "ValueError", "(", "\"Scan and Label don't contain same number of points\"", ")", "\n", "\n", "# sanity check", "\n", "", "assert", "(", "(", "self", ".", "sem_label", "+", "(", "self", ".", "inst_label", "<<", "16", ")", "==", "label", ")", ".", "all", "(", ")", ")", "\n", "\n", "if", "self", ".", "project", ":", "\n", "      ", "self", ".", "do_label_projection", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.colorize": [[260, 268], ["laserscan.SemLaserScan.sem_label_color.reshape", "laserscan.SemLaserScan.inst_label_color.reshape"], "methods", ["None"], ["", "", "def", "colorize", "(", "self", ")", ":", "\n", "    ", "\"\"\" Colorize pointcloud with the color of each semantic label\n    \"\"\"", "\n", "self", ".", "sem_label_color", "=", "self", ".", "sem_color_lut", "[", "self", ".", "sem_label", "]", "\n", "self", ".", "sem_label_color", "=", "self", ".", "sem_label_color", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "\n", "self", ".", "inst_label_color", "=", "self", ".", "inst_color_lut", "[", "self", ".", "inst_label", "]", "\n", "self", ".", "inst_label_color", "=", "self", ".", "inst_label_color", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.laserscan.SemLaserScan.do_label_projection": [[269, 280], ["None"], "methods", ["None"], ["", "def", "do_label_projection", "(", "self", ")", ":", "\n", "# only map colors to labels that exist", "\n", "    ", "mask", "=", "self", ".", "proj_idx", ">=", "0", "\n", "\n", "# semantics", "\n", "self", ".", "proj_sem_label", "[", "mask", "]", "=", "self", ".", "sem_label", "[", "self", ".", "proj_idx", "[", "mask", "]", "]", "\n", "self", ".", "proj_sem_color", "[", "mask", "]", "=", "self", ".", "sem_color_lut", "[", "self", ".", "sem_label", "[", "self", ".", "proj_idx", "[", "mask", "]", "]", "]", "\n", "\n", "# instances", "\n", "self", ".", "proj_inst_label", "[", "mask", "]", "=", "self", ".", "inst_label", "[", "self", ".", "proj_idx", "[", "mask", "]", "]", "\n", "self", ".", "proj_inst_color", "[", "mask", "]", "=", "self", ".", "inst_color_lut", "[", "self", ".", "inst_label", "[", "self", ".", "proj_idx", "[", "mask", "]", "]", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.__init__": [[15, 35], ["numpy.array", "numpy.array", "print", "print", "eval_np.PanopticEval.reset", "range"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset"], ["def", "__init__", "(", "self", ",", "\n", "n_classes", ",", "\n", "device", "=", "None", ",", "\n", "ignore", "=", "None", ",", "\n", "offset", "=", "2", "**", "32", ",", "\n", "min_points", "=", "30", ")", ":", "\n", "        ", "self", ".", "n_classes", "=", "n_classes", "\n", "assert", "(", "device", "==", "None", ")", "\n", "self", ".", "ignore", "=", "np", ".", "array", "(", "ignore", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "include", "=", "np", ".", "array", "(", "\n", "[", "n", "for", "n", "in", "range", "(", "self", ".", "n_classes", ")", "if", "n", "not", "in", "self", ".", "ignore", "]", ",", "\n", "dtype", "=", "np", ".", "int64", ")", "\n", "\n", "print", "(", "\"[PANOPTIC EVAL] IGNORE: \"", ",", "self", ".", "ignore", ")", "\n", "print", "(", "\"[PANOPTIC EVAL] INCLUDE: \"", ",", "self", ".", "include", ")", "\n", "\n", "self", ".", "reset", "(", ")", "\n", "self", ".", "offset", "=", "offset", "# largest number of instances in a given scan", "\n", "self", ".", "min_points", "=", "min_points", "# smallest number of points to consider instances in gt", "\n", "self", ".", "eps", "=", "1e-15", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.num_classes": [[36, 38], ["None"], "methods", ["None"], ["", "def", "num_classes", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "n_classes", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.reset": [[39, 49], ["numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.zeros"], "methods", ["None"], ["", "def", "reset", "(", "self", ")", ":", "\n", "# general things", "\n", "# iou stuff", "\n", "        ", "self", ".", "px_iou_conf_matrix", "=", "np", ".", "zeros", "(", "(", "self", ".", "n_classes", ",", "self", ".", "n_classes", ")", ",", "\n", "dtype", "=", "np", ".", "int64", ")", "\n", "# panoptic stuff", "\n", "self", ".", "pan_tp", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_iou", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "double", ")", "\n", "self", ".", "pan_fp", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "self", ".", "pan_fn", "=", "np", ".", "zeros", "(", "self", ".", "n_classes", ",", "dtype", "=", "np", ".", "int64", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.addBatchSemIoU": [[51, 57], ["numpy.stack", "numpy.add.at", "tuple"], "methods", ["None"], ["", "def", "addBatchSemIoU", "(", "self", ",", "x_sem", ",", "y_sem", ")", ":", "\n", "# idxs are labels and predictions", "\n", "        ", "idxs", "=", "np", ".", "stack", "(", "[", "x_sem", ",", "y_sem", "]", ",", "axis", "=", "0", ")", "\n", "\n", "# make confusion matrix (cols = gt, rows = pred)", "\n", "np", ".", "add", ".", "at", "(", "self", ".", "px_iou_conf_matrix", ",", "tuple", "(", "idxs", ")", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.getSemIoUStats": [[58, 72], ["eval_np.PanopticEval.px_iou_conf_matrix.copy().astype", "eval_np.PanopticEval.diagonal", "eval_np.PanopticEval.sum", "eval_np.PanopticEval.sum", "eval_np.PanopticEval.px_iou_conf_matrix.copy"], "methods", ["None"], ["", "def", "getSemIoUStats", "(", "self", ")", ":", "\n", "# clone to avoid modifying the real deal", "\n", "        ", "conf", "=", "self", ".", "px_iou_conf_matrix", ".", "copy", "(", ")", ".", "astype", "(", "np", ".", "double", ")", "\n", "# remove fp from confusion on the ignore classes predictions", "\n", "# points that were predicted of another class, but were ignore", "\n", "# (corresponds to zeroing the cols of those classes, since the predictions", "\n", "# go on the rows)", "\n", "conf", "[", ":", ",", "self", ".", "ignore", "]", "=", "0", "\n", "\n", "# get the clean stats", "\n", "tp", "=", "conf", ".", "diagonal", "(", ")", "\n", "fp", "=", "conf", ".", "sum", "(", "axis", "=", "1", ")", "-", "tp", "\n", "fn", "=", "conf", ".", "sum", "(", "axis", "=", "0", ")", "-", "tp", "\n", "return", "tp", ",", "fp", ",", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.getSemIoU": [[73, 86], ["eval_np.PanopticEval.getSemIoUStats", "numpy.maximum", "intersection.astype", "numpy.maximum.astype", "intersection[].astype", "union[].astype"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.getSemIoUStats"], ["", "def", "getSemIoU", "(", "self", ")", ":", "\n", "        ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getSemIoUStats", "(", ")", "\n", "# print(f\"tp={tp}\")", "\n", "# print(f\"fp={fp}\")", "\n", "# print(f\"fn={fn}\")", "\n", "intersection", "=", "tp", "\n", "union", "=", "tp", "+", "fp", "+", "fn", "\n", "union", "=", "np", ".", "maximum", "(", "union", ",", "self", ".", "eps", ")", "\n", "iou", "=", "intersection", ".", "astype", "(", "np", ".", "double", ")", "/", "union", ".", "astype", "(", "np", ".", "double", ")", "\n", "iou_mean", "=", "(", "intersection", "[", "self", ".", "include", "]", ".", "astype", "(", "np", ".", "double", ")", "/", "\n", "union", "[", "self", ".", "include", "]", ".", "astype", "(", "np", ".", "double", ")", ")", ".", "mean", "(", ")", "\n", "\n", "return", "iou_mean", ",", "iou", "# returns \"iou mean\", \"iou per class\" ALL CLASSES", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.getSemAcc": [[87, 95], ["eval_np.PanopticEval.getSemIoUStats", "tp.sum", "numpy.maximum", "tp[].sum", "fp[].sum", "tp.sum.astype", "numpy.maximum.astype"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.getSemIoUStats"], ["", "def", "getSemAcc", "(", "self", ")", ":", "\n", "        ", "tp", ",", "fp", ",", "fn", "=", "self", ".", "getSemIoUStats", "(", ")", "\n", "total_tp", "=", "tp", ".", "sum", "(", ")", "\n", "total", "=", "tp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "+", "fp", "[", "self", ".", "include", "]", ".", "sum", "(", ")", "\n", "total", "=", "np", ".", "maximum", "(", "total", ",", "self", ".", "eps", ")", "\n", "acc_mean", "=", "total_tp", ".", "astype", "(", "np", ".", "double", ")", "/", "total", ".", "astype", "(", "np", ".", "double", ")", "\n", "\n", "return", "acc_mean", "# returns \"acc mean\"", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.addBatchPanoptic": [[100, 177], ["print", "print", "numpy.unique", "numpy.array", "numpy.unique", "numpy.array", "numpy.logical_and", "numpy.unique", "numpy.array", "numpy.array", "numpy.sum", "numpy.sum", "numpy.sum", "numpy.sum", "cl.item", "x_inst_in_cl_mask.astype", "y_inst_in_cl_mask.astype", "intersections.astype", "unions.astype", "numpy.logical_and", "numpy.logical_and", "enumerate", "enumerate"], "methods", ["None"], ["", "def", "addBatchPanoptic", "(", "self", ",", "x_sem_row", ",", "x_inst_row", ",", "y_sem_row", ",", "y_inst_row", ")", ":", "\n", "# make sure instances are not zeros (it messes with my approach)", "\n", "        ", "x_inst_row", "=", "x_inst_row", "+", "1", "\n", "y_inst_row", "=", "y_inst_row", "+", "1", "\n", "\n", "# only interested in points that are outside the void area (not in excluded classes)", "\n", "for", "cl", "in", "self", ".", "ignore", ":", "\n", "# make a mask for this class", "\n", "            ", "gt_not_in_excl_mask", "=", "y_sem_row", "!=", "cl", "\n", "# remove all other points", "\n", "x_sem_row", "=", "x_sem_row", "[", "gt_not_in_excl_mask", "]", "\n", "y_sem_row", "=", "y_sem_row", "[", "gt_not_in_excl_mask", "]", "\n", "x_inst_row", "=", "x_inst_row", "[", "gt_not_in_excl_mask", "]", "\n", "y_inst_row", "=", "y_inst_row", "[", "gt_not_in_excl_mask", "]", "\n", "\n", "# first step is to count intersections > 0.5 IoU for each class (except the ignored ones)", "\n", "", "for", "cl", "in", "self", ".", "include", ":", "\n", "            ", "print", "(", "\"*\"", "*", "80", ")", "\n", "print", "(", "\"CLASS\"", ",", "cl", ".", "item", "(", ")", ")", "\n", "# get a class mask", "\n", "x_inst_in_cl_mask", "=", "x_sem_row", "==", "cl", "\n", "y_inst_in_cl_mask", "=", "y_sem_row", "==", "cl", "\n", "\n", "# get instance points in class (makes outside stuff 0)", "\n", "x_inst_in_cl", "=", "x_inst_row", "*", "x_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "y_inst_in_cl", "=", "y_inst_row", "*", "y_inst_in_cl_mask", ".", "astype", "(", "np", ".", "int64", ")", "\n", "\n", "# generate the areas for each unique instance prediction", "\n", "unique_pred", ",", "counts_pred", "=", "np", ".", "unique", "(", "x_inst_in_cl", "[", "x_inst_in_cl", ">", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "id2idx_pred", "=", "{", "id", ":", "idx", "for", "idx", ",", "id", "in", "enumerate", "(", "unique_pred", ")", "}", "\n", "matched_pred", "=", "np", ".", "array", "(", "[", "False", "]", "*", "unique_pred", ".", "shape", "[", "0", "]", ")", "\n", "# print(\"Unique predictions:\", unique_pred)", "\n", "\n", "# generate the areas for each unique instance gt_np", "\n", "unique_gt", ",", "counts_gt", "=", "np", ".", "unique", "(", "y_inst_in_cl", "[", "y_inst_in_cl", ">", "0", "]", ",", "return_counts", "=", "True", ")", "\n", "# print('unique_gt: ', unique_gt)", "\n", "# print('counts_gt: ', counts_gt)", "\n", "id2idx_gt", "=", "{", "id", ":", "idx", "for", "idx", ",", "id", "in", "enumerate", "(", "unique_gt", ")", "}", "\n", "matched_gt", "=", "np", ".", "array", "(", "[", "False", "]", "*", "unique_gt", ".", "shape", "[", "0", "]", ")", "\n", "# print('id2idx_gt: ', id2idx_gt)", "\n", "# print('matched_gt: ', matched_gt)", "\n", "# print(\"Unique ground truth:\", unique_gt)", "\n", "# for each semantic class, count instance labels and the num of points, map the instance labels to 0-num_of_instance", "\n", "\n", "# generate intersection using offset", "\n", "valid_combos", "=", "np", ".", "logical_and", "(", "x_inst_in_cl", ">", "0", ",", "y_inst_in_cl", ">", "0", ")", "# get the points that is in the ground_truth sem class and also the pred sem class", "\n", "offset_combo", "=", "x_inst_in_cl", "[", "valid_combos", "]", "+", "self", ".", "offset", "*", "y_inst_in_cl", "[", "valid_combos", "]", "# lower half is the pred label, higher half is the gt label", "\n", "unique_combo", ",", "counts_combo", "=", "np", ".", "unique", "(", "offset_combo", ",", "return_counts", "=", "True", ")", "# the intersection can be obtained, and the labels can be inconsistent", "\n", "\n", "# generate an intersection map", "\n", "# count the intersections with over 0.5 IoU as TP", "\n", "gt_labels", "=", "unique_combo", "//", "self", ".", "offset", "\n", "pred_labels", "=", "unique_combo", "%", "self", ".", "offset", "\n", "gt_areas", "=", "np", ".", "array", "(", "[", "counts_gt", "[", "id2idx_gt", "[", "id", "]", "]", "for", "id", "in", "gt_labels", "]", ")", "\n", "pred_areas", "=", "np", ".", "array", "(", "\n", "[", "counts_pred", "[", "id2idx_pred", "[", "id", "]", "]", "for", "id", "in", "pred_labels", "]", ")", "\n", "intersections", "=", "counts_combo", "\n", "unions", "=", "gt_areas", "+", "pred_areas", "-", "intersections", "\n", "ious", "=", "intersections", ".", "astype", "(", "np", ".", "float", ")", "/", "unions", ".", "astype", "(", "np", ".", "float", ")", "\n", "\n", "tp_indexes", "=", "ious", ">", "0.5", "\n", "self", ".", "pan_tp", "[", "cl", "]", "+=", "np", ".", "sum", "(", "tp_indexes", ")", "\n", "self", ".", "pan_iou", "[", "cl", "]", "+=", "np", ".", "sum", "(", "ious", "[", "tp_indexes", "]", ")", "\n", "\n", "matched_gt", "[", "[", "id2idx_gt", "[", "id", "]", "for", "id", "in", "gt_labels", "[", "tp_indexes", "]", "]", "]", "=", "True", "\n", "matched_pred", "[", "[", "id2idx_pred", "[", "id", "]", "\n", "for", "id", "in", "pred_labels", "[", "tp_indexes", "]", "]", "]", "=", "True", "\n", "\n", "# count the FN", "\n", "self", ".", "pan_fn", "[", "cl", "]", "+=", "np", ".", "sum", "(", "\n", "np", ".", "logical_and", "(", "counts_gt", ">=", "self", ".", "min_points", ",", "\n", "matched_gt", "==", "False", ")", ")", "\n", "\n", "# count the FP", "\n", "self", ".", "pan_fp", "[", "cl", "]", "+=", "np", ".", "sum", "(", "\n", "np", ".", "logical_and", "(", "counts_pred", ">=", "self", ".", "min_points", ",", "\n", "matched_pred", "==", "False", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.getPQ": [[178, 193], ["sq_all[].mean", "rq_all[].mean", "pq_all[].mean", "eval_np.PanopticEval.pan_iou.astype", "numpy.maximum", "eval_np.PanopticEval.pan_tp.astype", "numpy.maximum", "eval_np.PanopticEval.pan_tp.astype", "eval_np.PanopticEval.pan_tp.astype", "eval_np.PanopticEval.pan_fn.astype", "eval_np.PanopticEval.pan_fp.astype"], "methods", ["None"], ["", "", "def", "getPQ", "(", "self", ")", ":", "\n", "# first calculate for all classes", "\n", "        ", "sq_all", "=", "self", ".", "pan_iou", ".", "astype", "(", "np", ".", "double", ")", "/", "np", ".", "maximum", "(", "\n", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", ",", "self", ".", "eps", ")", "\n", "rq_all", "=", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", "/", "np", ".", "maximum", "(", "\n", "self", ".", "pan_tp", ".", "astype", "(", "np", ".", "double", ")", "+", "0.5", "*", "self", ".", "pan_fp", ".", "astype", "(", "np", ".", "double", ")", "\n", "+", "0.5", "*", "self", ".", "pan_fn", ".", "astype", "(", "np", ".", "double", ")", ",", "self", ".", "eps", ")", "\n", "pq_all", "=", "sq_all", "*", "rq_all", "\n", "\n", "# then do the REAL mean (no ignored classes)", "\n", "SQ", "=", "sq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "\n", "RQ", "=", "rq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "\n", "PQ", "=", "pq_all", "[", "self", ".", "include", "]", ".", "mean", "(", ")", "\n", "\n", "return", "PQ", ",", "SQ", ",", "RQ", ",", "pq_all", ",", "sq_all", ",", "rq_all", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.addBatch": [[197, 205], ["eval_np.PanopticEval.addBatchSemIoU", "eval_np.PanopticEval.addBatchPanoptic"], "methods", ["home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.addBatchSemIoU", "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.eval_np.PanopticEval.addBatchPanoptic"], ["", "def", "addBatch", "(", "self", ",", "x_sem", ",", "x_inst", ",", "y_sem", ",", "y_inst", ")", ":", "# x=preds, y=targets", "\n", "        ", "''' IMPORTANT: Inputs must be batched. Either [N,H,W], or [N, P]\n    '''", "\n", "# add to IoU calculation (for checking purposes)", "\n", "self", ".", "addBatchSemIoU", "(", "x_sem", ",", "y_sem", ")", "\n", "\n", "# now do the panoptic stuff", "\n", "self", ".", "addBatchPanoptic", "(", "x_sem", ",", "x_inst", ",", "y_sem", ",", "y_inst", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.kxhit_SG_PR.auxiliary.filelist2files.pack": [[11, 21], ["array.reshape.reshape", "numpy.array"], "function", ["None"], ["def", "pack", "(", "array", ")", ":", "\n", "  ", "\"\"\" convert a boolean array into a bitwise array. \"\"\"", "\n", "array", "=", "array", ".", "reshape", "(", "(", "-", "1", ")", ")", "\n", "\n", "#compressing bit flags.", "\n", "# yapf: disable", "\n", "compressed", "=", "array", "[", ":", ":", "8", "]", "<<", "7", "|", "array", "[", "1", ":", ":", "8", "]", "<<", "6", "|", "array", "[", "2", ":", ":", "8", "]", "<<", "5", "|", "array", "[", "3", ":", ":", "8", "]", "<<", "4", "|", "array", "[", "4", ":", ":", "8", "]", "<<", "3", "|", "array", "[", "5", ":", ":", "8", "]", "<<", "2", "|", "array", "[", "6", ":", ":", "8", "]", "<<", "1", "|", "array", "[", "7", ":", ":", "8", "]", "\n", "# yapf: enable", "\n", "\n", "return", "np", ".", "array", "(", "compressed", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "\n"]]}