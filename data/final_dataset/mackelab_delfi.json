{"home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.loss": [[24, 50], ["numpy.array", "numpy.array", "matplotlib.subplots", "ax.semilogx", "ax.set_xlabel", "ax.set_ylabel", "numpy.where", "len", "print", "len"], "function", ["None"], ["", "", "def", "loss", "(", "losses", ",", "key", "=", "'trn'", ",", "loss_clipping", "=", "1000.", ",", "title", "=", "''", ")", ":", "\n", "    ", "\"\"\"Given an info dict, plot loss\"\"\"", "\n", "\n", "x", "=", "np", ".", "array", "(", "losses", "[", "key", "+", "'_iter'", "]", ")", "\n", "y", "=", "np", ".", "array", "(", "losses", "[", "key", "+", "'_val'", "]", ")", "\n", "\n", "clip_idx", "=", "np", ".", "where", "(", "y", ">", "loss_clipping", ")", "[", "0", "]", "\n", "if", "len", "(", "clip_idx", ")", ">", "0", ":", "\n", "        ", "print", "(", "\n", "'warning: loss exceeds threshold of {:.2f} in total {} time(s); values will be clipped'", ".", "format", "(", "\n", "loss_clipping", ",", "\n", "len", "(", "clip_idx", ")", ")", ")", "\n", "\n", "", "y", "[", "clip_idx", "]", "=", "loss_clipping", "\n", "\n", "options", "=", "{", "}", "\n", "options", "[", "'title'", "]", "=", "title", "\n", "options", "[", "'xlabel'", "]", "=", "r'iteration'", "\n", "options", "[", "'ylabel'", "]", "=", "r'loss'", "\n", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ")", "\n", "ax", ".", "semilogx", "(", "x", ",", "y", ",", "'b'", ")", "\n", "ax", ".", "set_xlabel", "(", "options", "[", "'xlabel'", "]", ")", "\n", "ax", ".", "set_ylabel", "(", "options", "[", "'ylabel'", "]", ")", "\n", "\n", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.dist": [[52, 67], ["matplotlib.figure", "plt.figure.add_subplot", "len", "fig.add_subplot.hist", "fig.add_subplot.set_xlabel", "fig.add_subplot.set_ylabel", "fig.add_subplot.set_title", "int", "numpy.sqrt"], "function", ["None"], ["", "def", "dist", "(", "dist", ",", "title", "=", "''", ")", ":", "\n", "    ", "\"\"\"Given dist, plot histogram\"\"\"", "\n", "options", "=", "{", "}", "\n", "options", "[", "'title'", "]", "=", "title", "\n", "options", "[", "'xlabel'", "]", "=", "r'bin'", "\n", "options", "[", "'ylabel'", "]", "=", "r'distance'", "\n", "\n", "fig", "=", "plt", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "111", ")", "\n", "n_samples", "=", "len", "(", "dist", ")", "\n", "ax", ".", "hist", "(", "dist", ",", "bins", "=", "int", "(", "np", ".", "sqrt", "(", "n_samples", ")", ")", ")", "\n", "ax", ".", "set_xlabel", "(", "options", "[", "'xlabel'", "]", ")", "\n", "ax", ".", "set_ylabel", "(", "options", "[", "'ylabel'", "]", ")", "\n", "ax", ".", "set_title", "(", "options", "[", "'title'", "]", ")", "\n", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.info": [[69, 88], ["info.items"], "function", ["None"], ["", "def", "info", "(", "info", ",", "html", "=", "False", ",", "title", "=", "None", ")", ":", "\n", "    ", "\"\"\"Given info dict, produce info text\"\"\"", "\n", "if", "title", "is", "None", ":", "\n", "        ", "infotext", "=", "u''", "\n", "", "else", ":", "\n", "        ", "if", "html", ":", "\n", "            ", "infotext", "=", "u'<b>{}</b><br>'", ".", "format", "(", "title", ")", "\n", "", "else", ":", "\n", "            ", "infotext", "=", "u'{}\\n'", ".", "format", "(", "title", ")", "\n", "\n", "", "", "for", "key", ",", "value", "in", "info", ".", "items", "(", ")", ":", "\n", "        ", "if", "key", "not", "in", "[", "'losses'", "]", ":", "\n", "            ", "infotext", "+=", "u'{} : {}'", ".", "format", "(", "key", ",", "value", ")", "\n", "if", "html", ":", "\n", "                ", "infotext", "+=", "'<br>'", "\n", "", "else", ":", "\n", "                ", "infotext", "+=", "'\\n'", "\n", "\n", "", "", "", "return", "infotext", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.probs2contours": [[90, 132], ["numpy.asarray", "probs.flatten.flatten", "idx_sort.argsort", "probs.flatten.cumsum", "numpy.ones_like", "numpy.reshape", "numpy.all", "numpy.all", "probs.flatten.argsort", "numpy.sort"], "function", ["None"], ["", "def", "probs2contours", "(", "probs", ",", "levels", ")", ":", "\n", "    ", "\"\"\"Takes an array of probabilities and produces an array of contours at specified percentile levels\n\n    Parameters\n    ----------\n    probs : array\n        Probability array. doesn't have to sum to 1, but it is assumed it contains all the mass\n    levels : list\n        Percentile levels, have to be in [0.0, 1.0]\n\n    Return\n    ------\n    Array of same shape as probs with percentile labels\n    \"\"\"", "\n", "# make sure all contour levels are in [0.0, 1.0]", "\n", "levels", "=", "np", ".", "asarray", "(", "levels", ")", "\n", "assert", "np", ".", "all", "(", "levels", "<=", "1.0", ")", "and", "np", ".", "all", "(", "levels", ">=", "0.0", ")", "\n", "\n", "# flatten probability array", "\n", "shape", "=", "probs", ".", "shape", "\n", "probs", "=", "probs", ".", "flatten", "(", ")", "\n", "\n", "# sort probabilities in descending order", "\n", "idx_sort", "=", "probs", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "idx_unsort", "=", "idx_sort", ".", "argsort", "(", ")", "\n", "probs", "=", "probs", "[", "idx_sort", "]", "\n", "\n", "# cumulative probabilities", "\n", "cum_probs", "=", "probs", ".", "cumsum", "(", ")", "\n", "cum_probs", "/=", "cum_probs", "[", "-", "1", "]", "\n", "\n", "# create contours at levels", "\n", "contours", "=", "np", ".", "ones_like", "(", "cum_probs", ")", "\n", "levels", "=", "np", ".", "sort", "(", "levels", ")", "[", ":", ":", "-", "1", "]", "\n", "for", "level", "in", "levels", ":", "\n", "        ", "contours", "[", "cum_probs", "<=", "level", "]", "=", "level", "\n", "\n", "# make sure contours have the order and the shape of the original", "\n", "# probability array", "\n", "", "contours", "=", "np", ".", "reshape", "(", "contours", "[", "idx_unsort", "]", ",", "shape", ")", "\n", "\n", "return", "contours", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.plot_pdf": [[134, 370], ["numpy.min", "numpy.max", "numpy.asarray", "numpy.concatenate", "numpy.asarray", "matplotlib.subplots", "numpy.linspace", "zip", "ax.reshape.set_xlim", "ax.reshape.set_ylim", "matplotlib.subplots", "ax.reshape.reshape", "range", "numpy.tile", "ax.reshape.hist", "ax.reshape.vlines", "ax.reshape.get_yaxis().set_tick_params", "ax.reshape.get_xaxis().set_tick_params", "ax.reshape.set_xticks", "ax.reshape.set_yticks", "ax.reshape.xaxis.set_major_formatter", "ax.reshape.yaxis.set_major_formatter", "ax.reshape.get_xaxis().set_ticks", "ax.reshape.get_yaxis().set_ticks", "range", "np.min.reshape", "np.max.reshape", "pdf.eval", "ax.reshape.plot", "numpy.linspace", "numpy.linspace", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "min", "min", "ax.reshape.get_ylim", "ax.reshape.get_ylim", "ax.reshape.get_yaxis", "ax.reshape.get_xaxis", "min", "max", "ax.reshape.get_xaxis", "ax.reshape.get_yaxis", "numpy.linspace", "zip", "zip", "ax[].set_xlim", "ax[].set_ylim", "ax[].get_xlim", "ax[].get_ylim", "ax[].set_aspect", "numpy.linspace", "numpy.linspace", "numpy.meshgrid", "numpy.concatenate", "pdf.eval", "pdf.eval.reshape", "ax[].set_xlim", "ax[].set_ylim", "ax[].get_xaxis().set_ticks", "ax[].get_yaxis().set_ticks", "ax[].set_axis_off", "ax[].get_xlim", "ax[].get_ylim", "ax[].set_aspect", "ax[].hist", "ax[].vlines", "ax[].get_yaxis().set_tick_params", "ax[].get_xaxis().set_tick_params", "ax[].set_xticks", "ax[].set_yticks", "ax[].xaxis.set_major_formatter", "ax[].yaxis.set_major_formatter", "ax[].get_xaxis().set_ticks", "ax[].get_yaxis().set_ticks", "ax[].set_xlabel", "ax[].set_xlabel", "ax[].text", "matplotlib.text", "ax[].get_yaxis().set_visible", "ax[].get_xaxis().set_visible", "ax[].set_axis_off", "numpy.histogram2d", "ax[].imshow", "list", "ax[].contour", "ax[].imshow", "ax[].plot", "ax[].text", "pdf.eval", "pdf.eval", "ax[].plot", "numpy.linspace", "numpy.linspace", "matplotlib.ticker.FormatStrFormatter", "matplotlib.ticker.FormatStrFormatter", "X.reshape", "Y.reshape", "viz.probs2contours", "ax[].get_xaxis", "ax[].get_yaxis", "ax[].get_ylim", "ax[].get_ylim", "ax[].get_yaxis", "ax[].get_xaxis", "ax[].get_xaxis", "ax[].get_yaxis", "ax[].get_yaxis", "ax[].get_xaxis", "max", "numpy.abs", "numpy.abs", "numpy.abs", "numpy.abs", "max", "max"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.probs2contours"], ["", "def", "plot_pdf", "(", "pdf1", ",", "lims", "=", "None", ",", "pdf2", "=", "None", ",", "gt", "=", "None", ",", "contours", "=", "False", ",", "levels", "=", "(", "0.68", ",", "0.95", ")", ",", "\n", "resolution", "=", "500", ",", "labels_params", "=", "None", ",", "ticks", "=", "False", ",", "diag_only", "=", "False", ",", "\n", "diag_only_cols", "=", "4", ",", "diag_only_rows", "=", "4", ",", "figsize", "=", "(", "5", ",", "5", ")", ",", "fontscale", "=", "1", ",", "\n", "partial", "=", "False", ",", "samples", "=", "None", ",", "col1", "=", "'k'", ",", "col2", "=", "'b'", ",", "col3", "=", "'g'", ")", ":", "\n", "    ", "\"\"\"Plots marginals of a pdf, for each variable and pair of variables.\n\n    Parameters\n    ----------\n    pdf1 : object\n    lims : array\n    pdf2 : object (or None)\n        If not none, visualizes pairwise marginals for second pdf on lower diagonal\n    contours : bool\n    levels : tuple\n        For contours\n    resolution\n    labels_params : array of strings\n    ticks: bool\n        If True, includes ticks in plots\n    diag_only : bool\n    diag_only_cols : int\n        Number of grid columns if only the diagonal is plotted\n    diag_only_rows : int\n        Number of grid rows if only the diagonal is plotted\n    fontscale: int\n    partial: bool\n        If True, plots partial posterior with at the most 3 parameters.\n        Only available if `diag_only` is False\n    samples: array\n        If given, samples of a distribution are plotted along `pdf`.\n        If given, `pdf` is plotted with default `levels` (0.68, 0.95), if provided `levels` is None.\n        If given, `lims` is overwritten and taken to be the respective\n        limits of the samples in each dimension.\n    col1 : str\n        color 1\n    col2 : str\n        color 2\n    col3 : str\n        color 3 (for pdf2 if provided)\n    \"\"\"", "\n", "\n", "pdfs", "=", "(", "pdf1", ",", "pdf2", ")", "\n", "colrs", "=", "(", "col2", ",", "col3", ")", "\n", "\n", "if", "not", "(", "pdf1", "is", "None", "or", "pdf2", "is", "None", ")", ":", "\n", "        ", "assert", "pdf1", ".", "ndim", "==", "pdf2", ".", "ndim", "\n", "\n", "", "if", "samples", "is", "not", "None", ":", "\n", "        ", "contours", "=", "True", "\n", "if", "levels", "is", "None", ":", "\n", "            ", "levels", "=", "(", "0.68", ",", "0.95", ")", "\n", "\n", "", "", "if", "samples", "is", "not", "None", "and", "lims", "is", "None", ":", "\n", "        ", "lims_min", "=", "np", ".", "min", "(", "samples", ",", "axis", "=", "1", ")", "\n", "lims_max", "=", "np", ".", "max", "(", "samples", ",", "axis", "=", "1", ")", "\n", "lims", "=", "np", ".", "asarray", "(", "lims", ")", "\n", "lims", "=", "np", ".", "concatenate", "(", "\n", "(", "lims_min", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "lims_max", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "        ", "lims", "=", "np", ".", "asarray", "(", "lims", ")", "\n", "lims", "=", "np", ".", "tile", "(", "lims", ",", "[", "pdf1", ".", "ndim", ",", "1", "]", ")", "if", "lims", ".", "ndim", "==", "1", "else", "lims", "\n", "\n", "", "if", "pdf1", ".", "ndim", "==", "1", ":", "\n", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "facecolor", "=", "'white'", ",", "figsize", "=", "figsize", ")", "\n", "\n", "if", "samples", "is", "not", "None", ":", "\n", "            ", "ax", ".", "hist", "(", "samples", "[", "i", ",", ":", "]", ",", "bins", "=", "100", ",", "density", "=", "True", ",", "\n", "color", "=", "col1", ",", "\n", "edgecolor", "=", "col1", ")", "\n", "\n", "", "xx", "=", "np", ".", "linspace", "(", "lims", "[", "0", ",", "0", "]", ",", "lims", "[", "0", ",", "1", "]", ",", "resolution", ")", "\n", "\n", "for", "pdf", ",", "col", "in", "zip", "(", "pdfs", ",", "colrs", ")", ":", "\n", "            ", "if", "pdf", "is", "not", "None", ":", "\n", "                ", "pp", "=", "pdf", ".", "eval", "(", "xx", "[", ":", ",", "np", ".", "newaxis", "]", ",", "log", "=", "False", ")", "\n", "ax", ".", "plot", "(", "xx", ",", "pp", ",", "color", "=", "col", ")", "\n", "", "", "ax", ".", "set_xlim", "(", "lims", "[", "0", "]", ")", "\n", "ax", ".", "set_ylim", "(", "[", "0", ",", "ax", ".", "get_ylim", "(", ")", "[", "1", "]", "]", ")", "\n", "if", "gt", "is", "not", "None", ":", "\n", "            ", "ax", ".", "vlines", "(", "gt", ",", "0", ",", "ax", ".", "get_ylim", "(", ")", "[", "1", "]", ",", "color", "=", "'r'", ")", "\n", "\n", "", "if", "ticks", ":", "\n", "            ", "ax", ".", "get_yaxis", "(", ")", ".", "set_tick_params", "(", "which", "=", "'both'", ",", "direction", "=", "'out'", ")", "\n", "ax", ".", "get_xaxis", "(", ")", ".", "set_tick_params", "(", "which", "=", "'both'", ",", "direction", "=", "'out'", ")", "\n", "ax", ".", "set_xticks", "(", "np", ".", "linspace", "(", "lims", "[", "0", ",", "0", "]", ",", "lims", "[", "0", ",", "1", "]", ",", "2", ")", ")", "\n", "ax", ".", "set_yticks", "(", "np", ".", "linspace", "(", "min", "(", "pp", ")", ",", "max", "(", "pp", ")", ",", "2", ")", ")", "\n", "ax", ".", "xaxis", ".", "set_major_formatter", "(", "mpl", ".", "ticker", ".", "FormatStrFormatter", "(", "'%.1f'", ")", ")", "\n", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "mpl", ".", "ticker", ".", "FormatStrFormatter", "(", "'%.1f'", ")", ")", "\n", "", "else", ":", "\n", "            ", "ax", ".", "get_xaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "ax", ".", "get_yaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "\n", "        ", "if", "not", "diag_only", ":", "\n", "            ", "if", "partial", ":", "\n", "                ", "rows", "=", "min", "(", "3", ",", "pdf1", ".", "ndim", ")", "\n", "cols", "=", "min", "(", "3", ",", "pdf1", ".", "ndim", ")", "\n", "", "else", ":", "\n", "                ", "rows", "=", "pdf1", ".", "ndim", "\n", "cols", "=", "pdf1", ".", "ndim", "\n", "", "", "else", ":", "\n", "            ", "cols", "=", "diag_only_cols", "\n", "rows", "=", "diag_only_rows", "\n", "r", "=", "0", "\n", "c", "=", "-", "1", "\n", "\n", "", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "rows", ",", "cols", ",", "facecolor", "=", "'white'", ",", "figsize", "=", "figsize", ")", "\n", "ax", "=", "ax", ".", "reshape", "(", "rows", ",", "cols", ")", "\n", "\n", "for", "i", "in", "range", "(", "rows", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "cols", ")", ":", "\n", "\n", "                ", "if", "i", "==", "j", ":", "\n", "                    ", "if", "samples", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "hist", "(", "samples", "[", "i", ",", ":", "]", ",", "bins", "=", "100", ",", "density", "=", "True", ",", "\n", "color", "=", "col1", ",", "\n", "edgecolor", "=", "col1", ")", "\n", "", "xx", "=", "np", ".", "linspace", "(", "lims", "[", "i", ",", "0", "]", ",", "lims", "[", "i", ",", "1", "]", ",", "resolution", ")", "\n", "\n", "for", "pdf", ",", "col", "in", "zip", "(", "pdfs", ",", "colrs", ")", ":", "\n", "                        ", "if", "pdf", "is", "not", "None", ":", "\n", "                            ", "pp", "=", "pdf", ".", "eval", "(", "xx", ",", "ii", "=", "[", "i", "]", ",", "log", "=", "False", ")", "\n", "\n", "if", "diag_only", ":", "\n", "                                ", "c", "+=", "1", "\n", "", "else", ":", "\n", "                                ", "r", "=", "i", "\n", "c", "=", "j", "\n", "\n", "", "", "", "for", "pdf", ",", "col", "in", "zip", "(", "pdfs", ",", "colrs", ")", ":", "\n", "                        ", "if", "pdf", "is", "not", "None", ":", "\n", "                            ", "pp", "=", "pdf", ".", "eval", "(", "xx", ",", "ii", "=", "[", "i", "]", ",", "log", "=", "False", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "plot", "(", "xx", ",", "pp", ",", "color", "=", "col", ")", "\n", "\n", "", "", "ax", "[", "r", ",", "c", "]", ".", "set_xlim", "(", "lims", "[", "i", "]", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "set_ylim", "(", "[", "0", ",", "ax", "[", "r", ",", "c", "]", ".", "get_ylim", "(", ")", "[", "1", "]", "]", ")", "\n", "\n", "if", "gt", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "r", ",", "c", "]", ".", "vlines", "(", "\n", "gt", "[", "i", "]", ",", "0", ",", "ax", "[", "r", ",", "c", "]", ".", "get_ylim", "(", ")", "[", "1", "]", ",", "color", "=", "'r'", ")", "\n", "\n", "", "if", "ticks", ":", "\n", "                        ", "ax", "[", "r", ",", "c", "]", ".", "get_yaxis", "(", ")", ".", "set_tick_params", "(", "\n", "which", "=", "'both'", ",", "direction", "=", "'out'", ",", "labelsize", "=", "fontscale", "*", "15", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "get_xaxis", "(", ")", ".", "set_tick_params", "(", "\n", "which", "=", "'both'", ",", "direction", "=", "'out'", ",", "labelsize", "=", "fontscale", "*", "15", ")", "\n", "#                         ax[r, c].locator_params(nbins=3)", "\n", "ax", "[", "r", ",", "c", "]", ".", "set_xticks", "(", "np", ".", "linspace", "(", "\n", "lims", "[", "i", ",", "0", "]", "+", "0.15", "*", "np", ".", "abs", "(", "lims", "[", "i", ",", "0", "]", "-", "lims", "[", "j", ",", "1", "]", ")", ",", "lims", "[", "j", ",", "1", "]", "-", "0.15", "*", "np", ".", "abs", "(", "lims", "[", "i", ",", "0", "]", "-", "lims", "[", "j", ",", "1", "]", ")", ",", "2", ")", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "set_yticks", "(", "np", ".", "linspace", "(", "0", "+", "0.15", "*", "np", ".", "abs", "(", "0", "-", "max", "(", "pp", ")", ")", ",", "max", "(", "pp", ")", "-", "0.15", "*", "np", ".", "abs", "(", "0", "-", "max", "(", "pp", ")", ")", ",", "2", ")", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "xaxis", ".", "set_major_formatter", "(", "\n", "mpl", ".", "ticker", ".", "FormatStrFormatter", "(", "'%.1f'", ")", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "yaxis", ".", "set_major_formatter", "(", "\n", "mpl", ".", "ticker", ".", "FormatStrFormatter", "(", "'%.1f'", ")", ")", "\n", "", "else", ":", "\n", "                        ", "ax", "[", "r", ",", "c", "]", ".", "get_xaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "get_yaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "\n", "", "if", "labels_params", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "r", ",", "c", "]", ".", "set_xlabel", "(", "\n", "labels_params", "[", "i", "]", ",", "fontsize", "=", "fontscale", "*", "20", ")", "\n", "", "else", ":", "\n", "                        ", "ax", "[", "r", ",", "c", "]", ".", "set_xlabel", "(", "[", "]", ")", "\n", "\n", "", "x0", ",", "x1", "=", "ax", "[", "r", ",", "c", "]", ".", "get_xlim", "(", ")", "\n", "y0", ",", "y1", "=", "ax", "[", "r", ",", "c", "]", ".", "get_ylim", "(", ")", "\n", "ax", "[", "r", ",", "c", "]", ".", "set_aspect", "(", "(", "x1", "-", "x0", ")", "/", "(", "y1", "-", "y0", ")", ")", "\n", "\n", "if", "partial", "and", "i", "==", "rows", "-", "1", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "text", "(", "x1", "+", "(", "x1", "-", "x0", ")", "/", "6.", ",", "(", "y0", "+", "y1", ")", "/", "\n", "2.", ",", "'...'", ",", "fontsize", "=", "fontscale", "*", "25", ")", "\n", "plt", ".", "text", "(", "x1", "+", "(", "x1", "-", "x0", ")", "/", "8.4", ",", "y0", "-", "(", "y1", "-", "y0", ")", "/", "\n", "6.", ",", "'...'", ",", "fontsize", "=", "fontscale", "*", "25", ",", "rotation", "=", "-", "45", ")", "\n", "\n", "", "", "else", ":", "\n", "                    ", "if", "diag_only", ":", "\n", "                        ", "continue", "\n", "\n", "", "if", "i", "<", "j", ":", "\n", "                        ", "pdf", "=", "pdfs", "[", "0", "]", "\n", "", "else", ":", "\n", "                        ", "pdf", "=", "pdfs", "[", "1", "]", "\n", "\n", "", "if", "pdf", "is", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "get_yaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "get_xaxis", "(", ")", ".", "set_visible", "(", "False", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "set_axis_off", "(", ")", "\n", "continue", "\n", "\n", "", "if", "samples", "is", "not", "None", ":", "\n", "                        ", "H", ",", "xedges", ",", "yedges", "=", "np", ".", "histogram2d", "(", "\n", "samples", "[", "i", ",", ":", "]", ",", "samples", "[", "j", ",", ":", "]", ",", "bins", "=", "30", ",", "range", "=", "[", "\n", "[", "lims", "[", "i", ",", "0", "]", ",", "lims", "[", "i", ",", "1", "]", "]", ",", "[", "lims", "[", "j", ",", "0", "]", ",", "lims", "[", "j", ",", "1", "]", "]", "]", ",", "density", "=", "True", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "imshow", "(", "H", ",", "origin", "=", "'lower'", ",", "extent", "=", "[", "\n", "yedges", "[", "0", "]", ",", "yedges", "[", "-", "1", "]", ",", "xedges", "[", "0", "]", ",", "xedges", "[", "-", "1", "]", "]", ")", "\n", "\n", "", "xx", "=", "np", ".", "linspace", "(", "lims", "[", "i", ",", "0", "]", ",", "lims", "[", "i", ",", "1", "]", ",", "resolution", ")", "\n", "yy", "=", "np", ".", "linspace", "(", "lims", "[", "j", ",", "0", "]", ",", "lims", "[", "j", ",", "1", "]", ",", "resolution", ")", "\n", "X", ",", "Y", "=", "np", ".", "meshgrid", "(", "xx", ",", "yy", ")", "\n", "xy", "=", "np", ".", "concatenate", "(", "\n", "[", "X", ".", "reshape", "(", "[", "-", "1", ",", "1", "]", ")", ",", "Y", ".", "reshape", "(", "[", "-", "1", ",", "1", "]", ")", "]", ",", "axis", "=", "1", ")", "\n", "pp", "=", "pdf", ".", "eval", "(", "xy", ",", "ii", "=", "[", "i", ",", "j", "]", ",", "log", "=", "False", ")", "\n", "pp", "=", "pp", ".", "reshape", "(", "list", "(", "X", ".", "shape", ")", ")", "\n", "if", "contours", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "contour", "(", "Y", ",", "X", ",", "probs2contours", "(", "\n", "pp", ",", "levels", ")", ",", "levels", ",", "colors", "=", "(", "'w'", ",", "'y'", ")", ")", "\n", "", "else", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "imshow", "(", "pp", ".", "T", ",", "origin", "=", "'lower'", ",", "\n", "extent", "=", "[", "lims", "[", "j", ",", "0", "]", ",", "lims", "[", "j", ",", "1", "]", ",", "lims", "[", "i", ",", "0", "]", ",", "lims", "[", "i", ",", "1", "]", "]", ",", "\n", "aspect", "=", "'auto'", ",", "interpolation", "=", "'none'", ")", "\n", "", "ax", "[", "i", ",", "j", "]", ".", "set_xlim", "(", "lims", "[", "j", "]", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "set_ylim", "(", "lims", "[", "i", "]", ")", "\n", "\n", "if", "gt", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "plot", "(", "gt", "[", "j", "]", ",", "gt", "[", "i", "]", ",", "'r.'", ",", "ms", "=", "10", ",", "\n", "markeredgewidth", "=", "0.0", ")", "\n", "\n", "", "ax", "[", "i", ",", "j", "]", ".", "get_xaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "get_yaxis", "(", ")", ".", "set_ticks", "(", "[", "]", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "set_axis_off", "(", ")", "\n", "\n", "x0", ",", "x1", "=", "ax", "[", "i", ",", "j", "]", ".", "get_xlim", "(", ")", "\n", "y0", ",", "y1", "=", "ax", "[", "i", ",", "j", "]", ".", "get_ylim", "(", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "set_aspect", "(", "(", "x1", "-", "x0", ")", "/", "(", "y1", "-", "y0", ")", ")", "\n", "\n", "if", "partial", "and", "j", "==", "cols", "-", "1", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "text", "(", "x1", "+", "(", "x1", "-", "x0", ")", "/", "6.", ",", "(", "y0", "+", "y1", ")", "/", "\n", "2.", ",", "'...'", ",", "fontsize", "=", "fontscale", "*", "25", ")", "\n", "\n", "", "", "if", "diag_only", "and", "c", "==", "cols", "-", "1", ":", "\n", "                    ", "c", "=", "-", "1", "\n", "r", "+=", "1", "\n", "\n", "", "", "", "", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.plot_hist_marginals": [[372, 415], ["int", "numpy.sqrt", "matplotlib.subplots", "ax.hist", "ax.set_ylim", "matplotlib.subplots", "range", "ax.set_xlim", "ax.vlines", "numpy.array", "numpy.asarray", "range", "numpy.tile", "ax.get_ylim", "ax.get_ylim", "ax[].hist", "ax[].set_ylim", "ax[].plot", "ax[].set_xlim", "ax[].vlines", "ax[].set_xlim", "ax[].set_ylim", "ax[].plot", "ax[].get_ylim", "ax[].get_ylim"], "function", ["None"], ["", "def", "plot_hist_marginals", "(", "data", ",", "lims", "=", "None", ",", "gt", "=", "None", ")", ":", "\n", "    ", "\"\"\"Plots marginal histograms and pairwise scatter plots of a dataset\"\"\"", "\n", "n_bins", "=", "int", "(", "np", ".", "sqrt", "(", "data", ".", "shape", "[", "0", "]", ")", ")", "\n", "\n", "if", "data", ".", "ndim", "==", "1", ":", "\n", "        ", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "1", ",", "1", ",", "facecolor", "=", "'white'", ")", "\n", "ax", ".", "hist", "(", "data", ",", "n_bins", ",", "density", "=", "True", ")", "\n", "ax", ".", "set_ylim", "(", "[", "0", ",", "ax", ".", "get_ylim", "(", ")", "[", "1", "]", "]", ")", "\n", "if", "lims", "is", "not", "None", ":", "\n", "            ", "ax", ".", "set_xlim", "(", "lims", ")", "\n", "", "if", "gt", "is", "not", "None", ":", "\n", "            ", "ax", ".", "vlines", "(", "gt", ",", "0", ",", "ax", ".", "get_ylim", "(", ")", "[", "1", "]", ",", "color", "=", "'r'", ")", "\n", "\n", "", "", "else", ":", "\n", "        ", "n_dim", "=", "data", ".", "shape", "[", "1", "]", "\n", "fig", ",", "ax", "=", "plt", ".", "subplots", "(", "n_dim", ",", "n_dim", ",", "facecolor", "=", "'white'", ")", "\n", "ax", "=", "np", ".", "array", "(", "[", "[", "ax", "]", "]", ")", "if", "n_dim", "==", "1", "else", "ax", "\n", "\n", "if", "lims", "is", "not", "None", ":", "\n", "            ", "lims", "=", "np", ".", "asarray", "(", "lims", ")", "\n", "lims", "=", "np", ".", "tile", "(", "lims", ",", "[", "n_dim", ",", "1", "]", ")", "if", "lims", ".", "ndim", "==", "1", "else", "lims", "\n", "\n", "", "for", "i", "in", "range", "(", "n_dim", ")", ":", "\n", "            ", "for", "j", "in", "range", "(", "n_dim", ")", ":", "\n", "\n", "                ", "if", "i", "==", "j", ":", "\n", "                    ", "ax", "[", "i", ",", "j", "]", ".", "hist", "(", "data", "[", ":", ",", "i", "]", ",", "n_bins", ",", "density", "=", "True", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "set_ylim", "(", "[", "0", ",", "ax", "[", "i", ",", "j", "]", ".", "get_ylim", "(", ")", "[", "1", "]", "]", ")", "\n", "if", "lims", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "set_xlim", "(", "lims", "[", "i", "]", ")", "\n", "", "if", "gt", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "vlines", "(", "\n", "gt", "[", "i", "]", ",", "0", ",", "ax", "[", "i", ",", "j", "]", ".", "get_ylim", "(", ")", "[", "1", "]", ",", "color", "=", "'r'", ")", "\n", "\n", "", "", "else", ":", "\n", "                    ", "ax", "[", "i", ",", "j", "]", ".", "plot", "(", "data", "[", ":", ",", "i", "]", ",", "data", "[", ":", ",", "j", "]", ",", "'k.'", ",", "ms", "=", "2", ")", "\n", "if", "lims", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "set_xlim", "(", "lims", "[", "i", "]", ")", "\n", "ax", "[", "i", ",", "j", "]", ".", "set_ylim", "(", "lims", "[", "j", "]", ")", "\n", "", "if", "gt", "is", "not", "None", ":", "\n", "                        ", "ax", "[", "i", ",", "j", "]", ".", "plot", "(", "gt", "[", "i", "]", ",", "gt", "[", "j", "]", ",", "'r.'", ",", "ms", "=", "8", ")", "\n", "\n", "", "", "", "", "", "return", "fig", ",", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._update": [[418, 429], ["six.iteritems", "d.get", "isinstance", "isinstance", "viz._update"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._update"], ["", "def", "_update", "(", "d", ",", "u", ")", ":", "\n", "# https://stackoverflow.com/a/3233356", "\n", "    ", "for", "k", ",", "v", "in", "six", ".", "iteritems", "(", "u", ")", ":", "\n", "        ", "dv", "=", "d", ".", "get", "(", "k", ",", "{", "}", ")", "\n", "if", "not", "isinstance", "(", "dv", ",", "collectionsAbc", ".", "Mapping", ")", ":", "\n", "            ", "d", "[", "k", "]", "=", "v", "\n", "", "elif", "isinstance", "(", "v", ",", "collectionsAbc", ".", "Mapping", ")", ":", "\n", "            ", "d", "[", "k", "]", "=", "_update", "(", "dv", ",", "v", ")", "\n", "", "else", ":", "\n", "            ", "d", "[", "k", "]", "=", "v", "\n", "", "", "return", "d", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._format_axis": [[431, 458], ["ax.spines[].set_visible", "ax.set_xlabel", "ax.xaxis.set_ticks_position", "ax.xaxis.set_tick_params", "ax.set_ylabel", "ax.yaxis.set_ticks_position", "ax.yaxis.set_tick_params", "ax.set_xlabel", "ax.xaxis.set_ticks_position", "ax.xaxis.set_tick_params", "ax.spines[].set_visible", "ax.set_ylabel", "ax.yaxis.set_ticks_position", "ax.yaxis.set_tick_params", "ax.spines[].set_visible", "ax.xaxis.set_major_formatter", "ax.yaxis.set_major_formatter"], "function", ["None"], ["", "def", "_format_axis", "(", "ax", ",", "xhide", "=", "True", ",", "yhide", "=", "True", ",", "xlabel", "=", "''", ",", "ylabel", "=", "''", ",", "\n", "tickformatter", "=", "None", ")", ":", "\n", "    ", "for", "loc", "in", "[", "'right'", ",", "'top'", ",", "'left'", ",", "'bottom'", "]", ":", "\n", "        ", "ax", ".", "spines", "[", "loc", "]", ".", "set_visible", "(", "False", ")", "\n", "", "if", "xhide", ":", "\n", "        ", "ax", ".", "set_xlabel", "(", "''", ")", "\n", "ax", ".", "xaxis", ".", "set_ticks_position", "(", "'none'", ")", "\n", "ax", ".", "xaxis", ".", "set_tick_params", "(", "labelbottom", "=", "False", ")", "\n", "", "if", "yhide", ":", "\n", "        ", "ax", ".", "set_ylabel", "(", "''", ")", "\n", "ax", ".", "yaxis", ".", "set_ticks_position", "(", "'none'", ")", "\n", "ax", ".", "yaxis", ".", "set_tick_params", "(", "labelleft", "=", "False", ")", "\n", "", "if", "not", "xhide", ":", "\n", "        ", "ax", ".", "set_xlabel", "(", "xlabel", ")", "\n", "ax", ".", "xaxis", ".", "set_ticks_position", "(", "'bottom'", ")", "\n", "ax", ".", "xaxis", ".", "set_tick_params", "(", "labelbottom", "=", "True", ")", "\n", "if", "tickformatter", "is", "not", "None", ":", "\n", "            ", "ax", ".", "xaxis", ".", "set_major_formatter", "(", "tickformatter", ")", "\n", "", "ax", ".", "spines", "[", "'bottom'", "]", ".", "set_visible", "(", "True", ")", "\n", "", "if", "not", "yhide", ":", "\n", "        ", "ax", ".", "set_ylabel", "(", "ylabel", ")", "\n", "ax", ".", "yaxis", ".", "set_ticks_position", "(", "'left'", ")", "\n", "ax", ".", "yaxis", ".", "set_tick_params", "(", "labelleft", "=", "True", ")", "\n", "if", "tickformatter", "is", "not", "None", ":", "\n", "            ", "ax", ".", "yaxis", ".", "set_major_formatter", "(", "tickformatter", ")", "\n", "", "ax", ".", "spines", "[", "'left'", "]", ".", "set_visible", "(", "True", ")", "\n", "", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz.samples_nd": [[460, 841], ["_update.copy", "viz._update", "matplotlib.ticker.FormatStrFormatter", "os.path.join", "type", "type", "numpy.atleast_2d", "range", "type", "type", "os.path.join", "matplotlib.rc_context", "matplotlib.subplots", "axes.reshape.reshape", "fig.subplots_adjust", "fig.suptitle", "range", "matplotlib.rcParams[].by_key", "matplotlib.rcParams[].by_key", "os.path.dirname", "limits.append", "len", "len", "os.path.dirname", "len", "range", "len", "range", "range", "sample[].min", "sample[].max", "range", "range", "type", "matplotlib.sca", "ax.get_xlim", "ax.get_ylim", "despine", "len", "ax.get_xlim", "ax.get_ylim", "ax.text", "range", "range", "len", "len", "range", "type", "ax.set_facecolor", "ax.axis", "ax.set_xlim", "ax.set_xticks", "ax.set_xticklabels", "ax.text", "ax.set_ylim", "ax.set_yticks", "viz._format_axis", "viz._format_axis", "viz._format_axis", "viz._format_axis", "len", "enumerate", "len", "ax.get_ylim", "enumerate", "len", "enumerate", "len", "enumerate", "len", "str", "str", "matplotlib.plot", "matplotlib.plot", "matplotlib.hist", "numpy.histogram2d", "matplotlib.imshow", "len", "scipy.stats.gaussian_kde", "numpy.linspace", "scipy.stats.gaussian_kde.", "matplotlib.plot", "scipy.stats.gaussian_kde", "numpy.meshgrid", "numpy.vstack", "numpy.reshape", "numpy.linspace", "numpy.linspace", "matplotlib.imshow", "matplotlib.scatter", "X.ravel", "Y.ravel", "scipy.stats.gaussian_kde.", "matplotlib.contour", "matplotlib.plot", "np.reshape.min", "np.reshape.max", "np.reshape.min"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._update", "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._format_axis", "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._format_axis", "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._format_axis", "home.repos.pwc.inspect_result.mackelab_delfi.utils.viz._format_axis"], ["", "def", "samples_nd", "(", "samples", ",", "points", "=", "[", "]", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Plot samples and points\n\n    See `opts` below for available keyword arguments.\n    \"\"\"", "\n", "opts", "=", "{", "\n", "# what to plot on triagonal and diagonal subplots", "\n", "'upper'", ":", "'hist'", ",", "# hist/scatter/None", "\n", "'diag'", ":", "'hist'", ",", "# hist/None", "\n", "#'lower': None,     # hist/scatter/None  # TODO: implement", "\n", "\n", "# title and legend", "\n", "'title'", ":", "None", ",", "\n", "'legend'", ":", "False", ",", "\n", "\n", "# labels", "\n", "'labels'", ":", "[", "]", ",", "# for dimensions", "\n", "'labels_points'", ":", "[", "]", ",", "# for points", "\n", "'labels_samples'", ":", "[", "]", ",", "# for samples", "\n", "\n", "# colors", "\n", "'samples_colors'", ":", "plt", ".", "rcParams", "[", "'axes.prop_cycle'", "]", ".", "by_key", "(", ")", "[", "'color'", "]", ",", "\n", "'points_colors'", ":", "plt", ".", "rcParams", "[", "'axes.prop_cycle'", "]", ".", "by_key", "(", ")", "[", "'color'", "]", ",", "\n", "\n", "# subset", "\n", "'subset'", ":", "None", ",", "\n", "\n", "# axes limits", "\n", "'limits'", ":", "[", "]", ",", "\n", "\n", "# ticks", "\n", "'ticks'", ":", "[", "]", ",", "\n", "'tickformatter'", ":", "mpl", ".", "ticker", ".", "FormatStrFormatter", "(", "'%g'", ")", ",", "\n", "'tick_labels'", ":", "None", ",", "\n", "\n", "# options for hist", "\n", "'hist_diag'", ":", "{", "\n", "'alpha'", ":", "1.", ",", "\n", "'bins'", ":", "25", ",", "\n", "'density'", ":", "False", ",", "\n", "'histtype'", ":", "'step'", "\n", "}", ",", "\n", "'hist_offdiag'", ":", "{", "\n", "#'edgecolor': 'none',", "\n", "#'linewidth': 0.0,", "\n", "'bins'", ":", "25", ",", "\n", "}", ",", "\n", "\n", "# options for kde", "\n", "'kde_diag'", ":", "{", "\n", "'bw_method'", ":", "'scott'", ",", "\n", "'bins'", ":", "100", ",", "\n", "'color'", ":", "'black'", "\n", "}", ",", "\n", "'kde_offdiag'", ":", "{", "\n", "'bw_method'", ":", "'scott'", ",", "\n", "'bins'", ":", "25", "\n", "}", ",", "\n", "\n", "# options for contour", "\n", "'contour_offdiag'", ":", "{", "\n", "'levels'", ":", "[", "0.68", "]", "\n", "}", ",", "\n", "\n", "# options for scatter", "\n", "'scatter_offdiag'", ":", "{", "\n", "'alpha'", ":", "0.5", ",", "\n", "'edgecolor'", ":", "'none'", ",", "\n", "'rasterized'", ":", "False", ",", "\n", "}", ",", "\n", "\n", "# options for plot", "\n", "'plot_offdiag'", ":", "{", "}", ",", "\n", "\n", "# formatting points (scale, markers)", "\n", "'points_diag'", ":", "{", "\n", "}", ",", "\n", "'points_offdiag'", ":", "{", "\n", "'marker'", ":", "'.'", ",", "\n", "'markersize'", ":", "20", ",", "\n", "}", ",", "\n", "\n", "# matplotlib style", "\n", "'style'", ":", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "'matplotlibrc'", ")", ",", "\n", "\n", "# other options", "\n", "'fig_size'", ":", "(", "10", ",", "10", ")", ",", "\n", "'fig_bg_colors'", ":", "\n", "{", "'upper'", ":", "None", ",", "\n", "'diag'", ":", "None", ",", "\n", "'lower'", ":", "None", "}", ",", "\n", "'fig_subplots_adjust'", ":", "{", "\n", "'top'", ":", "0.9", ",", "\n", "}", ",", "\n", "'subplots'", ":", "{", "\n", "}", ",", "\n", "'despine'", ":", "{", "\n", "'offset'", ":", "5", ",", "\n", "}", ",", "\n", "'title_format'", ":", "{", "\n", "'fontsize'", ":", "16", "\n", "}", ",", "\n", "}", "\n", "# TODO: add color map support", "\n", "# TODO: automatically determine good bin sizes for histograms", "\n", "# TODO: get rid of seaborn dependency for despine", "\n", "# TODO: add legend (if legend is True)", "\n", "\n", "samples_nd", ".", "defaults", "=", "opts", ".", "copy", "(", ")", "\n", "opts", "=", "_update", "(", "opts", ",", "kwargs", ")", "\n", "\n", "# Prepare samples", "\n", "if", "type", "(", "samples", ")", "!=", "list", ":", "\n", "        ", "samples", "=", "[", "samples", "]", "\n", "\n", "# Prepare points", "\n", "", "if", "type", "(", "points", ")", "!=", "list", ":", "\n", "        ", "points", "=", "[", "points", "]", "\n", "", "points", "=", "[", "np", ".", "atleast_2d", "(", "p", ")", "for", "p", "in", "points", "]", "\n", "\n", "# Dimensions", "\n", "dim", "=", "samples", "[", "0", "]", ".", "shape", "[", "1", "]", "\n", "num_samples", "=", "samples", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# TODO: add asserts checking compatiblity of dimensions", "\n", "\n", "# Prepare labels", "\n", "if", "opts", "[", "'labels'", "]", "==", "[", "]", "or", "opts", "[", "'labels'", "]", "is", "None", ":", "\n", "        ", "labels_dim", "=", "[", "'dim {}'", ".", "format", "(", "i", "+", "1", ")", "for", "i", "in", "range", "(", "dim", ")", "]", "\n", "", "else", ":", "\n", "        ", "labels_dim", "=", "opts", "[", "'labels'", "]", "\n", "\n", "# Prepare limits", "\n", "", "if", "opts", "[", "'limits'", "]", "==", "[", "]", "or", "opts", "[", "'limits'", "]", "is", "None", ":", "\n", "        ", "limits", "=", "[", "]", "\n", "for", "d", "in", "range", "(", "dim", ")", ":", "\n", "            ", "min", "=", "+", "np", ".", "inf", "\n", "max", "=", "-", "np", ".", "inf", "\n", "for", "sample", "in", "samples", ":", "\n", "                ", "min_", "=", "sample", "[", ":", ",", "d", "]", ".", "min", "(", ")", "\n", "min", "=", "min_", "if", "min_", "<", "min", "else", "min", "\n", "max_", "=", "sample", "[", ":", ",", "d", "]", ".", "max", "(", ")", "\n", "max", "=", "max_", "if", "max_", ">", "max", "else", "max", "\n", "", "limits", ".", "append", "(", "[", "min", ",", "max", "]", ")", "\n", "", "", "else", ":", "\n", "        ", "if", "len", "(", "opts", "[", "'limits'", "]", ")", "==", "1", ":", "\n", "            ", "limits", "=", "[", "opts", "[", "'limits'", "]", "[", "0", "]", "for", "_", "in", "range", "(", "dim", ")", "]", "\n", "", "else", ":", "\n", "            ", "limits", "=", "opts", "[", "'limits'", "]", "\n", "\n", "# Prepare ticks", "\n", "", "", "if", "opts", "[", "'ticks'", "]", "==", "[", "]", "or", "opts", "[", "'ticks'", "]", "is", "None", ":", "\n", "        ", "ticks", "=", "None", "\n", "", "else", ":", "\n", "        ", "if", "len", "(", "opts", "[", "'ticks'", "]", ")", "==", "1", ":", "\n", "            ", "ticks", "=", "[", "opts", "[", "'ticks'", "]", "[", "0", "]", "for", "_", "in", "range", "(", "dim", ")", "]", "\n", "", "else", ":", "\n", "            ", "ticks", "=", "opts", "[", "'ticks'", "]", "\n", "\n", "# Prepare diag/upper/lower", "\n", "", "", "if", "type", "(", "opts", "[", "'diag'", "]", ")", "is", "not", "list", ":", "\n", "        ", "opts", "[", "'diag'", "]", "=", "[", "opts", "[", "'diag'", "]", "for", "_", "in", "range", "(", "len", "(", "samples", ")", ")", "]", "\n", "", "if", "type", "(", "opts", "[", "'upper'", "]", ")", "is", "not", "list", ":", "\n", "        ", "opts", "[", "'upper'", "]", "=", "[", "opts", "[", "'upper'", "]", "for", "_", "in", "range", "(", "len", "(", "samples", ")", ")", "]", "\n", "#if type(opts['lower']) is not list:", "\n", "#    opts['lower'] = [opts['lower'] for _ in range(len(samples))]", "\n", "", "opts", "[", "'lower'", "]", "=", "None", "\n", "\n", "# Style", "\n", "if", "opts", "[", "'style'", "]", "in", "[", "'dark'", ",", "'light'", "]", ":", "\n", "        ", "style", "=", "os", ".", "path", ".", "join", "(", "\n", "os", ".", "path", ".", "dirname", "(", "__file__", ")", ",", "\n", "'matplotlib_{}.style'", ".", "format", "(", "opts", "[", "'style'", "]", ")", ")", "\n", "", "else", ":", "\n", "        ", "style", "=", "opts", "[", "'style'", "]", ";", "\n", "\n", "# Apply custom style as context", "\n", "", "with", "mpl", ".", "rc_context", "(", "fname", "=", "style", ")", ":", "\n", "\n", "# Figure out if we subset the plot", "\n", "        ", "subset", "=", "opts", "[", "'subset'", "]", "\n", "if", "subset", "is", "None", ":", "\n", "            ", "rows", "=", "cols", "=", "dim", "\n", "subset", "=", "[", "i", "for", "i", "in", "range", "(", "dim", ")", "]", "\n", "", "else", ":", "\n", "            ", "if", "type", "(", "subset", ")", "==", "int", ":", "\n", "                ", "subset", "=", "[", "subset", "]", "\n", "", "elif", "type", "(", "subset", ")", "==", "list", ":", "\n", "                ", "pass", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "\n", "", "rows", "=", "cols", "=", "len", "(", "subset", ")", "\n", "\n", "", "fig", ",", "axes", "=", "plt", ".", "subplots", "(", "rows", ",", "cols", ",", "figsize", "=", "opts", "[", "'fig_size'", "]", ",", "**", "opts", "[", "'subplots'", "]", ")", "\n", "axes", "=", "axes", ".", "reshape", "(", "rows", ",", "cols", ")", "\n", "\n", "# Style figure", "\n", "fig", ".", "subplots_adjust", "(", "**", "opts", "[", "'fig_subplots_adjust'", "]", ")", "\n", "fig", ".", "suptitle", "(", "opts", "[", "'title'", "]", ",", "**", "opts", "[", "'title_format'", "]", ")", "\n", "\n", "# Style axes", "\n", "row_idx", "=", "-", "1", "\n", "for", "row", "in", "range", "(", "dim", ")", ":", "\n", "            ", "if", "row", "not", "in", "subset", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "row_idx", "+=", "1", "\n", "\n", "", "col_idx", "=", "-", "1", "\n", "for", "col", "in", "range", "(", "dim", ")", ":", "\n", "                ", "if", "col", "not", "in", "subset", ":", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "col_idx", "+=", "1", "\n", "\n", "", "if", "row", "==", "col", ":", "\n", "                    ", "current", "=", "'diag'", "\n", "", "elif", "row", "<", "col", ":", "\n", "                    ", "current", "=", "'upper'", "\n", "", "else", ":", "\n", "                    ", "current", "=", "'lower'", "\n", "\n", "", "ax", "=", "axes", "[", "row_idx", ",", "col_idx", "]", "\n", "plt", ".", "sca", "(", "ax", ")", "\n", "\n", "# Background color", "\n", "if", "current", "in", "opts", "[", "'fig_bg_colors'", "]", "and", "opts", "[", "'fig_bg_colors'", "]", "[", "current", "]", "is", "not", "None", ":", "\n", "                    ", "ax", ".", "set_facecolor", "(", "\n", "opts", "[", "'fig_bg_colors'", "]", "[", "current", "]", ")", "\n", "\n", "# Axes", "\n", "", "if", "opts", "[", "current", "]", "is", "None", ":", "\n", "                    ", "ax", ".", "axis", "(", "'off'", ")", "\n", "continue", "\n", "\n", "# Limits", "\n", "", "if", "limits", "is", "not", "None", ":", "\n", "                    ", "ax", ".", "set_xlim", "(", "\n", "(", "limits", "[", "col", "]", "[", "0", "]", ",", "limits", "[", "col", "]", "[", "1", "]", ")", ")", "\n", "if", "current", "is", "not", "'diag'", ":", "\n", "                        ", "ax", ".", "set_ylim", "(", "\n", "(", "limits", "[", "row", "]", "[", "0", "]", ",", "limits", "[", "row", "]", "[", "1", "]", ")", ")", "\n", "", "", "xmin", ",", "xmax", "=", "ax", ".", "get_xlim", "(", ")", "\n", "ymin", ",", "ymax", "=", "ax", ".", "get_ylim", "(", ")", "\n", "\n", "# Ticks", "\n", "if", "ticks", "is", "not", "None", ":", "\n", "                    ", "ax", ".", "set_xticks", "(", "\n", "(", "ticks", "[", "col", "]", "[", "0", "]", ",", "ticks", "[", "col", "]", "[", "1", "]", ")", ")", "\n", "if", "current", "is", "not", "'diag'", ":", "\n", "                        ", "ax", ".", "set_yticks", "(", "\n", "(", "ticks", "[", "row", "]", "[", "0", "]", ",", "ticks", "[", "row", "]", "[", "1", "]", ")", ")", "\n", "\n", "# Despine", "\n", "", "", "despine", "(", "ax", "=", "ax", ",", "**", "opts", "[", "'despine'", "]", ")", "\n", "\n", "# Formatting axes", "\n", "if", "current", "==", "'diag'", ":", "# off-diagnoals", "\n", "                    ", "if", "opts", "[", "'lower'", "]", "is", "None", "or", "col", "==", "dim", "-", "1", ":", "\n", "                        ", "_format_axis", "(", "ax", ",", "xhide", "=", "False", ",", "xlabel", "=", "labels_dim", "[", "col", "]", ",", "\n", "yhide", "=", "True", ",", "tickformatter", "=", "opts", "[", "'tickformatter'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "_format_axis", "(", "ax", ",", "xhide", "=", "True", ",", "yhide", "=", "True", ")", "\n", "", "", "else", ":", "# off-diagnoals", "\n", "                    ", "if", "row", "==", "dim", "-", "1", ":", "\n", "                        ", "_format_axis", "(", "ax", ",", "xhide", "=", "False", ",", "xlabel", "=", "labels_dim", "[", "col", "]", ",", "\n", "yhide", "=", "True", ",", "tickformatter", "=", "opts", "[", "'tickformatter'", "]", ")", "\n", "", "else", ":", "\n", "                        ", "_format_axis", "(", "ax", ",", "xhide", "=", "True", ",", "yhide", "=", "True", ")", "\n", "", "", "if", "opts", "[", "'tick_labels'", "]", "is", "not", "None", ":", "\n", "                    ", "ax", ".", "set_xticklabels", "(", "\n", "(", "str", "(", "opts", "[", "'tick_labels'", "]", "[", "col", "]", "[", "0", "]", ")", ",", "str", "(", "opts", "[", "'tick_labels'", "]", "[", "col", "]", "[", "1", "]", ")", ")", ")", "\n", "\n", "# Diagonals", "\n", "", "if", "current", "==", "'diag'", ":", "\n", "                    ", "if", "len", "(", "samples", ")", ">", "0", ":", "\n", "                        ", "for", "n", ",", "v", "in", "enumerate", "(", "samples", ")", ":", "\n", "                            ", "if", "opts", "[", "'diag'", "]", "[", "n", "]", "==", "'hist'", ":", "\n", "                                ", "h", "=", "plt", ".", "hist", "(", "\n", "v", "[", ":", ",", "row", "]", ",", "\n", "color", "=", "opts", "[", "'samples_colors'", "]", "[", "n", "]", ",", "\n", "**", "opts", "[", "'hist_diag'", "]", "\n", ")", "\n", "", "elif", "opts", "[", "'diag'", "]", "[", "n", "]", "==", "'kde'", ":", "\n", "                                ", "density", "=", "gaussian_kde", "(", "\n", "v", "[", ":", ",", "row", "]", ",", "\n", "bw_method", "=", "opts", "[", "'kde_diag'", "]", "[", "'bw_method'", "]", ")", "\n", "xs", "=", "np", ".", "linspace", "(", "xmin", ",", "xmax", ",", "opts", "[", "'kde_diag'", "]", "[", "'bins'", "]", ")", "\n", "ys", "=", "density", "(", "xs", ")", "\n", "h", "=", "plt", ".", "plot", "(", "xs", ",", "ys", ",", "\n", "color", "=", "opts", "[", "'samples_colors'", "]", "[", "n", "]", ",", "\n", ")", "\n", "", "else", ":", "\n", "                                ", "pass", "\n", "\n", "", "", "", "if", "len", "(", "points", ")", ">", "0", ":", "\n", "                        ", "extent", "=", "ax", ".", "get_ylim", "(", ")", "\n", "for", "n", ",", "v", "in", "enumerate", "(", "points", ")", ":", "\n", "                            ", "h", "=", "plt", ".", "plot", "(", "\n", "[", "v", "[", ":", ",", "row", "]", ",", "v", "[", ":", ",", "row", "]", "]", ",", "\n", "extent", ",", "\n", "color", "=", "opts", "[", "'points_colors'", "]", "[", "n", "]", ",", "\n", "**", "opts", "[", "'points_diag'", "]", "\n", ")", "\n", "\n", "# Off-diagonals", "\n", "", "", "", "else", ":", "\n", "\n", "                    ", "if", "len", "(", "samples", ")", ">", "0", ":", "\n", "                        ", "for", "n", ",", "v", "in", "enumerate", "(", "samples", ")", ":", "\n", "                            ", "if", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'hist'", "or", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'hist2d'", ":", "\n", "                                ", "hist", ",", "xedges", ",", "yedges", "=", "np", ".", "histogram2d", "(", "\n", "v", "[", ":", ",", "col", "]", ",", "v", "[", ":", ",", "row", "]", ",", "range", "=", "[", "\n", "[", "limits", "[", "col", "]", "[", "0", "]", ",", "limits", "[", "col", "]", "[", "1", "]", "]", ",", "\n", "[", "limits", "[", "row", "]", "[", "0", "]", ",", "limits", "[", "row", "]", "[", "1", "]", "]", "]", ",", "\n", "**", "opts", "[", "'hist_offdiag'", "]", ")", "\n", "h", "=", "plt", ".", "imshow", "(", "hist", ".", "T", ",", "\n", "origin", "=", "'lower'", ",", "\n", "extent", "=", "[", "xedges", "[", "0", "]", ",", "xedges", "[", "-", "1", "]", ",", "yedges", "[", "0", "]", ",", "yedges", "[", "-", "1", "]", "]", ",", "\n", "aspect", "=", "'auto'", "\n", ")", "\n", "\n", "", "elif", "opts", "[", "'upper'", "]", "[", "n", "]", "in", "[", "'kde'", ",", "'kde2d'", ",", "'contour'", ",", "'contourf'", "]", ":", "\n", "                                ", "density", "=", "gaussian_kde", "(", "v", "[", ":", ",", "[", "col", ",", "row", "]", "]", ".", "T", ",", "bw_method", "=", "opts", "[", "'kde_offdiag'", "]", "[", "'bw_method'", "]", ")", "\n", "X", ",", "Y", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "limits", "[", "col", "]", "[", "0", "]", ",", "limits", "[", "col", "]", "[", "1", "]", ",", "opts", "[", "'kde_offdiag'", "]", "[", "'bins'", "]", ")", ",", "\n", "np", ".", "linspace", "(", "limits", "[", "row", "]", "[", "0", "]", ",", "limits", "[", "row", "]", "[", "1", "]", ",", "opts", "[", "'kde_offdiag'", "]", "[", "'bins'", "]", ")", ")", "\n", "positions", "=", "np", ".", "vstack", "(", "[", "X", ".", "ravel", "(", ")", ",", "Y", ".", "ravel", "(", ")", "]", ")", "\n", "Z", "=", "np", ".", "reshape", "(", "density", "(", "positions", ")", ".", "T", ",", "X", ".", "shape", ")", "\n", "\n", "if", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'kde'", "or", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'kde2d'", ":", "\n", "                                    ", "h", "=", "plt", ".", "imshow", "(", "Z", ",", "\n", "extent", "=", "[", "limits", "[", "col", "]", "[", "0", "]", ",", "limits", "[", "col", "]", "[", "1", "]", ",", "limits", "[", "row", "]", "[", "0", "]", ",", "limits", "[", "row", "]", "[", "1", "]", "]", ",", "\n", "origin", "=", "'lower'", ",", "\n", "aspect", "=", "'auto'", ",", "\n", ")", "\n", "", "elif", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'contour'", ":", "\n", "                                    ", "Z", "=", "(", "Z", "-", "Z", ".", "min", "(", ")", ")", "/", "(", "Z", ".", "max", "(", ")", "-", "Z", ".", "min", "(", ")", ")", "\n", "h", "=", "plt", ".", "contour", "(", "X", ",", "Y", ",", "Z", ",", "\n", "origin", "=", "'lower'", ",", "\n", "extent", "=", "[", "limits", "[", "col", "]", "[", "0", "]", ",", "limits", "[", "col", "]", "[", "1", "]", ",", "limits", "[", "row", "]", "[", "0", "]", ",", "limits", "[", "row", "]", "[", "1", "]", "]", ",", "\n", "colors", "=", "opts", "[", "'samples_colors'", "]", "[", "n", "]", ",", "\n", "**", "opts", "[", "'contour_offdiag'", "]", "\n", ")", "\n", "", "else", ":", "\n", "                                    ", "pass", "\n", "", "", "elif", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'scatter'", ":", "\n", "                                ", "h", "=", "plt", ".", "scatter", "(", "\n", "v", "[", ":", ",", "col", "]", ",", "v", "[", ":", ",", "row", "]", ",", "\n", "color", "=", "opts", "[", "'samples_colors'", "]", "[", "n", "]", ",", "\n", "**", "opts", "[", "'scatter_offdiag'", "]", "\n", ")", "\n", "", "elif", "opts", "[", "'upper'", "]", "[", "n", "]", "==", "'plot'", ":", "\n", "                                ", "h", "=", "plt", ".", "plot", "(", "\n", "v", "[", ":", ",", "col", "]", ",", "v", "[", ":", ",", "row", "]", ",", "\n", "color", "=", "opts", "[", "'samples_colors'", "]", "[", "n", "]", ",", "\n", "**", "opts", "[", "'plot_offdiag'", "]", "\n", ")", "\n", "", "else", ":", "\n", "                                ", "pass", "\n", "\n", "", "", "", "if", "len", "(", "points", ")", ">", "0", ":", "\n", "\n", "                        ", "for", "n", ",", "v", "in", "enumerate", "(", "points", ")", ":", "\n", "                            ", "h", "=", "plt", ".", "plot", "(", "\n", "v", "[", ":", ",", "col", "]", ",", "v", "[", ":", ",", "row", "]", ",", "\n", "color", "=", "opts", "[", "'points_colors'", "]", "[", "n", "]", ",", "\n", "**", "opts", "[", "'points_offdiag'", "]", "\n", ")", "\n", "\n", "", "", "", "", "", "if", "len", "(", "subset", ")", "<", "dim", ":", "\n", "            ", "for", "row", "in", "range", "(", "len", "(", "subset", ")", ")", ":", "\n", "                ", "ax", "=", "axes", "[", "row", ",", "len", "(", "subset", ")", "-", "1", "]", "\n", "x0", ",", "x1", "=", "ax", ".", "get_xlim", "(", ")", "\n", "y0", ",", "y1", "=", "ax", ".", "get_ylim", "(", ")", "\n", "text_kwargs", "=", "{", "'fontsize'", ":", "plt", ".", "rcParams", "[", "'font.size'", "]", "*", "2.", "}", "\n", "ax", ".", "text", "(", "x1", "+", "(", "x1", "-", "x0", ")", "/", "8.", ",", "(", "y0", "+", "y1", ")", "/", "2.", ",", "'...'", ",", "**", "text_kwargs", ")", "\n", "if", "row", "==", "len", "(", "subset", ")", "-", "1", ":", "\n", "                    ", "ax", ".", "text", "(", "x1", "+", "(", "x1", "-", "x0", ")", "/", "12.", ",", "y0", "-", "(", "y1", "-", "y0", ")", "/", "1.5", ",", "'...'", ",", "rotation", "=", "-", "45", ",", "**", "text_kwargs", ")", "\n", "\n", "", "", "", "", "return", "fig", ",", "axes", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load": [[7, 26], ["io.load_pkl", "str", "inference.compile_observables", "inference.network.compile_funs", "type"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load_pkl", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.compile_observables", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.compile_funs"], ["def", "load", "(", "file", ")", ":", "\n", "    ", "\"\"\"Loads inference instance from pickle\n\n    Parameters\n    ----------\n    file : str\n\n    Returns\n    -------\n    inference instance\n    \"\"\"", "\n", "data", "=", "load_pkl", "(", "file", ")", "\n", "if", "'delfi.inference'", "in", "str", "(", "type", "(", "data", "[", "'inference'", "]", ")", ")", ":", "\n", "        ", "inference", "=", "data", "[", "'inference'", "]", "\n", "inference", ".", "compile_observables", "(", ")", "\n", "inference", ".", "network", ".", "compile_funs", "(", ")", "\n", "return", "inference", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load_pkl": [[28, 43], ["open", "dill.load", "open.close"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load"], ["", "", "def", "load_pkl", "(", "file", ")", ":", "\n", "    ", "\"\"\"Loads data from pickle\n\n    Parameters\n    ----------\n    file : str\n\n    Returns\n    -------\n    data\n    \"\"\"", "\n", "f", "=", "open", "(", "file", ",", "'rb'", ")", "\n", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "f", ".", "close", "(", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.save": [[45, 64], ["str", "io.save_pkl", "obj.compile_observables", "type"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.io.save_pkl", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.compile_observables"], ["", "def", "save", "(", "obj", ",", "file", ")", ":", "\n", "    ", "\"\"\"Saves inference result\n\n    Parameters\n    ----------\n    obj : inference instance\n    file : str\n    \"\"\"", "\n", "data", "=", "{", "}", "\n", "if", "'delfi.inference'", "in", "str", "(", "type", "(", "obj", ")", ")", ":", "\n", "        ", "data", "[", "'generator'", "]", "=", "obj", ".", "generator", "\n", "data", "[", "'network.spec_dict'", "]", "=", "obj", ".", "network", ".", "spec_dict", "\n", "data", "[", "'network.params_dict'", "]", "=", "obj", ".", "network", ".", "params_dict", "\n", "del", "obj", ".", "observables", "\n", "data", "[", "'inference'", "]", "=", "obj", "\n", "save_pkl", "(", "data", ",", "file", ")", "\n", "obj", ".", "compile_observables", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.save_pkl": [[66, 77], ["open", "dill.dump", "open.close"], "function", ["None"], ["", "", "def", "save_pkl", "(", "data", ",", "file", ")", ":", "\n", "    ", "\"\"\"Saves data to a pickle\n\n    Parameters\n    ----------\n    data : object\n    file : str\n    \"\"\"", "\n", "f", "=", "open", "(", "file", ",", "'wb'", ")", "\n", "pickle", ".", "dump", "(", "data", ",", "f", ")", "\n", "f", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.import_from_module_and_run": [[79, 109], ["isinstance", "isinstance", "os.getcwd", "os.chdir", "importlib.import_module", "getattr", "getattr.", "os.chdir"], "function", ["None"], ["", "def", "import_from_module_and_run", "(", "module_name", ",", "function_name", ",", "*", "args", ",", "starting_path", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n\n    :param module_name:\n    :param function_name:\n    :param args:\n    :param starting_path:\n    :param kwargs:\n    :return:\n    \"\"\"", "\n", "assert", "isinstance", "(", "function_name", ",", "str", ")", "and", "isinstance", "(", "module_name", ",", "str", ")", "\n", "if", "starting_path", "is", "not", "None", ":", "\n", "        ", "prev_dir", "=", "os", ".", "getcwd", "(", ")", "\n", "os", ".", "chdir", "(", "starting_path", ")", "\n", "\n", "", "try", ":", "\n", "        ", "m", "=", "import_module", "(", "module_name", ")", "\n", "f", "=", "getattr", "(", "m", ",", "function_name", ")", "\n", "result", "=", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "err", "=", "None", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "err", "=", "e", "\n", "", "finally", ":", "\n", "        ", "if", "starting_path", "is", "not", "None", ":", "\n", "            ", "os", ".", "chdir", "(", "prev_dir", ")", "\n", "\n", "", "", "if", "err", "is", "not", "None", ":", "\n", "        ", "raise", "err", "\n", "\n", "", "return", "result", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.run_function_from_file": [[111, 148], ["isinstance", "os.path.exists", "eval.", "os.getcwd", "os.chdir", "importlib.util.spec_from_file_location", "importlib.util.module_from_spec", "importlib.util.spec_from_file_location.loader.exec_module", "eval", "os.chdir"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "run_function_from_file", "(", "file", ",", "function_name", ",", "*", "args", ",", "starting_path", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Utility to retrieve a function by name from a python file and run it with optional inputs.\n\n    This can be useful for running simulators on remote hosts with installing/importing the necessary modules on the\n    client.\n    :param starting_path:\n    :param function_name:\n    :param file:\n    :param function_name:\n    :param args:\n    :param kwargs:\n    :return:\n    \"\"\"", "\n", "assert", "isinstance", "(", "function_name", ",", "str", ")", "\n", "assert", "os", ".", "path", ".", "exists", "(", "file", ")", ",", "\"file not found: {0}\"", ".", "format", "(", "file", ")", "\n", "if", "starting_path", "is", "not", "None", ":", "\n", "        ", "prev_dir", "=", "os", ".", "getcwd", "(", ")", "\n", "os", ".", "chdir", "(", "starting_path", ")", "\n", "\n", "", "try", ":", "\n", "        ", "spec", "=", "spec_from_file_location", "(", "'rfff_module'", ",", "file", ")", "\n", "module", "=", "module_from_spec", "(", "spec", ")", "\n", "spec", ".", "loader", ".", "exec_module", "(", "module", ")", "\n", "f", "=", "eval", "(", "'module.{0}'", ".", "format", "(", "function_name", ")", ")", "\n", "success", "=", "True", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "success", "=", "False", "\n", "err", "=", "e", "\n", "\n", "", "if", "starting_path", "is", "not", "None", ":", "\n", "        ", "os", ".", "chdir", "(", "prev_dir", ")", "\n", "\n", "", "if", "not", "success", ":", "\n", "        ", "raise", "err", "\n", "\n", "", "return", "f", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.math.MoGL2sq": [[6, 26], ["numpy.concatenate", "range", "isinstance", "isinstance", "len", "range", "math.gaussprodintegral", "math.gaussprodintegral"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussprodintegral", "home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussprodintegral"], ["def", "MoGL2sq", "(", "p1", ",", "p2", ")", ":", "\n", "    ", "\"\"\"\n    Calculate integral of squared difference between MoG pdfs\n\n    idea from this stats.stackexchange post:\n    https://stats.stackexchange.com/questions/71879/distance-between-two-gaussian-mixtures-to-evaluate-cluster-solutions\n    \"\"\"", "\n", "assert", "isinstance", "(", "p1", ",", "MoG", ")", "and", "isinstance", "(", "p2", ",", "MoG", ")", "\n", "\n", "w", "=", "np", ".", "concatenate", "(", "(", "p1", ".", "a", ",", "-", "p2", ".", "a", ")", ")", "\n", "allxs", "=", "p1", ".", "xs", "+", "p2", ".", "xs", "\n", "\n", "L2", "=", "0.0", "\n", "# compute all the integrals. don't compute cross terms twice", "\n", "for", "i", "in", "range", "(", "len", "(", "w", ")", ")", ":", "\n", "        ", "L2", "+=", "w", "[", "i", "]", "**", "2", "*", "gaussprodintegral", "(", "allxs", "[", "i", "]", ",", "allxs", "[", "i", "]", ")", "\n", "for", "j", "in", "range", "(", "i", ")", ":", "\n", "            ", "L2", "+=", "2", "*", "w", "[", "i", "]", "*", "w", "[", "j", "]", "*", "gaussprodintegral", "(", "allxs", "[", "i", "]", ",", "allxs", "[", "j", "]", ")", "\n", "\n", "", "", "return", "L2", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussprodintegral": [[28, 44], ["numpy.linalg.inv", "numpy.log", "numpy.sum", "numpy.linalg.det", "numpy.exp", "numpy.dot", "numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "gaussprodintegral", "(", "x1", ",", "x2", ",", "log", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate normalization constant for a product of Gaussian pdfs.\n    This is the integral of the unnormalized product.\n    \"\"\"", "\n", "d", "=", "x1", ".", "m", "-", "x2", ".", "m", "\n", "S", "=", "x1", ".", "S", "+", "x2", ".", "S", "\n", "\n", "P", "=", "np", ".", "linalg", ".", "inv", "(", "S", ")", "\n", "logdetS", "=", "np", ".", "log", "(", "np", ".", "linalg", ".", "det", "(", "S", ")", ")", "\n", "Q", "=", "np", ".", "sum", "(", "np", ".", "dot", "(", "d", ",", "P", ")", "*", "d", ")", "# quadratic term in Gaussian pdf exponent", "\n", "\n", "logZ", "=", "0.5", "*", "(", "-", "Q", "-", "logdetS", "-", "x1", ".", "ndim", "*", "np", ".", "log", "(", "2.0", "*", "np", ".", "pi", ")", ")", "\n", "\n", "res", "=", "logZ", "if", "log", "else", "np", ".", "exp", "(", "logZ", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussquotientintegral": [[46, 66], ["numpy.linalg.inv", "numpy.linalg.det", "numpy.log", "numpy.dot", "numpy.dot", "numpy.exp", "numpy.dot", "numpy.dot", "numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "gaussquotientintegral", "(", "x1", ",", "x2", ",", "log", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate normalization constant for a quotient of Gaussian pdfs.\n    This is the integral of the unnormalized product.\n    \"\"\"", "\n", "Pstar", "=", "x1", ".", "P", "-", "x2", ".", "P", "\n", "Sstar", "=", "np", ".", "linalg", ".", "inv", "(", "Pstar", ")", "\n", "detSstar", "=", "np", ".", "linalg", ".", "det", "(", "Sstar", ")", "\n", "if", "detSstar", "<", "0", ":", "\n", "        ", "return", "np", ".", "inf", "\n", "", "logdetSstar", "=", "np", ".", "log", "(", "detSstar", ")", "\n", "Pstarmstar", "=", "x1", ".", "Pm", "-", "x2", ".", "Pm", "\n", "mstar", "=", "np", ".", "dot", "(", "Sstar", ",", "Pstarmstar", ")", "\n", "\n", "Q", "=", "np", ".", "dot", "(", "x1", ".", "Pm", ",", "x1", ".", "m", ")", "-", "np", ".", "dot", "(", "x2", ".", "Pm", ",", "x2", ".", "m", ")", "-", "np", ".", "dot", "(", "Pstarmstar", ",", "mstar", ")", "\n", "D", "=", "x1", ".", "logdetP", "-", "x2", ".", "logdetP", "+", "logdetSstar", "+", "x1", ".", "ndim", "*", "np", ".", "log", "(", "2.0", "*", "np", ".", "pi", ")", "\n", "logZ", "=", "0.5", "*", "(", "D", "-", "Q", ")", "\n", "\n", "res", "=", "logZ", "if", "log", "else", "np", ".", "exp", "(", "logZ", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussprodquotientintegral": [[68, 90], ["numpy.linalg.inv", "numpy.linalg.det", "numpy.log", "numpy.dot", "numpy.dot", "numpy.exp", "numpy.dot", "numpy.dot", "numpy.dot"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "gaussprodquotientintegral", "(", "x1", ",", "x2", ",", "x3", ",", "log", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate normalization constant for a product-quotient of 3 Gaussian pdfs.\n    If x1, x2 and x3 are Gaussian with pdfs f1, f2 and f3, then we integrate\n    f1 * f2 / f3 and return the resulting normalization constant.\n    \"\"\"", "\n", "Pstar", "=", "x1", ".", "P", "+", "x2", ".", "P", "-", "x3", ".", "P", "\n", "Sstar", "=", "np", ".", "linalg", ".", "inv", "(", "Pstar", ")", "\n", "detSstar", "=", "np", ".", "linalg", ".", "det", "(", "Sstar", ")", "\n", "if", "detSstar", "<", "0", ":", "\n", "        ", "return", "np", ".", "inf", "\n", "", "logdetSstar", "=", "np", ".", "log", "(", "detSstar", ")", "\n", "Pstarmstar", "=", "x1", ".", "Pm", "+", "x2", ".", "Pm", "-", "x3", ".", "Pm", "\n", "mstar", "=", "np", ".", "dot", "(", "Sstar", ",", "Pstarmstar", ")", "\n", "\n", "Q", "=", "np", ".", "dot", "(", "x1", ".", "Pm", ",", "x1", ".", "m", ")", "+", "np", ".", "dot", "(", "x2", ".", "Pm", ",", "x2", ".", "m", ")", "-", "np", ".", "dot", "(", "x3", ".", "Pm", ",", "x3", ".", "m", ")", "-", "np", ".", "dot", "(", "Pstarmstar", ",", "mstar", ")", "\n", "D", "=", "x1", ".", "logdetP", "+", "x2", ".", "logdetP", "-", "x3", ".", "logdetP", "+", "logdetSstar", "\n", "logZ", "=", "0.5", "*", "(", "D", "-", "Q", ")", "\n", "\n", "res", "=", "logZ", "if", "log", "else", "np", ".", "exp", "(", "logZ", ")", "\n", "return", "res", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.meta.ABCMetaDoc.__prepare__": [[10, 19], ["super().__prepare__", "functools.partial", "meta.mro"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.meta.ABCMetaDoc.__prepare__", "home.repos.pwc.inspect_result.mackelab_delfi.utils.meta.mro"], ["@", "classmethod", "\n", "def", "__prepare__", "(", "cls", ",", "name", ",", "bases", ",", "**", "kwds", ")", ":", "\n", "        ", "classdict", "=", "super", "(", ")", ".", "__prepare__", "(", "name", ",", "bases", ",", "*", "kwds", ")", "\n", "\n", "# Inject decorators into class namespace", "\n", "classdict", "[", "'copy_ancestor_docstring'", "]", "=", "partial", "(", "\n", "_copy_ancestor_docstring", ",", "mro", "(", "*", "bases", ")", ")", "\n", "\n", "return", "classdict", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.meta.ABCMetaDoc.__new__": [[20, 39], ["type.__new__", "getattr", "RuntimeError"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.meta.ABCMetaDoc.__new__"], ["", "def", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "classdict", ")", ":", "\n", "\n", "# Decorator may not exist in class dict if the class (metaclass", "\n", "# instance) was constructed with an explicit call to `type`.", "\n", "# (cf http://bugs.python.org/issue18334)", "\n", "        ", "if", "'copy_ancestor_docstring'", "in", "classdict", ":", "\n", "\n", "# Make sure that class definition hasn't messed with decorators", "\n", "            ", "copy_impl", "=", "getattr", "(", "\n", "classdict", "[", "'copy_ancestor_docstring'", "]", ",", "'func'", ",", "None", ")", "\n", "if", "copy_impl", "is", "not", "_copy_ancestor_docstring", ":", "\n", "                ", "raise", "RuntimeError", "(", "\n", "'No copy_ancestor_docstring attribute may be created '", "\n", "'in classes using the InheritableDocstrings metaclass'", ")", "\n", "\n", "# Delete decorators from class namespace", "\n", "", "del", "classdict", "[", "'copy_ancestor_docstring'", "]", "\n", "\n", "", "return", "super", "(", ")", ".", "__new__", "(", "cls", ",", "name", ",", "bases", ",", "classdict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.meta._copy_ancestor_docstring": [[41, 61], ["RuntimeError", "getattr", "RuntimeError"], "function", ["None"], ["", "", "def", "_copy_ancestor_docstring", "(", "mro", ",", "fn", ")", ":", "\n", "    ", "\"\"\"Decorator to set docstring for *fn* from *mro*\n\n    Source: http://code.activestate.com/recipes/578587-inherit-method-docstrings-without-breaking-decorat/\n    \"\"\"", "\n", "if", "fn", ".", "__doc__", "is", "not", "None", ":", "\n", "        ", "raise", "RuntimeError", "(", "'Function already has docstring'", ")", "\n", "\n", "# Search for docstring in superclass", "\n", "", "for", "cls", "in", "mro", ":", "\n", "        ", "super_fn", "=", "getattr", "(", "cls", ",", "fn", ".", "__name__", ",", "None", ")", "\n", "if", "super_fn", "is", "None", ":", "\n", "            ", "continue", "\n", "", "fn", ".", "__doc__", "=", "super_fn", ".", "__doc__", "\n", "break", "\n", "", "else", ":", "\n", "        ", "raise", "RuntimeError", "(", "\"Can't inherit docstring for %s: method does not \"", "\n", "\"exist in superclass\"", "%", "fn", ".", "__name__", ")", "\n", "\n", "", "return", "fn", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.meta.mro": [[63, 97], ["list", "res.append", "list", "list", "filter", "tuple", "TypeError"], "function", ["None"], ["", "def", "mro", "(", "*", "bases", ")", ":", "\n", "    ", "\"\"\"Calculate the Method Resolution Order of bases using the C3 algorithm.\n\n    Suppose you intended creating a class K with the given base classes. This\n    function returns the MRO which K would have, *excluding* K itself (since\n    it doesn't yet exist), as if you had actually created the class.\n\n    Another way of looking at this, if you pass a single class K, this will\n    return the linearization of K (the MRO of K, *including* itself).\n\n    Source: http://code.activestate.com/recipes/577748-calculate-the-mro-of-a-class/\n    \"\"\"", "\n", "seqs", "=", "[", "list", "(", "C", ".", "__mro__", ")", "for", "C", "in", "bases", "]", "+", "[", "list", "(", "bases", ")", "]", "\n", "res", "=", "[", "]", "\n", "while", "True", ":", "\n", "        ", "non_empty", "=", "list", "(", "filter", "(", "None", ",", "seqs", ")", ")", "\n", "if", "not", "non_empty", ":", "\n", "# Nothing left to process, we're done.", "\n", "            ", "return", "tuple", "(", "res", ")", "\n", "", "for", "seq", "in", "non_empty", ":", "# Find merge candidates among seq heads.", "\n", "            ", "candidate", "=", "seq", "[", "0", "]", "\n", "not_head", "=", "[", "s", "for", "s", "in", "non_empty", "if", "candidate", "in", "s", "[", "1", ":", "]", "]", "\n", "if", "not_head", ":", "\n", "# Reject the candidate.", "\n", "                ", "candidate", "=", "None", "\n", "", "else", ":", "\n", "                ", "break", "\n", "", "", "if", "not", "candidate", ":", "\n", "            ", "raise", "TypeError", "(", "\"inconsistent hierarchy, no C3 MRO is possible\"", ")", "\n", "", "res", ".", "append", "(", "candidate", ")", "\n", "for", "seq", "in", "non_empty", ":", "\n", "# Remove candidate.", "\n", "            ", "if", "seq", "[", "0", "]", "==", "candidate", ":", "\n", "                ", "del", "seq", "[", "0", "]", "\n", "", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.BoxConstraintConditionalAutoregressiveFlow.BoxConstraintConditionalAutoregressiveFlow.__init__": [[20, 43], ["BoxConstraintConditionalAutoregressiveFlow.sym_sig_inv", "snl.ml.models.mafs.ConditionalMaskedAutoregressiveFlow.__init__", "theano.clone", "theano.clone", "theano.clone", "theano.clone", "theano.matrix", "theano.matrix", "theano.sum", "theano.sum", "theano.log", "theano.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.BoxConstraintConditionalAutoregressiveFlow.sym_sig_inv", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["\t", "def", "__init__", "(", "self", ",", "n_inputs", ",", "n_outputs", ",", "n_hiddens", ",", "act_fun", ",", "n_mades", ",", "\n", "upper", ",", "lower", ",", "\n", "batch_norm", "=", "True", ",", "output_order", "=", "'sequential'", ",", "mode", "=", "'sequential'", ",", "\n", "input", "=", "None", ",", "output", "=", "None", ",", "rng", "=", "np", ".", "random", ")", ":", "\n", "\n", "\t\t", "y", "=", "tt", ".", "matrix", "(", "'y'", ",", "dtype", "=", "dtype", ")", "if", "output", "is", "None", "else", "output", "\n", "\n", "self", ".", "upper", ",", "self", ".", "lower", "=", "upper", ",", "lower", "# add some checks", "\n", "self", ".", "diff", "=", "self", ".", "upper", "-", "self", ".", "lower", "\n", "\n", "y_scaled", "=", "(", "y", "-", "self", ".", "lower", ")", "/", "self", ".", "diff", "\n", "y_sig", "=", "sym_sig_inv", "(", "y_scaled", ")", "# (logit-) transformed y", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "n_inputs", "=", "n_inputs", ",", "n_outputs", "=", "n_outputs", ",", "\n", "n_hiddens", "=", "n_hiddens", ",", "act_fun", "=", "act_fun", ",", "n_mades", "=", "n_mades", ",", "\n", "batch_norm", "=", "batch_norm", ",", "output_order", "=", "output_order", ",", "mode", "=", "mode", ",", "\n", "input", "=", "input", ",", "output", "=", "y_sig", ",", "rng", "=", "rng", ")", "\n", "\n", "L", "=", "theano", ".", "clone", "(", "output", "=", "self", ".", "L", ",", "replace", "=", "{", "self", ".", "y", ":", "y_sig", "}", ",", "share_inputs", "=", "True", ")", "\n", "self", ".", "L", "=", "L", "-", "tt", ".", "sum", "(", "tt", ".", "log", "(", "self", ".", "diff", "*", "y_scaled", "*", "(", "1.", "-", "y_scaled", ")", ")", ",", "axis", "=", "1", ")", "\n", "self", ".", "L", ".", "name", "=", "'L'", "\n", "\n", "self", ".", "y", "=", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.BoxConstraintConditionalAutoregressiveFlow.BoxConstraintConditionalAutoregressiveFlow.gen": [[45, 50], ["super().gen", "BoxConstraintConditionalAutoregressiveFlow.sig"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.utils.BoxConstraintConditionalAutoregressiveFlow.sig"], ["", "def", "gen", "(", "self", ",", "x", ",", "n_samples", "=", "None", ",", "u", "=", "None", ",", "rng", "=", "np", ".", "random", ")", ":", "# overwrite that one", "\n", "\n", "\t\t", "y", "=", "super", "(", ")", ".", "gen", "(", "x", "=", "x", ",", "n_samples", "=", "n_samples", ",", "u", "=", "u", ",", "rng", "=", "rng", ")", "\n", "\n", "return", "self", ".", "diff", "*", "sig", "(", "y", ")", "+", "self", ".", "lower", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.BoxConstraintConditionalAutoregressiveFlow.sym_sig_inv": [[9, 12], ["theano.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["def", "sym_sig_inv", "(", "x", ")", ":", "\n", "\n", "\t", "return", "tt", ".", "log", "(", "x", "/", "(", "1.", "-", "x", ")", ")", "# there's probably more stable implementations...", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.BoxConstraintConditionalAutoregressiveFlow.sig": [[13, 16], ["numpy.exp"], "function", ["None"], ["", "def", "sig", "(", "x", ")", ":", "\n", "\n", "\t", "return", "1.", "/", "(", "1.", "+", "np", ".", "exp", "(", "-", "x", ")", ")", "# there's probably more stable implementations...", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint": [[4, 6], ["numpy.issubdtype", "type"], "function", ["None"], ["def", "isint", "(", "x", ")", ":", "\n", "    ", "return", "np", ".", "issubdtype", "(", "type", "(", "x", ")", ",", "np", ".", "integer", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.repnewax": [[8, 12], ["numpy.expand_dims().repeat", "numpy.expand_dims"], "function", ["None"], ["", "def", "repnewax", "(", "A", ",", "n", ",", "axis", "=", "0", ")", ":", "\n", "    ", "\"\"\"Add a new axis (default 0), shifting other dimensions down. Then repeat\n    all values on this new axis n times\"\"\"", "\n", "return", "np", ".", "expand_dims", "(", "A", ",", "axis", ")", ".", "repeat", "(", "n", ",", "axis", "=", "axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.combine_trn_datasets": [[14, 21], ["len", "tuple", "numpy.minimum", "numpy.concatenate", "range"], "function", ["None"], ["", "def", "combine_trn_datasets", "(", "trn_datasets", ",", "max_inputs", "=", "None", ")", ":", "\n", "    ", "n_vars", "=", "len", "(", "trn_datasets", "[", "0", "]", ")", "\n", "if", "max_inputs", "is", "not", "None", ":", "\n", "        ", "n_vars", "=", "np", ".", "minimum", "(", "n_vars", ",", "max_inputs", ")", "\n", "", "td", "=", "[", "np", ".", "concatenate", "(", "[", "x", "[", "j", "]", "for", "x", "in", "trn_datasets", "]", ",", "axis", "=", "0", ")", "\n", "for", "j", "in", "range", "(", "n_vars", ")", "]", "\n", "return", "tuple", "(", "td", ")", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.first": [[1, 5], ["next", "iter"], "function", ["None"], ["def", "first", "(", "ordered_dict", ")", ":", "\n", "    ", "\"\"\"Returns first element of ordered dictionary\"\"\"", "\n", "key", "=", "next", "(", "iter", "(", "ordered_dict", ")", ")", "\n", "return", "ordered_dict", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last": [[7, 11], ["next", "reversed"], "function", ["None"], ["", "def", "last", "(", "ordered_dict", ")", ":", "\n", "    ", "\"\"\"Returns last element of ordered dictionary\"\"\"", "\n", "key", "=", "next", "(", "reversed", "(", "ordered_dict", ")", ")", "\n", "return", "ordered_dict", "[", "key", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.nth": [[13, 17], ["list", "ordered_dict.items"], "function", ["None"], ["", "def", "nth", "(", "ordered_dict", ",", "n", ")", ":", "\n", "    ", "\"\"\"Returns nth element of ordered dictionary\"\"\"", "\n", "key_val", "=", "list", "(", "ordered_dict", ".", "items", "(", ")", ")", "[", "n", "]", "\n", "return", "key_val", "[", "1", "]", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.no_tqdm.__enter__": [[5, 10], ["blank"], "methods", ["None"], ["    ", "def", "__enter__", "(", "self", ")", ":", "\n", "        ", "class", "blank", "(", "object", ")", ":", "\n", "            ", "def", "update", "(", "self", ",", "x", ")", ":", "\n", "                ", "pass", "\n", "", "", "return", "blank", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.no_tqdm.__exit__": [[11, 13], ["None"], "methods", ["None"], ["", "def", "__exit__", "(", "self", ",", "type", ",", "value", ",", "traceback", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.no_tqdm.update": [[14, 16], ["None"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "i", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.progressbar": [[18, 34], ["get_ipython", "tqdm.tqdm_notebook", "tqdm.tqdm"], "function", ["None"], ["", "", "def", "progressbar", "(", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "    ", "\"\"\"Creates a tqdm instance for a notebook or command line\n\n    There is an open issue to support this as part of tqdm, see:\n    https://github.com/tqdm/tqdm/issues/234\n    https://github.com/tqdm/tqdm/issues/372\n    \"\"\"", "\n", "try", ":", "\n", "        ", "from", "IPython", "import", "get_ipython", "\n", "from", "ipywidgets", "import", "FloatProgress", "\n", "ipython", "=", "get_ipython", "(", ")", "\n", "if", "not", "ipython", "or", "ipython", ".", "__class__", ".", "__name__", "!=", "'ZMQInteractiveShell'", ":", "\n", "            ", "raise", "RuntimeError", "\n", "", "return", "tqdm_notebook", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "except", "BaseException", ":", "\n", "        ", "return", "tqdm", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.sbc.SBC.__init__": [[4, 20], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "generator", ",", "inf", ",", "f", ")", ":", "\n", "        ", "\"\"\" Simulation-based calibration\n\n        Parameters\n        ----------\n        generator : generator instance\n            Generator instance\n        inf : inference instance\n            Infernece instance\n        f : test-function\n            Test-function (maps parameters into test statistics).\n            Has to be appliable to N x dim(theta) data matrices.\n        \"\"\"", "\n", "self", ".", "generator", "=", "generator", "# delfi generator object", "\n", "self", ".", "inf", "=", "inf", "# delfi inference object", "\n", "self", ".", "f", "=", "f", "# test-function (maps x->f(x))", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.sbc.SBC.sample_full": [[21, 24], ["sbc.SBC.generator.gen"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "sample_full", "(", "self", ",", "N", ")", ":", "\n", "        ", "out", "=", "self", ".", "generator", ".", "gen", "(", "N", ")", "# will sample from generator.proposal unless it's None", "\n", "return", "out", "[", "0", "]", ",", "out", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.sbc.SBC.get_conditional": [[25, 27], ["sbc.SBC.inf.predict_uncorrected"], "methods", ["None"], ["", "def", "get_conditional", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "inf", ".", "predict_uncorrected", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.sbc.SBC.test": [[28, 48], ["numpy.empty", "range", "sbc.SBC.sample_full", "sbc.SBC.f", "sbc.SBC.f().reshape", "sbc.SBC.get_conditional", "sbc.SBC.f", "numpy.sum", "sbc.SBC.gen", "sbc.SBC.f"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.sbc.SBC.sample_full", "home.repos.pwc.inspect_result.mackelab_delfi.utils.sbc.SBC.get_conditional", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "test", "(", "self", ",", "N", ",", "L", ",", "data", "=", "None", ")", ":", "\n", "\n", "        ", "data", "=", "self", ".", "sample_full", "(", "N", ")", "if", "data", "is", "None", "else", "data", "\n", "assert", "data", "[", "0", "]", ".", "ndim", "==", "2", "\n", "N", "=", "data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "dim", "=", "self", ".", "f", "(", "data", "[", "0", "]", "[", ":", "1", ",", ":", "]", ")", ".", "size", "\n", "\n", "res", "=", "np", ".", "empty", "(", "(", "N", ",", "dim", ")", ")", "\n", "\n", "for", "i", "in", "range", "(", "N", ")", ":", "\n", "            ", "f0", "=", "self", ".", "f", "(", "data", "[", "0", "]", "[", "i", ",", ":", "]", ")", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "p", "=", "self", ".", "get_conditional", "(", "data", "[", "1", "]", "[", "i", ",", ":", "]", ")", "\n", "\n", "batch", "=", "self", ".", "f", "(", "p", ".", "gen", "(", "L", ")", ")", "\n", "assert", "batch", ".", "shape", "==", "(", "L", ",", "f0", ".", "size", ")", "\n", "\n", "res", "[", "i", ",", ":", "]", "=", "np", ".", "sum", "(", "f0", "<", "batch", ",", "axis", "=", "0", ")", "\n", "\n", "", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.expit_jac_logD": [[6, 9], ["scipy.special.expit", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["def", "expit_jac_logD", "(", "y", ")", ":", "\n", "    ", "x", "=", "expit", "(", "y", ")", "\n", "return", "(", "np", ".", "log", "(", "x", ")", "+", "np", ".", "log", "(", "1", "-", "x", ")", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.logit_jac_logD": [[11, 13], ["numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "logit_jac_logD", "(", "x", ")", ":", "\n", "    ", "return", "-", "(", "np", ".", "log", "(", "x", ")", "+", "np", ".", "log", "(", "1", "-", "x", ")", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.normcdf_jac_logD": [[15, 17], ["numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "normcdf_jac_logD", "(", "y", ")", ":", "# log of Gaussian pdf", "\n", "    ", "return", "-", "0.5", "*", "(", "y", "**", "2", "+", "np", ".", "log", "(", "2.0", "*", "np", ".", "pi", ")", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.norminvcdf_jac_logD": [[19, 21], ["bijection.normcdf_jac_logD", "scipy.special.ndtri"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.normcdf_jac_logD"], ["", "def", "norminvcdf_jac_logD", "(", "x", ")", ":", "\n", "    ", "return", "-", "normcdf_jac_logD", "(", "ndtri", "(", "x", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.affine_map": [[23, 25], ["None"], "function", ["None"], ["", "def", "affine_map", "(", "x", ",", "s", ",", "o", ")", ":", "\n", "    ", "return", "x", "*", "s", "+", "o", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.inv_affine_map": [[27, 29], ["None"], "function", ["None"], ["", "def", "inv_affine_map", "(", "y", ",", "s", ",", "o", ")", ":", "\n", "    ", "return", "(", "y", "-", "o", ")", "/", "s", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.affine_jac_logD": [[31, 35], ["numpy.full", "numpy.log().sum", "numpy.log().sum", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "affine_jac_logD", "(", "x", ",", "s", ")", ":", "\n", "    ", "if", "x", ".", "ndim", "==", "1", ":", "\n", "        ", "return", "np", ".", "log", "(", "s", ")", ".", "sum", "(", ")", "\n", "", "return", "np", ".", "full", "(", "x", ".", "shape", "[", ":", "-", "1", "]", ",", "np", ".", "log", "(", "s", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.inv_affine_jac_logD": [[37, 41], ["numpy.full", "numpy.log().sum", "numpy.log().sum", "numpy.log", "numpy.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "inv_affine_jac_logD", "(", "y", ",", "s", ")", ":", "\n", "    ", "if", "y", ".", "ndim", "==", "1", ":", "\n", "        ", "return", "-", "np", ".", "log", "(", "s", ")", ".", "sum", "(", ")", "\n", "", "return", "np", ".", "full", "(", "y", ".", "shape", "[", ":", "-", "1", "]", ",", "-", "np", ".", "log", "(", "s", ")", ".", "sum", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.named_bijection": [[43, 74], ["name.lower.lower", "kwargs[].copy", "kwargs[].copy", "functools.partial", "functools.partial", "functools.partial", "functools.partial", "ValueError"], "function", ["None"], ["", "def", "named_bijection", "(", "name", ",", "**", "kwargs", ")", ":", "\n", "    ", "name", "=", "name", ".", "lower", "(", ")", "\n", "\n", "if", "name", "==", "'logit'", ":", "\n", "\n", "        ", "f", "=", "logit", "\n", "finv", "=", "expit", "\n", "f_jac_logD", "=", "logit_jac_logD", "\n", "finv_jac_logD", "=", "expit_jac_logD", "\n", "\n", "", "elif", "name", "==", "'affine'", ":", "\n", "\n", "        ", "s", "=", "kwargs", "[", "'scale'", "]", ".", "copy", "(", ")", "\n", "o", "=", "kwargs", "[", "'offset'", "]", ".", "copy", "(", ")", "\n", "\n", "f", "=", "partial", "(", "affine_map", ",", "s", "=", "s", ",", "o", "=", "o", ")", "\n", "finv", "=", "partial", "(", "inv_affine_map", ",", "s", "=", "s", ",", "o", "=", "o", ")", "\n", "f_jac_logD", "=", "partial", "(", "affine_jac_logD", ",", "s", "=", "s", ")", "\n", "finv_jac_logD", "=", "partial", "(", "inv_affine_jac_logD", ",", "s", "=", "s", ")", "\n", "\n", "", "elif", "name", "==", "'norminvcdf'", ":", "\n", "\n", "        ", "f", "=", "ndtri", "\n", "finv", "=", "ndtr", "\n", "f_jac_logD", "=", "norminvcdf_jac_logD", "\n", "finv_jac_logD", "=", "normcdf_jac_logD", "\n", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "'unknown bijection: {0}'", ".", "format", "(", "name", ")", ")", "\n", "\n", "", "return", "f", ",", "finv", ",", "f_jac_logD", ",", "finv_jac_logD", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.flow.normalize_cmaf": [[6, 52], ["isinstance", "numpy.repeat", "numpy.full", "numpy.random.randomstate", "enumerate", "numpy.random.RandomState", "ConditionalMaskedAutoregressiveFlow", "delfi.neuralnet.loss.lossfunc.snpe_loss_prior_as_proposal", "delfi.neuralnet.Trainer.Trainer", "delfi.neuralnet.Trainer.Trainer.train", "cmaf.gen", "f_accept"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.snpe_loss_prior_as_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["def", "normalize_cmaf", "(", "cmaf", ",", "f_accept", ",", "xs", ",", "n_samples", "=", "10", ",", "seed", "=", "None", ",", "val_frac", "=", "0.1", ",", "\n", "minibatch", "=", "100", ",", "epochs", "=", "200", ",", "verbose", "=", "False", ",", "stop_on_nan", "=", "False", ")", ":", "\n", "    ", "from", "snl", ".", "ml", ".", "models", ".", "mafs", "import", "ConditionalMaskedAutoregressiveFlow", "\n", "assert", "isinstance", "(", "cmaf", ",", "ConditionalMaskedAutoregressiveFlow", ")", "\n", "\n", "# first, sample from the existing MAF and apply our acceptance criterion", "\n", "xs", "=", "np", ".", "repeat", "(", "xs", ",", "n_samples", ",", "axis", "=", "0", ")", "\n", "thetas", "=", "np", ".", "full", "(", "xs", ".", "shape", ",", "np", ".", "nan", ")", "\n", "rng", "=", "np", ".", "random", ".", "randomstate", "(", "seed", "=", "seed", ")", "\n", "\n", "jj", "=", "0", "# index into final array of thetas", "\n", "for", "i", ",", "x", "in", "enumerate", "(", "xs", ")", ":", "\n", "        ", "n_accepted", "=", "0", "\n", "while", "n_accepted", "<", "n_samples", ":", "\n", "            ", "next_thetas", "=", "cmaf", ".", "gen", "(", "x", "=", "x", ",", "n_samples", "=", "n_samples", "-", "n_accepted", ",", "rng", "=", "rng", ")", "\n", "for", "theta", "in", "next_thetas", ":", "\n", "                ", "if", "not", "f_accept", "(", "theta", ")", ":", "\n", "                    ", "continue", "\n", "", "thetas", "[", "jj", ",", ":", "]", "=", "theta", "\n", "n_accepted", "+=", "1", "\n", "jj", "+=", "1", "\n", "\n", "# create a new MAF", "\n", "", "", "", "newrng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "cmaf_new", "=", "ConditionalMaskedAutoregressiveFlow", "(", "\n", "n_inputs", "=", "cmaf", ".", "n_inputs", ",", "\n", "n_outputs", "=", "cmaf", ".", "n_outputs", ",", "\n", "n_hiddens", "=", "cmaf", ".", "n_hiddens", ",", "\n", "act_fun", "=", "cmaf", ".", "act_fun", ",", "\n", "n_mades", "=", "cmaf", ".", "n_mades", ",", "\n", "batch_norm", "=", "cmaf", ".", "batch_norm", ",", "\n", "mode", "=", "cmaf", ".", "mode", ",", "\n", "input", "=", "None", ",", "# is this ok?", "\n", "output", "=", "None", ",", "# is this ok?", "\n", "rng", "=", "newrng", ",", "\n", "output_order", "=", "cmaf", ".", "output_order", ")", "# hope this is ok?", "\n", "\n", "# train network by directly maximizing q(\\theta | x)", "\n", "loss", ",", "trn_inputs", "=", "snpe_loss_prior_as_proposal", "(", "cmaf", ",", "svi", "=", "False", ")", "\n", "trn_data", "=", "(", "thetas", ",", "xs", ")", "\n", "\n", "t", "=", "Trainer", "(", "network", "=", "cmaf", ",", "loss", "=", "loss", ",", "trn_data", "=", "trn_data", ",", "\n", "trn_inputs", "=", "trn_inputs", ",", "seed", "=", "seed", "+", "5", ")", "\n", "log", "=", "t", ".", "train", "(", "epochs", "=", "epochs", ",", "minibatch", "=", "minibatch", ",", "\n", "verbose", "=", "verbose", ",", "stop_on_nan", "=", "stop_on_nan", ",", "val_frac", "=", "val_frac", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.delfi2snl.SNLprior.__init__": [[21, 23], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "delfi_prior", ")", ":", "\n", "        ", "self", ".", "delfi_prior", "=", "delfi_prior", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.delfi2snl.SNLprior.gen": [[24, 50], ["delfi2snl.SNLprior.delfi_prior.gen"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "gen", "(", "self", ",", "n_samples", "=", "None", ",", "rng", "=", "None", ")", ":", "\n", "        ", "\"\"\"Method to generate samples\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate\n        rng : random stream\n            Optional method to set rng (used by SNL)\n\n        Returns\n        -------\n        n_samples x self.ndim if n_samples>1, else (self.ndim,)\n        \"\"\"", "\n", "if", "not", "rng", "is", "None", ":", "\n", "            ", "self", ".", "delfi_prior", ".", "rng", "=", "rng", "\n", "\n", "", "if", "n_samples", "is", "None", ":", "\n", "            ", "one_sample", "=", "True", "\n", "n_samples", "=", "1", "\n", "", "else", ":", "\n", "            ", "one_sample", "=", "False", "\n", "\n", "", "samples", "=", "self", ".", "delfi_prior", ".", "gen", "(", "n_samples", ")", "\n", "\n", "return", "samples", "[", "0", "]", "if", "one_sample", "else", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.delfi2snl.SNLprior.eval": [[51, 72], ["numpy.asarray", "delfi2snl.SNLprior.delfi_prior.eval", "delfi2snl.SNLprior.eval"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "\"\"\"Method to evaluate pdf\n\n        Parameters\n        ----------\n        x : int or list or np.array\n            Rows are inputs to evaluate at\n        ii : list\n            A list of indices specifying which marginal to evaluate.\n            If None, the joint pdf is evaluated\n        log : bool, defaulting to True\n            If True, the log pdf is evaluated\n\n        Returns\n        -------\n        array (if more than one datapoint x), else scalar\n        \"\"\"", "\n", "x", "=", "np", ".", "asarray", "(", "x", ")", "\n", "if", "x", ".", "ndim", "==", "1", ":", "\n", "            ", "return", "self", ".", "eval", "(", "x", "[", "np", ".", "newaxis", ",", ":", "]", ",", "ii", ",", "log", ")", "[", "0", "]", "\n", "", "return", "self", ".", "delfi_prior", ".", "eval", "(", "x", "=", "x", ",", "ii", "=", "ii", ",", "log", "=", "log", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.delfi2snl.SNLmodel.__init__": [[93, 96], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "delfi_model", ",", "summary", ")", ":", "\n", "        ", "self", ".", "delfi_model", "=", "delfi_model", "\n", "self", ".", "summary", "=", "summary", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.delfi2snl.SNLmodel.gen": [[97, 143], ["delfi2snl.SNLmodel.iterate_minibatches", "numpy.array", "numpy.array", "stats.squeeze.squeeze.squeeze", "delfi2snl.SNLmodel.delfi_model.gen", "delfi2snl.SNLmodel.process_batch", "range"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.iterate_minibatches", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.process_batch"], ["", "def", "gen", "(", "self", ",", "ps", ",", "rng", "=", "None", ",", "skip_feedback", "=", "False", ",", "minibatch", "=", "50", ")", ":", "\n", "        ", "\"\"\"Run forward model given parameters\n\n        Parameters\n        ----------\n        ps: array\n            Parameters to simulate from. (n_sampled, n_params) or (n_params,)\n        rng : random stream\n            Optional method to set rng (used by SNL)\n\n        Returns\n        -------\n        stats : n_samples x n_summary, or n_summary array\n            Summary statistics of data\n        \"\"\"", "\n", "\n", "if", "rng", "is", "not", "None", ":", "\n", "            ", "self", ".", "delfi_model", ".", "rng", "=", "rng", "\n", "\n", "# support one_sample coming from the (proposal prior):", "\n", "", "if", "ps", ".", "ndim", ">", "1", ":", "\n", "            ", "params", "=", "[", "ps", "[", "i", "]", "for", "i", "in", "range", "(", "ps", ".", "shape", "[", "0", "]", ")", "]", "\n", "", "else", ":", "\n", "            ", "params", "=", "[", "ps", "]", "\n", "\n", "# Run forward model for params (in batches)", "\n", "", "final_params", "=", "[", "]", "\n", "final_stats", "=", "[", "]", "# list of summary stats", "\n", "for", "params_batch", "in", "self", ".", "iterate_minibatches", "(", "params", ",", "minibatch", ")", ":", "\n", "\n", "# run forward model for all params, each n_reps times", "\n", "            ", "result", "=", "self", ".", "delfi_model", ".", "gen", "(", "params_batch", ",", "n_reps", "=", "1", ",", "pbar", "=", "None", ")", "\n", "\n", "stats", ",", "params", "=", "self", ".", "process_batch", "(", "params_batch", ",", "\n", "result", ",", "skip_feedback", "=", "skip_feedback", ")", "\n", "final_params", "+=", "params", "\n", "final_stats", "+=", "stats", "\n", "\n", "# n_samples x n_reps x dim theta", "\n", "", "params", "=", "np", ".", "array", "(", "final_params", ")", "\n", "\n", "# n_samples x n_reps x dim summary stats", "\n", "stats", "=", "np", ".", "array", "(", "final_stats", ")", "\n", "stats", "=", "stats", ".", "squeeze", "(", ")", "# already supports 'one_sample' !", "\n", "\n", "return", "stats", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp": [[7, 10], ["theano.max", "theano.log", "theano.sum", "theano.exp"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["def", "MyLogSumExp", "(", "x", ",", "axis", "=", "None", ")", ":", "\n", "    ", "x_max", "=", "tt", ".", "max", "(", "x", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", "\n", "return", "tt", ".", "log", "(", "tt", ".", "sum", "(", "tt", ".", "exp", "(", "x", "-", "x_max", ")", ",", "axis", "=", "axis", ",", "keepdims", "=", "True", ")", ")", "+", "x_max", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.mog_LL": [[12, 51], ["symbolic.MyLogSumExp", "numpy.log", "zip", "zip", "theano.stack", "symbolic.tensorQF_chol", "symbolic.tensorQF"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorQF_chol", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorQF"], ["", "def", "mog_LL", "(", "y", ",", "la", ",", "ms", ",", "Ps", ",", "ldetPs", ",", "from_cholesky", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate log-likelihood of data points y for a MoG\n\n    Parameters\n    ----------\n    y : 2D tensor (N_data x N_dim)\n        data points at which to evaluate the MoG\n    la : 2D tensor (N_data x N_components)\n        logs of mixture coefficients\n    ms : N_components-element list of 2D tensors (N_data x N_dim)\n        Mixture means\n    Ps : N_components-element list of 3D tensors (N_data x N_dim x N_dim)\n        Mixture precisions\n    ldetPs : N_components-element list of 1D tensors (N_data)\n        Mixture precision log determinants\n    from_cholesky: bool\n        Whether to instead interpret Ps as Cholesky factors of precisions,\n        such that the precision of the j-th component for the -th data point is\n        dot(Ps[j][i,:,:].T, Ps[j][i,:,:])\n\n    Returns\n    -------\n    LL : 1D tensor (N_data)\n        log-likelihood of MoG at the provided data points\n    \"\"\"", "\n", "# data likelihood for each Gaussian component (except for scale factor)", "\n", "if", "from_cholesky", ":", "\n", "        ", "lps", "=", "[", "-", "0.5", "*", "tensorQF_chol", "(", "P", ",", "y", "-", "m", ")", "+", "ldetP", "\n", "for", "m", ",", "P", ",", "ldetP", "in", "zip", "(", "ms", ",", "Ps", ",", "ldetPs", ")", "]", "\n", "", "else", ":", "\n", "        ", "lps", "=", "[", "-", "0.5", "*", "(", "tensorQF", "(", "P", ",", "y", "-", "m", ")", "-", "ldetP", ")", "\n", "for", "m", ",", "P", ",", "ldetP", "in", "zip", "(", "ms", ",", "Ps", ",", "ldetPs", ")", "]", "\n", "\n", "# include missing scale factor", "\n", "", "logpdf_offset", "=", "-", "0.5", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", "*", "y", ".", "shape", "[", "1", "]", "\n", "\n", "# add up components' Gauss pdfs, apply missing factor, stay in log domain", "\n", "return", "MyLogSumExp", "(", "tt", ".", "stack", "(", "lps", ",", "axis", "=", "1", ")", "+", "la", ",", "axis", "=", "1", ")", "+", "logpdf_offset", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.invert_each": [[53, 60], ["symbolic.batched_matrix_op", "theano.nlinalg.MatrixInverse"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.batched_matrix_op"], ["", "def", "invert_each", "(", "A", ")", ":", "\n", "    ", "\"\"\"\n    Invert a set of matrices stored in an N-D array. The rows and columns of\n    each matrix must correspond to the last 2 dimensions of the array, which\n    must be equal.\n    \"\"\"", "\n", "return", "batched_matrix_op", "(", "A", ",", "tt", ".", "nlinalg", ".", "MatrixInverse", "(", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.det_each": [[62, 70], ["symbolic.batched_matrix_op", "theano.nlinalg.Det", "theano.log"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.batched_matrix_op", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "det_each", "(", "A", ",", "log", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Calculate determinants for a set of matrices stored in an N-D array. The\n    rows and columns of each matrix must correspond to the last 2 dimensions of\n    the array, which must be equal.\n    \"\"\"", "\n", "D", "=", "batched_matrix_op", "(", "A", ",", "tt", ".", "nlinalg", ".", "Det", "(", ")", ",", "0", ")", "\n", "return", "tt", ".", "log", "(", "D", ")", "if", "log", "else", "D", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.cholesky_each": [[72, 81], ["symbolic.batched_matrix_op", "theano.Cholesky"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.batched_matrix_op"], ["", "def", "cholesky_each", "(", "A", ")", ":", "\n", "    ", "\"\"\"\n    Calculate cholesky factorizations for a set of positive definite matrices.\n\n    :param A: Array of input matrices. The rows and columns of each matrix must correspond to the last 2 dimensions of\n    A, which must be equal.\n    :return: cholesky factors\n    \"\"\"", "\n", "return", "batched_matrix_op", "(", "A", ",", "slinalg", ".", "Cholesky", "(", ")", ",", "2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.batched_matrix_op": [[83, 96], ["A.reshape", "theano.scan", "theano.scan", "theano.scan", "theano.join", "OpB.reshape", "theano.prod", "Op"], "function", ["None"], ["", "def", "batched_matrix_op", "(", "A", ",", "Op", ",", "Op_output_ndim", ",", "allow_gc", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Apply a unary operator to a set of matrices stored in an N-D array (N > 2).\n    The rows and columns of each matrix must correspond to the last 2\n    dimensions of the array. Op_output_ndim should be 0 for a scalar output, 1\n    for a vector, 2 for a matrix, etc.\n    \"\"\"", "\n", "sB", "=", "(", "tt", ".", "prod", "(", "A", ".", "shape", "[", ":", "-", "2", "]", ")", ",", "A", ".", "shape", "[", "-", "2", "]", ",", "A", ".", "shape", "[", "-", "1", "]", ")", "\n", "B", "=", "A", ".", "reshape", "(", "sB", ",", "ndim", "=", "3", ")", "\n", "OpB", ",", "_", "=", "theano", ".", "scan", "(", "fn", "=", "lambda", "X", ":", "Op", "(", "X", ")", ",", "allow_gc", "=", "allow_gc", ",", "sequences", "=", "B", ")", "\n", "ndim_out", "=", "(", "A", ".", "ndim", "-", "2", ")", "+", "Op_output_ndim", "\n", "sOpA", "=", "tt", ".", "join", "(", "0", ",", "A", ".", "shape", "[", ":", "-", "2", "]", ",", "OpB", ".", "shape", "[", "1", ":", "]", ")", "\n", "return", "OpB", ".", "reshape", "(", "sOpA", ",", "ndim", "=", "ndim_out", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN": [[98, 112], ["theano.vector", "theano.matrix", "theano.tensor3", "theano.tensor4"], "function", ["None"], ["", "def", "tensorN", "(", "N", ",", "name", "=", "None", ",", "dtype", "=", "theano", ".", "config", ".", "floatX", ")", ":", "\n", "    ", "\"\"\"\n    Return a tensor of the specified dimension.\n    \"\"\"", "\n", "if", "N", "==", "1", ":", "\n", "        ", "return", "tt", ".", "vector", "(", "name", "=", "name", ",", "dtype", "=", "dtype", ")", "\n", "", "if", "N", "==", "2", ":", "\n", "        ", "return", "tt", ".", "matrix", "(", "name", "=", "name", ",", "dtype", "=", "dtype", ")", "\n", "", "elif", "N", "==", "3", ":", "\n", "        ", "return", "tt", ".", "tensor3", "(", "name", "=", "name", ",", "dtype", "=", "dtype", ")", "\n", "", "elif", "N", "==", "4", ":", "\n", "        ", "return", "tt", ".", "tensor4", "(", "name", "=", "name", ",", "dtype", "=", "dtype", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorQF": [[114, 124], ["theano.sum", "theano.sum", "x.dimshuffle"], "function", ["None"], ["", "", "def", "tensorQF", "(", "A", ",", "x", ")", ":", "\n", "    ", "\"\"\"\n    Symbolically evaluate quadratic form with matrix A on vector x.\n\n    The first dimensions of A and x range over \"data points\", in the sense that\n    dot(dot(x[i, :], A[i, :, :]), x[i, :]) is evaluated for each i.\n\n    The returned tensor will be 1 dimensional\n    \"\"\"", "\n", "return", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "x", ".", "dimshuffle", "(", "[", "0", ",", "'x'", ",", "1", "]", ")", "*", "A", ",", "axis", "=", "2", ")", "*", "x", ",", "axis", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorQF_chol": [[126, 133], ["theano.sum", "theano.sum", "x.dimshuffle"], "function", ["None"], ["", "def", "tensorQF_chol", "(", "U", ",", "x", ")", ":", "\n", "    ", "\"\"\"\n    Symbolicaly evaluate quadratic form with matrix dot(U^T, U) on vector x.\n    This will usually be called on a U resulting from a Cholesky factorization.\n    See tensorQF for further details.\n    \"\"\"", "\n", "return", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "x", ".", "dimshuffle", "(", "[", "0", ",", "'x'", ",", "1", "]", ")", "*", "U", ",", "axis", "=", "2", ")", "**", "2", ",", "axis", "=", "1", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.rm_docstring_from_source": [[35, 56], ["source.split.split", "source.split.split", "range", "len", "len", "len", "len", "source[].lstrip"], "function", ["None"], ["def", "rm_docstring_from_source", "(", "source", ")", ":", "\n", "    ", "\"\"\"\n    Remote the docstring from the source code of a function or a class\n\n    **Parameters**\n    > **source:** `str` -- Source code of a function or a class\n\n    **Returns**\n    > `str` -- Source code of a class without docstring\n    \"\"\"", "\n", "source", "=", "source", ".", "split", "(", "'\"\"\"'", ")", "\n", "if", "len", "(", "source", ")", ">", "1", ":", "\n", "        ", "del", "source", "[", "1", "]", "# remove docstring", "\n", "", "source", "=", "\"\"", ".", "join", "(", "source", ")", "\n", "# to handle intendation inside functions and classes", "\n", "source", "=", "source", ".", "split", "(", "\"\\n\"", ")", "\n", "nb_indent", "=", "len", "(", "source", "[", "0", "]", ")", "-", "len", "(", "source", "[", "0", "]", ".", "lstrip", "(", ")", ")", "\n", "for", "i", "in", "range", "(", "len", "(", "source", ")", ")", ":", "\n", "        ", "source", "[", "i", "]", "=", "\"\\t\"", "+", "source", "[", "i", "]", "[", "nb_indent", ":", "]", "\n", "", "source", "=", "\"\\n\"", ".", "join", "(", "source", ")", "\n", "return", "source", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_fun": [[58, 92], ["automacdoc.rm_docstring_from_source", "inspect.signature", "inspect.getmodule", "inspect.getmodule", "inspect.getdoc", "inspect.getsource", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.rm_docstring_from_source"], ["", "def", "create_fun", "(", "name", ":", "str", ",", "obj", ",", "ignore_prefix_function", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Generate a dictionnary that contains the information about a function\n\n    **Parameters**\n    > **name:** `str` -- name of the function as returned by `inspect.getmembers`\n    > **obj:** `object` -- object of the function as returned by `inspect.getmembers`\n    > **ignore_prefix_function:** `str` -- *None* -- precise the prefix of function names to ignore\n\n    **Returns**\n    > `dict` -- with keys:\n    >  - *name*, *obj* -- the function name and object as returned by `inspect.getmembers`\n    >  - *module* -- name of the module\n    >  - *path* -- path of the module file\n    >  - *doc* -- docstring of the function\n    >  - *source* -- source code of the function\n    >  - *args* -- arguments of the function as a `inspect.signature` object\n    \"\"\"", "\n", "\n", "if", "(", "\n", "ignore_prefix_function", "is", "not", "None", "\n", "and", "name", "[", ":", "len", "(", "ignore_prefix_function", ")", "]", "==", "ignore_prefix_function", "\n", ")", ":", "\n", "        ", "return", "None", "\n", "\n", "", "fun", "=", "{", "}", "\n", "fun", "[", "\"name\"", "]", "=", "name", "\n", "fun", "[", "\"obj\"", "]", "=", "obj", "\n", "fun", "[", "\"module\"", "]", "=", "inspect", ".", "getmodule", "(", "obj", ")", ".", "__name__", "\n", "fun", "[", "\"path\"", "]", "=", "inspect", ".", "getmodule", "(", "obj", ")", ".", "__file__", "\n", "fun", "[", "\"doc\"", "]", "=", "inspect", ".", "getdoc", "(", "obj", ")", "or", "\"\"", "\n", "fun", "[", "\"source\"", "]", "=", "rm_docstring_from_source", "(", "inspect", ".", "getsource", "(", "obj", ")", ")", "\n", "fun", "[", "\"args\"", "]", "=", "inspect", ".", "signature", "(", "obj", ")", "\n", "return", "fun", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_class": [[94, 131], ["automacdoc.rm_docstring_from_source", "inspect.signature", "inspect.getmodule", "inspect.getmodule", "inspect.getdoc", "inspect.getsource", "automacdoc.create_fun", "automacdoc.create_fun", "inspect.getmembers", "inspect.getmembers"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.rm_docstring_from_source", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_fun", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_fun"], ["", "def", "create_class", "(", "name", ":", "str", ",", "obj", ",", "ignore_prefix_function", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Generate a dictionary that contains the information about a class\n\n    **Parameters**\n    > **name:** `str` -- name of the class as returned by `inspect.getmembers`\n    > **obj:** `object` -- object of the class as returned by `inspect.getmembers`\n    > **ignore_prefix_function:** `str` -- *None* -- precise the prefix of function or method names to ignore\n\n    **Returns**\n    > `dict` -- with keys:\n    >  - *name*, *obj* -- the class name and object as returned by `inspect.getmembers`\n    >  - *module* -- name of the module\n    >  - *path* -- path of the module file\n    >  - *doc* -- docstring of the class\n    >  - *source* -- source code of the class\n    >  - *args* -- arguments of the class as a `inspect.signature` object\n    >  - *functions* -- list of functions that are in the class (formatted as dict)\n    >  - *methods* -- list of methods that are in the class (formatted as dict)\n    \"\"\"", "\n", "clas", "=", "{", "}", "\n", "clas", "[", "\"name\"", "]", "=", "name", "\n", "clas", "[", "\"obj\"", "]", "=", "obj", "\n", "clas", "[", "\"module\"", "]", "=", "inspect", ".", "getmodule", "(", "obj", ")", ".", "__name__", "\n", "clas", "[", "\"path\"", "]", "=", "inspect", ".", "getmodule", "(", "obj", ")", ".", "__file__", "\n", "clas", "[", "\"doc\"", "]", "=", "inspect", ".", "getdoc", "(", "obj", ")", "or", "\"\"", "\n", "clas", "[", "\"source\"", "]", "=", "rm_docstring_from_source", "(", "inspect", ".", "getsource", "(", "obj", ")", ")", "\n", "clas", "[", "\"args\"", "]", "=", "inspect", ".", "signature", "(", "obj", ")", "\n", "clas", "[", "\"functions\"", "]", "=", "[", "\n", "create_fun", "(", "n", ",", "o", ",", "ignore_prefix_function", ")", "\n", "for", "n", ",", "o", "in", "inspect", ".", "getmembers", "(", "obj", ",", "inspect", ".", "isfunction", ")", "\n", "]", "\n", "clas", "[", "\"methods\"", "]", "=", "[", "\n", "create_fun", "(", "n", ",", "o", ",", "ignore_prefix_function", ")", "\n", "for", "n", ",", "o", "in", "inspect", ".", "getmembers", "(", "obj", ",", "inspect", ".", "ismethod", ")", "\n", "]", "\n", "return", "clas", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_function": [[148, 164], ["md_file.writelines", "md_file.writelines", "function_name_md", "len", "md_file.writelines", "source_md", "doc_md"], "function", ["None"], ["def", "write_function", "(", "md_file", ",", "fun", ")", ":", "\n", "    ", "\"\"\"\n    Add the documentation of a function to a markdown file\n\n    **Parameters**\n    > **md_file:** `file` -- file object of the markdown file\n    > **fun:** `dict` -- function information organized as a dict (see `create_fun`)\n\n    \"\"\"", "\n", "if", "fun", "is", "None", ":", "\n", "        ", "return", "\n", "\n", "", "md_file", ".", "writelines", "(", "function_name_md", "(", "fun", "[", "\"name\"", "]", ",", "fun", "[", "\"args\"", "]", ")", ")", "\n", "if", "len", "(", "fun", "[", "\"doc\"", "]", ")", ">", "0", ":", "\n", "        ", "md_file", ".", "writelines", "(", "doc_md", "(", "fun", "[", "\"doc\"", "]", ")", ")", "\n", "", "md_file", ".", "writelines", "(", "source_md", "(", "fun", "[", "\"source\"", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_method": [[166, 184], ["md_file.writelines", "md_file.writelines", "method_name_md", "len", "md_file.writelines", "source_md", "method[].replace", "doc_md"], "function", ["None"], ["", "def", "write_method", "(", "md_file", ",", "method", ",", "clas", ")", ":", "\n", "    ", "\"\"\"\n    Add the documentation of a method to a markdown file\n\n    **Parameters**\n    > **md_file:** `file` -- file object of the markdown file\n    > **method:** `dict` -- method information organized as a dict (see `create_fun`)\n    > **class:** `dict` -- class information organized as a dict (see `create_fun`)\n\n    \"\"\"", "\n", "if", "method", "is", "None", ":", "\n", "        ", "return", "\n", "\n", "", "md_file", ".", "writelines", "(", "method_name_md", "(", "clas", "[", "\"name\"", "]", ",", "method", "[", "\"name\"", "]", ".", "replace", "(", "'_'", ",", "'\\_'", ")", ",", "method", "[", "\"args\"", "]", ")", ")", "\n", "\n", "if", "len", "(", "method", "[", "\"doc\"", "]", ")", ">", "0", ":", "\n", "        ", "md_file", ".", "writelines", "(", "doc_md", "(", "method", "[", "\"doc\"", "]", ")", ")", "\n", "", "md_file", ".", "writelines", "(", "source_md", "(", "method", "[", "\"source\"", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_class": [[186, 221], ["md_file.writelines", "md_file.writelines", "class_name_md", "len", "md_file.writelines", "automacdoc.write_method", "automacdoc.write_method", "clas[].replace", "doc_md"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_method", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_method"], ["", "def", "write_class", "(", "md_file", ",", "clas", ")", ":", "\n", "    ", "\"\"\"\n    Add the documentation of a class to a markdown file\n\n    **Parameters**\n    > **md_file:** `file` -- file object of the markdown file\n    > **clas:** `dict` -- class information organized as a dict (see `create_clas`)\n\n    \"\"\"", "\n", "md_file", ".", "writelines", "(", "class_name_md", "(", "clas", "[", "\"name\"", "]", ".", "replace", "(", "'_'", ",", "'\\n'", ")", ")", ")", "\n", "\n", "if", "len", "(", "clas", "[", "\"doc\"", "]", ")", ">", "0", ":", "\n", "        ", "md_file", ".", "writelines", "(", "doc_md", "(", "clas", "[", "\"doc\"", "]", ")", ")", "\n", "\n", "", "\"\"\"\n    # list of methods\n    if len(clas[\"methods\"]):\n        md_file.writelines(\"\\n**class methods:** \\n\\n\")\n        for m in clas[\"methods\"]:\n            md_file.writelines(\" - [`{0}`](#{0})\\n\".format(m[\"name\"]))\n\n            # list of functions\n    if len(clas[\"functions\"]) > 0:\n        md_file.writelines(\"\\n**class functions & static methods:** \\n\\n\")\n        for f in clas[\"functions\"]:\n            md_file.writelines(\" - [`{0}`](#{0})\\n\".format(f[\"name\"]))\n    \"\"\"", "\n", "\n", "md_file", ".", "writelines", "(", "\"\\n\"", ")", "\n", "\n", "for", "m", "in", "clas", "[", "\"methods\"", "]", ":", "\n", "        ", "write_method", "(", "md_file", ",", "m", ",", "clas", ")", "\n", "\n", "", "for", "f", "in", "clas", "[", "\"functions\"", "]", ":", "\n", "        ", "write_method", "(", "md_file", ",", "f", ",", "clas", ")", "# use write_method to get the clas prefix", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_module": [[223, 269], ["os.path.abspath", "sys.path.insert", "open", "open.close", "importlib.import_module", "automacdoc.create_class", "automacdoc.create_fun", "os.path.isdir", "os.makedirs", "automacdoc.write_class", "open.writelines", "automacdoc.write_function", "open.writelines", "ModuleNotFoundError", "inspect.getmembers", "inspect.getmembers", "os.path.dirname", "os.path.dirname", "module_import.split", "str"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_class", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_fun", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_class", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_function"], ["", "", "def", "write_module", "(", "\n", "path_to_home", ":", "str", ",", "\n", "module_import", ":", "str", ",", "\n", "path_to_md", ":", "str", ",", "\n", "ignore_prefix_function", ":", "str", "=", "None", ",", "\n", ")", ":", "\n", "    ", "\"\"\"\n    Generate a Markdown file based on the content of a Python module\n\n    **Parameters**\n    > **path_to_home:** `str` -- path to the root of the project (2 steps before the `__init__.py`)\n    > **module_import:** `str` -- module name (ex: `my_package.my_module`)\n    > **path_to_md:** `str` -- path to the output markdown file\n    > **ignore_prefix_function:** `str` -- *None* -- precise the prefix of function or method names to ignore\n\n    \"\"\"", "\n", "package_path", "=", "os", ".", "path", ".", "abspath", "(", "path_to_home", ")", "\n", "sys", ".", "path", ".", "insert", "(", "0", ",", "package_path", ")", "\n", "\n", "try", ":", "\n", "        ", "module", "=", "importlib", ".", "import_module", "(", "module_import", ",", "package", "=", "module_import", ".", "split", "(", "\".\"", ")", "[", "0", "]", ")", "\n", "", "except", "ModuleNotFoundError", "as", "error", ":", "\n", "        ", "raise", "ModuleNotFoundError", "(", "str", "(", "error", ")", "+", "\" in \"", "+", "module_import", ")", "\n", "\n", "", "clas", "=", "[", "\n", "create_class", "(", "n", ",", "o", ",", "ignore_prefix_function", ")", "\n", "for", "n", ",", "o", "in", "inspect", ".", "getmembers", "(", "module", ",", "inspect", ".", "isclass", ")", "\n", "]", "\n", "funs", "=", "[", "\n", "create_fun", "(", "n", ",", "o", ",", "ignore_prefix_function", ")", "\n", "for", "n", ",", "o", "in", "inspect", ".", "getmembers", "(", "module", ",", "inspect", ".", "isfunction", ")", "\n", "]", "\n", "\n", "if", "not", "os", ".", "path", ".", "isdir", "(", "os", ".", "path", ".", "dirname", "(", "path_to_md", ")", ")", ":", "\n", "        ", "os", ".", "makedirs", "(", "os", ".", "path", ".", "dirname", "(", "path_to_md", ")", ")", "\n", "", "md_file", "=", "open", "(", "path_to_md", ",", "\"w\"", ")", "\n", "\n", "for", "c", "in", "clas", ":", "\n", "        ", "write_class", "(", "md_file", ",", "c", ")", "\n", "md_file", ".", "writelines", "(", "\"\"\"\\n______\\n\\n\"\"\"", ")", "\n", "\n", "", "for", "f", "in", "funs", ":", "\n", "        ", "write_function", "(", "md_file", ",", "f", ")", "\n", "md_file", ".", "writelines", "(", "\"\"\"\\n______\\n\\n\"\"\"", ")", "\n", "\n", "", "md_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.get_toc_lines_from_file_path": [[271, 279], ["enumerate", "mdfile_name.split", "len", "mdfile_name.split"], "function", ["None"], ["", "def", "get_toc_lines_from_file_path", "(", "mdfile_name", ")", ":", "\n", "    ", "lines", "=", "\"\"", "\n", "for", "i", ",", "layer", "in", "enumerate", "(", "mdfile_name", ".", "split", "(", "\"/\"", ")", ")", ":", "\n", "        ", "if", "i", "+", "1", "!=", "len", "(", "mdfile_name", ".", "split", "(", "\"/\"", ")", ")", ":", "\n", "            ", "lines", "+=", "\"        \"", "*", "(", "i", "+", "1", ")", "+", "\"- \"", "+", "layer", "+", "\":\\n\"", "\n", "", "else", ":", "\n", "            ", "lines", "+=", "\"        \"", "*", "(", "i", "+", "1", ")", "+", "\"- \"", "+", "mdfile_name", "+", "\"\\n\"", "\n", "", "", "return", "lines", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_mkdocs_yaml": [[281, 316], ["open", "open.writelines", "open.close"], "function", ["None"], ["", "def", "write_mkdocs_yaml", "(", "path_to_yaml", ":", "str", ",", "project_name", ":", "str", ",", "toc", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Generate the YAML file that contains the website configs\n\n    **Parameters**\n    > **path_to_yaml:** `str` -- path to the output YAML file\n    > **project_name:** `str` -- name of the project\n    > **toc:** `str` -- the toc and the all hierarchy of the website\n    \"\"\"", "\n", "yaml_file", "=", "open", "(", "path_to_yaml", ",", "\"w\"", ")", "\n", "content", "=", "\"\"\"site_name: {}\ntheme:\n  name: 'material'\nnav:\n    - Home: index.md\n    - Reference:\n{}\nmarkdown_extensions:\n    - toc:\n        toc_depth: 3\n        permalink: True\n    - extra\n    - smarty\n    - codehilite\n    - admonition\n    - pymdownx.details\n    - pymdownx.superfences\n    - pymdownx.emoji\n    - pymdownx.inlinehilite\n    - pymdownx.magiclink\n    \"\"\"", ".", "format", "(", "\n", "project_name", ",", "toc", "\n", ")", "\n", "yaml_file", ".", "writelines", "(", "content", ")", "\n", "yaml_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_indexmd": [[319, 333], ["open", "open.writelines", "open.close"], "function", ["None"], ["", "def", "write_indexmd", "(", "path_to_indexmd", ":", "str", ",", "project_name", ":", "str", ")", ":", "\n", "    ", "\"\"\"\n    Generate the YAML file that contains the website configs\n\n    **Parameters**\n    > **path_to_indexmd:** `str` -- path to the output YAML file\n    > **project_name:** `str` -- name of the project\n    \"\"\"", "\n", "indexmd_file", "=", "open", "(", "path_to_indexmd", ",", "\"w\"", ")", "\n", "content", "=", "\"\"\"# Welcome to {0}\nThis website contains the documentation for the wonderful project {0}\n\"\"\"", ".", "format", "(", "project_name", ")", "\n", "indexmd_file", ".", "writelines", "(", "content", ")", "\n", "indexmd_file", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_doc": [[335, 395], ["os.path.abspath", "os.path.join", "os.path.dirname", "glob.glob", "os.path.join", "automacdoc.write_mkdocs_yaml", "os.path.join", "automacdoc.write_indexmd", "mainfolder.split", "os.path.abspath", "os.path.abspath.split", "mod[].replace", "os.path.join", "len", "ValueError", "automacdoc.write_module", "automacdoc.get_toc_lines_from_file_path", "os.path.isfile", "print", "platform.system", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_mkdocs_yaml", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_indexmd", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_module", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.get_toc_lines_from_file_path"], ["", "def", "write_doc", "(", "src", ":", "str", ",", "mainfolder", ":", "str", ")", ":", "\n", "# variables", "\n", "    ", "project_icon", "=", "\"code\"", "# https://material.io/tools/icons/?style=baseline", "\n", "\n", "# setting the paths variable", "\n", "project_name", "=", "mainfolder", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", "\n", "code_path", "=", "os", ".", "path", ".", "abspath", "(", "src", ")", "\n", "doc_path", "=", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "abspath", "(", "mainfolder", ")", ",", "\"docs\"", ")", "\n", "package_name", "=", "code_path", ".", "split", "(", "\"/\"", ")", "[", "-", "1", "]", "\n", "root_path", "=", "os", ".", "path", ".", "dirname", "(", "code_path", ")", "\n", "\n", "#Since windows and Linux platforms utilizes different slash in their file structure", "\n", "system_slash_style", "=", "{", "\n", "\"Windows\"", ":", "\"\\\\\"", ",", "\n", "\"Linux\"", ":", "\"/\"", "\n", "}", "\n", "\n", "# load the architecture of the module", "\n", "ign_pref_file", "=", "\"__\"", "\n", "full_list_glob", "=", "glob", ".", "glob", "(", "code_path", "+", "\"/**\"", ",", "recursive", "=", "True", ")", "\n", "list_glob", "=", "[", "\n", "p", "\n", "for", "p", "in", "full_list_glob", "\n", "if", "\"/\"", "+", "ign_pref_file", "not", "in", "p", "and", "os", ".", "path", ".", "isfile", "(", "p", ")", "and", "p", "[", "-", "3", ":", "]", "==", "\".py\"", "and", "\"__init__\"", "not", "in", "p", "\n", "]", "\n", "\n", "# write every markdown files based on the architecture", "\n", "toc", "=", "\"\"", "\n", "for", "mod", "in", "list_glob", ":", "\n", "        ", "module_name", "=", "mod", "[", "len", "(", "root_path", ")", "+", "1", ":", "-", "3", "]", ".", "replace", "(", "system_slash_style", "[", "platform", ".", "system", "(", ")", "]", ",", "\".\"", ")", "\n", "mdfile_path", "=", "os", ".", "path", ".", "join", "(", "doc_path", ",", "mod", "[", "len", "(", "code_path", ")", "+", "1", ":", "-", "3", "]", "+", "\".md\"", ")", "\n", "mdfile_name", "=", "mdfile_path", "[", "len", "(", "doc_path", ")", "+", "1", ":", "]", "\n", "try", ":", "\n", "            ", "write_module", "(", "root_path", ",", "module_name", ",", "mdfile_path", ")", "\n", "toc", "+=", "get_toc_lines_from_file_path", "(", "mdfile_name", ")", "\n", "", "except", "Exception", "as", "error", ":", "\n", "            ", "print", "(", "\"[-]Warning \"", ",", "error", ")", "\n", "\n", "", "", "if", "len", "(", "toc", ")", "==", "0", ":", "\n", "        ", "raise", "ValueError", "(", "\"All the files seems invalid\"", ")", "\n", "\n", "\n", "#removed the condition because it would'nt update the yml file in case", "\n", "#of any update in the source code", "\n", "", "yml_path", "=", "os", ".", "path", ".", "join", "(", "mainfolder", ",", "'mkdocs.yml'", ")", "\n", "write_mkdocs_yaml", "(", "yml_path", ",", "project_name", ",", "toc", ")", "\n", "\n", "index_path", "=", "os", ".", "path", ".", "join", "(", "doc_path", ",", "'index.md'", ")", "\n", "write_indexmd", "(", "index_path", ",", "project_name", ")", "\n", "\n", "\"\"\"\n    if not os.path.isfile(yml_path):\n        write_mkdocs_yaml(yml_path, project_name, toc)\n\n    index_path = os.path.join(doc_path, 'index.md')\n    if not os.path.isfile(index_path):\n        write_indexmd(index_path, project_name)\n    \"\"\"", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.GaussMixture.GaussMixture.__init__": [[8, 28], ["delfi.simulator.BaseSimulator.BaseSimulator.__init__", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", "=", "1", ",", "noise_cov", "=", "[", "1.0", ",", "0.1", "]", ",", "bimodal", "=", "False", ",", "return_abs", "=", "False", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gaussian Mixture simulator\n\n        Toy model that draws data from a mixture distribution with 2 components\n        that have mean theta and fixed noise.\n\n        Parameters\n        ----------\n        dim : int\n            Number of dimensions of parameters\n        noise_cov : list\n            Covariance of noise on observations\n        seed : int or None\n            If set, randomness is seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "dim", ",", "seed", "=", "seed", ")", "\n", "self", ".", "a", "=", "[", "0.5", ",", "0.5", "]", "# mixture weights", "\n", "self", ".", "noise_cov", "=", "[", "nc", "*", "np", ".", "eye", "(", "dim", ")", "for", "nc", "in", "noise_cov", "]", "\n", "self", ".", "bimodal", "=", "bimodal", "\n", "self", ".", "return_abs", "=", "return_abs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.GaussMixture.GaussMixture.gen_single": [[29, 46], ["numpy.asarray().reshape", "delfi.MoG().gen", "delfi.MoG().gen", "numpy.abs", "numpy.abs.reshape", "numpy.asarray", "delfi.MoG", "delfi.MoG", "GaussMixture.GaussMixture.gen_newseed", "GaussMixture.GaussMixture.gen_newseed", "range", "range"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen_single", "(", "self", ",", "param", ")", ":", "\n", "# See BaseSimulator for docstring", "\n", "        ", "param", "=", "np", ".", "asarray", "(", "param", ")", ".", "reshape", "(", "-", "1", ")", "\n", "assert", "param", ".", "ndim", "==", "1", "\n", "assert", "param", ".", "shape", "[", "0", "]", "==", "self", ".", "dim_param", "\n", "\n", "if", "self", ".", "bimodal", ":", "\n", "            ", "sample", "=", "dd", ".", "MoG", "(", "a", "=", "self", ".", "a", ",", "ms", "=", "[", "(", "-", "1", ")", "**", "p", "*", "param", "for", "p", "in", "range", "(", "2", ")", "]", ",", "\n", "Ss", "=", "self", ".", "noise_cov", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", ".", "gen", "(", "1", ")", "\n", "", "else", ":", "\n", "            ", "sample", "=", "dd", ".", "MoG", "(", "a", "=", "self", ".", "a", ",", "ms", "=", "[", "param", "for", "p", "in", "range", "(", "2", ")", "]", ",", "\n", "Ss", "=", "self", ".", "noise_cov", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", ".", "gen", "(", "1", ")", "\n", "", "if", "self", ".", "return_abs", ":", "\n", "            ", "sample", "=", "np", ".", "abs", "(", "sample", ")", "\n", "\n", "", "return", "{", "'data'", ":", "sample", ".", "reshape", "(", "-", "1", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.MoGDistractors.MoGDistractors.__init__": [[8, 46], ["delfi.simulator.BaseSimulator.BaseSimulator.__init__", "type", "type", "isinstance", "numpy.eye", "numpy.ones", "numpy.random.rand", "range", "numpy.diag", "numpy.random.rand"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", "=", "2", ",", "noise_cov", "=", "1.0", ",", "distractors", "=", "10", ",", "p_true", "=", "None", ",", "n_samples", "=", "1", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gaussian Mixture simulator\n\n        Toy model that draws data from a mixture distribution with 1 \"moving\" component that depends on the parameters,\n        and several other \"distractor\" components that do not.\n\n        Parameters\n        ----------\n        dim : int\n            Number of dimensions of parameters\n        noise_cov : float or dim X dim covariance matrix as array\n            Covariance for the moving component\n        distractors: int or MoG\n            MoG components defining the distractors. Will be generated automatically an integer (count) is given.\n        p_true: float\n            Probability that each sampled data point is NOT from a distractor. If None, mixture weights are uniform.\n        n_samples: int\n            Number of data points per simulation, concatenated\n        seed : int or None\n            If set, randomness is seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "dim", ",", "seed", "=", "seed", ")", "\n", "self", ".", "n_samples", "=", "n_samples", "\n", "if", "type", "(", "noise_cov", ")", "is", "float", ":", "\n", "            ", "noise_cov", "=", "noise_cov", "*", "np", ".", "eye", "(", "dim", ")", "\n", "", "self", ".", "noise_cov", "=", "noise_cov", "\n", "if", "type", "(", "distractors", ")", "is", "int", ":", "\n", "            ", "self", ".", "a", "=", "np", ".", "ones", "(", "distractors", ")", "/", "distractors", "\n", "self", ".", "ms", "=", "np", ".", "random", ".", "rand", "(", "distractors", ",", "dim", ")", "*", "20.0", "-", "10.0", "\n", "self", ".", "Ss", "=", "[", "0.1", "+", "0.9", "*", "np", ".", "diag", "(", "np", ".", "random", ".", "rand", "(", "dim", ")", ")", "for", "_", "in", "range", "(", "distractors", ")", "]", "\n", "", "else", ":", "\n", "            ", "assert", "isinstance", "(", "distractors", ",", "dd", ".", "MoG", ")", "\n", "self", ".", "a", "=", "distractors", ".", "a", "\n", "self", ".", "ms", "=", "[", "x", ".", "m", "for", "x", "in", "distractors", ".", "xs", "]", "\n", "self", ".", "Ss", "=", "[", "x", ".", "S", "for", "x", "in", "distractors", ".", "xs", "]", "\n", "", "if", "p_true", "is", "None", ":", "\n", "            ", "p_true", "=", "1.0", "/", "(", "self", ".", "a", ".", "size", "+", "1.0", ")", "\n", "", "self", ".", "p_true", "=", "p_true", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.MoGDistractors.MoGDistractors.gen_single": [[47, 65], ["numpy.asarray().reshape", "delfi.Gaussian", "delfi.MoG", "range", "numpy.concatenate", "numpy.asarray", "MoGDistractors.MoGDistractors.gen_newseed", "MoGDistractors.MoGDistractors.gen_newseed", "numpy.random.rand", "samples.append", "samples.append", "delfi.Gaussian.gen", "delfi.MoG.gen"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen_single", "(", "self", ",", "param", ")", ":", "\n", "# See BaseSimulator for docstring", "\n", "        ", "param", "=", "np", ".", "asarray", "(", "param", ")", ".", "reshape", "(", "-", "1", ")", "\n", "assert", "param", ".", "ndim", "==", "1", "\n", "assert", "param", ".", "shape", "[", "0", "]", "==", "self", ".", "dim_param", "\n", "\n", "q_moving", "=", "dd", ".", "Gaussian", "(", "m", "=", "param", ",", "S", "=", "self", ".", "noise_cov", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "q_distractors", "=", "dd", ".", "MoG", "(", "a", "=", "self", ".", "a", ",", "ms", "=", "self", ".", "ms", ",", "Ss", "=", "self", ".", "Ss", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n", "samples", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "self", ".", "n_samples", ")", ":", "\n", "            ", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "self", ".", "p_true", ":", "\n", "                ", "samples", ".", "append", "(", "q_moving", ".", "gen", "(", "1", ")", ")", "\n", "", "else", ":", "\n", "                ", "samples", ".", "append", "(", "q_distractors", ".", "gen", "(", "1", ")", ")", "\n", "\n", "", "", "return", "{", "'data'", ":", "np", ".", "concatenate", "(", "samples", ",", "axis", "=", "0", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.NoiseDataDimensions.NoiseDataDimensions.__init__": [[8, 34], ["delfi.simulator.BaseSimulator.BaseSimulator.__init__", "NoiseDataDimensions.NoiseDataDimensions.reseed", "NoiseDataDimensions.NoiseDataDimensions.rng.permutation", "numpy.arange", "copy.deepcopy", "copy.deepcopy"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "noise_dist", ",", "seed", "=", "None", ",", "deepcopy_inputs", "=", "True", ",", "rand_permute", "=", "True", ")", ":", "\n", "        ", "\"\"\"Gauss simulator\n\n        Toy model that draws data from a distribution centered on theta with\n        fixed noise.\n\n        Parameters\n        ----------\n        dim : int\n            Number of dimensions of parameters\n        noise_cov : float\n            Covariance of noise on observations\n        seed : int or None\n            If set, randomness is seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "model", ".", "dim_param", "+", "noise_dist", ".", "ndim", ",", "seed", "=", "seed", ")", "\n", "if", "deepcopy_inputs", ":", "\n", "            ", "model", ",", "noise_dist", "=", "deepcopy", "(", "model", ")", ",", "deepcopy", "(", "noise_dist", ")", "\n", "", "self", ".", "model", ",", "self", ".", "noise_dist", "=", "model", ",", "noise_dist", "\n", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "reseed", "(", "seed", ")", "\n", "", "if", "rand_permute", ":", "\n", "            ", "self", ".", "permutation", "=", "self", ".", "rng", ".", "permutation", "(", "self", ".", "dim_param", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "permutation", "=", "np", ".", "arange", "(", "self", ".", "dim_param", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.NoiseDataDimensions.NoiseDataDimensions.reseed": [[35, 39], ["super().reseed", "NoiseDataDimensions.NoiseDataDimensions.model.reseed", "NoiseDataDimensions.NoiseDataDimensions.noise_dist.reseed", "NoiseDataDimensions.NoiseDataDimensions.gen_newseed", "NoiseDataDimensions.NoiseDataDimensions.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "super", "(", ")", ".", "reseed", "(", "seed", ")", "\n", "self", ".", "model", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "self", ".", "noise_dist", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.NoiseDataDimensions.NoiseDataDimensions.gen_single": [[40, 51], ["numpy.asarray().reshape", "NoiseDataDimensions.NoiseDataDimensions.model.gen", "NoiseDataDimensions.NoiseDataDimensions.noise_dist.gen", "numpy.asarray", "numpy.concatenate", "NoiseDataDimensions.NoiseDataDimensions.reshape"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen_single", "(", "self", ",", "param", ")", ":", "\n", "# See BaseSimulator for docstring", "\n", "        ", "param", "=", "np", ".", "asarray", "(", "param", ")", ".", "reshape", "(", "-", "1", ")", "\n", "assert", "param", ".", "ndim", "==", "1", "\n", "assert", "param", ".", "shape", "[", "0", "]", "==", "self", ".", "dim_param", "\n", "\n", "model_sample", "=", "self", ".", "model", ".", "gen", "(", "1", ")", "\n", "noise_sample", "=", "self", ".", "noise_dist", ".", "gen", "(", "1", ")", "\n", "\n", "return", "{", "'data'", ":", "np", ".", "concatenate", "(", "(", "model_sample", ".", "reshape", "(", "-", "1", ")", ",", "noise_sample", ")", ")", "[", "self", ".", "permutation", "]", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.TwoMoons.__init__": [[30, 67], ["delfi.simulator.BaseSimulator.BaseSimulator.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mean_radius", "=", "1.0", ",", "sd_radius", "=", "0.1", ",", "baseoffset", "=", "1.0", ",", "\n", "mapfunc", "=", "None", ",", "mapfunc_inverse", "=", "None", ",", "mapfunc_Jacobian_determinant", "=", "None", ",", "# transforms noise dist.", "\n", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Two Moons simulator\n\n        Toy model that draws data from a crescent shaped mixture distribution.\n        For the default mapfunc, this leads to a bimodal posterior, with each\n        mode the same shape as the simulator's data density.\n\n        Parameters\n        ----------\n        mean_radius: float\n            Radius of curvature for each moon in the posterior\n        sd_radius: float\n            Dispersion of samples perpendicular to moon curvature\n        base_offset: float\n            Minimum separation between moons in the posterior\n        mapfunc: callable or None\n            Mapping applied to points. Default as described in Greenberg et al., 2019\n        mapfunc_inverse: callable or None\n            Inverse of mapping\n        mapfunc_Jacobian_determinant: callable or None\n            determinant of Jacobian of manfunc, used for change of variables when calculating likelihood\n        seed : int or None\n            If set, randomness is seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "2", ",", "seed", "=", "seed", ")", "\n", "self", ".", "mean_radius", "=", "mean_radius", "\n", "self", ".", "sd_radius", "=", "sd_radius", "\n", "self", ".", "baseoffset", "=", "baseoffset", "\n", "if", "mapfunc", "is", "None", ":", "\n", "            ", "self", ".", "mapfunc", "=", "default_mapfunc", "\n", "self", ".", "mapfunc_inverse", "=", "default_mapfunc_inverse", "\n", "self", ".", "mapfunc_Jacobian_determinant", "=", "default_mapfunc_Jacobian_determinant", "\n", "", "else", ":", "\n", "            ", "self", ".", "mapfunc", ",", "self", ".", "mapfunc_inverse", ",", "self", ".", "mapfunc_Jacobian_determinant", "=", "mapfunc", ",", "mapfunc_inverse", ",", "mapfunc_Jacobian_determinant", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.TwoMoons.gen_single": [[68, 79], ["numpy.asarray().reshape", "numpy.array", "TwoMoons.TwoMoons.mapfunc", "numpy.asarray", "TwoMoons.TwoMoons.rng.rand", "TwoMoons.TwoMoons.rng.randn", "numpy.sin", "numpy.cos"], "methods", ["None"], ["", "", "@", "copy_ancestor_docstring", "\n", "def", "gen_single", "(", "self", ",", "param", ")", ":", "\n", "# See BaseSimulator for docstring", "\n", "        ", "param", "=", "np", ".", "asarray", "(", "param", ")", ".", "reshape", "(", "-", "1", ")", "\n", "assert", "param", ".", "ndim", "==", "1", "\n", "assert", "param", ".", "shape", "[", "0", "]", "==", "self", ".", "dim_param", "\n", "\n", "a", "=", "np", ".", "pi", "*", "(", "self", ".", "rng", ".", "rand", "(", ")", "-", "0.5", ")", "\n", "r", "=", "self", ".", "mean_radius", "+", "self", ".", "rng", ".", "randn", "(", ")", "*", "self", ".", "sd_radius", "\n", "p", "=", "np", ".", "array", "(", "[", "r", "*", "np", ".", "cos", "(", "a", ")", "+", "self", ".", "baseoffset", ",", "r", "*", "np", ".", "sin", "(", "a", ")", "]", ")", "\n", "return", "{", "'data'", ":", "self", ".", "mapfunc", "(", "param", ",", "p", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.TwoMoons.likelihood": [[80, 96], ["TwoMoons.TwoMoons.mapfunc_inverse", "numpy.sqrt", "numpy.isfinite().all", "numpy.exp", "numpy.log", "numpy.isfinite", "numpy.imag"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "likelihood", "(", "self", ",", "param", ",", "x", ",", "log", "=", "True", ")", ":", "\n", "        ", "assert", "x", ".", "size", "==", "2", ",", "\"not yet implemented for evaluation on multiple points at once\"", "\n", "assert", "np", ".", "isfinite", "(", "x", ")", ".", "all", "(", ")", "and", "(", "np", ".", "imag", "(", "(", "x", ")", ")", "==", "0", ")", ".", "all", "(", ")", ",", "\"invalid input\"", "\n", "if", "self", ".", "mapfunc_inverse", "is", "None", "or", "self", ".", "mapfunc_Jacobian_determinant", "is", "None", ":", "\n", "            ", "return", "np", ".", "nan", "\n", "", "p", "=", "self", ".", "mapfunc_inverse", "(", "param", ",", "x", ")", "\n", "assert", "p", ".", "size", "==", "2", ",", "\"not yet implemented for non-bijective map functions\"", "\n", "u", "=", "p", "[", "0", "]", "-", "self", ".", "baseoffset", "\n", "v", "=", "p", "[", "1", "]", "\n", "\n", "if", "u", "<", "0.0", ":", "# invalid x for this theta", "\n", "            ", "return", "-", "np", ".", "inf", "if", "log", "else", "0.0", "\n", "\n", "", "r", "=", "np", ".", "sqrt", "(", "u", "**", "2", "+", "v", "**", "2", ")", "# note the angle distribution is uniform", "\n", "L", "=", "-", "0.5", "*", "(", "(", "r", "-", "self", ".", "mean_radius", ")", "/", "self", ".", "sd_radius", ")", "**", "2", "-", "0.5", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", "*", "self", ".", "sd_radius", "**", "2", ")", "\n", "return", "L", "if", "log", "else", "np", ".", "exp", "(", "L", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.TwoMoons.gen_posterior_samples": [[97, 119], ["numpy.array", "numpy.cos", "numpy.sin", "numpy.zeros", "range", "numpy.zeros", "TwoMoons.TwoMoons.gen_single", "numpy.random.rand", "numpy.zeros"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen_single"], ["", "def", "gen_posterior_samples", "(", "self", ",", "obs", "=", "np", ".", "array", "(", "[", "0.0", ",", "0.0", "]", ")", ",", "prior", "=", "None", ",", "n_samples", "=", "1", ")", ":", "\n", "# works only when we use the default_mapfunc above", "\n", "\n", "# use opposite rotation as above", "\n", "        ", "ang", "=", "-", "np", ".", "pi", "/", "4.0", "\n", "c", "=", "np", ".", "cos", "(", "-", "ang", ")", "\n", "s", "=", "np", ".", "sin", "(", "-", "ang", ")", "\n", "\n", "theta", "=", "np", ".", "zeros", "(", "(", "n_samples", ",", "2", ")", ")", "\n", "for", "i", "in", "range", "(", "n_samples", ")", ":", "\n", "            ", "p", "=", "self", ".", "gen_single", "(", "np", ".", "zeros", "(", "2", ")", ")", "[", "'data'", "]", "\n", "q", "=", "np", ".", "zeros", "(", "2", ")", "\n", "q", "[", "0", "]", "=", "p", "[", "0", "]", "-", "obs", "[", "0", "]", "\n", "q", "[", "1", "]", "=", "obs", "[", "1", "]", "-", "p", "[", "1", "]", "\n", "\n", "if", "np", ".", "random", ".", "rand", "(", ")", "<", "0.5", ":", "\n", "                ", "q", "[", "0", "]", "=", "-", "q", "[", "0", "]", "\n", "\n", "", "theta", "[", "i", ",", "0", "]", "=", "c", "*", "q", "[", "0", "]", "-", "s", "*", "q", "[", "1", "]", "\n", "theta", "[", "i", ",", "1", "]", "=", "s", "*", "q", "[", "0", "]", "+", "c", "*", "q", "[", "1", "]", "\n", "\n", "", "return", "theta", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.default_mapfunc": [[6, 13], ["numpy.cos", "numpy.sin", "numpy.array", "numpy.abs"], "function", ["None"], ["def", "default_mapfunc", "(", "theta", ",", "p", ")", ":", "\n", "    ", "ang", "=", "-", "np", ".", "pi", "/", "4.0", "\n", "c", "=", "np", ".", "cos", "(", "ang", ")", "\n", "s", "=", "np", ".", "sin", "(", "ang", ")", "\n", "z0", "=", "c", "*", "theta", "[", "0", "]", "-", "s", "*", "theta", "[", "1", "]", "\n", "z1", "=", "s", "*", "theta", "[", "0", "]", "+", "c", "*", "theta", "[", "1", "]", "\n", "return", "p", "+", "np", ".", "array", "(", "[", "-", "np", ".", "abs", "(", "z0", ")", ",", "z1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.default_mapfunc_inverse": [[15, 22], ["numpy.cos", "numpy.sin", "numpy.array", "numpy.abs"], "function", ["None"], ["", "def", "default_mapfunc_inverse", "(", "theta", ",", "x", ")", ":", "\n", "    ", "ang", "=", "-", "np", ".", "pi", "/", "4.0", "\n", "c", "=", "np", ".", "cos", "(", "ang", ")", "\n", "s", "=", "np", ".", "sin", "(", "ang", ")", "\n", "z0", "=", "c", "*", "theta", "[", "0", "]", "-", "s", "*", "theta", "[", "1", "]", "\n", "z1", "=", "s", "*", "theta", "[", "0", "]", "+", "c", "*", "theta", "[", "1", "]", "\n", "return", "x", "-", "np", ".", "array", "(", "[", "-", "np", ".", "abs", "(", "z0", ")", ",", "z1", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TwoMoons.default_mapfunc_Jacobian_determinant": [[24, 27], ["None"], "function", ["None"], ["", "def", "default_mapfunc_Jacobian_determinant", "(", "theta", ",", "p", ")", ":", "\n", "# det. of Jacobian from p to x", "\n", "    ", "return", "1.0", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.MaskedSimulator.MaskedSimulator.__init__": [[11, 36], ["delfi.simulator.BaseSimulator.__init__", "len", "numpy.count_nonzero"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "sim", ",", "mask", ",", "obs", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Simulator with masked parameters\n\n        This is a wrapper around BaseSimulator which imputes\n        fixed values for specified parameters, reducing the \n        dimensionality of the problem.\n\n        Parameters\n        ----------\n        sim : BaseSimulator\n            The original simulator\n        mask : 1d array \n            Boolean array determining the values to be imputed. False corresponds to imputed entries.\n        obs : 1d array\n            Array of parameters from which to impute the values\n        seed : int or None\n            See BaseSimulator\n        \"\"\"", "\n", "assert", "len", "(", "mask", ")", "==", "sim", ".", "dim_param", ",", "\"Mask for simulator has incorrect length\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "np", ".", "count_nonzero", "(", "mask", ")", ",", "seed", "=", "seed", ")", "\n", "self", ".", "sim", "=", "sim", "\n", "\n", "self", ".", "mask", "=", "mask", "\n", "self", ".", "obs", "=", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.MaskedSimulator.MaskedSimulator.gen_single": [[37, 41], ["MaskedSimulator.MaskedSimulator.obs.copy", "MaskedSimulator.MaskedSimulator.sim.gen_single"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen_single"], ["", "def", "gen_single", "(", "self", ",", "params", ")", ":", "\n", "        ", "real_params", "=", "self", ".", "obs", ".", "copy", "(", ")", "\n", "real_params", "[", "self", ".", "mask", "]", "=", "params", "\n", "return", "self", ".", "sim", ".", "gen_single", "(", "real_params", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.Blob.Blob.__init__": [[7, 40], ["delfi.simulator.BaseSimulator.BaseSimulator.__init__", "numpy.meshgrid", "numpy.linspace", "numpy.linspace"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "isize", "=", "32", ",", "maxval", "=", "255", ",", "sigma", "=", "None", ",", "seed", "=", "None", ",", "\n", "xy_abs_max", "=", "17", ",", "gamma_min", "=", "0.2", ",", "gamma_max", "=", "5.05", ")", ":", "\n", "        ", "\"\"\"Gauss simulator\n\n        Toy model that generates images containing a blob. For details, see\n        figure 3 of https://arxiv.org/pdf/1805.09294.pdf\n\n        Parameters\n        ----------\n        isize: int\n            Number of image rows and columns\n        maxval: int\n            Maximum pixel value\n        xy_abs_max: int\n            Maximum distance of blob center from image center, in pixels\n        gamma_min: float\n            Parameter controlling blob shape\n        gamma__max: float\n            Parameter controlling blob shape\n        sigma : float\n            Sigma value. If none, it will become a 4th parameter for inference.\n        seed : int or None\n            If set, randomness is seeded\n        \"\"\"", "\n", "dim", "=", "4", "if", "sigma", "is", "None", "else", "3", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "dim", ",", "seed", "=", "seed", ")", "\n", "self", ".", "isize", ",", "self", ".", "maxval", "=", "isize", ",", "maxval", "\n", "self", ".", "xy_abs_max", ",", "self", ".", "gamma_min", ",", "self", ".", "gamma_max", "=", "xy_abs_max", ",", "gamma_min", ",", "gamma_max", "\n", "self", ".", "x", ",", "self", ".", "y", "=", "np", ".", "meshgrid", "(", "np", ".", "linspace", "(", "-", "isize", "//", "2", ",", "isize", "//", "2", ",", "isize", ")", ",", "\n", "np", ".", "linspace", "(", "-", "isize", "//", "2", ",", "isize", "//", "2", ",", "isize", ")", ")", "\n", "self", ".", "sigma", "=", "sigma", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.Blob.Blob.gen_single": [[41, 63], ["Blob.Blob.rng.binomial", "counts.reshape", "numpy.exp", "numpy.exp", "numpy.exp", "numpy.exp"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen_single", "(", "self", ",", "params", ")", ":", "\n", "# See BaseSimulator for docstring", "\n", "        ", "if", "self", ".", "sigma", "is", "None", ":", "\n", "            ", "assert", "params", ".", "size", "==", "4", "\n", "xo", ",", "yo", ",", "gamma", ",", "sigma", "=", "params", "\n", "", "else", ":", "\n", "            ", "assert", "params", ".", "size", "==", "3", "\n", "xo", ",", "yo", ",", "gamma", "=", "params", "\n", "sigma", "=", "self", ".", "sigma", "\n", "\n", "", "xo", "=", "self", ".", "xy_abs_max", "*", "(", "2.0", "/", "(", "1.0", "+", "np", ".", "exp", "(", "-", "xo", ")", ")", "-", "1.0", ")", "\n", "yo", "=", "self", ".", "xy_abs_max", "*", "(", "2.0", "/", "(", "1.0", "+", "np", ".", "exp", "(", "-", "yo", ")", ")", "-", "1.0", ")", "\n", "gamma", "=", "(", "self", ".", "gamma_max", "-", "self", ".", "gamma_min", ")", "/", "(", "1.", "+", "np", ".", "exp", "(", "-", "gamma", ")", ")", "+", "self", ".", "gamma_min", "\n", "\n", "r", "=", "(", "self", ".", "x", "-", "xo", ")", "**", "2", "+", "(", "self", ".", "y", "-", "yo", ")", "**", "2", "\n", "p", "=", "0.1", "+", "0.8", "*", "np", ".", "exp", "(", "-", "0.5", "*", "(", "r", "/", "sigma", "**", "2", ")", "**", "gamma", ")", "\n", "\n", "counts", "=", "self", ".", "rng", ".", "binomial", "(", "self", ".", "maxval", ",", "p", ")", "/", "self", ".", "maxval", "\n", "\n", "return", "{", "'data'", ":", "counts", ".", "reshape", "(", "-", "1", ")", "}", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TransformedSimulator.TransformedSimulator.__init__": [[7, 31], ["copy.deepcopy"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "simulator", ",", "inverse_bijection", ",", "makecopy", "=", "False", ")", ":", "\n", "        ", "'''\n        Simulator with parameters in a transformed space. An inverse bijection\n        must be supplied to map back into the original parameter space. This\n        reparamterization allows unrestricted real-valued Euclidean parameter\n        spaces for simulators whose outputs are defined only for certain\n        parameter values\n\n        For example, a log transform can make positive numbers onto the real\n        line, and a logit transform can map the unit interval onto the real\n        line. In each case, the inverse bijection (e.g. exp or logisitic) must\n        be supplied.\n\n        There is no checking that the user-supplied bijection inverse is in fact\n        a one-to-one mapping, this is up to the user to verify.\n\n        :param simulator: Original simulator\n        :param inverse_bijection: Inverse transformation back into original simulator's parameter space\n        :param makecopy: Whether to call deepcopy on the simulator, unlinking the RNGs\n        '''", "\n", "if", "makecopy", ":", "\n", "            ", "simulator", "=", "deepcopy", "(", "simulator", ")", "\n", "", "self", ".", "simulator", ",", "self", ".", "inverse_bijection", "=", "simulator", ",", "inverse_bijection", "\n", "self", ".", "dim_param", "=", "self", ".", "simulator", ".", "dim_param", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TransformedSimulator.TransformedSimulator.reseed": [[32, 34], ["TransformedSimulator.TransformedSimulator.simulator.reseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "self", ".", "simulator", ".", "reseed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TransformedSimulator.TransformedSimulator.gen_newseed": [[35, 37], ["TransformedSimulator.TransformedSimulator.simulator.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "simulator", ".", "gen_newseed", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.TransformedSimulator.TransformedSimulator.gen_single": [[38, 41], ["TransformedSimulator.TransformedSimulator.inverse_bijection", "TransformedSimulator.TransformedSimulator.simulator.gen_single"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen_single"], ["", "def", "gen_single", "(", "self", ",", "input_params", ")", ":", "\n", "        ", "transformed_params", "=", "self", ".", "inverse_bijection", "(", "input_params", ")", "\n", "return", "self", ".", "simulator", ".", "gen_single", "(", "transformed_params", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.Gauss.Gauss.__init__": [[8, 25], ["delfi.simulator.BaseSimulator.BaseSimulator.__init__", "numpy.eye"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "dim", "=", "1", ",", "noise_cov", "=", "0.1", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gauss simulator\n\n        Toy model that draws data from a distribution centered on theta with\n        fixed noise.\n\n        Parameters\n        ----------\n        dim : int\n            Number of dimensions of parameters\n        noise_cov : float\n            Covariance of noise on observations\n        seed : int or None\n            If set, randomness is seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "dim_param", "=", "dim", ",", "seed", "=", "seed", ")", "\n", "self", ".", "noise_cov", "=", "noise_cov", "*", "np", ".", "eye", "(", "dim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.Gauss.Gauss.gen_single": [[26, 37], ["numpy.asarray().reshape", "delfi.Gaussian().gen", "delfi.Gaussian().gen.reshape", "numpy.asarray", "delfi.Gaussian", "Gauss.Gauss.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen_single", "(", "self", ",", "param", ")", ":", "\n", "# See BaseSimulator for docstring", "\n", "        ", "param", "=", "np", ".", "asarray", "(", "param", ")", ".", "reshape", "(", "-", "1", ")", "\n", "assert", "param", ".", "ndim", "==", "1", "\n", "assert", "param", ".", "shape", "[", "0", "]", "==", "self", ".", "dim_param", "\n", "\n", "sample", "=", "dd", ".", "Gaussian", "(", "m", "=", "param", ",", "S", "=", "self", ".", "noise_cov", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", ".", "gen", "(", "1", ")", "\n", "\n", "return", "{", "'data'", ":", "sample", ".", "reshape", "(", "-", "1", ")", "}", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.BaseSimulator.BaseSimulator.__init__": [[9, 26], ["numpy.random.RandomState"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dim_param", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Abstract base class for simulator models\n\n        Simulator models must at least implement abstract methods and properties\n        of this class.\n\n        Parameters\n        ----------\n        dim_param : int\n            Dimensionality of parameter vector\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "self", ".", "dim_param", "=", "dim_param", "\n", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.BaseSimulator.BaseSimulator.gen": [[27, 57], ["range", "data_list.append", "rep_list.append", "pbar.update", "BaseSimulator.BaseSimulator.gen_single"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen_single"], ["", "def", "gen", "(", "self", ",", "params_list", ",", "n_reps", "=", "1", ",", "pbar", "=", "None", ")", ":", "\n", "        ", "\"\"\"Forward model for simulator for list of parameters\n\n        Parameters\n        ----------\n        params_list : list of lists or 1-d np.arrays\n            List of parameter vectors, each of which will be simulated\n        n_reps : int\n            If greater than 1, generate multiple samples given param\n        pbar : tqdm.tqdm or None\n            If None, will do nothing. Otherwise it will call pbar.update(1)\n            after each sample.\n\n        Returns\n        -------\n        data_list : list of lists containing n_reps dicts with data\n            Repetitions are runs with the same parameter set, different\n            repetitions. Each dictionary must contain a key data that contains\n            the results of the forward run. Additional entries can be present.\n        \"\"\"", "\n", "data_list", "=", "[", "]", "\n", "for", "param", "in", "params_list", ":", "\n", "            ", "rep_list", "=", "[", "]", "\n", "for", "r", "in", "range", "(", "n_reps", ")", ":", "\n", "                ", "rep_list", ".", "append", "(", "self", ".", "gen_single", "(", "param", ")", ")", "\n", "", "data_list", ".", "append", "(", "rep_list", ")", "\n", "if", "pbar", "is", "not", "None", ":", "\n", "                ", "pbar", ".", "update", "(", "1", ")", "\n", "\n", "", "", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.BaseSimulator.BaseSimulator.gen_single": [[58, 74], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "gen_single", "(", "self", ",", "params", ")", ":", "\n", "        ", "\"\"\"Forward model for simulator for single parameter set\n\n        Parameters\n        ----------\n        params : list or np.array, 1d of length dim_param\n            Parameter vector\n\n        Returns\n        -------\n        dict : dictionary with data\n            The dictionary must contain a key data that contains the results of\n            the forward run. Additional entries can be present.\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.BaseSimulator.BaseSimulator.reseed": [[75, 79], ["BaseSimulator.BaseSimulator.rng.seed"], "methods", ["None"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Reseeds the distribution's RNG\"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.simulator.BaseSimulator.BaseSimulator.gen_newseed": [[80, 86], ["BaseSimulator.BaseSimulator.rng.randint"], "methods", ["None"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.__init__": [[9, 34], ["numpy.random.RandomState"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "model", ",", "prior", ",", "summary", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generator\n\n        Parameters\n        ----------\n        model : Simulator instance\n            Forward model\n        prior : Distribution or Mixture instance\n            Prior over parameters\n        summary : SummaryStats instance\n            Summary statistics\n\n        Attributes\n        ----------\n        proposal : None or Distribution or Mixture instance\n            Proposal prior over parameters. If specified, will generate\n            samples given parameters drawn from proposal distribution rather\n            than samples drawn from prior when `gen` is called.\n        \"\"\"", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "prior", "=", "prior", "\n", "self", ".", "summary", "=", "summary", "\n", "self", ".", "proposal", "=", "None", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.gen_newseed": [[35, 41], ["BaseGenerator.BaseGenerator.rng.randint"], "methods", ["None"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.reseed": [[42, 58], ["BaseGenerator.BaseGenerator.rng.seed", "BaseGenerator.BaseGenerator.prior.reseed", "BaseGenerator.BaseGenerator.gen_newseed", "BaseGenerator.BaseGenerator.model.reseed", "BaseGenerator.BaseGenerator.proposal.reseed", "BaseGenerator.BaseGenerator.gen_newseed", "BaseGenerator.BaseGenerator.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Carries out the following operations, in order:\n        1) Reseeds the master RNG for the generator object, using the input seed\n        2) Reseeds the prior from the master RNG. This may cause additional\n        distributions to be reseeded using the prior's RNG (e.g. if the prior is\n        a mixture)\n        3) Reseeds the simulator RNG, from the master RNG\n        4) Reseeds the proposal, if present\n        \"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "prior", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "if", "self", ".", "model", "is", "not", "None", ":", "\n", "            ", "self", ".", "model", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "", "if", "self", ".", "proposal", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposal", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.draw_params": [[59, 94], ["delfi.utils.progress.no_tqdm", "delfi.utils.progress.progressbar", "delfi.utils.progress.progressbar.set_description", "type", "BaseGenerator.BaseGenerator._feedback_proposed_param", "BaseGenerator.BaseGenerator.prior.gen", "BaseGenerator.BaseGenerator.proposal.gen", "params.append", "delfi.utils.progress.progressbar.update", "BaseGenerator.BaseGenerator.rng.random_sample", "BaseGenerator.BaseGenerator.reshape", "ValueError"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.progressbar", "home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_proposed_param", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update"], ["", "", "def", "draw_params", "(", "self", ",", "n_samples", ",", "skip_feedback", "=", "False", ",", "prior_mixin", "=", "0", ",", "verbose", "=", "True", ",", "leave_pbar", "=", "True", ")", ":", "\n", "        ", "if", "not", "verbose", ":", "\n", "            ", "pbar", "=", "no_tqdm", "(", ")", "\n", "", "else", ":", "\n", "            ", "pbar", "=", "progressbar", "(", "total", "=", "n_samples", ",", "leave", "=", "leave_pbar", ")", "\n", "desc", "=", "'Draw parameters '", "\n", "if", "type", "(", "verbose", ")", "==", "str", ":", "\n", "                ", "desc", "+=", "verbose", "\n", "", "pbar", ".", "set_description", "(", "desc", ")", "\n", "\n", "# collect valid parameter vectors from the prior", "\n", "", "params", "=", "[", "]", "# list of parameter vectors", "\n", "with", "pbar", ":", "\n", "            ", "i", "=", "0", "\n", "while", "i", "<", "n_samples", ":", "\n", "# sample parameter", "\n", "                ", "if", "self", ".", "proposal", "is", "None", "or", "self", ".", "rng", ".", "random_sample", "(", ")", "<", "prior_mixin", ":", "\n", "                    ", "proposed_param", "=", "self", ".", "prior", ".", "gen", "(", "n_samples", "=", "1", ")", "# dim params,", "\n", "", "else", ":", "\n", "                    ", "proposed_param", "=", "self", ".", "proposal", ".", "gen", "(", "n_samples", "=", "1", ")", "\n", "\n", "# check if parameter vector is valid", "\n", "", "response", "=", "self", ".", "_feedback_proposed_param", "(", "proposed_param", ")", "\n", "if", "response", "==", "'accept'", "or", "skip_feedback", ":", "\n", "# add valid param vector to list", "\n", "                    ", "params", ".", "append", "(", "proposed_param", ".", "reshape", "(", "-", "1", ")", ")", "\n", "i", "+=", "1", "\n", "pbar", ".", "update", "(", "1", ")", "\n", "", "elif", "response", "==", "'resample'", ":", "\n", "# continue without increment on i or updating the bar", "\n", "                    ", "continue", "\n", "", "else", ":", "\n", "                    ", "raise", "ValueError", "(", "'response not supported'", ")", "\n", "\n", "", "", "return", "params", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.iterate_minibatches": [[95, 104], ["len", "range"], "methods", ["None"], ["", "", "def", "iterate_minibatches", "(", "self", ",", "params", ",", "minibatch", "=", "50", ")", ":", "\n", "        ", "n_samples", "=", "len", "(", "params", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "n_samples", "-", "minibatch", "+", "1", ",", "minibatch", ")", ":", "\n", "            ", "yield", "params", "[", "i", ":", "i", "+", "minibatch", "]", "\n", "\n", "", "rem_i", "=", "n_samples", "-", "(", "n_samples", "%", "minibatch", ")", "\n", "if", "rem_i", "!=", "n_samples", ":", "\n", "            ", "yield", "params", "[", "rem_i", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.gen": [[105, 168], ["BaseGenerator.BaseGenerator.draw_params", "numpy.array", "numpy.array", "delfi.utils.progress.no_tqdm", "delfi.utils.progress.progressbar", "delfi.utils.progress.progressbar.set_description", "BaseGenerator.BaseGenerator.iterate_minibatches", "len", "stats.squeeze.squeeze.squeeze", "type", "BaseGenerator.BaseGenerator.model.gen", "BaseGenerator.BaseGenerator.process_batch", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.draw_params", "home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.progressbar", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.iterate_minibatches", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.process_batch"], ["", "", "def", "gen", "(", "self", ",", "n_samples", ",", "n_reps", "=", "1", ",", "skip_feedback", "=", "False", ",", "prior_mixin", "=", "0", ",", "minibatch", "=", "50", ",", "keep_data", "=", "True", ",", "verbose", "=", "True", ",", "\n", "leave_pbar", "=", "True", ")", ":", "\n", "        ", "\"\"\"Draw parameters and run forward model\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples\n        n_reps: int\n            Number of repetitions per parameter sample\n        skip_feedback: bool\n            If True, feedback checks on params, data and sum stats are skipped\n        verbose : bool or str\n            If False, will not display progress bars. If a string is passed,\n            it will be appended to the description of the progress bar.\n\n        Returns\n        -------\n        params : n_samples x n_reps x n_params\n            Parameters\n        stats : n_samples x n_reps x n_summary\n            Summary statistics of data\n        \"\"\"", "\n", "assert", "n_reps", "==", "1", ",", "'n_reps > 1 is not yet supported'", "\n", "\n", "params", "=", "self", ".", "draw_params", "(", "n_samples", "=", "n_samples", ",", "\n", "skip_feedback", "=", "skip_feedback", ",", "\n", "prior_mixin", "=", "prior_mixin", ",", "\n", "verbose", "=", "verbose", ",", "\n", "leave_pbar", "=", "leave_pbar", ")", "\n", "\n", "# Run forward model for params (in batches)", "\n", "if", "not", "verbose", ":", "\n", "            ", "pbar", "=", "no_tqdm", "(", ")", "\n", "", "else", ":", "\n", "            ", "pbar", "=", "progressbar", "(", "total", "=", "len", "(", "params", ")", ",", "leave", "=", "leave_pbar", ")", "\n", "desc", "=", "'Run simulations '", "\n", "if", "type", "(", "verbose", ")", "==", "str", ":", "\n", "                ", "desc", "+=", "verbose", "\n", "", "pbar", ".", "set_description", "(", "desc", ")", "\n", "\n", "", "final_params", "=", "[", "]", "\n", "final_stats", "=", "[", "]", "# list of summary stats", "\n", "with", "pbar", ":", "\n", "            ", "for", "params_batch", "in", "self", ".", "iterate_minibatches", "(", "params", ",", "minibatch", ")", ":", "\n", "# run forward model for all params, each n_reps times", "\n", "                ", "result", "=", "self", ".", "model", ".", "gen", "(", "params_batch", ",", "n_reps", "=", "n_reps", ",", "pbar", "=", "pbar", ")", "\n", "\n", "stats", ",", "params", "=", "self", ".", "process_batch", "(", "params_batch", ",", "result", ",", "skip_feedback", "=", "skip_feedback", ")", "\n", "final_params", "+=", "params", "\n", "final_stats", "+=", "stats", "\n", "\n", "# TODO: for n_reps > 1 duplicate params; reshape stats array", "\n", "\n", "# n_samples x dim theta", "\n", "", "", "params", "=", "np", ".", "array", "(", "final_params", ")", "\n", "\n", "# n_samples x dim summary stats", "\n", "stats", "=", "np", ".", "array", "(", "final_stats", ")", "\n", "if", "len", "(", "final_stats", ")", ">", "0", ":", "\n", "            ", "stats", "=", "stats", ".", "squeeze", "(", "axis", "=", "1", ")", "\n", "\n", "", "return", "params", ",", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.process_batch": [[169, 206], ["zip", "zip", "BaseGenerator.BaseGenerator._feedback_forward_model", "BaseGenerator.BaseGenerator.summary.calc", "BaseGenerator.BaseGenerator._feedback_summary_stats", "data_valid.append", "params_data_valid.append", "ret_stats.append", "ret_params.append", "ValueError", "ValueError"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_forward_model", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.calc", "home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_summary_stats"], ["", "def", "process_batch", "(", "self", ",", "params_batch", ",", "result", ",", "skip_feedback", "=", "False", ")", ":", "\n", "        ", "ret_stats", "=", "[", "]", "\n", "ret_params", "=", "[", "]", "\n", "\n", "# for every datum in data, check validity", "\n", "params_data_valid", "=", "[", "]", "# list of params with valid data", "\n", "data_valid", "=", "[", "]", "# list of lists containing n_reps dicts with data", "\n", "\n", "for", "param", ",", "datum", "in", "zip", "(", "params_batch", ",", "result", ")", ":", "\n", "# check validity", "\n", "            ", "response", "=", "self", ".", "_feedback_forward_model", "(", "datum", ")", "\n", "if", "response", "==", "'accept'", "or", "skip_feedback", ":", "\n", "                ", "data_valid", ".", "append", "(", "datum", ")", "\n", "# if data is accepted, accept the param as well", "\n", "params_data_valid", ".", "append", "(", "param", ")", "\n", "", "elif", "response", "==", "'discard'", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'response not supported'", ")", "\n", "\n", "# for every data in data, calculate summary stats", "\n", "", "", "for", "param", ",", "datum", "in", "zip", "(", "params_data_valid", ",", "data_valid", ")", ":", "\n", "# calculate summary statistics", "\n", "            ", "sum_stats", "=", "self", ".", "summary", ".", "calc", "(", "datum", ")", "# n_reps x dim stats", "\n", "\n", "# check validity", "\n", "response", "=", "self", ".", "_feedback_summary_stats", "(", "sum_stats", ")", "\n", "if", "response", "==", "'accept'", "or", "skip_feedback", ":", "\n", "                ", "ret_stats", ".", "append", "(", "sum_stats", ")", "\n", "# if sum stats is accepted, accept the param as well", "\n", "ret_params", ".", "append", "(", "param", ")", "\n", "", "elif", "response", "==", "'discard'", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'response not supported'", ")", "\n", "\n", "", "", "return", "ret_stats", ",", "ret_params", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator._feedback_proposed_param": [[207, 224], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "_feedback_proposed_param", "(", "self", ",", "param", ")", ":", "\n", "        ", "\"\"\"Feedback step after parameter has been proposed\n\n        Parameters\n        ----------\n        param : np.array\n            Parameter\n\n        Returns\n        -------\n        response : str\n            Supported responses are in ['accept', 'resample']\n        \"\"\"", "\n", "# TODO: check if parameter is inside of support of prior when", "\n", "# proposal distribution was used for sampling", "\n", "return", "'accept'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator._feedback_forward_model": [[225, 240], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "_feedback_forward_model", "(", "self", ",", "data", ")", ":", "\n", "        ", "\"\"\"Feedback step after forward model ran\n\n        Parameters\n        ----------\n        data : np.array\n            Data\n\n        Returns\n        -------\n        response : str\n            Supported responses are in ['accept', 'discard']\n        \"\"\"", "\n", "return", "'accept'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator._feedback_summary_stats": [[241, 256], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "_feedback_summary_stats", "(", "self", ",", "sum_stats", ")", ":", "\n", "        ", "\"\"\"Feedback step after summary stats were computed\n\n        Parameters\n        ----------\n        sum_stats : np.array\n            Summary stats\n\n        Returns\n        -------\n        response : str\n            Supported responses are in ['accept', 'discard']\n        \"\"\"", "\n", "return", "'accept'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.RemoteGenerator.RemoteGenerator.__init__": [[133, 169], ["delfi.generator.Default.Default.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "simulator_class", ",", "prior", ",", "summary_class", ",", "\n", "hostname", ",", "username", ",", "\n", "simulator_args", "=", "None", ",", "simulator_kwargs", "=", "None", ",", "summary_args", "=", "None", ",", "summary_kwargs", "=", "None", ",", "\n", "save_every", "=", "None", ",", "\n", "remote_python_executable", "=", "None", ",", "use_slurm", "=", "False", ",", "slurm_options", "=", "None", ",", "\n", "local_work_path", "=", "None", ",", "remote_work_path", "=", "None", ",", "persistent", "=", "False", ",", "\n", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"\n        Generator that creates an MPGenerator on a remote server and uses that\n        to run simulations.\n\n        :param persistent: Whether to start a new job if the first one doesn't generate the necessary number of samples.\n            This can be useful when the remote host might cancel the job part-way through, combined with save_every.\n        :param save_every: Progress will be saved on the remote host every time this many samples is generated.\n        :param simulator_class:\n        :param prior:\n        :param summary:\n        :param hostname:\n        :param username:\n        :param remote_python_executable:\n        :param use_slurm:\n        :param local_work_path:\n        :param remote_work_path:\n        :param seed:\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "model", "=", "None", ",", "prior", "=", "prior", ",", "summary", "=", "None", ",", "seed", "=", "seed", ")", "\n", "self", ".", "simulator_class", ",", "self", ".", "summary_class", ",", "self", ".", "hostname", ",", "self", ".", "username", ",", "self", ".", "simulator_args", ",", "self", ".", "simulator_kwargs", ",", "self", ".", "summary_args", ",", "self", ".", "summary_kwargs", ",", "self", ".", "remote_python_executable", ",", "self", ".", "local_work_path", ",", "self", ".", "remote_work_path", ",", "self", ".", "use_slurm", ",", "self", ".", "slurm_options", ",", "self", ".", "save_every", ",", "self", ".", "persistent", "=", "simulator_class", ",", "summary_class", ",", "hostname", ",", "username", ",", "simulator_args", ",", "simulator_kwargs", ",", "summary_args", ",", "summary_kwargs", ",", "remote_python_executable", ",", "local_work_path", ",", "remote_work_path", ",", "use_slurm", ",", "slurm_options", ",", "save_every", ",", "persistent", "\n", "self", ".", "time", ",", "self", ".", "task_time", "=", "None", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.RemoteGenerator.RemoteGenerator.gen": [[170, 211], ["RemoteGenerator.RemoteGenerator.prior.reseed", "RemoteGenerator.RemoteGenerator.gen_newseed", "RemoteGenerator.RemoteGenerator.proposal.reseed", "RemoteGenerator.run_remote", "RemoteGenerator.RemoteGenerator.gen_newseed", "RemoteGenerator.RemoteGenerator.gen_newseed", "numpy.vstack", "numpy.vstack"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.generator.RemoteGenerator.run_remote", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "gen", "(", "self", ",", "n_samples", ",", "n_workers", "=", "None", ",", "persistent", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "prior", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "if", "self", ".", "proposal", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposal", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n", "", "if", "persistent", "is", "None", ":", "\n", "            ", "persistent", "=", "self", ".", "persistent", "\n", "\n", "", "samples_remaining", ",", "params", ",", "stats", "=", "n_samples", ",", "None", ",", "None", "\n", "while", "samples_remaining", ">", "0", ":", "\n", "            ", "next_params", ",", "next_stats", ",", "time", ",", "task_time", "=", "run_remote", "(", "self", ".", "simulator_class", ",", "\n", "self", ".", "summary_class", ",", "\n", "self", ".", "prior", ",", "\n", "n_samples", ",", "\n", "hostname", "=", "self", ".", "hostname", ",", "\n", "username", "=", "self", ".", "username", ",", "\n", "simulator_args", "=", "self", ".", "simulator_args", ",", "\n", "simulator_kwargs", "=", "self", ".", "simulator_kwargs", ",", "\n", "summary_args", "=", "self", ".", "summary_args", ",", "\n", "summary_kwargs", "=", "self", ".", "summary_kwargs", ",", "\n", "remote_python_executable", "=", "self", ".", "remote_python_executable", ",", "\n", "remote_work_path", "=", "self", ".", "remote_work_path", ",", "\n", "local_work_path", "=", "self", ".", "local_work_path", ",", "\n", "proposal", "=", "self", ".", "proposal", ",", "\n", "n_workers", "=", "n_workers", ",", "\n", "generator_seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "use_slurm", "=", "self", ".", "use_slurm", ",", "\n", "save_every", "=", "self", ".", "save_every", ",", "\n", "slurm_options", "=", "self", ".", "slurm_options", ",", "\n", "**", "kwargs", ")", "\n", "self", ".", "time", ",", "self", ".", "task_time", "=", "time", ",", "task_time", "\n", "if", "params", "is", "None", ":", "\n", "                ", "params", ",", "stats", "=", "next_params", ",", "next_stats", "\n", "", "else", ":", "\n", "                ", "params", ",", "stats", "=", "np", ".", "vstack", "(", "(", "params", ",", "next_params", ")", ")", ",", "np", ".", "vstack", "(", "(", "stats", ",", "next_stats", ")", ")", "\n", "", "samples_remaining", "-=", "next_params", ".", "shape", "[", "0", "]", "\n", "\n", "if", "not", "persistent", ":", "\n", "                ", "break", "\n", "\n", "", "", "return", "params", ",", "stats", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.RemoteGenerator.run_remote": [[9, 130], ["str", "os.path.join", "os.path.join", "os.path.join", "os.path.join", "dict", "subprocess.run", "subprocess.run", "subprocess.run", "os.remove", "os.remove", "subprocess.run", "dict", "dict", "os.getenv", "os.getcwd", "dict", "uuid.uuid1", "open", "pickle.dump", "subprocess.run.stderr.decode", "subprocess.run.stderr.decode", "subprocess.run.stderr.decode", "open", "pickle.load", "subprocess.run.stderr.decode", "pickle.load.keys"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load"], ["def", "run_remote", "(", "simulator_class", ",", "\n", "summary_class", ",", "\n", "prior", ",", "# might still be relevant with proposals due to rejection", "\n", "n_samples", ",", "\n", "hostname", ",", "\n", "username", ",", "\n", "simulator_args", "=", "None", ",", "\n", "simulator_kwargs", "=", "None", ",", "\n", "summary_args", "=", "None", ",", "\n", "summary_kwargs", "=", "None", ",", "\n", "remote_python_executable", "=", "None", ",", "\n", "remote_work_path", "=", "None", ",", "\n", "local_work_path", "=", "None", ",", "\n", "proposal", "=", "None", ",", "# use prior by default", "\n", "n_workers", "=", "None", ",", "# use number of remote cpus by default", "\n", "generator_seed", "=", "None", ",", "\n", "use_slurm", "=", "False", ",", "# use the job manager with sbatch", "\n", "slurm_options", "=", "None", ",", "\n", "save_every", "=", "None", ",", "\n", "**", "generator_kwargs", ")", ":", "\n", "    ", "\"\"\"\n    Create a MPGenerator on a remote server and generate samples.\n\n    :param summary_kwargs:\n    :param summary_args:\n    :param summary_class:\n    :param save_every:\n    :param remote_python_executable:\n    :param slurm_options:\n    :param simulator_class:\n    :param prior:\n    :param n_samples:\n    :param hostname:\n    :param username:\n    :param simulator_args:\n    :param simulator_kwargs:\n    :param remote_python_executable:\n    :param remote_work_path:\n    :param local_work_path:\n    :param proposal:\n    :param n_workers:\n    :param generator_seed:\n    :param use_slurm:\n    :param generator_kwargs:\n    :return: (params, stats)\n    \"\"\"", "\n", "if", "simulator_args", "is", "None", ":", "\n", "        ", "simulator_args", "=", "[", "]", "\n", "", "if", "simulator_kwargs", "is", "None", ":", "\n", "        ", "simulator_kwargs", "=", "dict", "(", ")", "\n", "", "if", "summary_args", "is", "None", ":", "\n", "        ", "summary_args", "=", "[", "]", "\n", "", "if", "summary_kwargs", "is", "None", ":", "\n", "        ", "summary_kwargs", "=", "dict", "(", ")", "\n", "", "if", "remote_python_executable", "is", "None", ":", "\n", "        ", "remote_python_executable", "=", "'python3'", "\n", "", "if", "remote_work_path", "is", "None", ":", "\n", "        ", "remote_work_path", "=", "'./'", "\n", "", "if", "local_work_path", "is", "None", ":", "\n", "        ", "local_work_path", "=", "os", ".", "getenv", "(", "'HOME'", ")", "\n", "", "if", "local_work_path", "is", "None", ":", "\n", "        ", "local_work_path", "=", "os", ".", "getcwd", "(", ")", "\n", "", "if", "slurm_options", "is", "None", ":", "\n", "        ", "slurm_options", "=", "dict", "(", ")", "\n", "\n", "# define file names. important to use different local/remote names in case", "\n", "# we're ssh-ing into localhost etc.", "\n", "", "uu", "=", "str", "(", "uuid", ".", "uuid1", "(", ")", ")", "\n", "datafile_local", "=", "os", ".", "path", ".", "join", "(", "local_work_path", ",", "\n", "'local_data_{0}.pickle'", ".", "format", "(", "uu", ")", ")", "\n", "datafile_remote", "=", "os", ".", "path", ".", "join", "(", "remote_work_path", ",", "\n", "'remote_data_{0}.pickle'", ".", "format", "(", "uu", ")", ")", "\n", "samplefile_local", "=", "os", ".", "path", ".", "join", "(", "local_work_path", ",", "\n", "'local_samples_{0}.pickle'", ".", "format", "(", "uu", ")", ")", "\n", "samplefile_remote", "=", "os", ".", "path", ".", "join", "(", "remote_work_path", ",", "\n", "'remote_samples_{0}.pickle'", ".", "format", "(", "uu", ")", ")", "\n", "\n", "data", "=", "dict", "(", "simulator_class", "=", "simulator_class", ",", "simulator_args", "=", "simulator_args", ",", "simulator_kwargs", "=", "simulator_kwargs", ",", "\n", "summary_class", "=", "summary_class", ",", "summary_args", "=", "summary_args", ",", "summary_kwargs", "=", "summary_kwargs", ",", "\n", "prior", "=", "prior", ",", "proposal", "=", "proposal", ",", "n_samples", "=", "n_samples", ",", "\n", "generator_seed", "=", "generator_seed", ",", "\n", "n_workers", "=", "n_workers", ",", "generator_kwargs", "=", "generator_kwargs", ",", "\n", "samplefile", "=", "samplefile_remote", ",", "use_slurm", "=", "use_slurm", ",", "\n", "python_executable", "=", "remote_python_executable", ",", "\n", "slurm_options", "=", "slurm_options", ",", "save_every", "=", "save_every", ")", "\n", "\n", "with", "open", "(", "datafile_local", ",", "'wb'", ")", "as", "f", ":", "\n", "        ", "pickle", ".", "dump", "(", "data", ",", "f", ",", "protocol", "=", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "# copy the data file to the remote host", "\n", "", "result", "=", "subprocess", ".", "run", "(", "[", "'scp'", ",", "datafile_local", ",", "'{0}@{1}:{2}'", ".", "format", "(", "username", ",", "hostname", ",", "datafile_remote", ")", "]", ",", "\n", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ")", "\n", "assert", "result", ".", "returncode", "==", "0", ",", "\"failed to copy data file to remote host: {0}\"", ".", "format", "(", "result", ".", "stderr", ".", "decode", "(", ")", ")", "\n", "\n", "# generate samples remotely", "\n", "python_commands", "=", "'from delfi.generator.MPGenerator import '", "'mpgen_from_file; mpgen_from_file(\\'{0}\\')'", ".", "format", "(", "datafile_remote", ")", "\n", "\n", "remote_command", "=", "'{0} -c \\\"{1}\\\"'", ".", "format", "(", "remote_python_executable", ",", "python_commands", ")", "\n", "\n", "result", "=", "subprocess", ".", "run", "(", "[", "'ssh'", ",", "hostname", ",", "'-l'", ",", "username", ",", "remote_command", "]", ",", "\n", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ")", "\n", "assert", "result", ".", "returncode", "==", "0", ",", "\"failed to run code on remote host: {0}\"", ".", "format", "(", "result", ".", "stderr", ".", "decode", "(", ")", ")", "\n", "\n", "# copy samples back to local host", "\n", "result", "=", "subprocess", ".", "run", "(", "[", "'scp'", ",", "'{0}@{1}:{2}'", ".", "format", "(", "username", ",", "hostname", ",", "samplefile_remote", ")", ",", "samplefile_local", "]", ",", "\n", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ")", "\n", "assert", "result", ".", "returncode", "==", "0", ",", "\"failed to copy samples file from remote host: {0}\"", ".", "format", "(", "result", ".", "stderr", ".", "decode", "(", ")", ")", "\n", "\n", "with", "open", "(", "samplefile_local", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "samples", "=", "pickle", ".", "load", "(", "f", ")", "\n", "\n", "# clean up by deleting data/sample files on remote/local machines", "\n", "", "os", ".", "remove", "(", "datafile_local", ")", "\n", "os", ".", "remove", "(", "samplefile_local", ")", "\n", "result", "=", "subprocess", ".", "run", "(", "[", "'ssh'", ",", "hostname", ",", "'-l'", ",", "username", ",", "'rm {0} && rm {1}'", ".", "format", "(", "datafile_remote", ",", "\n", "samplefile_remote", ")", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ")", "\n", "assert", "result", ".", "returncode", "==", "0", ",", "\"failed to delete file(s) from remote host: {0}\"", ".", "format", "(", "result", ".", "stderr", ".", "decode", "(", ")", ")", "\n", "\n", "task_time", "=", "None", "if", "'task_time'", "not", "in", "samples", ".", "keys", "(", ")", "else", "samples", "[", "'task_time'", "]", "\n", "return", "samples", "[", "'params'", "]", ",", "samples", "[", "'stats'", "]", ",", "samples", "[", "'time'", "]", ",", "task_time", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.__init__": [[13, 22], ["multiprocessing.Process.__init__", "numpy.random.RandomState"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n", ",", "queue", ",", "conn", ",", "model", ",", "summary", ",", "seed", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n", "=", "n", "\n", "self", ".", "queue", "=", "queue", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "conn", "=", "conn", "\n", "self", ".", "model", "=", "model", "\n", "self", ".", "summary", "=", "summary", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update": [[23, 25], ["MPGenerator.Worker.queue.put"], "methods", ["None"], ["", "def", "update", "(", "self", ",", "i", ")", ":", "\n", "        ", "self", ".", "queue", ".", "put", "(", "i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.run": [[26, 49], ["MPGenerator.Worker.log", "MPGenerator.Worker.log", "MPGenerator.Worker.model.gen", "MPGenerator.Worker.process_batch", "MPGenerator.Worker.log", "MPGenerator.Worker.queue.put", "MPGenerator.Worker.log", "MPGenerator.Worker.log", "MPGenerator.Worker.conn.recv", "len", "MPGenerator.Worker.log", "MPGenerator.Worker.conn.send", "MPGenerator.Worker.log", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.process_batch", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "run", "(", "self", ")", ":", "\n", "        ", "self", ".", "log", "(", "\"Starting worker\"", ")", "\n", "while", "True", ":", "\n", "            ", "try", ":", "\n", "                ", "self", ".", "log", "(", "\"Listening\"", ")", "\n", "params_batch", "=", "self", ".", "conn", ".", "recv", "(", ")", "\n", "", "except", "EOFError", ":", "\n", "                ", "self", ".", "log", "(", "\"Leaving\"", ")", "\n", "break", "\n", "", "if", "len", "(", "params_batch", ")", "==", "0", ":", "\n", "                ", "self", ".", "log", "(", "\"Skipping\"", ")", "\n", "self", ".", "conn", ".", "send", "(", "(", "[", "]", ",", "[", "]", ")", ")", "\n", "continue", "\n", "\n", "# run forward model for all params, each n_reps times", "\n", "", "self", ".", "log", "(", "\"Received data of size {}\"", ".", "format", "(", "len", "(", "params_batch", ")", ")", ")", "\n", "result", "=", "self", ".", "model", ".", "gen", "(", "params_batch", ",", "pbar", "=", "self", ")", "\n", "\n", "stats", ",", "params", "=", "self", ".", "process_batch", "(", "params_batch", ",", "result", ")", "\n", "\n", "self", ".", "log", "(", "\"Sending data\"", ")", "\n", "self", ".", "queue", ".", "put", "(", "(", "stats", ",", "params", ")", ")", "\n", "self", ".", "log", "(", "\"Done\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.process_batch": [[50, 71], ["zip", "zip", "data_valid.append", "params_data_valid.append", "MPGenerator.Worker.summary.calc", "ret_stats.append", "ret_params.append"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.calc"], ["", "", "def", "process_batch", "(", "self", ",", "params_batch", ",", "result", ")", ":", "\n", "        ", "ret_stats", "=", "[", "]", "\n", "ret_params", "=", "[", "]", "\n", "\n", "# for every datum in data, check validity", "\n", "params_data_valid", "=", "[", "]", "# list of params with valid data", "\n", "data_valid", "=", "[", "]", "# list of lists containing n_reps dicts with data", "\n", "\n", "for", "param", ",", "datum", "in", "zip", "(", "params_batch", ",", "result", ")", ":", "\n", "            ", "data_valid", ".", "append", "(", "datum", ")", "\n", "params_data_valid", ".", "append", "(", "param", ")", "\n", "\n", "# for every data in data, calculate summary stats", "\n", "", "for", "param", ",", "datum", "in", "zip", "(", "params_data_valid", ",", "data_valid", ")", ":", "\n", "# calculate summary statistics", "\n", "            ", "sum_stats", "=", "self", ".", "summary", ".", "calc", "(", "datum", ")", "# n_reps x dim stats", "\n", "\n", "ret_stats", ".", "append", "(", "sum_stats", ")", "\n", "ret_params", ".", "append", "(", "param", ")", "\n", "\n", "", "return", "ret_stats", ",", "ret_params", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.log": [[72, 75], ["print"], "methods", ["None"], ["", "def", "log", "(", "self", ",", "msg", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"Worker {}: {}\"", ".", "format", "(", "self", ".", "n", ",", "msg", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.__init__": [[82, 112], ["delfi.generator.Default.Default.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "models", ",", "prior", ",", "summary", ",", "rej", "=", "None", ",", "seed", "=", "None", ",", "verbose", "=", "False", ")", ":", "\n", "        ", "\"\"\"Generator supporting multiprocessing\n\n        Parameters\n        ----------\n        models : List of simulator instances\n            Forward models\n        prior : Distribution or Mixture instance\n            Prior over parameters\n        summary : SummaryStats instance\n            Summary statistics\n        rej : Function\n            Rejection kernel\n\n        Attributes\n        ----------\n        proposal : None or Distribution or Mixture instance\n            Proposal prior over parameters. If specified, will generate\n            samples given parameters drawn from proposal distribution rather\n            than samples drawn from prior when `gen` is called.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "model", "=", "None", ",", "prior", "=", "prior", ",", "summary", "=", "summary", ",", "seed", "=", "seed", ")", "\n", "\n", "self", ".", "rej", "=", "rej", "if", "rej", "is", "not", "None", "else", "default_MPGenerator_rej", "\n", "self", ".", "verbose", "=", "verbose", "\n", "self", ".", "models", "=", "models", "\n", "\n", "self", ".", "workers", "=", "None", "\n", "self", ".", "pipes", "=", "None", "\n", "self", ".", "queue", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.reseed": [[113, 129], ["MPGenerator.MPGenerator.rng.seed", "MPGenerator.MPGenerator.prior.reseed", "MPGenerator.MPGenerator.gen_newseed", "m.reseed", "MPGenerator.MPGenerator.proposal.reseed", "MPGenerator.MPGenerator.gen_newseed", "MPGenerator.MPGenerator.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Carries out the following operations, in order:\n        1) Reseeds the master RNG for the generator object, using the input seed\n        2) Reseeds the prior from the master RNG. This may cause additional\n        distributions to be reseeded using the prior's RNG (e.g. if the prior is\n        a mixture)\n        3) Reseeds the simulator RNG, from the master RNG\n        4) Reseeds the proposal, if present\n        \"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "prior", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "for", "m", "in", "self", ".", "models", ":", "\n", "            ", "m", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "", "if", "self", ".", "proposal", "is", "not", "None", ":", "\n", "            ", "self", ".", "proposal", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.start_workers": [[130, 141], ["multiprocessing.Queue", "MPGenerator.MPGenerator.log", "MPGenerator.MPGenerator.log", "multiprocessing.Pipe", "MPGenerator.Worker", "w.start", "range", "MPGenerator.MPGenerator.rng.randint", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "", "def", "start_workers", "(", "self", ")", ":", "\n", "        ", "pipes", "=", "[", "mp", ".", "Pipe", "(", "duplex", "=", "True", ")", "for", "m", "in", "self", ".", "models", "]", "\n", "self", ".", "queue", "=", "mp", ".", "Queue", "(", ")", "\n", "self", ".", "workers", "=", "[", "Worker", "(", "i", ",", "self", ".", "queue", ",", "pipes", "[", "i", "]", "[", "1", "]", ",", "self", ".", "models", "[", "i", "]", ",", "self", ".", "summary", ",", "seed", "=", "self", ".", "rng", ".", "randint", "(", "low", "=", "0", ",", "high", "=", "2", "**", "31", ")", ",", "verbose", "=", "self", ".", "verbose", ")", "for", "i", "in", "range", "(", "len", "(", "self", ".", "models", ")", ")", "]", "\n", "self", ".", "pipes", "=", "[", "p", "[", "0", "]", "for", "p", "in", "pipes", "]", "\n", "\n", "self", ".", "log", "(", "\"Starting workers\"", ")", "\n", "for", "w", "in", "self", ".", "workers", ":", "\n", "            ", "w", ".", "start", "(", ")", "\n", "\n", "", "self", ".", "log", "(", "\"Done\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.stop_workers": [[142, 161], ["MPGenerator.MPGenerator.log", "zip", "MPGenerator.MPGenerator.queue.close", "MPGenerator.MPGenerator.log", "p.close", "MPGenerator.MPGenerator.log", "w.join", "w.terminate", "hasattr"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "stop_workers", "(", "self", ")", ":", "\n", "        ", "if", "not", "hasattr", "(", "self", ",", "\"workers\"", ")", "or", "self", ".", "workers", "is", "None", ":", "\n", "            ", "return", "\n", "\n", "", "self", ".", "log", "(", "\"Closing\"", ")", "\n", "for", "w", ",", "p", "in", "zip", "(", "self", ".", "workers", ",", "self", ".", "pipes", ")", ":", "\n", "            ", "self", ".", "log", "(", "\"Closing pipe\"", ")", "\n", "p", ".", "close", "(", ")", "\n", "\n", "", "for", "w", "in", "self", ".", "workers", ":", "\n", "            ", "self", ".", "log", "(", "\"Joining process\"", ")", "\n", "w", ".", "join", "(", "timeout", "=", "1", ")", "\n", "w", ".", "terminate", "(", ")", "\n", "\n", "", "self", ".", "queue", ".", "close", "(", ")", "\n", "\n", "self", ".", "workers", "=", "None", "\n", "self", ".", "pipes", "=", "None", "\n", "self", ".", "queue", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.iterate_minibatches": [[162, 171], ["len", "range"], "methods", ["None"], ["", "def", "iterate_minibatches", "(", "self", ",", "params", ",", "minibatch", "=", "50", ")", ":", "\n", "        ", "n_samples", "=", "len", "(", "params", ")", "\n", "\n", "for", "i", "in", "range", "(", "0", ",", "n_samples", "-", "minibatch", "+", "1", ",", "minibatch", ")", ":", "\n", "            ", "yield", "params", "[", "i", ":", "i", "+", "minibatch", "]", "\n", "\n", "", "rem_i", "=", "n_samples", "-", "(", "n_samples", "%", "minibatch", ")", "\n", "if", "rem_i", "!=", "n_samples", ":", "\n", "            ", "yield", "params", "[", "rem_i", ":", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.gen": [[172, 202], ["MPGenerator.MPGenerator.draw_params", "MPGenerator.MPGenerator.run_model"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.BaseGenerator.BaseGenerator.draw_params", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.run_model"], ["", "", "def", "gen", "(", "self", ",", "n_samples", ",", "n_reps", "=", "1", ",", "skip_feedback", "=", "False", ",", "prior_mixin", "=", "0", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Draw parameters and run forward model\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples\n        n_reps: int\n            Number of repetitions per parameter sample\n        skip_feedback: bool\n            If True, feedback checks on params, data and sum stats are skipped\n        verbose : bool or str\n            If False, will not display progress bars. If a string is passed,\n            it will be appended to the description of the progress bar.\n\n        Returns\n        -------\n        params : n_samples x n_reps x n_params\n            Parameters\n        stats : n_samples x n_reps x n_summary\n            Summary statistics of data\n        \"\"\"", "\n", "assert", "n_reps", "==", "1", ",", "'n_reps > 1 is not yet supported'", "\n", "\n", "params", "=", "self", ".", "draw_params", "(", "n_samples", "=", "n_samples", ",", "\n", "skip_feedback", "=", "skip_feedback", ",", "\n", "prior_mixin", "=", "prior_mixin", ",", "\n", "verbose", "=", "verbose", ")", "\n", "\n", "return", "self", ".", "run_model", "(", "params", ",", "skip_feedback", "=", "skip_feedback", ",", "verbose", "=", "verbose", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.run_model": [[203, 262], ["MPGenerator.MPGenerator.start_workers", "MPGenerator.MPGenerator.iterate_minibatches", "MPGenerator.MPGenerator.stop_workers", "numpy.array", "numpy.array", "stats.squeeze.squeeze.squeeze", "delfi.utils.progress.no_tqdm", "delfi.utils.progress.progressbar", "delfi.utils.progress.progressbar.set_description", "type", "zip", "len", "len", "active_list.append", "MPGenerator.MPGenerator.log", "p.send", "MPGenerator.MPGenerator.log", "MPGenerator.MPGenerator.log", "MPGenerator.MPGenerator.queue.get", "next", "type", "MPGenerator.MPGenerator.log", "delfi.utils.progress.progressbar.update", "len", "type", "MPGenerator.MPGenerator.log", "MPGenerator.MPGenerator.filter_data", "MPGenerator.MPGenerator.log", "type"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.start_workers", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.iterate_minibatches", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.stop_workers", "home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.progressbar", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.filter_data", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "run_model", "(", "self", ",", "params", ",", "minibatch", "=", "50", ",", "skip_feedback", "=", "False", ",", "keep_data", "=", "True", ",", "verbose", "=", "False", ")", ":", "\n", "# Run forward model for params (in batches)", "\n", "        ", "if", "not", "verbose", ":", "\n", "            ", "pbar", "=", "no_tqdm", "(", ")", "\n", "", "else", ":", "\n", "            ", "pbar", "=", "progressbar", "(", "total", "=", "len", "(", "params", ")", ")", "\n", "desc", "=", "'Run simulations '", "\n", "if", "type", "(", "verbose", ")", "==", "str", ":", "\n", "                ", "desc", "+=", "verbose", "\n", "", "pbar", ".", "set_description", "(", "desc", ")", "\n", "\n", "", "self", ".", "start_workers", "(", ")", "\n", "final_params", "=", "[", "]", "\n", "final_stats", "=", "[", "]", "# list of summary stats", "\n", "minibatches", "=", "self", ".", "iterate_minibatches", "(", "params", ",", "minibatch", ")", "\n", "done", "=", "False", "\n", "with", "pbar", ":", "\n", "            ", "while", "not", "done", ":", "\n", "                ", "active_list", "=", "[", "]", "\n", "for", "w", ",", "p", "in", "zip", "(", "self", ".", "workers", ",", "self", ".", "pipes", ")", ":", "\n", "                    ", "try", ":", "\n", "                        ", "params_batch", "=", "next", "(", "minibatches", ")", "\n", "", "except", "StopIteration", ":", "\n", "                        ", "done", "=", "True", "\n", "break", "\n", "\n", "", "active_list", ".", "append", "(", "(", "w", ",", "p", ")", ")", "\n", "self", ".", "log", "(", "\"Dispatching to worker (len = {})\"", ".", "format", "(", "len", "(", "params_batch", ")", ")", ")", "\n", "p", ".", "send", "(", "params_batch", ")", "\n", "self", ".", "log", "(", "\"Done\"", ")", "\n", "\n", "", "n_remaining", "=", "len", "(", "active_list", ")", "\n", "while", "n_remaining", ">", "0", ":", "\n", "                    ", "self", ".", "log", "(", "\"Listening to worker\"", ")", "\n", "msg", "=", "self", ".", "queue", ".", "get", "(", ")", "\n", "if", "type", "(", "msg", ")", "==", "int", ":", "\n", "                        ", "self", ".", "log", "(", "\"Received int\"", ")", "\n", "pbar", ".", "update", "(", "msg", ")", "\n", "", "elif", "type", "(", "msg", ")", "==", "tuple", ":", "\n", "                        ", "self", ".", "log", "(", "\"Received results\"", ")", "\n", "stats", ",", "params", "=", "self", ".", "filter_data", "(", "*", "msg", ",", "skip_feedback", "=", "skip_feedback", ")", "\n", "final_stats", "+=", "stats", "\n", "final_params", "+=", "params", "\n", "n_remaining", "-=", "1", "\n", "", "else", ":", "\n", "                        ", "self", ".", "log", "(", "\"Warning: Received unknown message of type {}\"", ".", "format", "(", "type", "(", "msg", ")", ")", ")", "\n", "\n", "", "", "", "", "self", ".", "stop_workers", "(", ")", "\n", "\n", "# TODO: for n_reps > 1 duplicate params; reshape stats array", "\n", "\n", "# n_samples x n_reps x dim theta", "\n", "params", "=", "np", ".", "array", "(", "final_params", ")", "\n", "\n", "# n_samples x n_reps x dim summary stats", "\n", "stats", "=", "np", ".", "array", "(", "final_stats", ")", "\n", "stats", "=", "stats", ".", "squeeze", "(", "axis", "=", "1", ")", "\n", "\n", "return", "params", ",", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.filter_data": [[263, 281], ["zip", "MPGenerator.MPGenerator._feedback_summary_stats", "ret_stats.append", "ret_params.append", "ValueError"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_summary_stats"], ["", "def", "filter_data", "(", "self", ",", "stats", ",", "params", ",", "skip_feedback", "=", "False", ")", ":", "\n", "        ", "if", "skip_feedback", "==", "True", ":", "\n", "            ", "return", "stats", ",", "params", "\n", "\n", "", "ret_stats", "=", "[", "]", "\n", "ret_params", "=", "[", "]", "\n", "\n", "for", "stat", ",", "param", "in", "zip", "(", "stats", ",", "params", ")", ":", "\n", "            ", "response", "=", "self", ".", "_feedback_summary_stats", "(", "stat", ")", "\n", "if", "response", "==", "'accept'", ":", "\n", "                ", "ret_stats", ".", "append", "(", "stat", ")", "\n", "ret_params", ".", "append", "(", "param", ")", "\n", "", "elif", "response", "==", "'discard'", ":", "\n", "                ", "continue", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'response not supported'", ")", "\n", "\n", "", "", "return", "ret_stats", ",", "ret_params", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator._feedback_summary_stats": [[282, 297], ["MPGenerator.MPGenerator.rej"], "methods", ["None"], ["", "def", "_feedback_summary_stats", "(", "self", ",", "sum_stats", ")", ":", "\n", "        ", "\"\"\"Feedback step after summary stats were computed\n        Parameters\n        ----------\n        sum_stats : np.array\n            Summary stats\n        Returns\n        -------\n        response : str\n            Supported responses are in ['accept', 'discard']\n        \"\"\"", "\n", "if", "self", ".", "rej", "(", "sum_stats", ")", ":", "\n", "            ", "return", "'accept'", "\n", "", "else", ":", "\n", "            ", "return", "'discard'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log": [[298, 301], ["print"], "methods", ["None"], ["", "", "def", "log", "(", "self", ",", "msg", ")", ":", "\n", "        ", "if", "self", ".", "verbose", ":", "\n", "            ", "print", "(", "\"Parent: {}\"", ".", "format", "(", "msg", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.__del__": [[302, 304], ["MPGenerator.MPGenerator.stop_workers"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.stop_workers"], ["", "", "def", "__del__", "(", "self", ")", ":", "\n", "        ", "self", ".", "stop_workers", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.default_MPGenerator_rej": [[77, 79], ["None"], "function", ["None"], ["", "", "", "def", "default_MPGenerator_rej", "(", "x", ")", ":", "\n", "    ", "return", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.default_slurm_options": [[306, 315], ["os.path.expanduser", "os.path.join", "os.path.expanduser"], "function", ["None"], ["", "", "def", "default_slurm_options", "(", ")", ":", "# pragma: no cover", "\n", "    ", "opts", "=", "{", "'clusters'", ":", "None", ",", "\n", "'time'", ":", "'1:00:00'", ",", "\n", "'D'", ":", "os", ".", "path", ".", "expanduser", "(", "'~'", ")", ",", "\n", "'ntasks-per-node'", ":", "1", ",", "\n", "'nodes'", ":", "1", ",", "\n", "'output'", ":", "os", ".", "path", ".", "join", "(", "os", ".", "path", ".", "expanduser", "(", "'~'", ")", ",", "'%j.out'", ")", "\n", "}", "\n", "return", "opts", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.generate_slurm_script": [[317, 358], ["MPGenerator.default_slurm_options", "open", "pickle.load", "default_slurm_options.update", "open", "f.write", "default_slurm_options.items", "f.write", "f.write", "default_slurm_options.keys", "default_slurm_options.keys", "os.path.splitext", "f.write", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.default_slurm_options", "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update"], ["", "def", "generate_slurm_script", "(", "filename", ")", ":", "# pragma: no cover", "\n", "    ", "\"\"\"\n    Save a slurm script to run mpgen_from_file through a SLURM job manager\n\n    :param filename:\n    :return:\n    \"\"\"", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "\n", "", "slurm_options", "=", "default_slurm_options", "(", ")", "\n", "if", "data", "[", "'slurm_options'", "]", "is", "not", "None", ":", "\n", "        ", "slurm_options", ".", "update", "(", "data", "[", "'slurm_options'", "]", ")", "\n", "", "assert", "slurm_options", "[", "'clusters'", "]", "is", "not", "None", ",", "\"cluster(s) must be specified\"", "\n", "assert", "'wait'", "not", "in", "slurm_options", ".", "keys", "(", ")", "and", "'W'", "not", "in", "slurm_options", ".", "keys", "(", ")", ",", "\"--wait/W always on, not options\"", "\n", "\n", "slurm_script_file", "=", "os", ".", "path", ".", "splitext", "(", "filename", ")", "[", "0", "]", "+", "'_slurm.sh'", "\n", "with", "open", "(", "slurm_script_file", ",", "'w'", ")", "as", "f", ":", "\n", "\n", "        ", "f", ".", "write", "(", "'#!/bin/bash\\n'", ")", "\n", "\n", "for", "key", ",", "val", "in", "slurm_options", ".", "items", "(", ")", ":", "\n", "            ", "if", "len", "(", "key", ")", "==", "1", ":", "\n", "                ", "prefix", "=", "'-'", "\n", "postfix", "=", "' '", "\n", "", "else", ":", "\n", "                ", "prefix", "=", "'--'", "\n", "postfix", "=", "'='", "\n", "", "s", "=", "'#SBATCH {0}{1}'", ".", "format", "(", "prefix", ",", "key", ")", "\n", "if", "val", "is", "not", "None", ":", "\n", "                ", "s", "+=", "'{0}{1}'", ".", "format", "(", "postfix", ",", "val", ")", "\n", "", "f", ".", "write", "(", "s", "+", "'\\n'", ")", "\n", "\n", "", "f", ".", "write", "(", "'#SBATCH --wait\\n'", ")", "# block execution until the job finishes", "\n", "# f.write('source /etc/profile.d/modules.sh\\n')  # for LRZ, may not be universal", "\n", "\n", "python_commands", "=", "'from delfi.generator.MPGenerator import mpgen_from_file;'", "'mpgen_from_file(\\'{0}\\', from_slurm=True)'", ".", "format", "(", "filename", ")", "\n", "f", ".", "write", "(", "'srun {0} -c \"{1}\"\\n'", ".", "format", "(", "data", "[", "'python_executable'", "]", ",", "python_commands", ")", ")", "\n", "\n", "", "return", "slurm_options", ",", "slurm_script_file", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.get_slurm_task_index": [[360, 363], ["int", "int", "os.getenv", "os.getenv().split", "os.getenv"], "function", ["None"], ["", "def", "get_slurm_task_index", "(", ")", ":", "# pragma: no cover", "\n", "    ", "localid", "=", "int", "(", "os", ".", "getenv", "(", "'SLURM_LOCALID'", ")", ")", "\n", "return", "int", "(", "os", ".", "getenv", "(", "'SLURM_GTIDS'", ")", ".", "split", "(", "','", ")", "[", "localid", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.mpgen_from_file": [[365, 502], ["time.time", "numpy.minimum", "numpy.random.RandomState", "np.random.RandomState.randint", "prior.reseed", "open", "pickle.load", "MPGenerator.get_slurm_task_index", "os.getenv", "print", "int", "os.path.splitext", "int", "multiprocessing.cpu_count", "np.random.RandomState.randint", "MPGenerator.MPGenerator", "np.random.RandomState.randint", "delfi.generator.Default.Default", "delfi.generator.Default.Default.gen", "os.getenv", "numpy.ceil", "numpy.minimum", "MPGenerator.generate_slurm_script", "subprocess.run", "int", "range", "range", "slurm_options[].replace", "os.remove", "np.random.RandomState.randint", "numpy.minimum", "time.time", "open", "pickle.dump", "int", "int", "len", "sys.stderr.write", "numpy.full", "os.path.splitext", "time.time", "open", "pickle.dump", "os.path.splitext", "os.remove", "str", "sys.stderr.write", "os.remove", "range", "np.random.RandomState.randint", "np.random.RandomState.randint", "numpy.vstack", "numpy.vstack", "dict", "subprocess.run.stdout.decode().split", "rng.randint.startswith", "[].split", "os.path.exists", "open", "pickle.load", "dict", "os.path.exists", "subprocess.run.stderr.decode", "subprocess.run.stdout.decode", "numpy.vstack", "numpy.vstack", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.get_slurm_task_index", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.generate_slurm_script", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.utils.io.load"], ["", "def", "mpgen_from_file", "(", "filename", ",", "n_workers", "=", "None", ",", "from_slurm", "=", "False", ",", "cleanup", "=", "True", ")", ":", "# pragma: no cover", "\n", "    ", "\"\"\"\n    Run simulations from a file using a multi-process generator, and save them in a file.\n\n    This function can be used as a stand-alone utility, but is mainly meant to be called on a remote host over ssh by a\n    RemoteGenerator.\n\n    :param cleanup:\n    :param from_slurm:\n    :param n_workers:\n    :param filename: file describing simulations to be run\n    :return:\n    \"\"\"", "\n", "start_time", "=", "time", ".", "time", "(", ")", "\n", "with", "open", "(", "filename", ",", "'rb'", ")", "as", "f", ":", "\n", "        ", "data", "=", "pickle", ".", "load", "(", "f", ")", "\n", "\n", "", "if", "from_slurm", ":", "# this function is running on a slurm node", "\n", "\n", "        ", "tid", "=", "get_slurm_task_index", "(", ")", "\n", "ncpus", "=", "os", ".", "getenv", "(", "'SLURM_JOB_CPUS_PER_NODE'", ")", "\n", "print", "(", "'started task {0}, {1} cpus\\n'", ".", "format", "(", "tid", ",", "ncpus", ")", ")", "\n", "generator_seed", "=", "data", "[", "'generator_seed'", "]", "+", "tid", "\n", "ntasks", "=", "int", "(", "os", ".", "getenv", "(", "'SLURM_NTASKS'", ")", ")", "\n", "\n", "sf", ",", "se", "=", "os", ".", "path", ".", "splitext", "(", "data", "[", "'samplefile'", "]", ")", "\n", "samplefile", "=", "sf", "+", "'_{0}'", ".", "format", "(", "tid", ")", "+", "se", "\n", "\n", "samples_per_task", "=", "int", "(", "np", ".", "ceil", "(", "data", "[", "'n_samples'", "]", "/", "ntasks", ")", ")", "\n", "n_samples", "=", "np", ".", "minimum", "(", "(", "tid", "+", "1", ")", "*", "samples_per_task", ",", "data", "[", "'n_samples'", "]", ")", "-", "tid", "*", "samples_per_task", "\n", "\n", "", "elif", "data", "[", "'use_slurm'", "]", ":", "# start a slurm job that will call this function once per task", "\n", "\n", "        ", "slurm_options", ",", "slurm_script_file", "=", "generate_slurm_script", "(", "filename", ")", "\n", "ntasks", "=", "int", "(", "slurm_options", "[", "'ntasks-per-node'", "]", ")", "*", "int", "(", "slurm_options", "[", "'nodes'", "]", ")", "\n", "\n", "result", "=", "subprocess", ".", "run", "(", "[", "'sbatch'", ",", "slurm_script_file", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ",", "stderr", "=", "subprocess", ".", "PIPE", ")", "\n", "# sbatch will now block until job is completed due to --wait flag", "\n", "prefix", "=", "'Submitted batch job '", "\n", "L", "=", "[", "s", "for", "s", "in", "result", ".", "stdout", ".", "decode", "(", ")", ".", "split", "(", "'\\n'", ")", "if", "s", ".", "startswith", "(", "prefix", ")", "]", "\n", "assert", "len", "(", "L", ")", "==", "1", ",", "\"job was not submitted correctly\"", "\n", "jobid", "=", "int", "(", "L", "[", "0", "]", "[", "len", "(", "prefix", ")", ":", "]", ".", "split", "(", "' '", ")", "[", "0", "]", ")", "\n", "if", "result", ".", "returncode", "!=", "0", ":", "# e.g. job timed out", "\n", "            ", "sys", ".", "stderr", ".", "write", "(", "'SLURM job {0} terminated abnormally: {1}'", ".", "format", "(", "jobid", ",", "result", ".", "stderr", ".", "decode", "(", ")", ")", ")", "\n", "\n", "# collect results from each task's file", "\n", "", "params", ",", "stats", ",", "task_time", "=", "None", ",", "None", ",", "np", ".", "full", "(", "ntasks", ",", "np", ".", "nan", ")", "\n", "for", "tid", "in", "range", "(", "ntasks", ")", ":", "\n", "            ", "sf", ",", "se", "=", "os", ".", "path", ".", "splitext", "(", "data", "[", "'samplefile'", "]", ")", "\n", "samplefile_this_task", "=", "sf", "+", "'_{0}'", ".", "format", "(", "tid", ")", "+", "se", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "samplefile_this_task", ")", ":", "\n", "                ", "continue", "\n", "\n", "", "with", "open", "(", "samplefile_this_task", ",", "'rb'", ")", "as", "f", ":", "\n", "                ", "samples", "=", "pickle", ".", "load", "(", "f", ")", "\n", "if", "params", "is", "None", ":", "\n", "                    ", "params", ",", "stats", "=", "samples", "[", "'params'", "]", ",", "samples", "[", "'stats'", "]", "\n", "", "else", ":", "\n", "                    ", "params", ",", "stats", "=", "np", ".", "vstack", "(", "(", "params", ",", "samples", "[", "'params'", "]", ")", ")", ",", "np", ".", "vstack", "(", "(", "stats", ",", "samples", "[", "'stats'", "]", ")", ")", "\n", "", "task_time", "[", "tid", "]", "=", "samples", "[", "'time'", "]", "\n", "", "", "assert", "params", "is", "not", "None", ",", "\"failed to generate any samples\"", "\n", "\n", "elapsed_time", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "\n", "# save all samples in one file", "\n", "with", "open", "(", "data", "[", "'samplefile'", "]", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "dict", "(", "params", "=", "params", ",", "stats", "=", "stats", ",", "time", "=", "elapsed_time", ",", "task_time", "=", "task_time", ")", ",", "f", ",", "\n", "protocol", "=", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "\n", "", "if", "not", "cleanup", ":", "\n", "            ", "return", "\n", "\n", "#clean up all created files except the final samplefile:", "\n", "", "for", "tid", "in", "range", "(", "ntasks", ")", ":", "\n", "            ", "sf", ",", "se", "=", "os", ".", "path", ".", "splitext", "(", "data", "[", "'samplefile'", "]", ")", "\n", "samplefile_this_task", "=", "sf", "+", "'_{0}'", ".", "format", "(", "tid", ")", "+", "se", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "samplefile_this_task", ")", ":", "\n", "                ", "continue", "\n", "", "os", ".", "remove", "(", "samplefile_this_task", ")", "\n", "\n", "", "outputfile", "=", "slurm_options", "[", "'output'", "]", ".", "replace", "(", "'%j'", ",", "str", "(", "jobid", ")", ")", "\n", "if", "'%'", "in", "outputfile", ":", "\n", "            ", "sys", ".", "stderr", ".", "write", "(", "'output file(s) not be removed, only %t is supported'", ")", "\n", "", "else", ":", "\n", "            ", "os", ".", "remove", "(", "outputfile", ")", "\n", "\n", "", "os", ".", "remove", "(", "slurm_script_file", ")", "\n", "\n", "return", "\n", "\n", "", "else", ":", "# non-SLURM: use a single generator for all the samples", "\n", "\n", "        ", "n_samples", ",", "generator_seed", ",", "samplefile", "=", "data", "[", "'n_samples'", "]", ",", "data", "[", "'generator_seed'", "]", ",", "data", "[", "'samplefile'", "]", "\n", "\n", "", "if", "n_workers", "is", "None", ":", "\n", "        ", "n_workers", "=", "data", "[", "'n_workers'", "]", "\n", "", "if", "n_workers", "is", "None", ":", "\n", "        ", "n_workers", "=", "mp", ".", "cpu_count", "(", ")", "\n", "", "n_workers", "=", "np", ".", "minimum", "(", "n_workers", ",", "n_samples", ")", "\n", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "generator_seed", "+", "2500", ")", "\n", "summary_seed", "=", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "summary", "=", "data", "[", "'summary_class'", "]", "(", "*", "data", "[", "'summary_args'", "]", ",", "seed", "=", "summary_seed", ",", "**", "data", "[", "'summary_kwargs'", "]", ")", "\n", "prior", "=", "data", "[", "'prior'", "]", "\n", "prior", ".", "reseed", "(", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", ")", "\n", "\n", "if", "n_workers", ">", "1", ":", "\n", "        ", "simulator_seeds", "=", "[", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "for", "_", "in", "range", "(", "n_workers", ")", "]", "\n", "\n", "models", "=", "[", "data", "[", "'simulator_class'", "]", "(", "*", "data", "[", "'simulator_args'", "]", ",", "seed", "=", "s", ",", "**", "data", "[", "'simulator_kwargs'", "]", ")", "\n", "for", "s", "in", "simulator_seeds", "]", "\n", "g", "=", "MPGenerator", "(", "models", ",", "data", "[", "'prior'", "]", ",", "summary", ",", "seed", "=", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", ",", "verbose", "=", "False", ")", "\n", "", "else", ":", "\n", "        ", "s", "=", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "model", "=", "data", "[", "'simulator_class'", "]", "(", "*", "data", "[", "'simulator_args'", "]", ",", "seed", "=", "s", ",", "**", "data", "[", "'simulator_kwargs'", "]", ")", "\n", "g", "=", "Default", "(", "model", ",", "data", "[", "'prior'", "]", ",", "summary", ",", "seed", "=", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", ")", "\n", "\n", "", "g", ".", "proposal", "=", "data", "[", "'proposal'", "]", "\n", "\n", "samples_remaining", ",", "params", ",", "stats", "=", "n_samples", ",", "None", ",", "None", "\n", "while", "samples_remaining", ">", "0", ":", "\n", "\n", "        ", "if", "data", "[", "'save_every'", "]", "is", "not", "None", ":", "\n", "            ", "next_batchsize", "=", "np", ".", "minimum", "(", "samples_remaining", ",", "data", "[", "'save_every'", "]", ")", "\n", "", "else", ":", "\n", "            ", "next_batchsize", "=", "samples_remaining", "\n", "\n", "", "next_params", ",", "next_stats", "=", "g", ".", "gen", "(", "next_batchsize", ",", "**", "data", "[", "'generator_kwargs'", "]", ")", "\n", "if", "params", "is", "None", ":", "\n", "            ", "params", ",", "stats", "=", "next_params", ",", "next_stats", "\n", "", "else", ":", "\n", "            ", "params", ",", "stats", "=", "np", ".", "vstack", "(", "(", "params", ",", "next_params", ")", ")", ",", "np", ".", "vstack", "(", "(", "stats", ",", "next_stats", ")", ")", "\n", "", "samples_remaining", "-=", "next_params", ".", "shape", "[", "0", "]", "\n", "\n", "elapsed_time", "=", "time", ".", "time", "(", ")", "-", "start_time", "\n", "with", "open", "(", "samplefile", ",", "'wb'", ")", "as", "f", ":", "\n", "            ", "pickle", ".", "dump", "(", "dict", "(", "params", "=", "params", ",", "stats", "=", "stats", ",", "time", "=", "elapsed_time", ")", ",", "f", ",", "protocol", "=", "pickle", ".", "HIGHEST_PROTOCOL", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.RejKernel.RejKernel.__init__": [[9, 32], ["delfi.generator.Default.Default.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "rej", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generator\n\n        Parameters\n        ----------\n        model : Simulator instance\n            Forward model\n        prior : Distribution or Mixture instance\n            Prior over parameters\n        summary : SummaryStats instance\n            Summary statistics\n        rej : rejection function\n            Rejection kernel implementation\n\n        Attributes\n        ----------\n        proposal : None or Distribution or Mixture instance\n            Proposal prior over parameters. If specified, will generate\n            samples given parameters drawn from proposal distribution rather\n            than samples drawn from prior when `gen` is called.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "**", "kwargs", ")", "\n", "self", ".", "rej", "=", "rej", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.RejKernel.RejKernel._feedback_summary_stats": [[33, 39], ["RejKernel.RejKernel.rej"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "_feedback_summary_stats", "(", "self", ",", "sum_stats", ")", ":", "\n", "        ", "if", "self", ".", "rej", "(", "sum_stats", ")", ":", "\n", "            ", "return", "'accept'", "\n", "", "else", ":", "\n", "            ", "return", "'discard'", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_proposed_param": [[8, 31], ["isinstance", "isinstance", "numpy.any", "numpy.any", "enumerate", "isinstance", "isinstance", "numpy.any", "numpy.any", "numpy.any"], "methods", ["None"], ["    ", "@", "copy_ancestor_docstring", "\n", "def", "_feedback_proposed_param", "(", "self", ",", "param", ")", ":", "\n", "# See BaseGenerator for docstring", "\n", "\n", "# if prior is uniform, reject samples outside of bounds", "\n", "# samples might be drawn outside bounds due to proposal", "\n", "        ", "if", "isinstance", "(", "self", ".", "prior", ",", "dd", ".", "Uniform", ")", ":", "\n", "            ", "if", "np", ".", "any", "(", "param", "<", "self", ".", "prior", ".", "lower", ")", "or", "np", ".", "any", "(", "param", ">", "self", ".", "prior", ".", "upper", ")", ":", "\n", "                ", "return", "'resample'", "\n", "", "", "elif", "isinstance", "(", "self", ".", "prior", ",", "dd", ".", "IndependentJoint", ")", ":", "\n", "            ", "for", "j", ",", "p", "in", "enumerate", "(", "self", ".", "prior", ".", "dists", ")", ":", "\n", "                ", "ii", "=", "self", ".", "prior", ".", "dist_index_eachdim", "==", "j", "\n", "if", "isinstance", "(", "p", ",", "dd", ".", "Uniform", ")", ":", "\n", "                    ", "if", "np", ".", "any", "(", "param", "[", ":", ",", "ii", "]", "<", "p", ".", "lower", ")", "or", "np", ".", "any", "(", "param", "[", ":", ",", "ii", "]", ">", "p", ".", "upper", ")", ":", "\n", "                        ", "return", "'resample'", "\n", "\n", "", "", "elif", "isinstance", "(", "p", ",", "dd", ".", "Gamma", ")", ":", "\n", "                    ", "if", "np", ".", "any", "(", "param", "[", ":", ",", "ii", "]", "<", "p", ".", "offset", ")", ":", "\n", "                        ", "return", "'resample'", "\n", "\n", "", "", "", "", "return", "'accept'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_forward_model": [[32, 36], ["None"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "_feedback_forward_model", "(", "self", ",", "data", ")", ":", "\n", "# See BaseGenerator for docstring", "\n", "        ", "return", "'accept'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.generator.Default.Default._feedback_summary_stats": [[37, 41], ["None"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "_feedback_summary_stats", "(", "self", ",", "sum_stats", ")", ":", "\n", "# See BaseGenerator for docstring", "\n", "        ", "return", "'accept'", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.__init__": [[26, 121], ["theano.grad", "theano.grad", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "step", "set", "theano.function", "theano.function", "theano.function", "theano.function", "float", "numpy.random.RandomState", "numpy.random.RandomState", "lasagne.total_norm_constraint", "numpy.array", "len", "zip", "int", "theano.function", "theano.function", "theano.function", "theano.function", "len", "monitor.items"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "network", ",", "loss", ",", "trn_data", ",", "trn_inputs", ",", "step", "=", "lu", ".", "adam", ",", "lr", "=", "0.001", ",", "lr_decay", "=", "1.0", ",", "max_norm", "=", "0.1", ",", "\n", "monitor", "=", "None", ",", "val_frac", "=", "0.0", ",", "assemble_extra_inputs", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Construct and configure the trainer\n\n        The trainer takes as inputs a neural network, a loss function and\n        training data. During init the theano functions for training are\n        compiled.\n\n        Parameters\n        ----------\n        network : NeuralNet instance\n            The neural network to train\n        loss : theano variable\n            Loss function to be computed for network training\n        trn_data : tuple of arrays\n            Training data in the form (params, stats)\n        trn_inputs : list of theano variables\n            Theano variables that should contain the the training data\n        step : function\n            Function to call for updates, will pass gradients and parameters\n        lr : float\n            initial learning rate\n        lr_decay : float\n            learning rate decay factor, learning rate for each epoch is\n            set to lr * (lr_decay**epoch)\n        max_norm : float\n            Total norm constraint for gradients\n        monitor : dict\n            Dict containing theano variables (and names as keys) that should be\n            recorded during training along with the loss function\n        val_frac: float\n            Fraction of dataset to use as validation set\n        assemble_extra_inputs: function\n            (optional) function to compute extra inputs needed to evaluate loss\n        seed : int or None\n            If provided, random number generator for batches will be seeded\n        \"\"\"", "\n", "self", ".", "network", "=", "network", "\n", "self", ".", "loss", "=", "loss", "\n", "self", ".", "trn_data", "=", "trn_data", "\n", "self", ".", "trn_inputs", "=", "trn_inputs", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n", "# gradients", "\n", "", "grads", "=", "tt", ".", "grad", "(", "self", ".", "loss", ",", "self", ".", "network", ".", "aps", ")", "\n", "if", "max_norm", "is", "not", "None", ":", "\n", "            ", "grads", "=", "lu", ".", "total_norm_constraint", "(", "grads", ",", "max_norm", "=", "max_norm", ")", "\n", "\n", "# updates", "\n", "", "self", ".", "lr", "=", "lr", "\n", "self", ".", "lr_decay", "=", "lr_decay", "\n", "self", ".", "lr_op", "=", "theano", ".", "shared", "(", "np", ".", "array", "(", "self", ".", "lr", ",", "dtype", "=", "dtype", ")", ")", "\n", "self", ".", "updates", "=", "step", "(", "grads", ",", "self", ".", "network", ".", "aps", ",", "learning_rate", "=", "self", ".", "lr_op", ")", "\n", "\n", "# check trn_data", "\n", "n_trn_data_list", "=", "set", "(", "[", "x", ".", "shape", "[", "0", "]", "for", "x", "in", "trn_data", "]", ")", "\n", "assert", "len", "(", "n_trn_data_list", ")", "==", "1", ",", "'trn_data elements got different len'", "\n", "self", ".", "n_trn_data", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# outputs", "\n", "self", ".", "trn_outputs_names", "=", "[", "'loss'", "]", "\n", "self", ".", "trn_outputs_nodes", "=", "[", "self", ".", "loss", "]", "\n", "if", "monitor", "is", "not", "None", "and", "len", "(", "monitor", ")", ">", "0", ":", "\n", "            ", "monitor_names", ",", "monitor_nodes", "=", "zip", "(", "*", "monitor", ".", "items", "(", ")", ")", "\n", "self", ".", "trn_outputs_names", "+=", "monitor_names", "\n", "self", ".", "trn_outputs_nodes", "+=", "monitor_nodes", "\n", "\n", "# function for single update", "\n", "", "self", ".", "make_update", "=", "theano", ".", "function", "(", "\n", "inputs", "=", "self", ".", "trn_inputs", ",", "\n", "outputs", "=", "self", ".", "trn_outputs_nodes", ",", "\n", "updates", "=", "self", ".", "updates", "\n", ")", "\n", "\n", "self", ".", "assemble_extra_inputs", "=", "assemble_extra_inputs", "\n", "\n", "self", ".", "do_validation", "=", "val_frac", ">", "0", "\n", "\n", "if", "self", ".", "do_validation", ":", "\n", "\n", "            ", "n_trn", "=", "int", "(", "(", "1", "-", "val_frac", ")", "*", "self", ".", "n_trn_data", ")", "\n", "self", ".", "val_data", "=", "[", "data", "[", "n_trn", ":", "]", "for", "data", "in", "trn_data", "]", ".", "copy", "(", ")", "# copy() might be overly prudent", "\n", "self", ".", "trn_data", "=", "[", "data", "[", ":", "n_trn", "]", "for", "data", "in", "trn_data", "]", ".", "copy", "(", ")", "\n", "\n", "# compile theano function for validation", "\n", "self", ".", "eval_loss", "=", "theano", ".", "function", "(", "inputs", "=", "self", ".", "trn_inputs", ",", "outputs", "=", "self", ".", "loss", ")", "\n", "self", ".", "best_val_loss", "=", "np", ".", "inf", "\n", "\n", "# initialize variables", "\n", "", "self", ".", "loss", "=", "float", "(", "'inf'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.calc_validation_loss": [[122, 135], ["numpy.minimum", "tuple", "Trainer.Trainer.assemble_extra_inputs", "Trainer.Trainer.eval_loss"], "methods", ["None"], ["", "def", "calc_validation_loss", "(", "self", ",", "minibatch", ",", "strict_batch_size", ")", ":", "\n", "        ", "s", ",", "L", ",", "n_val", ",", "n_batches_used", "=", "0", ",", "0.0", ",", "self", ".", "val_data", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "0.0", "# n_batches_used can be fractional", "\n", "\n", "while", "s", "<", "n_val", "and", "(", "not", "strict_batch_size", "or", "s", "+", "minibatch", "<=", "n_val", ")", ":", "\n", "            ", "e", "=", "np", ".", "minimum", "(", "s", "+", "minibatch", ",", "n_val", ")", "\n", "next_batch", "=", "tuple", "(", "[", "x", "[", "s", ":", "e", "]", "for", "x", "in", "self", ".", "trn_data", "]", ")", "\n", "if", "self", ".", "assemble_extra_inputs", "is", "not", "None", ":", "\n", "                ", "next_batch", "=", "self", ".", "assemble_extra_inputs", "(", "next_batch", ")", "\n", "", "L", "+=", "self", ".", "eval_loss", "(", "*", "next_batch", ")", "*", "(", "s", "-", "e", ")", "/", "minibatch", "\n", "n_batches_used", "+=", "(", "s", "-", "e", ")", "/", "minibatch", "\n", "s", "+=", "minibatch", "\n", "\n", "", "return", "L", "/", "n_batches_used", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train": [[136, 287], ["trn_outputs.items", "min", "int", "x.astype", "delfi.utils.progress.no_tqdm", "delfi.utils.progress.progressbar", "delfi.utils.progress.progressbar.set_description", "range", "numpy.asarray", "print", "type", "Trainer.Trainer.lr_op.set_value", "Trainer.iterate_minibatches", "float", "Trainer.Trainer.make_update", "zip", "delfi.utils.progress.progressbar.update", "print", "Trainer.Trainer.gen_newseed", "Trainer.Trainer.assemble_extra_inputs", "tuple", "trn_outputs[].append", "numpy.isnan", "print", "tuple", "abs", "Trainer.Trainer.calc_validation_loss", "trn_outputs[].append", "trn_outputs[].append", "numpy.floor", "numpy.floor", "print"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.progress.progressbar", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.iterate_minibatches", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.calc_validation_loss"], ["", "def", "train", "(", "self", ",", "\n", "epochs", "=", "250", ",", "\n", "minibatch", "=", "50", ",", "\n", "patience", "=", "20", ",", "\n", "monitor_every", "=", "None", ",", "\n", "stop_on_nan", "=", "False", ",", "\n", "strict_batch_size", "=", "False", ",", "\n", "tol", "=", "None", ",", "\n", "verbose", "=", "False", ",", "\n", "print_each_epoch", "=", "False", ")", ":", "\n", "        ", "\"\"\"Trains the model\n\n        Parameters\n        ----------\n        epochs : int\n            number of epochs (iterations per sample)\n        minibatch : int\n            minibatch size\n        monitor_every : float\n            after how many epochs should validation loss be checked?\n        stop_on_nan : bool (default: False)\n            if True, will stop if loss becomes NaN\n        tol : float\n            tolerance criterion for stopping based on training set\n        verbose : bool\n            if True, print progress during training\n        strict_batch_size : bool\n            Whether to ignore last batch if it would be smaller than minibatch\n        print_each_epoch: bool\n            Whether to print a period `.' each epoch, useful to avoid timeouts in continuous integration.\n\n        Returns\n        -------\n        dict : containing loss values and possibly additional keys\n        \"\"\"", "\n", "\n", "# initialize variables", "\n", "iter", "=", "0", "\n", "patience_left", "=", "patience", "\n", "if", "monitor_every", "is", "None", ":", "\n", "            ", "monitor_every", "=", "min", "(", "10", "**", "5", "/", "float", "(", "self", ".", "n_trn_data", ")", ",", "1.0", ")", "\n", "", "logger", "=", "sys", ".", "stdout", "\n", "\n", "# minibatch size", "\n", "minibatch", "=", "self", ".", "n_trn_data", "if", "minibatch", "is", "None", "else", "minibatch", "\n", "if", "minibatch", ">", "self", ".", "n_trn_data", ":", "\n", "            ", "minibatch", "=", "self", ".", "n_trn_data", "\n", "\n", "", "if", "self", ".", "do_validation", "and", "strict_batch_size", ":", "\n", "            ", "assert", "self", ".", "val_data", "[", "0", "]", ".", "shape", "[", "0", "]", ">=", "minibatch", ",", "\"not enough validation samples for a minibatch\"", "\n", "if", "self", ".", "val_data", "[", "0", "]", ".", "shape", "[", "0", "]", "%", "minibatch", "!=", "0", "and", "verbose", ":", "\n", "                ", "print", "(", "'{0} validation samples not a multiple of minibatch size {1}, some samples will be wasted'", ".", "\n", "format", "(", "self", ".", "val_data", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "minibatch", ")", ")", "\n", "\n", "", "", "maxiter", "=", "int", "(", "self", ".", "n_trn_data", "/", "minibatch", "+", "0.5", ")", "*", "epochs", "\n", "\n", "# placeholders for outputs", "\n", "trn_outputs", "=", "{", "}", "\n", "for", "key", "in", "self", ".", "trn_outputs_names", ":", "\n", "            ", "trn_outputs", "[", "key", "]", "=", "[", "]", "\n", "\n", "", "if", "self", ".", "do_validation", ":", "\n", "            ", "trn_outputs", "[", "'val_loss'", "]", ",", "trn_outputs", "[", "'val_loss_iter'", "]", "=", "[", "]", ",", "[", "]", "\n", "\n", "# cast trn_data", "\n", "", "self", ".", "trn_data", "=", "[", "x", ".", "astype", "(", "dtype", ")", "for", "x", "in", "self", ".", "trn_data", "]", "\n", "\n", "if", "not", "verbose", ":", "\n", "            ", "pbar", "=", "no_tqdm", "(", ")", "\n", "", "else", ":", "\n", "            ", "pbar", "=", "progressbar", "(", "total", "=", "maxiter", "*", "minibatch", ")", "\n", "desc", "=", "'Training on {0} samples'", ".", "format", "(", "self", ".", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", ")", "\n", "if", "type", "(", "verbose", ")", "==", "str", ":", "\n", "                ", "desc", "+=", "verbose", "\n", "", "pbar", ".", "set_description", "(", "desc", ")", "\n", "\n", "", "break_flag", "=", "False", "\n", "with", "pbar", ":", "\n", "# loop over epochs", "\n", "            ", "for", "epoch", "in", "range", "(", "epochs", ")", ":", "\n", "# set learning rate", "\n", "                ", "lr_epoch", "=", "self", ".", "lr", "*", "(", "self", ".", "lr_decay", "**", "epoch", ")", "\n", "self", ".", "lr_op", ".", "set_value", "(", "lr_epoch", ")", "\n", "\n", "# loop over batches", "\n", "for", "trn_batch", "in", "iterate_minibatches", "(", "self", ".", "trn_data", ",", "minibatch", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "strict_batch_size", "=", "strict_batch_size", ")", ":", "\n", "\n", "                    ", "if", "self", ".", "assemble_extra_inputs", "is", "not", "None", ":", "\n", "                        ", "trn_batch", "=", "self", ".", "assemble_extra_inputs", "(", "tuple", "(", "trn_batch", ")", ")", "\n", "", "else", ":", "\n", "                        ", "trn_batch", "=", "tuple", "(", "trn_batch", ")", "\n", "\n", "", "outputs", "=", "self", ".", "make_update", "(", "*", "trn_batch", ")", "\n", "\n", "for", "name", ",", "value", "in", "zip", "(", "self", ".", "trn_outputs_names", ",", "outputs", ")", ":", "\n", "                        ", "trn_outputs", "[", "name", "]", ".", "append", "(", "value", ")", "\n", "\n", "", "trn_loss", "=", "trn_outputs", "[", "'loss'", "]", "[", "-", "1", "]", "\n", "diff", "=", "self", ".", "loss", "-", "trn_loss", "\n", "self", ".", "loss", "=", "trn_loss", "\n", "\n", "# check for convergence", "\n", "if", "tol", "is", "not", "None", ":", "\n", "                        ", "if", "abs", "(", "diff", ")", "<", "tol", ":", "\n", "                            ", "break_flag", "=", "True", "\n", "break", "\n", "\n", "# check for nan", "\n", "", "", "if", "stop_on_nan", "and", "np", ".", "isnan", "(", "trn_loss", ")", ":", "\n", "                        ", "print", "(", "'stopping due to NaN value on iteration {0}\\n'", ".", "format", "(", "iter", ")", ")", "\n", "break_flag", "=", "True", "\n", "break", "\n", "\n", "# validation-data tracking of convergence", "\n", "", "if", "self", ".", "do_validation", ":", "\n", "                        ", "epoch_frac", "=", "(", "iter", "*", "minibatch", ")", "/", "self", ".", "n_trn_data", "# how many epochs so far", "\n", "prev_epoch_frac", "=", "(", "(", "iter", "-", "1", ")", "*", "minibatch", ")", "/", "self", ".", "n_trn_data", "\n", "# do validation if we've passed a multiple of monitor_every epochs", "\n", "if", "iter", "==", "0", "or", "np", ".", "floor", "(", "epoch_frac", "/", "monitor_every", ")", "!=", "np", ".", "floor", "(", "prev_epoch_frac", "/", "monitor_every", ")", ":", "\n", "                            ", "val_loss", "=", "self", ".", "calc_validation_loss", "(", "minibatch", ",", "strict_batch_size", ")", "\n", "trn_outputs", "[", "'val_loss'", "]", ".", "append", "(", "val_loss", ")", "\n", "trn_outputs", "[", "'val_loss_iter'", "]", ".", "append", "(", "iter", ")", "\n", "patience_left", "-=", "1", "\n", "\n", "if", "val_loss", "<", "self", ".", "best_val_loss", ":", "\n", "                                ", "self", ".", "best_val_loss", "=", "val_loss", "\n", "patience_left", "=", "patience", "# reset patience_left", "\n", "\n", "", "if", "patience_left", "<=", "0", ":", "\n", "                                ", "break_flag", "=", "True", "\n", "if", "verbose", ":", "\n", "                                    ", "print", "(", "'Stopping at epoch {0}, '", "\n", "'training loss = {1}, '", "\n", "'validation loss = {2}\\n'", "\n", ".", "format", "(", "epoch_frac", ",", "trn_loss", ",", "val_loss", ")", ")", "\n", "", "break", "\n", "", "", "", "pbar", ".", "update", "(", "minibatch", ")", "\n", "iter", "+=", "1", "\n", "", "if", "print_each_epoch", ":", "\n", "                    ", "print", "(", "'.'", ")", "\n", "", "if", "break_flag", ":", "\n", "                    ", "break", "\n", "\n", "# convert lists to arrays", "\n", "", "", "", "for", "name", ",", "value", "in", "trn_outputs", ".", "items", "(", ")", ":", "\n", "            ", "trn_outputs", "[", "name", "]", "=", "np", ".", "asarray", "(", "value", ")", "\n", "\n", "", "return", "trn_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.gen_newseed": [[288, 294], ["Trainer.Trainer.rng.randint"], "methods", ["None"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.ActiveTrainer.__init__": [[334, 399], ["Trainer.Trainer.__init__", "f_assemble_extra_inputs"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "network", ",", "loss", ",", "trn_data", ",", "trn_inputs", ",", "\n", "step", "=", "lu", ".", "adam", ",", "lr", "=", "0.001", ",", "lr_decay", "=", "1.0", ",", "max_norm", "=", "0.1", ",", "\n", "monitor", "=", "None", ",", "val_frac", "=", "0.", ",", "seed", "=", "None", ",", "\n", "generator", "=", "None", ",", "n_atoms", "=", "1", ",", "moo", "=", "'resample'", ",", "obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Construct and configure the trainer\n\n        The trainer takes as inputs a neural network, a loss function and\n        training data. During init the theano functions for training are\n        compiled.\n\n        Parameters\n        ----------\n        network : NeuralNet instance\n            The neural network to train\n        loss : theano variable\n            Loss function to be computed for network training\n        trn_data : tuple of arrays\n            Training data in the form (params, stats)\n        trn_inputs : list of theano variables\n            Theano variables that should contain the the training data\n        step : function\n            Function to call for updates, will pass gradients and parameters\n        lr : float\n            initial learning rate\n        lr_decay : float\n            learning rate decay factor, learning rate for each epoch is\n            set to lr * (lr_decay**epoch)\n        max_norm : float\n            Total norm constraint for gradients\n        monitor : dict\n            Dict containing theano variables (and names as keys) that should be\n            recorded during training along with the loss function\n        val_frac: float\n            Fraction of dataset to use as validation set\n        seed : int or None\n            If provided, random number generator for batches will be seeded\n        generator: delfi generator object\n            Object with gen method to generate additional simulation parameters\n        n_atoms: int\n            Number of additional simulation parameters to draw for atomic APT\n        moo: string\n            Mode of operation for generation of additional simulation parameters\n        obs: ndarray\n            Observed summary statistics \n        \"\"\"", "\n", "if", "network", ".", "density", "==", "'maf'", ":", "\n", "            ", "f_assemble_extra_inputs", "=", "self", ".", "assemble_extra_inputs_maf", "\n", "", "elif", "network", ".", "density", "==", "'mog'", ":", "\n", "            ", "f_assemble_extra_inputs", "=", "self", ".", "assemble_extra_inputs_mdn", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "def", "assemble_extra_inputs", "(", "trn_data", ")", ":", "\n", "            ", "return", "f_assemble_extra_inputs", "(", "\n", "trn_data", "=", "trn_data", ",", "\n", "generator", "=", "generator", ",", "\n", "n_atoms", "=", "n_atoms", ",", "\n", "moo", "=", "moo", ",", "\n", "obs", "=", "obs", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "network", "=", "network", ",", "loss", "=", "loss", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "step", "=", "step", ",", "lr", "=", "lr", ",", "lr_decay", "=", "lr_decay", ",", "max_norm", "=", "max_norm", ",", "\n", "monitor", "=", "monitor", ",", "val_frac", "=", "val_frac", ",", "seed", "=", "seed", ",", "\n", "assemble_extra_inputs", "=", "assemble_extra_inputs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.ActiveTrainer.assemble_extra_inputs_mdn": [[400, 429], ["generator.prior.eval().reshape().astype", "numpy.empty", "range", "numpy.concatenate", "NotImplemented", "generator.prior.eval().reshape", "trn_data[].reshape", "Trainer.ActiveTrainer.rng.choice", "numpy.mod", "generator.prior.eval", "numpy.concatenate.reshape"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "assemble_extra_inputs_mdn", "(", "self", ",", "trn_data", ",", "generator", ",", "n_atoms", ",", "\n", "moo", "=", "'resample'", ",", "obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"convenience function for assembling input for network training\"\"\"", "\n", "\n", "batchsize", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "if", "moo", "==", "'resample'", ":", "\n", "# all-to-all comparison of theta's and x's, n_atoms loss evaluations", "\n", "\n", "            ", "th_nl", "=", "np", ".", "empty", "(", "(", "batchsize", ",", "n_atoms", ",", "trn_data", "[", "0", "]", ".", "shape", "[", "1", "]", ")", ",", "dtype", "=", "dtype", ")", "\n", "for", "n", "in", "range", "(", "batchsize", ")", ":", "\n", "                ", "idx", "=", "self", ".", "rng", ".", "choice", "(", "batchsize", "-", "1", ",", "n_atoms", ",", "replace", "=", "False", ")", "+", "n", "+", "1", "\n", "th_nl", "[", "n", ",", ":", ",", ":", "]", "=", "trn_data", "[", "0", "]", "[", "np", ".", "mod", "(", "idx", ",", "batchsize", ")", "]", "\n", "", "theta_all", "=", "np", ".", "concatenate", "(", "\n", "(", "trn_data", "[", "0", "]", ".", "reshape", "(", "(", "batchsize", ",", "1", ",", "-", "1", ")", ")", ",", "\n", "th_nl", ")", ",", "axis", "=", "1", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplemented", "(", "'mode of operation not supported'", ")", "\n", "\n", "# compute log prior ratios (assuming atomic proposal)", "\n", "", "lprs", "=", "generator", ".", "prior", ".", "eval", "(", "\n", "theta_all", ".", "reshape", "(", "batchsize", "*", "(", "n_atoms", "+", "1", ")", ",", "-", "1", ")", ",", "\n", "log", "=", "True", ")", ".", "reshape", "(", "batchsize", ",", "n_atoms", "+", "1", ")", ".", "astype", "(", "dtype", ")", "\n", "\n", "# theta_all : (n_batch * (n_atoms + 1)  x n_outputs", "\n", "# lprs  : n_batch x (n_atoms+1)", "\n", "# x : n_batch x n_inputs", "\n", "trn_data", "=", "(", "theta_all", ",", "trn_data", "[", "1", "]", ",", "lprs", ",", "*", "trn_data", "[", "2", ":", "]", ")", "\n", "\n", "return", "trn_data", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.ActiveTrainer.assemble_extra_inputs_maf": [[430, 467], ["generator.prior.eval().reshape().astype", "numpy.tile", "NotImplemented", "numpy.empty", "range", "numpy.vstack", "Trainer.block_circulant", "generator.prior.eval().reshape", "Trainer.ActiveTrainer.rng.choice", "generator.prior.eval", "numpy.arange().reshape", "numpy.mod", "numpy.arange"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.block_circulant", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "assemble_extra_inputs_maf", "(", "self", ",", "trn_data", ",", "generator", ",", "n_atoms", ",", "\n", "moo", "=", "'resample'", ",", "obs", "=", "None", ")", ":", "\n", "        ", "\"\"\"convenience function for assembling input for network training.\n        Note the data are assembled in a different ordering than for the MDN.\n        \"\"\"", "\n", "batchsize", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "if", "moo", "==", "'resample'", ":", "\n", "\n", "            ", "if", "n_atoms", "<", "batchsize", "-", "1", ":", "\n", "# all-to-all comparison of theta's and x's, n_atoms loss evaluations", "\n", "\n", "                ", "idx_", "=", "np", ".", "empty", "(", "(", "batchsize", ",", "n_atoms", ")", ",", "dtype", "=", "int", ")", "\n", "for", "n", "in", "range", "(", "batchsize", ")", ":", "\n", "                    ", "idx_", "[", "n", "]", "=", "self", ".", "rng", ".", "choice", "(", "batchsize", "-", "1", ",", "n_atoms", ",", "\n", "replace", "=", "False", ")", "\n", "", "idx_", "=", "(", "idx_", "+", "np", ".", "arange", "(", "1", ",", "batchsize", "+", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "th_nl", "=", "np", ".", "vstack", "(", "(", "trn_data", "[", "0", "]", ",", "trn_data", "[", "0", "]", "[", "np", ".", "mod", "(", "idx_", ",", "batchsize", ")", "]", ")", ")", "\n", "\n", "", "else", ":", "\n", "\n", "                ", "assert", "n_atoms", "<", "batchsize", "\n", "th_nl", "=", "block_circulant", "(", "trn_data", "[", "0", "]", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "raise", "NotImplemented", "(", "'mode of operation not supported'", ")", "\n", "\n", "# compute log prior ratios (assuming atomic proposal)", "\n", "", "lprs", "=", "generator", ".", "prior", ".", "eval", "(", "th_nl", ",", "log", "=", "True", ")", ".", "reshape", "(", "n_atoms", "+", "1", ",", "batchsize", ")", ".", "astype", "(", "dtype", ")", "\n", "\n", "# inputs to MAF (summary stats)", "\n", "x_nl", "=", "np", ".", "tile", "(", "trn_data", "[", "1", "]", ",", "(", "n_atoms", "+", "1", ",", "1", ")", ")", "\n", "\n", "# th_nl : (n_batch * (n_atoms + 1), n_outputs)", "\n", "# lprs  : ((n_atoms + 1) * n_batch)", "\n", "# x_nl  : ((n_batch * (n_atoms + 1), *input_size)", "\n", "return", "(", "th_nl", ",", "x_nl", ",", "lprs", ",", "*", "trn_data", "[", "2", ":", "]", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.block_circulant": [[13, 23], ["numpy.lib.stride_tricks.as_strided", "numpy.lib.stride_tricks.as_strided.reshape", "numpy.tile", "x.flatten"], "function", ["None"], ["def", "block_circulant", "(", "x", ")", ":", "\n", "\n", "    ", "n", ",", "d", "=", "x", ".", "shape", "\n", "b", "=", "x", ".", "itemsize", "\n", "\n", "y", "=", "as_strided", "(", "np", ".", "tile", "(", "x", ".", "flatten", "(", ")", ",", "2", ")", ",", "\n", "shape", "=", "(", "n", ",", "n", ",", "d", ")", ",", "\n", "strides", "=", "(", "d", "*", "b", ",", "d", "*", "b", ",", "b", ")", ",", "\n", "writeable", "=", "False", ")", "\n", "return", "y", ".", "reshape", "(", "n", "**", "2", ",", "d", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.iterate_minibatches": [[296, 330], ["len", "numpy.arange", "numpy.random.RandomState", "np.random.RandomState.shuffle", "range", "range", "range", "len", "len"], "function", ["None"], ["", "", "", "def", "iterate_minibatches", "(", "trn_data", ",", "minibatch", "=", "10", ",", "seed", "=", "None", ",", "strict_batch_size", "=", "False", ")", ":", "\n", "    ", "\"\"\"Minibatch iterator\n\n    Parameters\n    ----------\n    trn_data : tuple of arrays\n        Training daa\n    minibatch : int\n        Size of batches\n    seed : None or int\n        Seed for minibatch order\n\n    Returns\n    -------\n    trn_batch : tuple of arrays\n        Batch of training data\n    \"\"\"", "\n", "n_samples", "=", "len", "(", "trn_data", "[", "0", "]", ")", "\n", "indices", "=", "np", ".", "arange", "(", "n_samples", ")", "\n", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "rng", ".", "shuffle", "(", "indices", ")", "\n", "\n", "start_idx", "=", "0", "\n", "\n", "for", "start_idx", "in", "range", "(", "0", ",", "n_samples", "-", "minibatch", "+", "1", ",", "minibatch", ")", ":", "\n", "        ", "excerpt", "=", "indices", "[", "start_idx", ":", "start_idx", "+", "minibatch", "]", "\n", "\n", "yield", "(", "trn_data", "[", "k", "]", "[", "excerpt", "]", "for", "k", "in", "range", "(", "len", "(", "trn_data", ")", ")", ")", "\n", "\n", "", "rem_i", "=", "n_samples", "-", "(", "n_samples", "%", "minibatch", ")", "\n", "if", "not", "strict_batch_size", "and", "rem_i", "!=", "n_samples", ":", "\n", "        ", "excerpt", "=", "indices", "[", "rem_i", ":", "]", "\n", "yield", "(", "trn_data", "[", "k", "]", "[", "excerpt", "]", "for", "k", "in", "range", "(", "len", "(", "trn_data", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.__init__": [[22, 194], ["density.lower", "list", "theano.vector", "theano.vector", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "lasagne.random.set_rng", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "collections.OrderedDict", "lasagne.InputLayer", "lasagne.InputLayer", "lasagne.InputLayer", "lasagne.FlattenLayer", "lasagne.FlattenLayer", "lasagne.FlattenLayer", "NeuralNet.NeuralNet.compile_funs", "delfi.utils.data.isint", "delfi.utils.data.isint", "delfi.utils.data.isint", "delfi.utils.data.isint", "list", "len", "type", "type", "numpy.random.RandomState", "numpy.random.RandomState", "len", "delfi.ImputeMissingLayer", "delfi.ImputeMissingLayer", "delfi.ReplaceMissingLayer", "delfi.ReplaceMissingLayer", "delfi.utils.odict.last", "delfi.utils.odict.last", "slice", "slice", "lasagne.SliceLayer", "lasagne.SliceLayer", "lasagne.SliceLayer", "lasagne.SliceLayer", "lasagne.SliceLayer", "lasagne.SliceLayer", "lasagne.ReshapeLayer", "lasagne.ReshapeLayer", "lasagne.ReshapeLayer", "lasagne.GRULayer", "lasagne.GRULayer", "lasagne.GRULayer", "range", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "lasagne.layers.ConcatLayer", "NeuralNet.NeuralNet.init_mdn", "len", "len", "len", "numpy.prod", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "lasagne.Conv2DLayer", "lasagne.Conv2DLayer", "lasagne.Conv2DLayer", "delfi.utils.odict.last", "delfi.utils.odict.last", "NeuralNet.NeuralNet.init_maf", "range", "range", "len", "len", "lasagne.MaxPool2DLayer", "lasagne.MaxPool2DLayer", "lasagne.MaxPool2DLayer", "delfi.utils.odict.last", "delfi.utils.odict.last", "len", "len", "delfi.utils.odict.last", "delfi.utils.odict.last", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.GlorotUniform", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "lasagne.init.Constant", "str", "str", "delfi.utils.odict.last", "delfi.utils.odict.last", "str", "str"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.compile_funs", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.init_mdn", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.init_maf", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last"], ["    ", "def", "__init__", "(", "self", ",", "n_inputs", "=", "None", ",", "n_outputs", "=", "None", ",", "input_shape", "=", "None", ",", "\n", "n_bypass", "=", "0", ",", "\n", "density", "=", "'mog'", ",", "\n", "n_hiddens", "=", "(", "10", ",", "10", ")", ",", "impute_missing", "=", "True", ",", "seed", "=", "None", ",", "\n", "n_filters", "=", "(", ")", ",", "filter_sizes", "=", "3", ",", "pool_sizes", "=", "2", ",", "\n", "n_rnn", "=", "0", ",", "\n", "**", "density_opts", ")", ":", "\n", "\n", "        ", "\"\"\"Initialize a mixture density network with custom layers\n\n        Parameters\n        ----------\n        n_inputs : int\n            Total input dimensionality (data/summary stats)\n        n_outputs : int\n            Dimensionality of output (simulator parameters)\n        input_shape : tuple\n            Size to which data are reshaped before CNN or RNN\n        n_bypass : int\n            Number of elements at end of input which bypass CNN or RNN\n        density : string\n            Type of density condition on the network, can be 'mog' or 'maf'\n        n_components : int\n            Number of components of the mixture density\n        n_filters : list of ints\n            Number of filters  per convolutional layer\n        n_hiddens : list of ints\n            Number of hidden units per fully connected layer\n        n_rnn : None or int\n            Number of RNN units\n        impute_missing : bool\n            If set to True, learns replacement value for NaNs, otherwise those\n            inputs are set to zero\n        seed : int or None\n            If provided, random number generator will be seeded\n        density_opts : dict\n            Options for the density estimator\n        \"\"\"", "\n", "if", "n_rnn", ">", "0", "and", "len", "(", "n_filters", ")", ">", "0", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "", "assert", "isint", "(", "n_inputs", ")", "and", "isint", "(", "n_outputs", ")", "and", "n_inputs", ">", "0", "and", "n_outputs", ">", "0", "\n", "\n", "self", ".", "density", "=", "density", ".", "lower", "(", ")", "\n", "self", ".", "impute_missing", "=", "impute_missing", "\n", "self", ".", "n_hiddens", "=", "list", "(", "n_hiddens", ")", "\n", "self", ".", "n_outputs", ",", "self", ".", "n_inputs", "=", "n_outputs", ",", "n_inputs", "\n", "self", ".", "n_bypass", "=", "n_bypass", "\n", "\n", "self", ".", "n_rnn", "=", "n_rnn", "\n", "\n", "self", ".", "n_filters", ",", "self", ".", "filter_sizes", ",", "self", ".", "pool_sizes", ",", "n_cnn", "=", "list", "(", "n_filters", ")", ",", "filter_sizes", ",", "pool_sizes", ",", "len", "(", "n_filters", ")", "\n", "if", "type", "(", "self", ".", "filter_sizes", ")", "is", "int", ":", "\n", "            ", "self", ".", "filter_sizes", "=", "[", "self", ".", "filter_sizes", "for", "_", "in", "range", "(", "n_cnn", ")", "]", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "self", ".", "filter_sizes", ")", ">=", "n_cnn", "\n", "", "if", "type", "(", "self", ".", "pool_sizes", ")", "is", "int", ":", "\n", "            ", "self", ".", "pool_sizes", "=", "[", "self", ".", "pool_sizes", "for", "_", "in", "range", "(", "n_cnn", ")", "]", "\n", "", "else", ":", "\n", "            ", "assert", "len", "(", "self", ".", "pool_sizes", ")", ">=", "n_cnn", "\n", "\n", "", "self", ".", "iws", "=", "tt", ".", "vector", "(", "'iws'", ",", "dtype", "=", "dtype", ")", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "", "lasagne", ".", "random", ".", "set_rng", "(", "self", ".", "rng", ")", "\n", "\n", "self", ".", "input_shape", "=", "(", "n_inputs", ",", ")", "if", "input_shape", "is", "None", "else", "input_shape", "\n", "assert", "np", ".", "prod", "(", "self", ".", "input_shape", ")", "+", "self", ".", "n_bypass", "==", "self", ".", "n_inputs", "\n", "assert", "1", "<=", "len", "(", "self", ".", "input_shape", ")", "<=", "3", "\n", "\n", "# params: output placeholder (batch, self.n_outputs)", "\n", "self", ".", "params", "=", "tensorN", "(", "2", ",", "name", "=", "'params'", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# stats : input placeholder, (batch, self.n_inputs)", "\n", "self", ".", "stats", "=", "tensorN", "(", "2", ",", "name", "=", "'stats'", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# compose layers", "\n", "self", ".", "layer", "=", "collections", ".", "OrderedDict", "(", ")", "\n", "\n", "# input layer, None indicates batch size not fixed at compile time", "\n", "self", ".", "layer", "[", "'input'", "]", "=", "ll", ".", "InputLayer", "(", "\n", "(", "None", ",", "self", ".", "n_inputs", ")", ",", "input_var", "=", "self", ".", "stats", ")", "\n", "\n", "# learn replacement values", "\n", "if", "self", ".", "impute_missing", ":", "\n", "            ", "self", ".", "layer", "[", "'missing'", "]", "=", "dl", ".", "ImputeMissingLayer", "(", "last", "(", "self", ".", "layer", ")", ",", "\n", "n_inputs", "=", "(", "self", ".", "n_inputs", ",", ")", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "layer", "[", "'missing'", "]", "=", "dl", ".", "ReplaceMissingLayer", "(", "last", "(", "self", ".", "layer", ")", ",", "\n", "n_inputs", "=", "(", "self", ".", "n_inputs", ",", ")", ")", "\n", "\n", "", "if", "self", ".", "n_bypass", ">", "0", "and", "(", "self", ".", "n_rnn", ">", "0", "or", "n_cnn", ">", "0", ")", ":", "\n", "            ", "last_layer", "=", "last", "(", "self", ".", "layer", ")", "\n", "bypass_slice", "=", "slice", "(", "self", ".", "n_inputs", "-", "self", ".", "n_bypass", ",", "self", ".", "n_inputs", ")", "\n", "direct_slice", "=", "slice", "(", "0", ",", "self", ".", "n_inputs", "-", "self", ".", "n_bypass", ")", "\n", "self", ".", "layer", "[", "'bypass'", "]", "=", "ll", ".", "SliceLayer", "(", "last_layer", ",", "bypass_slice", ")", "\n", "self", ".", "layer", "[", "'direct'", "]", "=", "ll", ".", "SliceLayer", "(", "last_layer", ",", "direct_slice", ")", "\n", "\n", "# reshape inputs prior to RNN or CNN step", "\n", "", "if", "self", ".", "n_rnn", ">", "0", "or", "n_cnn", ">", "0", ":", "\n", "\n", "            ", "if", "len", "(", "n_filters", ")", ">", "0", "and", "len", "(", "self", ".", "input_shape", ")", "==", "2", ":", "# 1 channel", "\n", "                ", "rs", "=", "(", "-", "1", ",", "1", ",", "*", "self", ".", "input_shape", ")", "\n", "", "else", ":", "\n", "                ", "if", "self", ".", "n_rnn", ">", "0", ":", "\n", "                    ", "assert", "len", "(", "self", ".", "input_shape", ")", "==", "2", "# time, dim", "\n", "", "else", ":", "\n", "                    ", "assert", "len", "(", "self", ".", "input_shape", ")", "==", "3", "# channel, row, col", "\n", "", "rs", "=", "(", "-", "1", ",", "*", "self", ".", "input_shape", ")", "\n", "\n", "# last layer is 'missing' or 'direct'", "\n", "", "self", ".", "layer", "[", "'reshape'", "]", "=", "ll", ".", "ReshapeLayer", "(", "last", "(", "self", ".", "layer", ")", ",", "rs", ")", "\n", "\n", "# recurrent neural net, input: (batch, sequence_length, num_inputs)", "\n", "", "if", "self", ".", "n_rnn", ">", "0", ":", "\n", "            ", "self", ".", "layer", "[", "'rnn'", "]", "=", "ll", ".", "GRULayer", "(", "last", "(", "self", ".", "layer", ")", ",", "n_rnn", ",", "\n", "only_return_final", "=", "True", ")", "\n", "\n", "# convolutional net, input: (batch, channels, rows, columns)", "\n", "", "if", "n_cnn", ">", "0", ":", "\n", "            ", "for", "l", "in", "range", "(", "n_cnn", ")", ":", "# add layers", "\n", "                ", "if", "self", ".", "pool_sizes", "[", "l", "]", "==", "1", ":", "\n", "                    ", "padding", "=", "(", "self", ".", "filter_sizes", "[", "l", "]", "-", "1", ")", "//", "2", "\n", "", "else", ":", "\n", "                    ", "padding", "=", "0", "\n", "", "self", ".", "layer", "[", "'conv_'", "+", "str", "(", "l", "+", "1", ")", "]", "=", "ll", ".", "Conv2DLayer", "(", "\n", "name", "=", "'c'", "+", "str", "(", "l", "+", "1", ")", ",", "\n", "incoming", "=", "last", "(", "self", ".", "layer", ")", ",", "\n", "num_filters", "=", "self", ".", "n_filters", "[", "l", "]", ",", "\n", "filter_size", "=", "self", ".", "filter_sizes", "[", "l", "]", ",", "\n", "stride", "=", "(", "1", ",", "1", ")", ",", "\n", "pad", "=", "padding", ",", "\n", "untie_biases", "=", "False", ",", "\n", "W", "=", "lasagne", ".", "init", ".", "GlorotUniform", "(", ")", ",", "\n", "b", "=", "lasagne", ".", "init", ".", "Constant", "(", "0.", ")", ",", "\n", "nonlinearity", "=", "lnl", ".", "rectify", ",", "\n", "flip_filters", "=", "True", ",", "\n", "convolution", "=", "tt", ".", "nnet", ".", "conv2d", ")", "\n", "\n", "if", "self", ".", "pool_sizes", "[", "l", "]", ">", "1", ":", "\n", "                    ", "self", ".", "layer", "[", "'pool_'", "+", "str", "(", "l", "+", "1", ")", "]", "=", "ll", ".", "MaxPool2DLayer", "(", "\n", "name", "=", "'p'", "+", "str", "(", "l", "+", "1", ")", ",", "\n", "incoming", "=", "last", "(", "self", ".", "layer", ")", ",", "\n", "pool_size", "=", "self", ".", "pool_sizes", "[", "l", "]", ",", "\n", "stride", "=", "None", ",", "\n", "ignore_border", "=", "True", ")", "\n", "\n", "# flatten", "\n", "", "", "", "self", ".", "layer", "[", "'flatten'", "]", "=", "ll", ".", "FlattenLayer", "(", "\n", "incoming", "=", "last", "(", "self", ".", "layer", ")", ",", "\n", "outdim", "=", "2", ")", "\n", "\n", "# incorporate bypass inputs", "\n", "if", "self", ".", "n_bypass", ">", "0", "and", "(", "self", ".", "n_rnn", ">", "0", "or", "n_cnn", ">", "0", ")", ":", "\n", "            ", "self", ".", "layer", "[", "'bypass_merge'", "]", "=", "lasagne", ".", "layers", ".", "ConcatLayer", "(", "\n", "[", "self", ".", "layer", "[", "'bypass'", "]", ",", "last", "(", "self", ".", "layer", ")", "]", ",", "axis", "=", "1", ")", "\n", "\n", "", "if", "self", ".", "density", "==", "'mog'", ":", "\n", "            ", "self", ".", "init_mdn", "(", "**", "density_opts", ")", "\n", "", "elif", "self", ".", "density", "==", "'maf'", ":", "\n", "            ", "self", ".", "init_maf", "(", "**", "density_opts", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "self", ".", "compile_funs", "(", ")", "# theano functions", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.init_maf": [[195, 233], ["unused_kwargs.keys", "lasagne.get_output", "lasagne.get_output", "lasagne.get_output", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "numpy.random.RandomState", "snl.ml.models.mafs.ConditionalMaskedAutoregressiveFlow", "print", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.utils.odict.last", "len", "NeuralNet.NeuralNet.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "init_maf", "(", "self", ",", "n_mades", "=", "5", ",", "batch_norm", "=", "False", ",", "maf_actfun", "=", "'tanh'", ",", "\n", "output_order", "=", "'random'", ",", "maf_mode", "=", "'random'", ",", "\n", "**", "unused_kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param n_mades:\n        :param batch_norm:\n        :param output_order:\n        :param maf_mode:\n        :param unused_kwargs:\n        :return:\n        \"\"\"", "\n", "if", "batch_norm", ":", "\n", "            ", "raise", "NotImplementedError", "# why?", "\n", "", "self", ".", "n_mades", ",", "self", ".", "batch_norm", ",", "self", ".", "output_order", ",", "self", ".", "maf_mode", "=", "n_mades", ",", "batch_norm", ",", "output_order", ",", "maf_mode", "\n", "self", ".", "maf_actfun", "=", "maf_actfun", "\n", "for", "key", "in", "unused_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "print", "(", "\"CMAF ignoring unused input {0}\"", ".", "format", "(", "key", ")", ")", "\n", "\n", "# get previous output/params", "\n", "", "self", ".", "maf_input", "=", "ll", ".", "get_output", "(", "last", "(", "self", ".", "layer", ")", ")", "\n", "prev_params", "=", "ll", ".", "get_all_params", "(", "last", "(", "self", ".", "layer", ")", ")", "\n", "input_shape_cmaf", "=", "last", "(", "self", ".", "layer", ")", ".", "output_shape", "\n", "assert", "len", "(", "input_shape_cmaf", ")", "==", "2", "# (batch, input_dim)", "\n", "n_inputs_cmaf", "=", "input_shape_cmaf", "[", "1", "]", "\n", "\n", "rng_maf", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n", "self", ".", "cmaf", "=", "ConditionalMaskedAutoregressiveFlow", "(", "\n", "n_inputs", "=", "n_inputs_cmaf", ",", "n_outputs", "=", "self", ".", "n_outputs", ",", "\n", "n_hiddens", "=", "self", ".", "n_hiddens", ",", "act_fun", "=", "self", ".", "maf_actfun", ",", "\n", "n_mades", "=", "self", ".", "n_mades", ",", "batch_norm", "=", "self", ".", "batch_norm", ",", "\n", "output_order", "=", "self", ".", "output_order", ",", "mode", "=", "self", ".", "maf_mode", ",", "\n", "input", "=", "self", ".", "maf_input", ",", "output", "=", "self", ".", "params", ",", "rng", "=", "rng_maf", ")", "\n", "\n", "self", ".", "aps", "=", "prev_params", "+", "self", ".", "cmaf", ".", "parms", "\n", "self", ".", "lprobs", "=", "self", ".", "cmaf", ".", "L", "# model log-likelihood", "\n", "self", ".", "dlprobs", "=", "self", ".", "lprobs", "# svi not possible", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.init_mdn": [[234, 337], ["unused_kwargs.keys", "range", "delfi.utils.odict.last", "delfi.utils.odict.last", "delfi.MixtureWeightsLayer", "delfi.MixtureWeightsLayer", "delfi.MixtureMeansLayer", "delfi.MixtureMeansLayer", "PrecisionsLayer", "lasagne.get_output", "lasagne.get_output", "lasagne.get_output", "lasagne.get_output", "lasagne.get_output", "lasagne.get_output", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "lasagne.get_all_params", "print", "len", "delfi.FullyConnectedLayer", "delfi.FullyConnectedLayer", "delfi.utils.odict.last", "delfi.utils.odict.last", "zip", "zip", "str", "range", "str", "range", "theano.sum", "theano.sum", "delfi.utils.symbolic.MyLogSumExp", "delfi.utils.symbolic.MyLogSumExp", "str", "range", "str", "range", "theano.sum", "theano.sum", "delfi.utils.symbolic.MyLogSumExp", "delfi.utils.symbolic.MyLogSumExp", "str", "str", "numpy.log", "numpy.log", "theano.sum", "theano.sum", "theano.stack", "theano.stack", "theano.log", "theano.log", "theano.sum", "theano.sum", "theano.stack", "theano.stack", "theano.log", "theano.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.odict.last", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "init_mdn", "(", "self", ",", "svi", "=", "False", ",", "n_components", "=", "1", ",", "rank", "=", "None", ",", "\n", "mdn_actfun", "=", "lnl", ".", "tanh", ",", "homoscedastic", "=", "False", ",", "min_precisions", "=", "None", ",", "\n", "**", "unused_kwargs", ")", ":", "\n", "        ", "\"\"\"\n        :param svi: bool\n            Whether to use SVI version or not\n        :param n_components: int\n        :param rank: int\n        :param homoscedastic: bool\n        :param unused_kwargs: dict\n        :param mdn_actfun: lasagne nonlinearity\n            activation function for hidden units\n        :param min_precisions: minimum values for diagonal elements of precision\n            matrix for all components (usually taken to be prior precisions)\n        :return: None\n        \"\"\"", "\n", "self", ".", "svi", ",", "self", ".", "n_components", ",", "self", ".", "rank", ",", "self", ".", "mdn_actfun", ",", "self", ".", "homoscedastic", ",", "self", ".", "min_precisions", "=", "svi", ",", "n_components", ",", "rank", ",", "mdn_actfun", ",", "homoscedastic", ",", "min_precisions", "\n", "for", "key", "in", "unused_kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "print", "(", "\"MDN ignoring unused input {0}\"", ".", "format", "(", "key", ")", ")", "\n", "\n", "# hidden layers", "\n", "", "for", "l", "in", "range", "(", "len", "(", "self", ".", "n_hiddens", ")", ")", ":", "\n", "            ", "self", ".", "layer", "[", "'hidden_'", "+", "str", "(", "l", "+", "1", ")", "]", "=", "dl", ".", "FullyConnectedLayer", "(", "\n", "last", "(", "self", ".", "layer", ")", ",", "n_units", "=", "self", ".", "n_hiddens", "[", "l", "]", ",", "\n", "actfun", "=", "self", ".", "mdn_actfun", ",", "\n", "svi", "=", "self", ".", "svi", ",", "name", "=", "'h'", "+", "str", "(", "l", "+", "1", ")", ")", "\n", "\n", "", "last_hidden", "=", "last", "(", "self", ".", "layer", ")", "\n", "# mixture layers", "\n", "self", ".", "layer", "[", "'mixture_weights'", "]", "=", "dl", ".", "MixtureWeightsLayer", "(", "last_hidden", ",", "\n", "n_units", "=", "self", ".", "n_components", ",", "actfun", "=", "lnl", ".", "softmax", ",", "svi", "=", "self", ".", "svi", ",", "\n", "name", "=", "'weights'", ")", "\n", "self", ".", "layer", "[", "'mixture_means'", "]", "=", "dl", ".", "MixtureMeansLayer", "(", "last_hidden", ",", "\n", "n_components", "=", "self", ".", "n_components", ",", "n_dim", "=", "self", ".", "n_outputs", ",", "svi", "=", "self", ".", "svi", ",", "\n", "name", "=", "'means'", ")", "\n", "if", "self", ".", "homoscedastic", ":", "\n", "            ", "PrecisionsLayer", "=", "dl", ".", "MixtureHomoscedasticPrecisionsLayer", "\n", "", "else", ":", "\n", "            ", "PrecisionsLayer", "=", "dl", ".", "MixturePrecisionsLayer", "\n", "# why is homoscedastic an input to the layer init?", "\n", "", "self", ".", "layer", "[", "'mixture_precisions'", "]", "=", "PrecisionsLayer", "(", "last_hidden", ",", "\n", "n_components", "=", "self", ".", "n_components", ",", "n_dim", "=", "self", ".", "n_outputs", ",", "svi", "=", "self", ".", "svi", ",", "\n", "name", "=", "'precisions'", ",", "rank", "=", "self", ".", "rank", ",", "homoscedastic", "=", "self", ".", "homoscedastic", ",", "\n", "min_precisions", "=", "min_precisions", ")", "\n", "\n", "last_mog", "=", "[", "self", ".", "layer", "[", "'mixture_weights'", "]", ",", "\n", "self", ".", "layer", "[", "'mixture_means'", "]", ",", "\n", "self", ".", "layer", "[", "'mixture_precisions'", "]", "]", "\n", "\n", "# mixture parameters", "\n", "# a : weights, matrix with shape (batch, n_components)", "\n", "# ms : means, list of len n_components with (batch, n_dim, n_dim)", "\n", "# Us : precision factors, n_components list with (batch, n_dim, n_dim)", "\n", "# ldetUs : log determinants of precisions, n_comp list with (batch, )", "\n", "self", ".", "a", ",", "self", ".", "ms", ",", "precision_out", "=", "ll", ".", "get_output", "(", "last_mog", ",", "\n", "deterministic", "=", "False", ")", "\n", "self", ".", "Us", "=", "precision_out", "[", "'Us'", "]", "\n", "self", ".", "ldetUs", "=", "precision_out", "[", "'ldetUs'", "]", "\n", "self", ".", "comps", "=", "{", "\n", "**", "{", "'a'", ":", "self", ".", "a", "}", ",", "\n", "**", "{", "'m'", "+", "str", "(", "i", ")", ":", "self", ".", "ms", "[", "i", "]", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "}", ",", "\n", "**", "{", "'U'", "+", "str", "(", "i", ")", ":", "self", ".", "Us", "[", "i", "]", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "}", "}", "\n", "\n", "# log probability of y given the mixture distribution", "\n", "# lprobs_comps : log probs per component, list of len n_components with (batch, )", "\n", "# probs : log probs of mixture, (batch, )", "\n", "\n", "self", ".", "lprobs_comps", "=", "[", "-", "0.5", "*", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "(", "self", ".", "params", "-", "m", ")", ".", "dimshuffle", "(", "\n", "[", "0", ",", "'x'", ",", "1", "]", ")", "*", "U", ",", "axis", "=", "2", ")", "**", "2", ",", "axis", "=", "1", ")", "+", "ldetU", "\n", "for", "m", ",", "U", ",", "ldetU", "in", "zip", "(", "self", ".", "ms", ",", "self", ".", "Us", ",", "self", ".", "ldetUs", ")", "]", "\n", "self", ".", "lprobs", "=", "(", "MyLogSumExp", "(", "tt", ".", "stack", "(", "self", ".", "lprobs_comps", ",", "axis", "=", "1", ")", "+", "tt", ".", "log", "(", "self", ".", "a", ")", ",", "axis", "=", "1", ")", "\n", "-", "(", "0.5", "*", "self", ".", "n_outputs", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", ")", ")", ".", "squeeze", "(", ")", "\n", "\n", "# the quantities from above again, but with deterministic=True", "\n", "# --- in the svi case, this will disable injection of randomness;", "\n", "# the mean of weights is used instead", "\n", "self", ".", "da", ",", "self", ".", "dms", ",", "dprecision_out", "=", "ll", ".", "get_output", "(", "last_mog", ",", "\n", "deterministic", "=", "True", ")", "\n", "self", ".", "dUs", "=", "dprecision_out", "[", "'Us'", "]", "\n", "self", ".", "dldetUs", "=", "dprecision_out", "[", "'ldetUs'", "]", "\n", "self", ".", "dcomps", "=", "{", "\n", "**", "{", "'a'", ":", "self", ".", "da", "}", ",", "\n", "**", "{", "'m'", "+", "str", "(", "i", ")", ":", "self", ".", "dms", "[", "i", "]", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "}", ",", "\n", "**", "{", "'U'", "+", "str", "(", "i", ")", ":", "self", ".", "dUs", "[", "i", "]", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "}", "}", "\n", "\n", "self", ".", "dlprobs_comps", "=", "[", "-", "0.5", "*", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "(", "self", ".", "params", "-", "m", ")", ".", "dimshuffle", "(", "\n", "[", "0", ",", "'x'", ",", "1", "]", ")", "*", "U", ",", "axis", "=", "2", ")", "**", "2", ",", "axis", "=", "1", ")", "+", "ldetU", "\n", "for", "m", ",", "U", ",", "ldetU", "in", "zip", "(", "self", ".", "dms", ",", "self", ".", "dUs", ",", "self", ".", "dldetUs", ")", "]", "\n", "self", ".", "dlprobs", "=", "(", "MyLogSumExp", "(", "tt", ".", "stack", "(", "self", ".", "dlprobs_comps", ",", "axis", "=", "1", ")", "+", "tt", ".", "log", "(", "self", ".", "da", ")", ",", "axis", "=", "1", ")", "-", "(", "0.5", "*", "self", ".", "n_outputs", "*", "np", ".", "log", "(", "2", "*", "np", ".", "pi", ")", ")", ")", ".", "squeeze", "(", ")", "\n", "\n", "# parameters of network", "\n", "self", ".", "aps", "=", "ll", ".", "get_all_params", "(", "last_mog", ")", "# all parameters", "\n", "self", ".", "mps", "=", "ll", ".", "get_all_params", "(", "last_mog", ",", "mp", "=", "True", ")", "# means", "\n", "self", ".", "sps", "=", "ll", ".", "get_all_params", "(", "last_mog", ",", "sp", "=", "True", ")", "# log stds", "\n", "\n", "# weight and bias parameter sets as separate lists", "\n", "self", ".", "mps_wp", "=", "ll", ".", "get_all_params", "(", "last_mog", ",", "mp", "=", "True", ",", "wp", "=", "True", ")", "\n", "self", ".", "sps_wp", "=", "ll", ".", "get_all_params", "(", "last_mog", ",", "sp", "=", "True", ",", "wp", "=", "True", ")", "\n", "self", ".", "mps_bp", "=", "ll", ".", "get_all_params", "(", "last_mog", ",", "mp", "=", "True", ",", "bp", "=", "True", ")", "\n", "self", ".", "sps_bp", "=", "ll", ".", "get_all_params", "(", "last_mog", ",", "sp", "=", "True", ",", "bp", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.compile_funs": [[338, 357], ["theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function", "theano.function"], "methods", ["None"], ["", "def", "compile_funs", "(", "self", ")", ":", "\n", "        ", "\"\"\"Compiles theano functions\"\"\"", "\n", "self", ".", "_f_eval_lprobs", "=", "theano", ".", "function", "(", "\n", "inputs", "=", "[", "self", ".", "params", ",", "self", ".", "stats", "]", ",", "\n", "outputs", "=", "self", ".", "lprobs", ")", "\n", "self", ".", "_f_eval_dlprobs", "=", "theano", ".", "function", "(", "\n", "inputs", "=", "[", "self", ".", "params", ",", "self", ".", "stats", "]", ",", "\n", "outputs", "=", "self", ".", "dlprobs", ")", "\n", "if", "self", ".", "density", "==", "'mog'", ":", "\n", "            ", "self", ".", "_f_eval_comps", "=", "theano", ".", "function", "(", "\n", "inputs", "=", "[", "self", ".", "stats", "]", ",", "\n", "outputs", "=", "self", ".", "comps", ")", "\n", "self", ".", "_f_eval_dcomps", "=", "theano", ".", "function", "(", "\n", "inputs", "=", "[", "self", ".", "stats", "]", ",", "\n", "outputs", "=", "self", ".", "dcomps", ")", "\n", "", "elif", "self", ".", "density", "==", "'maf'", ":", "\n", "            ", "self", ".", "_f_eval_maf_input", "=", "theano", ".", "function", "(", "\n", "inputs", "=", "[", "self", ".", "stats", "]", ",", "\n", "outputs", "=", "self", ".", "maf_input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.eval_comps": [[358, 377], ["NeuralNet.NeuralNet._f_eval_dcomps", "NeuralNet.NeuralNet._f_eval_comps", "stats.astype", "stats.astype"], "methods", ["None"], ["", "", "def", "eval_comps", "(", "self", ",", "stats", ",", "deterministic", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluate the parameters of all mixture components at given inputs\n\n        Parameters\n        ----------\n        stats : np.array\n            rows are input locations\n        deterministic : bool\n            if True, mean weights are used for Bayesian network\n\n        Returns\n        -------\n        mixing coefficients, means and scale matrices\n        \"\"\"", "\n", "assert", "self", ".", "density", "==", "'mog'", "\n", "if", "deterministic", ":", "\n", "            ", "return", "self", ".", "_f_eval_dcomps", "(", "stats", ".", "astype", "(", "dtype", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_f_eval_comps", "(", "stats", ".", "astype", "(", "dtype", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.eval_lprobs": [[378, 396], ["NeuralNet.NeuralNet._f_eval_dlprobs", "NeuralNet.NeuralNet._f_eval_lprobs", "params.astype", "stats.astype", "params.astype", "stats.astype"], "methods", ["None"], ["", "", "def", "eval_lprobs", "(", "self", ",", "params", ",", "stats", ",", "deterministic", "=", "True", ")", ":", "\n", "        ", "\"\"\"Evaluate log probabilities for given input-output pairs.\n\n        Parameters\n        ----------\n        params : np.array\n        stats : np.array\n        deterministic : bool\n            if True, mean weights are used for Bayesian network\n\n        Returns\n        -------\n        log probabilities : log p(params|stats)\n        \"\"\"", "\n", "if", "deterministic", ":", "\n", "            ", "return", "self", ".", "_f_eval_dlprobs", "(", "params", ".", "astype", "(", "dtype", ")", ",", "stats", ".", "astype", "(", "dtype", ")", ")", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "_f_eval_lprobs", "(", "params", ".", "astype", "(", "dtype", ")", ",", "stats", ".", "astype", "(", "dtype", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_density": [[397, 413], ["stats.reshape().astype.reshape().astype.reshape().astype", "NeuralNet.NeuralNet.get_mog", "stats.reshape().astype.reshape().astype.reshape", "NeuralNet.NeuralNet._f_eval_maf_input", "NeuralNet.MAFconditional", "NeuralNet.NeuralNet.reshape", "numpy.random.RandomState", "NeuralNet.NeuralNet.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "", "def", "get_density", "(", "self", ",", "stats", ",", "deterministic", "=", "True", ")", ":", "\n", "        ", "assert", "stats", ".", "size", "==", "self", ".", "n_inputs", "\n", "stats", "=", "stats", ".", "reshape", "(", "1", ",", "-", "1", ")", ".", "astype", "(", "dtype", ")", "\n", "if", "self", ".", "density", "==", "'mog'", ":", "\n", "            ", "return", "self", ".", "get_mog", "(", "stats", ",", "deterministic", "=", "deterministic", ")", "\n", "\n", "", "elif", "self", ".", "density", "==", "'maf'", ":", "\n", "            ", "assert", "deterministic", "\n", "cmaf_input", "=", "self", ".", "_f_eval_maf_input", "(", "stats", ")", "\n", "return", "MAFconditional", "(", "\n", "model", "=", "self", ".", "cmaf", ",", "cmaf_inputs", "=", "cmaf_input", ".", "reshape", "(", "-", "1", ")", ",", "\n", "makecopy", "=", "True", ",", "\n", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog": [[414, 433], ["NeuralNet.NeuralNet.eval_comps", "delfi.MoG", "delfi.MoG", "range", "range", "NeuralNet.NeuralNet.gen_newseed", "str", "str"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.eval_comps", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "", "def", "get_mog", "(", "self", ",", "stats", ",", "deterministic", "=", "True", ")", ":", "\n", "        ", "\"\"\"Return the conditional MoG at location x\n\n        Parameters\n        ----------\n        stats : np.array\n            single input location\n        deterministic : bool\n            if True, mean weights are used for Bayesian network\n        \"\"\"", "\n", "assert", "self", ".", "density", "==", "'mog'", "\n", "assert", "stats", ".", "shape", "[", "0", "]", "==", "1", ",", "'x.shape[0] needs to be 1'", "\n", "\n", "comps", "=", "self", ".", "eval_comps", "(", "stats", ",", "deterministic", ")", "\n", "a", "=", "comps", "[", "'a'", "]", "[", "0", "]", "\n", "ms", "=", "[", "comps", "[", "'m'", "+", "str", "(", "i", ")", "]", "[", "0", "]", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "]", "\n", "Us", "=", "[", "comps", "[", "'U'", "+", "str", "(", "i", ")", "]", "[", "0", "]", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "]", "\n", "\n", "return", "dd", ".", "MoG", "(", "a", "=", "a", ",", "ms", "=", "ms", ",", "Us", "=", "Us", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog_tensors": [[434, 453], ["theano.batched_dot", "theano.batched_dot", "theano.sum", "theano.sum", "theano.sum", "theano.sum", "U.dimshuffle", "zip", "zip", "m.dimshuffle"], "methods", ["None"], ["", "def", "get_mog_tensors", "(", "self", ",", "svi", "=", "True", ",", "return_extras", "=", "False", ")", ":", "\n", "        ", "assert", "self", ".", "density", "==", "'mog'", "\n", "if", "svi", ":", "\n", "            ", "a", ",", "ms", ",", "Us", ",", "ldetUs", "=", "self", ".", "a", ",", "self", ".", "ms", ",", "self", ".", "Us", ",", "self", ".", "ldetUs", "\n", "", "else", ":", "\n", "            ", "a", ",", "ms", ",", "Us", ",", "ldetUs", "=", "self", ".", "da", ",", "self", ".", "dms", ",", "self", ".", "dUs", ",", "self", ".", "dldetUs", "\n", "", "if", "not", "return_extras", ":", "\n", "            ", "return", "a", ",", "ms", ",", "Us", ",", "ldetUs", "\n", "\n", "# precisions of posterior components:", "\n", "", "Ps", "=", "[", "tt", ".", "batched_dot", "(", "U", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ")", ",", "U", ")", "for", "U", "in", "Us", "]", "\n", "# log determinants of posterior component precisions", "\n", "ldetPs", "=", "[", "2", "*", "ldetU", "for", "ldetU", "in", "ldetUs", "]", "\n", "# precision times mean for each posterior component:", "\n", "Pms", "=", "[", "tt", ".", "sum", "(", "P", "*", "m", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", ",", "axis", "=", "2", ")", "\n", "for", "m", ",", "P", "in", "zip", "(", "ms", ",", "Ps", ")", "]", "\n", "# calculate tensorQF(P, m):", "\n", "QFs", "=", "[", "tt", ".", "sum", "(", "m", "*", "Pm", ",", "axis", "=", "1", ")", "for", "m", ",", "Pm", "in", "zip", "(", "ms", ",", "Pms", ")", "]", "\n", "return", "a", ",", "ms", ",", "Us", ",", "ldetUs", ",", "Ps", ",", "ldetPs", ",", "Pms", ",", "QFs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.reseed": [[454, 458], ["NeuralNet.NeuralNet.rng.seed"], "methods", ["None"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Reseeds the network's RNG\"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.gen_newseed": [[459, 465], ["NeuralNet.NeuralNet.rng.randint"], "methods", ["None"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.params_dict": [[474, 480], ["str", "pdict.keys", "p.set_value", "str"], "methods", ["None"], ["", "@", "params_dict", ".", "setter", "\n", "def", "params_dict", "(", "self", ",", "pdict", ")", ":", "\n", "        ", "\"\"\"Setter for params as dict\"\"\"", "\n", "for", "p", "in", "self", ".", "aps", ":", "\n", "            ", "if", "str", "(", "p", ")", "in", "pdict", ".", "keys", "(", ")", ":", "\n", "                ", "p", ".", "set_value", "(", "pdict", "[", "str", "(", "p", ")", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.spec_dict": [[481, 500], ["dict", "dict.update", "dict", "dict.update", "dict"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update"], ["", "", "", "@", "property", "\n", "def", "spec_dict", "(", "self", ")", ":", "\n", "        ", "\"\"\"Specs as dict\"\"\"", "\n", "spec", "=", "dict", "(", "n_inputs", "=", "self", ".", "n_inputs", ",", "n_outputs", "=", "self", ".", "n_outputs", ",", "\n", "n_filters", "=", "self", ".", "n_filters", ",", "n_hiddens", "=", "self", ".", "n_hiddens", ",", "\n", "n_rnn", "=", "self", ".", "n_rnn", ",", "n_bypass", "=", "self", ".", "n_bypass", ",", "\n", "input_shape", "=", "self", ".", "input_shape", ",", "filter_sizes", "=", "self", ".", "filter_sizes", ",", "\n", "pool_sizes", "=", "self", ".", "pool_sizes", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n", "if", "self", ".", "density", "==", "'mog'", ":", "\n", "            ", "spec", ".", "update", "(", "dict", "(", "svi", "=", "self", ".", "svi", ",", "n_components", "=", "self", ".", "n_components", ",", "\n", "rank", "=", "self", ".", "rank", ",", "homoscedastic", "=", "self", ".", "homoscedastic", ")", ")", "\n", "", "elif", "self", ".", "density", "==", "'maf'", ":", "\n", "            ", "spec", ".", "update", "(", "dict", "(", "n_mades", "=", "5", ",", "batch_norm", "=", "False", ",", "\n", "output_order", "=", "'sequential'", ",", "maf_mode", "=", "'random'", ")", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "return", "spec", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_loss": [[501, 503], ["theano.mean", "theano.mean"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "get_loss", "(", "self", ")", ":", "\n", "        ", "return", "-", "tt", ".", "mean", "(", "self", ".", "iws", "*", "self", ".", "lprobs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.MAFconditional.__init__": [[511, 521], ["isinstance", "numpy.ones", "numpy.zeros", "copy.deepcopy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "model", ",", "cmaf_inputs", ",", "makecopy", "=", "False", ",", "rng", "=", "np", ".", "random", ")", ":", "\n", "        ", "assert", "isinstance", "(", "model", ",", "ConditionalMaskedAutoregressiveFlow", ")", "\n", "self", ".", "model", "=", "deepcopy", "(", "model", ")", "if", "makecopy", "else", "model", "\n", "assert", "cmaf_inputs", ".", "ndim", "==", "1", "\n", "self", ".", "cmaf_inputs", "=", "cmaf_inputs", "\n", "self", ".", "rng", "=", "rng", "\n", "# store a scale and offset so we can transform/normalize", "\n", "self", ".", "scale", "=", "np", ".", "ones", "(", "self", ".", "model", ".", "n_outputs", ")", "\n", "self", ".", "offset", "=", "np", ".", "zeros", "(", "self", ".", "model", ".", "n_outputs", ")", "\n", "self", ".", "ndim", "=", "self", ".", "model", ".", "n_outputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.MAFconditional.set_scale_and_offset": [[522, 533], ["numpy.isfinite().all", "numpy.isfinite().all", "numpy.any", "numpy.isfinite", "numpy.isfinite"], "methods", ["None"], ["", "def", "set_scale_and_offset", "(", "self", ",", "scale", "=", "None", ",", "offset", "=", "None", ")", ":", "\n", "        ", "if", "scale", "is", "not", "None", ":", "\n", "            ", "assert", "scale", ".", "ndim", "==", "1", "and", "scale", ".", "size", "==", "self", ".", "model", ".", "n_outputs", "and", "np", ".", "isfinite", "(", "scale", ")", ".", "all", "(", ")", "and", "not", "np", ".", "any", "(", "scale", "==", "0", ")", "\n", "", "if", "offset", "is", "not", "None", ":", "\n", "            ", "assert", "offset", ".", "ndim", "==", "1", "and", "offset", ".", "size", "==", "self", ".", "model", ".", "n_outputs", "and", "np", ".", "isfinite", "(", "offset", ")", ".", "all", "(", ")", "\n", "", "if", "scale", "is", "not", "None", ":", "\n", "            ", "self", ".", "scale", "=", "scale", "\n", "", "if", "offset", "is", "not", "None", ":", "\n", "            ", "self", ".", "offset", "=", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.MAFconditional.get_scale_and_offset": [[534, 536], ["None"], "methods", ["None"], ["", "", "def", "get_scale_and_offset", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "scale", ",", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.MAFconditional.gen": [[537, 558], ["NeuralNet.MAFconditional.model.gen"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "gen", "(", "self", ",", "n_samples", ",", "cmaf_inputs", "=", "None", ")", ":", "\n", "        ", "\"\"\"Method to generate samples\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate\n        cmaf_inputs : array\n            Vector of inputs into cmaf (for conditional density param|stats )\n\n        Returns\n        -------\n        n_samples x self.ndim\n        \"\"\"", "\n", "if", "cmaf_inputs", "is", "not", "None", ":", "\n", "            ", "assert", "cmaf_inputs", ".", "ndim", "==", "1", "\n", "", "theta", "=", "self", ".", "model", ".", "gen", "(", "\n", "x", "=", "self", ".", "cmaf_inputs", "if", "cmaf_inputs", "is", "None", "else", "cmaf_inputs", ",", "\n", "n_samples", "=", "n_samples", ",", "\n", "rng", "=", "self", ".", "rng", ")", "\n", "return", "theta", "*", "self", ".", "scale", "+", "self", ".", "offset", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.MAFconditional.eval": [[559, 578], ["NeuralNet.MAFconditional.model.eval", "numpy.sum", "numpy.exp", "numpy.log", "numpy.abs"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "eval", "(", "self", ",", "theta", ",", "log", "=", "True", ")", ":", "\n", "        ", "\"\"\"Method to evaluate pdf\n\n        Parameters\n        ----------\n        theta : int or list or np.array\n            Rows are inputs to evaluate at\n        log : bool, defaulting to True\n            If True, the log pdf is evaluated\n\n        Returns\n        -------\n        scalar\n        \"\"\"", "\n", "assert", "theta", ".", "ndim", "<", "3", "\n", "theta_norm", "=", "(", "theta", "-", "self", ".", "offset", ")", "/", "self", ".", "scale", "\n", "logp", "=", "self", ".", "model", ".", "eval", "(", "xy", "=", "(", "self", ".", "cmaf_inputs", ",", "theta_norm", ")", ",", "log", "=", "True", ")", "-", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "abs", "(", "self", ".", "scale", ")", ")", ")", "\n", "return", "logp", "if", "log", "else", "np", ".", "exp", "(", "logp", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixturePrecisions.MixturePrecisionsLayer.__init__": [[13, 91], ["lasagne.HeNormal", "lasagne.HeNormal", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "super().__init__", "MixturePrecisions.MixturePrecisionsLayer.add_param", "MixturePrecisions.MixturePrecisionsLayer.add_param", "theano.sandbox.rng_mrg.MRG_RandomStreams", "theano.sandbox.rng_mrg.MRG_RandomStreams", "min_precisions.astype.astype.astype", "numpy.sqrt", "range", "range", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "MixturePrecisions.MixturePrecisionsLayer.add_param", "MixturePrecisions.MixturePrecisionsLayer.add_param", "range", "range", "str", "str", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "str", "str"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "incoming", ",", "\n", "n_components", ",", "\n", "n_dim", ",", "\n", "svi", "=", "True", ",", "\n", "rank", "=", "None", ",", "\n", "homoscedastic", "=", "False", ",", "\n", "mWs_init", "=", "linit", ".", "HeNormal", "(", ")", ",", "\n", "mbs_init", "=", "linit", ".", "Constant", "(", "[", "0.", "]", ")", ",", "\n", "sWs_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "sbs_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "min_precisions", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Fully connected layer for mixture precisions, optional weight uncertainty\n\n        Parameters\n        ----------\n        incoming : lasagne.layers.Layer instance\n            Incoming layer\n        n_components : int\n            Number of components\n        n_dim : int\n            Dimensionality of output vector\n        svi : bool\n            Weight uncertainty\n        mWs_init : function\n            Function to initialise weights for mean of weight (multiplicative);\n            applied per component\n        mbs_init : function\n            Function to initialise weights for mean of weight (bias);\n            applied per component\n        sWs_init : function\n            Function to initialise weights for log std of weight (multiplicative);\n            applied per component\n        sbs_init : function\n            Function to initialise weights for log std of weight (bias);\n            applied per component\n        min_precisions: 1D numpy array of float32 or None\n            Minimum values for the diagonal elements of the precision matrix,\n            for all components\n        \"\"\"", "\n", "super", "(", "MixturePrecisionsLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "self", ".", "n_components", "=", "n_components", "\n", "self", ".", "rank", "=", "rank", "\n", "assert", "not", "homoscedastic", "\n", "self", ".", "homoscedastic", "=", "homoscedastic", "\n", "self", ".", "n_dim", "=", "n_dim", "\n", "self", ".", "svi", "=", "svi", "\n", "\n", "self", ".", "mWs", "=", "[", "self", ".", "add_param", "(", "mWs_init", ",", "\n", "(", "self", ".", "input_shape", "[", "1", "]", ",", "self", ".", "n_dim", "**", "2", ")", ",", "\n", "name", "=", "'mW'", "+", "str", "(", "c", ")", ",", "mp", "=", "True", ",", "wp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "self", ".", "mbs", "=", "[", "self", ".", "add_param", "(", "mbs_init", ",", "\n", "(", "self", ".", "n_dim", "**", "2", ",", ")", ",", "\n", "name", "=", "'mb'", "+", "str", "(", "c", ")", ",", "mp", "=", "True", ",", "bp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "self", ".", "_srng", "=", "RandomStreams", "(", "\n", "lasagne", ".", "random", ".", "get_rng", "(", ")", ".", "randint", "(", "\n", "1", ",", "2147462579", ")", ")", "\n", "self", ".", "sWs", "=", "[", "self", ".", "add_param", "(", "sWs_init", ",", "\n", "(", "self", ".", "input_shape", "[", "1", "]", ",", "self", ".", "n_dim", "**", "2", ")", ",", "\n", "name", "=", "'sW'", "+", "str", "(", "c", ")", ",", "sp", "=", "True", ",", "wp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "self", ".", "sbs", "=", "[", "self", ".", "add_param", "(", "sbs_init", ",", "\n", "(", "self", ".", "n_dim", "**", "2", ",", ")", ",", "\n", "name", "=", "'sb'", "+", "str", "(", "c", ")", ",", "sp", "=", "True", ",", "bp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "\n", "", "if", "min_precisions", "is", "not", "None", ":", "\n", "            ", "assert", "min_precisions", ".", "ndim", "==", "1", "and", "min_precisions", ".", "size", "==", "self", ".", "n_dim", ",", "\"invalid min precisions\"", "\n", "min_precisions", "=", "min_precisions", ".", "astype", "(", "dtype", ")", "\n", "self", ".", "min_U_column_norms", "=", "np", ".", "sqrt", "(", "min_precisions", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "min_U_column_norms", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixturePrecisions.MixturePrecisionsLayer.get_output_for": [[92, 135], ["numpy.triu", "numpy.eye", "numpy.ones", "theano.sum", "theano.sum", "theano.reshape", "theano.reshape", "MixturePrecisions.MixturePrecisionsLayer._srng.normal", "theano.reshape", "theano.reshape", "theano.sum", "theano.sum", "theano.sqrt().reshape", "theano.sqrt().reshape", "theano.maximum", "theano.maximum", "zip", "range", "theano.dot", "theano.dot", "zip", "theano.dot", "theano.dot", "theano.exp", "theano.exp", "zip", "zip", "theano.exp", "theano.exp", "sf.dimshuffle", "zip", "theano.dot", "theano.dot", "theano.exp", "theano.exp", "theano.sqrt", "theano.sqrt", "theano.sqrt", "theano.sqrt", "theano.sum", "theano.sum"], "methods", ["None"], ["", "", "def", "get_output_for", "(", "self", ",", "input", ",", "deterministic", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Compute outputs\n\n        Returns\n        -------\n        list by concatenation of\n            Us : list of length n_components with (batch, n_dim, n_dim)\n                Precision factors\n            ldetUs : list of length n_components with (batch, n_dim, n_dim)\n                Log determinants of precisions\n        \"\"\"", "\n", "triu_mask", "=", "np", ".", "triu", "(", "np", ".", "ones", "(", "[", "self", ".", "n_dim", ",", "self", ".", "n_dim", "]", ",", "dtype", "=", "dtype", ")", ",", "1", ")", "\n", "if", "not", "self", ".", "rank", "is", "None", ":", "\n", "            ", "triu_mask", "[", "self", ".", "rank", ":", "]", "*=", "0.", "\n", "", "diag_mask", "=", "np", ".", "eye", "(", "self", ".", "n_dim", ",", "dtype", "=", "dtype", ")", "\n", "\n", "if", "not", "self", ".", "svi", "or", "deterministic", ":", "\n", "            ", "zas_reshaped", "=", "[", "tt", ".", "reshape", "(", "tt", ".", "dot", "(", "input", ",", "mW", ")", "+", "mb", ",", "\n", "[", "-", "1", ",", "self", ".", "n_dim", ",", "self", ".", "n_dim", "]", ")", "for", "mW", ",", "mb", "in", "zip", "(", "self", ".", "mWs", ",", "self", ".", "mbs", ")", "]", "\n", "", "else", ":", "\n", "            ", "uas", "=", "[", "\n", "self", ".", "_srng", ".", "normal", "(", "\n", "(", "input", ".", "shape", "[", "0", "]", ",", "\n", "self", ".", "n_dim", "**", "2", ")", ",", "\n", "dtype", "=", "dtype", ")", "for", "i", "in", "range", "(", "\n", "self", ".", "n_components", ")", "]", "\n", "mas", "=", "[", "tt", ".", "dot", "(", "input", ",", "mW", ")", "+", "mb", "for", "mW", ",", "mb", "in", "zip", "(", "self", ".", "mWs", ",", "self", ".", "mbs", ")", "]", "\n", "sas", "=", "[", "tt", ".", "dot", "(", "input", "**", "2", ",", "tt", ".", "exp", "(", "2", "*", "sW", ")", ")", "+", "tt", ".", "exp", "(", "2", "*", "sb", ")", "\n", "for", "sW", ",", "sb", "in", "zip", "(", "self", ".", "sWs", ",", "self", ".", "sbs", ")", "]", "\n", "zas", "=", "[", "tt", ".", "sqrt", "(", "sa", ")", "*", "ua", "+", "ma", "for", "sa", ",", "ua", ",", "ma", "in", "zip", "(", "sas", ",", "uas", ",", "mas", ")", "]", "\n", "zas_reshaped", "=", "[", "tt", ".", "reshape", "(", "\n", "za", ",", "[", "-", "1", ",", "self", ".", "n_dim", ",", "self", ".", "n_dim", "]", ")", "for", "za", "in", "zas", "]", "\n", "\n", "", "Us", "=", "[", "triu_mask", "*", "za", "+", "diag_mask", "*", "tt", ".", "exp", "(", "diag_mask", "*", "za", ")", "for", "za", "in", "zas_reshaped", "]", "\n", "ldetUs", "=", "[", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "diag_mask", "*", "za", ",", "axis", "=", "2", ")", ",", "axis", "=", "1", ")", "for", "za", "in", "zas_reshaped", "]", "\n", "\n", "# enforce lower bound on diagonal elements of the precision matrices", "\n", "if", "self", ".", "min_U_column_norms", "is", "not", "None", ":", "\n", "            ", "U_column_norms", "=", "[", "tt", ".", "sqrt", "(", "tt", ".", "sum", "(", "U", "**", "2", ",", "axis", "=", "1", ")", ")", ".", "reshape", "(", "(", "-", "1", ",", "self", ".", "n_dim", ")", ")", "for", "U", "in", "Us", "]", "\n", "scale_factors", "=", "[", "tt", ".", "maximum", "(", "1.0", ",", "self", ".", "min_U_column_norms", "/", "Ucn", ")", "for", "Ucn", "in", "U_column_norms", "]", "\n", "Us", "=", "[", "U", "*", "sf", ".", "dimshuffle", "(", "[", "0", ",", "'x'", ",", "1", "]", ")", "for", "U", ",", "sf", "in", "zip", "(", "Us", ",", "scale_factors", ")", "]", "\n", "\n", "", "return", "{", "'Us'", ":", "Us", ",", "'ldetUs'", ":", "ldetUs", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixturePrecisions.MixturePrecisionsLayer.get_output_shape_for": [[136, 138], ["None"], "methods", ["None"], ["", "def", "get_output_shape_for", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixturePrecisions.MixtureHomoscedasticPrecisionsLayer.__init__": [[141, 205], ["lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "super().__init__", "MixturePrecisions.MixtureHomoscedasticPrecisionsLayer.add_param", "theano.sandbox.rng_mrg.MRG_RandomStreams", "theano.sandbox.rng_mrg.MRG_RandomStreams", "range", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "MixturePrecisions.MixtureHomoscedasticPrecisionsLayer.add_param", "range", "str", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "str"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "incoming", ",", "\n", "n_components", ",", "\n", "n_dim", ",", "\n", "svi", "=", "True", ",", "\n", "rank", "=", "None", ",", "\n", "homoscedastic", "=", "True", ",", "\n", "mbs_init", "=", "linit", ".", "Constant", "(", "[", "0.", "]", ")", ",", "\n", "sbs_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Fully connected layer for mixture precisions, optional weight uncertainty\n\n        Parameters\n        ----------\n        incoming : lasagne.layers.Layer instance\n            Incoming layer\n        n_components : int\n            Number of components\n        n_dim : int\n            Dimensionality of output vector\n        svi : bool\n            Weight uncertainty\n        mWs_init : function\n            Function to initialise weights for mean of weight (multiplicative);\n            applied per component\n        mbs_init : function\n            Function to initialise weights for mean of weight (bias);\n            applied per component\n        sWs_init : function\n            Function to initialise weights for log std of weight (multiplicative);\n            applied per component\n        sbs_init : function\n            Function to initialise weights for log std of weight (bias);\n            applied per component\n        \"\"\"", "\n", "super", "(", "MixtureHomoscedasticPrecisionsLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "self", ".", "n_components", "=", "n_components", "\n", "self", ".", "rank", "=", "rank", "\n", "assert", "homoscedastic", "\n", "self", ".", "homoscedastic", "=", "homoscedastic", "\n", "self", ".", "n_dim", "=", "n_dim", "\n", "self", ".", "svi", "=", "svi", "\n", "\n", "#self.mWs = [self.add_param(mWs_init,", "\n", "#                           (self.input_shape[1], self.n_dim**2),", "\n", "#                           name='mW' + str(c), mp=True, wp=True)", "\n", "#            for c in range(n_components)]", "\n", "self", ".", "mbs", "=", "[", "self", ".", "add_param", "(", "mbs_init", ",", "\n", "(", "self", ".", "n_dim", "**", "2", ",", ")", ",", "\n", "name", "=", "'mb'", "+", "str", "(", "c", ")", ",", "mp", "=", "True", ",", "bp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "self", ".", "_srng", "=", "RandomStreams", "(", "\n", "lasagne", ".", "random", ".", "get_rng", "(", ")", ".", "randint", "(", "\n", "1", ",", "2147462579", ")", ")", "\n", "#self.sWs = [self.add_param(sWs_init,", "\n", "#                           (self.input_shape[1], self.n_dim**2),", "\n", "#                           name='sW' + str(c), sp=True, wp=True)", "\n", "#            for c in range(n_components)]", "\n", "self", ".", "sbs", "=", "[", "self", ".", "add_param", "(", "sbs_init", ",", "\n", "(", "self", ".", "n_dim", "**", "2", ",", ")", ",", "\n", "name", "=", "'sb'", "+", "str", "(", "c", ")", ",", "sp", "=", "True", ",", "bp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixturePrecisions.MixtureHomoscedasticPrecisionsLayer.get_output_for": [[206, 249], ["numpy.triu", "numpy.eye", "numpy.ones", "theano.sum", "theano.sum", "theano.reshape", "theano.reshape", "MixturePrecisions.MixtureHomoscedasticPrecisionsLayer._srng.normal", "theano.exp", "theano.exp", "theano.reshape", "theano.reshape", "theano.sum", "theano.sum", "range", "zip", "theano.exp", "theano.exp", "theano.sum", "theano.sum", "theano.sqrt", "theano.sqrt", "theano.sum", "theano.sum"], "methods", ["None"], ["", "", "def", "get_output_for", "(", "self", ",", "input", ",", "deterministic", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Compute outputs\n\n        Returns\n        -------\n        list by concatenation of\n            Us : list of length n_components with (batch, n_dim, n_dim)\n                Precision factors\n            ldetUs : list of length n_components with (batch, n_dim, n_dim)\n                Log determinants of precisions\n        \"\"\"", "\n", "triu_mask", "=", "np", ".", "triu", "(", "np", ".", "ones", "(", "[", "self", ".", "n_dim", ",", "self", ".", "n_dim", "]", ",", "dtype", "=", "dtype", ")", ",", "1", ")", "\n", "if", "not", "self", ".", "rank", "is", "None", ":", "\n", "            ", "triu_mask", "[", "self", ".", "rank", ":", "]", "*=", "0.", "\n", "", "diag_mask", "=", "np", ".", "eye", "(", "self", ".", "n_dim", ",", "dtype", "=", "dtype", ")", "\n", "\n", "if", "not", "self", ".", "svi", "or", "deterministic", ":", "\n", "            ", "zas_reshaped", "=", "[", "tt", ".", "reshape", "(", "mb", "+", "0.", "*", "tt", ".", "sum", "(", "input", ")", ",", "\n", "[", "-", "1", ",", "self", ".", "n_dim", ",", "self", ".", "n_dim", "]", ")", "for", "mb", "in", "self", ".", "mbs", "]", "\n", "", "else", ":", "\n", "            ", "uas", "=", "[", "\n", "self", ".", "_srng", ".", "normal", "(", "\n", "(", "input", ".", "shape", "[", "0", "]", ",", "\n", "self", ".", "n_dim", "**", "2", ")", ",", "\n", "dtype", "=", "dtype", ")", "for", "i", "in", "range", "(", "\n", "self", ".", "n_components", ")", "]", "\n", "mas", "=", "[", "mb", "+", "0.", "*", "tt", ".", "sum", "(", "input", ")", "for", "mb", "in", "self", ".", "mbs", "]", "\n", "sas", "=", "[", "tt", ".", "exp", "(", "2", "*", "sb", ")", "for", "sb", "in", "self", ".", "sbs", "]", "\n", "zas", "=", "[", "tt", ".", "sqrt", "(", "sa", ")", "*", "ua", "+", "ma", "for", "sa", ",", "ua", ",", "ma", "in", "zip", "(", "sas", ",", "uas", ",", "mas", ")", "]", "\n", "zas_reshaped", "=", "[", "tt", ".", "reshape", "(", "\n", "za", ",", "[", "-", "1", ",", "self", ".", "n_dim", ",", "self", ".", "n_dim", "]", ")", "for", "za", "in", "zas", "]", "\n", "\n", "", "Us", "=", "[", "\n", "triu_mask", "*", "\n", "za", "+", "\n", "diag_mask", "*", "\n", "tt", ".", "exp", "(", "\n", "diag_mask", "*", "\n", "za", ")", "for", "za", "in", "zas_reshaped", "]", "\n", "ldetUs", "=", "[", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "diag_mask", "*", "za", ",", "axis", "=", "2", ")", ",", "axis", "=", "1", ")", "\n", "for", "za", "in", "zas_reshaped", "]", "\n", "\n", "return", "{", "'Us'", ":", "Us", ",", "'ldetUs'", ":", "ldetUs", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixturePrecisions.MixtureHomoscedasticPrecisionsLayer.get_output_shape_for": [[250, 252], ["None"], "methods", ["None"], ["", "def", "get_output_shape_for", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixtureMeans.MixtureMeansLayer.__init__": [[14, 75], ["lasagne.HeNormal", "lasagne.HeNormal", "lasagne.HeNormal", "lasagne.HeNormal", "lasagne.Normal", "lasagne.Normal", "lasagne.Normal", "lasagne.Normal", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "super().__init__", "MixtureMeans.MixtureMeansLayer.add_param", "MixtureMeans.MixtureMeansLayer.add_param", "theano.sandbox.rng_mrg.MRG_RandomStreams", "theano.sandbox.rng_mrg.MRG_RandomStreams", "range", "range", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "MixtureMeans.MixtureMeansLayer.add_param", "MixtureMeans.MixtureMeansLayer.add_param", "range", "range", "str", "str", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "str", "str"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "\n", "incoming", ",", "\n", "n_components", ",", "\n", "n_dim", ",", "\n", "svi", "=", "True", ",", "\n", "mWs_init", "=", "linit", ".", "HeNormal", "(", ")", ",", "\n", "mbs_init", "=", "linit", ".", "Normal", "(", "1.", ")", ",", "\n", "sWs_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "sbs_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Fully connected layer for mixture means, optional weight uncertainty\n\n        Parameters\n        ----------\n        incoming : lasagne.layers.Layer instance\n            Incoming layer\n        n_components : int\n            Number of components\n        n_dim : int\n            Dimensionality of output vector\n        svi : bool\n            Weight uncertainty\n        mWs_init : function\n            Function to initialise weights for mean of weight (multiplicative);\n            applied per component\n        mbs_init : function\n            Function to initialise weights for mean of weight (bias);\n            applied per component\n        sWs_init : function\n            Function to initialise weights for log std of weight (multiplicative);\n            applied per component\n        sbs_init : function\n            Function to initialise weights for log std of weight (bias);\n            applied per component\n        \"\"\"", "\n", "super", "(", "MixtureMeansLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "self", ".", "n_components", "=", "n_components", "\n", "self", ".", "n_dim", "=", "n_dim", "\n", "self", ".", "svi", "=", "svi", "\n", "\n", "self", ".", "mWs", "=", "[", "self", ".", "add_param", "(", "mWs_init", ",", "\n", "(", "self", ".", "input_shape", "[", "1", "]", ",", "self", ".", "n_dim", ")", ",", "\n", "name", "=", "'mW'", "+", "str", "(", "c", ")", ",", "mp", "=", "True", ",", "wp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "self", ".", "mbs", "=", "[", "self", ".", "add_param", "(", "mbs_init", ",", "\n", "(", "self", ".", "n_dim", ",", ")", ",", "\n", "name", "=", "'mb'", "+", "str", "(", "c", ")", ",", "mp", "=", "True", ",", "bp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "self", ".", "_srng", "=", "RandomStreams", "(", "\n", "lasagne", ".", "random", ".", "get_rng", "(", ")", ".", "randint", "(", "\n", "1", ",", "2147462579", ")", ")", "\n", "self", ".", "sWs", "=", "[", "self", ".", "add_param", "(", "sWs_init", ",", "\n", "(", "self", ".", "input_shape", "[", "1", "]", ",", "self", ".", "n_dim", ")", ",", "\n", "name", "=", "'sW'", "+", "str", "(", "c", ")", ",", "sp", "=", "True", ",", "wp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "self", ".", "sbs", "=", "[", "self", ".", "add_param", "(", "sbs_init", ",", "\n", "(", "self", ".", "n_dim", ",", ")", ",", "\n", "name", "=", "'sb'", "+", "str", "(", "c", ")", ",", "sp", "=", "True", ",", "bp", "=", "True", ")", "\n", "for", "c", "in", "range", "(", "n_components", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixtureMeans.MixtureMeansLayer.get_output_for": [[76, 110], ["MixtureMeans.MixtureMeansLayer._srng.normal", "theano.dot", "theano.dot", "zip", "range", "theano.dot", "theano.dot", "zip", "theano.dot", "theano.dot", "theano.exp", "theano.exp", "zip", "zip", "theano.exp", "theano.exp", "theano.sqrt", "theano.sqrt"], "methods", ["None"], ["", "", "def", "get_output_for", "(", "self", ",", "input", ",", "deterministic", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Compute outputs\n\n        Returns\n        -------\n        list of length n_components with (batch, n_dim)\n        \"\"\"", "\n", "if", "not", "self", ".", "svi", "or", "deterministic", ":", "\n", "            ", "return", "[", "\n", "tt", ".", "dot", "(", "\n", "input", ",", "\n", "mW", ")", "+", "mb", "for", "mW", ",", "\n", "mb", "in", "zip", "(", "\n", "self", ".", "mWs", ",", "\n", "self", ".", "mbs", ")", "]", "\n", "", "else", ":", "\n", "            ", "uas", "=", "[", "\n", "self", ".", "_srng", ".", "normal", "(", "\n", "(", "input", ".", "shape", "[", "0", "]", ",", "\n", "self", ".", "n_dim", ")", ",", "\n", "dtype", "=", "dtype", ")", "for", "i", "in", "range", "(", "\n", "self", ".", "n_components", ")", "]", "\n", "mas", "=", "[", "\n", "tt", ".", "dot", "(", "\n", "input", ",", "\n", "mWm", ")", "+", "\n", "mbm", "for", "mWm", ",", "\n", "mbm", "in", "zip", "(", "\n", "self", ".", "mWs", ",", "\n", "self", ".", "mbs", ")", "]", "\n", "sas", "=", "[", "tt", ".", "dot", "(", "input", "**", "2", ",", "tt", ".", "exp", "(", "2", "*", "sW", ")", ")", "+", "tt", ".", "exp", "(", "2", "*", "sb", ")", "\n", "for", "sW", ",", "sb", "in", "zip", "(", "self", ".", "sWs", ",", "self", ".", "sbs", ")", "]", "\n", "zas", "=", "[", "tt", ".", "sqrt", "(", "sa", ")", "*", "ua", "+", "ma", "for", "sa", ",", "ua", ",", "ma", "in", "zip", "(", "sas", ",", "uas", ",", "mas", ")", "]", "\n", "return", "zas", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixtureMeans.MixtureMeansLayer.get_output_shape_for": [[111, 113], ["None"], "methods", ["None"], ["", "", "def", "get_output_shape_for", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MissingValues.ImputeMissingLayer.__init__": [[10, 14], ["lasagne.init.Normal", "lasagne.init.Normal", "lasagne.init.Normal", "lasagne.init.Normal", "super().__init__", "MissingValues.ImputeMissingLayer.add_param"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "incoming", ",", "n_inputs", ",", "R", "=", "lasagne", ".", "init", ".", "Normal", "(", "0.01", ")", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Inputs that are NaN will be replaced by learned imputation value\"\"\"", "\n", "super", "(", "ImputeMissingLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "self", ".", "R", "=", "self", ".", "add_param", "(", "R", ",", "(", "*", "n_inputs", ",", ")", ",", "name", "=", "'imputation_values'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MissingValues.ImputeMissingLayer.get_output_for": [[15, 17], ["theano.cast", "theano.cast", "theano.switch", "theano.switch", "theano.isnan", "theano.isnan"], "methods", ["None"], ["", "def", "get_output_for", "(", "self", ",", "input", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "tt", ".", "cast", "(", "tt", ".", "switch", "(", "tt", ".", "isnan", "(", "input", ")", ",", "self", ".", "R", ",", "input", ")", ",", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MissingValues.ImputeMissingLayer.get_output_shape_for": [[18, 20], ["None"], "methods", ["None"], ["", "def", "get_output_shape_for", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MissingValues.ReplaceMissingLayer.__init__": [[23, 27], ["super().__init__", "theano.zeros", "theano.zeros"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "incoming", ",", "n_inputs", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Inputs that are NaN will be replaced by zero through this layer\"\"\"", "\n", "super", "(", "ReplaceMissingLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "self", ".", "Z", "=", "tt", ".", "zeros", "(", "(", "*", "n_inputs", ",", ")", ",", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MissingValues.ReplaceMissingLayer.get_output_for": [[28, 30], ["theano.cast", "theano.cast", "theano.switch", "theano.switch", "theano.isnan", "theano.isnan"], "methods", ["None"], ["", "def", "get_output_for", "(", "self", ",", "input", ",", "**", "kwargs", ")", ":", "\n", "        ", "return", "tt", ".", "cast", "(", "tt", ".", "switch", "(", "tt", ".", "isnan", "(", "input", ")", ",", "self", ".", "Z", ",", "input", ")", ",", "dtype", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MissingValues.ReplaceMissingLayer.get_output_shape_for": [[31, 33], ["None"], "methods", ["None"], ["", "def", "get_output_shape_for", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "input_shape", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.FullyConnected.FullyConnectedLayer.__init__": [[14, 61], ["lasagne.HeNormal", "lasagne.HeNormal", "lasagne.HeNormal", "lasagne.HeNormal", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "super().__init__", "FullyConnected.FullyConnectedLayer.add_param", "FullyConnected.FullyConnectedLayer.add_param", "theano.sandbox.rng_mrg.MRG_RandomStreams", "theano.sandbox.rng_mrg.MRG_RandomStreams", "FullyConnected.FullyConnectedLayer.add_param", "FullyConnected.FullyConnectedLayer.add_param", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng().randint", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng", "lasagne.random.get_rng"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "incoming", ",", "n_units", ",", "svi", "=", "True", ",", "\n", "mW_init", "=", "linit", ".", "HeNormal", "(", ")", ",", "mb_init", "=", "linit", ".", "Constant", "(", "[", "0.", "]", ")", ",", "\n", "sW_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "sb_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "actfun", "=", "lnl", ".", "tanh", ",", "seed", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Fully connected layer with optional weight uncertainty\n\n        Parameters\n        ----------\n        incoming : lasagne.layers.Layer instance\n            Incoming layer\n        n_units : int\n            Number of units\n        svi : bool\n            Weight uncertainty\n        mW_init : function\n            Function to initialise weights for mean of weight (multiplicative)\n        mb_init : function\n            Function to initialise weights for mean of weight (bias)\n        sW_init : function\n            Function to initialise weights for log std of weight (multiplicative)\n        sb_init : function\n            Function to initialise weights for log std of weight (bias)\n        actfun : function\n            Activation function\n        \"\"\"", "\n", "super", "(", "FullyConnectedLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "self", ".", "n_units", "=", "n_units", "\n", "self", ".", "actfun", "=", "actfun", "\n", "self", ".", "svi", "=", "svi", "\n", "\n", "self", ".", "mW", "=", "self", ".", "add_param", "(", "mW_init", ",", "\n", "(", "self", ".", "input_shape", "[", "1", "]", ",", "self", ".", "n_units", ")", ",", "\n", "name", "=", "'mW'", ",", "mp", "=", "True", ",", "wp", "=", "True", ")", "\n", "self", ".", "mb", "=", "self", ".", "add_param", "(", "mb_init", ",", "\n", "(", "self", ".", "n_units", ",", ")", ",", "\n", "name", "=", "'mb'", ",", "mp", "=", "True", ",", "bp", "=", "True", ")", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "self", ".", "_srng", "=", "RandomStreams", "(", "\n", "lasagne", ".", "random", ".", "get_rng", "(", ")", ".", "randint", "(", "\n", "1", ",", "2147462579", ")", ")", "\n", "self", ".", "sW", "=", "self", ".", "add_param", "(", "sW_init", ",", "\n", "(", "self", ".", "input_shape", "[", "1", "]", ",", "self", ".", "n_units", ")", ",", "\n", "name", "=", "'sW'", ",", "sp", "=", "True", ",", "wp", "=", "True", ")", "\n", "self", ".", "sb", "=", "self", ".", "add_param", "(", "sb_init", ",", "\n", "(", "self", ".", "n_units", ",", ")", ",", "\n", "name", "=", "'sb'", ",", "sp", "=", "True", ",", "bp", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.FullyConnected.FullyConnectedLayer.get_output_for": [[62, 71], ["theano.dot", "theano.dot", "FullyConnected.FullyConnectedLayer.actfun", "FullyConnected.FullyConnectedLayer._srng.normal", "FullyConnected.FullyConnectedLayer.actfun", "theano.dot", "theano.dot", "theano.exp", "theano.exp", "theano.exp", "theano.exp", "theano.sqrt", "theano.sqrt"], "methods", ["None"], ["", "", "def", "get_output_for", "(", "self", ",", "input", ",", "deterministic", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Returns matrix with shape (batch, n_units)\"\"\"", "\n", "ma", "=", "tt", ".", "dot", "(", "input", ",", "self", ".", "mW", ")", "+", "self", ".", "mb", "\n", "if", "not", "self", ".", "svi", "or", "deterministic", ":", "\n", "            ", "return", "self", ".", "actfun", "(", "ma", ")", "\n", "", "else", ":", "\n", "            ", "sa", "=", "tt", ".", "dot", "(", "input", "**", "2", ",", "tt", ".", "exp", "(", "2", "*", "self", ".", "sW", ")", ")", "+", "tt", ".", "exp", "(", "2", "*", "self", ".", "sb", ")", "\n", "ua", "=", "self", ".", "_srng", ".", "normal", "(", "(", "input", ".", "shape", "[", "0", "]", ",", "self", ".", "n_units", ")", ",", "dtype", "=", "dtype", ")", "\n", "return", "self", ".", "actfun", "(", "tt", ".", "sqrt", "(", "sa", ")", "*", "ua", "+", "ma", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.FullyConnected.FullyConnectedLayer.get_output_shape_for": [[72, 74], ["None"], "methods", ["None"], ["", "", "def", "get_output_shape_for", "(", "self", ",", "input_shape", ")", ":", "\n", "        ", "return", "(", "input_shape", "[", "0", "]", ",", "self", ".", "n_units", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixtureWeights.MixtureWeightsLayer.__init__": [[14, 41], ["lasagne.HeNormal", "lasagne.HeNormal", "lasagne.HeNormal", "lasagne.HeNormal", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "lasagne.Constant", "delfi.neuralnet.layers.FullyConnected.FullyConnectedLayer.__init__", "delfi.neuralnet.layers.FullyConnected.FullyConnectedLayer.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "incoming", ",", "n_units", ",", "svi", "=", "True", ",", "\n", "mW_init", "=", "linit", ".", "HeNormal", "(", ")", ",", "mb_init", "=", "linit", ".", "Constant", "(", "[", "0.", "]", ")", ",", "\n", "sW_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "sb_init", "=", "linit", ".", "Constant", "(", "[", "-", "5.", "]", ")", ",", "\n", "actfun", "=", "lnl", ".", "softmax", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Mixture weights layer with optional weight uncertainty\n\n        If n_units > 1, this becomes a fully-connected layer. Else, no\n        parameters are added, and the output defaults to weight 1.\n\n        See ``delfi.neuralnet.layers.FullyConnected`` for docstring\n        \"\"\"", "\n", "self", ".", "n_units", "=", "n_units", "\n", "\n", "if", "n_units", ">", "1", ":", "\n", "            ", "super", "(", "MixtureWeightsLayer", ",", "self", ")", ".", "__init__", "(", "\n", "incoming", ",", "\n", "n_units", ",", "\n", "svi", "=", "svi", ",", "\n", "mW_init", "=", "mW_init", ",", "\n", "mb_init", "=", "mb_init", ",", "\n", "sW_init", "=", "sW_init", ",", "\n", "sb_init", "=", "sb_init", ",", "\n", "actfun", "=", "actfun", ",", "\n", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "# init of lasagne.layers.Layer", "\n", "            ", "super", "(", "FullyConnectedLayer", ",", "self", ")", ".", "__init__", "(", "incoming", ",", "**", "kwargs", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.layers.MixtureWeights.MixtureWeightsLayer.get_output_for": [[42, 51], ["super().get_output_for", "theano.ones", "theano.ones"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.layers.MixtureWeights.MixtureWeightsLayer.get_output_for"], ["", "", "def", "get_output_for", "(", "self", ",", "input", ",", "deterministic", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Returns matrix with shape (batch, n_units)\"\"\"", "\n", "if", "self", ".", "n_units", ">", "1", ":", "\n", "            ", "return", "super", "(", "MixtureWeightsLayer", ",", "self", ")", ".", "get_output_for", "(", "\n", "input", ",", "\n", "deterministic", "=", "deterministic", ",", "\n", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "return", "tt", ".", "ones", "(", "(", "input", ".", "shape", "[", "0", "]", ",", "self", ".", "n_units", ")", ",", "dtype", "=", "dtype", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_init": [[6, 52], ["sum", "sum", "sum", "sum", "sum", "range", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "len", "mp.get_value", "sp.get_value", "theano.sum", "theano.sum", "theano.sum", "theano.sum", "mp.get_value", "theano.exp", "zip", "zip", "theano.exp"], "function", ["None"], ["def", "svi_kl_init", "(", "mps", ",", "sps", ")", ":", "\n", "    ", "\"\"\"Regularization for SVI such that parameters stay close to initial values\n\n    Parameters\n    ----------\n    mps : list of means\n    sps : list of log stds\n\n    Returns\n    -------\n    L : theano variable\n        Regularizer\n    imvs : dict\n        Pointers to intermediate variables for monitoring during training\n    \"\"\"", "\n", "imvs", "=", "{", "}", "\n", "\n", "n_params", "=", "sum", "(", "[", "mp", ".", "get_value", "(", ")", ".", "size", "for", "mp", "in", "mps", "]", ")", "\n", "\n", "mps_init", "=", "[", "theano", ".", "shared", "(", "mp", ".", "get_value", "(", ")", ")", "for", "mp", "in", "mps", "]", "\n", "sps_init", "=", "[", "theano", ".", "shared", "(", "sp", ".", "get_value", "(", ")", ")", "for", "sp", "in", "sps", "]", "\n", "\n", "logdet_Sigma1", "=", "sum", "(", "[", "tt", ".", "sum", "(", "2", "*", "sp", ")", "for", "sp", "in", "sps", "]", ")", "\n", "logdet_Sigma2", "=", "sum", "(", "[", "tt", ".", "sum", "(", "2", "*", "sp_init", ")", "for", "sp_init", "in", "sps_init", "]", ")", "\n", "\n", "tr_invSigma2_Sigma1", "=", "sum", "(", "[", "tt", ".", "sum", "(", "tt", ".", "exp", "(", "2", "*", "(", "sp", "-", "sp_init", ")", ")", ")", "\n", "for", "sp", ",", "sp_init", "in", "zip", "(", "sps", ",", "sps_init", ")", "]", ")", "\n", "\n", "quad_form", "=", "sum", "(", "[", "tt", ".", "sum", "(", "(", "(", "mp", "-", "mp_init", ")", "**", "2", "/", "tt", ".", "exp", "(", "2", "*", "sp_init", ")", ")", ")", "\n", "for", "mp", ",", "mp_init", ",", "sp_init", "in", "zip", "(", "mps", ",", "mps_init", ",", "sps_init", ")", "]", ")", "\n", "\n", "L", "=", "0.5", "*", "(", "logdet_Sigma2", "-", "logdet_Sigma1", "-", "\n", "n_params", "+", "tr_invSigma2_Sigma1", "+", "quad_form", ")", "\n", "\n", "# intermediate values that can be monitored", "\n", "imvs", "[", "'reg.logdetP'", "]", "=", "-", "logdet_Sigma1", "\n", "\n", "for", "i", "in", "range", "(", "len", "(", "mps", ")", ")", ":", "\n", "        ", "imvs", "[", "'reg.mds{}'", ".", "format", "(", "i", ")", "]", "=", "mps", "[", "i", "]", "-", "mps_init", "[", "i", "]", "\n", "\n", "", "imvs", "[", "'reg.quad_form'", "]", "=", "quad_form", "\n", "imvs", "[", "'reg.diff_logdet_Sigma'", "]", "=", "logdet_Sigma2", "-", "logdet_Sigma1", "\n", "imvs", "[", "'reg.tr_invSigma2_Sigma1'", "]", "=", "tr_invSigma2_Sigma1", "\n", "imvs", "[", "'reg.total_dkl'", "]", "=", "L", "\n", "\n", "return", "L", ",", "imvs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_zero_diag_gauss": [[54, 114], ["sum", "sum", "sum", "sum", "sum", "sum", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.shared", "theano.sum", "theano.sum", "theano.sum", "theano.sum", "theano.exp", "zip", "zip", "mp.get_value", "mp.get_value", "mp.get_value", "mp.get_value", "numpy.log", "theano.exp", "sp.get_value", "numpy.sqrt", "sp.get_value", "numpy.log", "numpy.sqrt", "sp.get_value", "sp.get_value"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "svi_kl_zero_diag_gauss", "(", "mps_wp", ",", "sps_wp", ",", "mps_bp", ",", "sps_bp", ",", "a", "=", "1.0", ")", ":", "\n", "    ", "\"\"\"Regularization for SVI such that parameters stay close to zero\n\n    The covariance matrix is a diagonal Gaussian. Entries on the diagonal are\n    set according to 1/N_in where N_in is the number of incoming connections.\n    For bias parameters, a*1/N_in.\n\n    Parameters\n    ----------\n    mps_wp : list\n        means of weight parameters\n    sps_wp : list\n        log stds of weight parameters\n    mps_bp : list\n        means of bias parameters\n    sps_bp : list\n        log stds of bias parameters\n    a : float\n        multiplies variance of bias parameters\n\n    Returns\n    -------\n    L : theano variable\n        Regularizer\n    imvs : dict\n        Pointers to intermediate variables for monitoring during training\n    \"\"\"", "\n", "imvs", "=", "{", "}", "\n", "\n", "n_params", "=", "sum", "(", "[", "mp", ".", "get_value", "(", ")", ".", "size", "for", "mp", "in", "mps_wp", "]", ")", "+", "sum", "(", "[", "mp", ".", "get_value", "(", ")", ".", "size", "for", "mp", "in", "mps_bp", "]", ")", "\n", "\n", "mps_prior", "=", "[", "theano", ".", "shared", "(", "0.", "*", "mp", ".", "get_value", "(", ")", ")", "for", "mp", "in", "mps_wp", "]", "+", "[", "theano", ".", "shared", "(", "0.", "*", "mp", ".", "get_value", "(", ")", ")", "for", "mp", "in", "mps_bp", "]", "\n", "sps_prior", "=", "[", "theano", ".", "shared", "(", "0.", "*", "sp", ".", "get_value", "(", ")", "+", "\n", "np", ".", "log", "(", "np", ".", "sqrt", "(", "1.0", "/", "sp", ".", "get_value", "(", ")", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "for", "sp", "in", "sps_wp", "]", "+", "[", "theano", ".", "shared", "(", "0.", "*", "sp", ".", "get_value", "(", ")", "+", "\n", "a", "*", "np", ".", "log", "(", "np", ".", "sqrt", "(", "1.0", "/", "sp", ".", "get_value", "(", ")", ".", "shape", "[", "0", "]", ")", ")", ")", "\n", "for", "sp", "in", "sps_bp", "]", "\n", "\n", "mps", "=", "mps_wp", "+", "mps_bp", "\n", "sps", "=", "sps_wp", "+", "sps_bp", "\n", "\n", "logdet_Sigma1", "=", "sum", "(", "[", "tt", ".", "sum", "(", "2", "*", "sp", ")", "for", "sp", "in", "sps", "]", ")", "\n", "logdet_Sigma2", "=", "sum", "(", "[", "tt", ".", "sum", "(", "2", "*", "sp_prior", ")", "for", "sp_prior", "in", "sps_prior", "]", ")", "\n", "\n", "tr_invSigma2_Sigma1", "=", "sum", "(", "[", "tt", ".", "sum", "(", "tt", ".", "exp", "(", "2", "*", "(", "sp", "-", "sp_prior", ")", ")", ")", "\n", "for", "sp", ",", "sp_prior", "in", "zip", "(", "sps", ",", "sps_prior", ")", "]", ")", "\n", "\n", "quad_form", "=", "sum", "(", "[", "tt", ".", "sum", "(", "(", "(", "mp", "-", "mp_prior", ")", "**", "2", "/", "tt", ".", "exp", "(", "2", "*", "sp_prior", ")", ")", ")", "\n", "for", "mp", ",", "mp_prior", ",", "sp_prior", "in", "zip", "(", "mps", ",", "mps_prior", ",", "sps_prior", ")", "]", ")", "\n", "\n", "L", "=", "0.5", "*", "(", "logdet_Sigma2", "-", "logdet_Sigma1", "-", "\n", "n_params", "+", "tr_invSigma2_Sigma1", "+", "quad_form", ")", "\n", "\n", "# intermediate values that can be monitored", "\n", "imvs", "[", "'reg.quad_form'", "]", "=", "quad_form", "\n", "\n", "return", "L", ",", "imvs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_zero": [[116, 149], ["sum", "sum", "sum", "sum", "theano.sum", "numpy.log", "mp.get_value", "theano.sum", "theano.sum", "theano.exp"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "svi_kl_zero", "(", "mps", ",", "sps", ",", "wdecay", ")", ":", "\n", "    ", "\"\"\"Default regularization for SVI\n\n    Prior is a spherical zero-centered Gauss whose precision corresponds to the\n    weight decay parameter\n\n    Parameters\n    ----------\n    mps : list of means\n    sps : list of log stds\n    wdecay : precision parameter (lambda)\n\n    Returns\n    -------\n    L : theano variable\n        Regularizer\n    imvs : dict\n        Pointers to intermediate variables for monitoring during training\n    \"\"\"", "\n", "assert", "wdecay", ">", "0.0", "\n", "\n", "imvs", "=", "{", "}", "\n", "\n", "n_params", "=", "sum", "(", "[", "mp", ".", "get_value", "(", ")", ".", "size", "for", "mp", "in", "mps", "]", ")", "\n", "\n", "L1", "=", "0.5", "*", "wdecay", "*", "(", "sum", "(", "[", "tt", ".", "sum", "(", "mp", "**", "2", ")", "for", "mp", "in", "mps", "]", ")", "+", "\n", "sum", "(", "[", "tt", ".", "sum", "(", "tt", ".", "exp", "(", "sp", "*", "2", ")", ")", "for", "sp", "in", "sps", "]", ")", ")", "\n", "L2", "=", "sum", "(", "[", "tt", ".", "sum", "(", "sp", ")", "for", "sp", "in", "sps", "]", ")", "\n", "Lc", "=", "0.5", "*", "n_params", "*", "(", "1.0", "+", "np", ".", "log", "(", "wdecay", ")", ")", "\n", "\n", "L", "=", "L1", "-", "L2", "-", "Lc", "\n", "\n", "return", "L", ",", "imvs", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.snpe_loss_prior_as_proposal": [[9, 33], ["theano.mean", "theano.mean"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["def", "snpe_loss_prior_as_proposal", "(", "model", ",", "svi", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Simplest loss function, for the case where the prior is the same as the\n    proposal. In this case snpe-A, snpe-B and APT are equivalent, and we're\n    simply maximizing the likelihood of params under the parameterized mdn.\n\n    Parameters\n    ----------\n    model : NeuralNet or ConditionalMaskedAutoregressiveFlow\n        Mixture density network or conditional masked autoregressive flow.\n    svi : bool\n        Whether to use SVI version of the model or not (only for MDN models)\n\n    Returns\n    -------\n    loss : theano scalar\n        Loss function\n    trn_inputs : list\n        Tensors to be provided to the loss function during training\n    \"\"\"", "\n", "# note that lprobs and dlprobs are the same for non-svi networks", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "model", ".", "lprobs", ")", "if", "svi", "else", "-", "tt", ".", "mean", "(", "model", ".", "dlprobs", ")", "\n", "trn_inputs", "=", "[", "model", ".", "params", ",", "model", ".", "stats", "]", "\n", "return", "loss", ",", "trn_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.snpeb_loss": [[35, 43], ["delfi.utils.symbolic.tensorN", "theano.mean"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "snpeb_loss", "(", "model", ",", "svi", "=", "False", ")", ":", "\n", "# note that lprobs and dlprobs are the same for non-svi networks", "\n", "    ", "lprobs", "=", "model", ".", "lprobs", "if", "svi", "else", "model", ".", "dlprobs", "\n", "iws", "=", "tensorN", "(", "1", ",", "name", "=", "'iws'", ",", "dtype", "=", "dtype", ")", "# importance weights", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "iws", "*", "lprobs", ")", "\n", "# collect extra input variables to be provided for each training data point", "\n", "trn_inputs", "=", "[", "model", ".", "params", ",", "model", ".", "stats", ",", "iws", "]", "\n", "return", "loss", ",", "trn_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_loss_MoG_proposal": [[45, 199], ["isinstance", "mdn.get_mog_tensors", "theano.log", "theano.stack().dimshuffle", "theano.stack().dimshuffle", "theano.stack().dimshuffle", "theano.stack", "theano.stack", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "theano.sqrt", "Us_normed.reshape", "theano.batched_dot", "tt.batched_dot.reshape", "delfi.utils.symbolic.cholesky_each", "theano.sum", "delfi.utils.symbolic.invert_each", "pp_las_nonnormed.reshape.reshape", "pp_ldetPs.reshape.reshape", "pp_ms.reshape.reshape", "pp_Ps.reshape.reshape", "tt.stack().dimshuffle.dimshuffle", "P_0s.dimshuffle", "theano.sum", "tt.sqrt.dimshuffle", "tt.sqrt.dimshuffle", "tt.stack().dimshuffle.dimshuffle", "tt.sqrt.dimshuffle", "P_0s.dimshuffle", "Us_normed.reshape.dimshuffle", "theano.log", "tt.stack().dimshuffle.dimshuffle", "Pm_0s.dimshuffle", "delfi.utils.symbolic.MyLogSumExp", "theano.mean", "isinstance", "theano.stack", "theano.stack", "theano.stack", "numpy.eye", "theano.sum", "theano.sum", "tt.log.dimshuffle", "delfi.utils.symbolic.tensorN.dimshuffle", "range", "zip", "delfi.utils.symbolic.mog_LL", "numpy.eye", "theano.log", "pp_Pms.dimshuffle", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog_tensors", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.cholesky_each", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.invert_each", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.mog_LL", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "apt_loss_MoG_proposal", "(", "mdn", ",", "prior", ",", "n_proposal_components", "=", "None", ",", "svi", "=", "False", ",", "add_prior_precision", "=", "True", ",", "Ptol", "=", "1e-7", ")", ":", "\n", "    ", "\"\"\"Define loss function for training with a MoG proposal, allowing\n    the proposal distribution to be different for each sample. The proposal\n    means, precisions and weights are passed along with the stats and params.\n\n    This function computes a symbolic expression but does not actually compile\n    or calculate that expression.\n\n    This loss does not include any regularization or prior terms, which must be\n    added separately before compiling.\n\n    Parameters\n    ----------\n    mdn : NeuralNet\n        Mixture density network.\n    svi : bool\n        Whether to use SVI version of the mdn or not\n\n    Returns\n    -------\n    loss : theano scalar\n        Loss function\n    trn_inputs : list\n        Tensors to be provided to the loss function during training\n    \"\"\"", "\n", "assert", "mdn", ".", "density", "==", "'mog'", "\n", "uniform_prior", "=", "isinstance", "(", "prior", ",", "dd", ".", "Uniform", ")", "\n", "if", "not", "uniform_prior", "and", "not", "isinstance", "(", "prior", ",", "dd", ".", "Gaussian", ")", ":", "\n", "        ", "raise", "NotImplemented", "# prior must be Gaussian or uniform", "\n", "", "ncprop", "=", "mdn", ".", "n_components", "if", "n_proposal_components", "is", "None", "else", "n_proposal_components", "# default to component count of posterior", "\n", "\n", "nbatch", "=", "mdn", ".", "params", ".", "shape", "[", "0", "]", "\n", "\n", "# a mixture weights, ms means, P=U^T U precisions, QFs are tensorQF(P, m)", "\n", "a", ",", "ms", ",", "Us", ",", "ldetUs", ",", "Ps", ",", "ldetPs", ",", "Pms", ",", "QFs", "=", "mdn", ".", "get_mog_tensors", "(", "return_extras", "=", "True", ",", "svi", "=", "svi", ")", "\n", "# convert mixture vars from lists of tensors to single tensors, of sizes:", "\n", "las", "=", "tt", ".", "log", "(", "a", ")", "\n", "Us", "=", "tt", ".", "stack", "(", "Us", ",", "axis", "=", "3", ")", ".", "dimshuffle", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "Ps", "=", "tt", ".", "stack", "(", "Ps", ",", "axis", "=", "3", ")", ".", "dimshuffle", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "Pms", "=", "tt", ".", "stack", "(", "Pms", ",", "axis", "=", "2", ")", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ")", "\n", "ldetPs", "=", "tt", ".", "stack", "(", "ldetPs", ",", "axis", "=", "1", ")", "\n", "QFs", "=", "tt", ".", "stack", "(", "QFs", ",", "axis", "=", "1", ")", "\n", "# as: (batch, mdn.n_components)", "\n", "# Ps: (batch, mdn.n_components, n_outputs, n_outputs)", "\n", "# Pm: (batch, mdn.n_components, n_outputs)", "\n", "# ldetPs: (batch, mdn.n_components)", "\n", "# QFs: (batch, mdn.n_components)", "\n", "\n", "# Define symbolic variables, that hold for each sample's MoG proposal:", "\n", "# precisions times means (batch, ncprop, n_outputs)", "\n", "# precisions (batch, ncprop, n_outputs, n_outputs)", "\n", "# log determinants of precisions (batch, ncprop)", "\n", "# log mixture weights (batch, ncprop)", "\n", "# quadratic forms QF = m^T P m (batch, ncprop)", "\n", "prop_Pms", "=", "tensorN", "(", "3", ",", "name", "=", "'prop_Pms'", ",", "dtype", "=", "dtype", ")", "\n", "prop_Ps", "=", "tensorN", "(", "4", ",", "name", "=", "'prop_Ps'", ",", "dtype", "=", "dtype", ")", "\n", "prop_ldetPs", "=", "tensorN", "(", "2", ",", "name", "=", "'prop_ldetPs'", ",", "dtype", "=", "dtype", ")", "\n", "prop_las", "=", "tensorN", "(", "2", ",", "name", "=", "'prop_las'", ",", "dtype", "=", "dtype", ")", "\n", "prop_QFs", "=", "tensorN", "(", "2", ",", "name", "=", "'prop_QFs'", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# calculate corrections to precisions (P_0s) and precisions * means (Pm_0s)", "\n", "P_0s", "=", "prop_Ps", "\n", "Pm_0s", "=", "prop_Pms", "\n", "if", "not", "uniform_prior", "and", "not", "add_prior_precision", ":", "# Gaussian prior", "\n", "        ", "P_0s", "=", "P_0s", "-", "prior", ".", "P", "\n", "Pm_0s", "=", "Pm_0s", "-", "prior", ".", "Pm", "\n", "\n", "# To calculate the proposal posterior, we multiply all mixture component", "\n", "# pdfs from the true posterior by those from the proposal. The resulting", "\n", "# new mixture is ordered such that all product terms involving the first", "\n", "# component of the true posterior appear first. The shape of pp_Ps is", "\n", "# (batch, mdn.n_components, ncprop, n_outputs, n_outputs)", "\n", "", "pp_Ps", "=", "Ps", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ",", "2", ",", "3", ")", "+", "P_0s", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ",", "2", ",", "3", ")", "\n", "spp", "=", "pp_Ps", ".", "shape", "\n", "\n", "# get square roots of diagonal entries of posterior proposal precision components, which are equal to the L2 norms", "\n", "# of the Cholesky factor columns for the same matrix. we'll use these to improve the numerical conditioning of pp_Ps", "\n", "ds", "=", "tt", ".", "sqrt", "(", "tt", ".", "sum", "(", "pp_Ps", "*", "np", ".", "eye", "(", "mdn", ".", "n_outputs", ")", ",", "axis", "=", "4", ")", ")", "\n", "Ds", "=", "ds", ".", "dimshuffle", "(", "0", ",", "1", ",", "2", ",", "'x'", ",", "3", ")", "*", "ds", ".", "dimshuffle", "(", "0", ",", "1", ",", "2", ",", "3", ",", "'x'", ")", "\n", "# normalize the estimate of each true posterior component according to the corresponding elements of d:", "\n", "# first normalize the Cholesky factor of the true posterior component estimate, separately for each pairing of", "\n", "# proposal and true posterior components...", "\n", "Us_normed", "=", "Us", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ",", "2", ",", "3", ")", "/", "ds", ".", "dimshuffle", "(", "0", ",", "1", ",", "2", ",", "'x'", ",", "3", ")", "\n", "# then normalize the propsal. the resulting list is the same proposal, differently normalized for each component of", "\n", "# the true posterior", "\n", "P_0s_normed", "=", "P_0s", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ",", "2", ",", "3", ")", "/", "Ds", "\n", "\n", "# reshape temporarily so there's just one batch dimension", "\n", "Us_normed_R", "=", "Us_normed", ".", "reshape", "(", "(", "-", "1", ",", "mdn", ".", "n_outputs", ",", "mdn", ".", "n_outputs", ")", ")", "\n", "Ps_normed_R", "=", "tt", ".", "batched_dot", "(", "Us_normed_R", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ")", ",", "Us_normed_R", ")", "\n", "Ps_normed", "=", "Ps_normed_R", ".", "reshape", "(", "spp", ")", "\n", "\n", "pp_Ps_normed", "=", "Ps_normed", "+", "P_0s_normed", "+", "np", ".", "eye", "(", "mdn", ".", "n_outputs", ")", "*", "Ptol", "\n", "# lower Cholesky factors for normalized precisions of proposal posterior components", "\n", "pp_Ls_normed", "=", "cholesky_each", "(", "pp_Ps_normed", ")", "\n", "# log determinants of lower Cholesky factors for normalized precisions of proposal posterior components", "\n", "pp_ldetLs_normed", "=", "tt", ".", "sum", "(", "tt", ".", "log", "(", "tt", ".", "sum", "(", "pp_Ls_normed", "*", "np", ".", "eye", "(", "mdn", ".", "n_outputs", ")", ",", "axis", "=", "4", ")", ")", ",", "axis", "=", "3", ")", "\n", "# precisions of proposal posterior components (now well-conditioned)", "\n", "pp_Ps", "=", "pp_Ps_normed", "*", "Ds", "\n", "# log determinants of proposal posterior precisions", "\n", "pp_ldetPs", "=", "2.0", "*", "(", "tt", ".", "sum", "(", "tt", ".", "log", "(", "ds", ")", ",", "axis", "=", "3", ")", "+", "pp_ldetLs_normed", ")", "\n", "# covariance matrices", "\n", "pp_Ss", "=", "invert_each", "(", "pp_Ps", ")", "# covariances of proposal posterior components", "\n", "# precision times mean for each proposal posterior component:", "\n", "pp_Pms", "=", "Pms", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ",", "2", ")", "+", "Pm_0s", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ",", "2", ")", "\n", "# mean of proposal posterior components:", "\n", "pp_ms", "=", "(", "pp_Ss", "*", "pp_Pms", ".", "dimshuffle", "(", "0", ",", "1", ",", "2", ",", "'x'", ",", "3", ")", ")", ".", "sum", "(", "axis", "=", "4", ")", "\n", "# quadratic form defined by each pp_P evaluated at each pp_m", "\n", "pp_QFs", "=", "(", "pp_Pms", "*", "pp_ms", ")", ".", "sum", "(", "axis", "=", "3", ")", "\n", "\n", "# normalization constants for integrals of Gaussian product-quotients", "\n", "# (for Gaussian proposals) or Gaussian products (for uniform priors)", "\n", "# Note we drop a \"constant\" (for each combination of sample, proposal", "\n", "# component posterior component) term of", "\n", "#", "\n", "# 0.5 * (tensorQF(prior.P, prior.m) - prior_ldetP)", "\n", "#", "\n", "# since we're going to normalize the pp mixture coefficients sum to 1", "\n", "pp_lZs", "=", "0.5", "*", "(", "(", "ldetPs", "-", "QFs", ")", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ")", "+", "\n", "(", "prop_ldetPs", "-", "prop_QFs", ")", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", "-", "\n", "(", "pp_ldetPs", "-", "pp_QFs", ")", ")", "\n", "\n", "# calculate non-normalized log mixture coefficients of the proposal", "\n", "# posterior by adding log posterior weights a to normalization coefficients", "\n", "# Z. These do not yet sum to 1 in the linear domain", "\n", "pp_las_nonnormed", "=", "las", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ")", "+", "prop_las", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", "+", "pp_lZs", "\n", "\n", "# reshape tensors describing proposal posterior components so that there's", "\n", "# only one dimension that ranges over components", "\n", "ncpp", "=", "ncprop", "*", "mdn", ".", "n_components", "# number of proposal posterior components", "\n", "pp_las_nonnormed", "=", "pp_las_nonnormed", ".", "reshape", "(", "(", "nbatch", ",", "ncpp", ")", ")", "\n", "pp_ldetPs", "=", "pp_ldetPs", ".", "reshape", "(", "(", "nbatch", ",", "ncpp", ")", ")", "\n", "pp_ms", "=", "pp_ms", ".", "reshape", "(", "(", "nbatch", ",", "ncpp", ",", "mdn", ".", "n_outputs", ")", ")", "\n", "pp_Ps", "=", "pp_Ps", ".", "reshape", "(", "(", "nbatch", ",", "ncpp", ",", "mdn", ".", "n_outputs", ",", "mdn", ".", "n_outputs", ")", ")", "\n", "\n", "# normalize log mixture weights so they sum to 1 in the linear domain", "\n", "pp_las", "=", "pp_las_nonnormed", "-", "MyLogSumExp", "(", "pp_las_nonnormed", ",", "axis", "=", "1", ")", "\n", "\n", "mog_LL_inputs", "=", "[", "(", "pp_ms", "[", ":", ",", "i", ",", ":", "]", ",", "pp_Ps", "[", ":", ",", "i", ",", ":", ",", ":", "]", ",", "pp_ldetPs", "[", ":", ",", "i", "]", ")", "\n", "for", "i", "in", "range", "(", "ncpp", ")", "]", "# list (over comps) of tuples (over vars)", "\n", "# 2 tensor inputs, lists (over comps) of tensors:", "\n", "mog_LL_inputs", "=", "[", "mdn", ".", "params", ",", "pp_las", ",", "*", "zip", "(", "*", "mog_LL_inputs", ")", "]", "\n", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "mog_LL", "(", "*", "mog_LL_inputs", ")", ")", "\n", "\n", "# collect extra input variables to be provided for each training data point", "\n", "trn_inputs", "=", "[", "mdn", ".", "params", ",", "mdn", ".", "stats", ",", "\n", "prop_Pms", ",", "prop_Ps", ",", "prop_ldetPs", ",", "prop_las", ",", "prop_QFs", "]", "\n", "\n", "return", "loss", ",", "trn_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_loss_gaussian_proposal": [[201, 308], ["isinstance", "mdn.get_mog_tensors", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "theano.sum", "theano.sqrt", "delfi.utils.symbolic.cholesky_each", "theano.sum", "delfi.utils.symbolic.invert_each", "theano.batched_dot", "theano.sum", "theano.stack", "theano.log", "delfi.utils.symbolic.MyLogSumExp", "theano.mean", "isinstance", "delfi.utils.symbolic.tensorN.dimshuffle", "theano.sum", "d.dimshuffle", "zip", "zip", "theano.log", "d.dimshuffle", "zip", "zip", "zip", "zip", "zip", "delfi.utils.symbolic.mog_LL", "d.dimshuffle", "d.dimshuffle", "theano.batched_dot", "numpy.eye", "theano.sum", "d.dimshuffle", "theano.sum", "numpy.eye", "U_normed.dimshuffle", "theano.log", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog_tensors", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.cholesky_each", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.invert_each", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.mog_LL", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "apt_loss_gaussian_proposal", "(", "mdn", ",", "prior", ",", "svi", "=", "False", ",", "add_prior_precision", "=", "True", ",", "Ptol", "=", "1e-7", ")", ":", "\n", "    ", "\"\"\"Define loss function for training with a Gaussian proposal, allowing\n    the proposal distribution to be different for each sample. The proposal\n    mean and precision are passed along with the stats and params.\n\n    This function computes a symbolic expression but does not actually compile\n    or calculate that expression.\n\n    This loss does not include any regularization or prior terms, which must be\n    added separately before compiling.\n\n    Parameters\n    ----------\n    mdn : NeuralNet\n        Mixture density network.\n    svi : bool\n        Whether to use SVI version of the mdn or not\n\n    Returns\n    -------\n    loss : theano scalar\n        Loss function\n    trn_inputs : list\n        Tensors to be provided to the loss function during training\n    prior: delfi distribution\n        Prior distribution on parameters\n    \"\"\"", "\n", "assert", "mdn", ".", "density", "==", "'mog'", "\n", "uniform_prior", "=", "isinstance", "(", "prior", ",", "dd", ".", "Uniform", ")", "\n", "if", "not", "uniform_prior", "and", "not", "isinstance", "(", "prior", ",", "dd", ".", "Gaussian", ")", ":", "\n", "        ", "raise", "NotImplemented", "# prior must be Gaussian or uniform", "\n", "\n", "# a mixture weights, ms means, P=U^T U precisions, QFs are tensorQF(P, m)", "\n", "", "a", ",", "ms", ",", "Us", ",", "ldetUs", ",", "Ps", ",", "ldetPs", ",", "Pms", ",", "QFs", "=", "mdn", ".", "get_mog_tensors", "(", "return_extras", "=", "True", ",", "svi", "=", "svi", ")", "\n", "\n", "# define symbolic variables to hold for each sample's Gaussian proposal:", "\n", "# means (batch, n_outputs)", "\n", "# precisions (batch, n_outputs, n_outputs)", "\n", "prop_m", "=", "tensorN", "(", "2", ",", "name", "=", "'prop_m'", ",", "dtype", "=", "dtype", ")", "\n", "prop_P", "=", "tensorN", "(", "3", ",", "name", "=", "'prop_P'", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# calculate corrections to precision (P_0) and precision * mean (Pm_0)", "\n", "P_0", "=", "prop_P", "\n", "Pm_0", "=", "tt", ".", "sum", "(", "prop_P", "*", "prop_m", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", ",", "axis", "=", "2", ")", "\n", "if", "not", "uniform_prior", "and", "not", "add_prior_precision", ":", "# Gaussian prior", "\n", "        ", "P_0", "=", "P_0", "-", "prior", ".", "P", "\n", "Pm_0", "=", "Pm_0", "-", "prior", ".", "Pm", "\n", "\n", "# precisions of proposal posterior components (before numerical conditioning step)", "\n", "", "pp_Ps", "=", "[", "P", "+", "P_0", "for", "P", "in", "Ps", "]", "\n", "\n", "# get square roots of diagonal entries of posterior proposal precision components, which are equal to the L2 norms", "\n", "# of the Cholesky factor columns for the same matrix. we'll use these to improve the numerical conditioning of pp_Ps", "\n", "ds", "=", "[", "tt", ".", "sqrt", "(", "tt", ".", "sum", "(", "pp_P", "*", "np", ".", "eye", "(", "mdn", ".", "n_outputs", ")", ",", "axis", "=", "2", ")", ")", "for", "pp_P", "in", "pp_Ps", "]", "\n", "# normalize the estimate of each true posterior component according to the corresponding elements of d:", "\n", "# first normalize the Cholesky factor of the true posterior component estimate...", "\n", "Us_normed", "=", "[", "U", "/", "d", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", "for", "U", ",", "d", "in", "zip", "(", "Us", ",", "ds", ")", "]", "\n", "# then normalize the propsal. the resulting list is the same proposal, differently normalized for each component of", "\n", "# the true posterior", "\n", "P_0s_normed", "=", "[", "P_0", "/", "(", "d", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", "*", "d", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ")", ")", "for", "d", "in", "ds", "]", "\n", "pp_Ps_normed", "=", "[", "tt", ".", "batched_dot", "(", "U_normed", ".", "dimshuffle", "(", "0", ",", "2", ",", "1", ")", ",", "U_normed", ")", "+", "P_0_normed", "+", "np", ".", "eye", "(", "mdn", ".", "n_outputs", ")", "*", "Ptol", "\n", "for", "U_normed", ",", "P_0_normed", "in", "zip", "(", "Us_normed", ",", "P_0s_normed", ")", "]", "\n", "# lower Cholesky factors for normalized precisions of proposal posterior components", "\n", "pp_Ls_normed", "=", "[", "cholesky_each", "(", "pp_P_normed", ")", "for", "pp_P_normed", "in", "pp_Ps_normed", "]", "\n", "# log determinants of lower Cholesky factors for normalized precisions of proposal posterior components", "\n", "pp_ldetLs_normed", "=", "[", "tt", ".", "sum", "(", "tt", ".", "log", "(", "tt", ".", "sum", "(", "pp_L_normed", "*", "np", ".", "eye", "(", "mdn", ".", "n_outputs", ")", ",", "axis", "=", "2", ")", ")", ",", "axis", "=", "1", ")", "\n", "for", "pp_L_normed", "in", "pp_Ls_normed", "]", "\n", "# precisions of proposal posterior components (now well-conditioned)", "\n", "pp_Ps", "=", "[", "d", ".", "dimshuffle", "(", "0", ",", "1", ",", "'x'", ")", "*", "pp_P_normed", "*", "d", ".", "dimshuffle", "(", "0", ",", "'x'", ",", "1", ")", "\n", "for", "pp_P_normed", ",", "d", "in", "zip", "(", "pp_Ps_normed", ",", "ds", ")", "]", "\n", "# log determinants of proposal posterior precisions", "\n", "pp_ldetPs", "=", "[", "2.0", "*", "(", "tt", ".", "sum", "(", "tt", ".", "log", "(", "d", ")", ",", "axis", "=", "1", ")", "+", "pp_ldetL_normed", ")", "\n", "for", "d", ",", "pp_ldetL_normed", "in", "zip", "(", "ds", ",", "pp_ldetLs_normed", ")", "]", "\n", "\n", "# covariances of proposal posterior components:", "\n", "pp_Ss", "=", "[", "invert_each", "(", "P", ")", "for", "P", "in", "pp_Ps", "]", "\n", "# precision times mean for each proposal posterior component:", "\n", "pp_Pms", "=", "[", "Pm", "+", "Pm_0", "for", "Pm", "in", "Pms", "]", "\n", "# mean of proposal posterior components:", "\n", "pp_ms", "=", "[", "tt", ".", "batched_dot", "(", "S", ",", "Pm", ")", "for", "S", ",", "Pm", "in", "zip", "(", "pp_Ss", ",", "pp_Pms", ")", "]", "\n", "# quadratic form defined by each pp_P evaluated at each pp_m", "\n", "pp_QFs", "=", "[", "tt", ".", "sum", "(", "m", "*", "Pm", ",", "axis", "=", "1", ")", "for", "m", ",", "Pm", "in", "zip", "(", "pp_ms", ",", "pp_Pms", ")", "]", "\n", "\n", "# normalization constants for integrals of Gaussian product-quotients", "\n", "# (for Gaussian proposals) or Gaussian products (for uniform priors)", "\n", "# Note we drop a \"constant\" (for each sample, w.r.t trained params) term of", "\n", "#", "\n", "# 0.5 * (prop_ldetP - prior_ldetP + tensorQF(prior.P, prior.m) - tensorQF(prop_P, prop_m))", "\n", "#", "\n", "# since we're going to normalize the pp mixture coefficients sum to 1", "\n", "pp_lZs", "=", "[", "0.5", "*", "(", "ldetP", "-", "pp_ldetP", "-", "QF", "+", "pp_QF", ")", "\n", "for", "ldetP", ",", "pp_ldetP", ",", "QF", ",", "pp_QF", "\n", "in", "zip", "(", "ldetPs", ",", "pp_ldetPs", ",", "QFs", ",", "pp_QFs", ")", "]", "\n", "\n", "# calculate log mixture coefficients of proposal posterior in two steps:", "\n", "# 1) add log posterior weights a to normalization coefficients Z", "\n", "# 2) normalize to sum to 1 in the linear domain, but stay in the log domain", "\n", "pp_las", "=", "tt", ".", "stack", "(", "pp_lZs", ",", "axis", "=", "1", ")", "+", "tt", ".", "log", "(", "a", ")", "\n", "pp_las", "=", "pp_las", "-", "MyLogSumExp", "(", "pp_las", ",", "axis", "=", "1", ")", "\n", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "mog_LL", "(", "mdn", ".", "params", ",", "pp_las", ",", "pp_ms", ",", "pp_Ps", ",", "pp_ldetPs", ")", ")", "\n", "\n", "# collect extra input variables to be provided for each training data point", "\n", "trn_inputs", "=", "[", "mdn", ".", "params", ",", "mdn", ".", "stats", ",", "prop_m", ",", "prop_P", "]", "\n", "\n", "return", "loss", ",", "trn_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_loss_atomic_proposal": [[310, 326], ["lossfunc.apt_mdn_loss_atomic_proposal", "lossfunc.apt_maf_loss_atomic_proposal"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_mdn_loss_atomic_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_maf_loss_atomic_proposal"], ["", "def", "apt_loss_atomic_proposal", "(", "model", ",", "svi", "=", "False", ",", "combined_loss", "=", "False", ")", ":", "\n", "    ", "\"\"\"Define loss function for training with a atomic proposal. Assumes a\n    uniform proposal distribution over each sample parameter and an externally\n    provided set of alternatives.\n\n    model : NeuralNet or ConditionalMaskedAutoregressiveFlow\n        Mixture density network or conditional masked autoregressive flow.\n    svi : bool\n        Whether to use SVI version of the mdn or not\n    \"\"\"", "\n", "\n", "if", "model", ".", "density", "==", "'mog'", ":", "\n", "        ", "return", "apt_mdn_loss_atomic_proposal", "(", "model", ",", "svi", "=", "svi", ",", "combined_loss", "=", "combined_loss", ")", "\n", "", "elif", "model", ".", "density", "==", "'maf'", ":", "\n", "        ", "assert", "not", "svi", ",", "'SVI not supported for MAFs'", "\n", "return", "apt_maf_loss_atomic_proposal", "(", "model", ",", "svi", "=", "svi", ",", "combined_loss", "=", "combined_loss", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_mdn_loss_atomic_proposal": [[328, 383], ["mdn.get_mog_tensors", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.MyLogSumExp", "delfi.utils.symbolic.MyLogSumExp", "theano.sum", "delfi.utils.symbolic.MyLogSumExp.squeeze", "delfi.utils.symbolic.MyLogSumExp.squeeze", "delfi.utils.symbolic.MyLogSumExp.squeeze", "delfi.utils.symbolic.tensorN", "trn_inputs.append", "m.dimshuffle", "zip", "zip", "delfi.utils.symbolic.MyLogSumExp().squeeze", "zip", "theano.stack", "theano.log", "theano.stack", "theano.log", "theano.mean", "theano.mean", "theano.sum", "delfi.utils.symbolic.MyLogSumExp", "dtheta.dimshuffle", "U.dimshuffle"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog_tensors", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp"], ["", "", "def", "apt_mdn_loss_atomic_proposal", "(", "mdn", ",", "svi", "=", "False", ",", "combined_loss", "=", "False", ")", ":", "\n", "    ", "\"\"\"Define loss function for training with a atomic proposal. Assumes a\n    uniform proposal distribution over each sample parameter and an externally\n    provided set of alternatives.\n\n    mdn: NeuralNet\n        Mixture density network.\n    svi : bool\n        Whether to use SVI version of the mdn or not\n    \"\"\"", "\n", "assert", "mdn", ".", "density", "==", "'mog'", "\n", "\n", "# a is mixture weights, ms are means, U^T U are precisions", "\n", "a", ",", "ms", ",", "Us", ",", "ldetUs", "=", "mdn", ".", "get_mog_tensors", "(", "svi", "=", "svi", ")", "\n", "\n", "# define symbolic variable to hold params that will be inferred", "\n", "# theta_all : (n_batch * (n_atoms + 1)  x n_outputs", "\n", "# lprs  : n_batch x (n_atoms+1)", "\n", "theta_all", "=", "tensorN", "(", "3", ",", "name", "=", "'params_nl'", ",", "dtype", "=", "dtype", ")", "# true (row 1), atoms", "\n", "lprs", "=", "tensorN", "(", "2", ",", "name", "=", "'lprs'", ",", "dtype", "=", "dtype", ")", "# log tilde_p / p", "\n", "\n", "# calculate Mahalanobis distances distances wrt U'U for every theta,x pair", "\n", "# diffs : [ n_batch x (n_atoms+1) x n_outputs for each component ]", "\n", "# Ms    : [ n_batch x (n_atoms+1)             for each component ]", "\n", "# Ms[k][n,i] = (theta[i] - m[k][n])' U[k][n]' U[k][n] (theta[i] - m[k][n])", "\n", "dthetas", "=", "[", "theta_all", "-", "m", ".", "dimshuffle", "(", "[", "0", ",", "'x'", ",", "1", "]", ")", "for", "m", "in", "ms", "]", "# theta[i] - m[k][n]", "\n", "Ms", "=", "[", "tt", ".", "sum", "(", "tt", ".", "sum", "(", "dtheta", ".", "dimshuffle", "(", "[", "0", ",", "1", ",", "'x'", ",", "2", "]", ")", "*", "U", ".", "dimshuffle", "(", "[", "0", ",", "'x'", ",", "1", ",", "2", "]", ")", ",", "\n", "axis", "=", "3", ")", "**", "2", ",", "axis", "=", "2", ")", "for", "dtheta", ",", "U", "in", "zip", "(", "dthetas", ",", "Us", ")", "]", "\n", "\n", "# compute (unnormalized) log-densities, weighted by log prior ratios", "\n", "Ms", "=", "[", "-", "0.5", "*", "M", "-", "lprs", "for", "M", "in", "Ms", "]", "\n", "\n", "# compute per-component log-densities and log-normalizers", "\n", "lprobs_comps", "=", "[", "M", "[", ":", ",", "0", "]", "+", "ldetU", "for", "M", ",", "ldetU", "in", "zip", "(", "Ms", ",", "ldetUs", ")", "]", "\n", "lZ_comps", "=", "[", "MyLogSumExp", "(", "M", ",", "axis", "=", "1", ")", ".", "squeeze", "(", ")", "+", "ldetU", "\n", "for", "M", ",", "ldetU", "in", "zip", "(", "Ms", ",", "ldetUs", ")", "]", "# sum over all proposal thetas", "\n", "\n", "# compute overall log-densities and log-normalizers across components", "\n", "lq", "=", "MyLogSumExp", "(", "tt", ".", "stack", "(", "lprobs_comps", ",", "axis", "=", "1", ")", "+", "tt", ".", "log", "(", "a", ")", ",", "axis", "=", "1", ")", "\n", "lZ", "=", "MyLogSumExp", "(", "tt", ".", "stack", "(", "lZ_comps", ",", "axis", "=", "1", ")", "+", "tt", ".", "log", "(", "a", ")", ",", "axis", "=", "1", ")", "\n", "\n", "lprobs", "=", "lq", ".", "squeeze", "(", ")", "-", "lZ", ".", "squeeze", "(", ")", "\n", "\n", "# collect the extra input variables that have to be provided for each", "\n", "# training data point", "\n", "trn_inputs", "=", "[", "theta_all", ",", "mdn", ".", "stats", ",", "lprs", "]", "\n", "if", "combined_loss", ":", "# add prior loss on prior samples", "\n", "        ", "l_ml", "=", "lq", ".", "squeeze", "(", ")", "# direct posterior evalution", "\n", "is_prior_sample", "=", "tensorN", "(", "1", ",", "name", "=", "'prop_mask'", ",", "dtype", "=", "dtype", ")", "\n", "trn_inputs", ".", "append", "(", "is_prior_sample", ")", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "lprobs", "+", "is_prior_sample", "*", "l_ml", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "-", "tt", ".", "mean", "(", "lprobs", ")", "# average over samples", "\n", "\n", "", "return", "loss", ",", "trn_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_maf_loss_atomic_proposal": [[385, 434], ["delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "delfi.utils.symbolic.tensorN", "theano.clone", "theano.clone", "theano.reshape", "theano.shape", "atomic_ppZ[].squeeze", "delfi.utils.symbolic.MyLogSumExp().squeeze", "lprobs[].squeeze", "delfi.utils.symbolic.tensorN", "trn_inputs.append", "theano.shape", "theano.mean", "theano.mean", "delfi.utils.symbolic.MyLogSumExp"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.MyLogSumExp"], ["", "def", "apt_maf_loss_atomic_proposal", "(", "net", ",", "svi", "=", "False", ",", "combined_loss", "=", "False", ")", ":", "\n", "    ", "\"\"\"Define loss function for training with a atomic proposal. Assumes a\n    uniform proposal distribution over each sample parameter and an externally\n    provided set of alternatives.\n\n    net: MAF-based conditional density net\n    svi : bool\n        Whether to use SVI version of the mdn or not\n    \"\"\"", "\n", "assert", "net", ".", "density", "==", "'maf'", "\n", "assert", "not", "svi", ",", "'SVI not supported for MAFs'", "\n", "\n", "# define symbolic variable to hold params that will be inferred", "\n", "# params : n_batch x  n_outputs", "\n", "# all_thetas : (n_batch * (n_atoms + 1)  x n_outputs", "\n", "# lprs  : (n_atoms + 1) x n_batch", "\n", "# stats :  n_batch x  n_inputs", "\n", "# x_nl  : (n_batch * (n_atoms + 1)) x n_inputs", "\n", "theta_all", "=", "tensorN", "(", "2", ",", "name", "=", "'params_nl'", ",", "dtype", "=", "dtype", ")", "\n", "x_nl", "=", "tensorN", "(", "2", ",", "name", "=", "'stats_nl'", ",", "dtype", "=", "dtype", ")", "\n", "lprs", "=", "tensorN", "(", "2", ",", "name", "=", "'lprs'", ",", "dtype", "=", "dtype", ")", "# log tilde_p / p", "\n", "\n", "n_batch", "=", "tt", ".", "shape", "(", "lprs", ")", "[", "1", "]", "\n", "n_atoms", "=", "tt", ".", "shape", "(", "lprs", ")", "[", "0", "]", "-", "1", "\n", "\n", "# compute MAF log-densities for true and other atoms", "\n", "lprobs", "=", "theano", ".", "clone", "(", "output", "=", "net", ".", "lprobs", ",", "\n", "replace", "=", "{", "net", ".", "params", ":", "theta_all", ",", "net", ".", "stats", ":", "x_nl", "}", ",", "\n", "share_inputs", "=", "True", ")", "\n", "lprobs", "=", "tt", ".", "reshape", "(", "lprobs", ",", "newshape", "=", "(", "n_atoms", "+", "1", ",", "n_batch", ")", ",", "ndim", "=", "2", ")", "\n", "\n", "# compute nonnormalized log posterior probabilities", "\n", "atomic_ppZ", "=", "lprobs", "-", "lprs", "\n", "# compute posterior probability of true params in atomic task", "\n", "atomic_pp", "=", "atomic_ppZ", "[", "0", ",", ":", "]", ".", "squeeze", "(", ")", "-", "MyLogSumExp", "(", "atomic_ppZ", ",", "axis", "=", "0", ")", ".", "squeeze", "(", ")", "\n", "\n", "# collect the extra input variables that have to be provided for each", "\n", "# training data point, and calculate the loss by averaging over samples", "\n", "trn_inputs", "=", "[", "theta_all", ",", "x_nl", ",", "lprs", "]", "\n", "if", "combined_loss", ":", "# add prior loss on prior samples", "\n", "        ", "l_ml", "=", "lprobs", "[", "0", ",", ":", "]", ".", "squeeze", "(", ")", "# direct posterior evaluation", "\n", "is_prior_sample", "=", "tensorN", "(", "1", ",", "name", "=", "'prop_mask'", ",", "dtype", "=", "dtype", ")", "\n", "trn_inputs", ".", "append", "(", "is_prior_sample", ")", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "atomic_pp", "+", "is_prior_sample", "*", "l_ml", ")", "\n", "", "else", ":", "\n", "        ", "loss", "=", "-", "tt", ".", "mean", "(", "atomic_pp", ")", "\n", "\n", "", "return", "loss", ",", "trn_inputs", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEA.SNPEA.__init__": [[14, 68], ["numpy.any", "delfi.inference.BaseInference.BaseInference.__init__", "kwargs.update", "numpy.isnan", "ValueError"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update"], ["    ", "def", "__init__", "(", "self", ",", "generator", ",", "obs", ",", "prior_norm", "=", "False", ",", "pilot_samples", "=", "100", ",", "\n", "n_components", "=", "1", ",", "reg_lambda", "=", "0.01", ",", "seed", "=", "None", ",", "verbose", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"SNPE-A\n\n        Implementation of Papamakarios & Murray (NeurIPS 2016)\n\n        Parameters\n        ----------\n        generator : generator instance\n            Generator instance\n        obs : array\n            Observation in the format the generator returns (1 x n_summary)\n        prior_norm : bool\n            If set to True, will z-transform params based on mean/std of prior\n        pilot_samples : None or int\n            If an integer is provided, a pilot run with the given number of\n            samples is run. The mean and std of the summary statistics of the\n            pilot samples will be subsequently used to z-transform summary\n            statistics.\n        n_components : int\n            Number of components in final round (PM's algorithm 2)\n        reg_lambda : float\n            Precision parameter for weight regularizer if svi is True\n        seed : int or None\n            If provided, random number generator will be seeded\n        verbose : bool\n            Controls whether or not progressbars are shown\n        kwargs : additional keyword arguments\n            Additional arguments for the NeuralNet instance, including:\n                n_hiddens : list of ints\n                    Number of hidden units per layer of the neural network\n                svi : bool\n                    Whether to use SVI version of the network or not\n\n        Attributes\n        ----------\n        observables : dict\n            Dictionary containing theano variables that can be monitored while\n            training the neural network.\n        \"\"\"", "\n", "assert", "obs", "is", "not", "None", ",", "\"CDELFI requires observed data\"", "\n", "self", ".", "obs", "=", "obs", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "self", ".", "obs", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Observed data contains NaNs\"", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "generator", ",", "prior_norm", "=", "prior_norm", ",", "\n", "pilot_samples", "=", "pilot_samples", ",", "seed", "=", "seed", ",", "\n", "verbose", "=", "verbose", ",", "**", "kwargs", ")", "\n", "\n", "# we'll use only 1 component until the last round", "\n", "kwargs", ".", "update", "(", "{", "'n_components'", ":", "1", "}", ")", "\n", "self", ".", "n_components", "=", "n_components", "\n", "\n", "self", ".", "reg_lambda", "=", "reg_lambda", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEA.SNPEA.loss": [[69, 89], ["theano.mean", "delfi.neuralnet.loss.regularizer.svi_kl_zero", "SNPEA.SNPEA.observables.update"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_zero", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update"], ["", "def", "loss", "(", "self", ",", "N", ")", ":", "\n", "        ", "\"\"\"Loss function for training\n\n        Parameters\n        ----------\n        N : int\n            Number of training samples\n        \"\"\"", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "self", ".", "network", ".", "lprobs", ")", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "kl", ",", "imvs", "=", "svi_kl_zero", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ",", "\n", "self", ".", "reg_lambda", ")", "\n", "loss", "=", "loss", "+", "1", "/", "N", "*", "kl", "\n", "\n", "# adding nodes to dict s.t. they can be monitored", "\n", "self", ".", "observables", "[", "'loss.kl'", "]", "=", "kl", "\n", "self", ".", "observables", ".", "update", "(", "imvs", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEA.SNPEA.run": [[90, 206], ["range", "SNPEA.SNPEA.gen", "delfi.neuralnet.Trainer.Trainer", "logs.append", "trn_datasets.append", "SNPEA.SNPEA.project_to_gaussian", "type", "SNPEA.SNPEA.network.params_dict.copy", "SNPEA.SNPEA.network.spec_dict.copy", "SNPEA.SNPEA.update", "delfi.neuralnet.NeuralNet.NeuralNet", "SNPEA.SNPEA.loss", "delfi.neuralnet.Trainer.Trainer.train", "posteriors.append", "SNPEA.SNPEA.predict", "re.sub", "SNPEA.SNPEA.monitor_dict_from_names", "SNPEA.SNPEA.gen_newseed", "SNPEA.SNPEA.predict", "posteriors.append", "print", "source_param_val.copy", "SNPEA.SNPEA.rng.randn"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.project_to_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict"], ["", "def", "run", "(", "self", ",", "n_train", "=", "100", ",", "n_rounds", "=", "2", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "\n", "monitor", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Run algorithm\n\n        Parameters\n        ----------\n        n_train : int or list of ints\n            Number of data points drawn per round. If a list is passed, the\n            nth list element specifies the number of training examples in the\n            nth round. If there are fewer list elements than rounds, the last\n            list element is used.\n        n_rounds : int\n            Number of rounds\n        epochs: int\n            Number of epochs used for neural network training\n        minibatch: int\n            Size of the minibatches used for neural network training\n        monitor : list of str\n            Names of variables to record during training along with the value\n            of the loss function. The observables attribute contains all\n            possible variables that can be monitored\n        kwargs : additional keyword arguments\n            Additional arguments for the Trainer instance\n\n        Returns\n        -------\n        logs : list of dicts\n            Dictionaries contain information logged while training the networks\n        trn_datasets : list of (params, stats)\n            training datasets, z-transformed\n        posteriors : list of posteriors\n            posterior after each round\n        \"\"\"", "\n", "logs", "=", "[", "]", "\n", "trn_datasets", "=", "[", "]", "\n", "posteriors", "=", "[", "]", "\n", "\n", "for", "r", "in", "range", "(", "n_rounds", ")", ":", "# start at 1", "\n", "            ", "self", ".", "round", "+=", "1", "\n", "\n", "# if round > 1, set new proposal distribution before sampling", "\n", "if", "self", ".", "round", ">", "1", ":", "\n", "# posterior becomes new proposal prior", "\n", "                ", "try", ":", "\n", "                    ", "posterior", "=", "self", ".", "predict", "(", "self", ".", "obs", ")", "\n", "", "except", ":", "\n", "                    ", "pass", "\n", "", "self", ".", "generator", ".", "proposal", "=", "posterior", ".", "project_to_gaussian", "(", ")", "\n", "# number of training examples for this round", "\n", "", "if", "type", "(", "n_train", ")", "==", "list", ":", "\n", "                ", "try", ":", "\n", "                    ", "n_train_round", "=", "n_train", "[", "self", ".", "round", "-", "1", "]", "\n", "", "except", ":", "\n", "                    ", "n_train_round", "=", "n_train", "[", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "n_train_round", "=", "n_train", "\n", "\n", "# draw training data (z-transformed params and stats)", "\n", "", "verbose", "=", "'(round {}) '", ".", "format", "(", "r", ")", "if", "self", ".", "verbose", "else", "False", "\n", "trn_data", "=", "self", ".", "gen", "(", "n_train_round", ",", "verbose", "=", "verbose", ")", "\n", "\n", "# algorithm 2 of Papamakarios and Murray", "\n", "if", "r", "+", "1", "==", "n_rounds", "and", "self", ".", "n_components", ">", "1", ":", "\n", "\n", "# get parameters of current network", "\n", "                ", "old_params", "=", "self", ".", "network", ".", "params_dict", ".", "copy", "(", ")", "\n", "\n", "# create new network", "\n", "network_spec", "=", "self", ".", "network", ".", "spec_dict", ".", "copy", "(", ")", "\n", "network_spec", ".", "update", "(", "{", "'n_components'", ":", "self", ".", "n_components", "}", ")", "\n", "self", ".", "network", "=", "NeuralNet", "(", "**", "network_spec", ")", "\n", "new_params", "=", "self", ".", "network", ".", "params_dict", "\n", "\n", "\"\"\"In order to go from 1 component in previous rounds to\n                self.n_components in the current round we will duplicate\n                component 1 self.n_components times, with small random\n                perturbations to the parameters affecting component means\n                and precisions, and the SVI s.d.s of those parameters. Set the\n                mixture coefficients to all be equal\"\"\"", "\n", "mp_param_names", "=", "[", "s", "for", "s", "in", "new_params", "if", "'means'", "in", "s", "or", "'precisions'", "in", "s", "]", "# list of dict keys", "\n", "for", "param_name", "in", "mp_param_names", ":", "\n", "                    ", "\"\"\"for each param_name, get the corresponding old parameter\n                    name/value for what was previously the only mixture\n                    component\"\"\"", "\n", "param_label", "=", "re", ".", "sub", "(", "\"\\d\"", ",", "\"\"", ",", "param_name", ")", "# removing layer counts", "\n", "source_param_name", "=", "param_label", "+", "'0'", "\n", "source_param_val", "=", "old_params", "[", "source_param_name", "]", "\n", "# copy it to the new component, add noise to break symmetry", "\n", "old_params", "[", "param_name", "]", "=", "(", "source_param_val", ".", "copy", "(", ")", "+", "1.0e-6", "*", "self", ".", "rng", ".", "randn", "(", "*", "source_param_val", ".", "shape", ")", ")", ".", "astype", "(", "dtype", ")", "\n", "\n", "# initialize with equal mixture coefficients for all data", "\n", "", "old_params", "[", "'weights.mW'", "]", "=", "(", "0.", "*", "new_params", "[", "'weights.mW'", "]", ")", ".", "astype", "(", "dtype", ")", "\n", "old_params", "[", "'weights.mb'", "]", "=", "(", "0.", "*", "new_params", "[", "'weights.mb'", "]", ")", ".", "astype", "(", "dtype", ")", "\n", "\n", "self", ".", "network", ".", "params_dict", "=", "old_params", "\n", "\n", "", "trn_inputs", "=", "[", "self", ".", "network", ".", "params", ",", "self", ".", "network", ".", "stats", "]", "\n", "\n", "t", "=", "Trainer", "(", "self", ".", "network", ",", "self", ".", "loss", "(", "N", "=", "n_train_round", ")", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "**", "kwargs", ")", "\n", "logs", ".", "append", "(", "t", ".", "train", "(", "epochs", "=", "epochs", ",", "minibatch", "=", "minibatch", ",", "\n", "verbose", "=", "verbose", ")", ")", "\n", "\n", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "try", ":", "\n", "                ", "posteriors", ".", "append", "(", "self", ".", "predict", "(", "self", ".", "obs", ")", ")", "\n", "", "except", ":", "\n", "                ", "posteriors", ".", "append", "(", "None", ")", "\n", "print", "(", "'analytic correction for proposal seemingly failed!'", ")", "\n", "pass", "\n", "\n", "", "", "return", "logs", ",", "trn_datasets", ",", "posteriors", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEA.SNPEA.predict": [[207, 234], ["super().predict", "super().predict", "super().predict.prune_negligible_components", "isinstance", "isinstance"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.prune_negligible_components"], ["", "def", "predict", "(", "self", ",", "x", ",", "threshold", "=", "0.05", ")", ":", "\n", "        ", "\"\"\"Predict posterior given x\n\n        Parameters\n        ----------\n        x : array\n            Stats for which to compute the posterior\n        \"\"\"", "\n", "if", "self", ".", "generator", ".", "proposal", "is", "None", ":", "\n", "# no correction necessary", "\n", "            ", "return", "super", "(", ")", ".", "predict", "(", "x", ")", "# via super", "\n", "", "else", ":", "\n", "# mog is posterior given proposal prior", "\n", "            ", "mog", "=", "super", "(", ")", ".", "predict", "(", "x", ")", "# via super", "\n", "\n", "mog", ".", "prune_negligible_components", "(", "threshold", "=", "threshold", ")", "\n", "\n", "# compute posterior given prior by analytical division step", "\n", "if", "isinstance", "(", "self", ".", "generator", ".", "prior", ",", "dd", ".", "Uniform", ")", ":", "\n", "                ", "posterior", "=", "mog", "/", "self", ".", "generator", ".", "proposal", "\n", "", "elif", "isinstance", "(", "self", ".", "generator", ".", "prior", ",", "dd", ".", "Gaussian", ")", ":", "\n", "                ", "posterior", "=", "(", "mog", "*", "self", ".", "generator", ".", "prior", ")", "/", "self", ".", "generator", ".", "proposal", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplemented", "\n", "\n", "", "return", "posterior", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.__init__": [[15, 79], ["numpy.asarray", "delfi.inference.BaseInference.BaseInference.__init__", "numpy.any", "APT.APT.obs.reshape", "numpy.isnan", "ValueError", "numpy.finfo"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "generator", ",", "obs", "=", "None", ",", "prior_norm", "=", "False", ",", "\n", "pilot_samples", "=", "100", ",", "reg_lambda", "=", "0.01", ",", "seed", "=", "None", ",", "verbose", "=", "True", ",", "\n", "add_prior_precision", "=", "True", ",", "Ptol", "=", "None", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"SNPE-C/APT\n\n        Implementation of Greenberg, Nonnenmacher & Macke (ICML 2019)\n\n        Parameters\n        ----------\n        generator : generator instance\n            Generator instance\n        obs : array\n            Observation in the format the generator returns (1 x n_summary)\n        prior_norm : bool\n            If set to True, will z-transform params based on mean/std of prior\n        pilot_samples : None or int\n            If an integer is provided, a pilot run with the given number of\n            samples is run. The mean and std of the summary statistics of the\n            pilot samples will be subsequently used to z-transform summary\n            statistics.\n        n_components : int\n            Number of components in final round (PM's algorithm 2)\n        reg_lambda : float\n            Precision parameter for weight regularizer if svi is True\n        seed : int or None\n            If provided, random number generator will be seeded\n        verbose : bool\n            Controls whether or not progressbars are shown\n        add_prior_precision: bool\n            Whether to add the prior precision to each posterior component for Gauss/MoG proposals\n        Ptol: float\n            Quantity added to the diagonal entries of the precision matrix for each Gaussian posterior component\n        kwargs : additional keyword arguments\n            Additional arguments for the NeuralNet instance, including:\n                n_hiddens : list of ints\n                    Number of hidden units per layer of the neural network\n                svi : bool\n                    Whether to use SVI version of the network or not\n\n        Attributes\n        ----------\n        observables : dict\n            Dictionary containing theano variables that can be monitored while\n            training the neural network.\n        \"\"\"", "\n", "assert", "obs", "is", "not", "None", ",", "\"APT requires observed data\"", "\n", "self", ".", "obs", "=", "np", ".", "asarray", "(", "obs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "generator", ",", "prior_norm", "=", "prior_norm", ",", "\n", "pilot_samples", "=", "pilot_samples", ",", "seed", "=", "seed", ",", "\n", "verbose", "=", "verbose", ",", "**", "kwargs", ")", "# initializes network", "\n", "assert", "0", "<", "self", ".", "obs", ".", "ndim", "<=", "2", "\n", "if", "self", ".", "obs", ".", "ndim", "==", "1", ":", "\n", "            ", "self", ".", "obs", "=", "self", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", "\n", "", "assert", "self", ".", "obs", ".", "shape", "[", "0", "]", "==", "1", "\n", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "self", ".", "obs", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Observed data contains NaNs\"", ")", "\n", "\n", "", "self", ".", "Ptol", "=", "np", ".", "finfo", "(", "dtype", ")", ".", "resolution", "if", "Ptol", "is", "None", "else", "Ptol", "\n", "self", ".", "add_prior_precision", "=", "add_prior_precision", "\n", "self", ".", "reg_lambda", "=", "reg_lambda", "\n", "self", ".", "exception_info", "=", "(", "None", ",", "None", ",", "None", ")", "\n", "self", ".", "trn_datasets", ",", "self", ".", "proposal_used", "=", "[", "]", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.predict": [[80, 92], ["super().predict", "delfi.MoG", "isinstance", "numpy.eye", "isinstance", "delfi.Gaussian"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict"], ["", "def", "predict", "(", "self", ",", "*", "args", ",", "**", "kwargs", ")", ":", "\n", "        ", "p", "=", "super", "(", ")", ".", "predict", "(", "*", "args", ",", "**", "kwargs", ")", "\n", "\n", "if", "self", ".", "round", ">", "0", "and", "self", ".", "proposal_used", "[", "-", "1", "]", "in", "[", "'gaussian'", ",", "'mog'", "]", ":", "\n", "            ", "assert", "self", ".", "network", ".", "density", "==", "'mog'", "and", "isinstance", "(", "p", ",", "dd", ".", "MoG", ")", "\n", "P_offset", "=", "np", ".", "eye", "(", "p", ".", "ndim", ")", "*", "self", ".", "Ptol", "\n", "# add the prior precision to each posterior component if needed", "\n", "if", "self", ".", "add_prior_precision", "and", "isinstance", "(", "self", ".", "generator", ".", "prior", ",", "dd", ".", "Gaussian", ")", ":", "\n", "                ", "P_offset", "+=", "self", ".", "generator", ".", "prior", ".", "P", "\n", "", "p", "=", "dd", ".", "MoG", "(", "a", "=", "p", ".", "a", ",", "xs", "=", "[", "dd", ".", "Gaussian", "(", "m", "=", "x", ".", "m", ",", "P", "=", "x", ".", "P", "+", "P_offset", ",", "seed", "=", "x", ".", "seed", ")", "for", "x", "in", "p", ".", "xs", "]", ")", "\n", "\n", "", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.define_loss": [[93, 155], ["isinstance", "isinstance", "prior.ztrans.ztrans.ztrans", "delfi.neuralnet.loss.lossfunc.snpe_loss_prior_as_proposal", "APT.APT.observables.update", "isinstance", "delfi.neuralnet.loss.lossfunc.apt_loss_gaussian_proposal", "delfi.neuralnet.loss.regularizer.svi_kl_init", "proposal.lower", "isinstance", "delfi.neuralnet.loss.lossfunc.apt_loss_MoG_proposal", "delfi.neuralnet.loss.regularizer.svi_kl_zero", "delfi.neuralnet.loss.lossfunc.apt_loss_atomic_proposal", "NotImplemented"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans", "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.snpe_loss_prior_as_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_loss_gaussian_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_init", "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_loss_MoG_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_zero", "home.repos.pwc.inspect_result.mackelab_delfi.loss.lossfunc.apt_loss_atomic_proposal"], ["", "def", "define_loss", "(", "self", ",", "n", ",", "round_cl", "=", "1", ",", "proposal", "=", "'gaussian'", ",", "\n", "combined_loss", "=", "False", ")", ":", "\n", "        ", "\"\"\"Loss function for training\n\n        Parameters\n        ----------\n        n : int\n            Number of training samples\n        round_cl : int\n            Round after which to start continual learning\n        proposal : str\n            Specifier for type of proposal used: continuous ('gaussian', 'mog')\n            or 'atomic' proposals are implemented.\n        combined_loss : bool\n            Whether to include prior likelihood terms in addition to atomic\n        \"\"\"", "\n", "prior", "=", "self", ".", "generator", ".", "prior", "\n", "if", "isinstance", "(", "prior", ",", "dd", ".", "Gaussian", ")", "or", "isinstance", "(", "prior", ",", "dd", ".", "MoG", ")", ":", "\n", "            ", "prior", "=", "prior", ".", "ztrans", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "\n", "", "if", "proposal", "==", "'prior'", ":", "# using prior as proposal", "\n", "            ", "loss", ",", "trn_inputs", "=", "snpe_loss_prior_as_proposal", "(", "self", ".", "network", ",", "svi", "=", "self", ".", "svi", ")", "\n", "\n", "", "elif", "proposal", "==", "'gaussian'", ":", "\n", "            ", "assert", "self", ".", "network", ".", "density", "==", "'mog'", "\n", "assert", "isinstance", "(", "self", ".", "generator", ".", "proposal", ",", "dd", ".", "Gaussian", ")", "\n", "loss", ",", "trn_inputs", "=", "apt_loss_gaussian_proposal", "(", "self", ".", "network", ",", "prior", ",", "svi", "=", "self", ".", "svi", ",", "\n", "add_prior_precision", "=", "self", ".", "add_prior_precision", ")", "\n", "", "elif", "proposal", ".", "lower", "(", ")", "==", "'mog'", ":", "\n", "            ", "assert", "self", ".", "network", ".", "density", "==", "'mog'", "\n", "assert", "isinstance", "(", "self", ".", "generator", ".", "proposal", ",", "dd", ".", "MoG", ")", "\n", "loss", ",", "trn_inputs", "=", "apt_loss_MoG_proposal", "(", "self", ".", "network", ",", "prior", ",", "svi", "=", "self", ".", "svi", ",", "\n", "add_prior_precision", "=", "self", ".", "add_prior_precision", ")", "\n", "", "elif", "proposal", "==", "'atomic'", ":", "\n", "            ", "loss", ",", "trn_inputs", "=", "apt_loss_atomic_proposal", "(", "self", ".", "network", ",", "svi", "=", "self", ".", "svi", ",", "combined_loss", "=", "combined_loss", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplemented", "(", ")", "\n", "\n", "# adding nodes to dict s.t. they can be monitored during training", "\n", "", "self", ".", "observables", "[", "'loss.lprobs'", "]", "=", "self", ".", "network", ".", "lprobs", "\n", "self", ".", "observables", "[", "'loss.raw_loss'", "]", "=", "loss", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "if", "self", ".", "round", "<=", "round_cl", ":", "\n", "# weights close to zero-centered prior in the first round", "\n", "                ", "if", "self", ".", "reg_lambda", ">", "0", ":", "\n", "                    ", "kl", ",", "imvs", "=", "svi_kl_zero", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ",", "\n", "self", ".", "reg_lambda", ")", "\n", "", "else", ":", "\n", "                    ", "kl", ",", "imvs", "=", "0", ",", "{", "}", "\n", "", "", "else", ":", "\n", "# weights close to those of previous round", "\n", "                ", "kl", ",", "imvs", "=", "svi_kl_init", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ")", "\n", "\n", "", "loss", "=", "loss", "+", "1", "/", "n", "*", "kl", "\n", "\n", "# adding nodes to dict s.t. they can be monitored", "\n", "self", ".", "observables", "[", "'loss.kl'", "]", "=", "kl", "\n", "self", ".", "observables", ".", "update", "(", "imvs", ")", "\n", "\n", "", "return", "loss", ",", "trn_inputs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run": [[156, 233], ["range", "logs.append", "trn_datasets.append", "posteriors.append", "kwargs.keys", "APT.APT.run_round", "APT.APT.predict", "kwargs.keys", "APT.APT.run_round", "print", "sys.exc_info"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_round", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_round"], ["", "def", "run", "(", "self", ",", "n_rounds", "=", "1", ",", "proposal", "=", "'gaussian'", ",", "silent_fail", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Run algorithm\n\n        Parameters\n        ----------\n        n_train : int or list of ints\n            Number of data points drawn per round. If a list is passed, the\n            nth list element specifies the number of training examples in the\n            nth round. If there are fewer list elements than rounds, the last\n            list element is used.\n        n_rounds : int\n            Number of rounds\n        proposal : str\n            Specifier for type of proposal used: continuous ('gaussian', 'mog')\n            or 'atomic' proposals are implemented.\n        epochs : int\n            Number of epochs used for neural network training\n        minibatch : int\n            Size of the minibatches used for neural network training\n        monitor : list of str\n            Names of variables to record during training along with the value\n            of the loss function. The observables attribute contains all\n            possible variables that can be monitored\n        round_cl : int\n            Round after which to start continual learning\n        stop_on_nan : bool\n            If True, will halt if NaNs in the loss are encountered\n        silent_fail : bool\n            If true, will continue without throwing an error when a round fails\n        kwargs : additional keyword arguments\n            Additional arguments for the Trainer instance\n\n        Returns\n        -------\n        logs : list of dicts\n            Dictionaries contain information logged while training the networks\n        trn_datasets : list of (params, stats)\n            training datasets, z-transformed\n        posteriors : list of distributions\n            posterior after each round\n        \"\"\"", "\n", "# support 'discrete' instead of 'atomic' for backwards compatibility", "\n", "if", "proposal", "==", "'discrete'", ":", "\n", "            ", "proposal", "=", "'atomic'", "\n", "", "elif", "proposal", "==", "'discrete_comb'", ":", "\n", "            ", "proposal", "=", "'atomic_comb'", "\n", "\n", "", "logs", "=", "[", "]", "\n", "trn_datasets", "=", "[", "]", "\n", "posteriors", "=", "[", "]", "\n", "\n", "if", "'train_on_all'", "in", "kwargs", ".", "keys", "(", ")", "and", "kwargs", "[", "'train_on_all'", "]", "is", "True", ":", "\n", "            ", "kwargs", "[", "'round_cl'", "]", "=", "np", ".", "inf", "\n", "if", "proposal", "==", "'gaussian'", "and", "self", ".", "network", ".", "n_components", ">", "1", "and", "'reuse_prior_samples'", "not", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "# prevent numerical instability (broad unused comps)", "\n", "                ", "kwargs", "[", "'reuse_prior_samples'", "]", "=", "False", "\n", "\n", "", "", "for", "r", "in", "range", "(", "n_rounds", ")", ":", "\n", "            ", "self", ".", "round", "+=", "1", "\n", "\n", "if", "silent_fail", ":", "\n", "                ", "try", ":", "\n", "                    ", "log", ",", "trn_data", "=", "self", ".", "run_round", "(", "proposal", ",", "**", "kwargs", ")", "\n", "", "except", ":", "\n", "                    ", "print", "(", "'Round {0} failed'", ".", "format", "(", "self", ".", "round", ")", ")", "\n", "import", "sys", "\n", "self", ".", "exception_info", "=", "sys", ".", "exc_info", "(", ")", "\n", "break", "\n", "", "", "else", ":", "\n", "                ", "log", ",", "trn_data", "=", "self", ".", "run_round", "(", "proposal", ",", "**", "kwargs", ")", "\n", "\n", "", "logs", ".", "append", "(", "log", ")", "\n", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "posteriors", ".", "append", "(", "self", ".", "predict", "(", "self", ".", "obs", ")", ")", "\n", "\n", "", "return", "logs", ",", "trn_datasets", ",", "posteriors", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_round": [[234, 251], ["APT.APT.proposal_used.append", "proposal.lower", "APT.APT.run_prior", "APT.APT.run_gaussian", "APT.APT.run_MoG", "APT.APT.run_atomic", "APT.APT.run_atomic", "NotImplemented"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_prior", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_MoG", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_atomic", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_atomic"], ["", "def", "run_round", "(", "self", ",", "proposal", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "\n", "        ", "proposal", "=", "proposal", ".", "lower", "(", ")", "if", "self", ".", "round", ">", "1", "else", "'prior'", "\n", "self", ".", "proposal_used", ".", "append", "(", "proposal", ")", "\n", "\n", "if", "proposal", "==", "'prior'", "or", "self", ".", "round", "==", "1", ":", "\n", "            ", "return", "self", ".", "run_prior", "(", "**", "kwargs", ")", "\n", "", "elif", "proposal", "==", "'gaussian'", ":", "\n", "            ", "return", "self", ".", "run_gaussian", "(", "**", "kwargs", ")", "\n", "", "elif", "proposal", "==", "'mog'", ":", "\n", "            ", "return", "self", ".", "run_MoG", "(", "**", "kwargs", ")", "\n", "", "elif", "proposal", "==", "'atomic'", ":", "\n", "            ", "return", "self", ".", "run_atomic", "(", "combined_loss", "=", "False", ",", "**", "kwargs", ")", "\n", "", "elif", "proposal", "==", "'atomic_comb'", ":", "\n", "            ", "return", "self", ".", "run_atomic", "(", "combined_loss", "=", "True", ",", "**", "kwargs", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplemented", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_prior": [[252, 284], ["APT.APT.gen", "APT.APT.trn_datasets.append", "APT.APT.define_loss", "delfi.neuralnet.Trainer.Trainer", "delfi.neuralnet.Trainer.Trainer.train", "delfi.utils.data.combine_trn_datasets", "APT.APT.gen_newseed", "APT.APT.monitor_dict_from_names", "APT.APT.epochs_round", "enumerate"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.define_loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.combine_trn_datasets", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.epochs_round"], ["", "", "def", "run_prior", "(", "self", ",", "n_train", "=", "100", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "n_atoms", "=", "None", ",", "\n", "moo", "=", "None", ",", "train_on_all", "=", "False", ",", "round_cl", "=", "1", ",", "stop_on_nan", "=", "False", ",", "\n", "monitor", "=", "None", ",", "verbose", "=", "False", ",", "print_each_epoch", "=", "False", ",", "\n", "patience", "=", "20", ",", "monitor_every", "=", "None", ",", "reuse_prior_samples", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "\n", "# simulate data", "\n", "        ", "self", ".", "generator", ".", "proposal", "=", "self", ".", "generator", ".", "prior", "\n", "trn_data", ",", "n_train_round", "=", "self", ".", "gen", "(", "n_train", ")", "\n", "self", ".", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "\n", "if", "train_on_all", "and", "reuse_prior_samples", ":", "\n", "            ", "prior_datasets", "=", "[", "d", "for", "i", ",", "d", "in", "enumerate", "(", "self", ".", "trn_datasets", ")", "\n", "if", "self", ".", "proposal_used", "[", "i", "]", "==", "'prior'", "]", "\n", "trn_data", "=", "combine_trn_datasets", "(", "prior_datasets", ")", "\n", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# train network", "\n", "", "self", ".", "loss", ",", "trn_inputs", "=", "self", ".", "define_loss", "(", "n", "=", "n_train_round", ",", "\n", "round_cl", "=", "round_cl", ",", "\n", "proposal", "=", "'prior'", ")", "\n", "t", "=", "Trainer", "(", "self", ".", "network", ",", "\n", "self", ".", "loss", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "**", "kwargs", ")", "\n", "log", "=", "t", ".", "train", "(", "epochs", "=", "self", ".", "epochs_round", "(", "epochs", ")", ",", "minibatch", "=", "minibatch", ",", "\n", "verbose", "=", "verbose", ",", "print_each_epoch", "=", "print_each_epoch", ",", "\n", "stop_on_nan", "=", "stop_on_nan", ",", "patience", "=", "patience", ",", "monitor_every", "=", "monitor_every", ")", "\n", "\n", "return", "log", ",", "trn_data", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_gaussian": [[285, 344], ["APT.APT.set_proposal", "isinstance", "APT.APT.generator.proposal.ztrans", "APT.APT.gen", "numpy.expand_dims().repeat", "numpy.expand_dims().repeat", "APT.APT.trn_datasets.append", "APT.APT.define_loss", "delfi.neuralnet.Trainer.Trainer", "delfi.neuralnet.Trainer.Trainer.train", "enumerate", "delfi.utils.data.combine_trn_datasets", "numpy.expand_dims", "numpy.expand_dims", "isinstance", "numpy.expand_dims().repeat", "numpy.expand_dims().repeat", "prev_datasets.append", "APT.APT.gen_newseed", "APT.APT.monitor_dict_from_names", "APT.APT.epochs_round", "prev_datasets.append", "APT.APT.generator.prior.ztrans", "isinstance", "numpy.zeros", "numpy.zeros", "numpy.expand_dims", "numpy.expand_dims"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.set_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.define_loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.combine_trn_datasets", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.epochs_round", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans"], ["", "def", "run_gaussian", "(", "self", ",", "n_train", "=", "100", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "n_atoms", "=", "None", ",", "moo", "=", "None", ",", "train_on_all", "=", "False", ",", "\n", "round_cl", "=", "1", ",", "stop_on_nan", "=", "False", ",", "monitor", "=", "None", ",", "verbose", "=", "False", ",", "print_each_epoch", "=", "False", ",", "\n", "patience", "=", "20", ",", "monitor_every", "=", "None", ",", "\n", "reuse_prior_samples", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "\n", "# simulate data", "\n", "        ", "self", ".", "set_proposal", "(", "project_to_gaussian", "=", "True", ")", "\n", "assert", "isinstance", "(", "self", ".", "generator", ".", "proposal", ",", "dd", ".", "Gaussian", ")", "\n", "prop", "=", "self", ".", "generator", ".", "proposal", ".", "ztrans", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "\n", "trn_data", ",", "n_train_round", "=", "self", ".", "gen", "(", "n_train", ")", "\n", "\n", "prop_m", "=", "np", ".", "expand_dims", "(", "prop", ".", "m", ",", "0", ")", ".", "repeat", "(", "n_train_round", ",", "axis", "=", "0", ")", "\n", "prop_P", "=", "np", ".", "expand_dims", "(", "prop", ".", "P", ",", "0", ")", ".", "repeat", "(", "n_train_round", ",", "axis", "=", "0", ")", "\n", "trn_data", "=", "(", "*", "trn_data", ",", "prop_m", ",", "prop_P", ")", "\n", "self", ".", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "\n", "if", "train_on_all", ":", "\n", "            ", "prev_datasets", "=", "[", "]", "\n", "for", "i", ",", "d", "in", "enumerate", "(", "self", ".", "trn_datasets", ")", ":", "\n", "                ", "if", "self", ".", "proposal_used", "[", "i", "]", "==", "'gaussian'", ":", "\n", "                    ", "prev_datasets", ".", "append", "(", "d", ")", "\n", "continue", "\n", "", "elif", "self", ".", "proposal_used", "[", "i", "]", "!=", "'prior'", "or", "not", "reuse_prior_samples", ":", "\n", "                    ", "continue", "\n", "# prior samples. the Gauss loss will reduce to the prior loss", "\n", "", "if", "isinstance", "(", "self", ".", "generator", ".", "prior", ",", "dd", ".", "Gaussian", ")", ":", "\n", "                    ", "prior", "=", "self", ".", "generator", ".", "prior", ".", "ztrans", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "prop_m", "=", "prior", ".", "mean", "\n", "prop_P", "=", "prior", ".", "P", "\n", "", "elif", "isinstance", "(", "self", ".", "generator", ".", "prior", ",", "dd", ".", "Uniform", ")", ":", "\n", "# model a uniform as an zero-precision Gaussian:", "\n", "                    ", "prop_m", "=", "np", ".", "zeros", "(", "self", ".", "generator", ".", "prior", ".", "ndim", ",", "dtype", ")", "\n", "prop_P", "=", "np", ".", "zeros", "(", "(", "self", ".", "generator", ".", "prior", ".", "ndim", ",", "self", ".", "generator", ".", "prior", ".", "ndim", ")", ",", "dtype", ")", "\n", "", "else", ":", "# can't reuse prior samples unless prior is uniform or Gaussian", "\n", "                    ", "continue", "\n", "", "prop_m", "=", "np", ".", "expand_dims", "(", "prop_m", ",", "0", ")", ".", "repeat", "(", "d", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "prop_P", "=", "np", ".", "expand_dims", "(", "prop_P", ",", "0", ")", ".", "repeat", "(", "d", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "axis", "=", "0", ")", "\n", "prev_datasets", ".", "append", "(", "(", "*", "d", ",", "prop_m", ",", "prop_P", ")", ")", "\n", "\n", "", "trn_data", "=", "combine_trn_datasets", "(", "prev_datasets", ")", "\n", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# train network", "\n", "", "self", ".", "loss", ",", "trn_inputs", "=", "self", ".", "define_loss", "(", "n", "=", "n_train_round", ",", "\n", "round_cl", "=", "round_cl", ",", "\n", "proposal", "=", "'gaussian'", ")", "\n", "t", "=", "Trainer", "(", "self", ".", "network", ",", "\n", "self", ".", "loss", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "**", "kwargs", ")", "\n", "\n", "log", "=", "t", ".", "train", "(", "epochs", "=", "self", ".", "epochs_round", "(", "epochs", ")", ",", "minibatch", "=", "minibatch", ",", "verbose", "=", "verbose", ",", "\n", "print_each_epoch", "=", "print_each_epoch", ",", "stop_on_nan", "=", "stop_on_nan", ",", "\n", "patience", "=", "patience", ",", "monitor_every", "=", "monitor_every", ")", "\n", "\n", "return", "log", ",", "trn_data", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_MoG": [[345, 397], ["APT.APT.set_proposal", "isinstance", "APT.APT.generator.proposal.ztrans", "APT.APT.gen", "APT.APT.trn_datasets.append", "APT.APT.define_loss", "delfi.neuralnet.Trainer.Trainer", "delfi.neuralnet.Trainer.Trainer.train", "enumerate", "delfi.utils.data.combine_trn_datasets", "APT.MoG_prop_APT_training_vars", "APT.APT.gen_newseed", "APT.APT.monitor_dict_from_names", "APT.APT.epochs_round", "prev_datasets.append", "prev_datasets.append", "isinstance", "prior.ztrans.ztrans.ztrans", "delfi.Gaussian", "prev_datasets.append", "APT.MoG_prop_APT_training_vars", "numpy.diff().any", "numpy.diff().any", "APT.MoG_prop_APT_training_vars", "numpy.diff", "numpy.diff"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.set_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.define_loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.combine_trn_datasets", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.MoG_prop_APT_training_vars", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.epochs_round", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.MoG_prop_APT_training_vars", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.MoG_prop_APT_training_vars"], ["", "def", "run_MoG", "(", "self", ",", "n_train", "=", "100", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "n_atoms", "=", "None", ",", "moo", "=", "None", ",", "train_on_all", "=", "False", ",", "round_cl", "=", "1", ",", "\n", "stop_on_nan", "=", "False", ",", "monitor", "=", "None", ",", "verbose", "=", "False", ",", "print_each_epoch", "=", "False", ",", "reuse_prior_samples", "=", "True", ",", "\n", "patience", "=", "20", ",", "monitor_every", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "\n", "# simulate data", "\n", "        ", "self", ".", "set_proposal", "(", "project_to_gaussian", "=", "False", ")", "\n", "assert", "isinstance", "(", "self", ".", "generator", ".", "proposal", ",", "dd", ".", "MoG", ")", "\n", "prop", "=", "self", ".", "generator", ".", "proposal", ".", "ztrans", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "\n", "trn_data", ",", "n_train_round", "=", "self", ".", "gen", "(", "n_train", ")", "\n", "trn_data", "=", "(", "*", "trn_data", ",", "*", "MoG_prop_APT_training_vars", "(", "prop", ",", "n_train_round", ",", "prop", ".", "n_components", ")", ")", "\n", "\n", "self", ".", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "\n", "if", "train_on_all", ":", "\n", "            ", "prev_datasets", "=", "[", "]", "\n", "for", "i", ",", "d", "in", "enumerate", "(", "self", ".", "trn_datasets", ")", ":", "\n", "                ", "if", "self", ".", "proposal_used", "[", "i", "]", "==", "'mog'", ":", "\n", "                    ", "prev_datasets", ".", "append", "(", "d", ")", "\n", "", "elif", "self", ".", "proposal_used", "==", "'prior'", "and", "reuse_prior_samples", ":", "\n", "                    ", "prior", "=", "self", ".", "generator", ".", "prior", "\n", "if", "not", "isinstance", "(", "prior", ",", "dd", ".", "Uniform", ")", ":", "\n", "                        ", "prior", "=", "prior", ".", "ztrans", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "", "d", "=", "(", "*", "d", ",", "*", "MoG_prop_APT_training_vars", "(", "prior", ",", "n_train_round", ")", ")", "\n", "prev_datasets", ".", "append", "(", "d", ")", "\n", "", "elif", "self", ".", "proposal_used", "[", "i", "]", "==", "'gaussian'", ":", "\n", "                    ", "params", ",", "stats", ",", "prop_m", ",", "prop_P", "=", "d", "\n", "if", "np", ".", "diff", "(", "prop_m", ",", "axis", "=", "0", ")", ".", "any", "(", ")", "or", "np", ".", "diff", "(", "prop_P", ",", "axis", "=", "0", ")", ".", "any", "(", ")", ":", "\n", "                        ", "continue", "# reusing samples with proposals that changed within a round is not yet supported", "\n", "", "prop", "=", "dd", ".", "Gaussian", "(", "m", "=", "prop_m", "[", "0", "]", ",", "P", "=", "prop_P", "[", "0", "]", ")", "\n", "d", "=", "(", "params", ",", "stats", ",", "*", "MoG_prop_APT_training_vars", "(", "prop", ",", "n_train_round", ")", ")", "\n", "prev_datasets", ".", "append", "(", "d", ")", "\n", "", "else", ":", "# can't re-use samples from this proposal", "\n", "                    ", "continue", "\n", "\n", "", "", "trn_data", "=", "combine_trn_datasets", "(", "prev_datasets", ")", "\n", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "", "self", ".", "loss", ",", "trn_inputs", "=", "self", ".", "define_loss", "(", "n", "=", "n_train_round", ",", "round_cl", "=", "round_cl", ",", "proposal", "=", "'mog'", ")", "\n", "\n", "t", "=", "Trainer", "(", "self", ".", "network", ",", "\n", "self", ".", "loss", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "**", "kwargs", ")", "\n", "\n", "log", "=", "t", ".", "train", "(", "epochs", "=", "self", ".", "epochs_round", "(", "epochs", ")", ",", "minibatch", "=", "minibatch", ",", "verbose", "=", "verbose", ",", "\n", "print_each_epoch", "=", "print_each_epoch", ",", "stop_on_nan", "=", "stop_on_nan", ",", "\n", "patience", "=", "patience", ",", "monitor_every", "=", "monitor_every", ")", "\n", "\n", "return", "log", ",", "trn_data", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.run_atomic": [[398, 450], ["APT.APT.set_proposal", "APT.APT.gen", "APT.APT.trn_datasets.append", "APT.APT.define_loss", "delfi.neuralnet.Trainer.ActiveTrainer", "delfi.neuralnet.Trainer.ActiveTrainer.train", "numpy.all", "numpy.all", "theano.config.device.startswith", "numpy.minimum", "delfi.utils.data.combine_trn_datasets", "delfi.utils.data.combine_trn_datasets", "APT.APT.gen_newseed", "APT.APT.monitor_dict_from_names", "APT.APT.epochs_round", "numpy.concatenate", "numpy.ones", "zip", "zip"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.set_proposal", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.define_loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.combine_trn_datasets", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.combine_trn_datasets", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.epochs_round"], ["", "def", "run_atomic", "(", "self", ",", "n_train", "=", "100", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "n_atoms", "=", "10", ",", "moo", "=", "'resample'", ",", "train_on_all", "=", "False", ",", "\n", "reuse_prior_samples", "=", "True", ",", "combined_loss", "=", "False", ",", "round_cl", "=", "1", ",", "stop_on_nan", "=", "False", ",", "monitor", "=", "None", ",", "\n", "patience", "=", "20", ",", "monitor_every", "=", "None", ",", "\n", "verbose", "=", "False", ",", "print_each_epoch", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "\n", "# activetrainer doesn't de-norm params before evaluating the prior", "\n", "        ", "assert", "np", ".", "all", "(", "self", ".", "params_mean", "==", "0.0", ")", "and", "np", ".", "all", "(", "self", ".", "params_std", "==", "1.0", ")", ",", "\"prior_norm + atomic not supported\"", "\n", "\n", "assert", "minibatch", ">", "1", ",", "\"minimum minibatch size 2 for atomic proposals\"", "\n", "if", "n_atoms", "is", "None", ":", "\n", "            ", "n_atoms", "=", "minibatch", "-", "1", "if", "theano", ".", "config", ".", "device", ".", "startswith", "(", "'cuda'", ")", "else", "np", ".", "minimum", "(", "minibatch", "-", "1", ",", "9", ")", "\n", "", "assert", "n_atoms", "<", "minibatch", ",", "\"Minibatch too small for this many atoms\"", "\n", "# simulate data", "\n", "self", ".", "set_proposal", "(", ")", "\n", "trn_data", ",", "n_train_round", "=", "self", ".", "gen", "(", "n_train", ")", "\n", "self", ".", "trn_datasets", ".", "append", "(", "trn_data", ")", "# don't store prior_masks", "\n", "\n", "if", "train_on_all", ":", "\n", "            ", "if", "reuse_prior_samples", ":", "\n", "                ", "trn_data", "=", "combine_trn_datasets", "(", "self", ".", "trn_datasets", ",", "max_inputs", "=", "2", ")", "\n", "", "else", ":", "\n", "                ", "trn_data", "=", "combine_trn_datasets", "(", "\n", "[", "td", "for", "td", ",", "pu", "in", "zip", "(", "self", ".", "trn_datasets", ",", "self", ".", "proposal_used", ")", "if", "pu", "!=", "'prior'", "]", ")", "\n", "", "if", "combined_loss", ":", "\n", "                ", "prior_masks", "=", "[", "np", ".", "ones", "(", "td", "[", "0", "]", ".", "shape", "[", "0", "]", ",", "dtype", ")", "*", "(", "pu", "==", "'prior'", ")", "\n", "for", "td", ",", "pu", "in", "zip", "(", "self", ".", "trn_datasets", ",", "self", ".", "proposal_used", ")", "]", "\n", "trn_data", "=", "(", "*", "trn_data", ",", "np", ".", "concatenate", "(", "prior_masks", ")", ")", "\n", "", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# train network", "\n", "", "self", ".", "loss", ",", "trn_inputs", "=", "self", ".", "define_loss", "(", "n", "=", "n_train_round", ",", "\n", "round_cl", "=", "round_cl", ",", "\n", "proposal", "=", "'atomic'", ",", "\n", "combined_loss", "=", "combined_loss", "and", "train_on_all", ")", "\n", "\n", "t", "=", "ActiveTrainer", "(", "self", ".", "network", ",", "\n", "self", ".", "loss", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "generator", "=", "self", ".", "generator", ",", "\n", "n_atoms", "=", "n_atoms", ",", "\n", "moo", "=", "moo", ",", "\n", "obs", "=", "(", "self", ".", "obs", "-", "self", ".", "stats_mean", ")", "/", "self", ".", "stats_std", ",", "\n", "**", "kwargs", ")", "\n", "\n", "log", "=", "t", ".", "train", "(", "epochs", "=", "self", ".", "epochs_round", "(", "epochs", ")", ",", "minibatch", "=", "minibatch", ",", "verbose", "=", "verbose", ",", "\n", "print_each_epoch", "=", "print_each_epoch", ",", "strict_batch_size", "=", "True", ",", "\n", "patience", "=", "patience", ",", "monitor_every", "=", "monitor_every", ")", "\n", "\n", "return", "log", ",", "trn_data", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.set_proposal": [[451, 463], ["APT.APT.predict", "posterior.project_to_gaussian.project_to_gaussian.project_to_gaussian"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.project_to_gaussian"], ["", "def", "set_proposal", "(", "self", ",", "project_to_gaussian", "=", "False", ")", ":", "\n", "# posterior estimate becomes new proposal prior", "\n", "        ", "if", "self", ".", "round", "==", "0", ":", "\n", "            ", "return", "None", "\n", "\n", "", "posterior", "=", "self", ".", "predict", "(", "self", ".", "obs", ")", "\n", "\n", "if", "project_to_gaussian", ":", "\n", "            ", "assert", "self", ".", "network", ".", "density", "==", "'mog'", ",", "\"cannot project a MAF\"", "\n", "posterior", "=", "posterior", ".", "project_to_gaussian", "(", ")", "\n", "\n", "", "self", ".", "generator", ".", "proposal", "=", "posterior", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.gen": [[464, 491], ["APT.APT.n_train_round", "super().gen", "kwargs.keys"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.n_train_round", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "gen", "(", "self", ",", "n_train", ",", "project_to_gaussian", "=", "False", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Generate from generator and z-transform\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate\n        n_reps : int\n            Number of repeats per parameter\n        verbose : None or bool or str\n            If None is passed, will default to self.verbose\n        project_to_gaussian: bool\n            Whether to always return Gaussian objects (instead of MoG)\n        n_train: int\n            Number of training samples\n        \"\"\"", "\n", "if", "'verbose'", "in", "kwargs", ".", "keys", "(", ")", ":", "\n", "            ", "verbose", "=", "kwargs", "[", "'verbose'", "]", "\n", "", "else", ":", "\n", "            ", "verbose", "=", "self", ".", "verbose", "\n", "", "verbose", "=", "'(round {}) '", ".", "format", "(", "self", ".", "round", ")", "if", "verbose", "else", "False", "\n", "n_train_round", "=", "self", ".", "n_train_round", "(", "n_train", ")", "\n", "\n", "trn_data", "=", "super", "(", ")", ".", "gen", "(", "n_train_round", ",", "verbose", "=", "verbose", ",", "**", "kwargs", ")", "\n", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "# may have decreased (rejection)", "\n", "\n", "return", "trn_data", ",", "n_train_round", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.n_train_round": [[492, 503], ["type"], "methods", ["None"], ["", "def", "n_train_round", "(", "self", ",", "n_train", ")", ":", "\n", "# number of training examples for this round", "\n", "        ", "if", "type", "(", "n_train", ")", "==", "list", ":", "\n", "            ", "try", ":", "\n", "                ", "n_train_round", "=", "n_train", "[", "self", ".", "round", "-", "1", "]", "\n", "", "except", ":", "\n", "                ", "n_train_round", "=", "n_train", "[", "-", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "n_train_round", "=", "n_train", "\n", "\n", "", "return", "n_train_round", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.epochs_round": [[504, 515], ["type"], "methods", ["None"], ["", "def", "epochs_round", "(", "self", ",", "epochs", ")", ":", "\n", "# number of training examples for this round", "\n", "        ", "if", "type", "(", "epochs", ")", "==", "list", ":", "\n", "            ", "try", ":", "\n", "                ", "epochs_round", "=", "epochs", "[", "self", ".", "round", "-", "1", "]", "\n", "", "except", ":", "\n", "                ", "epochs_round", "=", "epochs", "[", "-", "1", "]", "\n", "", "", "else", ":", "\n", "            ", "epochs_round", "=", "epochs", "\n", "\n", "", "return", "epochs_round", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.APT.reset": [[516, 519], ["super().reset"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset"], ["", "def", "reset", "(", "self", ",", "seed", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "reset", "(", "seed", "=", "seed", ")", "\n", "self", ".", "trn_datasets", ",", "self", ".", "proposal_used", "=", "[", "]", ",", "[", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.APT.MoG_prop_APT_training_vars": [[521, 543], ["isinstance", "isinstance", "isinstance", "delfi.utils.data.repnewax", "delfi.utils.data.repnewax", "delfi.utils.data.repnewax", "delfi.utils.data.repnewax", "delfi.utils.data.repnewax", "numpy.zeros", "numpy.zeros", "numpy.zeros", "numpy.full", "numpy.zeros", "delfi.MoG", "delfi.MoG", "numpy.stack", "numpy.stack", "numpy.stack", "numpy.log", "numpy.stack", "numpy.log", "numpy.ones", "numpy.sum", "numpy.ones", "range"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.data.repnewax", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.repnewax", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.repnewax", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.repnewax", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.repnewax", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "", "def", "MoG_prop_APT_training_vars", "(", "prop", ",", "n_train_round", ",", "n_components", ")", ":", "\n", "    ", "if", "isinstance", "(", "prop", ",", "dd", ".", "Uniform", ")", ":", "\n", "        ", "prop_Pms", "=", "np", ".", "zeros", "(", "(", "n_train_round", ",", "n_components", ",", "prop", ".", "ndim", ")", ")", "\n", "prop_Ps", "=", "np", ".", "zeros", "(", "(", "n_train_round", ",", "n_components", ",", "prop", ".", "ndim", ",", "prop", ".", "ndim", ")", ")", "\n", "prop_ldetPs", "=", "np", ".", "zeros", "(", "n_train_round", ",", "n_components", ")", "\n", "prop_las", "=", "np", ".", "full", "(", "(", "n_train_round", ",", "n_components", ")", ",", "np", ".", "log", "(", "1.0", "/", "n_components", ")", ")", "\n", "prop_QFs", "=", "np", ".", "zeros", "(", "n_train_round", ",", "n_components", ")", "\n", "return", "prop_Pms", ",", "prop_Ps", ",", "prop_ldetPs", ",", "prop_las", ",", "prop_QFs", "\n", "\n", "", "if", "isinstance", "(", "prop", ",", "dd", ".", "Gaussian", ")", ":", "\n", "        ", "prop", "=", "dd", ".", "MoG", "(", "a", "=", "np", ".", "ones", "(", "1", ")", ",", "xs", "=", "[", "prop", "]", ")", "\n", "", "assert", "isinstance", "(", "prop", ",", "dd", ".", "MoG", ")", ",", "\"input must be Gaussian, Uniform or MoG\"", "\n", "if", "prop", ".", "n_components", "==", "1", ":", "\n", "        ", "prop", "=", "dd", ".", "MoG", "(", "a", "=", "np", ".", "ones", "(", "n_components", ")", "/", "n_components", ",", "xs", "=", "[", "prop", ".", "xs", "[", "0", "]", "for", "_", "in", "range", "(", "n_components", ")", "]", ")", "\n", "\n", "", "assert", "prop", ".", "n_components", "==", "n_components", ",", "\"invalid number of components\"", "\n", "prop_Pms", "=", "repnewax", "(", "np", ".", "stack", "(", "[", "x", ".", "Pm", "for", "x", "in", "prop", ".", "xs", "]", ",", "axis", "=", "0", ")", ",", "n_train_round", ")", "\n", "prop_Ps", "=", "repnewax", "(", "np", ".", "stack", "(", "[", "x", ".", "P", "for", "x", "in", "prop", ".", "xs", "]", ",", "axis", "=", "0", ")", ",", "n_train_round", ")", "\n", "prop_ldetPs", "=", "repnewax", "(", "np", ".", "stack", "(", "[", "x", ".", "logdetP", "for", "x", "in", "prop", ".", "xs", "]", ",", "axis", "=", "0", ")", ",", "n_train_round", ")", "\n", "prop_las", "=", "repnewax", "(", "np", ".", "log", "(", "prop", ".", "a", ")", ",", "n_train_round", ")", "\n", "prop_QFs", "=", "repnewax", "(", "np", ".", "stack", "(", "[", "np", ".", "sum", "(", "x", ".", "Pm", "*", "x", ".", "m", ")", "for", "x", "in", "prop", ".", "xs", "]", ",", "axis", "=", "0", ")", ",", "n_train_round", ")", "\n", "return", "prop_Pms", ",", "prop_Ps", ",", "prop_ldetPs", ",", "prop_las", ",", "prop_QFs", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.__init__": [[13, 97], ["kwargs.update", "BaseInference.BaseInference.pilot_run", "BaseInference.BaseInference.reinit_network", "BaseInference.BaseInference.compile_observables", "numpy.random.RandomState", "numpy.random.RandomState", "type", "generator.gen", "numpy.zeros", "numpy.ones", "BaseInference.BaseInference.gen_newseed", "kwargs.keys", "numpy.any", "numpy.any", "numpy.isnan", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.pilot_run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reinit_network", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.compile_observables", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["    ", "def", "__init__", "(", "self", ",", "generator", ",", "\n", "prior_norm", "=", "True", ",", "init_norm", "=", "False", ",", "\n", "pilot_samples", "=", "100", ",", "\n", "seed", "=", "None", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Abstract base class for inference algorithms\n\n        Inference algorithms must at least implement abstract methods of this\n        class.\n\n        Parameters\n        ----------\n        generator : generator instance\n            Generator instance\n        prior_norm : bool\n            If set to True, will z-transform params based on mean/std of prior\n        pilot_samples : None or int or tuple\n            If an integer is provided, a pilot run with the given number of\n            samples is run. The mean and std of the summary statistics of the\n            pilot samples will be subsequently used to z-transform summary\n            statistics.\n            If an tuple of the form (params, stats) is provided, these will be\n            used directly as samples from the prior.\n        seed : int or None\n            If provided, random number generator will be seeded\n        kwargs : additional keyword arguments\n            Additional arguments used when creating the NeuralNet instance\n\n        Attributes\n        ----------\n        observables : dict\n            Dictionary containing theano variables that can be monitored while\n            training the neural network.\n        \"\"\"", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "", "self", ".", "verbose", "=", "verbose", "\n", "\n", "# bind generator, reset proposal attribute", "\n", "self", ".", "generator", "=", "generator", "\n", "self", ".", "generator", ".", "proposal", "=", "None", "\n", "\n", "# get input and output dimensions", "\n", "if", "type", "(", "pilot_samples", ")", "is", "tuple", ":", "\n", "            ", "params", ",", "stats", "=", "pilot_samples", "[", "0", "]", ",", "pilot_samples", "[", "1", "]", "\n", "", "else", ":", "\n", "            ", "params", ",", "stats", "=", "generator", ".", "gen", "(", "1", ",", "skip_feedback", "=", "True", ",", "verbose", "=", "False", ")", "\n", "", "assert", "stats", ".", "ndim", "==", "2", ",", "\"invalid summary stats\"", "\n", "kwargs", ".", "update", "(", "{", "'n_inputs'", ":", "stats", ".", "shape", "[", "1", "]", ",", "\n", "'n_outputs'", ":", "params", ".", "shape", "[", "1", "]", ",", "\n", "'seed'", ":", "self", ".", "gen_newseed", "(", ")", "}", ")", "\n", "\n", "self", ".", "kwargs", "=", "kwargs", "\n", "\n", "# optional: z-transform output for obs (also re-centres x onto obs!)", "\n", "self", ".", "init_norm", "=", "init_norm", "\n", "if", "'n_components'", "in", "kwargs", ".", "keys", "(", ")", "and", "kwargs", "[", "'n_components'", "]", ">", "1", ":", "\n", "            ", "self", ".", "init_fcv", "=", "0.8", "\n", "", "else", ":", "\n", "            ", "self", ".", "init_fcv", "=", "0.0", "\n", "\n", "# parameters for z-transform of params", "\n", "", "if", "prior_norm", ":", "\n", "# z-transform for params based on prior", "\n", "            ", "self", ".", "params_mean", "=", "self", ".", "generator", ".", "prior", ".", "mean", "\n", "self", ".", "params_std", "=", "self", ".", "generator", ".", "prior", ".", "std", "\n", "assert", "not", "np", ".", "any", "(", "np", ".", "isnan", "(", "self", ".", "params_mean", ")", ")", "and", "not", "np", ".", "any", "(", "np", ".", "isnan", "(", "self", ".", "params_std", ")", ")", "and", "self", ".", "params_mean", "is", "not", "None", "and", "self", ".", "params_std", "is", "not", "None", "\n", "", "else", ":", "\n", "# parameters are set such that z-transform has no effect", "\n", "            ", "self", ".", "params_mean", "=", "np", ".", "zeros", "(", "(", "params", ".", "shape", "[", "1", "]", ",", ")", ")", "\n", "self", ".", "params_std", "=", "np", ".", "ones", "(", "(", "params", ".", "shape", "[", "1", "]", ",", ")", ")", "\n", "\n", "", "self", ".", "pilot_run", "(", "pilot_samples", ",", "stats", ".", "shape", "[", "1", "]", ")", "\n", "\n", "self", ".", "reinit_network", "(", ")", "# init network, then update self.kwargs['seed']", "\n", "\n", "# observables contains vars that can be monitored during training", "\n", "self", ".", "compile_observables", "(", ")", "\n", "self", ".", "round", "=", "0", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.loss": [[98, 101], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "loss", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.run": [[102, 105], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "run", "(", "self", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.run_repeated": [[106, 146], ["range", "range", "BaseInference.BaseInference.gen_newseed", "BaseInference.BaseInference.reset", "BaseInference.BaseInference.run", "posteriors.append", "repeat_index.append", "BaseInference.BaseInference.generator.reseed", "outputs.append", "outputs.append", "callback"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed"], ["", "def", "run_repeated", "(", "self", ",", "n_repeats", "=", "10", ",", "n_NN_inits_per_repeat", "=", "1", ",", "\n", "callback", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Repeatedly run the method and collect results. Optionally, carry out\n        several runs with the same initial generator RNG state but different\n        neural network initializations.\n\n        parameters\n        ----------\n        n_repeats : int\n            Number of times to run the algorithm\n        n_NN_inits : int\n            Number of times to\n        callback: function\n            callback function that will be called after each run. It should\n            take 4 inputs: callback(log, train_data, posterior, self)\n        kwargs : additional keyword arguments\n            Additional arguments that will be passed to the run() method\n        \"\"\"", "\n", "posteriors", ",", "outputs", ",", "repeat_index", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "r", "in", "range", "(", "n_repeats", ")", ":", "\n", "\n", "            ", "if", "n_NN_inits_per_repeat", ">", "1", ":", "\n", "                ", "generator_seed", "=", "self", ".", "gen_newseed", "(", ")", "\n", "\n", "", "for", "i", "in", "range", "(", "n_NN_inits_per_repeat", ")", ":", "\n", "\n", "                ", "self", ".", "reset", "(", ")", "\n", "if", "n_NN_inits_per_repeat", ">", "1", ":", "\n", "                    ", "self", ".", "generator", ".", "reseed", "(", "generator_seed", ")", "\n", "\n", "", "log", ",", "train_data", ",", "posterior", "=", "self", ".", "run", "(", "**", "kwargs", ")", "\n", "\n", "if", "callback", "is", "not", "None", ":", "\n", "                    ", "outputs", ".", "append", "(", "callback", "(", "log", ",", "train_data", ",", "posterior", ",", "self", ")", ")", "\n", "", "else", ":", "\n", "                    ", "outputs", ".", "append", "(", "None", ")", "\n", "", "posteriors", ".", "append", "(", "posterior", ")", "\n", "repeat_index", ".", "append", "(", "r", ")", "\n", "\n", "", "", "return", "posteriors", ",", "outputs", ",", "repeat_index", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reinit_network": [[147, 156], ["delfi.neuralnet.NeuralNet.NeuralNet", "BaseInference.BaseInference.gen_newseed", "BaseInference.BaseInference.norm_init", "dir"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.norm_init"], ["", "def", "reinit_network", "(", "self", ")", ":", "\n", "        ", "\"\"\"Reinitializes the network instance (re-setting the weights!)\n        \"\"\"", "\n", "self", ".", "network", "=", "NeuralNet", "(", "**", "self", ".", "kwargs", ")", "\n", "self", ".", "svi", "=", "self", ".", "network", ".", "svi", "if", "'svi'", "in", "dir", "(", "self", ".", "network", ")", "else", "False", "\n", "\"\"\"update self.kwargs['seed'] so that reinitializing the network gives a\n        different result each time unless we reseed the inference method\"\"\"", "\n", "self", ".", "kwargs", "[", "'seed'", "]", "=", "self", ".", "gen_newseed", "(", ")", "\n", "self", ".", "norm_init", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.centre_on_obs": [[157, 164], ["BaseInference.BaseInference.obs.copy"], "methods", ["None"], ["", "def", "centre_on_obs", "(", "self", ")", ":", "\n", "        ", "\"\"\" Centres first-layer input onto observed summary statistics\n\n        Ensures x' = x - xo, i.e. first-layer input x' = 0 for x = xo.\n        \"\"\"", "\n", "\n", "self", ".", "stats_mean", "=", "self", ".", "obs", ".", "copy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.remove_hidden_biases": [[165, 174], ["filter", "b.set_value", "numpy.zeros_like", "b.get_value"], "methods", ["None"], ["", "def", "remove_hidden_biases", "(", "self", ")", ":", "\n", "        ", "\"\"\" Resets all bias weights in hidden layers to zero.\n\n        \"\"\"", "\n", "def", "idx_hiddens", "(", "x", ")", ":", "\n", "            ", "return", "x", ".", "name", "[", "0", "]", "==", "'h'", "\n", "\n", "", "for", "b", "in", "filter", "(", "idx_hiddens", ",", "self", ".", "network", ".", "mps_bp", ")", ":", "\n", "            ", "b", ".", "set_value", "(", "np", ".", "zeros_like", "(", "b", ".", "get_value", "(", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.conditional_norm": [[175, 255], ["print", "print", "print", "BaseInference.BaseInference.network.get_mog", "BaseInference.BaseInference.ztrans_inv", "numpy.all", "numpy.triu", "numpy.eye", "range", "numpy.zeros_like", "range", "numpy.sqrt().reshape", "numpy.sqrt().reshape", "numpy.zeros_like", "zip", "zip", "zip", "obz.reshape", "numpy.ones", "numpy.zeros_like", "numpy.zeros_like", "numpy.zeros_like", "numpy.eye", "filter", "filter", "filter", "filter", "h.dot", "b.set_value", "filter", "filter", "h.dot().reshape", "b.get_value().copy().reshape", "b.set_value", "numpy.diff", "numpy.outer", "numpy.sqrt", "numpy.sqrt", "numpy.zeros", "h.dot", "b.get_value", "w.get_value", "val.flatten", "w.get_value", "h.dot", "b.get_value().copy", "numpy.diag", "numpy.diag", "w.get_value", "numpy.diag", "numpy.diag", "numpy.diag", "w.get_value", "b.get_value", "numpy.log", "numpy.diag", "b.get_value"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans_inv", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "", "def", "conditional_norm", "(", "self", ",", "fcv", "=", "0.8", ",", "tmu", "=", "None", ",", "tSig", "=", "None", ",", "h", "=", "None", ")", ":", "\n", "        ", "\"\"\"Normalizes current network output at observed summary statistics\n\n        Parameters\n        ----------\n        fcv : float\n            Fraction of total that comes from uncertainty over components, i.e.\n            Var[th] = E[Var[th|z]] + Var[E[th|z]]\n                    =  (1-fcv)     +     fcv       = 1\n        tmu: array\n            Target mean.\n        tSig: array\n            Target covariance.\n        \"\"\"", "\n", "\n", "# avoid CDELFI.predict() attempt to analytically correct for proposal", "\n", "print", "(", "'obs'", ",", "self", ".", "obs", ".", "shape", ")", "\n", "print", "(", "'mean'", ",", "self", ".", "stats_mean", ".", "shape", ")", "\n", "print", "(", "'std'", ",", "self", ".", "stats_std", ".", "shape", ")", "\n", "obz", "=", "(", "self", ".", "obs", "-", "self", ".", "stats_mean", ")", "/", "self", ".", "stats_std", "\n", "posterior", "=", "self", ".", "network", ".", "get_mog", "(", "obz", ".", "reshape", "(", "self", ".", "obs", ".", "shape", ")", ",", "\n", "deterministic", "=", "True", ")", "\n", "mog", "=", "posterior", ".", "ztrans_inv", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "\n", "assert", "np", ".", "all", "(", "np", ".", "diff", "(", "mog", ".", "a", ")", "==", "0.", ")", "# assumes uniform alpha", "\n", "\n", "n_dim", "=", "self", ".", "kwargs", "[", "'n_outputs'", "]", "\n", "triu_mask", "=", "np", ".", "triu", "(", "np", ".", "ones", "(", "[", "n_dim", ",", "n_dim", "]", ",", "dtype", "=", "dtype", ")", ",", "1", ")", "\n", "diag_mask", "=", "np", ".", "eye", "(", "n_dim", ",", "dtype", "=", "dtype", ")", "\n", "\n", "# compute MoG mean mu, Sig = E[Var[th|z]] and C = Var[E[th|z]]", "\n", "mu", ",", "Sig", "=", "np", ".", "zeros_like", "(", "mog", ".", "xs", "[", "0", "]", ".", "m", ")", ",", "np", ".", "zeros_like", "(", "mog", ".", "xs", "[", "0", "]", ".", "S", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "network", ".", "n_components", ")", ":", "\n", "            ", "Sig", "+=", "mog", ".", "a", "[", "i", "]", "*", "mog", ".", "xs", "[", "i", "]", ".", "S", "\n", "mu", "+=", "mog", ".", "a", "[", "i", "]", "*", "mog", ".", "xs", "[", "i", "]", ".", "m", "\n", "", "C", "=", "np", ".", "zeros_like", "(", "Sig", ")", "\n", "for", "i", "in", "range", "(", "self", ".", "network", ".", "n_components", ")", ":", "\n", "            ", "dmu", "=", "mog", ".", "xs", "[", "i", "]", ".", "m", "-", "mu", "if", "self", ".", "network", ".", "n_components", ">", "1", "else", "mog", ".", "xs", "[", "i", "]", ".", "m", "\n", "C", "+=", "mog", ".", "a", "[", "i", "]", "*", "np", ".", "outer", "(", "dmu", ",", "dmu", ")", "\n", "\n", "# if not provided, target zero-mean unit variance (as for prior_norm=True)", "\n", "", "tmu", "=", "np", ".", "zeros_like", "(", "mog", ".", "xs", "[", "0", "]", ".", "m", ")", "if", "tmu", "is", "None", "else", "tmu", "\n", "tSig", "=", "np", ".", "eye", "(", "mog", ".", "xs", "[", "0", "]", ".", "m", ".", "size", ")", "if", "tSig", "is", "None", "else", "tSig", "\n", "\n", "# compute normalizers (we only z-score, don't whiten!)", "\n", "Z1inv", "=", "np", ".", "sqrt", "(", "(", "1.", "-", "fcv", ")", "/", "np", ".", "diag", "(", "Sig", ")", "*", "np", ".", "diag", "(", "tSig", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "Z2inv", "=", "np", ".", "sqrt", "(", "fcv", "/", "np", ".", "diag", "(", "C", ")", "*", "np", ".", "diag", "(", "tSig", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n", "# first we need the center of means", "\n", "def", "idx_MoG", "(", "x", ")", ":", "\n", "            ", "return", "x", ".", "name", "[", ":", "5", "]", "==", "'means'", "\n", "", "mu_", "=", "np", ".", "zeros_like", "(", "mog", ".", "xs", "[", "0", "]", ".", "m", ")", "\n", "for", "w", ",", "b", "in", "zip", "(", "filter", "(", "idx_MoG", ",", "self", ".", "network", ".", "mps_wp", ")", ",", "\n", "filter", "(", "idx_MoG", ",", "self", ".", "network", ".", "mps_bp", ")", ")", ":", "\n", "            ", "h", "=", "np", ".", "zeros", "(", "w", ".", "get_value", "(", ")", ".", "shape", "[", "0", "]", ")", "if", "h", "is", "None", "else", "h", "\n", "mu_", "+=", "h", ".", "dot", "(", "w", ".", "get_value", "(", ")", ")", "+", "b", ".", "get_value", "(", ")", "\n", "", "mu_", "/=", "self", ".", "network", ".", "n_components", "\n", "\n", "# center and normalize means", "\n", "# mu =  Z2inv * (Wh + b - mu_) + tmu", "\n", "#    = Wh + (Z2inv * (b - mu_ + Wh) - Wh + tum)", "\n", "for", "w", ",", "b", "in", "zip", "(", "filter", "(", "idx_MoG", ",", "self", ".", "network", ".", "mps_wp", ")", ",", "\n", "filter", "(", "idx_MoG", ",", "self", ".", "network", ".", "mps_bp", ")", ")", ":", "\n", "            ", "Wh", "=", "h", ".", "dot", "(", "w", ".", "get_value", "(", ")", ")", "\n", "b", ".", "set_value", "(", "Z2inv", "*", "(", "Wh", "+", "b", ".", "get_value", "(", ")", "-", "mu_", ")", "-", "Wh", "+", "tmu", ")", "\n", "\n", "# normalize covariances", "\n", "", "def", "idx_MoG", "(", "x", ")", ":", "\n", "            ", "return", "x", ".", "name", "[", ":", "10", "]", "==", "'precisions'", "\n", "# Sig^-0.5 = diag_mask * (exp(Wh+b)/exp(log(Z1)) + triu_mask * (Wh+b)*Z1", "\n", "#          = diag_mask *  exp(Wh+ (b-log(Z1))    + triu_mask * (Wh+((b+Wh)*Z1-Wh))", "\n", "", "for", "w", ",", "b", "in", "zip", "(", "filter", "(", "idx_MoG", ",", "self", ".", "network", ".", "mps_wp", ")", ",", "\n", "filter", "(", "idx_MoG", ",", "self", ".", "network", ".", "mps_bp", ")", ")", ":", "\n", "            ", "Wh", "=", "h", ".", "dot", "(", "w", ".", "get_value", "(", ")", ")", ".", "reshape", "(", "n_dim", ",", "n_dim", ")", "\n", "b_", "=", "b", ".", "get_value", "(", ")", ".", "copy", "(", ")", ".", "reshape", "(", "n_dim", ",", "n_dim", ")", "\n", "\n", "val", "=", "diag_mask", "*", "(", "b_", "-", "np", ".", "diag", "(", "np", ".", "log", "(", "Z1inv", ")", ")", ")", "+", "triu_mask", "*", "(", "(", "b_", "+", "Wh", ")", ".", "dot", "(", "np", ".", "diag", "(", "1.", "/", "Z1inv", ")", ")", "-", "Wh", ")", "\n", "\n", "b", ".", "set_value", "(", "val", ".", "flatten", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.norm_init": [[257, 264], ["print", "BaseInference.BaseInference.standardize_init", "BaseInference.BaseInference.standardize_init"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.standardize_init", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.standardize_init"], ["", "", "def", "norm_init", "(", "self", ")", ":", "\n", "        ", "if", "self", ".", "init_norm", "and", "self", ".", "network", ".", "density", "==", "'mog'", ":", "\n", "            ", "print", "(", "'standardizing network initialization'", ")", "\n", "if", "self", ".", "network", ".", "n_components", ">", "1", ":", "\n", "                ", "self", ".", "standardize_init", "(", "fcv", "=", "self", ".", "init_fcv", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "standardize_init", "(", "fcv", "=", "0.", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.standardize_init": [[265, 282], ["isinstance", "BaseInference.BaseInference.centre_on_obs", "BaseInference.BaseInference.remove_hidden_biases", "BaseInference.BaseInference.conditional_norm"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.centre_on_obs", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.remove_hidden_biases", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.conditional_norm"], ["", "", "", "def", "standardize_init", "(", "self", ",", "fcv", "=", "0.8", ")", ":", "\n", "        ", "\"\"\" Standardizes the network initialization on obs\n\n        Ensures output distributions for xo have mean zero and unit variance.\n        Alters hidden layers to propagates x=xo as zero to the last layer, and\n        alters the MoG layers to produce the desired output distribution.\n        \"\"\"", "\n", "assert", "isinstance", "(", "self", ".", "network", ",", "NeuralNet", ")", "\n", "\n", "# ensure x' = x - xo", "\n", "self", ".", "centre_on_obs", "(", ")", "\n", "\n", "# ensure x' = 0 stays zero up to MoG layer (setting biases to zero)", "\n", "self", ".", "remove_hidden_biases", "(", ")", "\n", "\n", "# ensure MoG returns standardized output on x' = 0", "\n", "self", ".", "conditional_norm", "(", "fcv", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.gen": [[283, 323], ["numpy.minimum", "len", "BaseInference.BaseInference.generator.gen", "BaseInference.BaseInference.generator.gen", "numpy.concatenate", "numpy.concatenate"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "gen", "(", "self", ",", "n_samples", ",", "n_reps", "=", "1", ",", "prior_mixin", "=", "0", ",", "verbose", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate from generator and z-transform\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate\n        n_reps : int\n            Number of repeats per parameter\n        verbose : None or bool or str\n            If None is passed, will default to self.verbose\n        \"\"\"", "\n", "assert", "n_reps", "==", "1", ",", "'n_reps > 1 is not yet supported'", "\n", "verbose", "=", "self", ".", "verbose", "if", "verbose", "is", "None", "else", "verbose", "\n", "\n", "n_pilot", "=", "np", ".", "minimum", "(", "n_samples", ",", "len", "(", "self", ".", "unused_pilot_samples", "[", "0", "]", ")", ")", "\n", "if", "n_pilot", ">", "0", "and", "self", ".", "generator", ".", "proposal", "is", "self", ".", "generator", ".", "prior", ":", "# reuse pilot samples", "\n", "            ", "params", "=", "self", ".", "unused_pilot_samples", "[", "0", "]", "[", ":", "n_pilot", ",", ":", "]", "\n", "stats", "=", "self", ".", "unused_pilot_samples", "[", "1", "]", "[", ":", "n_pilot", ",", ":", "]", "\n", "self", ".", "unused_pilot_samples", "=", "(", "self", ".", "unused_pilot_samples", "[", "0", "]", "[", "n_pilot", ":", ",", ":", "]", ",", "\n", "self", ".", "unused_pilot_samples", "[", "1", "]", "[", "n_pilot", ":", ",", ":", "]", ")", "\n", "n_samples", "-=", "n_pilot", "\n", "\n", "if", "n_samples", ">", "0", ":", "\n", "                ", "params_rem", ",", "stats_rem", "=", "self", ".", "generator", ".", "gen", "(", "n_samples", ",", "\n", "prior_mixin", "=", "prior_mixin", ",", "\n", "verbose", "=", "verbose", ")", "\n", "params", "=", "np", ".", "concatenate", "(", "(", "params", ",", "params_rem", ")", ",", "axis", "=", "0", ")", "\n", "stats", "=", "np", ".", "concatenate", "(", "(", "stats", ",", "stats_rem", ")", ",", "axis", "=", "0", ")", "\n", "", "", "else", ":", "\n", "            ", "params", ",", "stats", "=", "self", ".", "generator", ".", "gen", "(", "n_samples", ",", "\n", "prior_mixin", "=", "prior_mixin", ",", "\n", "verbose", "=", "verbose", ")", "\n", "\n", "# z-transform params and stats", "\n", "", "params", "=", "(", "params", "-", "self", ".", "params_mean", ")", "/", "self", ".", "params_std", "\n", "stats", "=", "(", "stats", "-", "self", ".", "stats_mean", ")", "/", "self", ".", "stats_std", "\n", "\n", "return", "params", ",", "stats", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset": [[324, 337], ["BaseInference.BaseInference.reinit_network", "BaseInference.BaseInference.reseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reinit_network", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed"], ["", "def", "reset", "(", "self", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Resets inference method to a naive state, before it has seen any\n        real or simulated data. The following happens, in order:\n        1) The generator's proposal is set to None, and self.round is set to 0\n        2) The inference method is reseeded if a seed is provided\n        3) The network is reinitialized\n        4) Any additional resetting of state specific to each inference method\n        \"\"\"", "\n", "self", ".", "generator", ".", "proposal", "=", "None", "\n", "self", ".", "round", "=", "0", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "reseed", "(", "seed", ")", "\n", "", "self", ".", "reinit_network", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reseed": [[338, 346], ["BaseInference.BaseInference.rng.seed", "BaseInference.BaseInference.gen_newseed", "BaseInference.BaseInference.generator.reseed", "isinstance", "BaseInference.BaseInference.gen_newseed", "BaseInference.BaseInference.network.reseed", "BaseInference.BaseInference.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"reseed inference method's RNG, then generator, then network\"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "kwargs", "[", "'seed'", "]", "=", "self", ".", "gen_newseed", "(", ")", "# for consistent NN init", "\n", "self", ".", "generator", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "# also reseeds prior + model", "\n", "if", "isinstance", "(", "self", ".", "network", ",", "NeuralNet", ")", ":", "\n", "            ", "self", ".", "network", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "# for reproducible samples", "\n", "# unfortunately, MAFs cannot currently be (re)seeded", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.gen_newseed": [[348, 354], ["BaseInference.BaseInference.rng.randint"], "methods", ["None"], ["", "", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.pilot_run": [[355, 383], ["delfi.utils.data.isint", "numpy.nanmean", "numpy.nanstd", "numpy.maximum", "numpy.logical_not", "numpy.zeros", "numpy.ones", "BaseInference.BaseInference.generator.gen", "numpy.isnan().any", "numpy.isnan().any", "numpy.logical_or", "delfi.utils.data.isint", "BaseInference.BaseInference.generator.reseed", "numpy.isnan().any", "numpy.isnan().any", "BaseInference.BaseInference.gen_newseed", "numpy.isnan", "numpy.isnan", "numpy.isnan", "numpy.isnan"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.utils.data.isint", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "", "def", "pilot_run", "(", "self", ",", "pilot_samples", ",", "n_stats", ",", "min_std", "=", "1e-4", ")", ":", "\n", "        ", "\"\"\"Pilot run in order to find parameters for z-scoring stats\"\"\"", "\n", "if", "pilot_samples", "is", "None", "or", "(", "isint", "(", "pilot_samples", ")", "and", "pilot_samples", "==", "0", ")", ":", "\n", "            ", "self", ".", "unused_pilot_samples", "=", "(", "[", "]", ",", "[", "]", ")", "\n", "self", ".", "stats_mean", "=", "np", ".", "zeros", "(", "n_stats", ")", "\n", "self", ".", "stats_std", "=", "np", ".", "ones", "(", "n_stats", ")", "\n", "return", "\n", "\n", "", "if", "isint", "(", "pilot_samples", ")", ":", "# determine via pilot run", "\n", "            ", "assert", "pilot_samples", ">", "0", "\n", "if", "self", ".", "seed", "is", "not", "None", ":", "# reseed generator for consistent inits", "\n", "                ", "self", ".", "generator", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "", "verbose", "=", "'(pilot run) '", "if", "self", ".", "verbose", "else", "False", "\n", "params", ",", "stats", "=", "self", ".", "generator", ".", "gen", "(", "pilot_samples", ",", "verbose", "=", "verbose", ")", "\n", "", "else", ":", "# samples were provided as an input", "\n", "            ", "params", ",", "stats", "=", "pilot_samples", "\n", "\n", "", "self", ".", "stats_mean", "=", "np", ".", "nanmean", "(", "stats", ",", "axis", "=", "0", ")", "\n", "self", ".", "stats_std", "=", "np", ".", "nanstd", "(", "stats", ",", "axis", "=", "0", ")", "\n", "assert", "not", "np", ".", "isnan", "(", "self", ".", "stats_mean", ")", ".", "any", "(", ")", ",", "\"pilot run failed\"", "\n", "assert", "not", "np", ".", "isnan", "(", "self", ".", "stats_std", ")", ".", "any", "(", ")", ",", "\"pilot run failed\"", "\n", "self", ".", "stats_std", "[", "self", ".", "stats_std", "==", "0.0", "]", "=", "1.0", "\n", "self", ".", "stats_std", "=", "np", ".", "maximum", "(", "self", ".", "stats_std", ",", "min_std", ")", "\n", "assert", "(", "self", ".", "stats_std", ">", "0", ")", ".", "all", "(", ")", ",", "\"pilot run failed\"", "\n", "ok_sims", "=", "np", ".", "logical_not", "(", "np", ".", "logical_or", "(", "np", ".", "isnan", "(", "stats", ")", ".", "any", "(", "axis", "=", "1", ")", ",", "\n", "np", ".", "isnan", "(", "params", ")", ".", "any", "(", "axis", "=", "1", ")", ")", ")", "\n", "self", ".", "unused_pilot_samples", "=", "(", "params", "[", "ok_sims", ",", ":", "]", ",", "stats", "[", "ok_sims", ",", ":", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict": [[384, 411], ["isinstance", "BaseInference.BaseInference.network.get_density", "posterior.ztrans_inv.ztrans_inv.ztrans_inv", "posterior.ztrans_inv.ztrans_inv.set_scale_and_offset", "numpy.all", "numpy.all"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_density", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans_inv", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.MAFconditional.set_scale_and_offset"], ["", "def", "predict", "(", "self", ",", "x", ",", "deterministic", "=", "True", ")", ":", "\n", "        ", "\"\"\"Predict posterior given x\n\n        Parameters\n        ----------\n        x : array\n            Stats for which to compute the posterior\n        deterministic : bool\n            if True, mean weights are used for Bayesian network\n        \"\"\"", "\n", "assert", "isinstance", "(", "self", ".", "network", ",", "NeuralNet", ")", "\n", "# z-transform inputs", "\n", "x_zt", "=", "(", "x", "-", "self", ".", "stats_mean", ")", "/", "self", ".", "stats_std", "\n", "\n", "posterior", "=", "self", ".", "network", ".", "get_density", "(", "x_zt", ",", "deterministic", "=", "deterministic", ")", "\n", "\n", "# z-transform outputs", "\n", "if", "self", ".", "network", ".", "density", "==", "'mog'", ":", "\n", "            ", "posterior", "=", "posterior", ".", "ztrans_inv", "(", "self", ".", "params_mean", ",", "self", ".", "params_std", ")", "\n", "", "elif", "self", ".", "network", ".", "density", "==", "'maf'", ":", "\n", "            ", "posterior", ".", "set_scale_and_offset", "(", "scale", "=", "self", ".", "params_std", ",", "\n", "offset", "=", "self", ".", "params_mean", ")", "\n", "", "else", ":", "\n", "            ", "assert", "np", ".", "all", "(", "self", ".", "params_std", "==", "1.0", ")", "and", "np", ".", "all", "(", "self", ".", "params_mean", "==", "0.0", ")", "\n", "\n", "", "return", "posterior", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.compile_observables": [[412, 418], ["str"], "methods", ["None"], ["", "def", "compile_observables", "(", "self", ")", ":", "\n", "        ", "\"\"\"Creates observables dict\"\"\"", "\n", "self", ".", "observables", "=", "{", "}", "\n", "self", ".", "observables", "[", "'loss.lprobs'", "]", "=", "self", ".", "network", ".", "lprobs", "\n", "for", "p", "in", "self", ".", "network", ".", "aps", ":", "\n", "            ", "self", ".", "observables", "[", "str", "(", "p", ")", "]", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names": [[419, 431], ["isinstance"], "methods", ["None"], ["", "", "def", "monitor_dict_from_names", "(", "self", ",", "monitor", "=", "None", ")", ":", "\n", "        ", "\"\"\"Generate monitor dict from list of variable names\"\"\"", "\n", "if", "monitor", "is", "not", "None", ":", "\n", "            ", "observe", "=", "{", "}", "\n", "if", "isinstance", "(", "monitor", ",", "str", ")", ":", "\n", "                ", "monitor", "=", "[", "monitor", "]", "\n", "", "for", "m", "in", "monitor", ":", "\n", "                ", "if", "m", "in", "self", ".", "observables", ":", "\n", "                    ", "observe", "[", "m", "]", "=", "self", ".", "observables", "[", "m", "]", "\n", "", "", "", "else", ":", "\n", "            ", "observe", "=", "None", "\n", "", "return", "observe", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.Basic.Basic.__init__": [[9, 53], ["delfi.inference.BaseInference.BaseInference.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "generator", ",", "obs", "=", "None", ",", "prior_norm", "=", "False", ",", "pilot_samples", "=", "100", ",", "\n", "reg_lambda", "=", "0.01", ",", "seed", "=", "None", ",", "verbose", "=", "True", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Basic inference algorithm\n\n        Uses samples from the prior for density estimation likelihood-free\n        inference.\n        \n        Parameters\n        ----------\n        generator : generator instance\n            Generator instance\n        obs : array or None\n            Observation in the format the generator returns (1 x n_summary)\n        prior_norm : bool\n            If set to True, will z-transform params based on mean/std of prior\n        pilot_samples : None or int\n            If an integer is provided, a pilot run with the given number of\n            samples is run. The mean and std of the summary statistics of the\n            pilot samples will be subsequently used to z-transform summary\n            statistics.\n        reg_lambda : float\n            Precision parameter for weight regularizer if svi is True\n        seed : int or None\n            If provided, random number generator will be seeded\n        kwargs : additional keyword arguments\n            Additional arguments for the NeuralNet instance, including:\n                n_components : int\n                    Number of components of the mixture density\n                n_hiddens : list of ints\n                    Number of hidden units per layer of the neural network\n                svi : bool\n                    Whether to use SVI version of the network or not\n\n        Attributes\n        ----------\n        observables : dict\n            Dictionary containing theano variables that can be monitored while\n            training the neural network.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "generator", ",", "prior_norm", "=", "prior_norm", ",", "\n", "pilot_samples", "=", "pilot_samples", ",", "seed", "=", "seed", ",", "\n", "verbose", "=", "verbose", ",", "**", "kwargs", ")", "\n", "self", ".", "obs", "=", "obs", "\n", "self", ".", "reg_lambda", "=", "reg_lambda", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.Basic.Basic.loss": [[54, 80], ["theano.mean", "delfi.neuralnet.loss.regularizer.svi_kl_init", "delfi.neuralnet.loss.regularizer.svi_kl_zero"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_init", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_zero"], ["", "def", "loss", "(", "self", ",", "N", ",", "round_cl", "=", "1", ")", ":", "\n", "        ", "\"\"\"Loss function for training\n\n        Parameters\n        ----------\n        N : int\n            Number of training samples\n        \"\"\"", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "self", ".", "network", ".", "lprobs", ")", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "\n", "            ", "if", "self", ".", "round", "<=", "round_cl", ":", "\n", "# weights close to zero-centered prior in the first round", "\n", "                ", "if", "self", ".", "reg_lambda", ">", "0", ":", "\n", "                    ", "kl", ",", "imvs", "=", "svi_kl_zero", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ",", "\n", "self", ".", "reg_lambda", ")", "\n", "", "else", ":", "\n", "                    ", "kl", ",", "imvs", "=", "0", ",", "{", "}", "\n", "", "", "else", ":", "\n", "# weights close to those of previous round", "\n", "                ", "kl", ",", "imvs", "=", "svi_kl_init", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ")", "\n", "\n", "", "loss", "=", "loss", "+", "1", "/", "N", "*", "kl", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.Basic.Basic.run": [[81, 163], ["range", "Basic.Basic.gen", "delfi.neuralnet.Trainer.Trainer", "logs.append", "trn_datasets.append", "type", "Basic.Basic.loss", "delfi.neuralnet.Trainer.Trainer.train", "Basic.Basic.gen_newseed", "Basic.Basic.monitor_dict_from_names", "posteriors.append", "posteriors.append", "posteriors.append", "print", "Basic.Basic.predict"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict"], ["", "def", "run", "(", "self", ",", "n_train", "=", "100", ",", "n_rounds", "=", "1", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "\n", "round_cl", "=", "1", ",", "stop_on_nan", "=", "False", ",", "monitor", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Run algorithm\n\n        Parameters\n        ----------\n        n_train : int or list of ints\n            Number of data points drawn per round. If a list is passed, the\n            nth list element specifies the number of training examples in the\n            nth round. If there are fewer list elements than rounds, the last\n            list element is used.\n        n_rounds : int\n            Number of rounds\n        epochs : int\n            Number of epochs used for neural network training\n        minibatch : int\n            Size of the minibatches used for neural network training\n        monitor : list of str\n            Names of variables to record during training along with the value\n            of the loss function. The observables attribute contains all\n            possible variables that can be monitored\n        round_cl : int\n            Round after which to start continual learning\n        stop_on_nan : bool\n            If True, will halt if NaNs in the loss are encountered\n        kwargs : additional keyword arguments\n            Additional arguments for the Trainer instance\n\n        Returns\n        -------\n        logs : list of dicts\n            Dictionaries contain information logged while training the networks\n        trn_datasets : list of (params, stats)\n            training datasets, z-transformed\n        posteriors : list of distributions\n            posterior after each round\n        \"\"\"", "\n", "logs", "=", "[", "]", "\n", "trn_datasets", "=", "[", "]", "\n", "posteriors", "=", "[", "]", "\n", "\n", "for", "r", "in", "range", "(", "n_rounds", ")", ":", "\n", "            ", "self", ".", "round", "+=", "1", "\n", "\n", "# number of training examples for this round", "\n", "if", "type", "(", "n_train", ")", "==", "list", ":", "\n", "                ", "try", ":", "\n", "                    ", "n_train_round", "=", "n_train", "[", "self", ".", "round", "-", "1", "]", "\n", "", "except", ":", "\n", "                    ", "n_train_round", "=", "n_train", "[", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "n_train_round", "=", "n_train", "\n", "\n", "# draw training data (z-transformed params and stats)", "\n", "", "verbose", "=", "'(round {}) '", ".", "format", "(", "self", ".", "round", ")", "if", "self", ".", "verbose", "else", "False", "\n", "trn_data", "=", "self", ".", "gen", "(", "n_train_round", ",", "verbose", "=", "verbose", ")", "\n", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "trn_data", "=", "(", "trn_data", "[", "0", "]", ",", "trn_data", "[", "1", "]", ")", "\n", "trn_inputs", "=", "[", "self", ".", "network", ".", "params", ",", "self", ".", "network", ".", "stats", "]", "\n", "\n", "t", "=", "Trainer", "(", "self", ".", "network", ",", "\n", "self", ".", "loss", "(", "N", "=", "n_train_round", ",", "round_cl", "=", "round_cl", ")", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "**", "kwargs", ")", "\n", "logs", ".", "append", "(", "t", ".", "train", "(", "epochs", "=", "epochs", ",", "minibatch", "=", "minibatch", ",", "\n", "verbose", "=", "verbose", ",", "stop_on_nan", "=", "stop_on_nan", ")", ")", "\n", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "\n", "try", ":", "\n", "                ", "if", "self", ".", "obs", "is", "None", ":", "\n", "                    ", "posteriors", ".", "append", "(", "None", ")", "\n", "", "else", ":", "\n", "                    ", "posteriors", ".", "append", "(", "self", ".", "predict", "(", "self", ".", "obs", ")", ")", "\n", "", "", "except", ":", "\n", "                ", "posteriors", ".", "append", "(", "None", ")", "\n", "print", "(", "'Posterior inference failed'", ")", "\n", "break", "\n", "\n", "", "", "return", "logs", ",", "trn_datasets", ",", "posteriors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.__init__": [[9, 72], ["numpy.asarray", "delfi.inference.BaseInference.BaseInference.__init__", "numpy.any", "numpy.isnan", "ValueError"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "generator", ",", "obs", ",", "prior_norm", "=", "False", ",", "pilot_samples", "=", "100", ",", "\n", "convert_to_T", "=", "3", ",", "reg_lambda", "=", "0.01", ",", "prior_mixin", "=", "0", ",", "kernel", "=", "None", ",", "seed", "=", "None", ",", "verbose", "=", "True", ",", "\n", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"SNPE-B\n\n        Implementation of Lueckmann, Goncalves, Bassetto, \u00d6cal, Nonnenmacher & Macke (NeurIPS 2017)\n\n        Parameters\n        ----------\n        generator : generator instance\n            Generator instance\n        obs : array\n            Observation in the format the generator returns (1 x n_summary)\n        prior_norm : bool\n            If set to True, will z-transform params based on mean/std of prior\n        pilot_samples : None or int\n            If an integer is provided, a pilot run with the given number of\n            samples is run. The mean and std of the summary statistics of the\n            pilot samples will be subsequently used to z-transform summary\n            statistics.\n        convert_to_T : None or int\n            Convert proposal distribution to Student's T? If a number if given,\n            the number specifies the degrees of freedom. None for no conversion\n        reg_lambda : float\n            Precision parameter for weight regularizer if svi is True\n        prior_mixin : float\n            Percentage of the prior mixed into the proposal prior. While training,\n            an additional prior_mixin * N samples will be drawn from the actual prior\n            in each round.\n        seed : int or None\n            If provided, random number generator will be seeded\n        verbose : bool\n            Controls whether or not progressbars are shown\n        kwargs : additional keyword arguments\n            Additional arguments for the NeuralNet instance, including:\n                n_components : int\n                    Number of components of the mixture density\n                n_hiddens : list of ints\n                    Number of hidden units per layer of the neural network\n                svi : bool\n                    Whether to use SVI version of the network or not\n\n        Attributes\n        ----------\n        observables : dict\n            Dictionary containing theano variables that can be monitored while\n            training the neural network.\n        \"\"\"", "\n", "assert", "obs", "is", "not", "None", ",", "\"SNPE requires observed data\"", "\n", "self", ".", "obs", "=", "np", ".", "asarray", "(", "obs", ")", "\n", "super", "(", ")", ".", "__init__", "(", "generator", ",", "prior_norm", "=", "prior_norm", ",", "\n", "pilot_samples", "=", "pilot_samples", ",", "seed", "=", "seed", ",", "\n", "verbose", "=", "verbose", ",", "**", "kwargs", ")", "\n", "\n", "if", "np", ".", "any", "(", "np", ".", "isnan", "(", "self", ".", "obs", ")", ")", ":", "\n", "            ", "raise", "ValueError", "(", "\"Observed data contains NaNs\"", ")", "\n", "\n", "", "self", ".", "reg_lambda", "=", "reg_lambda", "\n", "self", ".", "convert_to_T", "=", "convert_to_T", "\n", "\n", "self", ".", "prior_mixin", "=", "0", "if", "prior_mixin", "is", "None", "else", "prior_mixin", "\n", "\n", "self", ".", "kernel", "=", "kernel", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.loss": [[73, 107], ["SNPEB.SNPEB.network.get_loss", "SNPEB.SNPEB.observables.update", "delfi.neuralnet.loss.regularizer.svi_kl_init", "delfi.neuralnet.loss.regularizer.svi_kl_zero"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_loss", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_init", "home.repos.pwc.inspect_result.mackelab_delfi.loss.regularizer.svi_kl_zero"], ["", "def", "loss", "(", "self", ",", "N", ",", "round_cl", "=", "1", ")", ":", "\n", "        ", "\"\"\"Loss function for training\n\n        Parameters\n        ----------\n        N : int\n            Number of training samples\n        \"\"\"", "\n", "loss", "=", "self", ".", "network", ".", "get_loss", "(", ")", "\n", "\n", "# adding nodes to dict s.t. they can be monitored during training", "\n", "self", ".", "observables", "[", "'loss.lprobs'", "]", "=", "self", ".", "network", ".", "lprobs", "\n", "self", ".", "observables", "[", "'loss.iws'", "]", "=", "self", ".", "network", ".", "iws", "\n", "self", ".", "observables", "[", "'loss.raw_loss'", "]", "=", "loss", "\n", "\n", "if", "self", ".", "svi", ":", "\n", "            ", "if", "self", ".", "round", "<=", "round_cl", ":", "\n", "# weights close to zero-centered prior in the first round", "\n", "                ", "if", "self", ".", "reg_lambda", ">", "0", ":", "\n", "                    ", "kl", ",", "imvs", "=", "svi_kl_zero", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ",", "\n", "self", ".", "reg_lambda", ")", "\n", "", "else", ":", "\n", "                    ", "kl", ",", "imvs", "=", "0", ",", "{", "}", "\n", "", "", "else", ":", "\n", "# weights close to those of previous round", "\n", "                ", "kl", ",", "imvs", "=", "svi_kl_init", "(", "self", ".", "network", ".", "mps", ",", "self", ".", "network", ".", "sps", ")", "\n", "\n", "", "loss", "=", "loss", "+", "1", "/", "N", "*", "kl", "\n", "\n", "# adding nodes to dict s.t. they can be monitored", "\n", "self", ".", "observables", "[", "'loss.kl'", "]", "=", "kl", "\n", "self", ".", "observables", ".", "update", "(", "imvs", ")", "\n", "\n", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run": [[108, 226], ["range", "SNPEB.SNPEB.gen", "numpy.mean", "delfi.neuralnet.Trainer.Trainer", "logs.append", "trn_datasets.append", "type", "SNPEB.SNPEB.generator.prior.eval", "SNPEB.SNPEB.generator.proposal.eval", "numpy.ones", "SNPEB.SNPEB.kernel.eval", "SNPEB.SNPEB.loss", "delfi.neuralnet.Trainer.Trainer.train", "posteriors.append", "SNPEB.SNPEB.predict", "trn_data[].reshape", "SNPEB.SNPEB.gen_newseed", "SNPEB.SNPEB.monitor_dict_from_names", "SNPEB.SNPEB.predict", "posteriors.append", "print", "proposal.convert_to_T.convert_to_T.convert_to_T", "type"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.loss", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.monitor_dict_from_names", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.convert_to_T"], ["", "def", "run", "(", "self", ",", "n_train", "=", "100", ",", "n_rounds", "=", "2", ",", "epochs", "=", "100", ",", "minibatch", "=", "50", ",", "\n", "round_cl", "=", "1", ",", "stop_on_nan", "=", "False", ",", "proposal", "=", "None", ",", "\n", "monitor", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"Run algorithm\n\n        Parameters\n        ----------\n        n_train : int or list of ints\n            Number of data points drawn per round. If a list is passed, the\n            nth list element specifies the number of training examples in the\n            nth round. If there are fewer list elements than rounds, the last\n            list element is used.\n        n_rounds : int\n            Number of rounds\n        epochs : int\n            Number of epochs used for neural network training\n        minibatch : int\n            Size of the minibatches used for neural network training\n        monitor : list of str\n            Names of variables to record during training along with the value\n            of the loss function. The observables attribute contains all\n            possible variables that can be monitored\n        round_cl : int\n            Round after which to start continual learning\n        stop_on_nan : bool\n            If True, will halt if NaNs in the loss are encountered\n        proposal : Distribution of None\n            If given, will use this distribution as the starting proposal prior\n        kwargs : additional keyword arguments\n            Additional arguments for the Trainer instance\n\n        Returns\n        -------\n        logs : list of dicts\n            Dictionaries contain information logged while training the networks\n        trn_datasets : list of (params, stats)\n            training datasets, z-transformed\n        posteriors : list of distributions\n            posterior after each round\n        \"\"\"", "\n", "logs", "=", "[", "]", "\n", "trn_datasets", "=", "[", "]", "\n", "posteriors", "=", "[", "]", "\n", "\n", "for", "r", "in", "range", "(", "n_rounds", ")", ":", "\n", "            ", "self", ".", "round", "+=", "1", "\n", "\n", "if", "r", "==", "0", "and", "proposal", "is", "not", "None", ":", "\n", "                ", "self", ".", "generator", ".", "proposal", "=", "proposal", "\n", "# if round > 1, set new proposal distribution before sampling", "\n", "", "elif", "self", ".", "round", ">", "1", ":", "\n", "# posterior becomes new proposal prior", "\n", "                ", "proposal", "=", "self", ".", "predict", "(", "self", ".", "obs", ")", "# see super", "\n", "\n", "# convert proposal to student's T?", "\n", "if", "self", ".", "convert_to_T", "is", "not", "None", ":", "\n", "                    ", "if", "type", "(", "self", ".", "convert_to_T", ")", "==", "int", ":", "\n", "                        ", "dofs", "=", "self", ".", "convert_to_T", "\n", "", "else", ":", "\n", "                        ", "dofs", "=", "10", "\n", "", "proposal", "=", "proposal", ".", "convert_to_T", "(", "dofs", "=", "dofs", ")", "\n", "\n", "", "self", ".", "generator", ".", "proposal", "=", "proposal", "\n", "\n", "# number of training examples for this round", "\n", "", "if", "type", "(", "n_train", ")", "==", "list", ":", "\n", "                ", "try", ":", "\n", "                    ", "n_train_round", "=", "n_train", "[", "self", ".", "round", "-", "1", "]", "\n", "", "except", ":", "\n", "                    ", "n_train_round", "=", "n_train", "[", "-", "1", "]", "\n", "", "", "else", ":", "\n", "                ", "n_train_round", "=", "n_train", "\n", "\n", "\n", "# draw training data (z-transformed params and stats)", "\n", "", "verbose", "=", "'(round {}) '", ".", "format", "(", "self", ".", "round", ")", "if", "self", ".", "verbose", "else", "False", "\n", "\n", "trn_data", "=", "self", ".", "gen", "(", "n_train_round", ",", "prior_mixin", "=", "self", ".", "prior_mixin", ",", "verbose", "=", "verbose", ")", "\n", "n_train_round", "=", "trn_data", "[", "0", "]", ".", "shape", "[", "0", "]", "\n", "\n", "# precompute importance weights", "\n", "if", "self", ".", "generator", ".", "proposal", "is", "not", "None", ":", "\n", "                ", "params", "=", "self", ".", "params_std", "*", "trn_data", "[", "0", "]", "+", "self", ".", "params_mean", "\n", "p_prior", "=", "self", ".", "generator", ".", "prior", ".", "eval", "(", "params", ",", "log", "=", "False", ")", "\n", "p_proposal", "=", "self", ".", "generator", ".", "proposal", ".", "eval", "(", "params", ",", "log", "=", "False", ")", "\n", "iws", "=", "p_prior", "/", "(", "self", ".", "prior_mixin", "*", "p_prior", "+", "(", "1", "-", "self", ".", "prior_mixin", ")", "*", "p_proposal", ")", "\n", "", "else", ":", "\n", "                ", "iws", "=", "np", ".", "ones", "(", "(", "n_train_round", ",", ")", ")", "\n", "\n", "# normalize weights", "\n", "", "iws", "/=", "np", ".", "mean", "(", "iws", ")", "\n", "\n", "if", "self", ".", "kernel", "is", "not", "None", ":", "\n", "                ", "iws", "*=", "self", ".", "kernel", ".", "eval", "(", "trn_data", "[", "1", "]", ".", "reshape", "(", "n_train_round", ",", "-", "1", ")", ")", "\n", "\n", "", "trn_data", "=", "(", "trn_data", "[", "0", "]", ",", "trn_data", "[", "1", "]", ",", "iws", ")", "\n", "trn_inputs", "=", "[", "self", ".", "network", ".", "params", ",", "self", ".", "network", ".", "stats", ",", "\n", "self", ".", "network", ".", "iws", "]", "\n", "\n", "t", "=", "Trainer", "(", "self", ".", "network", ",", "\n", "self", ".", "loss", "(", "N", "=", "n_train_round", ",", "round_cl", "=", "round_cl", ")", ",", "\n", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ",", "\n", "monitor", "=", "self", ".", "monitor_dict_from_names", "(", "monitor", ")", ",", "\n", "**", "kwargs", ")", "\n", "logs", ".", "append", "(", "t", ".", "train", "(", "epochs", "=", "epochs", ",", "minibatch", "=", "minibatch", ",", "\n", "verbose", "=", "verbose", ",", "stop_on_nan", "=", "stop_on_nan", ")", ")", "\n", "\n", "trn_datasets", ".", "append", "(", "trn_data", ")", "\n", "\n", "try", ":", "\n", "                ", "posteriors", ".", "append", "(", "self", ".", "predict", "(", "self", ".", "obs", ")", ")", "\n", "", "except", "np", ".", "linalg", ".", "LinAlgError", ":", "\n", "                ", "posteriors", ".", "append", "(", "None", ")", "\n", "print", "(", "\"Cannot predict posterior after round {} due to NaNs\"", ".", "format", "(", "r", ")", ")", "\n", "break", "\n", "\n", "", "", "return", "logs", ",", "trn_datasets", ",", "posteriors", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gamma.Gamma.__init__": [[7, 30], ["delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.all", "numpy.all", "scipy.stats.gamma", "numpy.atleast_1d", "numpy.atleast_1d"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "alpha", "=", "1.", ",", "beta", "=", "1.", ",", "offset", "=", "0.", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Univariate (!) Gamma distribution\n\n        Parameters\n        ----------\n        alpha : list, or np.array, 1d\n            Shape parameters\n        beta : list, or np.array, 1d\n            inverse scale paramters\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "1", ",", "seed", "=", "seed", ")", "\n", "\n", "alpha", ",", "beta", "=", "np", ".", "atleast_1d", "(", "alpha", ")", ",", "np", ".", "atleast_1d", "(", "beta", ")", "\n", "assert", "alpha", ".", "ndim", "==", "1", ",", "'alpha must be a 1-d array'", "\n", "assert", "alpha", ".", "size", "==", "beta", ".", "size", ",", "'alpha and beta must match in size'", "\n", "assert", "np", ".", "all", "(", "alpha", ">", "0.", ")", ",", "'Should be greater than zero.'", "\n", "assert", "np", ".", "all", "(", "beta", ">", "0.", ")", ",", "'Should be greater than zero.'", "\n", "self", ".", "alpha", "=", "alpha", "\n", "self", ".", "beta", "=", "beta", "\n", "self", ".", "offset", "=", "offset", "\n", "self", ".", "_gamma", "=", "gamma", "(", "a", "=", "alpha", ",", "scale", "=", "1.", "/", "beta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gamma.Gamma.mean": [[31, 35], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "alpha", "/", "self", ".", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gamma.Gamma.std": [[36, 40], ["numpy.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "sqrt", "(", "self", ".", "alpha", ")", "/", "self", ".", "beta", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gamma.Gamma.eval": [[41, 53], ["numpy.atleast_2d", "res.reshape", "Gamma.Gamma._gamma.logpdf", "Gamma.Gamma._gamma.pdf"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# univariate distribution only, i.e. ii=[0] in any case", "\n", "\n", "# x should have a second dim with length 1, not more", "\n", "        ", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "assert", "x", ".", "shape", "[", "1", "]", "==", "1", ",", "'x needs second dim'", "\n", "assert", "not", "x", ".", "ndim", ">", "2", ",", "'no more than 2 dims in x'", "\n", "\n", "res", "=", "self", ".", "_gamma", ".", "logpdf", "(", "x", "-", "self", ".", "offset", ")", "if", "log", "else", "self", ".", "_gamma", ".", "pdf", "(", "x", "-", "self", ".", "offset", ")", "\n", "# reshape to (nbatch, )", "\n", "return", "res", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gamma.Gamma.gen": [[54, 62], ["Gamma.Gamma.rng.gamma"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ",", "seed", "=", "None", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "\n", "        ", "x", "=", "self", ".", "rng", ".", "gamma", "(", "shape", "=", "self", ".", "alpha", ",", "\n", "scale", "=", "1.", "/", "self", ".", "beta", ",", "\n", "size", "=", "(", "n_samples", ",", "self", ".", "ndim", ")", ")", "+", "self", ".", "offset", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.PointMass.PointMass.__init__": [[6, 19], ["numpy.asarray().flatten", "delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.asarray"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "loc", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Discrete distribution\n\n        Parameters\n        ----------\n        loc : np.array\n            Position of the point mass in sampling space\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "self", ".", "loc", "=", "np", ".", "asarray", "(", "loc", ")", ".", "flatten", "(", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "self", ".", "loc", ".", "size", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.PointMass.PointMass.mean": [[20, 24], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "loc", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.PointMass.PointMass.std": [[25, 29], ["numpy.zeros"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "zeros", "(", "self", ".", "ndim", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.PointMass.PointMass.eval": [[30, 35], ["numpy.prod", "numpy.log", "PointMass.PointMass.loc.reshape"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "assert", "ii", "is", "None", "\n", "pp", "=", "np", ".", "prod", "(", "x", "==", "self", ".", "loc", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "axis", "=", "1", ")", "\n", "return", "np", ".", "log", "(", "pp", ")", "if", "log", "else", "pp", "# this happily returns -inf", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.PointMass.PointMass.gen": [[36, 39], ["numpy.tile", "PointMass.PointMass.loc.reshape"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ",", "seed", "=", "None", ")", ":", "\n", "        ", "return", "np", ".", "tile", "(", "self", ".", "loc", ".", "reshape", "(", "1", ",", "-", "1", ")", ",", "(", "n_samples", ",", "1", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.__init__": [[33, 42], ["copy.deepcopy"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "distribution", ",", "bijection", ",", "inverse_bijection", ",", "bijection_jac_logD", ",", "makecopy", "=", "False", ")", ":", "\n", "#assert isinstance(distribution, BaseDistribution) or isinstance(distribution, BaseMixture) \\", "\n", "#    or isinstance(distribution, MAFconditional)", "\n", "        ", "if", "makecopy", ":", "\n", "            ", "distribution", "=", "deepcopy", "(", "distribution", ")", "\n", "", "self", ".", "distribution", "=", "distribution", "\n", "self", ".", "bijection", ",", "self", ".", "inverse_bijection", "=", "bijection", ",", "inverse_bijection", "\n", "self", ".", "bijection_jac_logD", "=", "bijection_jac_logD", "\n", "self", ".", "ndim", "=", "distribution", ".", "ndim", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.mean": [[43, 47], ["numpy.nan"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "np", ".", "nan", "(", "self", ".", "ndim", ")", "# generally unknown", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.std": [[48, 52], ["numpy.nan"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "nan", "(", "self", ".", "ndim", ")", "# generally unknown", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.eval": [[53, 60], ["TransformedDistribution.TransformedDistribution.inverse_bijection", "TransformedDistribution.TransformedDistribution.distribution.eval", "TransformedDistribution.TransformedDistribution.bijection_jac_logD", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "assert", "ii", "is", "None", ",", "\"cannot marginalize transformed distributions\"", "\n", "x_original", "=", "self", ".", "inverse_bijection", "(", "x", ")", "\n", "logp_original", "=", "self", ".", "distribution", ".", "eval", "(", "x_original", ",", "log", "=", "True", ")", "\n", "logp", "=", "logp_original", "-", "self", ".", "bijection_jac_logD", "(", "x_original", ")", "# change of variables", "\n", "return", "logp", "if", "log", "else", "np", ".", "exp", "(", "logp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.gen": [[61, 65], ["TransformedDistribution.TransformedDistribution.distribution.gen", "TransformedDistribution.TransformedDistribution.bijection"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "samples", "=", "self", ".", "distribution", ".", "gen", "(", "n_samples", "=", "n_samples", ")", "\n", "return", "self", ".", "bijection", "(", "samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.reseed": [[66, 69], ["TransformedDistribution.TransformedDistribution.distribution.reseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Reseeds the distribution's RNG\"\"\"", "\n", "self", ".", "distribution", ".", "reseed", "(", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedDistribution.TransformedDistribution.gen_newseed": [[70, 73], ["TransformedDistribution.TransformedDistribution.distribution.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "return", "self", ".", "distribution", ".", "gen_newseed", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Discrete.Discrete.__init__": [[7, 23], ["delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.asarray", "numpy.isclose", "numpy.sum"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "p", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Discrete distribution\n\n        Parameters\n        ----------\n        p : list or np.array, 1d\n            Probabilities of elements, must sum to 1\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "1", ",", "seed", "=", "seed", ")", "\n", "\n", "p", "=", "np", ".", "asarray", "(", "p", ")", "\n", "assert", "p", ".", "ndim", "==", "1", ",", "'p must be a 1-d array'", "\n", "assert", "np", ".", "isclose", "(", "np", ".", "sum", "(", "p", ")", ",", "1", ")", ",", "'p must sum to 1'", "\n", "self", ".", "p", "=", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Discrete.Discrete.mean": [[24, 28], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Discrete.Discrete.std": [[29, 33], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Discrete.Discrete.eval": [[34, 37], ["NotImplementedError"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "raise", "NotImplementedError", "(", "\"To be implemented\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Discrete.Discrete.gen": [[38, 44], ["Discrete.Discrete.rng.rand", "numpy.sum().reshape", "numpy.cumsum", "numpy.sum"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ",", "seed", "=", "None", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "c", "=", "np", ".", "cumsum", "(", "self", ".", "p", "[", ":", "-", "1", "]", ")", "[", "np", ".", "newaxis", ",", ":", "]", "# cdf", "\n", "r", "=", "self", ".", "rng", ".", "rand", "(", "n_samples", ",", "1", ")", "\n", "return", "np", ".", "sum", "(", "(", "r", ">", "c", ")", ".", "astype", "(", "int", ")", ",", "axis", "=", "1", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.IndependentJoint.IndependentJoint.__init__": [[20, 44], ["numpy.sum", "numpy.zeros", "numpy.zeros", "numpy.append", "range", "BaseDistribution.BaseDistribution.__init__", "numpy.cumsum", "len", "numpy.arange", "numpy.arange", "isinstance"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["def", "__init__", "(", "self", ",", "dists", ",", "seed", "=", "None", ")", ":", "\n", "\n", "        ", "for", "d", "in", "dists", ":", "\n", "            ", "assert", "not", "isinstance", "(", "d", ",", "IndependentJoint", ")", ",", "\"IndependentJoint objects cannot be nested\"", "\n", "", "self", ".", "dists", "=", "[", "d", "for", "d", "in", "dists", "if", "d", ".", "ndim", ">", "0", "]", "\n", "self", ".", "dimlist", "=", "[", "d", ".", "ndim", "for", "d", "in", "self", ".", "dists", "]", "\n", "ndim", "=", "np", ".", "sum", "(", "self", ".", "dimlist", ")", "\n", "\n", "# self.dist_index_eachdim stores the index of the child distribution", "\n", "# for each dimension of the full distribution.", "\n", "self", ".", "dist_index_eachdim", "=", "np", ".", "zeros", "(", "ndim", ",", "dtype", "=", "int", ")", "\n", "# self.ii_full2child stores the index into the child distribution for", "\n", "# each index into the full distribution", "\n", "self", ".", "ii_full2child", "=", "np", ".", "zeros", "(", "ndim", ",", "dtype", "=", "int", ")", "\n", "\n", "# list of indices for the full distribution for each child distribution:", "\n", "self", ".", "ii_list_eachdist", "=", "[", "]", "\n", "csdims", "=", "np", ".", "append", "(", "0", ",", "np", ".", "cumsum", "(", "self", ".", "dimlist", ")", ")", "\n", "for", "j", "in", "range", "(", "len", "(", "self", ".", "dists", ")", ")", ":", "\n", "            ", "ii_child", "=", "np", ".", "arange", "(", "csdims", "[", "j", "]", ",", "csdims", "[", "j", "+", "1", "]", ")", "\n", "self", ".", "dist_index_eachdim", "[", "ii_child", "]", "=", "j", "\n", "self", ".", "ii_full2child", "[", "ii_child", "]", "=", "np", ".", "arange", "(", "self", ".", "dimlist", "[", "j", "]", ")", "\n", "", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "ndim", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.IndependentJoint.IndependentJoint.mean": [[45, 47], ["numpy.concatenate"], "methods", ["None"], ["", "def", "mean", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "concatenate", "(", "[", "d", ".", "mean", "for", "d", "in", "self", ".", "dists", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.IndependentJoint.IndependentJoint.std": [[48, 50], ["numpy.concatenate"], "methods", ["None"], ["", "def", "std", "(", "self", ")", ":", "\n", "        ", "return", "np", ".", "concatenate", "(", "[", "d", ".", "std", "for", "d", "in", "self", ".", "dists", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.IndependentJoint.IndependentJoint.eval": [[51, 84], ["numpy.sum", "numpy.atleast_1d", "enumerate", "numpy.split", "d.eval", "numpy.vstack", "numpy.exp", "numpy.flatnozero", "ds.append", "numpy.split.append", "numpy.cumsum", "zip", "is_childj.any", "ii_children.append", "ii_children.append", "numpy.diff"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "if", "ii", "is", "not", "None", ":", "\n", "            ", "ii", "=", "np", ".", "atleast_1d", "(", "ii", ")", "\n", "if", "ii", ".", "dtype", "==", "bool", ":", "# convert to array of indices", "\n", "                ", "assert", "ii", ".", "size", "==", "self", ".", "ndim", ",", "'incorrectly sized binary mask'", "\n", "ii", "=", "np", ".", "flatnozero", "(", "ii", ")", "\n", "", "assert", "(", "np", ".", "diff", "(", "ii", ")", ">", "0", ")", ".", "all", "(", ")", ",", "'ii must be increasing'", "\n", "assert", "(", "ii", ">=", "0", ")", ".", "all", "(", ")", "and", "(", "ii", "<", "self", ".", "ndim", ")", ".", "all", "(", ")", ",", "'invalid index'", "\n", "\n", "xsplit", ",", "ds", ",", "ii_children", "=", "[", "]", ",", "[", "]", ",", "[", "]", "\n", "for", "j", ",", "d", "in", "enumerate", "(", "self", ".", "dists", ")", ":", "\n", "# is_childj stores whether each element of ii is in child j", "\n", "                ", "is_childj", "=", "self", ".", "dist_index_eachdim", "[", "ii", "]", "==", "j", "\n", "if", "not", "is_childj", ".", "any", "(", ")", ":", "\n", "                    ", "continue", "\n", "", "ds", ".", "append", "(", "d", ")", "\n", "# ii_child stores indices into child distribution's dimensions", "\n", "ii_child", "=", "self", ".", "ii_full2child", "[", "ii", "[", "is_childj", "]", "]", "\n", "xsplit", ".", "append", "(", "x", "[", ":", ",", "is_childj", "]", ")", "\n", "if", "ii_child", ".", "size", "==", "self", ".", "dimlist", "[", "j", "]", ":", "\n", "                    ", "ii_children", ".", "append", "(", "None", ")", "# full child distribution", "\n", "", "else", ":", "\n", "                    ", "ii_children", ".", "append", "(", "ii_child", ")", "\n", "", "", "", "else", ":", "\n", "            ", "ds", "=", "self", ".", "dists", "\n", "xsplit", "=", "np", ".", "split", "(", "x", ",", "np", ".", "cumsum", "(", "self", ".", "dimlist", ")", ",", "axis", "=", "-", "1", ")", "\n", "ii_children", "=", "[", "None", "for", "d", "in", "ds", "]", "# full child distribution", "\n", "\n", "", "logps", "=", "[", "d", ".", "eval", "(", "x", ",", "ii", "=", "ii", ",", "log", "=", "True", ")", "\n", "for", "d", ",", "x", ",", "ii", "in", "zip", "(", "ds", ",", "xsplit", ",", "ii_children", ")", "]", "\n", "# each element of logps is a vector with one log prob per data point", "\n", "logp", "=", "np", ".", "sum", "(", "np", ".", "vstack", "(", "logps", ")", ",", "axis", "=", "0", ")", "\n", "return", "logp", "if", "log", "else", "np", ".", "exp", "(", "logp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.IndependentJoint.IndependentJoint.gen": [[85, 87], ["numpy.concatenate", "d.gen"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "return", "np", ".", "concatenate", "(", "[", "d", ".", "gen", "(", "n_samples", ")", "for", "d", "in", "self", ".", "dists", "]", ",", "axis", "=", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.IndependentJoint.IndependentJoint.reseed": [[88, 92], ["super().reseed", "d.reseed", "IndependentJoint.IndependentJoint.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "super", "(", ")", ".", "reseed", "(", "seed", ")", "\n", "for", "d", "in", "self", ".", "dists", ":", "\n", "            ", "d", ".", "reseed", "(", "self", ".", "gen_newseed", "(", ")", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Logistic.Logistic.__init__": [[7, 29], ["delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.atleast_1d", "numpy.atleast_1d", "numpy.full", "numpy.isfinite().all", "numpy.isfinite().all", "numpy.isreal().all", "numpy.isreal().all", "numpy.isfinite", "numpy.isfinite", "numpy.isreal", "numpy.isreal"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mu", "=", "0.0", ",", "s", "=", "1.0", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Distribution with independent dimensions and logistic marginals\n\n        Parameters\n        ---------\n        mu : list, or np.array, 1d\n            Means\n        s : list, or np.array, 1d\n            Scale factors\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "mu", ",", "s", "=", "np", ".", "atleast_1d", "(", "mu", ")", ",", "np", ".", "atleast_1d", "(", "s", ")", "\n", "if", "s", ".", "size", "==", "1", ":", "\n", "            ", "s", "=", "np", ".", "full", "(", "mu", ".", "size", ",", "s", "[", "0", "]", ")", "\n", "\n", "", "assert", "(", "s", ">", "0", ")", ".", "all", "(", ")", "and", "np", ".", "isfinite", "(", "s", ")", ".", "all", "(", ")", "and", "np", ".", "isfinite", "(", "mu", ")", ".", "all", "(", ")", "and", "np", ".", "isreal", "(", "s", ")", ".", "all", "(", ")", "and", "np", ".", "isreal", "(", "mu", ")", ".", "all", "(", ")", ",", "\"bad params\"", "\n", "assert", "s", ".", "ndim", "==", "1", "and", "mu", ".", "ndim", "==", "1", "and", "mu", ".", "size", "==", "s", ".", "size", ",", "\"bad sizes\"", "\n", "self", ".", "mu", ",", "self", ".", "s", "=", "mu", ",", "s", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "mu", ".", "size", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Logistic.Logistic.mean": [[30, 34], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Logistic.Logistic.std": [[35, 39], ["numpy.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "self", ".", "s", "*", "np", ".", "pi", "/", "np", ".", "sqrt", "(", "3.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Logistic.Logistic.eval": [[40, 54], ["numpy.atleast_2d", "logp_eachdim[].sum", "numpy.arange", "numpy.exp", "numpy.log", "numpy.log", "numpy.exp"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "assert", "x", ".", "shape", "[", "1", "]", "==", "self", ".", "ndim", ",", "\"incorrect data dimension\"", "\n", "\n", "if", "ii", "is", "None", ":", "\n", "            ", "ii", "=", "np", ".", "arange", "(", "self", ".", "ndim", ")", "\n", "\n", "", "z", "=", "(", "x", "-", "self", ".", "mu", ")", "/", "self", ".", "s", "\n", "logp_eachdim", "=", "-", "z", "-", "np", ".", "log", "(", "self", ".", "s", ")", "-", "2.0", "*", "np", ".", "log", "(", "1.0", "+", "np", ".", "exp", "(", "-", "z", ")", ")", "\n", "logp", "=", "logp_eachdim", "[", ":", ",", "ii", "]", ".", "sum", "(", "axis", "=", "1", ")", "\n", "\n", "return", "logp", "if", "log", "else", "np", ".", "exp", "(", "logp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Logistic.Logistic.gen": [[55, 60], ["numpy.random.uniform", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "u", "=", "np", ".", "random", ".", "uniform", "(", "size", "=", "(", "n_samples", ",", "self", ".", "ndim", ")", ")", "\n", "return", "self", ".", "mu", "+", "self", ".", "s", "*", "(", "np", ".", "log", "(", "u", ")", "-", "np", ".", "log", "(", "1", "-", "u", ")", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal.__init__": [[9, 130], ["numpy.all", "delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.asarray", "numpy.zeros_like", "numpy.atleast_1d", "numpy.ones_like", "numpy.atleast_1d", "numpy.zeros_like", "numpy.atleast_1d", "numpy.in1d", "numpy.asarray", "numpy.linalg.cholesky", "numpy.linalg.inv", "numpy.dot", "numpy.dot", "numpy.asarray", "ValueError", "numpy.unique", "numpy.arange", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.sum", "numpy.asarray", "numpy.dot", "numpy.linalg.inv", "numpy.dot", "numpy.dot", "numpy.asarray", "numpy.linalg.cholesky", "numpy.linalg.inv", "numpy.dot", "numpy.linalg.solve", "numpy.log", "numpy.sum", "numpy.asarray", "numpy.linalg.inv", "numpy.dot", "ValueError", "numpy.sum", "numpy.asarray", "numpy.dot", "numpy.linalg.inv", "numpy.dot", "numpy.linalg.solve", "numpy.diagonal", "numpy.log", "numpy.linalg.cholesky", "numpy.sum", "numpy.log", "numpy.sum", "numpy.asarray", "numpy.linalg.inv", "numpy.dot", "ValueError", "numpy.diagonal", "numpy.log", "numpy.diagonal", "numpy.log", "numpy.linalg.cholesky", "numpy.sum", "numpy.diagonal", "numpy.diagonal", "numpy.log", "numpy.diagonal"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["    ", "def", "__init__", "(", "self", ",", "m", "=", "None", ",", "P", "=", "None", ",", "U", "=", "None", ",", "S", "=", "None", ",", "Pm", "=", "None", ",", "\n", "upper", "=", "None", ",", "lower", "=", "None", ",", "flags", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"multivariate normals with some entries in log- and/or logit-space.\n\n        Initialize the pdf given a valid combination of its parameters.\n        Valid combinations are: m-P, m-U, m-S, Pm-P, Pm-U, Pm-S\n\n        Parameters\n        ----------\n        m : list or np.array, 1d\n            Mean\n        P : list or np.array, 2d\n            Precision\n        U : list or np.array, 2d\n            Upper triangular precision factor such that U'U = P\n        S : list or np.array, 2d\n            Covariance\n        C : list or np.array, 2d\n            Upper or lower triangular covariance factor, in any case S = C'C\n        Pm : list or np.array, 1d\n            Precision times mean such that P*m = Pm\n        flags: list or np.array, 1d\n            List of flags for each variable whether it is untransformed (=0),\n            log-transformed (=1) or logit-transformed (=2).\n        lower: list or np.array, 1d\n            Lower bounds for logit-box. Defaults to 0 for each parameter.\n        upper: list or np.array, 1d\n            Upper bounds for logit-box. Defaults to 1 for each parameter.\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "\n", "assert", "m", "is", "None", "or", "np", ".", "asarray", "(", "m", ")", ".", "ndim", "==", "1", "\n", "assert", "P", "is", "None", "or", "np", ".", "asarray", "(", "P", ")", ".", "ndim", "==", "2", "\n", "assert", "U", "is", "None", "or", "np", ".", "asarray", "(", "U", ")", ".", "ndim", "==", "2", "\n", "assert", "S", "is", "None", "or", "np", ".", "asarray", "(", "S", ")", ".", "ndim", "==", "2", "\n", "assert", "Pm", "is", "None", "or", "np", ".", "asarray", "(", "Pm", ")", ".", "ndim", "==", "1", "\n", "\n", "if", "m", "is", "not", "None", ":", "\n", "            ", "m", "=", "np", ".", "asarray", "(", "m", ")", "\n", "self", ".", "m", "=", "m", "\n", "ndim", "=", "self", ".", "m", ".", "size", "\n", "\n", "if", "P", "is", "not", "None", ":", "\n", "                ", "P", "=", "np", ".", "asarray", "(", "P", ")", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "P", ")", "# P=LL' (lower triag)", "\n", "self", ".", "P", "=", "P", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "L", ")", "# C is lower triangular here", "\n", "# S = C'C = L^{-1}^T L^{-1} = (LL^T)^{-1}", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "L", ")", ")", ")", "\n", "\n", "", "elif", "U", "is", "not", "None", ":", "\n", "                ", "U", "=", "np", ".", "asarray", "(", "U", ")", "\n", "self", ".", "P", "=", "np", ".", "dot", "(", "U", ".", "T", ",", "U", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "U", ".", "T", ")", "# C is lower triangular here", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "self", ".", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "U", ")", ")", ")", "\n", "\n", "", "elif", "S", "is", "not", "None", ":", "\n", "                ", "S", "=", "np", ".", "asarray", "(", "S", ")", "\n", "self", ".", "P", "=", "np", ".", "linalg", ".", "inv", "(", "S", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "cholesky", "(", "S", ")", ".", "T", "# C is upper triangular here", "\n", "self", ".", "S", "=", "S", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "self", ".", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "-", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "self", ".", "C", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "elif", "Pm", "is", "not", "None", ":", "\n", "            ", "Pm", "=", "np", ".", "asarray", "(", "Pm", ")", "\n", "self", ".", "Pm", "=", "Pm", "\n", "ndim", "=", "self", ".", "Pm", ".", "size", "\n", "\n", "if", "P", "is", "not", "None", ":", "\n", "                ", "P", "=", "np", ".", "asarray", "(", "P", ")", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "P", ")", "\n", "# L = np.linalg.cholesky(P + 0.001*np.identity(P.shape[0]))", "\n", "self", ".", "P", "=", "P", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "L", ")", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "m", "=", "np", ".", "linalg", ".", "solve", "(", "P", ",", "Pm", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "L", ")", ")", ")", "\n", "\n", "", "elif", "U", "is", "not", "None", ":", "\n", "                ", "U", "=", "np", ".", "asarray", "(", "U", ")", "\n", "self", ".", "P", "=", "np", ".", "dot", "(", "U", ".", "T", ",", "U", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "U", ".", "T", ")", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "m", "=", "np", ".", "linalg", ".", "solve", "(", "self", ".", "P", ",", "Pm", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "U", ")", ")", ")", "\n", "\n", "", "elif", "S", "is", "not", "None", ":", "\n", "                ", "S", "=", "np", ".", "asarray", "(", "S", ")", "\n", "self", ".", "P", "=", "np", ".", "linalg", ".", "inv", "(", "S", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "cholesky", "(", "S", ")", ".", "T", "\n", "self", ".", "S", "=", "S", "\n", "self", ".", "m", "=", "np", ".", "dot", "(", "S", ",", "Pm", ")", "\n", "self", ".", "logdetP", "=", "-", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "self", ".", "C", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Mean information missing'", ")", "\n", "\n", "", "self", ".", "lower", "=", "np", ".", "zeros_like", "(", "m", ")", "if", "lower", "is", "None", "else", "np", ".", "atleast_1d", "(", "lower", ")", "\n", "self", ".", "upper", "=", "np", ".", "ones_like", "(", "m", ")", "if", "upper", "is", "None", "else", "np", ".", "atleast_1d", "(", "upper", ")", "\n", "\n", "assert", "self", ".", "lower", ".", "ndim", "==", "self", ".", "upper", ".", "ndim", "\n", "assert", "self", ".", "lower", ".", "ndim", "==", "1", "\n", "\n", "self", ".", "flags", "=", "np", ".", "zeros_like", "(", "m", ")", "if", "flags", "is", "None", "else", "np", ".", "atleast_1d", "(", "flags", ")", "\n", "\n", "assert", "self", ".", "flags", ".", "ndim", "==", "1", "\n", "assert", "np", ".", "all", "(", "np", ".", "in1d", "(", "np", ".", "unique", "(", "self", ".", "flags", ")", ",", "np", ".", "arange", "(", "3", ")", ")", ")", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal.mean": [[131, 135], ["numpy.ones_like().reshape", "numpy.ones_like"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means - not analytic for logit-normal!\"\"\"", "\n", "return", "np", ".", "nan", "*", "np", ".", "ones_like", "(", "self", ".", "m", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal.std": [[136, 140], ["numpy.ones_like().reshape", "numpy.ones_like", "numpy.diag"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals - not analytic for logit-normal!\"\"\"", "\n", "return", "np", ".", "nan", "*", "np", ".", "ones_like", "(", "np", ".", "diag", "(", "self", ".", "S", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal.eval": [[141, 173], ["x.reshape.reshape.reshape", "TransformedNormal.TransformedNormal._finv", "TransformedNormal.TransformedNormal._logZ", "TransformedNormal.TransformedNormal._finv", "numpy.exp", "numpy.arange", "numpy.sum", "numpy.arange", "numpy.linalg.matrix_rank", "len", "scipy.stats.multivariate_normal.logpdf", "TransformedNormal.TransformedNormal._logZ", "ValueError", "numpy.log", "numpy.array", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._finv", "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal._logZ", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._finv", "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal._logZ", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseDistribution.py for docstring        ", "\n", "\n", "        ", "if", "x", ".", "ndim", "==", "1", ":", "\n", "            ", "x", "=", "x", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "\n", "\n", "", "if", "ii", "is", "None", ":", "\n", "\n", "            ", "finv", "=", "self", ".", "_finv", "(", "x", ",", "np", ".", "arange", "(", "self", ".", "ndim", ")", ")", "\n", "xm", "=", "finv", "-", "self", ".", "m", "\n", "lp", "=", "-", "np", ".", "sum", "(", "np", ".", "dot", "(", "xm", ",", "self", ".", "P", ")", "*", "xm", ",", "axis", "=", "1", ")", "\n", "lp", "+=", "self", ".", "logdetP", "-", "self", ".", "ndim", "*", "np", ".", "log", "(", "2.0", "*", "np", ".", "pi", ")", "\n", "lp", "*=", "0.5", "\n", "lp", "-=", "self", ".", "_logZ", "(", "x", ",", "np", ".", "arange", "(", "self", ".", "ndim", ")", ")", "\n", "\n", "", "else", ":", "\n", "\n", "            ", "finv", "=", "self", ".", "_finv", "(", "x", ",", "ii", ")", "\n", "m", "=", "self", ".", "m", "[", "ii", "]", "\n", "S", "=", "self", ".", "S", "[", "ii", "]", "[", ":", ",", "ii", "]", "\n", "\n", "if", "np", ".", "linalg", ".", "matrix_rank", "(", "S", ")", "==", "len", "(", "S", "[", ":", ",", "0", "]", ")", ":", "\n", "                ", "lp", "=", "scipy", ".", "stats", ".", "multivariate_normal", ".", "logpdf", "(", "finv", ",", "m", ",", "S", ",", "allow_singular", "=", "True", ")", "\n", "lp", "=", "np", ".", "array", "(", "[", "lp", "]", ")", "if", "x", ".", "shape", "[", "0", "]", "==", "1", "else", "lp", "\n", "lp", "-=", "self", ".", "_logZ", "(", "x", ",", "ii", ")", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Rank deficiency in covariance matrix'", ")", "\n", "\n", "", "", "res", "=", "lp", "if", "log", "else", "np", ".", "exp", "(", "lp", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal.gen": [[174, 180], ["TransformedNormal.TransformedNormal.rng.randn", "TransformedNormal.TransformedNormal._f", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._f"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "z", "=", "self", ".", "rng", ".", "randn", "(", "n_samples", ",", "self", ".", "ndim", ")", "\n", "samples", "=", "np", ".", "dot", "(", "z", ",", "self", ".", "C", ")", "+", "self", ".", "m", "\n", "return", "self", ".", "_f", "(", "samples", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal._f": [[181, 194], ["x.copy", "numpy.exp", "numpy.where", "numpy.where", "numpy.exp"], "methods", ["None"], ["", "def", "_f", "(", "self", ",", "x", ")", ":", "\n", "\n", "        ", "y", "=", "x", ".", "copy", "(", ")", "\n", "\n", "# log-transformed entries", "\n", "idx", "=", "np", ".", "where", "(", "self", ".", "flags", "==", "1.", ")", "[", "0", "]", "\n", "y", "[", ":", ",", "idx", "]", "=", "np", ".", "exp", "(", "y", "[", ":", ",", "idx", "]", ")", "\n", "\n", "# logit-transformed entries", "\n", "idx", "=", "np", ".", "where", "(", "self", ".", "flags", "==", "2.", ")", "[", "0", "]", "\n", "y", "[", ":", ",", "idx", "]", "=", "(", "self", ".", "upper", "[", "idx", "]", "-", "self", ".", "lower", "[", "idx", "]", ")", "/", "(", "1.", "+", "np", ".", "exp", "(", "-", "y", "[", ":", ",", "idx", "]", ")", ")", "+", "self", ".", "lower", "[", "idx", "]", "\n", "\n", "return", "y", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal._finv": [[195, 214], ["y.copy", "numpy.intersect1d", "numpy.intersect1d", "numpy.where", "len", "numpy.log", "numpy.where", "len", "numpy.where", "numpy.in1d", "numpy.where", "numpy.in1d", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "_finv", "(", "self", ",", "y", ",", "ii", ")", ":", "\n", "\n", "        ", "x", "=", "y", ".", "copy", "(", ")", "\n", "\n", "#ii = np.arange(self.ndim) if ii is None else ii", "\n", "\n", "ii_", "=", "np", ".", "intersect1d", "(", "np", ".", "where", "(", "self", ".", "flags", "==", "1.", ")", "[", "0", "]", ",", "ii", ")", "\n", "idx", "=", "np", ".", "where", "(", "np", ".", "in1d", "(", "ii", ",", "ii_", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "idx", ")", ">", "0", ":", "\n", "            ", "x", "[", ":", ",", "idx", "]", "=", "np", ".", "log", "(", "x", "[", ":", ",", "idx", "]", ")", "\n", "\n", "# logit-transformed entries", "\n", "", "ii_", "=", "np", ".", "intersect1d", "(", "np", ".", "where", "(", "self", ".", "flags", "==", "2.", ")", "[", "0", "]", ",", "ii", ")", "\n", "idx", "=", "np", ".", "where", "(", "np", ".", "in1d", "(", "ii", ",", "ii_", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "idx", ")", ">", "0", ":", "\n", "            ", "x", "[", ":", ",", "idx", "]", "=", "(", "x", "[", ":", ",", "idx", "]", "-", "self", ".", "lower", "[", "ii_", "]", ")", "/", "(", "self", ".", "upper", "[", "ii_", "]", "-", "self", ".", "lower", "[", "ii_", "]", ")", "\n", "x", "[", ":", ",", "idx", "]", "=", "np", ".", "log", "(", "x", "[", ":", ",", "idx", "]", ")", "-", "np", ".", "log", "(", "1.", "-", "x", "[", ":", ",", "idx", "]", ")", "\n", "\n", "", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.TransformedNormal.TransformedNormal._logZ": [[215, 234], ["numpy.intersect1d", "numpy.intersect1d", "numpy.where", "len", "numpy.sum", "numpy.where", "len", "numpy.sum", "numpy.sum", "numpy.where", "numpy.in1d", "numpy.log", "numpy.where", "numpy.in1d", "numpy.log", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "_logZ", "(", "self", ",", "x", ",", "ii", ")", ":", "\n", "\n", "        ", "logZ", "=", "0.", "\n", "\n", "# log-transformed entries", "\n", "ii_", "=", "np", ".", "intersect1d", "(", "np", ".", "where", "(", "self", ".", "flags", "==", "1.", ")", "[", "0", "]", ",", "ii", ")", "\n", "idx", "=", "np", ".", "where", "(", "np", ".", "in1d", "(", "ii", ",", "ii_", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "idx", ")", ">", "0", ":", "\n", "            ", "logZ", "+=", "np", ".", "sum", "(", "np", ".", "log", "(", "x", "[", ":", ",", "idx", "]", ")", ",", "axis", "=", "1", ")", "\n", "\n", "# logit-transformed entries", "\n", "", "ii_", "=", "np", ".", "intersect1d", "(", "np", ".", "where", "(", "self", ".", "flags", "==", "2.", ")", "[", "0", "]", ",", "ii", ")", "\n", "idx", "=", "np", ".", "where", "(", "np", ".", "in1d", "(", "ii", ",", "ii_", ")", ")", "[", "0", "]", "\n", "if", "len", "(", "idx", ")", ">", "0", ":", "\n", "            ", "x_", "=", "(", "x", "[", ":", ",", "idx", "]", "-", "self", ".", "lower", "[", "ii_", "]", ")", "/", "(", "self", ".", "upper", "[", "ii_", "]", "-", "self", ".", "lower", "[", "ii_", "]", ")", "\n", "logZ", "+=", "np", ".", "sum", "(", "np", ".", "log", "(", "x_", "*", "(", "1.", "-", "x_", ")", ")", ",", "axis", "=", "1", ")", "\n", "logZ", "+=", "np", ".", "sum", "(", "np", ".", "log", "(", "self", ".", "upper", "[", "ii_", "]", "-", "self", ".", "lower", "[", "ii_", "]", ")", ")", "# account for overall volume", "\n", "\n", "", "return", "logZ", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Poisson.Poisson.__init__": [[7, 25], ["delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.atleast_1d", "scipy.stats.poisson"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "mu", "=", "0.", ",", "offset", "=", "0.", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Univariate (!) Poisson distribution\n        Parameters\n        ----------\n        mu: shape parameter of the Poisson (Poisson rate)\n        offset: shift in the mean parameter, see scipy.stats.Poisson documentation. \n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "1", ",", "seed", "=", "seed", ")", "\n", "\n", "mu", "=", "np", ".", "atleast_1d", "(", "mu", ")", "\n", "assert", "mu", ".", "ndim", "==", "1", ",", "'mu must be a 1-d array'", "\n", "assert", "offset", ">=", "0", ",", "'offset must not be negative'", "\n", "\n", "self", ".", "mu", "=", "mu", "\n", "self", ".", "offset", "=", "offset", "\n", "self", ".", "_poisson", "=", "poisson", "(", "mu", "=", "mu", ",", "loc", "=", "offset", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Poisson.Poisson.mean": [[26, 30], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "mu", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Poisson.Poisson.std": [[31, 35], ["numpy.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "sqrt", "(", "self", ".", "mu", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Poisson.Poisson.eval": [[36, 49], ["numpy.atleast_2d", "res.reshape", "Poisson.Poisson._poisson.logpmf", "Poisson.Poisson._poisson.pmf"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# univariate distribution only, i.e. ii=[0] in any case", "\n", "        ", "assert", "ii", "is", "None", ",", "'this is a univariate Poisson, ii must be None.'", "\n", "\n", "# x should have a second dim with length 1, not more", "\n", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "assert", "x", ".", "shape", "[", "1", "]", "==", "1", ",", "'x needs second dim'", "\n", "assert", "not", "x", ".", "ndim", ">", "2", ",", "'no more than 2 dims in x'", "\n", "\n", "res", "=", "self", ".", "_poisson", ".", "logpmf", "(", "x", ")", "if", "log", "else", "self", ".", "_poisson", ".", "pmf", "(", "x", ")", "\n", "# reshape to (nbatch, )", "\n", "return", "res", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Poisson.Poisson.gen": [[50, 56], ["Poisson.Poisson._poisson.rvs"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ",", "seed", "=", "None", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "\n", "        ", "x", "=", "self", ".", "_poisson", ".", "rvs", "(", "random_state", "=", "self", ".", "rng", ",", "size", "=", "(", "n_samples", ",", "self", ".", "ndim", ")", ")", "\n", "return", "x", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.__init__": [[8, 28], ["numpy.random.RandomState", "numpy.random.RandomState"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "ndim", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Abstract base class for distributions\n\n        Distributions must at least implement abstract properties and methods of\n        this class.\n\n        Parameters\n        ----------\n        ndim : int\n            Number of ndimensions of the distribution\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "self", ".", "ndim", "=", "ndim", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.mean": [[29, 33], ["None"], "methods", ["None"], ["", "", "@", "abc", ".", "abstractproperty", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.std": [[34, 38], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractproperty", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.eval": [[39, 58], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "\"\"\"Method to evaluate pdf\n\n        Parameters\n        ----------\n        x : int or list or np.array\n            Rows are inputs to evaluate at\n        ii : list\n            A list of indices specifying which marginal to evaluate.\n            If None, the joint pdf is evaluated\n        log : bool, defaulting to True\n            If True, the log pdf is evaluated\n\n        Returns\n        -------\n        scalar\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.gen": [[59, 73], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "\"\"\"Method to generate samples\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate\n\n        Returns\n        -------\n        n_samples x self.ndim\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.reseed": [[74, 78], ["BaseDistribution.BaseDistribution.rng.seed"], "methods", ["None"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Reseeds the distribution's RNG\"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.BaseDistribution.BaseDistribution.gen_newseed": [[79, 85], ["BaseDistribution.BaseDistribution.rng.randint"], "methods", ["None"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Uniform.Uniform.__init__": [[7, 26], ["numpy.atleast_1d", "numpy.atleast_1d", "delfi.distribution.BaseDistribution.BaseDistribution.__init__", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "lower", "=", "0.", ",", "upper", "=", "1.", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Uniform distribution\n\n        Parameters\n        ----------\n        lower : list, or np.array, 1d\n            Lower bound(s)\n        upper : list, or np.array, 1d\n            Upper bound(s)\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "self", ".", "lower", "=", "np", ".", "atleast_1d", "(", "lower", ")", "\n", "self", ".", "upper", "=", "np", ".", "atleast_1d", "(", "upper", ")", "\n", "\n", "assert", "self", ".", "lower", ".", "ndim", "==", "self", ".", "upper", ".", "ndim", "\n", "assert", "self", ".", "lower", ".", "ndim", "==", "1", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "len", "(", "self", ".", "lower", ")", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Uniform.Uniform.mean": [[27, 31], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "(", "0.5", "*", "(", "self", ".", "lower", "+", "self", ".", "upper", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Uniform.Uniform.std": [[32, 36], ["numpy.sqrt().reshape", "numpy.sqrt"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "sqrt", "(", "1", "/", "12.", "*", "(", "self", ".", "upper", "-", "self", ".", "lower", ")", "**", "2", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Uniform.Uniform.eval": [[37, 69], ["numpy.arange", "numpy.atleast_1d", "numpy.atleast_2d.reshape", "numpy.atleast_2d", "numpy.prod", "numpy.ones", "ind.any", "ValueError", "numpy.log", "numpy.prod"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "if", "ii", "is", "None", ":", "\n", "            ", "ii", "=", "np", ".", "arange", "(", "self", ".", "ndim", ")", "\n", "", "else", ":", "\n", "            ", "ii", "=", "np", ".", "atleast_1d", "(", "ii", ")", "\n", "\n", "", "if", "x", ".", "ndim", "==", "1", "and", "ii", ".", "size", "==", "1", ":", "\n", "            ", "x", "=", "x", ".", "reshape", "(", "-", "1", ",", "1", ")", "\n", "", "else", ":", "\n", "            ", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "\n", "", "assert", "x", ".", "ndim", "==", "2", "and", "ii", ".", "ndim", "==", "1", "\n", "assert", "x", ".", "shape", "[", "1", "]", "==", "ii", ".", "size", "\n", "\n", "N", "=", "x", ".", "shape", "[", "0", "]", "\n", "\n", "p", "=", "1.0", "/", "np", ".", "prod", "(", "self", ".", "upper", "[", "ii", "]", "-", "self", ".", "lower", "[", "ii", "]", ")", "\n", "p", "=", "p", "*", "np", ".", "ones", "(", "(", "N", ",", ")", ")", "# broadcasting", "\n", "\n", "# truncation of density", "\n", "ind", "=", "(", "x", ">", "self", ".", "lower", "[", "ii", "]", ")", "&", "(", "x", "<", "self", ".", "upper", "[", "ii", "]", ")", "\n", "p", "[", "np", ".", "prod", "(", "ind", ",", "axis", "=", "1", ")", "==", "0", "]", "=", "0", "\n", "\n", "if", "log", ":", "\n", "            ", "if", "ind", ".", "any", "(", ")", "==", "False", ":", "\n", "                ", "raise", "ValueError", "(", "'log probability not defined outside of truncation'", ")", "\n", "", "else", ":", "\n", "                ", "return", "np", ".", "log", "(", "p", ")", "\n", "", "", "else", ":", "\n", "            ", "return", "p", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Uniform.Uniform.gen": [[70, 75], ["Uniform.Uniform.rng.rand"], "methods", ["None"], ["", "", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "ms", "=", "self", ".", "rng", ".", "rand", "(", "n_samples", ",", "self", ".", "ndim", ")", "*", "(", "self", ".", "upper", "-", "self", ".", "lower", ")", "+", "self", ".", "lower", "\n", "return", "ms", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__init__": [[9, 115], ["delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.asarray", "numpy.asarray", "numpy.linalg.cholesky", "numpy.linalg.inv", "numpy.dot", "numpy.dot", "numpy.asarray", "ValueError", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.asarray", "numpy.sum", "numpy.asarray", "numpy.dot", "numpy.linalg.inv", "numpy.dot", "numpy.dot", "numpy.asarray", "numpy.linalg.cholesky", "numpy.linalg.inv", "numpy.dot", "numpy.linalg.solve", "numpy.log", "numpy.sum", "numpy.asarray", "numpy.linalg.inv", "numpy.dot", "ValueError", "numpy.sum", "numpy.asarray", "numpy.dot", "numpy.linalg.inv", "numpy.dot", "numpy.linalg.solve", "numpy.diagonal", "numpy.log", "numpy.linalg.cholesky", "numpy.sum", "numpy.log", "numpy.sum", "numpy.asarray", "numpy.linalg.inv", "numpy.dot", "ValueError", "numpy.diagonal", "numpy.log", "numpy.diagonal", "numpy.log", "numpy.linalg.cholesky", "numpy.sum", "numpy.diagonal", "numpy.diagonal", "numpy.log", "numpy.diagonal"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["    ", "def", "__init__", "(", "self", ",", "m", "=", "None", ",", "P", "=", "None", ",", "U", "=", "None", ",", "S", "=", "None", ",", "Pm", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Gaussian distribution\n\n        Initialize a gaussian pdf given a valid combination of its parameters.\n        Valid combinations are: m-P, m-U, m-S, Pm-P, Pm-U, Pm-S\n\n        Focus is on efficient multiplication, division and sampling.\n\n        Parameters\n        ----------\n        m : list or np.array, 1d\n            Mean\n        P : list or np.array, 2d\n            Precision\n        U : list or np.array, 2d\n            Upper triangular precision factor such that U'U = P\n        S : list or np.array, 2d\n            Covariance\n        C : list or np.array, 2d\n            Upper or lower triangular covariance factor, in any case S = C'C\n        Pm : list or np.array, 1d\n            Precision times mean such that P*m = Pm\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "assert", "m", "is", "None", "or", "np", ".", "asarray", "(", "m", ")", ".", "ndim", "==", "1", "\n", "assert", "P", "is", "None", "or", "np", ".", "asarray", "(", "P", ")", ".", "ndim", "==", "2", "\n", "assert", "U", "is", "None", "or", "np", ".", "asarray", "(", "U", ")", ".", "ndim", "==", "2", "\n", "assert", "S", "is", "None", "or", "np", ".", "asarray", "(", "S", ")", ".", "ndim", "==", "2", "\n", "assert", "Pm", "is", "None", "or", "np", ".", "asarray", "(", "Pm", ")", ".", "ndim", "==", "1", "\n", "\n", "self", ".", "__div__", "=", "self", ".", "__truediv__", "\n", "self", ".", "__idiv__", "=", "self", ".", "__itruediv__", "\n", "\n", "if", "m", "is", "not", "None", ":", "\n", "            ", "m", "=", "np", ".", "asarray", "(", "m", ")", "\n", "self", ".", "m", "=", "m", "\n", "ndim", "=", "self", ".", "m", ".", "size", "\n", "\n", "if", "P", "is", "not", "None", ":", "\n", "                ", "P", "=", "np", ".", "asarray", "(", "P", ")", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "P", ")", "# P=LL' (lower triag)", "\n", "self", ".", "P", "=", "P", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "L", ")", "# C is lower triangular here", "\n", "# S = C'C = L^{-1}^T L^{-1} = (LL^T)^{-1}", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "L", ")", ")", ")", "\n", "\n", "", "elif", "U", "is", "not", "None", ":", "\n", "                ", "U", "=", "np", ".", "asarray", "(", "U", ")", "\n", "self", ".", "P", "=", "np", ".", "dot", "(", "U", ".", "T", ",", "U", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "U", ".", "T", ")", "# C is lower triangular here", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "self", ".", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "U", ")", ")", ")", "\n", "\n", "", "elif", "S", "is", "not", "None", ":", "\n", "                ", "S", "=", "np", ".", "asarray", "(", "S", ")", "\n", "self", ".", "P", "=", "np", ".", "linalg", ".", "inv", "(", "S", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "cholesky", "(", "S", ")", ".", "T", "# C is upper triangular here", "\n", "self", ".", "S", "=", "S", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "self", ".", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "-", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "self", ".", "C", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "elif", "Pm", "is", "not", "None", ":", "\n", "            ", "Pm", "=", "np", ".", "asarray", "(", "Pm", ")", "\n", "self", ".", "Pm", "=", "Pm", "\n", "ndim", "=", "self", ".", "Pm", ".", "size", "\n", "\n", "if", "P", "is", "not", "None", ":", "\n", "                ", "P", "=", "np", ".", "asarray", "(", "P", ")", "\n", "L", "=", "np", ".", "linalg", ".", "cholesky", "(", "P", ")", "\n", "# L = np.linalg.cholesky(P + 0.001*np.identity(P.shape[0]))", "\n", "self", ".", "P", "=", "P", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "L", ")", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "m", "=", "np", ".", "linalg", ".", "solve", "(", "P", ",", "Pm", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "L", ")", ")", ")", "\n", "\n", "", "elif", "U", "is", "not", "None", ":", "\n", "                ", "U", "=", "np", ".", "asarray", "(", "U", ")", "\n", "self", ".", "P", "=", "np", ".", "dot", "(", "U", ".", "T", ",", "U", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "inv", "(", "U", ".", "T", ")", "\n", "self", ".", "S", "=", "np", ".", "dot", "(", "self", ".", "C", ".", "T", ",", "self", ".", "C", ")", "\n", "self", ".", "m", "=", "np", ".", "linalg", ".", "solve", "(", "self", ".", "P", ",", "Pm", ")", "\n", "self", ".", "logdetP", "=", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "U", ")", ")", ")", "\n", "\n", "", "elif", "S", "is", "not", "None", ":", "\n", "                ", "S", "=", "np", ".", "asarray", "(", "S", ")", "\n", "self", ".", "P", "=", "np", ".", "linalg", ".", "inv", "(", "S", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "cholesky", "(", "S", ")", ".", "T", "\n", "self", ".", "S", "=", "S", "\n", "self", ".", "m", "=", "np", ".", "dot", "(", "S", ",", "Pm", ")", "\n", "self", ".", "logdetP", "=", "-", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "self", ".", "C", ")", ")", ")", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Mean information missing'", ")", "\n", "\n", "", "super", "(", ")", ".", "__init__", "(", "ndim", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.mean": [[116, 120], ["Gaussian.Gaussian.m.reshape"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "m", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.std": [[121, 125], ["numpy.sqrt().reshape", "numpy.sqrt", "numpy.diag"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "sqrt", "(", "np", ".", "diag", "(", "self", ".", "S", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__mul__": [[126, 134], ["isinstance", "Gaussian.Gaussian"], "methods", ["None"], ["", "def", "__mul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Multiply with another Gaussian\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "P", "=", "self", ".", "P", "+", "other", ".", "P", "\n", "Pm", "=", "self", ".", "Pm", "+", "other", ".", "Pm", "\n", "\n", "return", "Gaussian", "(", "P", "=", "P", ",", "Pm", "=", "Pm", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__imul__": [[135, 149], ["isinstance"], "methods", ["None"], ["", "def", "__imul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Incrementally multiply with another Gaussian\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "res", "=", "self", "*", "other", "\n", "\n", "self", ".", "m", "=", "res", ".", "m", "\n", "self", ".", "P", "=", "res", ".", "P", "\n", "self", ".", "C", "=", "res", ".", "C", "\n", "self", ".", "S", "=", "res", ".", "S", "\n", "self", ".", "Pm", "=", "res", ".", "Pm", "\n", "self", ".", "logdetP", "=", "res", ".", "logdetP", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__truediv__": [[150, 160], ["isinstance", "Gaussian.Gaussian"], "methods", ["None"], ["", "def", "__truediv__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Divide by another Gaussian\n\n        Note that the resulting Gaussian might be improper.\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "P", "=", "self", ".", "P", "-", "other", ".", "P", "\n", "Pm", "=", "self", ".", "Pm", "-", "other", ".", "Pm", "\n", "\n", "return", "Gaussian", "(", "P", "=", "P", ",", "Pm", "=", "Pm", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__itruediv__": [[161, 177], ["isinstance"], "methods", ["None"], ["", "def", "__itruediv__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Incrementally divide by another Gaussian\n\n        Note that the resulting Gaussian might be improper.\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "res", "=", "self", "/", "other", "\n", "\n", "self", ".", "m", "=", "res", ".", "m", "\n", "self", ".", "P", "=", "res", ".", "P", "\n", "self", ".", "C", "=", "res", ".", "C", "\n", "self", ".", "S", "=", "res", ".", "S", "\n", "self", ".", "Pm", "=", "res", ".", "Pm", "\n", "self", ".", "logdetP", "=", "res", ".", "logdetP", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__pow__": [[178, 184], ["Gaussian.Gaussian"], "methods", ["None"], ["", "def", "__pow__", "(", "self", ",", "power", ",", "modulo", "=", "None", ")", ":", "\n", "        ", "\"\"\"Raise Gaussian to a power and get another Gaussian\"\"\"", "\n", "P", "=", "power", "*", "self", ".", "P", "\n", "Pm", "=", "power", "*", "self", ".", "Pm", "\n", "\n", "return", "Gaussian", "(", "P", "=", "P", ",", "Pm", "=", "Pm", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.__ipow__": [[185, 197], ["None"], "methods", ["None"], ["", "def", "__ipow__", "(", "self", ",", "power", ")", ":", "\n", "        ", "\"\"\"Incrementally raise gaussian to a power\"\"\"", "\n", "res", "=", "self", "**", "power", "\n", "\n", "self", ".", "m", "=", "res", ".", "m", "\n", "self", ".", "P", "=", "res", ".", "P", "\n", "self", ".", "C", "=", "res", ".", "C", "\n", "self", ".", "S", "=", "res", ".", "S", "\n", "self", ".", "Pm", "=", "res", ".", "Pm", "\n", "self", ".", "logdetP", "=", "res", ".", "logdetP", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.convert_to_T": [[198, 207], ["delfi.distribution.StudentsT.StudentsT"], "methods", ["None"], ["", "def", "convert_to_T", "(", "self", ",", "dof", ")", ":", "\n", "        ", "\"\"\"Converts Gaussian to Student T\n\n        Parameters\n        ----------\n        dof : int\n            Degrees of freedom\n        \"\"\"", "\n", "return", "StudentsT", "(", "self", ".", "m", ",", "self", ".", "S", ",", "dof", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.eval": [[208, 235], ["numpy.atleast_2d", "numpy.atleast_1d", "numpy.exp", "numpy.sum", "x.reshape.reshape.reshape", "numpy.linalg.matrix_rank", "len", "scipy.stats.multivariate_normal.logpdf", "ValueError", "numpy.log", "numpy.array", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "x", "=", "np", ".", "atleast_2d", "(", "x", ")", "\n", "\n", "if", "ii", "is", "None", ":", "\n", "            ", "assert", "x", ".", "shape", "[", "1", "]", "==", "self", ".", "ndim", ",", "\"incorrect data dimension\"", "\n", "xm", "=", "x", "-", "self", ".", "m", "\n", "lp", "=", "-", "np", ".", "sum", "(", "np", ".", "dot", "(", "xm", ",", "self", ".", "P", ")", "*", "xm", ",", "axis", "=", "1", ")", "\n", "lp", "+=", "self", ".", "logdetP", "-", "self", ".", "ndim", "*", "np", ".", "log", "(", "2.0", "*", "np", ".", "pi", ")", "\n", "lp", "*=", "0.5", "\n", "\n", "", "else", ":", "\n", "            ", "ii", "=", "np", ".", "atleast_1d", "(", "ii", ")", "\n", "m", "=", "self", ".", "m", "[", "ii", "]", "\n", "S", "=", "self", ".", "S", "[", "ii", "]", "[", ":", ",", "ii", "]", "\n", "if", "m", ".", "size", "==", "1", ":", "# single marginal", "\n", "                ", "x", "=", "x", ".", "reshape", "(", "-", "1", ",", "m", ".", "size", ")", "\n", "", "assert", "x", ".", "shape", "[", "1", "]", "==", "m", ".", "size", "\n", "if", "np", ".", "linalg", ".", "matrix_rank", "(", "S", ")", "==", "len", "(", "S", "[", ":", ",", "0", "]", ")", ":", "\n", "                ", "lp", "=", "scipy", ".", "stats", ".", "multivariate_normal", ".", "logpdf", "(", "x", ",", "m", ",", "S", ",", "allow_singular", "=", "True", ")", "\n", "lp", "=", "np", ".", "array", "(", "[", "lp", "]", ")", "if", "x", ".", "shape", "[", "0", "]", "==", "1", "else", "lp", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Rank deficiency in covariance matrix'", ")", "\n", "\n", "", "", "res", "=", "lp", "if", "log", "else", "np", ".", "exp", "(", "lp", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.gen": [[236, 242], ["Gaussian.Gaussian.rng.randn", "numpy.dot"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "z", "=", "self", ".", "rng", ".", "randn", "(", "n_samples", ",", "self", ".", "ndim", ")", "\n", "samples", "=", "np", ".", "dot", "(", "z", ",", "self", ".", "C", ")", "+", "self", ".", "m", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.kl": [[243, 261], ["isinstance", "numpy.sum", "numpy.dot", "numpy.dot"], "methods", ["None"], ["", "def", "kl", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Calculates the KL divergence from this to another Gaussian\n\n        Direction of KL is KL(this | other)\n        \"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "assert", "self", ".", "ndim", "==", "other", ".", "ndim", "\n", "\n", "t1", "=", "np", ".", "sum", "(", "other", ".", "P", "*", "self", ".", "S", ")", "\n", "\n", "m", "=", "other", ".", "m", "-", "self", ".", "m", "\n", "t2", "=", "np", ".", "dot", "(", "m", ",", "np", ".", "dot", "(", "other", ".", "P", ",", "m", ")", ")", "\n", "\n", "t3", "=", "self", ".", "logdetP", "-", "other", ".", "logdetP", "\n", "\n", "t", "=", "0.5", "*", "(", "t1", "+", "t2", "+", "t3", "-", "self", ".", "ndim", ")", "\n", "\n", "return", "t", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.ztrans": [[262, 279], ["Gaussian.Gaussian", "numpy.outer"], "methods", ["None"], ["", "def", "ztrans", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "\"\"\"Z-transform\n\n        Parameters\n        ----------\n        mean : array\n            Mean vector\n        std : array\n            Std vector\n\n        Returns\n        -------\n        Gaussian distribution\n        \"\"\"", "\n", "m", "=", "(", "self", ".", "m", "-", "mean", ")", "/", "std", "\n", "S", "=", "self", ".", "S", "/", "np", ".", "outer", "(", "std", ",", "std", ")", "\n", "return", "Gaussian", "(", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.Gaussian.Gaussian.ztrans_inv": [[280, 297], ["Gaussian.Gaussian", "numpy.outer"], "methods", ["None"], ["", "def", "ztrans_inv", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "\"\"\"Z-transform inverse\n\n        Parameters\n        ----------\n        mean : array\n            Mean vector\n        std : array\n            Std vector\n\n        Returns\n        -------\n        Gaussian distribution\n        \"\"\"", "\n", "m", "=", "std", "*", "self", ".", "m", "+", "mean", "\n", "S", "=", "np", ".", "outer", "(", "std", ",", "std", ")", "*", "self", ".", "S", "\n", "return", "Gaussian", "(", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "self", ".", "seed", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.StudentsT.StudentsT.__init__": [[8, 34], ["numpy.asarray", "numpy.asarray", "numpy.linalg.inv", "numpy.dot", "delfi.distribution.BaseDistribution.BaseDistribution.__init__", "numpy.linalg.cholesky", "numpy.sum", "numpy.log", "numpy.diagonal"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["    ", "def", "__init__", "(", "self", ",", "m", ",", "S", ",", "dof", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Student's T distribution\n\n        Parameters\n        ----------\n        m : list or np.array, 1d\n            Mean\n        S : list or np.array, 1d\n            Covariance\n        dof : int\n            Degrees of freedom\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "m", "=", "np", ".", "asarray", "(", "m", ")", "\n", "self", ".", "m", "=", "m", "\n", "self", ".", "dof", "=", "dof", "\n", "assert", "(", "dof", ">", "0", ")", "\n", "\n", "S", "=", "np", ".", "asarray", "(", "S", ")", "\n", "self", ".", "P", "=", "np", ".", "linalg", ".", "inv", "(", "S", ")", "\n", "self", ".", "C", "=", "np", ".", "linalg", ".", "cholesky", "(", "S", ")", ".", "T", "# C is upper triangular here", "\n", "self", ".", "S", "=", "S", "\n", "self", ".", "Pm", "=", "np", ".", "dot", "(", "self", ".", "P", ",", "m", ")", "\n", "self", ".", "logdetP", "=", "-", "2.0", "*", "np", ".", "sum", "(", "np", ".", "log", "(", "np", ".", "diagonal", "(", "self", ".", "C", ")", ")", ")", "\n", "super", "(", ")", ".", "__init__", "(", "ndim", "=", "m", ".", "size", ",", "seed", "=", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.StudentsT.StudentsT.mean": [[35, 39], ["StudentsT.StudentsT.m.reshape"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "m", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.StudentsT.StudentsT.std": [[40, 45], ["numpy.sqrt().reshape", "numpy.sqrt", "numpy.diag"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "sqrt", "(", "(", "self", ".", "dof", "/", "(", "self", ".", "dof", "-", "2", ")", ")", "*", "\n", "np", ".", "diag", "(", "self", ".", "S", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.StudentsT.StudentsT.eval": [[46, 61], ["numpy.log", "numpy.log", "scipy.special.gamma", "numpy.exp", "scipy.special.gammaln", "numpy.sum", "numpy.log", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "if", "ii", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "xm", "=", "x", "-", "self", ".", "m", "\n", "lp", "=", "np", ".", "log", "(", "1", "+", "np", ".", "sum", "(", "np", ".", "dot", "(", "xm", ",", "self", ".", "P", ")", "*", "xm", ",", "axis", "=", "1", ")", "/", "self", ".", "dof", ")", "\n", "lp", "*=", "-", "(", "self", ".", "dof", "+", "self", ".", "ndim", ")", "/", "2.0", "\n", "lp", "+=", "np", ".", "log", "(", "scipy", ".", "special", ".", "gamma", "(", "(", "self", ".", "dof", "+", "self", ".", "ndim", ")", "/", "2", ")", ")", "\n", "lp", "-=", "scipy", ".", "special", ".", "gammaln", "(", "self", ".", "dof", "/", "2", ")", "+", "self", ".", "ndim", "/", "2", "*", "np", ".", "log", "(", "self", ".", "dof", "*", "np", ".", "pi", ")", "-", "0.5", "*", "self", ".", "logdetP", "\n", "\n", "res", "=", "lp", "if", "log", "else", "np", ".", "exp", "(", "lp", ")", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.distribution.StudentsT.StudentsT.gen": [[62, 69], ["StudentsT.StudentsT.rng.multivariate_normal", "StudentsT.StudentsT.rng.chisquare", "numpy.zeros", "numpy.sqrt"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseDistribution.py for docstring", "\n", "        ", "u", "=", "self", ".", "rng", ".", "chisquare", "(", "self", ".", "dof", ",", "n_samples", ")", "/", "self", ".", "dof", "\n", "y", "=", "self", ".", "rng", ".", "multivariate_normal", "(", "np", ".", "zeros", "(", "self", ".", "ndim", ")", ",", "\n", "self", ".", "S", ",", "(", "n_samples", ",", ")", ")", "\n", "return", "self", ".", "m", "+", "y", "/", "np", ".", "sqrt", "(", "u", ")", "[", ":", ",", "None", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.__init__": [[27, 39], ["numpy.asarray", "delfi.distribution.Discrete.Discrete", "numpy.random.RandomState", "numpy.random.RandomState", "BaseMixture.BaseMixture.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["def", "__init__", "(", "self", ",", "a", ",", "ncomp", ",", "ndim", ",", "seed", "=", "None", ")", ":", "\n", "        ", "self", ".", "a", "=", "np", ".", "asarray", "(", "a", ")", "\n", "self", ".", "ncomp", "=", "ncomp", "\n", "self", ".", "ndim", "=", "ndim", "\n", "\n", "self", ".", "seed", "=", "seed", "\n", "if", "seed", "is", "not", "None", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", ")", "\n", "\n", "", "self", ".", "discrete_sample", "=", "Discrete", "(", "p", "=", "self", ".", "a", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.eval": [[40, 59], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "        ", "\"\"\"Method to evaluate pdf\n\n        Parameters\n        ----------\n        x : int or list or np.array\n            Rows are inputs to evaluate at\n        ii : list\n            A list of indices specifying which marginal to evaluate.\n            If None, the joint pdf is evaluated\n        log : bool, defaulting to True\n            If True, the log pdf is evaluated\n\n        Returns\n        -------\n        scalar\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.gen": [[60, 74], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "\"\"\"Method to generate samples\n\n        Parameters\n        ----------\n        n_samples : int\n            Number of samples to generate\n\n        Returns\n        -------\n        n_samples x self.ndim\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.n_components": [[75, 78], ["None"], "methods", ["None"], ["", "@", "property", "\n", "def", "n_components", "(", "self", ")", ":", "\n", "        ", "return", "self", ".", "ncomp", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.gen_comp": [[79, 82], ["BaseMixture.BaseMixture.discrete_sample.gen().reshape", "BaseMixture.BaseMixture.discrete_sample.gen"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "gen_comp", "(", "self", ",", "n_samples", ")", ":", "\n", "        ", "\"\"\"Generate component index according to self.a\"\"\"", "\n", "return", "self", ".", "discrete_sample", ".", "gen", "(", "n_samples", ")", ".", "reshape", "(", "-", "1", ")", "# n_samples,", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.reseed": [[83, 96], ["BaseMixture.BaseMixture.rng.seed", "BaseMixture.BaseMixture.discrete_sample.reseed", "x.reseed", "BaseMixture.BaseMixture.gen_newseed", "BaseMixture.BaseMixture.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "\"\"\"Reseeds the following RNGs in the following order:\n        1) Master RNG for the mixture object, using the input seed\n        2) RNG for the discrete distribution used to sample components. The seed\n        is generated using the master RNG.\n        3) RNG for each mixture component, in order. Each seed is generated by\n        the master RNG.\n        \"\"\"", "\n", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "discrete_sample", ".", "reseed", "(", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "for", "x", "in", "self", ".", "xs", ":", "\n", "            ", "x", ".", "reseed", "(", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.gen_newseed": [[97, 103], ["BaseMixture.BaseMixture.rng.randint"], "methods", ["None"], ["", "", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.kl": [[104, 117], ["BaseMixture.BaseMixture.gen", "BaseMixture.BaseMixture.eval", "other.eval", "numpy.mean", "numpy.std", "numpy.sqrt"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.std"], ["", "", "def", "kl", "(", "self", ",", "other", ",", "n_samples", "=", "10000", ")", ":", "\n", "        ", "\"\"\"Estimates the KL from this to another PDF\n\n        KL(this | other), using Monte Carlo\"\"\"", "\n", "x", "=", "self", ".", "gen", "(", "n_samples", ")", "\n", "lp", "=", "self", ".", "eval", "(", "x", ",", "log", "=", "True", ")", "\n", "lq", "=", "other", ".", "eval", "(", "x", ",", "log", "=", "True", ")", "\n", "t", "=", "lp", "-", "lq", "\n", "\n", "res", "=", "np", ".", "mean", "(", "t", ")", "\n", "err", "=", "np", ".", "std", "(", "t", ",", "ddof", "=", "1", ")", "/", "np", ".", "sqrt", "(", "n_samples", ")", "\n", "\n", "return", "res", ",", "err", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.prune_negligible_components": [[118, 132], ["numpy.sum", "numpy.delete", "numpy.nonzero", "enumerate"], "methods", ["None"], ["", "def", "prune_negligible_components", "(", "self", ",", "threshold", ")", ":", "\n", "        ", "\"\"\"Prune components\n\n        Removes all the components whose mixing coefficient is less\n        than a threshold.\n        \"\"\"", "\n", "ii", "=", "np", ".", "nonzero", "(", "(", "self", ".", "a", "<", "threshold", ")", ".", "astype", "(", "int", ")", ")", "[", "0", "]", "\n", "total_del_a", "=", "np", ".", "sum", "(", "self", ".", "a", "[", "ii", "]", ")", "\n", "del_count", "=", "ii", ".", "size", "\n", "\n", "self", ".", "ncomp", "-=", "del_count", "\n", "self", ".", "a", "=", "np", ".", "delete", "(", "self", ".", "a", ",", "ii", ")", "\n", "self", ".", "a", "+=", "total_del_a", "/", "self", ".", "n_components", "\n", "self", ".", "xs", "=", "[", "x", "for", "i", ",", "x", "in", "enumerate", "(", "self", ".", "xs", ")", "if", "i", "not", "in", "ii", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG.__init__": [[9, 115], ["numpy.all", "numpy.zeros_like", "numpy.atleast_1d", "numpy.ones_like", "numpy.atleast_1d", "numpy.zeros_like", "numpy.atleast_1d", "numpy.in1d", "delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "numpy.unique", "numpy.arange", "delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "ValueError", "numpy.asarray", "len", "len", "delfi.distribution.TransformedNormal.TransformedNormal", "numpy.all", "numpy.all", "numpy.all", "zip", "delfi.distribution.TransformedNormal.TransformedNormal", "ValueError", "numpy.asarray", "len", "TransformedGaussianMixture.MoTG.gen_newseed", "zip", "delfi.distribution.TransformedNormal.TransformedNormal", "TransformedGaussianMixture.MoTG.gen_newseed", "zip", "TransformedGaussianMixture.MoTG.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "a", ",", "\n", "ms", "=", "None", ",", "\n", "Ps", "=", "None", ",", "\n", "Us", "=", "None", ",", "\n", "Ss", "=", "None", ",", "\n", "xs", "=", "None", ",", "\n", "upper", "=", "None", ",", "\n", "lower", "=", "None", ",", "\n", "flags", "=", "None", ",", "\n", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Mixture of 'transformed' Gaussians\n\n        Creates a MoG with a valid combination of parameters or an already given\n        list of log-, logit- and/or un-transformed Gaussian variables.\n\n        Parameters\n        ----------\n        a : list or np.array, 1d\n            Mixing coefficients\n        ms : list, length n_components\n            Means\n        Ps : list, length n_components\n            Precisions\n        Us : list, length n_components\n            Precision factors such that U'U = P\n        Ss : list, length n_components\n            Covariances\n        xs : list, length n_components\n            List of gaussian variables\n        flags: list or np.array, 1d\n            List of flags for each variable whether it is untransformed (=0),\n            log-transformed (=1) or logit-transformed (=2).\n        lower: list or np.array, 1d\n            Lower bounds for logit-box. Defaults to 0 for each parameter.\n        upper: list or np.array, 1d\n            Upper bounds for logit-box. Defaults to 1 for each parameter.\n\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "\n", "m", "=", "ms", "[", "0", "]", "if", "not", "ms", "is", "None", "else", "xs", "[", "0", "]", ".", "m", "\n", "\n", "self", ".", "lower", "=", "np", ".", "zeros_like", "(", "m", ")", "if", "lower", "is", "None", "else", "np", ".", "atleast_1d", "(", "lower", ")", "\n", "self", ".", "upper", "=", "np", ".", "ones_like", "(", "m", ")", "if", "upper", "is", "None", "else", "np", ".", "atleast_1d", "(", "upper", ")", "\n", "\n", "assert", "self", ".", "lower", ".", "ndim", "==", "self", ".", "upper", ".", "ndim", "\n", "assert", "self", ".", "lower", ".", "ndim", "==", "1", "\n", "\n", "self", ".", "flags", "=", "np", ".", "zeros_like", "(", "m", ")", "if", "flags", "is", "None", "else", "np", ".", "atleast_1d", "(", "flags", ")", "\n", "\n", "assert", "self", ".", "flags", ".", "ndim", "==", "1", "\n", "assert", "np", ".", "all", "(", "np", ".", "in1d", "(", "np", ".", "unique", "(", "self", ".", "flags", ")", ",", "np", ".", "arange", "(", "3", ")", ")", ")", "\n", "\n", "if", "ms", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "ms", ")", ",", "\n", "ndim", "=", "len", "(", "ms", "[", "0", "]", ")", ",", "\n", "seed", "=", "seed", ")", "\n", "\n", "if", "Ps", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "TransformedNormal", "(", "\n", "m", "=", "m", ",", "P", "=", "P", ",", "upper", "=", "self", ".", "upper", ",", "lower", "=", "self", ".", "lower", ",", "\n", "flags", "=", "self", ".", "flags", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "P", "in", "zip", "(", "\n", "ms", ",", "Ps", ")", "]", "\n", "\n", "", "elif", "Us", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "TransformedNormal", "(", "\n", "m", "=", "m", ",", "U", "=", "U", ",", "upper", "=", "self", ".", "upper", ",", "lower", "=", "self", ".", "lower", ",", "\n", "flags", "=", "self", ".", "flags", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "U", "in", "zip", "(", "\n", "ms", ",", "Us", ")", "]", "\n", "\n", "", "elif", "Ss", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "TransformedNormal", "(", "\n", "m", "=", "m", ",", "S", "=", "S", ",", "upper", "=", "self", ".", "upper", ",", "lower", "=", "self", ".", "lower", ",", "\n", "flags", "=", "self", ".", "flags", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "S", "in", "zip", "(", "\n", "ms", ",", "Ss", ")", "]", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "elif", "xs", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "xs", ")", ",", "\n", "ndim", "=", "xs", "[", "0", "]", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "self", ".", "xs", "=", "xs", "\n", "\n", "# MoGT enforces its flags and bounds (initialize accordingly!):", "\n", "for", "x", "in", "xs", ":", "\n", "                ", "assert", "np", ".", "all", "(", "x", ".", "flags", "==", "self", ".", "flags", ")", "\n", "assert", "np", ".", "all", "(", "x", ".", "upper", "==", "self", ".", "upper", ")", "\n", "assert", "np", ".", "all", "(", "x", ".", "lower", "==", "self", ".", "lower", ")", "\n", "\n", "", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Mean information missing'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._f": [[116, 123], ["TransformedGaussianMixture.MoTG.xs[]._f"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._f"], ["", "", "def", "_f", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" forward transformation\n            x[i] -> x[i]        for Gaussian x[i]\n            x[i] -> log(x[i])   for log-Normal x[i]\n            x[i] -> logit(x[i]) for logit-Normal x[i]\n         \"\"\"", "\n", "return", "self", ".", "xs", "[", "0", "]", ".", "_f", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._finv": [[124, 131], ["TransformedGaussianMixture.MoTG.xs[]._finv"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG._finv"], ["", "def", "_finv", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\" backward transformation\n            x[i] -> x[i]        for Gaussian x[i]\n            x[i] -> exp(x[i])   for log-Normal x[i]\n            x[i] -> expit(x[i]) for logit-Normal x[i]\n         \"\"\"", "\n", "return", "self", ".", "xs", "[", "0", "]", ".", "_finv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG.mean": [[133, 137], ["numpy.ones_like().reshape", "numpy.ones_like"], "methods", ["None"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means - not analytic for logit-normal!\"\"\"", "\n", "return", "np", ".", "nan", "*", "np", ".", "ones_like", "(", "self", ".", "m", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG.std": [[138, 142], ["numpy.ones_like().reshape", "numpy.ones_like", "numpy.diag"], "methods", ["None"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals - not analytic for logit-normal!\"\"\"", "\n", "return", "np", ".", "nan", "*", "np", ".", "ones_like", "(", "np", ".", "diag", "(", "self", ".", "S", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG.eval": [[143, 156], ["numpy.array", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "numpy.dot", "c.eval", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseMixture.py for docstring", "\n", "        ", "ps", "=", "np", ".", "array", "(", "[", "c", ".", "eval", "(", "x", ",", "ii", ",", "log", ")", "for", "c", "in", "self", ".", "xs", "]", ")", ".", "T", "\n", "res", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "ps", "+", "\n", "np", ".", "log", "(", "\n", "self", ".", "a", ")", ",", "\n", "axis", "=", "1", ")", "if", "log", "else", "np", ".", "dot", "(", "\n", "ps", ",", "\n", "self", ".", "a", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.TransformedGaussianMixture.MoTG.gen": [[157, 168], ["TransformedGaussianMixture.MoTG.gen_comp", "numpy.concatenate", "TransformedGaussianMixture.MoTG.rng.shuffle", "numpy.sum", "x.gen", "range", "zip"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.gen_comp", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseMixture.py for docstring", "\n", "        ", "ii", "=", "self", ".", "gen_comp", "(", "n_samples", ")", "# n_samples,", "\n", "\n", "ns", "=", "[", "np", ".", "sum", "(", "(", "ii", "==", "i", ")", ".", "astype", "(", "int", ")", ")", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "]", "\n", "samples", "=", "[", "x", ".", "gen", "(", "n", ")", "for", "x", ",", "n", "in", "zip", "(", "self", ".", "xs", ",", "ns", ")", "]", "\n", "samples", "=", "np", ".", "concatenate", "(", "samples", ",", "axis", "=", "0", ")", "\n", "self", ".", "rng", ".", "shuffle", "(", "samples", ")", "\n", "\n", "return", "samples", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.__init__": [[12, 85], ["delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "ValueError", "numpy.asarray", "len", "delfi.distribution.Gaussian.Gaussian", "numpy.asarray", "zip", "delfi.distribution.Gaussian.Gaussian", "ValueError", "numpy.asarray", "len", "GaussianMixture.MoG.gen_newseed", "zip", "delfi.distribution.Gaussian.Gaussian", "GaussianMixture.MoG.gen_newseed", "zip", "GaussianMixture.MoG.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "a", ",", "\n", "ms", "=", "None", ",", "\n", "Ps", "=", "None", ",", "\n", "Us", "=", "None", ",", "\n", "Ss", "=", "None", ",", "\n", "xs", "=", "None", ",", "\n", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Mixture of Gaussians\n\n        Creates a MoG with a valid combination of parameters or an already given\n        list of Gaussian variables.\n\n        Parameters\n        ----------\n        a : list or np.array, 1d\n            Mixing coefficients\n        ms : list, length n_components\n            Means\n        Ps : list, length n_components\n            Precisions\n        Us : list, length n_components\n            Precision factors such that U'U = P\n        Ss : list, length n_components\n            Covariances\n        xs : list, length n_components\n            List of gaussian variables\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "self", ".", "__div__", "=", "self", ".", "__truediv__", "\n", "self", ".", "__idiv__", "=", "self", ".", "__itruediv__", "\n", "\n", "if", "ms", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "ms", ")", ",", "\n", "ndim", "=", "np", ".", "asarray", "(", "\n", "ms", "[", "0", "]", ")", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "\n", "if", "Ps", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "Gaussian", "(", "\n", "m", "=", "m", ",", "P", "=", "P", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "P", "in", "zip", "(", "\n", "ms", ",", "Ps", ")", "]", "\n", "\n", "", "elif", "Us", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "Gaussian", "(", "\n", "m", "=", "m", ",", "U", "=", "U", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "U", "in", "zip", "(", "\n", "ms", ",", "Us", ")", "]", "\n", "\n", "", "elif", "Ss", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "Gaussian", "(", "\n", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "S", "in", "zip", "(", "\n", "ms", ",", "Ss", ")", "]", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "elif", "xs", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "xs", ")", ",", "\n", "ndim", "=", "xs", "[", "0", "]", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "self", ".", "xs", "=", "xs", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Mean information missing'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.__mul__": [[86, 107], ["isinstance", "numpy.empty_like", "enumerate", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "numpy.exp", "GaussianMixture.MoG", "zip", "numpy.log", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "", "def", "__mul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Multiply with a single gaussian\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "ys", "=", "[", "x", "*", "other", "for", "x", "in", "self", ".", "xs", "]", "\n", "\n", "lcs", "=", "np", ".", "empty_like", "(", "self", ".", "a", ")", "\n", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "xs", ",", "ys", ")", ")", ":", "\n", "\n", "            ", "lcs", "[", "i", "]", "=", "x", ".", "logdetP", "+", "other", ".", "logdetP", "-", "y", ".", "logdetP", "\n", "lcs", "[", "i", "]", "-=", "np", ".", "dot", "(", "x", ".", "m", ",", "np", ".", "dot", "(", "x", ".", "P", ",", "x", ".", "m", ")", ")", "+", "np", ".", "dot", "(", "other", ".", "m", ",", "np", ".", "dot", "(", "other", ".", "P", ",", "other", ".", "m", ")", ")", "-", "np", ".", "dot", "(", "y", ".", "m", ",", "np", ".", "dot", "(", "y", ".", "P", ",", "y", ".", "m", ")", ")", "\n", "lcs", "[", "i", "]", "*=", "0.5", "\n", "\n", "", "la", "=", "np", ".", "log", "(", "self", ".", "a", ")", "+", "lcs", "\n", "la", "-=", "scipy", ".", "special", ".", "logsumexp", "(", "la", ")", "\n", "a", "=", "np", ".", "exp", "(", "la", ")", "\n", "\n", "return", "MoG", "(", "a", "=", "a", ",", "xs", "=", "ys", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.__imul__": [[108, 118], ["isinstance"], "methods", ["None"], ["", "def", "__imul__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Incrementally multiply with a single gaussian\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "res", "=", "self", "*", "other", "\n", "\n", "self", ".", "a", "=", "res", ".", "a", "\n", "self", ".", "xs", "=", "res", ".", "xs", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.__truediv__": [[119, 140], ["isinstance", "numpy.empty_like", "enumerate", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "numpy.exp", "GaussianMixture.MoG", "zip", "numpy.log", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot", "numpy.dot"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "__truediv__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Divide by a single gaussian\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "ys", "=", "[", "x", "/", "other", "for", "x", "in", "self", ".", "xs", "]", "\n", "\n", "lcs", "=", "np", ".", "empty_like", "(", "self", ".", "a", ")", "\n", "\n", "for", "i", ",", "(", "x", ",", "y", ")", "in", "enumerate", "(", "zip", "(", "self", ".", "xs", ",", "ys", ")", ")", ":", "\n", "\n", "            ", "lcs", "[", "i", "]", "=", "x", ".", "logdetP", "-", "other", ".", "logdetP", "-", "y", ".", "logdetP", "\n", "lcs", "[", "i", "]", "-=", "np", ".", "dot", "(", "x", ".", "m", ",", "np", ".", "dot", "(", "x", ".", "P", ",", "x", ".", "m", ")", ")", "-", "np", ".", "dot", "(", "other", ".", "m", ",", "np", ".", "dot", "(", "other", ".", "P", ",", "other", ".", "m", ")", ")", "-", "np", ".", "dot", "(", "y", ".", "m", ",", "np", ".", "dot", "(", "y", ".", "P", ",", "y", ".", "m", ")", ")", "\n", "lcs", "[", "i", "]", "*=", "0.5", "\n", "\n", "", "la", "=", "np", ".", "log", "(", "self", ".", "a", ")", "+", "lcs", "\n", "la", "-=", "scipy", ".", "special", ".", "logsumexp", "(", "la", ")", "\n", "a", "=", "np", ".", "exp", "(", "la", ")", "\n", "\n", "return", "MoG", "(", "a", "=", "a", ",", "xs", "=", "ys", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.__itruediv__": [[141, 151], ["isinstance"], "methods", ["None"], ["", "def", "__itruediv__", "(", "self", ",", "other", ")", ":", "\n", "        ", "\"\"\"Incrementally divide by a single gaussian\"\"\"", "\n", "assert", "isinstance", "(", "other", ",", "Gaussian", ")", "\n", "\n", "res", "=", "self", "/", "other", "\n", "\n", "self", ".", "a", "=", "res", ".", "a", "\n", "self", ".", "xs", "=", "res", ".", "xs", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.calc_mean_and_cov": [[152, 162], ["numpy.dot", "numpy.array", "numpy.sum", "numpy.outer", "numpy.outer", "zip", "numpy.array", "zip"], "methods", ["None"], ["", "def", "calc_mean_and_cov", "(", "self", ")", ":", "\n", "        ", "\"\"\"Calculate the mean vector and the covariance matrix of the MoG\"\"\"", "\n", "ms", "=", "[", "x", ".", "m", "for", "x", "in", "self", ".", "xs", "]", "\n", "m", "=", "np", ".", "dot", "(", "self", ".", "a", ",", "np", ".", "array", "(", "ms", ")", ")", "\n", "\n", "msqs", "=", "[", "x", ".", "S", "+", "np", ".", "outer", "(", "mi", ",", "mi", ")", "for", "x", ",", "mi", "in", "zip", "(", "self", ".", "xs", ",", "ms", ")", "]", "\n", "S", "=", "np", ".", "sum", "(", "\n", "np", ".", "array", "(", "[", "a", "*", "msq", "for", "a", ",", "msq", "in", "zip", "(", "self", ".", "a", ",", "msqs", ")", "]", ")", ",", "axis", "=", "0", ")", "-", "np", ".", "outer", "(", "m", ",", "m", ")", "\n", "\n", "return", "m", ",", "S", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean": [[163, 167], ["[].reshape", "GaussianMixture.MoG.calc_mean_and_cov"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.calc_mean_and_cov"], ["", "@", "property", "\n", "def", "mean", "(", "self", ")", ":", "\n", "        ", "\"\"\"Means\"\"\"", "\n", "return", "self", ".", "calc_mean_and_cov", "(", ")", "[", "0", "]", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.std": [[168, 172], ["numpy.sqrt().reshape", "numpy.sqrt", "numpy.diag", "GaussianMixture.MoG.calc_mean_and_cov"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.calc_mean_and_cov"], ["", "@", "property", "\n", "def", "std", "(", "self", ")", ":", "\n", "        ", "\"\"\"Standard deviations of marginals\"\"\"", "\n", "return", "np", ".", "sqrt", "(", "np", ".", "diag", "(", "self", ".", "calc_mean_and_cov", "(", ")", "[", "1", "]", ")", ")", ".", "reshape", "(", "-", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.convert_to_T": [[173, 185], ["delfi.distribution.mixture.StudentsTMixture.MoT", "type", "x.convert_to_T", "zip", "range", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.convert_to_T"], ["", "def", "convert_to_T", "(", "self", ",", "dofs", ")", ":", "\n", "        ", "\"\"\"Convert to Mixture of Student's T distributions\n\n        Parameters\n        ----------\n        dofs : int or list of ints\n            Degrees of freedom of component distributions\n        \"\"\"", "\n", "if", "type", "(", "dofs", ")", "==", "int", ":", "\n", "            ", "dofs", "=", "[", "dofs", "for", "i", "in", "range", "(", "len", "(", "self", ".", "xs", ")", ")", "]", "\n", "", "ys", "=", "[", "x", ".", "convert_to_T", "(", "dof", ")", "for", "x", ",", "dof", "in", "zip", "(", "self", ".", "xs", ",", "dofs", ")", "]", "\n", "return", "MoT", "(", "self", ".", "a", ",", "xs", "=", "ys", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.convert_to_E": [[186, 190], ["delfi.distribution.mixture.EllipsoidalMixture.MoE"], "methods", ["None"], ["", "def", "convert_to_E", "(", "self", ",", "beta", "=", "0.99", ")", ":", "\n", "        ", "\"\"\"Convert to Mixture of ellipsoidal distributions\n        \"\"\"", "\n", "return", "MoE", "(", "self", ".", "a", ",", "xs", "=", "self", ".", "xs", ",", "seed", "=", "self", ".", "seed", ",", "beta", "=", "beta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.eval": [[191, 204], ["numpy.array", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "numpy.dot", "c.eval", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseMixture.py for docstring", "\n", "        ", "ps", "=", "np", ".", "array", "(", "[", "c", ".", "eval", "(", "x", ",", "ii", ",", "log", ")", "for", "c", "in", "self", ".", "xs", "]", ")", ".", "T", "\n", "res", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "ps", "+", "\n", "np", ".", "log", "(", "\n", "self", ".", "a", ")", ",", "\n", "axis", "=", "1", ")", "if", "log", "else", "np", ".", "dot", "(", "\n", "ps", ",", "\n", "self", ".", "a", ")", "\n", "\n", "return", "res", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.gen": [[205, 216], ["GaussianMixture.MoG.gen_comp", "numpy.concatenate", "GaussianMixture.MoG.rng.shuffle", "numpy.sum", "x.gen", "range", "zip"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.gen_comp", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseMixture.py for docstring", "\n", "        ", "ii", "=", "self", ".", "gen_comp", "(", "n_samples", ")", "# n_samples,", "\n", "\n", "ns", "=", "[", "np", ".", "sum", "(", "(", "ii", "==", "i", ")", ".", "astype", "(", "int", ")", ")", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "]", "\n", "samples", "=", "[", "x", ".", "gen", "(", "n", ")", "for", "x", ",", "n", "in", "zip", "(", "self", ".", "xs", ",", "ns", ")", "]", "\n", "samples", "=", "np", ".", "concatenate", "(", "samples", ",", "axis", "=", "0", ")", "\n", "self", ".", "rng", ".", "shuffle", "(", "samples", ")", "\n", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.project_to_gaussian": [[217, 221], ["GaussianMixture.MoG.calc_mean_and_cov", "delfi.distribution.Gaussian.Gaussian"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.calc_mean_and_cov"], ["", "def", "project_to_gaussian", "(", "self", ")", ":", "\n", "        ", "\"\"\"Returns a gaussian with the same mean and precision as the mog\"\"\"", "\n", "m", ",", "S", "=", "self", ".", "calc_mean_and_cov", "(", ")", "\n", "return", "Gaussian", "(", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans": [[222, 226], ["GaussianMixture.MoG", "x.ztrans"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans"], ["", "def", "ztrans", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "\"\"\"Z-transform\"\"\"", "\n", "xs", "=", "[", "x", ".", "ztrans", "(", "mean", ",", "std", ")", "for", "x", "in", "self", ".", "xs", "]", "\n", "return", "MoG", "(", "self", ".", "a", ",", "xs", "=", "xs", ",", "seed", "=", "self", ".", "seed", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans_inv": [[227, 231], ["GaussianMixture.MoG", "x.ztrans_inv"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.ztrans_inv"], ["", "def", "ztrans_inv", "(", "self", ",", "mean", ",", "std", ")", ":", "\n", "        ", "\"\"\"Z-transform inverse\"\"\"", "\n", "xs", "=", "[", "x", ".", "ztrans_inv", "(", "mean", ",", "std", ")", "for", "x", "in", "self", ".", "xs", "]", "\n", "return", "MoG", "(", "self", ".", "a", ",", "xs", "=", "xs", ",", "seed", "=", "self", ".", "seed", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.__init__": [[13, 80], ["delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "scipy.special.gammaincinv", "scipy.special.gammaincinv", "scipy.special.gammaincinv", "delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "ValueError", "numpy.asarray", "len", "delfi.distribution.Gaussian.Gaussian", "numpy.asarray", "zip", "delfi.distribution.Gaussian.Gaussian", "ValueError", "numpy.asarray", "len", "EllipsoidalMixture.MoE.gen_newseed", "zip", "delfi.distribution.Gaussian.Gaussian", "EllipsoidalMixture.MoE.gen_newseed", "zip", "EllipsoidalMixture.MoE.gen_newseed"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["    ", "def", "__init__", "(", "self", ",", "a", ",", "ms", "=", "None", ",", "Ps", "=", "None", ",", "Us", "=", "None", ",", "Ss", "=", "None", ",", "xs", "=", "None", ",", "\n", "seed", "=", "None", ",", "beta", "=", "0.99", ")", ":", "\n", "        ", "\"\"\"Mixture of Ellipsoidals\n\n        Creates a MoE with a valid combination of parameters or an already given\n        list of Gaussian variables.\n\n        Parameters\n        ----------\n        a : list or np.array, 1d\n            Mixing coefficients\n        ms : list, length n_components\n            Means\n        Ps : list, length n_components\n            Precisions\n        Us : list, length n_components\n            Precision factors such that U'U = P\n        Ss : list, length n_components\n            Covariances\n        xs : list, length n_components\n            List of gaussian variables\n        seed : int or None\n            If provided, random number generator will be seeded\n        beta : float\n            Mass to preserve when sampling\n        \"\"\"", "\n", "if", "ms", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "ms", ")", ",", "\n", "ndim", "=", "np", ".", "asarray", "(", "\n", "ms", "[", "0", "]", ")", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "\n", "if", "Ps", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "Gaussian", "(", "\n", "m", "=", "m", ",", "P", "=", "P", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "P", "in", "zip", "(", "\n", "ms", ",", "Ps", ")", "]", "\n", "\n", "", "elif", "Us", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "Gaussian", "(", "\n", "m", "=", "m", ",", "U", "=", "U", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "U", "in", "zip", "(", "\n", "ms", ",", "Us", ")", "]", "\n", "\n", "", "elif", "Ss", "is", "not", "None", ":", "\n", "                ", "self", ".", "xs", "=", "[", "\n", "Gaussian", "(", "\n", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "S", "in", "zip", "(", "\n", "ms", ",", "Ss", ")", "]", "\n", "\n", "", "else", ":", "\n", "                ", "raise", "ValueError", "(", "'Precision information missing'", ")", "\n", "\n", "", "", "elif", "xs", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "xs", ")", ",", "\n", "ndim", "=", "xs", "[", "0", "]", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "self", ".", "xs", "=", "xs", "\n", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Mean information missing'", ")", "\n", "\n", "", "self", ".", "threshold", "=", "2", "*", "gammaincinv", "(", "0.5", "*", "self", ".", "ndim", ",", "beta", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen": [[81, 92], ["range", "range", "numpy.array", "len", "numpy.linalg.cholesky", "numpy.array.append", "EllipsoidalMixture.MoE.gen_single"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen_single"], ["", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "xs", ")", ")", ":", "\n", "            ", "self", ".", "xs", "[", "i", "]", ".", "L", "=", "la", ".", "cholesky", "(", "self", ".", "xs", "[", "i", "]", ".", "S", ")", "\n", "\n", "", "samp", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "n_samples", ")", ":", "\n", "            ", "samp", ".", "append", "(", "self", ".", "gen_single", "(", ")", ")", "\n", "", "samp", "=", "np", ".", "array", "(", "samp", ")", "\n", "\n", "return", "samp", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.gen_single": [[93, 114], ["EllipsoidalMixture.MoE.uni_rand_ellipse", "EllipsoidalMixture.MoE.gen_single.draw_proposal"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.uni_rand_ellipse"], ["", "def", "gen_single", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generate single sample\n        \"\"\"", "\n", "def", "draw_proposal", "(", "xs", ")", ":", "\n", "            ", "\u03bc", "=", "xs", ".", "m", "\n", "L", "=", "xs", ".", "L", "\n", "x", "=", "self", ".", "uni_rand_ellipse", "(", "L", "*", "np", ".", "sqrt", "(", "self", ".", "threshold", ")", ")", "\n", "return", "x", ".", "ravel", "(", ")", "+", "\u03bc", ".", "ravel", "(", ")", "\n", "\n", "", "while", "True", ":", "\n", "            ", "i", "=", "self", ".", "gen_comp", "(", "1", ")", "[", "0", "]", "# component index", "\n", "x", "=", "draw_proposal", "(", "self", ".", "xs", "[", "i", "]", ")", "\n", "\u03c1", "=", "np", ".", "zeros", "(", "self", ".", "ncomp", ")", "\n", "for", "j", ",", "xs", "in", "enumerate", "(", "self", ".", "xs", ")", ":", "\n", "                ", "\u03bc", "=", "xs", ".", "m", "\n", "L", "=", "xs", ".", "L", "\n", "z", "=", "la", ".", "solve", "(", "L", ",", "(", "x", "-", "\u03bc", ")", ")", "\n", "\u03c1", "[", "j", "]", "=", "np", ".", "dot", "(", "z", ",", "z", ")", "\n", "", "\u03c0", "=", "1", "/", "np", ".", "sum", "(", "\u03c1", "<", "self", ".", "threshold", ")", "\n", "if", "self", ".", "rng", ".", "rand", "(", ")", "<", "\u03c0", ":", "\n", "                ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.uni_rand_ellipse": [[115, 138], ["EllipsoidalMixture.MoE.rng.normal", "numpy.sqrt", "EllipsoidalMixture.MoE.rng.uniform", "numpy.dot", "numpy.sum", "numpy.outer", "numpy.ones"], "methods", ["None"], ["", "", "", "def", "uni_rand_ellipse", "(", "self", ",", "L", ",", "n", "=", "1", ")", ":", "\n", "        ", "\"\"\"Sample from ellipsoid\n\n        Parameters\n        ----------\n        L : np.array\n            Cholesky factorization of covariance matrix s.t. \u03a3 = LL'\n        n : int\n            number of samples to generate\n        \"\"\"", "\n", "m", "=", "L", ".", "shape", "[", "0", "]", "\n", "x", "=", "self", ".", "rng", ".", "normal", "(", "size", "=", "(", "m", ",", "n", ")", ")", "\n", "\n", "# map the points on the n-dimensional hypersphere", "\n", "w", "=", "np", ".", "sqrt", "(", "np", ".", "sum", "(", "x", "**", "2", ",", "axis", "=", "0", ")", ")", "# norm of the vector", "\n", "x", "=", "x", "/", "w", "# normalized vector", "\n", "\n", "# generate points distributed as m * r^(m-1) for 0 < r < 1", "\n", "u", "=", "self", ".", "rng", ".", "uniform", "(", "size", "=", "n", ")", "\n", "r", "=", "np", ".", "outer", "(", "np", ".", "ones", "(", "m", ")", ",", "u", ")", "**", "(", "1", "/", "m", ")", "\n", "\n", "\u03c6sph", "=", "r", "*", "x", "# \u03c6 is uniformely distributed within the unit sphere", "\n", "return", "np", ".", "dot", "(", "L", ",", "\u03c6sph", ")", "# rescale the sphere into an ellipsoid", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.EllipsoidalMixture.MoE.eval": [[139, 154], ["ps.squeeze.squeeze.squeeze", "numpy.array", "numpy.log", "c.eval"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# Returns 1 everywhere (unnormalized)", "\n", "        ", "if", "ii", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "ps", "=", "np", ".", "array", "(", "[", "c", ".", "eval", "(", "x", ",", "ii", ",", "log", ")", "for", "c", "in", "self", ".", "xs", "]", ")", ".", "T", "\n", "ps", "*=", "0", "\n", "ps", "+=", "1.", "\n", "ps", "=", "ps", ".", "squeeze", "(", ")", "\n", "\n", "if", "log", ":", "\n", "            ", "return", "np", ".", "log", "(", "ps", ")", "\n", "", "else", ":", "\n", "            ", "return", "ps", "\n", "", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.__init__": [[11, 59], ["delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "delfi.distribution.StudentsT.StudentsT", "delfi.distribution.mixture.BaseMixture.BaseMixture.__init__", "ValueError", "numpy.asarray", "len", "zip", "numpy.asarray", "StudentsTMixture.MoT.gen_newseed", "numpy.asarray", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed"], ["    ", "def", "__init__", "(", "self", ",", "a", ",", "ms", "=", "None", ",", "Ss", "=", "None", ",", "dofs", "=", "None", ",", "xs", "=", "None", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Mixture of Student's T distributions\n\n        Creates a MoT with a valid combination of parameters or an already given\n        list of gaussian variables.\n\n        Parameters\n        ----------\n        a : list or 1d array\n            Mixing coefficients\n        ms : list of length n_components\n            Means\n        Ss : list of length n_components\n            Covariances\n        dofs: list of length n_components\n            Degrees of freedom\n        xs : list of length n_components\n            List of Student's T distributions\n        seed : int or None\n            If provided, random number generator will be seeded\n        \"\"\"", "\n", "if", "ms", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "ms", ")", ",", "\n", "ndim", "=", "np", ".", "asarray", "(", "\n", "ms", "[", "0", "]", ")", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "self", ".", "xs", "=", "[", "\n", "StudentsT", "(", "\n", "m", "=", "m", ",", "\n", "S", "=", "S", ",", "\n", "dof", "=", "dof", ",", "\n", "seed", "=", "self", ".", "gen_newseed", "(", ")", ")", "for", "m", ",", "\n", "S", ",", "\n", "dof", "in", "zip", "(", "\n", "ms", ",", "\n", "Ss", ",", "\n", "dofs", ")", "]", "\n", "", "elif", "xs", "is", "not", "None", ":", "\n", "            ", "super", "(", ")", ".", "__init__", "(", "\n", "a", "=", "np", ".", "asarray", "(", "a", ")", ",", "\n", "ncomp", "=", "len", "(", "xs", ")", ",", "\n", "ndim", "=", "xs", "[", "0", "]", ".", "ndim", ",", "\n", "seed", "=", "seed", ")", "\n", "self", ".", "xs", "=", "xs", "\n", "", "else", ":", "\n", "            ", "raise", "ValueError", "(", "'Mean information missing'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen": [[60, 71], ["StudentsTMixture.MoT.gen_comp", "numpy.concatenate", "StudentsTMixture.MoT.rng.shuffle", "numpy.sum", "x.gen", "range", "zip"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.BaseMixture.BaseMixture.gen_comp", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "", "@", "copy_ancestor_docstring", "\n", "def", "gen", "(", "self", ",", "n_samples", "=", "1", ")", ":", "\n", "# See BaseMixture.py for docstring", "\n", "        ", "ii", "=", "self", ".", "gen_comp", "(", "n_samples", ")", "# n_samples,", "\n", "\n", "ns", "=", "[", "np", ".", "sum", "(", "(", "ii", "==", "i", ")", ".", "astype", "(", "int", ")", ")", "for", "i", "in", "range", "(", "self", ".", "n_components", ")", "]", "\n", "samples", "=", "[", "x", ".", "gen", "(", "n", ")", "for", "x", ",", "n", "in", "zip", "(", "self", ".", "xs", ",", "ns", ")", "]", "\n", "samples", "=", "np", ".", "concatenate", "(", "samples", ",", "axis", "=", "0", ")", "\n", "self", ".", "rng", ".", "shuffle", "(", "samples", ")", "\n", "\n", "return", "samples", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval": [[72, 88], ["numpy.array", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "scipy.special.logsumexp", "numpy.dot", "c.eval", "numpy.log"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "@", "copy_ancestor_docstring", "\n", "def", "eval", "(", "self", ",", "x", ",", "ii", "=", "None", ",", "log", "=", "True", ")", ":", "\n", "# See BaseMixture.py for docstring", "\n", "        ", "if", "ii", "is", "not", "None", ":", "\n", "            ", "raise", "NotImplementedError", "\n", "\n", "", "ps", "=", "np", ".", "array", "(", "[", "c", ".", "eval", "(", "x", ",", "ii", "=", "None", ",", "log", "=", "log", ")", "for", "c", "in", "self", ".", "xs", "]", ")", ".", "T", "\n", "res", "=", "scipy", ".", "special", ".", "logsumexp", "(", "\n", "ps", "+", "\n", "np", ".", "log", "(", "\n", "self", ".", "a", ")", ",", "\n", "axis", "=", "1", ")", "if", "log", "else", "np", ".", "dot", "(", "\n", "ps", ",", "\n", "self", ".", "a", ")", "\n", "\n", "return", "res", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.Identity.Identity.__init__": [[14, 17], ["delfi.summarystats.BaseSummaryStats.BaseSummaryStats.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["def", "__init__", "(", "self", ",", "seed", "=", "None", ",", "idx", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "seed", "=", "seed", ")", "\n", "self", ".", "idx", "=", "idx", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.Identity.Identity.calc": [[18, 34], ["len", "numpy.zeros", "enumerate"], "methods", ["None"], ["", "@", "copy_ancestor_docstring", "\n", "def", "calc", "(", "self", ",", "repetition_list", ")", ":", "\n", "# See BaseSummaryStats.py for docstring", "\n", "\n", "# get the number of samples contained", "\n", "        ", "n_reps", "=", "len", "(", "repetition_list", ")", "\n", "\n", "# get the size of the data inside a sample", "\n", "self", ".", "n_summary", "=", "repetition_list", "[", "0", "]", "[", "'data'", "]", ".", "size", "\n", "\n", "# build a matrix of n_reps x n_summary", "\n", "data_matrix", "=", "np", ".", "zeros", "(", "(", "n_reps", ",", "self", ".", "n_summary", ")", ")", "\n", "for", "rep_idx", ",", "rep_dict", "in", "enumerate", "(", "repetition_list", ")", ":", "\n", "            ", "data_matrix", "[", "rep_idx", ",", ":", "]", "=", "rep_dict", "[", "'data'", "]", "\n", "\n", "", "return", "data_matrix", "if", "self", ".", "idx", "is", "None", "else", "data_matrix", "[", ":", ",", "self", ".", "idx", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.Mean.Mean.__init__": [[10, 14], ["delfi.summarystats.BaseSummaryStats.BaseSummaryStats.__init__"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["def", "__init__", "(", "self", ",", "seed", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", "seed", "=", "seed", ")", "\n", "# should return a matrix n_samples x 1 (mean)", "\n", "self", ".", "n_summary", "=", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.Mean.Mean.calc": [[15, 30], ["len", "numpy.zeros", "enumerate", "numpy.mean"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "@", "copy_ancestor_docstring", "\n", "def", "calc", "(", "self", ",", "repetition_list", ")", ":", "\n", "# See BaseSummaryStats.py for docstring", "\n", "\n", "# get the number of repetitions contained", "\n", "        ", "n_reps", "=", "len", "(", "repetition_list", ")", "\n", "\n", "# build a matrix of n_reps x 1", "\n", "repetition_stats_matrix", "=", "np", ".", "zeros", "(", "(", "n_reps", ",", "self", ".", "n_summary", ")", ")", "\n", "\n", "# for every repetition, take the mean of the data in the dict", "\n", "for", "rep_idx", ",", "rep_dict", "in", "enumerate", "(", "repetition_list", ")", ":", "\n", "            ", "repetition_stats_matrix", "[", "rep_idx", ",", "]", "=", "np", ".", "mean", "(", "rep_dict", "[", "'data'", "]", ")", "\n", "\n", "", "return", "repetition_stats_matrix", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.__init__": [[8, 29], ["numpy.random.RandomState"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\"Abstract base class for summary stats\n\n        Summary Stats must at least implement abstract methods and properties of\n        this class: The method ``calc()`` needs to be implemented. The attribute\n        ``n_summary`` can be useful to have, for example to write tests, but it\n        is not strictly required.\n\n        Parameters\n        ----------\n        seed : int or None\n            If provided, random number generator will be seeded\n\n        Attributes\n        ----------\n        n_summary : int\n            Number of resulting summary features\n        \"\"\"", "\n", "self", ".", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "self", ".", "n_summary", "=", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.calc": [[30, 44], ["None"], "methods", ["None"], ["", "@", "abc", ".", "abstractmethod", "\n", "def", "calc", "(", "self", ",", "repetition_list", ")", ":", "\n", "        ", "\"\"\"Method computing summary statistics\n\n        Parameters\n        ----------\n        repetition_list : list of dictionaries, one per repetition\n            data list, returned by `gen` method of Simulator instance\n\n        Returns\n        -------\n        np.arrray, 2d with n_reps x n_summary\n        \"\"\"", "\n", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.gen_newseed": [[45, 51], ["BaseSummaryStats.BaseSummaryStats.rng.randint"], "methods", ["None"], ["", "def", "gen_newseed", "(", "self", ")", ":", "\n", "        ", "\"\"\"Generates a new random seed\"\"\"", "\n", "if", "self", ".", "seed", "is", "None", ":", "\n", "            ", "return", "None", "\n", "", "else", ":", "\n", "            ", "return", "self", ".", "rng", ".", "randint", "(", "0", ",", "2", "**", "31", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed": [[52, 55], ["BaseSummaryStats.BaseSummaryStats.rng.seed"], "methods", ["None"], ["", "", "def", "reseed", "(", "self", ",", "seed", ")", ":", "\n", "        ", "self", ".", "rng", ".", "seed", "(", "seed", "=", "seed", ")", "\n", "self", ".", "seed", "=", "seed", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__": [[7, 33], ["delfi.summarystats.BaseSummaryStats.__init__", "numpy.count_nonzero", "len"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.__init__"], ["    ", "def", "__init__", "(", "self", ",", "s", ",", "mask", ",", "obs", ",", "seed", "=", "None", ")", ":", "\n", "        ", "\"\"\" Summary stats with imputed values\n\n        This is a wrapper around BaseSummaryStats which imputes\n        fixed values for specified statistics.\n\n        Parameters\n        ----------\n        s : BaseSummaryStats\n            The original summary stats\n        mask : 1d array \n            Boolean array determining the values to be imputed. False corresponds to imputed entries.\n        obs : 1d array\n            Array of summary statistics from which to impute the values\n        seed : int or None\n            See BaseSummaryStats\n        \"\"\"", "\n", "\n", "super", "(", ")", ".", "__init__", "(", "seed", "=", "seed", ")", "\n", "self", ".", "s", "=", "s", "\n", "self", ".", "mask", "=", "mask", "\n", "\n", "self", ".", "n_summary", "=", "np", ".", "count_nonzero", "(", "self", ".", "mask", ")", "\n", "assert", "len", "(", "mask", ")", "==", "s", ".", "n_summary", ",", "\"Summary statistics mask has the wrong size\"", "\n", "\n", "self", ".", "obs", "=", "obs", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.calc": [[34, 40], ["MaskedSummaryStats.MaskedSummaryStats.s.calc", "numpy.broadcast_to", "numpy.broadcast_to"], "methods", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.calc"], ["", "def", "calc", "(", "self", ",", "repetition_list", ")", ":", "\n", "        ", "ret", "=", "self", ".", "s", ".", "calc", "(", "repetition_list", ")", "\n", "mask", "=", "np", ".", "broadcast_to", "(", "self", ".", "mask", ",", "ret", ".", "shape", ")", "\n", "obs_vals", "=", "np", ".", "broadcast_to", "(", "self", ".", "obs_vals", ",", "ret", ".", "shape", ")", "\n", "ret", "[", "~", "mask", "]", "=", "obs_vals", "[", "~", "mask", "]", "\n", "return", "ret", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.docs.make_autodoc.main": [[11, 50], ["importlib.import_module", "inspect.getmembers", "inspect.getmembers", "create_class", "classes.append", "create_fun", "functions.append", "open", "write_class", "open", "write_function", "pathlib.Path().absolute", "pathlib.Path().absolute", "pathlib.Path", "pathlib.Path"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_class", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.create_fun", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_class", "home.repos.pwc.inspect_result.mackelab_delfi.utils.automacdoc.write_function"], ["def", "main", "(", "argv", "=", "None", ")", ":", "\n", "    ", "argv", "=", "sys", ".", "argv", "if", "argv", "is", "None", "else", "argv", "\n", "\n", "#write_doc(argv[1], argv[2])", "\n", "\n", "modules", "=", "[", "\n", "'delfi.distribution'", ",", "\n", "'delfi.generator'", ",", "\n", "'delfi.inference'", ",", "\n", "'delfi.neuralnet.NeuralNet'", ",", "\n", "'delfi.simulator'", ",", "\n", "'delfi.summarystats'", ",", "\n", "'delfi.utils.viz'", "]", "\n", "\n", "classes", "=", "[", "]", "\n", "functions", "=", "[", "]", "\n", "\n", "for", "module_name", "in", "modules", ":", "\n", "        ", "module", "=", "importlib", ".", "import_module", "(", "module_name", ",", "package", "=", "'delfi'", ")", "\n", "\n", "for", "name", ",", "obj", "in", "inspect", ".", "getmembers", "(", "module", ",", "inspect", ".", "isclass", ")", ":", "\n", "            ", "cls", "=", "create_class", "(", "name", ",", "obj", ",", "ignore_prefix_function", "=", "None", ")", "\n", "classes", ".", "append", "(", "cls", ")", "\n", "\n", "", "for", "name", ",", "obj", "in", "inspect", ".", "getmembers", "(", "module", ",", "inspect", ".", "isfunction", ")", ":", "\n", "            ", "fun", "=", "create_fun", "(", "name", ",", "obj", ",", "ignore_prefix_function", "=", "None", ")", "\n", "functions", ".", "append", "(", "fun", ")", "\n", "\n", "", "", "for", "cls", "in", "classes", ":", "\n", "        ", "md_path", "=", "Path", "(", "__file__", ")", ".", "absolute", "(", ")", ".", "parent", "/", "'autodoc/{module}.md'", ".", "format", "(", "\n", "module", "=", "cls", "[", "'module'", "]", ")", "\n", "with", "open", "(", "md_path", ",", "'w'", ")", "as", "md_file", ":", "\n", "            ", "write_class", "(", "md_file", ",", "cls", ")", "\n", "\n", "", "", "for", "fun", "in", "functions", ":", "\n", "        ", "md_path", "=", "Path", "(", "__file__", ")", ".", "absolute", "(", ")", ".", "parent", "/", "'autodoc/{module}.{name}.md'", ".", "format", "(", "\n", "module", "=", "fun", "[", "'module'", "]", ",", "name", "=", "fun", "[", "'name'", "]", ")", "\n", "with", "open", "(", "md_path", ",", "'w'", ")", "as", "md_file", ":", "\n", "            ", "write_function", "(", "md_file", ",", "fun", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_generator.test_gauss_shape": [[12, 26], ["range", "delfi.simulator.Gauss.Gauss", "delfi.Gaussian", "delfi.Identity", "delfi.Default", "dg.Default.gen", "numpy.zeros", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["def", "test_gauss_shape", "(", ")", ":", "\n", "    ", "for", "n_params", "in", "range", "(", "1", ",", "3", ")", ":", "\n", "        ", "m", "=", "Gauss", "(", "dim", "=", "n_params", ")", "\n", "p", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", ")", "\n", "s", "=", "ds", ".", "Identity", "(", ")", "\n", "\n", "g", "=", "dg", ".", "Default", "(", "model", "=", "m", ",", "prior", "=", "p", ",", "summary", "=", "s", ")", "\n", "\n", "n_samples", "=", "100", "\n", "params", ",", "stats", "=", "g", ".", "gen", "(", "n_samples", ")", "\n", "\n", "n_summary", "=", "n_params", "\n", "assert", "params", ".", "shape", "==", "(", "n_samples", ",", "n_params", ")", "\n", "assert", "stats", ".", "shape", "==", "(", "n_samples", ",", "n_summary", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_generator.test_IndependentJoint_uniform_rejection": [[28, 55], ["delfi.Uniform", "delfi.Uniform", "delfi.IndependentJoint", "delfi.Gaussian", "delfi.simulator.Gauss.Gauss", "delfi.Identity", "delfi.Default", "dg.Default.gen", "params.min", "numpy.array", "params.min", "numpy.array"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "", "def", "test_IndependentJoint_uniform_rejection", "(", ")", ":", "\n", "# check that proposed samples are correctly rejected when using a", "\n", "# IndependentJoint prior with some child distributions uniform. We used a", "\n", "# Gaussian proposal to generate some samples that need to be rejected.", "\n", "    ", "N", "=", "1000", "\n", "B1", "=", "[", "-", "1.0", ",", "1.0", "]", "\n", "B2", "=", "[", "-", "2.0", ",", "2.0", "]", "\n", "u1", "=", "dd", ".", "Uniform", "(", "B1", "[", "0", "]", ",", "B1", "[", "1", "]", ")", "\n", "u2", "=", "dd", ".", "Uniform", "(", "B2", "[", "0", "]", ",", "B2", "[", "1", "]", ")", "\n", "prior", "=", "dd", ".", "IndependentJoint", "(", "[", "u1", ",", "u2", "]", ")", "\n", "\n", "m", "=", "[", "0.", ",", "0.", "]", "\n", "S", "=", "[", "[", "2.", ",", "0.", ",", "]", ",", "\n", "[", "0.", ",", "2.", ",", "]", "]", "\n", "proposal", "=", "dd", ".", "Gaussian", "(", "m", "=", "m", ",", "S", "=", "S", ")", "\n", "\n", "model", "=", "Gauss", "(", "dim", "=", "2", ")", "\n", "\n", "s", "=", "ds", ".", "Identity", "(", ")", "\n", "\n", "g", "=", "dg", ".", "Default", "(", "model", "=", "model", ",", "prior", "=", "prior", ",", "summary", "=", "s", ")", "\n", "g", ".", "proposal", "=", "proposal", "\n", "\n", "params", ",", "stats", "=", "g", ".", "gen", "(", "N", ",", "verbose", "=", "False", ")", "\n", "assert", "(", "params", ".", "min", "(", "axis", "=", "0", ")", ">=", "np", ".", "array", "(", "[", "B1", "[", "0", "]", ",", "B2", "[", "0", "]", "]", ")", ")", ".", "all", "(", ")", "and", "(", "params", ".", "min", "(", "axis", "=", "0", ")", "<=", "np", ".", "array", "(", "[", "B1", "[", "1", "]", ",", "B2", "[", "1", "]", "]", ")", ")", ".", "all", "(", ")", ",", "\"rejection failed\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_generator.test_mpgen": [[57, 69], ["delfi.Gaussian", "delfi.Identity", "delfi.MPGenerator", "dg.MPGenerator.gen", "delfi.simulator.Gauss.Gauss", "numpy.unique", "numpy.unique", "numpy.zeros", "numpy.eye", "range"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "test_mpgen", "(", "n_samples", "=", "1000", ",", "n_params", "=", "2", ",", "n_cores", "=", "4", ",", "seed", "=", "500", ")", ":", "\n", "    ", "p", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", ",", "seed", "=", "seed", ")", "\n", "s", "=", "ds", ".", "Identity", "(", "seed", "=", "seed", "+", "1", ")", "\n", "\n", "mlist", "=", "[", "Gauss", "(", "dim", "=", "n_params", ",", "seed", "=", "seed", "+", "2", "+", "i", ")", "for", "i", "in", "range", "(", "n_cores", ")", "]", "\n", "g", "=", "dg", ".", "MPGenerator", "(", "models", "=", "mlist", ",", "prior", "=", "p", ",", "summary", "=", "s", ",", "\n", "seed", "=", "seed", "+", "2", "+", "n_cores", ")", "\n", "params", ",", "stats", "=", "g", ".", "gen", "(", "n_samples", ",", "verbose", "=", "False", ")", "\n", "\n", "# make sure the different models are providing different outputs", "\n", "assert", "np", ".", "unique", "(", "params", ".", "size", ")", "==", "params", ".", "size", "\n", "assert", "np", ".", "unique", "(", "stats", ".", "size", ")", "==", "stats", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_generator.test_remotegen": [[71, 137], ["delfi.Gaussian", "dict", "getpass.getuser", "os.system", "os.system", "os.system", "os.system", "os.system", "os.system", "os.system", "os.system", "os.system", "os.system", "os.path.expanduser", "sys.stderr.write", "sys.stderr.write", "sys.stderr.write", "sys.stderr.write", "sys.stderr.write", "sys.stderr.write", "delfi.RemoteGenerator", "dg.RemoteGenerator.gen", "numpy.unique", "numpy.unique", "numpy.zeros", "numpy.eye", "subprocess.run().stdout.decode", "subprocess.run().stdout.decode", "subprocess.run().stdout.decode", "subprocess.run().stdout.decode", "subprocess.run().stdout.decode", "subprocess.run().stdout.decode", "subprocess.run", "subprocess.run", "subprocess.run", "subprocess.run", "subprocess.run", "subprocess.run", "os.path.join", "os.path.join"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run"], ["", "def", "test_remotegen", "(", "n_samples", "=", "1000", ",", "n_params", "=", "2", ",", "seed", "=", "66", ",", "run_diagnostics", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    test the RemoteGenerator by using the local machine to ssh into itself.\n    For this test to succeed, an ssh private key will need to be added to the\n    ssh agent, and the corresponding public key added to authorized_keys\n\n    NOTE: This test will fail on travis unless eval $(ssh-agent -s) is run in the main script. Running it here using\n    os.system seems to have no effect.\n    \"\"\"", "\n", "p", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", ",", "seed", "=", "seed", ")", "\n", "\n", "simulator_kwargs", "=", "dict", "(", "dim", "=", "2", ")", "\n", "\n", "hostname", "=", "'127.0.0.1'", "\n", "username", "=", "getpass", ".", "getuser", "(", ")", "\n", "\n", "# in a real-world scenario, we would have already manually authenticated", "\n", "# the host. what we're doing here is a big security risk, but for localhost", "\n", "# it's (probably?) ok", "\n", "os", ".", "system", "(", "'cp ~/.ssh/known_hosts ~/.ssh/known_hosts_backup'", ")", "\n", "os", ".", "system", "(", "'cp ~/.ssh/authorized_keys ~/.ssh/authorized_keys_backup'", ")", "\n", "os", ".", "system", "(", "'ssh-keyscan -H {0} >> ~/.ssh/known_hosts'", ".", "format", "(", "hostname", ")", ")", "\n", "# generate a key-pair to use on localhost", "\n", "os", ".", "system", "(", "'ssh-keygen -b 2048 -t rsa -f ~/.ssh/test_remotegen -q -N \"\"'", ")", "\n", "os", ".", "system", "(", "'ssh-add ~/.ssh/test_remotegen'", ")", "# add private key for client side", "\n", "os", ".", "system", "(", "'cat ~/.ssh/test_remotegen.pub >> ~/.ssh/authorized_keys'", ")", "\n", "\n", "if", "run_diagnostics", ":", "\n", "# run some diagnostics and print results to stderr", "\n", "        ", "sshdir", "=", "os", ".", "path", ".", "expanduser", "(", "'~/.ssh/'", ")", "\n", "sys", ".", "stderr", ".", "write", "(", "subprocess", ".", "run", "(", "[", "'ssh-add'", ",", "'-l'", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "stdout", ".", "decode", "(", ")", "+", "'\\n\\n'", ")", "\n", "sys", ".", "stderr", ".", "write", "(", "subprocess", ".", "run", "(", "[", "'ls'", ",", "sshdir", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "stdout", ".", "decode", "(", ")", "+", "'\\n\\n'", ")", "\n", "sys", ".", "stderr", ".", "write", "(", "subprocess", ".", "run", "(", "[", "'cat'", ",", "os", ".", "path", ".", "join", "(", "sshdir", ",", "'authorized_keys'", ")", "]", ",", "\n", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "stdout", ".", "decode", "(", ")", "+", "'\\n\\n'", ")", "\n", "sys", ".", "stderr", ".", "write", "(", "subprocess", ".", "run", "(", "[", "'cat'", ",", "os", ".", "path", ".", "join", "(", "sshdir", ",", "'known_hosts'", ")", "]", ",", "\n", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "stdout", ".", "decode", "(", ")", "+", "'\\n\\n'", ")", "\n", "sys", ".", "stderr", ".", "write", "(", "subprocess", ".", "run", "(", "[", "'ls'", ",", "'-ld'", ",", "sshdir", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "stdout", ".", "decode", "(", ")", "+", "'\\n\\n'", ")", "\n", "sys", ".", "stderr", ".", "write", "(", "subprocess", ".", "run", "(", "[", "'ls'", ",", "'-l'", ",", "sshdir", "]", ",", "stdout", "=", "subprocess", ".", "PIPE", ")", ".", "stdout", ".", "decode", "(", ")", "+", "'\\n\\n'", ")", "\n", "\n", "", "try", ":", "\n", "        ", "g", "=", "dg", ".", "RemoteGenerator", "(", "simulator_class", "=", "Gauss", ",", "\n", "prior", "=", "p", ",", "summary_class", "=", "ds", ".", "Identity", ",", "\n", "hostname", "=", "hostname", ",", "\n", "username", "=", "username", ",", "\n", "simulator_kwargs", "=", "simulator_kwargs", ",", "\n", "use_slurm", "=", "False", ",", "\n", "remote_python_executable", "=", "sys", ".", "executable", ",", "\n", "seed", "=", "seed", "+", "2", ")", "\n", "params", ",", "stats", "=", "g", ".", "gen", "(", "n_samples", ",", "verbose", "=", "False", ")", "\n", "success", "=", "True", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "success", "=", "False", "\n", "err", "=", "e", "\n", "\n", "# restore ssh to previous state etc.", "\n", "", "os", ".", "system", "(", "'ssh-add -d ~/.ssh/test_remotegen'", ")", "\n", "os", ".", "system", "(", "'mv ~/.ssh/known_hosts_backup ~/.ssh/known_hosts'", ")", "\n", "os", ".", "system", "(", "'mv ~/.ssh/authorized_keys_backup ~/.ssh/authorized_keys'", ")", "\n", "os", ".", "system", "(", "'rm ~/.ssh/test_remotegen*'", ")", "\n", "\n", "if", "not", "success", ":", "\n", "        ", "raise", "err", "\n", "\n", "# make sure the different models are providing different outputs", "\n", "", "assert", "np", ".", "unique", "(", "params", ".", "size", ")", "==", "params", ".", "size", "\n", "assert", "np", ".", "unique", "(", "stats", ".", "size", ")", "==", "stats", ".", "size", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_generator.dont_test_remotegen_slurm": [[139, 169], ["delfi.Gaussian", "dict", "delfi.RemoteGenerator", "dg.RemoteGenerator.gen", "type", "type", "type", "numpy.zeros", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "dont_test_remotegen_slurm", "(", "n_samples", "=", "500", ",", "n_params", "=", "2", ",", "seed", "=", "66", ",", "save_every", "=", "200", ",", "\n", "hostname", "=", "None", ",", "username", "=", "None", ",", "clusters", "=", "None", ",", "\n", "remote_python_executable", "=", "None", ",", "remote_work_path", "=", "None", ")", ":", "\n", "    ", "assert", "type", "(", "hostname", ")", "is", "str", "and", "type", "(", "username", ")", "is", "str", ",", "\"hostname and username must be provided\"", "\n", "assert", "type", "(", "clusters", ")", "is", "str", ",", "\"cluster(s) must be specified as a (comma-delimited) string\"", "\n", "'''this test is currently disabled because we don't have slurm running on travis right now. it works fine\n    if it's run locally on a machine with key-based ssh-access to a SLURM cluster, as of 17.09.2019'''", "\n", "\n", "p", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", ",", "seed", "=", "seed", ")", "\n", "\n", "simulator_kwargs", "=", "dict", "(", "dim", "=", "2", ")", "\n", "\n", "slurm_options", "=", "{", "'clusters'", ":", "clusters", ",", "\n", "'time'", ":", "'0:10:00'", ",", "\n", "'ntasks-per-node'", ":", "2", ",", "\n", "'nodes'", ":", "2", "}", "\n", "\n", "g", "=", "dg", ".", "RemoteGenerator", "(", "simulator_class", "=", "Gauss", ",", "\n", "prior", "=", "p", ",", "summary_class", "=", "ds", ".", "Identity", ",", "\n", "hostname", "=", "hostname", ",", "\n", "username", "=", "username", ",", "\n", "simulator_kwargs", "=", "simulator_kwargs", ",", "\n", "use_slurm", "=", "True", ",", "\n", "remote_python_executable", "=", "remote_python_executable", ",", "\n", "remote_work_path", "=", "remote_work_path", ",", "\n", "slurm_options", "=", "slurm_options", ",", "\n", "save_every", "=", "save_every", ",", "\n", "seed", "=", "seed", "+", "2", ")", "\n", "params", ",", "stats", "=", "g", ".", "gen", "(", "n_samples", ",", "verbose", "=", "False", ")", "\n", "return", "params", ",", "stats", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_trainer.test_trainer_updates": [[15, 46], ["delfi.simulator.Gauss.Gauss", "delfi.Gaussian", "delfi.Identity", "delfi.Default", "delfi.neuralnet.NeuralNet.NeuralNet", "dg.Default.gen", "tuple", "delfi.neuralnet.Trainer.Trainer", "delfi.neuralnet.Trainer.Trainer.make_update", "delfi.neuralnet.Trainer.Trainer.train", "theano.mean", "numpy.zeros", "numpy.eye", "x.astype"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.Trainer.Trainer.train", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["def", "test_trainer_updates", "(", ")", ":", "\n", "    ", "n_components", "=", "1", "\n", "n_params", "=", "2", "\n", "seed", "=", "42", "\n", "svi", "=", "True", "\n", "\n", "m", "=", "Gauss", "(", "dim", "=", "n_params", ")", "\n", "p", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", ")", "\n", "s", "=", "ds", ".", "Identity", "(", ")", "\n", "g", "=", "dg", ".", "Default", "(", "model", "=", "m", ",", "prior", "=", "p", ",", "summary", "=", "s", ")", "\n", "\n", "nn", "=", "NeuralNet", "(", "\n", "n_components", "=", "n_components", ",", "\n", "n_hiddens", "=", "[", "10", "]", ",", "\n", "n_inputs", "=", "n_params", ",", "\n", "n_outputs", "=", "n_params", ",", "\n", "seed", "=", "seed", ",", "\n", "svi", "=", "svi", ")", "\n", "loss", "=", "-", "tt", ".", "mean", "(", "nn", ".", "lprobs", ")", "\n", "\n", "trn_inputs", "=", "[", "nn", ".", "params", ",", "nn", ".", "stats", "]", "\n", "trn_data", "=", "g", ".", "gen", "(", "100", ")", "# params, stats", "\n", "trn_data", "=", "tuple", "(", "x", ".", "astype", "(", "dtype", ")", "for", "x", "in", "trn_data", ")", "\n", "\n", "t", "=", "Trainer", "(", "network", "=", "nn", ",", "loss", "=", "loss", ",", "trn_data", "=", "trn_data", ",", "trn_inputs", "=", "trn_inputs", ")", "\n", "\n", "# single update", "\n", "outputs", "=", "t", ".", "make_update", "(", "*", "trn_data", ")", "\n", "\n", "# training", "\n", "outputs", "=", "t", ".", "train", "(", "100", ",", "50", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.simplegaussprod": [[12, 24], ["m1.squeeze.squeeze", "m2.squeeze.squeeze", "numpy.linalg.inv", "numpy.dot", "numpy.linalg.inv", "numpy.dot", "numpy.linalg.inv", "numpy.dot"], "function", ["None"], ["def", "simplegaussprod", "(", "m1", ",", "S1", ",", "m2", ",", "S2", ")", ":", "\n", "    ", "m1", "=", "m1", ".", "squeeze", "(", ")", "\n", "m2", "=", "m2", ".", "squeeze", "(", ")", "\n", "P1", "=", "np", ".", "linalg", ".", "inv", "(", "S1", ")", "\n", "Pm1", "=", "np", ".", "dot", "(", "P1", ",", "m1", ")", "\n", "P2", "=", "np", ".", "linalg", ".", "inv", "(", "S2", ")", "\n", "Pm2", "=", "np", ".", "dot", "(", "P2", ",", "m2", ")", "\n", "P", "=", "P1", "+", "P2", "\n", "S", "=", "np", ".", "linalg", ".", "inv", "(", "P", ")", "\n", "Pm", "=", "Pm1", "+", "Pm2", "\n", "m", "=", "np", ".", "dot", "(", "S", ",", "Pm", ")", "\n", "return", "m", ",", "S", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian": [[26, 38], ["delfi.simulator.Gauss.Gauss", "delfi.Gaussian", "delfi.Identity", "delfi.Default", "numpy.zeros", "inferenceobj", "inferenceobj.reset", "test_inference.simplegaussprod", "numpy.zeros", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.simplegaussprod"], ["", "def", "init_all_gaussian", "(", "n_params", "=", "2", ",", "seed", "=", "42", ",", "inferenceobj", "=", "None", ",", "Sfac", "=", "1.0", ",", "**", "inf_setup_opts", ")", ":", "\n", "    ", "model", "=", "Gauss", "(", "dim", "=", "n_params", ",", "seed", "=", "seed", ",", "noise_cov", "=", "0.1", "*", "Sfac", ")", "\n", "prior", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", "*", "Sfac", ",", "seed", "=", "seed", "+", "1", ")", "\n", "s", "=", "ds", ".", "Identity", "(", "seed", "=", "seed", "+", "2", ")", "\n", "g", "=", "dg", ".", "Default", "(", "model", "=", "model", ",", "prior", "=", "prior", ",", "summary", "=", "s", ",", "seed", "=", "seed", "+", "3", ")", "\n", "obs", "=", "np", ".", "zeros", "(", "(", "1", ",", "n_params", ")", ")", "# reseed generator etc. (?)", "\n", "\n", "res", "=", "inferenceobj", "(", "g", ",", "obs", "=", "obs", ",", "seed", "=", "seed", "+", "4", ",", "**", "inf_setup_opts", ")", "\n", "res", ".", "reset", "(", "seed", "=", "seed", "+", "4", ")", "\n", "\n", "m_true", ",", "S_true", "=", "simplegaussprod", "(", "obs", ",", "model", ".", "noise_cov", ",", "prior", ".", "m", ",", "prior", ".", "S", ")", "\n", "return", "res", ",", "m_true", ",", "S_true", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior": [[40, 57], ["isinstance", "numpy.allclose", "numpy.allclose", "posterior.project_to_gaussian", "isinstance", "posterior.gen", "posterior.gen.mean", "numpy.cov"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.project_to_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ",", "atol_mean", "=", "0.05", ",", "atol_cov", "=", "0.05", ",", "\n", "n_samples", "=", "10000", ")", ":", "\n", "    ", "if", "isinstance", "(", "posterior", ",", "dd", ".", "MoG", ")", ":", "\n", "        ", "posterior_gauss", "=", "posterior", ".", "project_to_gaussian", "(", ")", "\n", "posterior_mean", "=", "posterior_gauss", ".", "m", "\n", "posterior_cov", "=", "posterior_gauss", ".", "S", "\n", "", "elif", "isinstance", "(", "posterior", ",", "MAFconditional", ")", ":", "\n", "# Note that if the inference method was seeded, the resulting posteriors", "\n", "# will also be seeded upon creation when network.get_density is called.", "\n", "        ", "posterior_samples", "=", "posterior", ".", "gen", "(", "n_samples", ")", "\n", "posterior_mean", "=", "posterior_samples", ".", "mean", "(", "axis", "=", "0", ")", "\n", "posterior_cov", "=", "np", ".", "cov", "(", "posterior_samples", ".", "T", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "\n", "\n", "", "assert", "np", ".", "allclose", "(", "posterior_mean", ",", "m_true", ",", "atol", "=", "atol_mean", ")", "\n", "assert", "np", ".", "allclose", "(", "posterior_cov", ",", "S_true", ",", "atol", "=", "atol_cov", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_basic_inference": [[59, 65], ["test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_basic_inference", "(", "n_params", "=", "2", ",", "seed", "=", "42", ")", ":", "\n", "    ", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "Basic", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_basic_inference_inputsamples": [[67, 86], ["delfi.simulator.Gauss.Gauss", "delfi.Gaussian", "delfi.Identity", "delfi.Default", "numpy.zeros", "test_inference.simplegaussprod", "dg.Default.gen", "delfi.Basic", "infer.Basic.reset", "infer.Basic.run", "infer.Basic.predict", "test_inference.check_gaussian_posterior", "infer.Basic.obs.reshape", "numpy.zeros", "numpy.eye"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.simplegaussprod", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_basic_inference_inputsamples", "(", "n_params", "=", "2", ",", "seed", "=", "42", ",", "n_pilot", "=", "1000", ")", ":", "\n", "    ", "model", "=", "Gauss", "(", "dim", "=", "n_params", ",", "seed", "=", "seed", ")", "\n", "prior", "=", "dd", ".", "Gaussian", "(", "m", "=", "np", ".", "zeros", "(", "(", "n_params", ",", ")", ")", ",", "S", "=", "np", ".", "eye", "(", "n_params", ")", ",", "\n", "seed", "=", "seed", "+", "1", ")", "\n", "s", "=", "ds", ".", "Identity", "(", "seed", "=", "seed", "+", "2", ")", "\n", "g", "=", "dg", ".", "Default", "(", "model", "=", "model", ",", "prior", "=", "prior", ",", "summary", "=", "s", ",", "seed", "=", "seed", "+", "3", ")", "\n", "obs", "=", "np", ".", "zeros", "(", "(", "1", ",", "n_params", ")", ")", "# reseed generator etc. (?)", "\n", "m_true", ",", "S_true", "=", "simplegaussprod", "(", "obs", ",", "model", ".", "noise_cov", ",", "prior", ".", "m", ",", "prior", ".", "S", ")", "\n", "\n", "params", ",", "stats", "=", "g", ".", "gen", "(", "n_pilot", ")", "\n", "pilot_samples", "=", "(", "params", ",", "stats", ")", "\n", "\n", "res", "=", "infer", ".", "Basic", "(", "g", ",", "obs", "=", "obs", ",", "seed", "=", "seed", "+", "4", ",", "pilot_samples", "=", "pilot_samples", ")", "\n", "res", ".", "reset", "(", "seed", "=", "seed", "+", "4", ")", "\n", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_snpeB_inference": [[88, 94], ["test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_snpeB_inference", "(", "n_params", "=", "2", ",", "seed", "=", "42", ")", ":", "\n", "    ", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "SNPEB", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ",", "n_rounds", "=", "1", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_apt_inference_mogprop": [[96, 106], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_apt_inference_mogprop", "(", "n_params", "=", "2", ",", "seed", "=", "47", ")", ":", "\n", "    ", "inf_setup_opts", "=", "dict", "(", "n_components", "=", "2", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ",", "n_rounds", "=", "2", ",", "proposal", "=", "'mog'", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ",", "\n", "reuse_prior_samples", "=", "True", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_apt_inference_gaussprop": [[108, 121], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape", "numpy.sqrt"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_apt_inference_gaussprop", "(", "n_params", "=", "2", ",", "seed", "=", "47", ",", "Sfac", "=", "1000.0", ")", ":", "\n", "    ", "inf_setup_opts", "=", "dict", "(", "n_components", "=", "2", ",", "prior_norm", "=", "True", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "Sfac", "=", "Sfac", ",", "\n", "**", "inf_setup_opts", ")", "\n", "# 3 rounds to test sample reuse. by default prior samples not reused", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1500", ",", "n_rounds", "=", "3", ",", "proposal", "=", "'gaussian'", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ",", "\n", "reuse_prior_samples", "=", "True", ")", "\n", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ",", "atol_mean", "=", "0.05", "*", "np", ".", "sqrt", "(", "Sfac", ")", ",", "atol_cov", "=", "0.05", "*", "Sfac", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_apt_inference_atomicprop_mdn": [[123, 132], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_apt_inference_atomicprop_mdn", "(", "n_params", "=", "2", ",", "seed", "=", "47", ")", ":", "\n", "    ", "inf_setup_opts", "=", "dict", "(", "n_components", "=", "2", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1020", ",", "n_rounds", "=", "2", ",", "proposal", "=", "'atomic'", ",", "n_atoms", "=", "10", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ",", "verbose", "=", "True", ",", "val_frac", "=", "0.05", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_apt_inference_atomicprop_mdn_comb": [[134, 143], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_apt_inference_atomicprop_mdn_comb", "(", "n_params", "=", "2", ",", "seed", "=", "47", ")", ":", "\n", "    ", "inf_setup_opts", "=", "dict", "(", "n_components", "=", "2", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ",", "n_rounds", "=", "2", ",", "proposal", "=", "'atomic_comb'", ",", "\n", "n_atoms", "=", "10", ",", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_apt_inference_atomicprop_maf": [[145, 155], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_apt_inference_atomicprop_maf", "(", "n_params", "=", "2", ",", "seed", "=", "47", ")", ":", "\n", "    ", "inf_setup_opts", "=", "dict", "(", "density", "=", "'maf'", ",", "maf_mode", "=", "'random'", ",", "n_mades", "=", "5", ",", "\n", "maf_actfun", "=", "'tanh'", ",", "batch_norm", "=", "False", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ",", "n_rounds", "=", "2", ",", "proposal", "=", "'atomic'", ",", "n_atoms", "=", "10", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_apt_inference_atomicprop_maf_comb": [[157, 167], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_apt_inference_atomicprop_maf_comb", "(", "n_params", "=", "2", ",", "seed", "=", "47", ")", ":", "\n", "    ", "inf_setup_opts", "=", "dict", "(", "density", "=", "'maf'", ",", "maf_mode", "=", "'random'", ",", "n_mades", "=", "5", ",", "\n", "maf_actfun", "=", "'tanh'", ",", "batch_norm", "=", "False", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "1000", ",", "n_rounds", "=", "2", ",", "proposal", "=", "'atomic_comb'", ",", "n_atoms", "=", "10", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_inference_apt_maf_rnn": [[169, 188], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_inference_apt_maf_rnn", "(", "n_steps", "=", "2", ",", "dim_per_t", "=", "2", ",", "seed", "=", "42", ")", ":", "\n", "    ", "if", "theano", ".", "config", ".", "device", "==", "'cpu'", ":", "\n", "        ", "return", "# need a gpu", "\n", "# we're going to reshape a Gaussian observation to be a time series", "\n", "# this will test the code but a better test would be a Kalman filter.", "\n", "", "n_params", "=", "n_steps", "*", "dim_per_t", "\n", "\n", "# we need to infer a posterior with n_params degrees of freedom, so we need", "\n", "# to essentially \"record\" every data dimension with the RNN", "\n", "inf_setup_opts", "=", "dict", "(", "density", "=", "'maf'", ",", "maf_mode", "=", "'random'", ",", "n_mades", "=", "5", ",", "\n", "maf_actfun", "=", "'tanh'", ",", "batch_norm", "=", "False", ",", "\n", "n_rnn", "=", "5", "*", "n_params", ",", "input_shape", "=", "(", "n_steps", ",", "dim_per_t", ")", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "5000", ",", "n_rounds", "=", "2", ",", "proposal", "=", "'atomic'", ",", "n_atoms", "=", "10", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.test_inference_apt_maf_cnn": [[190, 212], ["dict", "test_inference.init_all_gaussian", "res.run", "res.predict", "test_inference.check_gaussian_posterior", "res.obs.reshape"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.init_all_gaussian", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.check_gaussian_posterior"], ["", "def", "test_inference_apt_maf_cnn", "(", "rows", "=", "2", ",", "cols", "=", "2", ",", "seed", "=", "42", ")", ":", "\n", "    ", "if", "theano", ".", "config", ".", "device", "==", "'cpu'", ":", "\n", "        ", "return", "# need a gpu", "\n", "# we're going to reshape a Gaussian observation to be an image", "\n", "# this will test the code but a better test would involve correlated x_i.", "\n", "# one option would be to try using a very small blob model", "\n", "", "n_params", "=", "rows", "*", "cols", "\n", "\n", "# we need to infer a posterior with n_params degrees of freedom, so we need", "\n", "# to essentially \"record\" every data dimension with the CNN", "\n", "inf_setup_opts", "=", "dict", "(", "density", "=", "'maf'", ",", "maf_mode", "=", "'random'", ",", "n_mades", "=", "5", ",", "\n", "maf_actfun", "=", "'tanh'", ",", "batch_norm", "=", "False", ",", "\n", "n_filters", "=", "[", "2", "*", "n_params", "]", ",", "filter_sizes", "=", "[", "2", "]", ",", "\n", "pool_sizes", "=", "[", "1", "]", ",", "\n", "input_shape", "=", "(", "1", ",", "rows", ",", "cols", ")", ")", "\n", "res", ",", "m_true", ",", "S_true", "=", "init_all_gaussian", "(", "seed", "=", "seed", ",", "n_params", "=", "n_params", ",", "\n", "inferenceobj", "=", "infer", ".", "APT", ",", "\n", "**", "inf_setup_opts", ")", "\n", "out", "=", "res", ".", "run", "(", "n_train", "=", "5000", ",", "n_rounds", "=", "3", ",", "proposal", "=", "'atomic'", ",", "n_atoms", "=", "10", ",", "\n", "train_on_all", "=", "True", ",", "silent_fail", "=", "False", ",", "print_each_epoch", "=", "True", ")", "\n", "posterior", "=", "res", ".", "predict", "(", "res", ".", "obs", ".", "reshape", "(", "1", ",", "-", "1", ")", ")", "\n", "check_gaussian_posterior", "(", "posterior", ",", "m_true", ",", "S_true", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.functional.test_inference.dont_test_apt_inference_atomicprop_maf_normalize": [[214, 221], ["delfi.simulator.Gauss.Gauss", "delfi.Uniform", "delfi.Identity", "delfi.Default", "numpy.ones", "numpy.ones"], "function", ["None"], ["", "def", "dont_test_apt_inference_atomicprop_maf_normalize", "(", "n_params", ",", "seed", "=", "47", ")", ":", "\n", "# normalization test is not finished yet.", "\n", "    ", "m", "=", "Gauss", "(", "dim", "=", "n_params", ",", "noise_cov", "=", "0.1", ")", "\n", "p", "=", "dd", ".", "Uniform", "(", "lower", "=", "-", "0.05", "*", "np", ".", "ones", "(", "n_params", ")", ",", "\n", "upper", "=", "0.05", "*", "np", ".", "ones", "(", "n_params", ")", ")", "\n", "s", "=", "ds", ".", "Identity", "(", ")", "\n", "g", "=", "dg", ".", "Default", "(", "model", "=", "m", ",", "prior", "=", "p", ",", "summary", "=", "s", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_math.test_gaussprodZ": [[10, 21], ["delfi.distribution.Gaussian", "delfi.distribution.Gaussian", "delfi.gaussprodintegral", "numpy.vstack", "xprod.eval", "numpy.isclose().all", "delfi.distribution.Gaussian.eval", "delfi.distribution.Gaussian.eval", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.isclose"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussprodintegral", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["def", "test_gaussprodZ", "(", ")", ":", "\n", "    ", "x1", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "0.25", ",", "0.5", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "0.6", ",", "0.1", "]", ",", "[", "0.1", ",", "0.5", "]", "]", ")", ")", "\n", "x2", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "-", "0.1", ",", "0.2", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "-", "0.1", "]", ",", "[", "-", "0.1", ",", "1.25", "]", "]", ")", ")", "\n", "xprod", "=", "x1", "*", "x2", "# new Gaussian random variable from pdf product", "\n", "logZ", "=", "mm", ".", "gaussprodintegral", "(", "x1", ",", "x2", ",", "log", "=", "True", ")", "\n", "\n", "test_pts", "=", "np", ".", "vstack", "(", "(", "x1", ".", "m", ",", "x2", ".", "m", ",", "(", "x1", ".", "m", "+", "x2", ".", "m", ")", "/", "2.0", ",", "xprod", ".", "m", ",", "0.0", "*", "x1", ".", "m", ")", ")", "\n", "lpdfprod", "=", "x1", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "+", "x2", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "\n", "lpdfprod_normed", "=", "xprod", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "\n", "\n", "assert", "np", ".", "isclose", "(", "lpdfprod_normed", "+", "logZ", ",", "lpdfprod", ")", ".", "all", "(", ")", ",", "\"wrong Z (prod)\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_math.test_gaussquotientZ": [[23, 34], ["delfi.distribution.Gaussian", "delfi.distribution.Gaussian", "delfi.gaussquotientintegral", "numpy.vstack", "xquot.eval", "numpy.isclose().all", "delfi.distribution.Gaussian.eval", "delfi.distribution.Gaussian.eval", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.isclose"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussquotientintegral", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_gaussquotientZ", "(", ")", ":", "\n", "    ", "x1", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "0.25", ",", "0.5", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "0.6", ",", "0.1", "]", ",", "[", "0.1", ",", "0.5", "]", "]", ")", ")", "\n", "x2", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "-", "0.1", ",", "0.2", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "-", "0.1", "]", ",", "[", "-", "0.1", ",", "1.25", "]", "]", ")", ")", "\n", "xquot", "=", "x1", "/", "x2", "# new Gaussian random variable from pdf product", "\n", "logZ", "=", "mm", ".", "gaussquotientintegral", "(", "x1", ",", "x2", ",", "log", "=", "True", ")", "\n", "\n", "test_pts", "=", "np", ".", "vstack", "(", "(", "x1", ".", "m", ",", "x2", ".", "m", ",", "(", "x1", ".", "m", "+", "x2", ".", "m", ")", "/", "2.0", ",", "xquot", ".", "m", ",", "0.0", "*", "x1", ".", "m", ")", ")", "\n", "\n", "lpdfquot", "=", "x1", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "-", "x2", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "\n", "lpdfquot_normed", "=", "xquot", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "\n", "assert", "np", ".", "isclose", "(", "lpdfquot_normed", "+", "logZ", ",", "lpdfquot", ")", ".", "all", "(", ")", ",", "\"wrong Z (quot)\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_math.test_gaussprodquotientZ": [[36, 50], ["delfi.distribution.Gaussian", "delfi.distribution.Gaussian", "delfi.distribution.Gaussian", "delfi.gaussprodquotientintegral", "numpy.vstack", "xprodquot.eval", "numpy.isclose().all", "delfi.distribution.Gaussian.eval", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "delfi.distribution.Gaussian.eval", "delfi.distribution.Gaussian.eval", "numpy.isclose"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.math.gaussprodquotientintegral", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_gaussprodquotientZ", "(", ")", ":", "\n", "    ", "x1", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "0.25", ",", "0.5", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "0.6", ",", "0.1", "]", ",", "[", "0.1", ",", "0.5", "]", "]", ")", ")", "\n", "x2", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "-", "0.1", ",", "0.2", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "1.5", ",", "-", "0.1", "]", ",", "[", "-", "0.1", ",", "1.25", "]", "]", ")", ")", "\n", "x3", "=", "Gaussian", "(", "m", "=", "np", ".", "array", "(", "[", "-", "0.05", ",", "0.3", "]", ")", ",", "S", "=", "np", ".", "array", "(", "[", "[", "3.5", ",", "-", "0.1", "]", ",", "[", "-", "0.1", ",", "4.25", "]", "]", ")", ")", "\n", "xprodquot", "=", "(", "x1", "*", "x2", ")", "/", "x3", "# new Gaussian random variable from pdf product", "\n", "logZ", "=", "mm", ".", "gaussprodquotientintegral", "(", "x1", ",", "x2", ",", "x3", ",", "log", "=", "True", ")", "\n", "\n", "test_pts", "=", "np", ".", "vstack", "(", "(", "x1", ".", "m", ",", "x2", ".", "m", ",", "x3", ".", "m", ",", "(", "x1", ".", "m", "+", "x2", ".", "m", "+", "x3", ".", "m", ")", "/", "3.0", ",", "\n", "xprodquot", ".", "m", ",", "0.0", "*", "x1", ".", "m", ")", ")", "\n", "\n", "lpdfprodquot", "=", "x1", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "+", "x2", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "-", "x3", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "\n", "lpdfprodquot_normed", "=", "xprodquot", ".", "eval", "(", "test_pts", ",", "log", "=", "True", ")", "\n", "assert", "np", ".", "isclose", "(", "lpdfprodquot_normed", "+", "logZ", ",", "lpdfprodquot", ")", ".", "all", "(", ")", ",", "\"wrong Z (prod-quot)\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_math.test_bijections": [[52, 70], ["numpy.random.RandomState", "dict", "delfi.utils.bijection.named_bijection", "np.random.RandomState.rand", "f", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.allclose", "dict.update", "finv", "finv", "f_jac_logD", "f_jac_logD", "dict", "finv_jac_logD", "finv_jac_logD", "np.random.RandomState.rand", "np.random.RandomState.rand"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.named_bijection", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.Worker.update"], ["", "def", "test_bijections", "(", "dim", "=", "2", ",", "nsamples", "=", "1000", ",", "seed", "=", "1", ")", ":", "\n", "    ", "rng", "=", "np", ".", "random", ".", "RandomState", "(", "seed", "=", "seed", ")", "\n", "\n", "for", "name", "in", "[", "'affine'", ",", "'logit'", ",", "'norminvcdf'", "]", ":", "\n", "\n", "        ", "kwargs", "=", "dict", "(", ")", "\n", "if", "name", "==", "'affine'", ":", "\n", "            ", "kwargs", ".", "update", "(", "dict", "(", "scale", "=", "1.0", "+", "rng", ".", "rand", "(", "dim", ")", ",", "\n", "offset", "=", "rng", ".", "rand", "(", "dim", ")", ")", ")", "\n", "\n", "", "f", ",", "finv", ",", "f_jac_logD", ",", "finv_jac_logD", "=", "named_bijection", "(", "name", ",", "**", "kwargs", ")", "\n", "\n", "x", "=", "rng", ".", "rand", "(", "nsamples", ",", "dim", ")", "# values between 0 and 1", "\n", "y", "=", "f", "(", "x", ")", "\n", "assert", "np", ".", "allclose", "(", "x", ",", "finv", "(", "y", ")", ",", "atol", "=", "1e-8", ")", "\n", "assert", "np", ".", "allclose", "(", "x", "[", "0", "]", ",", "finv", "(", "y", "[", "0", "]", ")", ",", "atol", "=", "1e-8", ")", "\n", "assert", "np", ".", "allclose", "(", "f_jac_logD", "(", "x", ")", ",", "-", "finv_jac_logD", "(", "y", ")", ",", "atol", "=", "1e-8", ")", "\n", "assert", "np", ".", "allclose", "(", "f_jac_logD", "(", "x", "[", "0", "]", ")", ",", "-", "finv_jac_logD", "(", "y", "[", "0", "]", ")", ",", "atol", "=", "1e-8", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_math.test_batched_matrix_ops": [[72, 105], ["numpy.full", "numpy.full", "numpy.full", "numpy.full", "numpy.full", "range", "delfi.tensorN", "theano.function", "theano.function", "theano.function", "theano.function.", "theano.function.", "theano.function.", "numpy.allclose", "numpy.allclose", "numpy.allclose", "numpy.dot", "numpy.dot", "numpy.linalg.inv", "numpy.linalg.det", "theano.function.", "numpy.tril", "numpy.diag", "numpy.tril", "numpy.diag", "numpy.tril", "numpy.diag", "numpy.dot", "delfi.cholesky_each", "delfi.invert_each", "delfi.det_each", "isinstance", "numpy.random.randn", "numpy.random.rand", "numpy.exp", "numpy.random.rand", "numpy.exp", "numpy.exp", "numpy.random.randn", "numpy.random.randn", "numpy.random.randn"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.tensorN", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.cholesky_each", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.invert_each", "home.repos.pwc.inspect_result.mackelab_delfi.utils.symbolic.det_each"], ["", "", "def", "test_batched_matrix_ops", "(", "dim", "=", "4", ",", "nsamples", "=", "100", ")", ":", "\n", "    ", "A_pd", "=", "np", ".", "full", "(", "(", "nsamples", ",", "dim", ",", "dim", ")", ",", "np", ".", "nan", ",", "dtype", "=", "dtype", ")", "\n", "A_nonsing", "=", "np", ".", "full", "(", "(", "nsamples", ",", "dim", ",", "dim", ")", ",", "np", ".", "nan", ",", "dtype", "=", "dtype", ")", "\n", "L", "=", "np", ".", "full", "(", "(", "nsamples", ",", "dim", ",", "dim", ")", ",", "np", ".", "nan", ",", "dtype", "=", "dtype", ")", "\n", "inv", "=", "np", ".", "full", "(", "(", "nsamples", ",", "dim", ",", "dim", ")", ",", "np", ".", "nan", ",", "dtype", "=", "dtype", ")", "\n", "det", "=", "np", ".", "full", "(", "nsamples", ",", "np", ".", "nan", ",", "dtype", "=", "dtype", ")", "\n", "for", "i", "in", "range", "(", "nsamples", ")", ":", "\n", "        ", "L", "[", "i", "]", "=", "np", ".", "tril", "(", "np", ".", "random", ".", "randn", "(", "dim", ",", "dim", ")", ",", "-", "1", ")", "+", "np", ".", "diag", "(", "1.0", "+", "np", ".", "exp", "(", "np", ".", "random", ".", "randn", "(", "dim", ")", ")", ")", "\n", "A_pd", "[", "i", "]", "=", "np", ".", "dot", "(", "L", "[", "i", "]", ",", "L", "[", "i", "]", ".", "T", ")", "\n", "L2", "=", "np", ".", "tril", "(", "np", ".", "random", ".", "rand", "(", "dim", ",", "dim", ")", ",", "-", "1", ")", "+", "np", ".", "diag", "(", "np", ".", "exp", "(", "np", ".", "random", ".", "randn", "(", "dim", ")", ")", ")", "\n", "L3", "=", "np", ".", "tril", "(", "np", ".", "random", ".", "rand", "(", "dim", ",", "dim", ")", ",", "-", "1", ")", "+", "np", ".", "diag", "(", "np", ".", "exp", "(", "np", ".", "random", ".", "randn", "(", "dim", ")", ")", ")", "\n", "A_nonsing", "[", "i", "]", "=", "np", ".", "dot", "(", "np", ".", "dot", "(", "L2", ",", "A_pd", "[", "i", "]", ")", ",", "L3", ".", "T", ")", "\n", "inv", "[", "i", "]", "=", "np", ".", "linalg", ".", "inv", "(", "A_nonsing", "[", "i", "]", ")", "\n", "det", "[", "i", "]", "=", "np", ".", "linalg", ".", "det", "(", "A_nonsing", "[", "i", "]", ")", "\n", "\n", "", "tA", "=", "sym", ".", "tensorN", "(", "3", ")", "\n", "f_choleach", "=", "theano", ".", "function", "(", "inputs", "=", "[", "tA", "]", ",", "outputs", "=", "sym", ".", "cholesky_each", "(", "tA", ")", ")", "\n", "f_inveach", "=", "theano", ".", "function", "(", "inputs", "=", "[", "tA", "]", ",", "outputs", "=", "sym", ".", "invert_each", "(", "tA", ")", ")", "\n", "f_deteach", "=", "theano", ".", "function", "(", "inputs", "=", "[", "tA", "]", ",", "outputs", "=", "sym", ".", "det_each", "(", "tA", ")", ")", "\n", "\n", "symL", "=", "f_choleach", "(", "A_pd", ")", "\n", "symdet", "=", "f_deteach", "(", "A_nonsing", ")", "\n", "syminv", "=", "f_inveach", "(", "A_nonsing", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "symL", ",", "L", ",", "atol", "=", "1e-8", ")", "\n", "assert", "np", ".", "allclose", "(", "symdet", ",", "det", ",", "atol", "=", "1e-8", ")", "\n", "assert", "np", ".", "allclose", "(", "syminv", ",", "inv", ",", "atol", "=", "1e-8", ")", "\n", "\n", "try", ":", "\n", "        ", "f_choleach", "(", "A_nonsing", ")", "# try Cholesky factorizing some non-symmetric matrices", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "assert", "isinstance", "(", "e", ",", "np", ".", "linalg", ".", "linalg", ".", "LinAlgError", ")", ",", "\"unexpected error when trying Cholesky factorization of non-symmetric matrix\"", "\n", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_discrete_gen": [[9, 17], ["delfi.Discrete", "dd.Discrete.gen", "numpy.isclose", "numpy.array", "numpy.sum"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["def", "test_discrete_gen", "(", ")", ":", "\n", "    ", "N", "=", "25000", "\n", "p", "=", "0.9", "\n", "dist", "=", "dd", ".", "Discrete", "(", "np", ".", "array", "(", "[", "1", "-", "p", ",", "p", "]", ")", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "np", ".", "isclose", "(", "np", ".", "sum", "(", "samples", ")", "/", "N", ",", "p", ",", "atol", "=", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_gaussian_1d": [[19, 32], ["delfi.Gaussian", "dd.Gaussian.gen", "dd.Gaussian.eval", "numpy.isclose", "numpy.isclose", "numpy.mean().reshape", "numpy.cov().reshape", "numpy.mean", "numpy.cov"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "test_gaussian_1d", "(", ")", ":", "\n", "    ", "N", "=", "50000", "\n", "m", "=", "[", "1.", "]", "\n", "S", "=", "[", "[", "3.", "]", "]", "\n", "dist", "=", "dd", ".", "Gaussian", "(", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "assert", "np", ".", "isclose", "(", "np", ".", "mean", "(", "samples", ")", ".", "reshape", "(", "-", "1", ")", ",", "m", ",", "atol", "=", "0.1", ")", "\n", "assert", "np", ".", "isclose", "(", "\n", "np", ".", "cov", "(", "samples", ",", "rowvar", "=", "False", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "S", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_gaussian_3d": [[34, 48], ["delfi.Gaussian", "dd.Gaussian.gen", "dd.Gaussian.eval", "numpy.allclose", "numpy.allclose", "numpy.mean", "numpy.cov"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "test_gaussian_3d", "(", ")", ":", "\n", "    ", "N", "=", "50000", "\n", "m", "=", "[", "1.", ",", "3.", ",", "0.", "]", "\n", "S", "=", "[", "[", "8.", ",", "2.", ",", "1.", "]", ",", "\n", "[", "2.", ",", "3.", ",", "2.", "]", ",", "\n", "[", "1.", ",", "2.", ",", "3.", "]", "]", "\n", "dist", "=", "dd", ".", "Gaussian", "(", "m", "=", "m", ",", "S", "=", "S", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "3", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "mean", "(", "samples", ",", "axis", "=", "0", ")", ",", "m", ",", "atol", "=", "0.1", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "cov", "(", "samples", ",", "rowvar", "=", "False", ")", ",", "S", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_poisson": [[50, 61], ["delfi.Poisson", "dd.Poisson.gen", "dd.Poisson.eval", "numpy.allclose", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "test_poisson", "(", ")", ":", "\n", "    ", "N", "=", "50000", "\n", "mu", "=", "5.", "\n", "offset", "=", "1.", "\n", "dist", "=", "dd", ".", "Poisson", "(", "mu", "=", "mu", ",", "offset", "=", "offset", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "mean", "(", "samples", ",", "axis", "=", "0", ")", ",", "mu", "+", "offset", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_studentst_1d": [[63, 78], ["delfi.StudentsT", "dd.StudentsT.gen", "dd.StudentsT.eval", "numpy.isclose", "numpy.isclose", "numpy.asarray", "numpy.mean().reshape", "numpy.cov().reshape", "numpy.mean", "numpy.cov"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "test_studentst_1d", "(", ")", ":", "\n", "    ", "N", "=", "100000", "\n", "m", "=", "[", "1.", "]", "\n", "S", "=", "[", "[", "3.", "]", "]", "\n", "dof", "=", "1000", "\n", "dist", "=", "dd", ".", "StudentsT", "(", "m", "=", "m", ",", "S", "=", "S", ",", "dof", "=", "dof", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "St", "=", "np", ".", "asarray", "(", "S", ")", "*", "(", "dof", "/", "(", "dof", "-", "2", ")", ")", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "assert", "np", ".", "isclose", "(", "np", ".", "mean", "(", "samples", ")", ".", "reshape", "(", "-", "1", ")", ",", "m", ",", "atol", "=", "0.1", ")", "\n", "assert", "np", ".", "isclose", "(", "\n", "np", ".", "cov", "(", "samples", ",", "rowvar", "=", "False", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ",", "St", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_studentst_3d": [[80, 96], ["delfi.StudentsT", "dd.StudentsT.gen", "dd.StudentsT.eval", "numpy.allclose", "numpy.allclose", "numpy.asarray", "numpy.mean", "numpy.cov"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["", "def", "test_studentst_3d", "(", ")", ":", "\n", "    ", "N", "=", "100000", "\n", "m", "=", "[", "1.", ",", "3.", ",", "0.", "]", "\n", "S", "=", "[", "[", "8.", ",", "2.", ",", "1.", "]", ",", "\n", "[", "2.", ",", "3.", ",", "2.", "]", ",", "\n", "[", "1.", ",", "2.", ",", "3.", "]", "]", "\n", "dof", "=", "1000", "\n", "dist", "=", "dd", ".", "StudentsT", "(", "m", "=", "m", ",", "S", "=", "S", ",", "dof", "=", "dof", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "St", "=", "np", ".", "asarray", "(", "S", ")", "*", "(", "dof", "/", "(", "dof", "-", "2", ")", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "3", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "mean", "(", "samples", ",", "axis", "=", "0", ")", ",", "m", ",", "atol", "=", "0.1", ")", "\n", "assert", "np", ".", "allclose", "(", "np", ".", "cov", "(", "samples", ",", "rowvar", "=", "False", ")", ",", "St", ",", "atol", "=", "0.1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_uniform_1d": [[98, 108], ["delfi.Uniform", "dd.Uniform.gen", "dd.Uniform.eval"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_uniform_1d", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "lower", "=", "[", "1.", "]", "\n", "upper", "=", "[", "2.", "]", "\n", "dist", "=", "dd", ".", "Uniform", "(", "lower", ",", "upper", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_uniform_2d": [[110, 120], ["delfi.Uniform", "dd.Uniform.gen", "dd.Uniform.eval"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_uniform_2d", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "lower", "=", "[", "1.", ",", "3.", "]", "\n", "upper", "=", "[", "2.", ",", "4.", "]", "\n", "dist", "=", "dd", ".", "Uniform", "(", "lower", ",", "upper", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "2", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_IndependentJoint_eval": [[122, 136], ["delfi.Uniform", "delfi.Uniform", "delfi.IndependentJoint", "dd.IndependentJoint.gen", "dd.IndependentJoint.eval", "numpy.isclose().all", "numpy.log", "numpy.isclose"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log"], ["", "def", "test_IndependentJoint_eval", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "B1", "=", "[", "-", "1.0", ",", "1.0", "]", "\n", "B2", "=", "[", "-", "2.0", ",", "2.0", "]", "\n", "u1", "=", "dd", ".", "Uniform", "(", "B1", "[", "0", "]", ",", "B1", "[", "1", "]", ")", "\n", "u2", "=", "dd", ".", "Uniform", "(", "B2", "[", "0", "]", ",", "B2", "[", "1", "]", ")", "\n", "dist", "=", "dd", ".", "IndependentJoint", "(", "[", "u1", ",", "u2", "]", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ",", "log", "=", "True", ")", "\n", "lpdfval", "=", "-", "np", ".", "log", "(", "(", "B2", "[", "1", "]", "-", "B2", "[", "0", "]", ")", "*", "(", "B1", "[", "1", "]", "-", "B1", "[", "0", "]", ")", ")", "\n", "assert", "np", ".", "isclose", "(", "logprobs", ",", "lpdfval", ")", ".", "all", "(", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "2", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_IndependentJoint_marginals": [[138, 160], ["numpy.array", "delfi.IndependentJoint", "dd.IndependentJoint.gen", "dd.IndependentJoint.eval", "numpy.isclose().all", "dd.IndependentJoint.dists[].eval", "dd.IndependentJoint.dists[].eval", "dd.IndependentJoint.dists[].eval", "dd.IndependentJoint.eval", "numpy.isclose().all", "delfi.Gaussian", "numpy.arange", "dd.IndependentJoint.eval", "range", "numpy.isclose", "numpy.isclose", "numpy.vstack().sum", "numpy.vstack"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_IndependentJoint_marginals", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "m", "=", "np", ".", "array", "(", "[", "1.", ",", "3.", ",", "0.", "]", ")", "\n", "S", "=", "[", "[", "8.", ",", "2.", ",", "1.", "]", ",", "\n", "[", "2.", ",", "3.", ",", "2.", "]", ",", "\n", "[", "1.", ",", "2.", ",", "3.", "]", "]", "\n", "gs", "=", "[", "dd", ".", "Gaussian", "(", "m", "=", "m", "+", "i", ",", "S", "=", "S", ")", "for", "i", "in", "[", "-", "1", ",", "0", ",", "1", "]", "]", "\n", "dist", "=", "dd", ".", "IndependentJoint", "(", "gs", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "log_probs", "=", "dist", ".", "eval", "(", "samples", ",", "log", "=", "True", ")", "\n", "jjs", "=", "[", "np", ".", "arange", "(", "3", "*", "i", ",", "3", "*", "(", "i", "+", "1", ")", ")", "for", "i", "in", "range", "(", "3", ")", "]", "\n", "log_marginals", "=", "[", "dist", ".", "eval", "(", "samples", "[", ":", ",", "jj", "]", ",", "ii", "=", "jj", ")", "for", "jj", "in", "jjs", "]", "\n", "assert", "np", ".", "isclose", "(", "log_probs", ",", "np", ".", "vstack", "(", "log_marginals", ")", ".", "sum", "(", "axis", "=", "0", ")", ")", ".", "all", "(", ")", "\n", "\n", "log_submarginal_1", "=", "dist", ".", "dists", "[", "0", "]", ".", "eval", "(", "samples", "[", ":", ",", "[", "1", "]", "]", ",", "ii", "=", "[", "1", "]", ")", "\n", "log_submarginal_4", "=", "dist", ".", "dists", "[", "1", "]", ".", "eval", "(", "samples", "[", ":", ",", "[", "4", "]", "]", ",", "ii", "=", "[", "1", "]", ")", "\n", "log_submarginal_6_7_8", "=", "dist", ".", "dists", "[", "2", "]", ".", "eval", "(", "samples", "[", ":", ",", "[", "6", ",", "7", ",", "8", "]", "]", ")", "\n", "log_submarginal_1_4_6_7_8", "=", "dist", ".", "eval", "(", "samples", "[", ":", ",", "[", "1", ",", "4", ",", "6", ",", "7", ",", "8", "]", "]", ",", "\n", "ii", "=", "[", "1", ",", "4", ",", "6", ",", "7", ",", "8", "]", ")", "\n", "assert", "np", ".", "isclose", "(", "log_submarginal_1_4_6_7_8", ",", "\n", "log_submarginal_1", "+", "log_submarginal_4", "+", "\n", "log_submarginal_6_7_8", ")", ".", "all", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_mixture_of_gaussians_1d": [[162, 174], ["delfi.MoG", "dd.MoG.gen", "dd.MoG.eval"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_mixture_of_gaussians_1d", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "m", "=", "[", "1.", "]", "\n", "S", "=", "[", "[", "3.", "]", "]", "\n", "ms", "=", "[", "m", ",", "m", "]", "\n", "Ss", "=", "[", "S", ",", "S", "]", "\n", "dist", "=", "dd", ".", "MoG", "(", "a", "=", "[", "0.5", ",", "0.5", "]", ",", "ms", "=", "ms", ",", "Ss", "=", "Ss", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_mixture_of_gaussians_3d": [[176, 190], ["delfi.MoG", "dd.MoG.gen", "dd.MoG.eval"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_mixture_of_gaussians_3d", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "m", "=", "[", "1.", ",", "3.", ",", "0.", "]", "\n", "S", "=", "[", "[", "8.", ",", "2.", ",", "1.", "]", ",", "\n", "[", "2.", ",", "3.", ",", "2.", "]", ",", "\n", "[", "1.", ",", "2.", ",", "3.", "]", "]", "\n", "ms", "=", "[", "m", ",", "m", "]", "\n", "Ss", "=", "[", "S", ",", "S", "]", "\n", "dist", "=", "dd", ".", "MoG", "(", "a", "=", "[", "0.5", ",", "0.5", "]", ",", "ms", "=", "ms", ",", "Ss", "=", "Ss", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "3", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_mixture_of_studentst_1d": [[192, 206], ["delfi.MoT", "dd.MoT.gen", "dd.MoT.eval"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_mixture_of_studentst_1d", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "m", "=", "[", "1.", "]", "\n", "S", "=", "[", "[", "3.", "]", "]", "\n", "dof", "=", "1000", "\n", "ms", "=", "[", "m", ",", "m", "]", "\n", "Ss", "=", "[", "S", ",", "S", "]", "\n", "dofs", "=", "[", "dof", ",", "dof", "]", "\n", "dist", "=", "dd", ".", "MoT", "(", "a", "=", "[", "0.5", ",", "0.5", "]", ",", "ms", "=", "ms", ",", "Ss", "=", "Ss", ",", "dofs", "=", "dofs", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "1", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_mixture_of_studentst_3d": [[208, 224], ["delfi.MoT", "dd.MoT.gen", "dd.MoT.eval"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_mixture_of_studentst_3d", "(", ")", ":", "\n", "    ", "N", "=", "1000", "\n", "m", "=", "[", "1.", ",", "3.", ",", "0.", "]", "\n", "S", "=", "[", "[", "8.", ",", "2.", ",", "1.", "]", ",", "\n", "[", "2.", ",", "3.", ",", "2.", "]", ",", "\n", "[", "1.", ",", "2.", ",", "3.", "]", "]", "\n", "dof", "=", "1000", "\n", "ms", "=", "[", "m", ",", "m", "]", "\n", "Ss", "=", "[", "S", ",", "S", "]", "\n", "dofs", "=", "[", "dof", ",", "dof", "]", "\n", "dist", "=", "dd", ".", "MoT", "(", "a", "=", "[", "0.5", ",", "0.5", "]", ",", "ms", "=", "ms", ",", "Ss", "=", "Ss", ",", "dofs", "=", "dofs", ",", "seed", "=", "seed", ")", "\n", "samples", "=", "dist", ".", "gen", "(", "N", ")", "\n", "logprobs", "=", "dist", ".", "eval", "(", "samples", ")", "\n", "\n", "assert", "samples", ".", "shape", "==", "(", "N", ",", "3", ")", "\n", "assert", "logprobs", ".", "shape", "==", "(", "N", ",", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_distribution.test_TransformedDistribution": [[226, 264], ["numpy.random.rand", "delfi.Uniform", "dd.Uniform.reseed", "dd.Uniform.gen", "delfi.utils.bijection.named_bijection", "delfi.utils.bijection.named_bijection", "delfi.TransformedDistribution", "dd.TransformedDistribution.reseed", "dd.TransformedDistribution.gen", "numpy.allclose", "delfi.Logistic", "numpy.allclose", "numpy.allclose", "numpy.random.rand", "g", "finv", "bijection", "dd.Logistic.eval", "dd.TransformedDistribution.eval", "dd.Logistic.eval", "dd.TransformedDistribution.eval", "f", "ginv", "g_jac_logD", "f_jac_logD", "numpy.zeros", "f"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.named_bijection", "home.repos.pwc.inspect_result.mackelab_delfi.utils.bijection.named_bijection", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.eval"], ["", "def", "test_TransformedDistribution", "(", "seed", "=", "5", ",", "nsamples", "=", "1000", ",", "ndim", "=", "2", ")", ":", "\n", "    ", "lower", "=", "np", ".", "random", ".", "rand", "(", "ndim", ")", "\n", "upper", "=", "np", ".", "random", ".", "rand", "(", "ndim", ")", "+", "2", "\n", "dist", "=", "dd", ".", "Uniform", "(", "lower", ",", "upper", ")", "\n", "\n", "dist", ".", "reseed", "(", "seed", ")", "\n", "z", "=", "dist", ".", "gen", "(", "nsamples", ")", "\n", "\n", "f", ",", "finv", ",", "f_jac_logD", ",", "finv_jac_logD", "=", "named_bijection", "(", "'affine'", ",", "\n", "scale", "=", "1.0", "/", "(", "upper", "-", "lower", ")", ",", "\n", "offset", "=", "-", "lower", "/", "(", "upper", "-", "lower", ")", ")", "\n", "\n", "g", ",", "ginv", ",", "g_jac_logD", ",", "ginv_jac_logD", "=", "named_bijection", "(", "'logit'", ")", "\n", "\n", "bijection", "=", "lambda", "x", ":", "g", "(", "f", "(", "x", ")", ")", "\n", "inverse_bijection", "=", "lambda", "y", ":", "finv", "(", "ginv", "(", "y", ")", ")", "\n", "bijection_jac_logD", "=", "lambda", "x", ":", "g_jac_logD", "(", "f", "(", "x", ")", ")", "+", "f_jac_logD", "(", "x", ")", "\n", "\n", "#inputscale = lambda x: (x - lower) / (upper - lower)", "\n", "#bijection = lambda x: logit(inputscale(x))  # logit function with scaled input", "\n", "#inverse_bijection = lambda y: expit(y) * (upper - lower) + lower  # logistic function with scaled output", "\n", "#bijection_jac_logD = lambda x: -(np.log(inputscale(x) * (1 - inputscale(x))) + np.log(upper - lower)).sum(axis=-1)", "\n", "\n", "dist_transformed", "=", "dd", ".", "TransformedDistribution", "(", "distribution", "=", "dist", ",", "\n", "bijection", "=", "bijection", ",", "\n", "inverse_bijection", "=", "inverse_bijection", ",", "\n", "bijection_jac_logD", "=", "bijection_jac_logD", ")", "\n", "dist_transformed", ".", "reseed", "(", "seed", ")", "\n", "z_transformed", "=", "dist_transformed", ".", "gen", "(", "nsamples", ")", "\n", "assert", "np", ".", "allclose", "(", "z_transformed", ",", "bijection", "(", "z", ")", ",", "atol", "=", "1e-8", ")", "\n", "\n", "dist_logistic", "=", "dd", ".", "Logistic", "(", "mu", "=", "np", ".", "zeros", "(", "ndim", ")", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "dist_logistic", ".", "eval", "(", "z_transformed", ",", "log", "=", "False", ")", ",", "dist_transformed", ".", "eval", "(", "z_transformed", ",", "log", "=", "False", ")", ")", ",", "\"incorrect density\"", "\n", "assert", "np", ".", "allclose", "(", "dist_logistic", ".", "eval", "(", "z_transformed", ",", "log", "=", "True", ")", ",", "dist_transformed", ".", "eval", "(", "z_transformed", ",", "log", "=", "True", ")", ")", ",", "\"incorrect log density\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_MoGL2.test_1D_1K": [[7, 23], ["delfi.distribution.MoG", "delfi.distribution.MoG", "scipy.stats.norm.pdf", "scipy.stats.norm.pdf", "scipy.stats.norm.pdf", "numpy.isclose", "numpy.sqrt", "numpy.sqrt", "numpy.sqrt", "delfi.utils.math.MoGL2sq"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.math.MoGL2sq"], ["def", "test_1D_1K", "(", ")", ":", "\n", "    ", "m1", "=", "0.0", "\n", "m2", "=", "1.0", "\n", "S1", "=", "1.0", "\n", "S2", "=", "2.0", "\n", "\n", "# first MoG", "\n", "q1", "=", "MoG", "(", "a", "=", "[", "1.0", "]", ",", "ms", "=", "[", "[", "m1", "]", "]", ",", "Ss", "=", "[", "[", "[", "S1", "]", "]", "]", ")", "\n", "\n", "# second MoG", "\n", "q2", "=", "MoG", "(", "a", "=", "[", "1.0", "]", ",", "ms", "=", "[", "[", "m2", "]", "]", ",", "Ss", "=", "[", "[", "[", "S2", "]", "]", "]", ")", "\n", "\n", "A", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "m1", ",", "m1", ",", "np", ".", "sqrt", "(", "S1", "+", "S1", ")", ")", "\n", "B", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "m2", ",", "m2", ",", "np", ".", "sqrt", "(", "S2", "+", "S2", ")", ")", "\n", "C", "=", "scipy", ".", "stats", ".", "norm", ".", "pdf", "(", "m1", ",", "m2", ",", "np", ".", "sqrt", "(", "S1", "+", "S2", ")", ")", "\n", "assert", "np", ".", "isclose", "(", "MoGL2sq", "(", "q1", ",", "q2", ")", ",", "A", "+", "B", "-", "2", "*", "C", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_MoGL2.test_2D_2K": [[25, 42], ["numpy.array", "numpy.array", "numpy.array", "numpy.array", "delfi.distribution.MoG", "numpy.array", "numpy.array", "numpy.array", "numpy.array", "delfi.distribution.MoG", "numpy.isclose", "delfi.utils.math.MoGL2sq", "delfi.utils.math.MoGL2sq"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.utils.math.MoGL2sq", "home.repos.pwc.inspect_result.mackelab_delfi.utils.math.MoGL2sq"], ["", "def", "test_2D_2K", "(", ")", ":", "\n", "# first MoG", "\n", "    ", "mu1", "=", "np", ".", "array", "(", "[", "0.", ",", "0.", "]", ")", "\n", "mu2", "=", "np", ".", "array", "(", "[", "0.25", ",", "0.5", "]", ")", "\n", "S1", "=", "np", ".", "array", "(", "[", "[", "1.", ",", "0.", "]", ",", "[", "0.", ",", "1.", "]", "]", ")", "\n", "S2", "=", "np", ".", "array", "(", "[", "[", ".5", ",", ".1", "]", ",", "[", ".1", ",", ".5", "]", "]", ")", "\n", "q12", "=", "MoG", "(", "a", "=", "[", ".5", ",", ".5", "]", ",", "ms", "=", "[", "mu1", ",", "mu2", "]", ",", "Ss", "=", "[", "S1", ",", "S2", "]", ")", "\n", "\n", "# second MoG", "\n", "mu3", "=", "np", ".", "array", "(", "[", "-", "0.1", ",", "0.25", "]", ")", "\n", "mu4", "=", "np", ".", "array", "(", "[", "0.3", ",", "0.4", "]", ")", "\n", "S3", "=", "np", ".", "array", "(", "[", "[", "1.1", ",", "0.", "]", ",", "[", "0.", ",", "0.9", "]", "]", ")", "\n", "S4", "=", "np", ".", "array", "(", "[", "[", ".45", ",", ".1", "]", ",", "[", ".1", ",", ".55", "]", "]", ")", "\n", "q34", "=", "MoG", "(", "a", "=", "[", ".45", ",", ".55", "]", ",", "ms", "=", "[", "mu3", ",", "mu4", "]", ",", "Ss", "=", "[", "S3", ",", "S4", "]", ")", "\n", "\n", "assert", "MoGL2sq", "(", "q12", ",", "q34", ")", ">", "0", "\n", "assert", "np", ".", "isclose", "(", "MoGL2sq", "(", "q12", ",", "q12", ")", ",", "0", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_summarystats.test_mean_1_sample_1_feature": [[5, 16], ["delfi.Mean", "dss.Mean.calc", "numpy.asarray().reshape", "numpy.array_equal", "len", "numpy.array", "numpy.array", "numpy.asarray", "numpy.mean"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.calc", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.GaussianMixture.MoG.mean"], ["def", "test_mean_1_sample_1_feature", "(", ")", ":", "\n", "    ", "obs", "=", "[", "{", "'data'", ":", "np", ".", "array", "(", "[", "-", "1.", ",", "1.", "]", ")", "}", ",", "\n", "{", "'data'", ":", "np", ".", "array", "(", "[", "1.", ",", "2.", "]", ")", "}", "]", "\n", "\n", "s", "=", "dss", ".", "Mean", "(", ")", "\n", "result", "=", "s", ".", "calc", "(", "obs", ")", "\n", "\n", "expected", "=", "np", ".", "asarray", "(", "[", "np", ".", "mean", "(", "o", "[", "'data'", "]", ")", "\n", "for", "o", "in", "obs", "]", ")", ".", "reshape", "(", "len", "(", "obs", ")", ",", "1", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "result", ",", "expected", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_summarystats.test_identity_1_sample_1_feature": [[18, 28], ["delfi.Identity", "dss.Identity.calc", "numpy.asarray", "numpy.array_equal", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.MaskedSummaryStats.MaskedSummaryStats.calc"], ["", "def", "test_identity_1_sample_1_feature", "(", ")", ":", "\n", "    ", "obs", "=", "[", "{", "'data'", ":", "np", ".", "array", "(", "[", "-", "1.", ",", "1.", "]", ")", "}", ",", "\n", "{", "'data'", ":", "np", ".", "array", "(", "[", "1.", ",", "2.", "]", ")", "}", "]", "\n", "\n", "s", "=", "dss", ".", "Identity", "(", ")", "\n", "result", "=", "s", ".", "calc", "(", "obs", ")", "\n", "\n", "expected", "=", "np", ".", "asarray", "(", "[", "o", "[", "'data'", "]", "for", "o", "in", "obs", "]", ")", "\n", "\n", "assert", "np", ".", "array_equal", "(", "result", ",", "expected", ")", "\n", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_simulator.test_distractors": [[6, 15], ["delfi.simulator.MoGDistractors", "numpy.random.rand", "delfi.simulator.MoGDistractors.gen", "isinstance", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["def", "test_distractors", "(", ")", ":", "\n", "    ", "dim", "=", "2", "\n", "s", "=", "MoGDistractors", "(", "dim", "=", "dim", ")", "\n", "n_samples", "=", "10", "\n", "thetas", "=", "np", ".", "random", ".", "rand", "(", "n_samples", ",", "dim", ")", "\n", "sample_list", "=", "s", ".", "gen", "(", "thetas", ")", "\n", "assert", "len", "(", "sample_list", ")", "==", "n_samples", "\n", "assert", "isinstance", "(", "\n", "sample_list", "[", "0", "]", "[", "0", "]", ",", "dict", ")", ",", "'the entries should be dictionaries'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_simulator.test_twomoons": [[17, 27], ["delfi.simulator.TwoMoons", "numpy.random.rand", "delfi.simulator.TwoMoons.gen", "isinstance", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "test_twomoons", "(", ")", ":", "\n", "    ", "s", "=", "TwoMoons", "(", ")", "\n", "\n", "n_samples", "=", "10", "\n", "thetas", "=", "np", ".", "random", ".", "rand", "(", "n_samples", ",", "2", ")", "\n", "sample_list", "=", "s", ".", "gen", "(", "thetas", ")", "\n", "\n", "assert", "len", "(", "sample_list", ")", "==", "n_samples", "\n", "assert", "isinstance", "(", "\n", "sample_list", "[", "0", "]", "[", "0", "]", ",", "dict", ")", ",", "'the entries should be dictionaries'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_simulator.test_gauss_1d_simulator_output": [[29, 43], ["delfi.simulator.Gauss", "numpy.tile", "delfi.simulator.Gauss.gen", "isinstance", "numpy.array", "len"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "test_gauss_1d_simulator_output", "(", ")", ":", "\n", "    ", "\"\"\"Test the output of the simulator using the example of a 1D Gaussian\n    \"\"\"", "\n", "dim", "=", "1", "\n", "s", "=", "Gauss", "(", "dim", "=", "dim", ")", "\n", "\n", "n_samples", "=", "10", "\n", "thetas", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "[", "0.", "]", ")", ",", "(", "n_samples", ",", "1", ")", ")", "\n", "sample_list", "=", "s", ".", "gen", "(", "thetas", ")", "\n", "\n", "assert", "len", "(", "\n", "sample_list", ")", "==", "n_samples", ",", "'the list should have as many entries as there are samples'", "\n", "assert", "isinstance", "(", "\n", "sample_list", "[", "0", "]", "[", "0", "]", ",", "dict", ")", ",", "'the entries should be dictionaries'", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_simulator.test_gauss_2d_data_dimension": [[45, 58], ["delfi.simulator.Gauss", "numpy.tile", "delfi.simulator.Gauss.gen", "numpy.array"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "test_gauss_2d_data_dimension", "(", ")", ":", "\n", "    ", "\"\"\"Test the data dimensionality output of the Gauss Simulator using a 2D Gaussian\n    \"\"\"", "\n", "dim", "=", "2", "\n", "s", "=", "Gauss", "(", "dim", "=", "dim", ")", "\n", "\n", "n_samples", "=", "10", "\n", "thetas", "=", "np", ".", "tile", "(", "np", ".", "array", "(", "[", "0.", ",", "1.", "]", ")", ",", "(", "n_samples", ",", "1", ")", ")", "\n", "sample_list", "=", "s", ".", "gen", "(", "thetas", ")", "\n", "\n", "assert", "sample_list", "[", "0", "]", "[", "0", "]", "[", "'data'", "]", ".", "shape", "==", "(", "dim", ",", ")", ",", "'the dimensionality of the data is wrong. '", "'should be {} is {}'", ".", "format", "(", "(", "dim", ",", "1", ")", ",", "sample_list", "[", "0", "]", "[", "0", "]", "[", "'data'", "]", ".", "shape", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_simulator.test_TransformedSimulator": [[60, 77], ["delfi.simulator.Gauss", "numpy.random.rand", "bijection", "delfi.simulator.Gauss.reseed", "numpy.array", "delfi.simulator.TransformedSimulator", "delfi.simulator.TransformedSimulator.reseed", "numpy.array", "numpy.allclose", "numpy.log", "numpy.exp", "delfi.simulator.Gauss.gen", "delfi.simulator.TransformedSimulator.gen"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.generator.MPGenerator.MPGenerator.log", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "test_TransformedSimulator", "(", "seed", "=", "5", ",", "nsamples", "=", "1000", ",", "dim", "=", "2", ")", ":", "\n", "    ", "s", "=", "Gauss", "(", "dim", "=", "dim", ")", "\n", "\n", "bijection", "=", "lambda", "x", ":", "np", ".", "log", "(", "x", ")", "\n", "inverse_bijection", "=", "lambda", "x", ":", "np", ".", "exp", "(", "x", ")", "\n", "\n", "theta", "=", "np", ".", "random", ".", "rand", "(", "nsamples", ",", "dim", ")", "\n", "theta_transformed", "=", "bijection", "(", "theta", ")", "\n", "\n", "s", ".", "reseed", "(", "seed", ")", "\n", "x", "=", "np", ".", "array", "(", "[", "z", "[", "0", "]", "[", "'data'", "]", "for", "z", "in", "s", ".", "gen", "(", "theta", ")", "]", ")", "\n", "\n", "s_transformed", "=", "TransformedSimulator", "(", "s", ",", "inverse_bijection", ")", "\n", "s_transformed", ".", "reseed", "(", "seed", ")", "\n", "x_from_transformed_theta", "=", "np", ".", "array", "(", "[", "z", "[", "0", "]", "[", "'data'", "]", "for", "z", "in", "s_transformed", ".", "gen", "(", "theta_transformed", ")", "]", ")", "\n", "\n", "assert", "np", ".", "allclose", "(", "x", ",", "x_from_transformed_theta", ",", "atol", "=", "1e-8", ")", ",", "\"data don't match after parameter transformation\"", "", "", ""]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_neuralnet.test_lprobs": [[10, 24], ["delfi.neuralnet.NeuralNet.NeuralNet", "theano.function", "theano.function.", "delfi.neuralnet.NeuralNet.NeuralNet.get_mog", "numpy.array", "numpy.array", "numpy.array"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog"], ["def", "test_lprobs", "(", ")", ":", "\n", "    ", "n_components", "=", "2", "\n", "seed", "=", "42", "\n", "svi", "=", "False", "\n", "\n", "nn", "=", "NeuralNet", "(", "n_components", "=", "n_components", ",", "n_hiddens", "=", "[", "10", "]", ",", "n_inputs", "=", "1", ",", "\n", "n_outputs", "=", "1", ",", "seed", "=", "seed", ",", "svi", "=", "svi", ")", "\n", "\n", "eval_lprobs", "=", "theano", ".", "function", "(", "[", "nn", ".", "params", ",", "nn", ".", "stats", "]", ",", "nn", ".", "lprobs", ")", "\n", "\n", "res", "=", "eval_lprobs", "(", "np", ".", "array", "(", "[", "[", "1.", "]", ",", "[", "2.", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", "np", ".", "array", "(", "[", "[", "1.", "]", ",", "[", "2.", "]", "]", ",", "dtype", "=", "dtype", ")", ")", "\n", "\n", "mog", "=", "nn", ".", "get_mog", "(", "np", ".", "array", "(", "[", "[", "1.", "]", "]", ",", "dtype", "=", "dtype", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_neuralnet.test_diag_precision_bounds": [[26, 41], ["numpy.array", "delfi.neuralnet.NeuralNet.NeuralNet", "delfi.neuralnet.NeuralNet.NeuralNet", "delfi.neuralnet.NeuralNet.NeuralNet.get_mog", "numpy.array", "numpy.allclose", "numpy.ones", "numpy.maximum", "numpy.diag"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog"], ["", "def", "test_diag_precision_bounds", "(", ")", ":", "\n", "    ", "n_components", "=", "2", "\n", "seed", "=", "42", "\n", "svi", "=", "False", "\n", "min_precisions", "=", "np", ".", "array", "(", "[", "0.1", ",", "2.0", ",", "15.0", "]", ")", "\n", "\n", "nn", "=", "NeuralNet", "(", "n_components", "=", "n_components", ",", "n_hiddens", "=", "[", "10", "]", ",", "n_inputs", "=", "3", ",", "\n", "n_outputs", "=", "3", ",", "seed", "=", "seed", ",", "svi", "=", "svi", ",", "min_precisions", "=", "None", ")", "\n", "\n", "nn_bounded", "=", "NeuralNet", "(", "n_components", "=", "n_components", ",", "n_hiddens", "=", "[", "10", "]", ",", "\n", "n_inputs", "=", "3", ",", "n_outputs", "=", "3", ",", "seed", "=", "seed", ",", "svi", "=", "svi", ",", "\n", "min_precisions", "=", "min_precisions", ")", "\n", "mog_bounded", "=", "nn_bounded", ".", "get_mog", "(", "np", ".", "array", "(", "np", ".", "ones", "(", "(", "1", ",", "3", ")", ")", ",", "dtype", "=", "dtype", ")", ")", "\n", "for", "x", "in", "mog_bounded", ".", "xs", ":", "\n", "        ", "assert", "np", ".", "allclose", "(", "0.0", ",", "np", ".", "maximum", "(", "0.0", ",", "min_precisions", "-", "np", ".", "diag", "(", "x", ".", "P", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_neuralnet.test_conv": [[43, 68], ["delfi.neuralnet.NeuralNet.NeuralNet", "theano.function", "theano.function.", "delfi.neuralnet.NeuralNet.NeuralNet.get_mog", "lasagne.layers.get_output_shape", "numpy.array", "numpy.random.normal().astype", "numpy.random.normal().astype", "range", "numpy.random.normal", "numpy.random.normal", "str"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.neuralnet.NeuralNet.NeuralNet.get_mog"], ["", "", "def", "test_conv", "(", ")", ":", "\n", "    ", "\"\"\"Test multichannel convolution with bypass\"\"\"", "\n", "n_components", "=", "1", "\n", "seed", "=", "42", "\n", "L", "=", "20", "\n", "channels", "=", "3", "\n", "bypass", "=", "1", "\n", "svi", "=", "False", "\n", "\n", "n_inputs", "=", "channels", "*", "L", "**", "2", "+", "bypass", "\n", "\n", "nn", "=", "NeuralNet", "(", "n_components", "=", "n_components", ",", "n_filters", "=", "[", "8", ",", "8", "]", ",", "n_hiddens", "=", "[", "10", "]", ",", "\n", "n_inputs", "=", "n_inputs", ",", "input_shape", "=", "(", "channels", ",", "L", ",", "L", ")", ",", "\n", "n_bypass", "=", "1", ",", "n_outputs", "=", "1", ",", "\n", "seed", "=", "seed", ",", "svi", "=", "svi", ")", "\n", "\n", "eval_lprobs", "=", "theano", ".", "function", "(", "[", "nn", ".", "params", ",", "nn", ".", "stats", "]", ",", "nn", ".", "lprobs", ")", "\n", "\n", "conv_sizes", "=", "[", "lasagne", ".", "layers", ".", "get_output_shape", "(", "\n", "nn", ".", "layer", "[", "'conv_'", "+", "str", "(", "i", "+", "1", ")", "]", ")", "for", "i", "in", "range", "(", "2", ")", "]", "\n", "\n", "res", "=", "eval_lprobs", "(", "np", ".", "array", "(", "[", "[", "1.", "]", ",", "[", "2.", "]", "]", ",", "dtype", "=", "dtype", ")", ",", "\n", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "2", ",", "n_inputs", ")", ")", ".", "astype", "(", "dtype", ")", ")", "\n", "\n", "mog", "=", "nn", ".", "get_mog", "(", "np", ".", "random", ".", "normal", "(", "size", "=", "(", "1", ",", "n_inputs", ")", ")", ".", "astype", "(", "dtype", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.test_rng_repeatability": [[14, 55], ["numpy.atleast_1d", "numpy.atleast_2d", "delfi.Gaussian", "test_seeding.check_repeatability_dist", "delfi.MoG", "test_seeding.check_repeatability_dist", "delfi.Gauss", "test_seeding.check_repeatability_sim", "delfi.GaussMixture", "test_seeding.check_repeatability_sim", "delfi.Default", "test_seeding.check_repeatability_gen", "dict", "delfi.Basic", "test_seeding.check_repeatability_infer", "delfi.Basic", "test_seeding.check_repeatability_infer", "delfi.SNPEB", "test_seeding.check_repeatability_infer", "numpy.zeros().reshape", "numpy.zeros().reshape", "gen.Default.gen", "copy.deepcopy", "copy.deepcopy", "copy.deepcopy", "numpy.array", "delfi.summarystats.Identity", "numpy.zeros", "numpy.zeros"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_dist", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_dist", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_sim", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_sim", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_gen", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_infer", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_infer", "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_infer", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["def", "test_rng_repeatability", "(", ")", ":", "\n", "    ", "mu", "=", "np", ".", "atleast_1d", "(", "[", "0.0", "]", ")", "\n", "S", "=", "np", ".", "atleast_2d", "(", "1.0", ")", "\n", "\n", "# distributions", "\n", "pG", "=", "dd", ".", "Gaussian", "(", "m", "=", "mu", ",", "S", "=", "S", ")", "\n", "check_repeatability_dist", "(", "pG", ")", "\n", "\n", "pMoG", "=", "dd", ".", "MoG", "(", "a", "=", "np", ".", "array", "(", "[", "0.25", ",", "0.75", "]", ")", ",", "ms", "=", "[", "mu", ",", "mu", "]", ",", "Ss", "=", "[", "S", ",", "S", "]", ")", "\n", "check_repeatability_dist", "(", "pMoG", ")", "\n", "\n", "# simulators", "\n", "mG", "=", "sims", ".", "Gauss", "(", ")", "\n", "check_repeatability_sim", "(", "mG", ",", "np", ".", "zeros", "(", "mG", ".", "dim_param", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "mMoG", "=", "sims", ".", "GaussMixture", "(", ")", "\n", "check_repeatability_sim", "(", "mMoG", ",", "np", ".", "zeros", "(", "mMoG", ".", "dim_param", ")", ".", "reshape", "(", "-", "1", ",", "1", ")", ")", "\n", "\n", "# generators", "\n", "g", "=", "gen", ".", "Default", "(", "model", "=", "mMoG", ",", "prior", "=", "pMoG", ",", "summary", "=", "Identity", "(", ")", ")", "\n", "check_repeatability_gen", "(", "g", ")", "\n", "\n", "# inference methods", "\n", "# we're going to create each one with a different deepcopy of g to make", "\n", "# sure thre are are no side effects e.g. changes to the proposal", "\n", "x0", "=", "g", ".", "gen", "(", "1", ",", "verbose", "=", "False", ")", "[", "1", "]", "\n", "inf_opts", "=", "dict", "(", "obs", "=", "x0", ",", "n_components", "=", "2", ",", "n_hiddens", "=", "[", "5", ",", "5", "]", ",", "verbose", "=", "False", ",", "\n", "pilot_samples", "=", "0", ")", "\n", "\n", "yB_nosvi", "=", "inf", ".", "Basic", "(", "deepcopy", "(", "g", ")", ",", "svi", "=", "False", ",", "**", "inf_opts", ")", "\n", "check_repeatability_infer", "(", "yB_nosvi", ")", "\n", "\n", "yB_svi", "=", "inf", ".", "Basic", "(", "deepcopy", "(", "g", ")", ",", "svi", "=", "True", ",", "**", "inf_opts", ")", "\n", "check_repeatability_infer", "(", "yB_svi", ")", "\n", "\n", "# skip CDELFI for now since it might crash if we don't use the prior", "\n", "#yC = inf.CDELFI(deepcopy(g), **inf_opts)", "\n", "#check_repeatability_infer(yC)", "\n", "\n", "yS", "=", "inf", ".", "SNPEB", "(", "deepcopy", "(", "g", ")", ",", "prior_mixin", "=", "0.5", ",", "**", "inf_opts", ")", "\n", "check_repeatability_infer", "(", "yS", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_infer": [[57, 89], ["y.reset", "y.run", "y.predict().gen", "y.reset", "y.run", "y.predict().gen", "range", "numpy.all", "type", "len", "len", "len", "numpy.all", "numpy.all", "numpy.all", "zip", "y.predict", "y.predict", "numpy.all", "numpy.all"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.reset", "home.repos.pwc.inspect_result.mackelab_delfi.inference.SNPEB.SNPEB.run", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict", "home.repos.pwc.inspect_result.mackelab_delfi.inference.BaseInference.BaseInference.predict"], ["", "def", "check_repeatability_infer", "(", "y", ",", "seed", "=", "42", ",", "n_train", "=", "10", ")", ":", "\n", "    ", "\"\"\"\n    Run an inference algorithm twice, and make sure all results are the same.\n    \"\"\"", "\n", "y", ".", "reset", "(", "seed", "=", "seed", ")", "\n", "log1", ",", "train_data1", ",", "posterior1", "=", "y", ".", "run", "(", "n_train", "=", "n_train", ")", "\n", "a1", "=", "y", ".", "predict", "(", "y", ".", "obs", ")", ".", "gen", "(", "5", ")", "\n", "\n", "y", ".", "reset", "(", "seed", "=", "seed", ")", "\n", "log2", ",", "train_data2", ",", "posterior2", "=", "y", ".", "run", "(", "n_train", "=", "n_train", ")", "\n", "a2", "=", "y", ".", "predict", "(", "y", ".", "obs", ")", ".", "gen", "(", "5", ")", "\n", "\n", "\"\"\"For a single-round algorithm train_data will be returned as a tuple.\n    For multiround methods, it's a list of tuples. log and posterior are\n    similar.\"\"\"", "\n", "if", "type", "(", "train_data1", ")", "is", "not", "list", ":", "\n", "        ", "train_data1", ",", "train_data2", "=", "[", "train_data1", "]", ",", "[", "train_data2", "]", "\n", "log1", ",", "log2", "=", "[", "log1", "]", ",", "[", "log2", "]", "\n", "posterior1", ",", "posterior2", "=", "[", "posterior1", "]", ",", "[", "posterior2", "]", "\n", "\n", "", "assert", "len", "(", "train_data1", ")", "==", "len", "(", "train_data2", ")", ",", "\"Different number of rounds\"", "\n", "for", "r", "in", "range", "(", "len", "(", "train_data1", ")", ")", ":", "# for each round", "\n", "        ", "assert", "np", ".", "all", "(", "train_data1", "[", "r", "]", "[", "0", "]", "==", "train_data2", "[", "r", "]", "[", "0", "]", ")", ",", "\"different parameters\"", "\n", "assert", "np", ".", "all", "(", "train_data1", "[", "r", "]", "[", "1", "]", "==", "train_data2", "[", "r", "]", "[", "1", "]", ")", ",", "\"different sufficient statistic values\"", "\n", "assert", "np", ".", "all", "(", "posterior1", "[", "r", "]", ".", "a", "==", "posterior2", "[", "r", "]", ".", "a", ")", ",", "\"different mixture coefficients\"", "\n", "for", "x1", ",", "x2", "in", "zip", "(", "posterior1", "[", "r", "]", ".", "xs", ",", "posterior2", "[", "r", "]", ".", "xs", ")", ":", "\n", "            ", "assert", "np", ".", "all", "(", "x1", ".", "m", "==", "x2", ".", "m", ")", ",", "\"Component means do not match\"", "\n", "assert", "np", ".", "all", "(", "x1", ".", "S", "==", "x2", ".", "S", ")", ",", "\"Component covariances do not match\"", "\n", "", "", "assert", "np", ".", "all", "(", "a1", "==", "a2", ")", ",", "\"posterior samples do not match\"", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_dist": [[91, 97], ["p.reseed", "p.gen", "p.reseed", "p.gen", "numpy.all"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "check_repeatability_dist", "(", "p", ",", "n", "=", "100", ",", "seed", "=", "42", ")", ":", "\n", "    ", "p", ".", "reseed", "(", "seed", ")", "\n", "params1", "=", "p", ".", "gen", "(", "n", ")", "\n", "p", ".", "reseed", "(", "seed", ")", "\n", "params2", "=", "p", ".", "gen", "(", "n", ")", "\n", "assert", "np", ".", "all", "(", "params1", "==", "params2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_sim": [[99, 105], ["m.reseed", "m.gen", "m.reseed", "m.gen", "numpy.all"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "check_repeatability_sim", "(", "m", ",", "params", ",", "n", "=", "100", ",", "seed", "=", "42", ")", ":", "\n", "    ", "m", ".", "reseed", "(", "seed", ")", "\n", "x1", "=", "m", ".", "gen", "(", "params", ",", "n_reps", "=", "n", ")", "\n", "m", ".", "reseed", "(", "seed", ")", "\n", "x2", "=", "m", ".", "gen", "(", "params", ",", "n_reps", "=", "n", ")", "\n", "assert", "np", ".", "all", "(", "x1", "==", "x2", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.mackelab_delfi.unit.test_seeding.check_repeatability_gen": [[107, 115], ["g.reseed", "g.gen", "g.reseed", "g.gen", "numpy.all", "numpy.all"], "function", ["home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen", "home.repos.pwc.inspect_result.mackelab_delfi.summarystats.BaseSummaryStats.BaseSummaryStats.reseed", "home.repos.pwc.inspect_result.mackelab_delfi.mixture.StudentsTMixture.MoT.gen"], ["", "def", "check_repeatability_gen", "(", "g", ",", "n", "=", "100", ",", "seed", "=", "42", ")", ":", "\n", "# use prior_mixin to test the RNG of the generator too.", "\n", "    ", "g", ".", "reseed", "(", "seed", ")", "\n", "params1", ",", "stats1", "=", "g", ".", "gen", "(", "n", ",", "prior_mixin", "=", "0.5", ",", "verbose", "=", "False", ")", "\n", "g", ".", "reseed", "(", "seed", ")", "\n", "params2", ",", "stats2", "=", "g", ".", "gen", "(", "n", ",", "prior_mixin", "=", "0.5", ",", "verbose", "=", "False", ")", "\n", "assert", "np", ".", "all", "(", "params1", "==", "params2", ")", ",", "\"parameters do not match\"", "\n", "assert", "np", ".", "all", "(", "stats1", "==", "stats2", ")", ",", "\"stats do not match\"", "\n", "", ""]]}