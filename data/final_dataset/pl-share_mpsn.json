{"home.repos.pwc.inspect_result.pl-share_mpsn.None.eval.eval": [[31, 95], ["train_or.Head_Detector_Trainer", "enumerate", "print", "img2.cuda.cuda", "src.scalar", "range", "src.tonumpy", "img.cuda().float", "bbox_.cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "head_detector.predict", "src.tonumpy", "src.bbox_tools.bbox_iou", "src.bbox_tools.bbox_iou.max", "len", "numpy.zeros", "numpy.append", "numpy.append", "sklearn.metrics.average_precision_score", "str", "numpy.where", "len", "numpy.zeros", "numpy.ones", "img.cuda", "max", "max"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.scalar", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.predict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bbox_iou"], ["def", "eval", "(", "dataloader", ",", "head_detector", ")", ":", "\n", "    ", "trainer", "=", "Head_Detector_Trainer", "(", "head_detector", ")", "\n", "\"\"\"\n    Given the dataloader of the test split compute the\n    average corLoc of the dataset using the head detector \n    model given as the argument to the function. \n    \"\"\"", "\n", "test_img_num", "=", "0", "\n", "test_corrLoc", "=", "0.0", "\n", "AP", "=", "0.0", "\n", "\n", "for", "ii", ",", "(", "img_path", ",", "img", ",", "img2", ",", "bbox_", ",", "scale", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "\n", "# print(scale)", "\n", "        ", "img", ",", "bbox", "=", "img", ".", "cuda", "(", ")", ".", "float", "(", ")", ",", "bbox_", ".", "cuda", "(", ")", "\n", "img2", "=", "img2", ".", "cuda", "(", ")", "\n", "scale", "=", "at", ".", "scalar", "(", "scale", ")", "\n", "# img, bbox = img.cuda().float(), bbox_.cuda()", "\n", "img", ",", "img2", ",", "bbox", "=", "Variable", "(", "img", ")", ",", "Variable", "(", "img2", ")", ",", "Variable", "(", "bbox", ")", "\n", "\n", "for", "gg", "in", "range", "(", "1", ")", ":", "\n", "            ", "pred_bboxes_", ",", "scores", "=", "head_detector", ".", "predict", "(", "img", ",", "img2", ",", "scale", ",", "mode", "=", "'evaluate'", ",", "\n", "thresh", "=", "0.000", ")", "# 0\u30020005", "\n", "# s2 = datetime.datetime.now()", "\n", "# print(s1,s2)", "\n", "# print((s1 - s2).seconds)", "\n", "", "gt_bboxs", "=", "at", ".", "tonumpy", "(", "bbox_", ")", "[", "0", "]", "\n", "pred_bboxes_", "=", "at", ".", "tonumpy", "(", "pred_bboxes_", ")", "\n", "\n", "\n", "\n", "\n", "\n", "if", "pred_bboxes_", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "test_img_num", "+=", "1", "\n", "continue", "\n", "", "else", ":", "\n", "            ", "ious", "=", "bbox_iou", "(", "pred_bboxes_", ",", "gt_bboxs", ")", "\n", "max_ious", "=", "ious", ".", "max", "(", "axis", "=", "1", ")", "\n", "corr_preds", "=", "np", ".", "where", "(", "max_ious", ">=", "0.5", ")", "[", "0", "]", "\n", "num_boxs", "=", "gt_bboxs", ".", "shape", "[", "0", "]", "\n", "num_corr_preds", "=", "len", "(", "corr_preds", ")", "\n", "\n", "gt_labels", "=", "np", ".", "zeros", "(", "len", "(", "scores", ")", ")", "\n", "for", "index", "in", "corr_preds", ":", "\n", "                ", "gt_labels", "[", "index", "]", "=", "1", "\n", "\n", "\n", "", "scores", "=", "np", ".", "append", "(", "scores", ",", "np", ".", "zeros", "(", "max", "(", "num_boxs", "-", "num_corr_preds", ",", "0", ")", ")", ")", "# .astype(np.float)", "\n", "gt_labels", "=", "np", ".", "append", "(", "gt_labels", ",", "np", ".", "ones", "(", "max", "(", "num_boxs", "-", "num_corr_preds", ",", "0", ")", ")", ")", "# .astype(np.bool_)", "\n", "ap", "=", "average_precision_score", "(", "gt_labels", ",", "scores", ")", "\n", "# curve=precision_recall_curve(gt_labels,scores)", "\n", "# recall=recall_score(gt_labels,scores)", "\n", "AP", "=", "AP", "+", "ap", "\n", "# print(scores)", "\n", "\n", "\n", "test_corrLoc", "+=", "num_corr_preds", "/", "num_boxs", "\n", "test_img_num", "+=", "1", "\n", "\n", "", "img_path_pre", "=", "img_path", "\n", "", "print", "(", "\"AP:\"", "+", "str", "(", "AP", "/", "test_img_num", ")", ")", "\n", "\n", "return", "AP", "/", "test_img_num", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.eval.main": [[97, 152], ["print", "print", "print", "data.dataset.Dataset", "data.dataset.Dataset", "print", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "src.head_backbone.mpsn", "print", "train_or.Head_Detector_Trainer().cuda", "Head_Detector_Trainer().cuda.load", "eval.eval", "print", "src.check_loaded_data", "src.check_loaded_data", "src.check_loaded_data", "len", "len", "len", "train_or.Head_Detector_Trainer", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "random.randint", "random.randint", "random.randint", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "len", "len", "len"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train.eval", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list"], ["", "def", "main", "(", "args", ")", ":", "\n", "# Get the dataset", "\n", "    ", "for", "phase", "in", "phases", ":", "\n", "        ", "if", "phase", "==", "'train'", ":", "\n", "            ", "if", "dataset_name", "==", "'brainwash'", ":", "\n", "                ", "train_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "'brainwash_train.idl'", ")", "\n", "train_data_list", "=", "utils", ".", "get_phase_data_list", "(", "train_data_list_path", ",", "dataset_name", ")", "\n", "", "if", "dataset_name", "==", "'RGBdata'", ":", "\n", "                ", "train_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "'RGBdata_train.idl'", ")", "\n", "train_data_list", "=", "utils", ".", "get_phase_data_list", "(", "train_data_list_path", ",", "dataset_name", ")", "\n", "", "", "elif", "phase", "==", "'val'", ":", "\n", "\n", "            ", "if", "dataset_name", "==", "'brainwash'", ":", "\n", "                ", "val_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "'brainwash_val.idl'", ")", "\n", "val_data_list", "=", "utils", ".", "get_phase_data_list", "(", "val_data_list_path", ",", "dataset_name", ")", "\n", "", "if", "dataset_name", "==", "'RGBdata'", ":", "\n", "                ", "val_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "'RGBdata_val.idl'", ")", "\n", "val_data_list", "=", "utils", ".", "get_phase_data_list", "(", "val_data_list_path", ",", "dataset_name", ")", "\n", "", "", "elif", "phase", "==", "'test'", ":", "\n", "            ", "if", "dataset_name", "==", "'RGBdata'", ":", "\n", "                ", "test_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "'RGBdata_test.idl'", ")", "\n", "test_data_list", "=", "utils", ".", "get_phase_data_list", "(", "test_data_list_path", ",", "dataset_name", ")", "\n", "", "if", "dataset_name", "==", "'brainwash'", ":", "\n", "                ", "test_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "'brainwash_test.idl'", ")", "\n", "test_data_list", "=", "utils", ".", "get_phase_data_list", "(", "test_data_list_path", ",", "dataset_name", ")", "\n", "\n", "", "", "", "print", "(", "\"Number of images for training: %s\"", "%", "(", "len", "(", "train_data_list", ")", ")", ")", "\n", "print", "(", "\"Number of images for val: %s\"", "%", "(", "len", "(", "val_data_list", ")", ")", ")", "\n", "print", "(", "\"Number of images for test: %s\"", "%", "(", "len", "(", "test_data_list", ")", ")", ")", "\n", "\n", "if", "data_check_flag", ":", "\n", "        ", "utils", ".", "check_loaded_data", "(", "train_data_list", "[", "random", ".", "randint", "(", "1", ",", "len", "(", "train_data_list", ")", ")", "]", ")", "\n", "utils", ".", "check_loaded_data", "(", "val_data_list", "[", "random", ".", "randint", "(", "1", ",", "len", "(", "val_data_list", ")", ")", "]", ")", "\n", "utils", ".", "check_loaded_data", "(", "test_data_list", "[", "random", ".", "randint", "(", "1", ",", "len", "(", "test_data_list", ")", ")", "]", ")", "\n", "\n", "# Load the train dataset", "\n", "#train_dataset = Dataset(train_data_list)", "\n", "", "val_dataset", "=", "Dataset", "(", "val_data_list", ")", "\n", "test_dataset", "=", "Dataset", "(", "test_data_list", ")", "\n", "print", "(", "\"Load data.\"", ")", "\n", "\n", "#train_dataloader = data_.DataLoader(train_dataset, batch_size=1, shuffle=True, num_workers=1)", "\n", "val_dataloader", "=", "data_", ".", "DataLoader", "(", "val_dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "1", ")", "\n", "test_dataloader", "=", "data_", ".", "DataLoader", "(", "test_dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "1", ")", "\n", "# Initialize the head detector.", "\n", "#head_detector_mpsn = Head_Detector_VGG16(ratios=[1], anchor_scales=[8, 16])", "\n", "head_detector_mpsn", "=", "mpsn", "(", "ratios", "=", "[", "1", "]", ",", "anchor_scales", "=", "[", "2", ",", "4", "]", ")", "\n", "print", "(", "\"model construct completed\"", ")", "\n", "\n", "\n", "trainer", "=", "Head_Detector_Trainer", "(", "head_detector_mpsn", ")", ".", "cuda", "(", ")", "\n", "trainer", ".", "load", "(", "args", ".", "model_path", ")", "\n", "#avg_test_CorrLoc = eval(val_dataloader, head_detector_mpsn)", "\n", "test_Corr", "=", "eval", "(", "test_dataloader", ",", "head_detector_mpsn", ")", "\n", "print", "(", "\"  test average corrLoc accuracy:\\t\\t{:.3f}\"", ".", "format", "(", "test_Corr", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.__init__": [[23, 32], ["torch.nn.Module.__init__", "src.creator_tool.AnchorTargetCreator", "trainer.Head_Detector_Trainer.head_detector.get_optimizer", "torchnet.meter.ConfusionMeter", "torchnet.meter.AverageValueMeter"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.get_optimizer"], ["    ", "def", "__init__", "(", "self", ",", "head_detector", ")", ":", "\n", "        ", "super", "(", "Head_Detector_Trainer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "head_detector", "=", "head_detector", "\n", "self", ".", "rpn_sigma", "=", "opt", ".", "rpn_sigma", "\n", "self", ".", "anchor_target_creator", "=", "AnchorTargetCreator", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "head_detector", ".", "get_optimizer", "(", ")", "\n", "#self.vis = Visualizer(env=opt.env)", "\n", "self", ".", "rpn_cm", "=", "ConfusionMeter", "(", "2", ")", "\n", "self", ".", "meters", "=", "{", "k", ":", "AverageValueMeter", "(", ")", "for", "k", "in", "LossTuple", ".", "_fields", "}", "# average loss", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.forward": [[33, 70], ["bboxs.size", "imgs.size", "trainer.Head_Detector_Trainer.head_detector.vgg", "trainer.Head_Detector_Trainer.head_detector.left_add", "trainer.Head_Detector_Trainer.head_detector.addnet", "trainer.Head_Detector_Trainer.head_detector.rpn", "trainer.Head_Detector_Trainer.anchor_target_creator", "src.tovariable().long", "src.tovariable", "trainer.head_detector_loss", "torch.nn.functional.cross_entropy", "trainer.Head_Detector_Trainer.rpn_cm.add", "ValueError", "torch.mul", "src.tonumpy", "src.tovariable().long.cuda", "src.tonumpy", "src.totensor", "_gt_rpn_label.data.long", "LossTuple", "torch.sigmoid", "src.tovariable", "sum", "src.tonumpy"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.head_detector_loss", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.totensor", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy"], ["", "def", "forward", "(", "self", ",", "imgs", ",", "imgs2", ",", "bboxs", ",", "scale", ")", ":", "\n", "        ", "n", ",", "_", ",", "_", "=", "bboxs", ".", "size", "(", ")", "\n", "if", "n", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Currently only batch size 1 is supported.'", ")", "\n", "", "_", ",", "_", ",", "H", ",", "W", "=", "imgs", ".", "size", "(", ")", "\n", "img_size", "=", "(", "H", ",", "W", ")", "\n", "x", "=", "imgs", "\n", "x2", "=", "imgs2", "\n", "h1", "=", "self", ".", "head_detector", ".", "vgg", "(", "x", ")", "\n", "h2", "=", "self", ".", "head_detector", ".", "left_add", "(", "x2", ")", "\n", "h3", "=", "self", ".", "head_detector", ".", "addnet", "(", "h2", ")", "\n", "# hf2=h1+h3", "\n", "hf2", "=", "t", ".", "mul", "(", "h1", ",", "t", ".", "sigmoid", "(", "h3", ")", ")", "+", "h3", "\n", "features", "=", "hf2", "\n", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "=", "self", ".", "head_detector", ".", "rpn", "(", "features", ",", "img_size", ",", "scale", ")", "\n", "bbox", "=", "bboxs", "[", "0", "]", "\n", "rpn_score", "=", "rpn_scores", "[", "0", "]", "\n", "rpn_loc", "=", "rpn_locs", "[", "0", "]", "\n", "\n", "# ------------------ RPN losses -------------------#", "\n", "gt_rpn_loc", ",", "gt_rpn_label", "=", "self", ".", "anchor_target_creator", "(", "at", ".", "tonumpy", "(", "bbox", ")", ",", "anchor", ",", "img_size", ")", "\n", "gt_rpn_label", "=", "at", ".", "tovariable", "(", "gt_rpn_label", ")", ".", "long", "(", ")", "\n", "gt_rpn_loc", "=", "at", ".", "tovariable", "(", "gt_rpn_loc", ")", "\n", "rpn_loc_loss", "=", "head_detector_loss", "(", "\n", "rpn_loc", ",", "\n", "gt_rpn_loc", ",", "\n", "gt_rpn_label", ".", "data", ",", "\n", "self", ".", "rpn_sigma", ")", "\n", "\n", "rpn_cls_loss", "=", "F", ".", "cross_entropy", "(", "rpn_score", ",", "gt_rpn_label", ".", "cuda", "(", ")", ",", "ignore_index", "=", "-", "1", ")", "\n", "_gt_rpn_label", "=", "gt_rpn_label", "[", "gt_rpn_label", ">", "-", "1", "]", "\n", "_rpn_score", "=", "at", ".", "tonumpy", "(", "rpn_score", ")", "[", "at", ".", "tonumpy", "(", "gt_rpn_label", ")", ">", "-", "1", "]", "\n", "self", ".", "rpn_cm", ".", "add", "(", "at", ".", "totensor", "(", "_rpn_score", ",", "False", ")", ",", "_gt_rpn_label", ".", "data", ".", "long", "(", ")", ")", "\n", "losses", "=", "[", "rpn_loc_loss", ",", "rpn_cls_loss", "]", "\n", "losses", "=", "losses", "+", "[", "sum", "(", "losses", ")", "]", "\n", "\n", "return", "LossTuple", "(", "*", "losses", ")", ",", "rois", ",", "rois_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.train_step": [[71, 78], ["trainer.Head_Detector_Trainer.optimizer.zero_grad", "trainer.Head_Detector_Trainer.forward", "losses.total_loss.backward", "trainer.Head_Detector_Trainer.optimizer.step", "trainer.Head_Detector_Trainer.update_meters"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.RegionProposalNetwork.forward", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.update_meters"], ["", "def", "train_step", "(", "self", ",", "imgs", ",", "imgs2", ",", "bboxes", ",", "scale", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ",", "rois", ",", "rois_scores", "=", "self", ".", "forward", "(", "imgs", ",", "imgs2", ",", "bboxes", ",", "scale", ")", "\n", "losses", ".", "total_loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "update_meters", "(", "losses", ")", "\n", "return", "losses", ",", "rois", ",", "rois_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.save": [[79, 98], ["dict", "trainer.Head_Detector_Trainer.head_detector.state_dict", "src.config.opt._state_dict", "torch.save", "trainer.Head_Detector_Trainer.optimizer.state_dict", "time.strftime", "os.path.join", "kwargs.items"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.save", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.state_dict"], ["", "def", "save", "(", "self", ",", "save_optimizer", "=", "False", ",", "save_path", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "save_dict", "=", "dict", "(", ")", "\n", "save_dict", "[", "'model'", "]", "=", "self", ".", "head_detector", ".", "state_dict", "(", ")", "\n", "save_dict", "[", "'config'", "]", "=", "opt", ".", "_state_dict", "(", ")", "\n", "save_dict", "[", "'other_info'", "]", "=", "kwargs", "\n", "#save_dict['vis_info'] = self.vis.state_dict()", "\n", "\n", "if", "save_optimizer", ":", "\n", "            ", "save_dict", "[", "'optimizer'", "]", "=", "self", ".", "optimizer", ".", "state_dict", "(", ")", "\n", "\n", "", "if", "save_path", "is", "None", ":", "\n", "            ", "timestr", "=", "time", ".", "strftime", "(", "'%m%d%H%M'", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "model_save_path", ",", "'head_detector%s'", "%", "timestr", ")", "\n", "for", "k_", ",", "v_", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "save_path", "+=", "'_%s'", "%", "v_", "\n", "\n", "", "", "t", ".", "save", "(", "save_dict", ",", "save_path", ")", "\n", "#self.vis.save([self.vis.env])", "\n", "return", "save_path", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.load": [[99, 111], ["torch.load", "trainer.Head_Detector_Trainer.head_detector.load_state_dict", "trainer.Head_Detector_Trainer.head_detector.load_state_dict", "src.config.opt._parse", "trainer.Head_Detector_Trainer.optimizer.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._parse", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict"], ["", "def", "load", "(", "self", ",", "path", ",", "load_optimizer", "=", "True", ",", "parse_opt", "=", "False", ",", ")", ":", "\n", "        ", "state_dict", "=", "t", ".", "load", "(", "path", ")", "\n", "if", "'model'", "in", "state_dict", ":", "\n", "            ", "self", ".", "head_detector", ".", "load_state_dict", "(", "state_dict", "[", "'model'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "head_detector", ".", "load_state_dict", "(", "state_dict", ")", "\n", "return", "self", "\n", "", "if", "parse_opt", ":", "\n", "            ", "opt", ".", "_parse", "(", "state_dict", "[", "'config'", "]", ")", "\n", "", "if", "'optimizer'", "in", "state_dict", "and", "load_optimizer", ":", "\n", "            ", "self", ".", "optimizer", ".", "load_state_dict", "(", "state_dict", "[", "'optimizer'", "]", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.update_meters": [[112, 116], ["trainer.Head_Detector_Trainer.meters.items", "src.scalar", "meter.add", "src.tonumpy", "losses._asdict().items", "losses._asdict"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.scalar", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy"], ["", "def", "update_meters", "(", "self", ",", "losses", ")", ":", "\n", "        ", "loss_d", "=", "{", "k", ":", "at", ".", "scalar", "(", "at", ".", "tonumpy", "(", "v", ")", ")", "for", "k", ",", "v", "in", "losses", ".", "_asdict", "(", ")", ".", "items", "(", ")", "}", "\n", "for", "key", ",", "meter", "in", "self", ".", "meters", ".", "items", "(", ")", ":", "\n", "            ", "meter", ".", "add", "(", "loss_d", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.reset_meters": [[117, 121], ["trainer.Head_Detector_Trainer.meters.items", "trainer.Head_Detector_Trainer.rpn_cm.reset", "meter.reset"], "methods", ["None"], ["", "", "def", "reset_meters", "(", "self", ")", ":", "\n", "        ", "for", "key", ",", "meter", "in", "self", ".", "meters", ".", "items", "(", ")", ":", "\n", "            ", "meter", ".", "reset", "(", ")", "\n", "", "self", ".", "rpn_cm", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.Head_Detector_Trainer.get_meter_data": [[122, 124], ["v.value", "trainer.Head_Detector_Trainer.meters.items"], "methods", ["None"], ["", "def", "get_meter_data", "(", "self", ")", ":", "\n", "        ", "return", "{", "k", ":", "v", ".", "value", "(", ")", "[", "0", "]", "for", "k", ",", "v", "in", "self", ".", "meters", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer._smooth_l1_loss": [[125, 135], ["t.float.float", "diff.abs", "torch.autograd.Variable", "y.sum"], "function", ["None"], ["", "", "def", "_smooth_l1_loss", "(", "x", ",", "t", ",", "in_weight", ",", "sigma", ")", ":", "\n", "    ", "t", "=", "t", ".", "float", "(", ")", "\n", "sigma2", "=", "sigma", "**", "2", "\n", "diff", "=", "in_weight", "*", "(", "x", "-", "t", ")", "\n", "abs_diff", "=", "diff", ".", "abs", "(", ")", "\n", "flag", "=", "(", "abs_diff", ".", "data", "<", "(", "1.", "/", "sigma2", ")", ")", ".", "float", "(", ")", "\n", "flag", "=", "Variable", "(", "flag", ")", "\n", "y", "=", "(", "flag", "*", "(", "sigma2", "/", "2.", ")", "*", "(", "diff", "**", "2", ")", "+", "\n", "(", "1", "-", "flag", ")", "*", "(", "abs_diff", "-", "0.5", "/", "sigma2", ")", ")", "\n", "return", "y", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.trainer.head_detector_loss": [[136, 142], ["torch.zeros().cuda", "trainer._smooth_l1_loss", "torch.autograd.Variable", "torch.zeros", "gt_loc.size"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or._smooth_l1_loss"], ["", "def", "head_detector_loss", "(", "pred_loc", ",", "gt_loc", ",", "gt_label", ",", "sigma", ")", ":", "\n", "    ", "in_weight", "=", "t", ".", "zeros", "(", "gt_loc", ".", "size", "(", ")", ")", ".", "cuda", "(", ")", "\n", "in_weight", "[", "(", "gt_label", ">", "0", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "in_weight", ")", ".", "cuda", "(", ")", "]", "=", "1", "\n", "loc_loss", "=", "_smooth_l1_loss", "(", "pred_loc", ",", "gt_loc", ",", "Variable", "(", "in_weight", ")", ",", "sigma", ")", "\n", "loc_loss", "/=", "(", "gt_label", ">=", "0", ")", ".", "sum", "(", ")", ".", "float", "(", ")", "# ignore gt_label==-1 for rpn_loss", "\n", "return", "loc_loss", "\n", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train.save": [[31, 36], ["dict", "trainer.head_detector.state_dict", "src.config.opt._state_dict"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._state_dict"], ["def", "save", "(", "trainer", ")", ":", "\n", "    ", "save_dict", "=", "dict", "(", ")", "\n", "save_dict", "[", "'model'", "]", "=", "trainer", ".", "head_detector", ".", "state_dict", "(", ")", "\n", "save_dict", "[", "'config'", "]", "=", "opt", ".", "_state_dict", "(", ")", "\n", "return", "save_dict", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train.eval": [[38, 105], ["train_or.Head_Detector_Trainer", "enumerate", "print", "img2.cuda.cuda", "src.scalar", "range", "src.tonumpy", "img.cuda().float", "bbox_.cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "head_detector.predict", "src.tonumpy", "src.bbox_tools.bbox_iou", "src.bbox_tools.bbox_iou.max", "len", "numpy.zeros", "numpy.append", "numpy.append", "sklearn.metrics.average_precision_score", "str", "numpy.where", "len", "numpy.zeros", "numpy.ones", "img.cuda", "max", "max"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.scalar", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.predict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bbox_iou"], ["", "def", "eval", "(", "dataloader", ",", "head_detector", ")", ":", "\n", "    ", "trainer", "=", "Head_Detector_Trainer", "(", "head_detector", ")", "\n", "\n", "# trainer.load('./checkpoints/diff_head_detector03120716_0.8')", "\n", "# print(os.getcwd())", "\n", "#  trainer.load('./checkpoints/diff_head_detector04151658_0.895')", "\n", "# trainer.load('./checkpoints/head_detector12200617_0.813')", "\n", "# trainer.load('./checkpoints/head_detector12251121_0.809')", "\n", "\n", "\"\"\"\n    Given the dataloader of the test split compute the\n    average corLoc of the dataset using the head detector \n    model given as the argument to the function. \n    \"\"\"", "\n", "test_img_num", "=", "0", "\n", "test_corrLoc", "=", "0.0", "\n", "AP", "=", "0.0", "\n", "for", "ii", ",", "(", "img_path", ",", "img", ",", "img2", ",", "bbox_", ",", "scale", ")", "in", "enumerate", "(", "dataloader", ")", ":", "\n", "\n", "# print(scale)", "\n", "        ", "img", ",", "bbox", "=", "img", ".", "cuda", "(", ")", ".", "float", "(", ")", ",", "bbox_", ".", "cuda", "(", ")", "\n", "img2", "=", "img2", ".", "cuda", "(", ")", "\n", "\n", "scale", "=", "at", ".", "scalar", "(", "scale", ")", "\n", "# img, bbox = img.cuda().float(), bbox_.cuda()", "\n", "img", ",", "img2", ",", "bbox", "=", "Variable", "(", "img", ")", ",", "Variable", "(", "img2", ")", ",", "Variable", "(", "bbox", ")", "\n", "# s1 = datetime.datetime.now()", "\n", "for", "gg", "in", "range", "(", "1", ")", ":", "\n", "            ", "pred_bboxes_", ",", "scores", "=", "head_detector", ".", "predict", "(", "img", ",", "img2", ",", "scale", ",", "mode", "=", "'evaluate'", ",", "\n", "thresh", "=", "0.000", ")", "# 0\u30020005", "\n", "# s2 = datetime.datetime.now()", "\n", "# print(s1,s2)", "\n", "# print((s1 - s2).seconds)", "\n", "", "gt_bboxs", "=", "at", ".", "tonumpy", "(", "bbox_", ")", "[", "0", "]", "\n", "pred_bboxes_", "=", "at", ".", "tonumpy", "(", "pred_bboxes_", ")", "\n", "\n", "# img2 = img.clone()", "\n", "\n", "if", "pred_bboxes_", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "            ", "test_img_num", "+=", "1", "\n", "continue", "\n", "", "else", ":", "\n", "            ", "ious", "=", "bbox_iou", "(", "pred_bboxes_", ",", "gt_bboxs", ")", "\n", "max_ious", "=", "ious", ".", "max", "(", "axis", "=", "1", ")", "\n", "corr_preds", "=", "np", ".", "where", "(", "max_ious", ">=", "0.5", ")", "[", "0", "]", "\n", "num_boxs", "=", "gt_bboxs", ".", "shape", "[", "0", "]", "\n", "num_corr_preds", "=", "len", "(", "corr_preds", ")", "\n", "\n", "gt_labels", "=", "np", ".", "zeros", "(", "len", "(", "scores", ")", ")", "\n", "for", "index", "in", "corr_preds", ":", "\n", "                ", "gt_labels", "[", "index", "]", "=", "1", "\n", "\n", "", "scores", "=", "np", ".", "append", "(", "scores", ",", "np", ".", "zeros", "(", "max", "(", "num_boxs", "-", "num_corr_preds", ",", "0", ")", ")", ")", "# .astype(np.float)", "\n", "gt_labels", "=", "np", ".", "append", "(", "gt_labels", ",", "np", ".", "ones", "(", "max", "(", "num_boxs", "-", "num_corr_preds", ",", "0", ")", ")", ")", "# .astype(np.bool_)", "\n", "ap", "=", "average_precision_score", "(", "gt_labels", ",", "scores", ")", "\n", "# curve=precision_recall_curve(gt_labels,scores)", "\n", "# recall=recall_score(gt_labels,scores)", "\n", "AP", "=", "AP", "+", "ap", "\n", "# print(scores)", "\n", "# show_img(img_path,img_path_pre,pred_bboxes_,scores,cam_img)", "\n", "\n", "test_corrLoc", "+=", "num_corr_preds", "/", "num_boxs", "\n", "test_img_num", "+=", "1", "\n", "", "img_path_pre", "=", "img_path", "\n", "", "print", "(", "\"AP:\"", "+", "str", "(", "AP", "/", "test_img_num", ")", ")", "\n", "\n", "return", "AP", "/", "test_img_num", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train.train": [[107, 234], ["print", "print", "print", "data.dataset.Dataset", "data.dataset.Dataset", "data.dataset.Dataset", "print", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "torch.utils.data.DataLoader", "src.head_backbone.mpsn", "print", "train_or.Head_Detector_Trainer().cuda", "range", "log.append", "print", "log.append", "print", "matplotlib.title", "matplotlib.plot", "matplotlib.plot", "matplotlib.legend", "os.path.join", "matplotlib.savefig", "f.close", "os.path.join", "copy.deepcopy.save", "os.path.join", "copy.deepcopy.save", "src.check_loaded_data", "src.check_loaded_data", "src.check_loaded_data", "enumerate", "round", "round", "test_ap.append", "val_ap.append", "ep.append", "print", "log.append", "print", "print", "log.append", "log.append", "open", "f.writelines", "str", "str", "len", "len", "len", "train_or.Head_Detector_Trainer", "src.scalar", "img2.cuda.cuda", "Head_Detector_Trainer().cuda.train_step", "train.eval", "train.eval", "copy.deepcopy", "copy.deepcopy", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "img.cuda().float", "bbox_.cuda", "torch.autograd.Variable", "torch.autograd.Variable", "torch.autograd.Variable", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "random.randint", "random.randint", "random.randint", "os.path.join", "src.get_phase_data_list", "os.path.join", "src.get_phase_data_list", "len", "len", "len", "img.cuda"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.plot", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.plot", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.save", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.save", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.scalar", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.train_step", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train.eval", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train.eval", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list", "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list"], ["", "def", "train", "(", ")", ":", "\n", "# Get the dataset", "\n", "    ", "for", "phase", "in", "phases", ":", "\n", "        ", "if", "phase", "==", "'train'", ":", "\n", "            ", "if", "dataset_name", "==", "'brainwash'", ":", "\n", "                ", "train_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "'brainwash_train.idl'", ")", "\n", "train_data_list", "=", "utils", ".", "get_phase_data_list", "(", "train_data_list_path", ",", "dataset_name", ")", "\n", "", "if", "dataset_name", "==", "'RGBdata'", ":", "\n", "                ", "train_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "'RGBdata_train.idl'", ")", "\n", "train_data_list", "=", "utils", ".", "get_phase_data_list", "(", "train_data_list_path", ",", "dataset_name", ")", "\n", "", "", "elif", "phase", "==", "'val'", ":", "\n", "            ", "if", "dataset_name", "==", "'brainwash'", ":", "\n", "                ", "val_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "'brainwash_val.idl'", ")", "\n", "val_data_list", "=", "utils", ".", "get_phase_data_list", "(", "val_data_list_path", ",", "dataset_name", ")", "\n", "", "if", "dataset_name", "==", "'RGBdata'", ":", "\n", "                ", "val_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "'RGBdata_val.idl'", ")", "\n", "val_data_list", "=", "utils", ".", "get_phase_data_list", "(", "val_data_list_path", ",", "dataset_name", ")", "\n", "", "", "elif", "phase", "==", "'test'", ":", "\n", "            ", "if", "dataset_name", "==", "'RGBdata'", ":", "\n", "                ", "test_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "'RGBdata_test.idl'", ")", "\n", "test_data_list", "=", "utils", ".", "get_phase_data_list", "(", "test_data_list_path", ",", "dataset_name", ")", "\n", "", "if", "dataset_name", "==", "'brainwash'", ":", "\n", "                ", "test_data_list_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "'brainwash_test.idl'", ")", "\n", "test_data_list", "=", "utils", ".", "get_phase_data_list", "(", "test_data_list_path", ",", "dataset_name", ")", "\n", "\n", "", "", "", "print", "(", "\"Number of images for training: %s\"", "%", "(", "len", "(", "train_data_list", ")", ")", ")", "\n", "print", "(", "\"Number of images for val: %s\"", "%", "(", "len", "(", "val_data_list", ")", ")", ")", "\n", "print", "(", "\"Number of images for test: %s\"", "%", "(", "len", "(", "test_data_list", ")", ")", ")", "\n", "\n", "if", "data_check_flag", ":", "\n", "        ", "utils", ".", "check_loaded_data", "(", "train_data_list", "[", "random", ".", "randint", "(", "1", ",", "len", "(", "train_data_list", ")", ")", "]", ")", "\n", "utils", ".", "check_loaded_data", "(", "val_data_list", "[", "random", ".", "randint", "(", "1", ",", "len", "(", "val_data_list", ")", ")", "]", ")", "\n", "utils", ".", "check_loaded_data", "(", "test_data_list", "[", "random", ".", "randint", "(", "1", ",", "len", "(", "test_data_list", ")", ")", "]", ")", "\n", "\n", "# Load the train dataset", "\n", "", "train_dataset", "=", "Dataset", "(", "train_data_list", ")", "\n", "val_dataset", "=", "Dataset", "(", "val_data_list", ")", "\n", "test_dataset", "=", "Dataset", "(", "test_data_list", ")", "\n", "print", "(", "\"Load data.\"", ")", "\n", "\n", "train_dataloader", "=", "data_", ".", "DataLoader", "(", "train_dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "1", ")", "\n", "val_dataloader", "=", "data_", ".", "DataLoader", "(", "val_dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "1", ")", "\n", "test_dataloader", "=", "data_", ".", "DataLoader", "(", "test_dataset", ",", "batch_size", "=", "1", ",", "shuffle", "=", "True", ",", "num_workers", "=", "1", ")", "\n", "# Initialize the head detector.", "\n", "scales1", "=", "[", "4", ",", "8", "]", "\n", "head_detector_mpsn", "=", "mpsn", "(", "ratios", "=", "[", "1", "]", ",", "anchor_scales", "=", "scales1", ")", "\n", "print", "(", "\"model construct completed\"", ")", "\n", "\n", "trainer", "=", "Head_Detector_Trainer", "(", "head_detector_mpsn", ")", ".", "cuda", "(", ")", "\n", "lr_", "=", "opt", ".", "lr", "\n", "test_ap", "=", "[", "]", "\n", "val_ap", "=", "[", "]", "\n", "ep", "=", "[", "]", "\n", "log", "=", "[", "]", "\n", "best_val", "=", "0", "\n", "best_test", "=", "0", "\n", "\n", "for", "epoch", "in", "range", "(", "opt", ".", "epoch", ")", ":", "\n", "        ", "log_tmp", "=", "[", "]", "\n", "# trainer.reset_meters()", "\n", "for", "ii", ",", "(", "img_path", ",", "img", ",", "img2", ",", "bbox_", ",", "scale", ")", "in", "enumerate", "(", "train_dataloader", ")", ":", "\n", "            ", "scale", "=", "at", ".", "scalar", "(", "scale", ")", "\n", "img", ",", "bbox", "=", "img", ".", "cuda", "(", ")", ".", "float", "(", ")", ",", "bbox_", ".", "cuda", "(", ")", "\n", "img2", "=", "img2", ".", "cuda", "(", ")", "\n", "img", ",", "img2", ",", "bbox", "=", "Variable", "(", "img", ")", ",", "Variable", "(", "img2", ")", ",", "Variable", "(", "bbox", ")", "\n", "_", ",", "_", ",", "_", "=", "trainer", ".", "train_step", "(", "img", ",", "img2", ",", "bbox", ",", "scale", ")", "\n", "", "val_Corr", "=", "round", "(", "eval", "(", "val_dataloader", ",", "head_detector_mpsn", ")", ",", "3", ")", "\n", "test_Corr", "=", "round", "(", "eval", "(", "test_dataloader", ",", "head_detector_mpsn", ")", ",", "3", ")", "\n", "test_ap", ".", "append", "(", "test_Corr", ")", "\n", "val_ap", ".", "append", "(", "val_Corr", ")", "\n", "ep", ".", "append", "(", "epoch", ")", "\n", "\n", "print", "(", "\"Epoch {} of {}.\"", ".", "format", "(", "epoch", "+", "1", ",", "opt", ".", "epoch", ")", ")", "\n", "log_tmp", "=", "\"Epoch {} of {}.\\n\"", ".", "format", "(", "epoch", "+", "1", ",", "opt", ".", "epoch", ")", "\n", "log", ".", "append", "(", "log_tmp", ")", "\n", "if", "test_Corr", ">", "best_test", ":", "\n", "            ", "best_test", "=", "test_Corr", "\n", "test_model", "=", "copy", ".", "deepcopy", "(", "trainer", ")", "\n", "", "if", "val_Corr", ">", "best_val", ":", "\n", "            ", "best_val", "=", "val_Corr", "\n", "val_model", "=", "copy", ".", "deepcopy", "(", "trainer", ")", "\n", "\n", "", "print", "(", "\"  test average corrLoc accuracy:\\t\\t{:.3f}\"", ".", "format", "(", "test_Corr", ")", ")", "\n", "print", "(", "\"  val average corrLoc accuracy:\\t\\t{:.3f}\"", ".", "format", "(", "val_Corr", ")", ")", "\n", "log_tmp", "=", "\"  test average corrLoc accuracy:\\t\\t{:.3f}\\n\"", ".", "format", "(", "test_Corr", ")", "\n", "log", ".", "append", "(", "log_tmp", ")", "\n", "log_tmp", "=", "\"  val average corrLoc accuracy:\\t\\t{:.3f}\\n\"", ".", "format", "(", "val_Corr", ")", "\n", "log", ".", "append", "(", "log_tmp", ")", "\n", "if", "epoch", "==", "15", "or", "epoch", "==", "35", "or", "epoch", "==", "42", ":", "\n", "# trainer.load(model_save_path)", "\n", "#trainer.head_detector.scale_lr(opt.lr_decay)", "\n", "            ", "lr_", "=", "lr_", "*", "opt", ".", "lr_decay", "# 0.1", "\n", "\n", "# model_save_path = trainer.save(best_map=avg_test_CorrLoc)", "\n", "\n", "\n", "\n", "", "", "name", "=", "'resnet diff DFA+APC RGBdata '", "\n", "title", "=", "name", "+", "' Anchor_scales {:} AP '", ".", "format", "(", "scales1", ")", "\n", "log_tmp", "=", "title", "+", "'best_test_ap:\\t{:.3f}\\n'", ".", "format", "(", "best_test", ")", "\n", "log", ".", "append", "(", "log_tmp", ")", "\n", "print", "(", "log_tmp", ")", "\n", "log_tmp", "=", "title", "+", "'best_val_ap:\\t{:.3f}\\n'", ".", "format", "(", "best_val", ")", "\n", "log", ".", "append", "(", "log_tmp", ")", "\n", "print", "(", "log_tmp", ")", "\n", "\n", "\n", "# plt.figure()", "\n", "plt", ".", "title", "(", "title", ")", "\n", "plt", ".", "plot", "(", "ep", ",", "test_ap", ",", "color", "=", "'red'", ",", "label", "=", "'Test'", ")", "\n", "plt", ".", "plot", "(", "ep", ",", "val_ap", ",", "color", "=", "'blue'", ",", "label", "=", "'Val'", ")", "\n", "plt", ".", "legend", "(", "loc", "=", "'upper left'", ")", "\n", "save_path", "=", "title", "+", "'.png'", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "'output'", ",", "save_path", ")", "\n", "plt", ".", "savefig", "(", "save_path", ")", "\n", "txt_path", "=", "'output/'", "+", "title", "+", "' .txt'", "\n", "with", "open", "(", "txt_path", ",", "'w+'", ")", "as", "f", ":", "\n", "        ", "f", ".", "writelines", "(", "log", ")", "\n", "", "f", ".", "close", "(", ")", "\n", "name1", "=", "name", "+", "' test '", "+", "str", "(", "best_test", ")", "\n", "\n", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "model_save_path", ",", "name1", ")", "\n", "test_model", ".", "save", "(", "save_path", "=", "model_save_path", ",", "best_map", "=", "best_test", ")", "\n", "\n", "name1", "=", "name", "+", "' val '", "+", "str", "(", "best_val", ")", "\n", "model_save_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "model_save_path", ",", "name1", ")", "\n", "val_model", ".", "save", "(", "save_path", "=", "model_save_path", ",", "best_map", "=", "best_val", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.__init__": [[23, 32], ["torch.nn.Module.__init__", "src.creator_tool.AnchorTargetCreator", "train_or.Head_Detector_Trainer.head_detector.get_optimizer", "torchnet.meter.ConfusionMeter", "torchnet.meter.AverageValueMeter"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.get_optimizer"], ["    ", "def", "__init__", "(", "self", ",", "head_detector", ")", ":", "\n", "        ", "super", "(", "Head_Detector_Trainer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "head_detector", "=", "head_detector", "\n", "self", ".", "rpn_sigma", "=", "opt", ".", "rpn_sigma", "\n", "self", ".", "anchor_target_creator", "=", "AnchorTargetCreator", "(", ")", "\n", "self", ".", "optimizer", "=", "self", ".", "head_detector", ".", "get_optimizer", "(", ")", "\n", "#self.vis = Visualizer(env=opt.env)", "\n", "self", ".", "rpn_cm", "=", "ConfusionMeter", "(", "2", ")", "\n", "self", ".", "meters", "=", "{", "k", ":", "AverageValueMeter", "(", ")", "for", "k", "in", "LossTuple", ".", "_fields", "}", "# average loss", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.forward": [[33, 70], ["bboxs.size", "imgs.size", "train_or.Head_Detector_Trainer.head_detector.left_vgg", "train_or.Head_Detector_Trainer.head_detector.addnet", "train_or.Head_Detector_Trainer.head_detector.rpn", "train_or.Head_Detector_Trainer.anchor_target_creator", "src.tovariable().long", "src.tovariable", "train_or.head_detector_loss", "torch.nn.functional.cross_entropy", "train_or.Head_Detector_Trainer.rpn_cm.add", "ValueError", "torch.mul", "src.tonumpy", "src.tovariable().long.cuda", "src.tonumpy", "src.totensor", "_gt_rpn_label.data.long", "LossTuple", "torch.sigmoid", "src.tovariable", "sum", "src.tonumpy"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.head_detector_loss", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.totensor", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy"], ["", "def", "forward", "(", "self", ",", "imgs", ",", "imgs2", ",", "bboxs", ",", "scale", ")", ":", "\n", "        ", "n", ",", "_", ",", "_", "=", "bboxs", ".", "size", "(", ")", "\n", "if", "n", "!=", "1", ":", "\n", "            ", "raise", "ValueError", "(", "'Currently only batch size 1 is supported.'", ")", "\n", "", "_", ",", "_", ",", "H", ",", "W", "=", "imgs", ".", "size", "(", ")", "\n", "img_size", "=", "(", "H", ",", "W", ")", "\n", "x", "=", "imgs", "\n", "x2", "=", "imgs2", "\n", "h1", "=", "self", ".", "head_detector", ".", "left_vgg", "(", "x", ")", "\n", "h2", "=", "self", ".", "head_detector", ".", "addnet", "(", "x2", ")", "\n", "hf2", "=", "t", ".", "mul", "(", "h1", ",", "t", ".", "sigmoid", "(", "h2", ")", ")", "+", "h2", "\n", "#hf2 = h1+h2", "\n", "h", "=", "hf2", "\n", "features", "=", "h", "\n", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "=", "self", ".", "head_detector", ".", "rpn", "(", "features", ",", "img_size", ",", "scale", ")", "\n", "bbox", "=", "bboxs", "[", "0", "]", "\n", "rpn_score", "=", "rpn_scores", "[", "0", "]", "\n", "rpn_loc", "=", "rpn_locs", "[", "0", "]", "\n", "\n", "# ------------------ RPN losses -------------------#", "\n", "gt_rpn_loc", ",", "gt_rpn_label", "=", "self", ".", "anchor_target_creator", "(", "at", ".", "tonumpy", "(", "bbox", ")", ",", "anchor", ",", "img_size", ")", "\n", "gt_rpn_label", "=", "at", ".", "tovariable", "(", "gt_rpn_label", ")", ".", "long", "(", ")", "\n", "gt_rpn_loc", "=", "at", ".", "tovariable", "(", "gt_rpn_loc", ")", "\n", "rpn_loc_loss", "=", "head_detector_loss", "(", "\n", "rpn_loc", ",", "\n", "gt_rpn_loc", ",", "\n", "gt_rpn_label", ".", "data", ",", "\n", "self", ".", "rpn_sigma", ")", "\n", "\n", "rpn_cls_loss", "=", "F", ".", "cross_entropy", "(", "rpn_score", ",", "gt_rpn_label", ".", "cuda", "(", ")", ",", "ignore_index", "=", "-", "1", ")", "\n", "_gt_rpn_label", "=", "gt_rpn_label", "[", "gt_rpn_label", ">", "-", "1", "]", "\n", "_rpn_score", "=", "at", ".", "tonumpy", "(", "rpn_score", ")", "[", "at", ".", "tonumpy", "(", "gt_rpn_label", ")", ">", "-", "1", "]", "\n", "self", ".", "rpn_cm", ".", "add", "(", "at", ".", "totensor", "(", "_rpn_score", ",", "False", ")", ",", "_gt_rpn_label", ".", "data", ".", "long", "(", ")", ")", "\n", "losses", "=", "[", "rpn_loc_loss", ",", "rpn_cls_loss", "]", "\n", "losses", "=", "losses", "+", "[", "sum", "(", "losses", ")", "]", "\n", "\n", "return", "LossTuple", "(", "*", "losses", ")", ",", "rois", ",", "rois_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.train_step": [[71, 78], ["train_or.Head_Detector_Trainer.optimizer.zero_grad", "train_or.Head_Detector_Trainer.forward", "losses.total_loss.backward", "train_or.Head_Detector_Trainer.optimizer.step", "train_or.Head_Detector_Trainer.update_meters"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.RegionProposalNetwork.forward", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.update_meters"], ["", "def", "train_step", "(", "self", ",", "imgs", ",", "imgs2", ",", "bboxes", ",", "scale", ")", ":", "\n", "        ", "self", ".", "optimizer", ".", "zero_grad", "(", ")", "\n", "losses", ",", "rois", ",", "rois_scores", "=", "self", ".", "forward", "(", "imgs", ",", "imgs2", ",", "bboxes", ",", "scale", ")", "\n", "losses", ".", "total_loss", ".", "backward", "(", ")", "\n", "self", ".", "optimizer", ".", "step", "(", ")", "\n", "self", ".", "update_meters", "(", "losses", ")", "\n", "return", "losses", ",", "rois", ",", "rois_scores", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.save": [[79, 98], ["dict", "train_or.Head_Detector_Trainer.head_detector.state_dict", "src.config.opt._state_dict", "torch.save", "train_or.Head_Detector_Trainer.optimizer.state_dict", "time.strftime", "os.path.join", "kwargs.items"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.save", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.state_dict"], ["", "def", "save", "(", "self", ",", "save_optimizer", "=", "False", ",", "save_path", "=", "None", ",", "**", "kwargs", ")", ":", "\n", "        ", "save_dict", "=", "dict", "(", ")", "\n", "save_dict", "[", "'model'", "]", "=", "self", ".", "head_detector", ".", "state_dict", "(", ")", "\n", "save_dict", "[", "'config'", "]", "=", "opt", ".", "_state_dict", "(", ")", "\n", "save_dict", "[", "'other_info'", "]", "=", "kwargs", "\n", "#save_dict['vis_info'] = self.vis.state_dict()", "\n", "\n", "if", "save_optimizer", ":", "\n", "            ", "save_dict", "[", "'optimizer'", "]", "=", "self", ".", "optimizer", ".", "state_dict", "(", ")", "\n", "\n", "", "if", "save_path", "is", "None", ":", "\n", "            ", "timestr", "=", "time", ".", "strftime", "(", "'%m%d%H%M'", ")", "\n", "save_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "model_save_path", ",", "'head_detector%s'", "%", "timestr", ")", "\n", "for", "k_", ",", "v_", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "                ", "save_path", "+=", "'_%s'", "%", "v_", "\n", "\n", "", "", "t", ".", "save", "(", "save_dict", ",", "save_path", ")", "\n", "#self.vis.save([self.vis.env])", "\n", "return", "save_path", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load": [[99, 111], ["torch.load", "train_or.Head_Detector_Trainer.head_detector.load_state_dict", "train_or.Head_Detector_Trainer.head_detector.load_state_dict", "src.config.opt._parse", "train_or.Head_Detector_Trainer.optimizer.load_state_dict"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._parse", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict"], ["", "def", "load", "(", "self", ",", "path", ",", "load_optimizer", "=", "True", ",", "parse_opt", "=", "False", ",", ")", ":", "\n", "        ", "state_dict", "=", "t", ".", "load", "(", "path", ")", "\n", "if", "'model'", "in", "state_dict", ":", "\n", "            ", "self", ".", "head_detector", ".", "load_state_dict", "(", "state_dict", "[", "'model'", "]", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "head_detector", ".", "load_state_dict", "(", "state_dict", ")", "\n", "return", "self", "\n", "", "if", "parse_opt", ":", "\n", "            ", "opt", ".", "_parse", "(", "state_dict", "[", "'config'", "]", ")", "\n", "", "if", "'optimizer'", "in", "state_dict", "and", "load_optimizer", ":", "\n", "            ", "self", ".", "optimizer", ".", "load_state_dict", "(", "state_dict", "[", "'optimizer'", "]", ")", "\n", "", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.update_meters": [[112, 116], ["train_or.Head_Detector_Trainer.meters.items", "src.scalar", "meter.add", "src.tonumpy", "losses._asdict().items", "losses._asdict"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.scalar", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy"], ["", "def", "update_meters", "(", "self", ",", "losses", ")", ":", "\n", "        ", "loss_d", "=", "{", "k", ":", "at", ".", "scalar", "(", "at", ".", "tonumpy", "(", "v", ")", ")", "for", "k", ",", "v", "in", "losses", ".", "_asdict", "(", ")", ".", "items", "(", ")", "}", "\n", "for", "key", ",", "meter", "in", "self", ".", "meters", ".", "items", "(", ")", ":", "\n", "            ", "meter", ".", "add", "(", "loss_d", "[", "key", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.reset_meters": [[117, 121], ["train_or.Head_Detector_Trainer.meters.items", "train_or.Head_Detector_Trainer.rpn_cm.reset", "meter.reset"], "methods", ["None"], ["", "", "def", "reset_meters", "(", "self", ")", ":", "\n", "        ", "for", "key", ",", "meter", "in", "self", ".", "meters", ".", "items", "(", ")", ":", "\n", "            ", "meter", ".", "reset", "(", ")", "\n", "", "self", ".", "rpn_cm", ".", "reset", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.get_meter_data": [[122, 124], ["v.value", "train_or.Head_Detector_Trainer.meters.items"], "methods", ["None"], ["", "def", "get_meter_data", "(", "self", ")", ":", "\n", "        ", "return", "{", "k", ":", "v", ".", "value", "(", ")", "[", "0", "]", "for", "k", ",", "v", "in", "self", ".", "meters", ".", "items", "(", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or._smooth_l1_loss": [[125, 135], ["t.float.float", "diff.abs", "torch.autograd.Variable", "y.sum"], "function", ["None"], ["", "", "def", "_smooth_l1_loss", "(", "x", ",", "t", ",", "in_weight", ",", "sigma", ")", ":", "\n", "    ", "t", "=", "t", ".", "float", "(", ")", "\n", "sigma2", "=", "sigma", "**", "2", "\n", "diff", "=", "in_weight", "*", "(", "x", "-", "t", ")", "\n", "abs_diff", "=", "diff", ".", "abs", "(", ")", "\n", "flag", "=", "(", "abs_diff", ".", "data", "<", "(", "1.", "/", "sigma2", ")", ")", ".", "float", "(", ")", "\n", "flag", "=", "Variable", "(", "flag", ")", "\n", "y", "=", "(", "flag", "*", "(", "sigma2", "/", "2.", ")", "*", "(", "diff", "**", "2", ")", "+", "\n", "(", "1", "-", "flag", ")", "*", "(", "abs_diff", "-", "0.5", "/", "sigma2", ")", ")", "\n", "return", "y", ".", "sum", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.head_detector_loss": [[136, 142], ["torch.zeros().cuda", "train_or._smooth_l1_loss", "torch.autograd.Variable", "torch.zeros", "gt_loc.size"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or._smooth_l1_loss"], ["", "def", "head_detector_loss", "(", "pred_loc", ",", "gt_loc", ",", "gt_label", ",", "sigma", ")", ":", "\n", "    ", "in_weight", "=", "t", ".", "zeros", "(", "gt_loc", ".", "size", "(", ")", ")", ".", "cuda", "(", ")", "\n", "in_weight", "[", "(", "gt_label", ">", "0", ")", ".", "view", "(", "-", "1", ",", "1", ")", ".", "expand_as", "(", "in_weight", ")", ".", "cuda", "(", ")", "]", "=", "1", "\n", "loc_loss", "=", "_smooth_l1_loss", "(", "pred_loc", ",", "gt_loc", ",", "Variable", "(", "in_weight", ")", ",", "sigma", ")", "\n", "loc_loss", "/=", "(", "gt_label", ">=", "0", ")", ".", "sum", "(", ")", ".", "float", "(", ")", "# ignore gt_label==-1 for rpn_loss", "\n", "return", "loc_loss", "\n", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.loc2bbox": [[8, 78], ["src_bbox.astype.astype", "numpy.zeros", "numpy.zeros", "numpy.exp", "numpy.exp"], "function", ["None"], ["def", "loc2bbox", "(", "src_bbox", ",", "loc", ")", ":", "\n", "    ", "\"\"\"Decode bounding boxes from bounding box offsets and scales.\n\n    Given bounding box offsets and scales computed by\n    :meth:`bbox2loc`, this function decodes the representation to\n    coordinates in 2D image coordinates.\n\n    Given scales and offsets :math:`t_y, t_x, t_h, t_w` and a bounding\n    box whose center is :math:`(y, x) = p_y, p_x` and size :math:`p_h, p_w`,\n    the decoded bounding box's center :math:`\\\\hat{g}_y`, :math:`\\\\hat{g}_x`\n    and size :math:`\\\\hat{g}_h`, :math:`\\\\hat{g}_w` are calculated\n    by the following formulas.\n\n    * :math:`\\\\hat{g}_y = p_h t_y + p_y`\n    * :math:`\\\\hat{g}_x = p_w t_x + p_x`\n    * :math:`\\\\hat{g}_h = p_h \\\\exp(t_h)`\n    * :math:`\\\\hat{g}_w = p_w \\\\exp(t_w)`\n\n    The decoding formulas are used in works such as R-CNN [#]_.\n\n    The output is same type as the type of the inputs.\n\n    .. [#] Ross Girshick, Jeff Donahue, Trevor Darrell, Jitendra Malik. \\\n    Rich feature hierarchies for accurate object detection and semantic \\\n    segmentation. CVPR 2014.\n\n    Args:\n        src_bbox (array): A coordinates of bounding boxes.\n            Its shape is :math:`(R, 4)`. These coordinates are\n            :math:`p_{ymin}, p_{xmin}, p_{ymax}, p_{xmax}`.\n        loc (array): An array with offsets and scales.\n            The shapes of :obj:`src_bbox` and :obj:`loc` should be same.\n            This contains values :math:`t_y, t_x, t_h, t_w`.\n\n    Returns:\n        array:\n        Decoded bounding box coordinates. Its shape is :math:`(R, 4)`. \\\n        The second axis contains four values \\\n        :math:`\\\\hat{g}_{ymin}, \\\\hat{g}_{xmin},\n        \\\\hat{g}_{ymax}, \\\\hat{g}_{xmax}`.\n\n    \"\"\"", "\n", "\n", "if", "src_bbox", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "np", ".", "zeros", "(", "(", "0", ",", "4", ")", ",", "dtype", "=", "loc", ".", "dtype", ")", "\n", "\n", "", "src_bbox", "=", "src_bbox", ".", "astype", "(", "src_bbox", ".", "dtype", ",", "copy", "=", "False", ")", "\n", "\n", "src_height", "=", "src_bbox", "[", ":", ",", "2", "]", "-", "src_bbox", "[", ":", ",", "0", "]", "\n", "src_width", "=", "src_bbox", "[", ":", ",", "3", "]", "-", "src_bbox", "[", ":", ",", "1", "]", "\n", "src_ctr_y", "=", "src_bbox", "[", ":", ",", "0", "]", "+", "0.5", "*", "src_height", "\n", "src_ctr_x", "=", "src_bbox", "[", ":", ",", "1", "]", "+", "0.5", "*", "src_width", "\n", "\n", "dy", "=", "loc", "[", ":", ",", "0", ":", ":", "4", "]", "\n", "dx", "=", "loc", "[", ":", ",", "1", ":", ":", "4", "]", "\n", "dh", "=", "loc", "[", ":", ",", "2", ":", ":", "4", "]", "\n", "dw", "=", "loc", "[", ":", ",", "3", ":", ":", "4", "]", "\n", "\n", "ctr_y", "=", "dy", "*", "src_height", "[", ":", ",", "np", ".", "newaxis", "]", "+", "src_ctr_y", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "ctr_x", "=", "dx", "*", "src_width", "[", ":", ",", "np", ".", "newaxis", "]", "+", "src_ctr_x", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "h", "=", "np", ".", "exp", "(", "dh", ")", "*", "src_height", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "w", "=", "np", ".", "exp", "(", "dw", ")", "*", "src_width", "[", ":", ",", "np", ".", "newaxis", "]", "\n", "\n", "dst_bbox", "=", "np", ".", "zeros", "(", "loc", ".", "shape", ",", "dtype", "=", "loc", ".", "dtype", ")", "\n", "dst_bbox", "[", ":", ",", "0", ":", ":", "4", "]", "=", "ctr_y", "-", "0.5", "*", "h", "\n", "dst_bbox", "[", ":", ",", "1", ":", ":", "4", "]", "=", "ctr_x", "-", "0.5", "*", "w", "\n", "dst_bbox", "[", ":", ",", "2", ":", ":", "4", "]", "=", "ctr_y", "+", "0.5", "*", "h", "\n", "dst_bbox", "[", ":", ",", "3", ":", ":", "4", "]", "=", "ctr_x", "+", "0.5", "*", "w", "\n", "\n", "return", "dst_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bbox2loc": [[80, 143], ["numpy.maximum", "numpy.maximum", "numpy.log", "numpy.log", "numpy.vstack().transpose", "numpy.finfo", "numpy.vstack"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.log", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.log"], ["", "def", "bbox2loc", "(", "src_bbox", ",", "dst_bbox", ")", ":", "\n", "    ", "\"\"\"Encodes the source and the destination bounding boxes to \"loc\".\n\n    Given bounding boxes, this function computes offsets and scales\n    to match the source bounding boxes to the target bounding boxes.\n    Mathematcially, given a bounding box whose center is\n    :math:`(y, x) = p_y, p_x` and\n    size :math:`p_h, p_w` and the target bounding box whose center is\n    :math:`g_y, g_x` and size :math:`g_h, g_w`, the offsets and scales\n    :math:`t_y, t_x, t_h, t_w` can be computed by the following formulas.\n\n    * :math:`t_y = \\\\frac{(g_y - p_y)} {p_h}`\n    * :math:`t_x = \\\\frac{(g_x - p_x)} {p_w}`\n    * :math:`t_h = \\\\log(\\\\frac{g_h} {p_h})`\n    * :math:`t_w = \\\\log(\\\\frac{g_w} {p_w})`\n\n    The output is same type as the type of the inputs.\n    The encoding formulas are used in works such as R-CNN [#]_.\n\n    .. [#] Ross Girshick, Jeff Donahue, Trevor Darrell, Jitendra Malik. \\\n    Rich feature hierarchies for accurate object detection and semantic \\\n    segmentation. CVPR 2014.\n\n    Args:\n        src_bbox (array): An image coordinate array whose shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n            These coordinates are\n            :math:`p_{ymin}, p_{xmin}, p_{ymax}, p_{xmax}`.\n        dst_bbox (array): An image coordinate array whose shape is\n            :math:`(R, 4)`.\n            These coordinates are\n            :math:`g_{ymin}, g_{xmin}, g_{ymax}, g_{xmax}`.\n\n    Returns:\n        array:\n        Bounding box offsets and scales from :obj:`src_bbox` \\\n        to :obj:`dst_bbox`. \\\n        This has shape :math:`(R, 4)`.\n        The second axis contains four values :math:`t_y, t_x, t_h, t_w`.\n\n    \"\"\"", "\n", "\n", "height", "=", "src_bbox", "[", ":", ",", "2", "]", "-", "src_bbox", "[", ":", ",", "0", "]", "\n", "width", "=", "src_bbox", "[", ":", ",", "3", "]", "-", "src_bbox", "[", ":", ",", "1", "]", "\n", "ctr_y", "=", "src_bbox", "[", ":", ",", "0", "]", "+", "0.5", "*", "height", "\n", "ctr_x", "=", "src_bbox", "[", ":", ",", "1", "]", "+", "0.5", "*", "width", "\n", "\n", "base_height", "=", "dst_bbox", "[", ":", ",", "2", "]", "-", "dst_bbox", "[", ":", ",", "0", "]", "\n", "base_width", "=", "dst_bbox", "[", ":", ",", "3", "]", "-", "dst_bbox", "[", ":", ",", "1", "]", "\n", "base_ctr_y", "=", "dst_bbox", "[", ":", ",", "0", "]", "+", "0.5", "*", "base_height", "\n", "base_ctr_x", "=", "dst_bbox", "[", ":", ",", "1", "]", "+", "0.5", "*", "base_width", "\n", "\n", "eps", "=", "np", ".", "finfo", "(", "height", ".", "dtype", ")", ".", "eps", "\n", "height", "=", "np", ".", "maximum", "(", "height", ",", "eps", ")", "\n", "width", "=", "np", ".", "maximum", "(", "width", ",", "eps", ")", "\n", "\n", "dy", "=", "(", "base_ctr_y", "-", "ctr_y", ")", "/", "height", "\n", "dx", "=", "(", "base_ctr_x", "-", "ctr_x", ")", "/", "width", "\n", "dh", "=", "np", ".", "log", "(", "base_height", "/", "height", ")", "\n", "dw", "=", "np", ".", "log", "(", "base_width", "/", "width", ")", "\n", "\n", "loc", "=", "np", ".", "vstack", "(", "(", "dy", ",", "dx", ",", "dh", ",", "dw", ")", ")", ".", "transpose", "(", ")", "\n", "return", "loc", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bb_intersection_over_union": [[144, 167], ["max", "max", "min", "min", "max", "max", "float"], "function", ["None"], ["", "def", "bb_intersection_over_union", "(", "boxA", ",", "boxB", ")", ":", "\n", "# determine the (x, y)-coordinates of the intersection rectangle", "\n", "# ymin,xmin,ymax,xmax", "\n", "    ", "xA", "=", "max", "(", "boxA", "[", "1", "]", ",", "boxB", "[", "1", "]", ")", "\n", "yA", "=", "max", "(", "boxA", "[", "0", "]", ",", "boxB", "[", "0", "]", ")", "\n", "xB", "=", "min", "(", "boxA", "[", "3", "]", ",", "boxB", "[", "3", "]", ")", "\n", "yB", "=", "min", "(", "boxA", "[", "2", "]", ",", "boxB", "[", "2", "]", ")", "\n", "\n", "# compute the area of intersection rectangle", "\n", "interArea", "=", "max", "(", "0", ",", "xB", "-", "xA", "+", "1", ")", "*", "max", "(", "0", ",", "yB", "-", "yA", "+", "1", ")", "\n", "\n", "# compute the area of both the prediction and ground-truth", "\n", "# rectangles", "\n", "boxAArea", "=", "(", "boxA", "[", "2", "]", "-", "boxA", "[", "0", "]", "+", "1", ")", "*", "(", "boxA", "[", "3", "]", "-", "boxA", "[", "1", "]", "+", "1", ")", "\n", "boxBArea", "=", "(", "boxB", "[", "2", "]", "-", "boxB", "[", "0", "]", "+", "1", ")", "*", "(", "boxB", "[", "3", "]", "-", "boxB", "[", "1", "]", "+", "1", ")", "\n", "\n", "# compute the intersection over union by taking the intersection", "\n", "# area and dividing it by the sum of prediction + ground-truth", "\n", "# areas - the interesection area", "\n", "iou", "=", "interArea", "/", "float", "(", "boxAArea", "+", "boxBArea", "-", "interArea", ")", "\n", "\n", "# return the intersection over union value", "\n", "return", "iou", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bbox_iou": [[180, 219], ["numpy.maximum", "numpy.minimum", "numpy.prod", "numpy.prod", "numpy.prod"], "function", ["None"], ["", "def", "bbox_iou", "(", "bbox_a", ",", "bbox_b", ")", ":", "\n", "    ", "\"\"\"Calculate the Intersection of Unions (IoUs) between bounding boxes.\n\n    IoU is calculated as a ratio of area of the intersection\n    and area of the union.\n\n    This function accepts both :obj:`numpy.ndarray` and :obj:`cupy.ndarray` as\n    inputs. Please note that both :obj:`bbox_a` and :obj:`bbox_b` need to be\n    same type.\n    The output is same type as the type of the inputs.\n\n    Args:\n        bbox_a (array): An array whose shape is :math:`(N, 4)`.\n            :math:`N` is the number of bounding boxes.\n            The dtype should be :obj:`numpy.float32`.\n        bbox_b (array): An array similar to :obj:`bbox_a`,\n            whose shape is :math:`(K, 4)`.\n            The dtype should be :obj:`numpy.float32`.\n\n    Returns:\n        array:\n        An array whose shape is :math:`(N, K)`. \\\n        An element at index :math:`(n, k)` contains IoUs between \\\n        :math:`n` th bounding box in :obj:`bbox_a` and :math:`k` th bounding \\\n        box in :obj:`bbox_b`.\n\n    \"\"\"", "\n", "if", "bbox_a", ".", "shape", "[", "1", "]", "!=", "4", "or", "bbox_b", ".", "shape", "[", "1", "]", "!=", "4", ":", "\n", "        ", "raise", "IndexError", "\n", "\n", "# top left", "\n", "", "tl", "=", "np", ".", "maximum", "(", "bbox_a", "[", ":", ",", "None", ",", ":", "2", "]", ",", "bbox_b", "[", ":", ",", ":", "2", "]", ")", "\n", "# bottom right", "\n", "br", "=", "np", ".", "minimum", "(", "bbox_a", "[", ":", ",", "None", ",", "2", ":", "]", ",", "bbox_b", "[", ":", ",", "2", ":", "]", ")", "\n", "\n", "area_i", "=", "np", ".", "prod", "(", "br", "-", "tl", ",", "axis", "=", "2", ")", "*", "(", "tl", "<", "br", ")", ".", "all", "(", "axis", "=", "2", ")", "\n", "area_a", "=", "np", ".", "prod", "(", "bbox_a", "[", ":", ",", "2", ":", "]", "-", "bbox_a", "[", ":", ",", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "area_b", "=", "np", ".", "prod", "(", "bbox_b", "[", ":", ",", "2", ":", "]", "-", "bbox_b", "[", ":", ",", ":", "2", "]", ",", "axis", "=", "1", ")", "\n", "return", "area_i", "/", "(", "area_a", "[", ":", ",", "None", "]", "+", "area_b", "-", "area_i", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.__test": [[221, 223], ["None"], "function", ["None"], ["", "def", "__test", "(", ")", ":", "\n", "    ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.generate_anchor_base": [[229, 282], ["numpy.zeros", "range", "len", "range", "len", "len", "len", "numpy.sqrt", "numpy.sqrt", "len"], "function", ["None"], ["", "def", "generate_anchor_base", "(", "base_size", "=", "16", ",", "ratios", "=", "[", "0.5", ",", "1", ",", "2", "]", ",", "\n", "anchor_scales", "=", "[", "8", ",", "16", ",", "32", "]", ")", ":", "\n", "    ", "\"\"\"Generate anchor base windows by enumerating aspect ratio and scales.\n\n    Generate anchors that are scaled and modified to the given aspect ratios.\n    Area of a scaled anchor is preserved when modifying to the given aspect\n    ratio.\n\n    :obj:`R = len(ratios) * len(anchor_scales)` anchors are generated by this\n    function.\n    The :obj:`i * len(anchor_scales) + j` th anchor corresponds to an anchor\n    generated by :obj:`ratios[i]` and :obj:`anchor_scales[j]`.\n\n    For example, if the scale is :math:`8` and the ratio is :math:`0.25`,\n    the width and the height of the base window will be stretched by :math:`8`.\n    For modifying the anchor to the given aspect ratio,\n    the height is halved and the width is doubled.\n\n    Args:\n        base_size (number): The width and the height of the reference window.\n        ratios (list of floats): This is ratios of width to height of\n            the anchors.\n        anchor_scales (list of numbers): This is areas of anchors.\n            Those areas will be the product of the square of an element in\n            :obj:`anchor_scales` and the original area of the reference\n            window.\n\n    Returns:\n        ~numpy.ndarray:\n        An array of shape :math:`(R, 4)`.\n        Each element is a set of coordinates of a bounding box.\n        The second axis corresponds to\n        :math:`(y_{min}, x_{min}, y_{max}, x_{max})` of a bounding box.\n\n    \"\"\"", "\n", "py", "=", "base_size", "/", "2.", "\n", "px", "=", "base_size", "/", "2.", "\n", "\n", "anchor_base", "=", "np", ".", "zeros", "(", "(", "len", "(", "ratios", ")", "*", "len", "(", "anchor_scales", ")", ",", "4", ")", ",", "\n", "dtype", "=", "np", ".", "float32", ")", "\n", "# for i in six.moves.range(len(ratios)):", "\n", "for", "i", "in", "range", "(", "len", "(", "ratios", ")", ")", ":", "\n", "# for j in six.moves.range(len(anchor_scales)):", "\n", "        ", "for", "j", "in", "range", "(", "len", "(", "anchor_scales", ")", ")", ":", "\n", "            ", "h", "=", "base_size", "*", "anchor_scales", "[", "j", "]", "*", "np", ".", "sqrt", "(", "ratios", "[", "i", "]", ")", "\n", "w", "=", "base_size", "*", "anchor_scales", "[", "j", "]", "*", "np", ".", "sqrt", "(", "1.", "/", "ratios", "[", "i", "]", ")", "\n", "\n", "index", "=", "i", "*", "len", "(", "anchor_scales", ")", "+", "j", "\n", "anchor_base", "[", "index", ",", "0", "]", "=", "py", "-", "h", "/", "2.", "\n", "anchor_base", "[", "index", ",", "1", "]", "=", "px", "-", "w", "/", "2.", "\n", "anchor_base", "[", "index", ",", "2", "]", "=", "py", "+", "h", "/", "2.", "\n", "anchor_base", "[", "index", ",", "3", "]", "=", "px", "+", "w", "/", "2.", "\n", "", "", "return", "anchor_base", "\n", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._parse": [[31, 41], ["config.Config._state_dict", "kwargs.items", "print", "pprint.pprint.pprint", "print", "setattr", "config.Config._state_dict", "ValueError"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._state_dict"], ["def", "_parse", "(", "self", ",", "kwargs", ")", ":", "\n", "        ", "state_dict", "=", "self", ".", "_state_dict", "(", ")", "\n", "for", "k", ",", "v", "in", "kwargs", ".", "items", "(", ")", ":", "\n", "            ", "if", "k", "not", "in", "state_dict", ":", "\n", "                ", "raise", "ValueError", "(", "'UnKnown Option: \"--%s\"'", "%", "k", ")", "\n", "", "setattr", "(", "self", ",", "k", ",", "v", ")", "\n", "\n", "", "print", "(", "'======user config========'", ")", "\n", "pprint", "(", "self", ".", "_state_dict", "(", ")", ")", "\n", "print", "(", "'==========end============'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.config.Config._state_dict": [[42, 45], ["getattr", "Config.__dict__.items", "k.startswith"], "methods", ["None"], ["", "def", "_state_dict", "(", "self", ")", ":", "\n", "        ", "return", "{", "k", ":", "getattr", "(", "self", ",", "k", ")", "for", "k", ",", "_", "in", "Config", ".", "__dict__", ".", "items", "(", ")", "if", "not", "k", ".", "startswith", "(", "'_'", ")", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.Head_Detector_VGG16.__init__": [[94, 111], ["head_detector_vgg16.right_addnet", "head_detector_vgg16.decom_vgg16", "head_detector_vgg16.left_addnet", "src.region_proposal_network.RegionProposalNetwork", "src.head_detector1.Head_Detector.__init__"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.right_addnet", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.decom_vgg16", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.left_addnet", "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "ratios", "=", "[", "0.5", ",", "1", ",", "2", "]", ",", "anchor_scales", "=", "[", "8", ",", "16", ",", "32", "]", ")", ":", "\n", "#extractor = right_vgg16()", "\n", "#addnet=right_addnet()", "\n", "        ", "addnet", "=", "right_addnet", "(", ")", "\n", "vgg", "=", "decom_vgg16", "(", ")", "\n", "left_add", "=", "left_addnet", "(", ")", "\n", "rpn", "=", "RegionProposalNetwork", "(", "\n", "512", ",", "512", ",", "\n", "ratios", "=", "ratios", ",", "\n", "anchor_scales", "=", "anchor_scales", ",", "\n", "feat_stride", "=", "self", ".", "feat_stride", "\n", ")", "\n", "super", "(", "Head_Detector_VGG16", ",", "self", ")", ".", "__init__", "(", "\n", "vgg", ",", "\n", "addnet", ",", "\n", "left_add", ",", "\n", "rpn", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.left_vgg16": [[8, 21], ["torchvision.models.vgg16", "torchvision.models.vgg16.load_state_dict", "torch.nn.Sequential", "torch.load", "list"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load"], ["def", "left_vgg16", "(", ")", ":", "\n", "    ", "\"\"\" Load the default PyTorch model or the pre-trained caffe model.\n    Freeze the weights of some layers of the network and train the rest\n    of the features.\n    \"\"\"", "\n", "\n", "\n", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "model", ".", "load_state_dict", "(", "t", ".", "load", "(", "opt", ".", "caffe_pretrain_path", ")", ")", "\n", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "0", ":", "10", "]", "\n", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "", "def", "right_vgg16", "(", ")", ":", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.right_vgg16": [[21, 26], ["torchvision.models.vgg16", "torchvision.models.vgg16.load_state_dict", "torch.nn.Sequential", "torch.load", "list"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load"], ["", "def", "right_vgg16", "(", ")", ":", "\n", "    ", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "model", ".", "load_state_dict", "(", "t", ".", "load", "(", "opt", ".", "caffe_pretrain_path", ")", ")", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "10", ":", "30", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.left_addnet": [[27, 35], ["torchvision.models.vgg16", "torchvision.models.vgg16.load_state_dict", "torch.nn.Sequential", "torch.load", "list"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load"], ["", "def", "left_addnet", "(", ")", ":", "\n", "\n", "    ", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "model", ".", "load_state_dict", "(", "t", ".", "load", "(", "opt", ".", "caffe_pretrain_path", ")", ")", "\n", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "0", ":", "10", "]", "\n", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.right_addnet": [[36, 41], ["torchvision.models.vgg16", "torchvision.models.vgg16.load_state_dict", "torch.nn.Sequential", "torch.load", "list"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load"], ["", "def", "right_addnet", "(", ")", ":", "\n", "    ", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "model", ".", "load_state_dict", "(", "t", ".", "load", "(", "opt", ".", "caffe_pretrain_path", ")", ")", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "10", ":", "30", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector_vgg16.decom_vgg16": [[42, 63], ["torch.nn.Sequential", "torchvision.models.vgg16", "torchvision.models.vgg16.load_state_dict", "torchvision.models.vgg16", "list", "torch.load"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict", "home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load"], ["", "def", "decom_vgg16", "(", ")", ":", "\n", "    ", "\"\"\" Load the default PyTorch model or the pre-trained caffe model. \n    Freeze the weights of some layers of the network and train the rest \n    of the features. \n    \"\"\"", "\n", "if", "opt", ".", "caffe_pretrain", ":", "\n", "# Load the caffe model", "\n", "        ", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "model", ".", "load_state_dict", "(", "t", ".", "load", "(", "opt", ".", "caffe_pretrain_path", ")", ")", "\n", "", "else", ":", "\n", "# Load the default model in PyTorch", "\n", "        ", "model", "=", "vgg16", "(", "pretrained", "=", "True", ")", "\n", "\n", "", "features", "=", "list", "(", "model", ".", "features", ")", "[", ":", "30", "]", "\n", "\n", "# Freeze some of the layers.", "\n", "# for layer in features[:10]:", "\n", "#     for p in layer.parameters():", "\n", "#         p.requires_grad = False", "\n", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.AnchorTargetCreator.__init__": [[11, 19], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "\n", "n_sample", "=", "32", ",", "\n", "pos_iou_thresh", "=", "0.7", ",", "neg_iou_thresh", "=", "0.3", ",", "\n", "pos_ratio", "=", "0.5", ")", ":", "\n", "        ", "self", ".", "n_sample", "=", "n_sample", "\n", "self", ".", "pos_iou_thresh", "=", "pos_iou_thresh", "\n", "self", ".", "neg_iou_thresh", "=", "neg_iou_thresh", "\n", "self", ".", "pos_ratio", "=", "pos_ratio", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.AnchorTargetCreator.__call__": [[20, 33], ["len", "creator_tool._get_inside_index", "creator_tool.AnchorTargetCreator._create_label", "src.bbox_tools.bbox2loc", "creator_tool._unmap", "creator_tool._unmap"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool._get_inside_index", "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.AnchorTargetCreator._create_label", "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bbox2loc", "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool._unmap", "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool._unmap"], ["", "def", "__call__", "(", "self", ",", "bbox", ",", "anchor", ",", "img_size", ")", ":", "\n", "        ", "img_H", ",", "img_W", "=", "img_size", "\n", "n_anchor", "=", "len", "(", "anchor", ")", "\n", "inside_index", "=", "_get_inside_index", "(", "anchor", ",", "img_H", ",", "img_W", ")", "\n", "anchor", "=", "anchor", "[", "inside_index", "]", "\n", "\n", "argmax_ious", ",", "label", "=", "self", ".", "_create_label", "(", "\n", "inside_index", ",", "anchor", ",", "bbox", ")", "\n", "\n", "loc", "=", "bbox2loc", "(", "anchor", ",", "bbox", "[", "argmax_ious", "]", ")", "\n", "label", "=", "_unmap", "(", "label", ",", "n_anchor", ",", "inside_index", ",", "fill", "=", "-", "1", ")", "\n", "loc", "=", "_unmap", "(", "loc", ",", "n_anchor", ",", "inside_index", ",", "fill", "=", "0", ")", "\n", "return", "loc", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.AnchorTargetCreator._create_label": [[34, 62], ["numpy.empty", "numpy.empty.fill", "creator_tool.AnchorTargetCreator._calc_ious", "int", "numpy.where", "len", "numpy.random.choice", "numpy.sum", "numpy.where", "len", "numpy.random.choice", "len", "len", "len"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.AnchorTargetCreator._calc_ious"], ["", "def", "_create_label", "(", "self", ",", "inside_index", ",", "anchor", ",", "bbox", ")", ":", "\n", "        ", "label", "=", "np", ".", "empty", "(", "(", "len", "(", "inside_index", ")", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "label", ".", "fill", "(", "-", "1", ")", "\n", "\n", "argmax_ious", ",", "max_ious", ",", "gt_argmax_ious", "=", "self", ".", "_calc_ious", "(", "anchor", ",", "bbox", ",", "inside_index", ")", "\n", "\n", "label", "[", "max_ious", "<", "self", ".", "neg_iou_thresh", "]", "=", "0", "\n", "\n", "label", "[", "gt_argmax_ious", "]", "=", "1", "\n", "\n", "label", "[", "max_ious", ">=", "self", ".", "pos_iou_thresh", "]", "=", "1", "\n", "\n", "n_pos", "=", "int", "(", "self", ".", "pos_ratio", "*", "self", ".", "n_sample", ")", "\n", "pos_index", "=", "np", ".", "where", "(", "label", "==", "1", ")", "[", "0", "]", "\n", "if", "len", "(", "pos_index", ")", ">", "n_pos", ":", "\n", "            ", "disable_index", "=", "np", ".", "random", ".", "choice", "(", "\n", "pos_index", ",", "size", "=", "(", "len", "(", "pos_index", ")", "-", "n_pos", ")", ",", "replace", "=", "False", ")", "\n", "label", "[", "disable_index", "]", "=", "-", "1", "\n", "\n", "", "n_neg", "=", "self", ".", "n_sample", "-", "np", ".", "sum", "(", "label", "==", "1", ")", "\n", "neg_index", "=", "np", ".", "where", "(", "label", "==", "0", ")", "[", "0", "]", "\n", "if", "len", "(", "neg_index", ")", ">", "n_neg", ":", "\n", "            ", "disable_index", "=", "np", ".", "random", ".", "choice", "(", "\n", "neg_index", ",", "size", "=", "(", "len", "(", "neg_index", ")", "-", "n_neg", ")", ",", "replace", "=", "False", ")", "\n", "label", "[", "disable_index", "]", "=", "-", "1", "\n", "\n", "", "return", "argmax_ious", ",", "label", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.AnchorTargetCreator._calc_ious": [[63, 72], ["src.bbox_tools.bbox_iou", "src.bbox_tools.bbox_iou.argmax", "src.bbox_tools.bbox_iou.argmax", "numpy.where", "numpy.arange", "numpy.arange", "len"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.bbox_iou"], ["", "def", "_calc_ious", "(", "self", ",", "anchor", ",", "bbox", ",", "inside_index", ")", ":", "\n", "        ", "ious", "=", "bbox_iou", "(", "anchor", ",", "bbox", ")", "\n", "argmax_ious", "=", "ious", ".", "argmax", "(", "axis", "=", "1", ")", "\n", "max_ious", "=", "ious", "[", "np", ".", "arange", "(", "len", "(", "inside_index", ")", ")", ",", "argmax_ious", "]", "\n", "gt_argmax_ious", "=", "ious", ".", "argmax", "(", "axis", "=", "0", ")", "\n", "gt_max_ious", "=", "ious", "[", "gt_argmax_ious", ",", "np", ".", "arange", "(", "ious", ".", "shape", "[", "1", "]", ")", "]", "\n", "gt_argmax_ious", "=", "np", ".", "where", "(", "ious", "==", "gt_max_ious", ")", "[", "0", "]", "\n", "\n", "return", "argmax_ious", ",", "max_ious", ",", "gt_argmax_ious", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.ProposalCreator.__init__": [[97, 112], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "parent_model", ",", "\n", "nms_thresh", "=", "0.7", ",", "\n", "n_train_pre_nms", "=", "12000", ",", "\n", "n_train_post_nms", "=", "300", ",", "\n", "n_test_pre_nms", "=", "6000", ",", "\n", "n_test_post_nms", "=", "300", ",", "\n", "min_size", "=", "16", "\n", ")", ":", "\n", "        ", "self", ".", "parent_model", "=", "parent_model", "\n", "self", ".", "nms_thresh", "=", "nms_thresh", "\n", "self", ".", "n_train_pre_nms", "=", "n_train_pre_nms", "\n", "self", ".", "n_train_post_nms", "=", "n_train_post_nms", "\n", "self", ".", "n_test_pre_nms", "=", "n_test_pre_nms", "\n", "self", ".", "n_test_post_nms", "=", "n_test_post_nms", "\n", "self", ".", "min_size", "=", "min_size", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool.ProposalCreator.__call__": [[113, 154], ["src.bbox_tools.loc2bbox", "numpy.clip", "numpy.clip", "min_size.numpy.numpy.numpy", "src.nms.non_maximum_suppression", "numpy.where", "score.ravel().argsort", "cupy.ascontiguousarray", "cupy.asarray", "slice", "slice", "score.ravel", "slice", "slice"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.loc2bbox", "home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression.non_maximum_suppression"], ["", "def", "__call__", "(", "self", ",", "loc", ",", "score", ",", "\n", "anchor", ",", "img_size", ",", "scale", "=", "1.", ")", ":", "\n", "\n", "        ", "if", "self", ".", "parent_model", ".", "training", ":", "\n", "            ", "n_pre_nms", "=", "self", ".", "n_train_pre_nms", "\n", "n_post_nms", "=", "self", ".", "n_train_post_nms", "\n", "", "else", ":", "\n", "            ", "n_pre_nms", "=", "self", ".", "n_test_pre_nms", "\n", "n_post_nms", "=", "self", ".", "n_test_post_nms", "\n", "\n", "", "roi", "=", "loc2bbox", "(", "anchor", ",", "loc", ")", "\n", "\n", "roi", "[", ":", ",", "slice", "(", "0", ",", "4", ",", "2", ")", "]", "=", "np", ".", "clip", "(", "\n", "roi", "[", ":", ",", "slice", "(", "0", ",", "4", ",", "2", ")", "]", ",", "0", ",", "img_size", "[", "0", "]", ")", "\n", "roi", "[", ":", ",", "slice", "(", "1", ",", "4", ",", "2", ")", "]", "=", "np", ".", "clip", "(", "\n", "roi", "[", ":", ",", "slice", "(", "1", ",", "4", ",", "2", ")", "]", ",", "0", ",", "img_size", "[", "1", "]", ")", "\n", "\n", "\n", "min_size", "=", "self", ".", "min_size", "*", "scale", "\n", "min_size", "=", "min_size", ".", "numpy", "(", ")", "\n", "hs", "=", "roi", "[", ":", ",", "2", "]", "-", "roi", "[", ":", ",", "0", "]", "\n", "ws", "=", "roi", "[", ":", ",", "3", "]", "-", "roi", "[", ":", ",", "1", "]", "\n", "\n", "keep", "=", "np", ".", "where", "(", "(", "hs", ">=", "min_size", ")", "&", "(", "ws", ">=", "min_size", ")", ")", "[", "0", "]", "\n", "roi", "=", "roi", "[", "keep", ",", ":", "]", "\n", "score", "=", "score", "[", "keep", "]", "\n", "\n", "order", "=", "score", ".", "ravel", "(", ")", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", "\n", "if", "n_pre_nms", ">", "0", ":", "\n", "            ", "order", "=", "order", "[", ":", "n_pre_nms", "]", "\n", "", "roi", "=", "roi", "[", "order", ",", ":", "]", "\n", "score", "=", "score", "[", "order", "]", "\n", "\n", "keep", "=", "non_maximum_suppression", "(", "\n", "cp", ".", "ascontiguousarray", "(", "cp", ".", "asarray", "(", "roi", ")", ")", ",", "\n", "thresh", "=", "self", ".", "nms_thresh", ")", "\n", "if", "n_post_nms", ">", "0", ":", "\n", "            ", "keep", "=", "keep", "[", ":", "n_post_nms", "]", "\n", "", "roi", "=", "roi", "[", "keep", ",", ":", "]", "\n", "score", "=", "score", "[", "keep", "]", "\n", "return", "roi", ",", "score", "\n", "", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool._unmap": [[74, 84], ["len", "numpy.empty", "np.empty.fill", "numpy.empty", "np.empty.fill"], "function", ["None"], ["", "", "def", "_unmap", "(", "data", ",", "count", ",", "index", ",", "fill", "=", "0", ")", ":", "\n", "    ", "if", "len", "(", "data", ".", "shape", ")", "==", "1", ":", "\n", "        ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", ",", "dtype", "=", "data", ".", "dtype", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "index", "]", "=", "data", "\n", "", "else", ":", "\n", "        ", "ret", "=", "np", ".", "empty", "(", "(", "count", ",", ")", "+", "data", ".", "shape", "[", "1", ":", "]", ",", "dtype", "=", "data", ".", "dtype", ")", "\n", "ret", ".", "fill", "(", "fill", ")", "\n", "ret", "[", "index", ",", ":", "]", "=", "data", "\n", "", "return", "ret", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.creator_tool._get_inside_index": [[86, 94], ["numpy.where"], "function", ["None"], ["", "def", "_get_inside_index", "(", "anchor", ",", "H", ",", "W", ")", ":", "\n", "    ", "index_inside", "=", "np", ".", "where", "(", "\n", "(", "anchor", "[", ":", ",", "0", "]", ">=", "0", ")", "&", "\n", "(", "anchor", "[", ":", ",", "1", "]", ">=", "0", ")", "&", "\n", "(", "anchor", "[", ":", ",", "2", "]", "<=", "H", ")", "&", "\n", "(", "anchor", "[", ":", ",", "3", "]", "<=", "W", ")", "\n", ")", "[", "0", "]", "\n", "return", "index_inside", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector1.Head_Detector.__init__": [[15, 21], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "vgg", ",", "addnet", ",", "left_add", ",", "rpn", ")", ":", "\n", "        ", "super", "(", "Head_Detector", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "vgg", "=", "vgg", "\n", "self", ".", "addnet", "=", "addnet", "\n", "self", ".", "rpn", "=", "rpn", "\n", "self", ".", "left_add", "=", "left_add", "\n", "# self.nms_thresh = 0.3 ", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector1.Head_Detector.forward": [[24, 43], ["x.size", "head_detector1.Head_Detector.vgg", "head_detector1.Head_Detector.left_add", "head_detector1.Head_Detector.addnet", "head_detector1.Head_Detector.rpn", "torch.mul", "torch.sigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "x2", ",", "scale", "=", "1.", ")", ":", "\n", "# _, _, H, W = x.size()", "\n", "# img_size = (H, W)", "\n", "# h = self.extractor(x)", "\n", "# rpn_locs, rpn_scores, rois, rois_scores, anchor = self.rpn(h, img_size, scale)", "\n", "# return rpn_locs, rpn_scores, rois, rois_scores, anchor", "\n", "#", "\n", "        ", "_", ",", "_", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "img_size", "=", "(", "H", ",", "W", ")", "\n", "h1", "=", "self", ".", "vgg", "(", "x", ")", "\n", "h2", "=", "self", ".", "left_add", "(", "x2", ")", "\n", "h3", "=", "self", ".", "addnet", "(", "h2", ")", "\n", "hf2", "=", "t", ".", "mul", "(", "h1", ",", "t", ".", "sigmoid", "(", "h3", ")", ")", "+", "h3", "\n", "#hf2=h1+h3", "\n", "h", "=", "hf2", "\n", "\n", "# second", "\n", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "=", "self", ".", "rpn", "(", "h", ",", "img_size", ",", "scale", ")", "\n", "return", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector1.Head_Detector.get_optimizer": [[44, 58], ["dict().items", "torch.optim.Adam", "torch.optim.SGD", "dict", "head_detector1.Head_Detector.named_parameters"], "methods", ["None"], ["", "def", "get_optimizer", "(", "self", ")", ":", "\n", "        ", "lr", "=", "opt", ".", "lr", "\n", "params", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "dict", "(", "self", ".", "named_parameters", "(", ")", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "value", ".", "requires_grad", ":", "\n", "                ", "if", "'bias'", "in", "key", ":", "\n", "                    ", "params", "+=", "[", "{", "'params'", ":", "[", "value", "]", ",", "'lr'", ":", "lr", "*", "2", ",", "'weight_decay'", ":", "0", "}", "]", "\n", "", "else", ":", "\n", "                    ", "params", "+=", "[", "{", "'params'", ":", "[", "value", "]", ",", "'lr'", ":", "lr", ",", "'weight_decay'", ":", "opt", ".", "weight_decay", "}", "]", "\n", "", "", "", "if", "opt", ".", "use_adam", ":", "\n", "            ", "self", ".", "optimizer", "=", "t", ".", "optim", ".", "Adam", "(", "params", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "optimizer", "=", "t", ".", "optim", ".", "SGD", "(", "params", ",", "momentum", "=", "0.9", ")", "\n", "", "return", "self", ".", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector1.Head_Detector._suppress": [[60, 76], ["src.nms.non_maximum_suppression", "cupy.asnumpy", "cupy.array"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression.non_maximum_suppression"], ["", "def", "_suppress", "(", "self", ",", "raw_cls_bbox", ",", "raw_prob", ",", "nms_thresh", ",", "score_thresh", ")", ":", "\n", "# bbox = list()", "\n", "# score = list()", "\n", "        ", "mask", "=", "raw_prob", ">", "score_thresh", "\n", "bbox", "=", "raw_cls_bbox", "[", "mask", "]", "\n", "scores", "=", "raw_prob", "[", "mask", "]", "\n", "keep", "=", "non_maximum_suppression", "(", "\n", "cp", ".", "array", "(", "bbox", ")", ",", "nms_thresh", ",", "scores", ")", "\n", "keep", "=", "cp", ".", "asnumpy", "(", "keep", ")", "\n", "bbox", "=", "bbox", "[", "keep", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "#         bbox.append(cls_bbox_l[keep])", "\n", "#         score.append(prob_l[keep])", "\n", "#         bbox = np.concatenate(bbox, axis=0).astype(np.float32)", "\n", "#         score = np.concatenate(score, axis=0).astype(np.float32)", "\n", "return", "bbox", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector1.Head_Detector.predict": [[78, 99], ["head_detector1.Head_Detector.forward", "src.array_tool.totensor", "src.array_tool.tonumpy", "x.size", "roi[].clamp", "roi[].clamp", "src.array_tool.tonumpy", "numpy.squeeze", "head_detector1.Head_Detector._suppress", "torch.nn.functional.softmax", "src.array_tool.tovariable"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.RegionProposalNetwork.forward", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.totensor", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector._suppress", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable"], ["", "def", "predict", "(", "self", ",", "x", ",", "x2", ",", "scale", "=", "1.", ",", "mode", "=", "'evaluate'", ",", "thresh", "=", "0.01", ")", ":", "\n", "\n", "        ", "if", "mode", "==", "'evaluate'", ":", "\n", "            ", "nms_thresh", "=", "0.3", "\n", "score_thresh", "=", "thresh", "\n", "", "elif", "mode", "==", "'visualize'", ":", "\n", "            ", "nms_thresh", "=", "0.3", "\n", "score_thresh", "=", "thresh", "\n", "\n", "", "_", ",", "_", ",", "rois", ",", "rois_scores", ",", "_", "=", "self", ".", "forward", "(", "x", ",", "x2", ",", "scale", "=", "scale", ")", "\n", "roi", "=", "at", ".", "totensor", "(", "rois", ")", "\n", "probabilities", "=", "at", ".", "tonumpy", "(", "F", ".", "softmax", "(", "at", ".", "tovariable", "(", "rois_scores", ")", ",", "dim", "=", "0", ")", ")", "\n", "#probabilities = at.tonumpy(F.softmax(at.tovariable(rois_scores)))", "\n", "_", ",", "_", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "size", "=", "(", "H", ",", "W", ")", "\n", "roi", "[", ":", ",", "0", ":", ":", "2", "]", "=", "(", "roi", "[", ":", ",", "0", ":", ":", "2", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "size", "[", "0", "]", ")", "\n", "roi", "[", ":", ",", "1", ":", ":", "2", "]", "=", "(", "roi", "[", ":", ",", "1", ":", ":", "2", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "size", "[", "1", "]", ")", "\n", "roi_raw", "=", "at", ".", "tonumpy", "(", "roi", ")", "\n", "probabilities", "=", "np", ".", "squeeze", "(", "probabilities", ")", "\n", "bbox", ",", "score", "=", "self", ".", "_suppress", "(", "roi_raw", ",", "probabilities", ",", "nms_thresh", ",", "score_thresh", ")", "\n", "return", "bbox", ",", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector1.Head_Detector.scale_lr": [[100, 104], ["None"], "methods", ["None"], ["", "def", "scale_lr", "(", "self", ",", "decay", "=", "0.1", ")", ":", "\n", "        ", "for", "param_group", "in", "self", ".", "optimizer", ".", "param_groups", ":", "\n", "            ", "param_group", "[", "'lr'", "]", "*=", "decay", "\n", "", "return", "self", ".", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.__init__": [[16, 23], ["torch.nn.Module.__init__"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__"], ["    ", "def", "__init__", "(", "self", ",", "addnet", ",", "left_vgg", ",", "rpn", ")", ":", "\n", "        ", "super", "(", "Head_Detector", ",", "self", ")", ".", "__init__", "(", ")", "\n", "\n", "self", ".", "left_vgg", "=", "left_vgg", "\n", "\n", "self", ".", "addnet", "=", "addnet", "\n", "self", ".", "rpn", "=", "rpn", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.forward": [[27, 39], ["x.size", "head_detector.Head_Detector.left_vgg", "head_detector.Head_Detector.addnet", "head_detector.Head_Detector.rpn", "torch.mul", "torch.sigmoid"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ",", "x2", ",", "scale", "=", "1.", ")", ":", "\n", "\n", "        ", "_", ",", "_", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "img_size", "=", "(", "H", ",", "W", ")", "\n", "h1", "=", "self", ".", "left_vgg", "(", "x", ")", "\n", "h2", "=", "self", ".", "addnet", "(", "x2", ")", "\n", "hf2", "=", "t", ".", "mul", "(", "h1", ",", "t", ".", "sigmoid", "(", "h2", ")", ")", "+", "h2", "\n", "#hf2 = h1 + h2", "\n", "h", "=", "hf2", "\n", "# second", "\n", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "=", "self", ".", "rpn", "(", "h", ",", "img_size", ",", "scale", ")", "\n", "return", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.get_optimizer": [[40, 54], ["dict().items", "torch.optim.Adam", "torch.optim.SGD", "dict", "head_detector.Head_Detector.named_parameters"], "methods", ["None"], ["", "def", "get_optimizer", "(", "self", ")", ":", "\n", "        ", "lr", "=", "opt", ".", "lr", "\n", "params", "=", "[", "]", "\n", "for", "key", ",", "value", "in", "dict", "(", "self", ".", "named_parameters", "(", ")", ")", ".", "items", "(", ")", ":", "\n", "            ", "if", "value", ".", "requires_grad", ":", "\n", "                ", "if", "'bias'", "in", "key", ":", "\n", "                    ", "params", "+=", "[", "{", "'params'", ":", "[", "value", "]", ",", "'lr'", ":", "lr", "*", "2", ",", "'weight_decay'", ":", "0", "}", "]", "\n", "", "else", ":", "\n", "                    ", "params", "+=", "[", "{", "'params'", ":", "[", "value", "]", ",", "'lr'", ":", "lr", ",", "'weight_decay'", ":", "opt", ".", "weight_decay", "}", "]", "\n", "", "", "", "if", "opt", ".", "use_adam", ":", "\n", "            ", "self", ".", "optimizer", "=", "t", ".", "optim", ".", "Adam", "(", "params", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "optimizer", "=", "t", ".", "optim", ".", "SGD", "(", "params", ",", "momentum", "=", "0.9", ")", "\n", "", "return", "self", ".", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector._suppress": [[55, 71], ["src.nms.non_maximum_suppression", "cupy.asnumpy", "cupy.array"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression.non_maximum_suppression"], ["", "def", "_suppress", "(", "self", ",", "raw_cls_bbox", ",", "raw_prob", ",", "nms_thresh", ",", "score_thresh", ")", ":", "\n", "# bbox = list()", "\n", "# score = list()", "\n", "        ", "mask", "=", "raw_prob", ">", "score_thresh", "\n", "bbox", "=", "raw_cls_bbox", "[", "mask", "]", "\n", "scores", "=", "raw_prob", "[", "mask", "]", "\n", "keep", "=", "non_maximum_suppression", "(", "\n", "cp", ".", "array", "(", "bbox", ")", ",", "nms_thresh", ",", "scores", ")", "\n", "keep", "=", "cp", ".", "asnumpy", "(", "keep", ")", "\n", "bbox", "=", "bbox", "[", "keep", "]", "\n", "scores", "=", "scores", "[", "keep", "]", "\n", "#         bbox.append(cls_bbox_l[keep])", "\n", "#         score.append(prob_l[keep])", "\n", "#         bbox = np.concatenate(bbox, axis=0).astype(np.float32)", "\n", "#         score = np.concatenate(score, axis=0).astype(np.float32)", "\n", "return", "bbox", ",", "scores", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.predict": [[72, 93], ["head_detector.Head_Detector.forward", "src.array_tool.totensor", "src.array_tool.tonumpy", "x.size", "roi[].clamp", "roi[].clamp", "src.array_tool.tonumpy", "numpy.squeeze", "head_detector.Head_Detector._suppress", "torch.nn.functional.softmax", "src.array_tool.tovariable"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.RegionProposalNetwork.forward", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.totensor", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector._suppress", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable"], ["", "def", "predict", "(", "self", ",", "x", ",", "x2", ",", "scale", "=", "1.", ",", "mode", "=", "'evaluate'", ",", "thresh", "=", "0.01", ")", ":", "\n", "\n", "        ", "if", "mode", "==", "'evaluate'", ":", "\n", "            ", "nms_thresh", "=", "0.3", "\n", "score_thresh", "=", "thresh", "\n", "", "elif", "mode", "==", "'visualize'", ":", "\n", "            ", "nms_thresh", "=", "0.3", "\n", "score_thresh", "=", "thresh", "\n", "\n", "", "_", ",", "_", ",", "rois", ",", "rois_scores", ",", "_", "=", "self", ".", "forward", "(", "x", ",", "x2", ",", "scale", "=", "scale", ")", "\n", "roi", "=", "at", ".", "totensor", "(", "rois", ")", "\n", "probabilities", "=", "at", ".", "tonumpy", "(", "F", ".", "softmax", "(", "at", ".", "tovariable", "(", "rois_scores", ")", ",", "dim", "=", "0", ")", ")", "\n", "# probabilities = at.tonumpy(F.softmax(at.tovariable(rois_scores)))", "\n", "_", ",", "_", ",", "H", ",", "W", "=", "x", ".", "size", "(", ")", "\n", "size", "=", "(", "H", ",", "W", ")", "\n", "roi", "[", ":", ",", "0", ":", ":", "2", "]", "=", "(", "roi", "[", ":", ",", "0", ":", ":", "2", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "size", "[", "0", "]", ")", "\n", "roi", "[", ":", ",", "1", ":", ":", "2", "]", "=", "(", "roi", "[", ":", ",", "1", ":", ":", "2", "]", ")", ".", "clamp", "(", "min", "=", "0", ",", "max", "=", "size", "[", "1", "]", ")", "\n", "roi_raw", "=", "at", ".", "tonumpy", "(", "roi", ")", "\n", "probabilities", "=", "np", ".", "squeeze", "(", "probabilities", ")", "\n", "bbox", ",", "score", "=", "self", ".", "_suppress", "(", "roi_raw", ",", "probabilities", ",", "nms_thresh", ",", "score_thresh", ")", "\n", "return", "bbox", ",", "score", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_detector.Head_Detector.scale_lr": [[94, 98], ["None"], "methods", ["None"], ["", "def", "scale_lr", "(", "self", ",", "decay", "=", "0.1", ")", ":", "\n", "        ", "for", "param_group", "in", "self", ".", "optimizer", ".", "param_groups", ":", "\n", "            ", "param_group", "[", "'lr'", "]", "*=", "decay", "\n", "", "return", "self", ".", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.__init__": [[197, 204], ["visdom.Visdom"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "env", "=", "'default'", ",", "**", "kwargs", ")", ":", "\n", "        ", "self", ".", "vis", "=", "visdom", ".", "Visdom", "(", "env", "=", "env", ",", "**", "kwargs", ")", "\n", "self", ".", "_vis_kw", "=", "kwargs", "\n", "\n", "# e.g.\uff08\u2019loss',23\uff09 the 23th value of loss", "\n", "self", ".", "index", "=", "{", "}", "\n", "self", ".", "log_text", "=", "''", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.reinit": [[205, 211], ["visdom.Visdom"], "methods", ["None"], ["", "def", "reinit", "(", "self", ",", "env", "=", "'default'", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        change the config of visdom\n        \"\"\"", "\n", "self", ".", "vis", "=", "visdom", ".", "Visdom", "(", "env", "=", "env", ",", "**", "kwargs", ")", "\n", "return", "self", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.plot_many": [[212, 220], ["d.items", "vis_tool.Visualizer.plot"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.plot"], ["", "def", "plot_many", "(", "self", ",", "d", ")", ":", "\n", "        ", "\"\"\"\n        plot multi values\n        @params d: dict (name,value) i.e. ('loss',0.11)\n        \"\"\"", "\n", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", ":", "\n", "            ", "if", "v", "is", "not", "None", ":", "\n", "                ", "self", ".", "plot", "(", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.img_many": [[221, 224], ["d.items", "vis_tool.Visualizer.img"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.img"], ["", "", "", "def", "img_many", "(", "self", ",", "d", ")", ":", "\n", "        ", "for", "k", ",", "v", "in", "d", ".", "items", "(", ")", ":", "\n", "            ", "self", ".", "img", "(", "k", ",", "v", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.plot": [[225, 237], ["vis_tool.Visualizer.index.get", "vis_tool.Visualizer.vis.line", "numpy.array", "numpy.array", "dict"], "methods", ["None"], ["", "", "def", "plot", "(", "self", ",", "name", ",", "y", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        self.plot('loss',1.00)\n        \"\"\"", "\n", "x", "=", "self", ".", "index", ".", "get", "(", "name", ",", "0", ")", "\n", "self", ".", "vis", ".", "line", "(", "Y", "=", "np", ".", "array", "(", "[", "y", "]", ")", ",", "X", "=", "np", ".", "array", "(", "[", "x", "]", ")", ",", "\n", "win", "=", "name", ",", "\n", "opts", "=", "dict", "(", "title", "=", "name", ")", ",", "\n", "update", "=", "None", "if", "x", "==", "0", "else", "'append'", ",", "\n", "**", "kwargs", "\n", ")", "\n", "self", ".", "index", "[", "name", "]", "=", "x", "+", "1", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.img": [[238, 250], ["vis_tool.Visualizer.vis.images", "torch.Tensor().cpu().numpy", "dict", "torch.Tensor().cpu", "torch.Tensor"], "methods", ["None"], ["", "def", "img", "(", "self", ",", "name", ",", "img_", ",", "**", "kwargs", ")", ":", "\n", "        ", "\"\"\"\n        self.img('input_img',t.Tensor(64,64))\n        self.img('input_imgs',t.Tensor(3,64,64))\n        self.img('input_imgs',t.Tensor(100,1,64,64))\n        self.img('input_imgs',t.Tensor(100,3,64,64),nrows=10)\n        \uff01\uff01\uff01don\u2018t ~~self.img('input_imgs',t.Tensor(100,64,64),nrows=10)~~\uff01\uff01\uff01\n        \"\"\"", "\n", "self", ".", "vis", ".", "images", "(", "t", ".", "Tensor", "(", "img_", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ",", "\n", "win", "=", "name", ",", "\n", "opts", "=", "dict", "(", "title", "=", "name", ")", ",", "\n", "**", "kwargs", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.log": [[252, 260], ["vis_tool.Visualizer.vis.text", "time.strftime"], "methods", ["None"], ["", "def", "log", "(", "self", ",", "info", ",", "win", "=", "'log_text'", ")", ":", "\n", "        ", "\"\"\"\n        self.log({'loss':1,'lr':0.0001})\n        \"\"\"", "\n", "self", ".", "log_text", "+=", "(", "'[{time}] {info} <br>'", ".", "format", "(", "\n", "time", "=", "time", ".", "strftime", "(", "'%m%d_%H%M%S'", ")", ",", "info", "=", "info", ")", ")", "\n", "self", ".", "vis", ".", "text", "(", "self", ".", "log_text", ",", "win", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.__getattr__": [[261, 263], ["getattr"], "methods", ["None"], ["", "def", "__getattr__", "(", "self", ",", "name", ")", ":", "\n", "        ", "return", "getattr", "(", "self", ".", "vis", ",", "name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.state_dict": [[264, 270], ["None"], "methods", ["None"], ["", "def", "state_dict", "(", "self", ")", ":", "\n", "        ", "return", "{", "\n", "'index'", ":", "self", ".", "index", ",", "\n", "'vis_kw'", ":", "self", ".", "_vis_kw", ",", "\n", "'log_text'", ":", "self", ".", "log_text", ",", "\n", "'env'", ":", "self", ".", "vis", ".", "env", "\n", "}", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.Visualizer.load_state_dict": [[272, 277], ["visdom.Visdom", "d.get", "d.get", "dict", "d.get", "vis_tool.Visualizer.d.get"], "methods", ["None"], ["", "def", "load_state_dict", "(", "self", ",", "d", ")", ":", "\n", "        ", "self", ".", "vis", "=", "visdom", ".", "Visdom", "(", "env", "=", "d", ".", "get", "(", "'env'", ",", "self", ".", "vis", ".", "env", ")", ",", "**", "(", "self", ".", "d", ".", "get", "(", "'vis_kw'", ")", ")", ")", "\n", "self", ".", "log_text", "=", "d", ".", "get", "(", "'log_text'", ",", "''", ")", "\n", "self", ".", "index", "=", "d", ".", "get", "(", "'index'", ",", "dict", "(", ")", ")", "\n", "return", "self", "\n", "", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.vis_image": [[42, 65], ["img.transpose.transpose", "fig.add_subplot.imshow", "matplotlib.pyplot.figure", "plot.figure.add_subplot", "img.transpose.astype"], "function", ["None"], ["def", "vis_image", "(", "img", ",", "ax", "=", "None", ")", ":", "\n", "    ", "\"\"\"Visualize a color image.\n\n    Args:\n        img (~numpy.ndarray): An array of shape :math:`(3, height, width)`.\n            This is in RGB format and the range of its value is\n            :math:`[0, 255]`.\n        ax (matplotlib.axes.Axis): The visualization is displayed on this\n            axis. If this is :obj:`None` (default), a new axis is created.\n\n    Returns:\n        ~matploblib.axes.Axes:\n        Returns the Axes object with the plot for further tweaking.\n\n    \"\"\"", "\n", "\n", "if", "ax", "is", "None", ":", "\n", "        ", "fig", "=", "plot", ".", "figure", "(", ")", "\n", "ax", "=", "fig", ".", "add_subplot", "(", "1", ",", "1", ",", "1", ")", "\n", "# CHW -> HWC", "\n", "", "img", "=", "img", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "ax", ".", "imshow", "(", "img", ".", "astype", "(", "np", ".", "uint8", ")", ")", "\n", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.vis_bbox": [[66, 82], ["vis_tool.vis_image", "enumerate", "len", "vis_image.add_patch", "matplotlib.pyplot.Rectangle"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.vis_image"], ["", "def", "vis_bbox", "(", "img", ",", "bbox", ")", ":", "\n", "# Returns newly instantiated matplotlib.axes.Axes object if ax is None", "\n", "    ", "ax", "=", "vis_image", "(", "img", ",", "ax", "=", "None", ")", "\n", "\n", "# If there is no bounding box to display, visualize the image and exit.", "\n", "if", "len", "(", "bbox", ")", "==", "0", ":", "\n", "        ", "return", "ax", "\n", "\n", "", "for", "i", ",", "bb", "in", "enumerate", "(", "bbox", ")", ":", "\n", "        ", "xy", "=", "(", "bb", "[", "1", "]", ",", "bb", "[", "0", "]", ")", "\n", "height", "=", "bb", "[", "2", "]", "-", "bb", "[", "0", "]", "\n", "width", "=", "bb", "[", "3", "]", "-", "bb", "[", "1", "]", "\n", "ax", ".", "add_patch", "(", "plot", ".", "Rectangle", "(", "\n", "xy", ",", "width", ",", "height", ",", "fill", "=", "False", ",", "edgecolor", "=", "'red'", ",", "linewidth", "=", "2", ")", ")", "\n", "\n", "", "return", "ax", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.fig2data": [[151, 170], ["fig.canvas.draw", "fig.canvas.get_width_height", "numpy.fromstring", "numpy.roll", "np.roll.reshape", "fig.canvas.tostring_argb"], "function", ["None"], ["", "def", "fig2data", "(", "fig", ")", ":", "\n", "    ", "\"\"\"\n    brief Convert a Matplotlib figure to a 4D numpy array with RGBA \n    channels and return it\n\n    @param fig\uff1a a matplotlib figure\n    @return a numpy 3D array of RGBA values\n    \"\"\"", "\n", "# draw the renderer", "\n", "fig", ".", "canvas", ".", "draw", "(", ")", "\n", "\n", "# Get the RGBA buffer from the figure", "\n", "w", ",", "h", "=", "fig", ".", "canvas", ".", "get_width_height", "(", ")", "\n", "buf", "=", "np", ".", "fromstring", "(", "fig", ".", "canvas", ".", "tostring_argb", "(", ")", ",", "dtype", "=", "np", ".", "uint8", ")", "\n", "buf", ".", "shape", "=", "(", "w", ",", "h", ",", "4", ")", "\n", "\n", "# canvas.tostring_argb give pixmap in ARGB mode. Roll the ALPHA channel to have it in RGBA mode", "\n", "buf", "=", "np", ".", "roll", "(", "buf", ",", "3", ",", "axis", "=", "2", ")", "\n", "return", "buf", ".", "reshape", "(", "h", ",", "w", ",", "4", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.fig4vis": [[172, 181], ["fig.get_figure", "fig2data().astype", "matplotlib.pyplot.close", "img_data[].transpose", "vis_tool.fig2data"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.fig2data"], ["", "def", "fig4vis", "(", "fig", ")", ":", "\n", "    ", "\"\"\"\n    convert figure to ndarray\n    \"\"\"", "\n", "ax", "=", "fig", ".", "get_figure", "(", ")", "\n", "img_data", "=", "fig2data", "(", "ax", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "plot", ".", "close", "(", ")", "\n", "# HWC->CHW", "\n", "return", "img_data", "[", ":", ",", ":", ",", ":", "3", "]", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "/", "255.", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.visdom_bbox": [[183, 187], ["vis_tool.vis_bbox", "vis_tool.fig4vis"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.vis_bbox", "home.repos.pwc.inspect_result.pl-share_mpsn.src.vis_tool.fig4vis"], ["", "def", "visdom_bbox", "(", "img", ",", "rois", ")", ":", "\n", "    ", "fig", "=", "vis_bbox", "(", "img", ",", "rois", ")", "\n", "data", "=", "fig4vis", "(", "fig", ")", "\n", "return", "data", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.mpsn.__init__": [[56, 71], ["head_backbone.right_res", "head_backbone.left_res", "src.region_proposal_network.RegionProposalNetwork", "src.head_detector.Head_Detector.__init__"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.right_res", "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.left_res", "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__"], ["def", "__init__", "(", "self", ",", "ratios", "=", "[", "0.5", ",", "1", ",", "2", "]", ",", "anchor_scales", "=", "[", "8", ",", "16", ",", "32", "]", ")", ":", "\n", "\n", "        ", "addnet", "=", "right_res", "(", ")", "\n", "left_vgg", "=", "left_res", "(", ")", "\n", "in_channel", "=", "256", "#mob : 96    res : 256", "\n", "rpn", "=", "RegionProposalNetwork", "(", "\n", "in_channel", ",", "256", ",", "\n", "ratios", "=", "ratios", ",", "\n", "anchor_scales", "=", "anchor_scales", ",", "\n", "feat_stride", "=", "self", ".", "feat_stride", "\n", ")", "\n", "super", "(", "mpsn", ",", "self", ")", ".", "__init__", "(", "\n", "addnet", ",", "\n", "left_vgg", ",", "\n", "rpn", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.left_mob": [[9, 14], ["torchvision.models.mobilenet_v2", "torch.nn.Sequential", "list"], "function", ["None"], ["def", "left_mob", "(", ")", ":", "\n", "#model = mobilenet_v2(pretrained=False,norm_layer=nn.InstanceNorm2d)", "\n", "    ", "model", "=", "mobilenet_v2", "(", "pretrained", "=", "True", ")", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "0", ":", "14", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.right_mob": [[16, 21], ["torchvision.models.mobilenet_v2", "torch.nn.Sequential", "list"], "function", ["None"], ["", "def", "right_mob", "(", ")", ":", "\n", "#model = mobilenet_v2(pretrained=False,norm_layer=nn.InstanceNorm2d)", "\n", "    ", "model", "=", "mobilenet_v2", "(", "pretrained", "=", "True", ")", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "0", ":", "14", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.left_vgg16": [[22, 27], ["torchvision.models.vgg16", "torch.nn.Sequential", "list"], "function", ["None"], ["", "def", "left_vgg16", "(", ")", ":", "\n", "    ", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "#model.load_state_dict(t.load(opt.caffe_pretrain_path))", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "0", ":", "30", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.right_vgg16": [[28, 33], ["torchvision.models.vgg16", "torch.nn.Sequential", "list"], "function", ["None"], ["", "def", "right_vgg16", "(", ")", ":", "\n", "    ", "model", "=", "vgg16", "(", "pretrained", "=", "False", ")", "\n", "#model.load_state_dict(t.load(opt.caffe_pretrain_path))", "\n", "features", "=", "list", "(", "model", ".", "features", ")", "[", "0", ":", "30", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.left_res": [[34, 42], ["torchvision.models.resnet18", "torch.nn.Sequential"], "function", ["None"], ["", "def", "left_res", "(", ")", ":", "\n", "    ", "'''\n    brainwash: resnet(pretrained=False,norm_layer=nn.InstanceNorm2d)\n    restaurant: renet18(pretrained=True)\n    '''", "\n", "model", "=", "resnet18", "(", "pretrained", "=", "True", ")", "\n", "features", "=", "[", "model", ".", "conv1", ",", "model", ".", "bn1", ",", "model", ".", "relu", ",", "model", ".", "maxpool", ",", "model", ".", "layer1", ",", "model", ".", "layer2", ",", "model", ".", "layer3", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.head_backbone.right_res": [[43, 47], ["torchvision.models.resnet18", "torch.nn.Sequential"], "function", ["None"], ["", "def", "right_res", "(", ")", ":", "\n", "    ", "model", "=", "resnet18", "(", "pretrained", "=", "True", ")", "\n", "features", "=", "[", "model", ".", "conv1", ",", "model", ".", "bn1", ",", "model", ".", "relu", ",", "model", ".", "maxpool", ",", "model", ".", "layer1", ",", "model", ".", "layer2", ",", "model", ".", "layer3", "]", "\n", "return", "nn", ".", "Sequential", "(", "*", "features", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.RegionProposalNetwork.__init__": [[24, 45], ["dict", "torch.nn.Module.__init__", "src.bbox_tools.generate_anchor_base", "src.creator_tool.ProposalCreator", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "torch.nn.Conv2d", "region_proposal_network.normal_init", "region_proposal_network.normal_init", "region_proposal_network.normal_init", "region_proposal_network.normal_init", "region_proposal_network.normal_init"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__", "home.repos.pwc.inspect_result.pl-share_mpsn.src.bbox_tools.generate_anchor_base", "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.normal_init", "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.normal_init", "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.normal_init", "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.normal_init", "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.normal_init"], ["def", "__init__", "(", "\n", "self", ",", "in_channels", "=", "512", ",", "mid_channels", "=", "512", ",", "ratios", "=", "[", "0.5", ",", "1", ",", "2", "]", ",", "\n", "anchor_scales", "=", "[", "8", ",", "16", ",", "32", "]", ",", "feat_stride", "=", "16", ",", "\n", "proposal_creator_params", "=", "dict", "(", ")", ",", "\n", ")", ":", "\n", "        ", "super", "(", "RegionProposalNetwork", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "anchor_base", "=", "generate_anchor_base", "(", "\n", "anchor_scales", "=", "anchor_scales", ",", "ratios", "=", "ratios", ")", "\n", "self", ".", "feat_stride", "=", "feat_stride", "\n", "self", ".", "proposal_layer", "=", "ProposalCreator", "(", "self", ",", "**", "proposal_creator_params", ")", "\n", "n_anchor", "=", "self", ".", "anchor_base", ".", "shape", "[", "0", "]", "\n", "self", ".", "conv1", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "mid_channels", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv2", "=", "nn", ".", "Conv2d", "(", "mid_channels", ",", "128", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "conv3", "=", "nn", ".", "Conv2d", "(", "128", ",", "64", ",", "3", ",", "1", ",", "1", ")", "\n", "self", ".", "score", "=", "nn", ".", "Conv2d", "(", "64", ",", "n_anchor", "*", "2", ",", "1", ",", "1", ",", "0", ")", "\n", "self", ".", "loc", "=", "nn", ".", "Conv2d", "(", "64", ",", "n_anchor", "*", "4", ",", "1", ",", "1", ",", "0", ")", "\n", "normal_init", "(", "self", ".", "conv1", ",", "0", ",", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv2", ",", "0", ",", "0.01", ")", "\n", "normal_init", "(", "self", ".", "conv3", ",", "0", ",", "0.01", ")", "\n", "normal_init", "(", "self", ".", "score", ",", "0", ",", "0.01", ")", "\n", "normal_init", "(", "self", ".", "loc", ",", "0", ",", "0.01", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.RegionProposalNetwork.forward": [[46, 89], ["x.size", "region_proposal_network._enumerate_shifted_anchor", "torch.nn.functional.relu", "torch.nn.functional.relu", "torch.nn.functional.relu", "region_proposal_network.RegionProposalNetwork.loc", "rpn_locs.permute().contiguous().view.permute().contiguous().view.permute().contiguous().view", "region_proposal_network.RegionProposalNetwork.score", "rpn_scores.view.view.permute().contiguous", "[].contiguous", "rpn_fg_scores.view.view.view", "rpn_scores.view.view.view", "region_proposal_network.RegionProposalNetwork.proposal_layer", "numpy.array", "region_proposal_network.RegionProposalNetwork.conv1", "region_proposal_network.RegionProposalNetwork.conv2", "region_proposal_network.RegionProposalNetwork.conv3", "rpn_locs[].cpu().data.numpy", "rpn_fg_scores[].cpu().data.numpy", "rpn_locs.permute().contiguous().view.permute().contiguous().view.permute().contiguous", "rpn_scores.view.view.permute", "rpn_scores.view.view.view", "rpn_locs.permute().contiguous().view.permute().contiguous().view.permute", "rpn_locs[].cpu", "rpn_fg_scores[].cpu"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network._enumerate_shifted_anchor"], ["", "def", "forward", "(", "self", ",", "x", ",", "img_size", ",", "scale", "=", "1.", ")", ":", "\n", "        ", "\"\"\" Forward pass function to the network. \n\n        Args: \n            x : feature size\n            img_size: size of the image.\n\n        Returns: \n            rpn_locs: the scales and translates of the anchors.\n            rpn_scores: probability score of the anchors \n            rois: mapped region proposal from the scales and the translates. \n            rois_scores: scores of the rois. \n            anchors: anchors that are used to compute the proposals.\n        \"\"\"", "\n", "n", ",", "_", ",", "hh", ",", "ww", "=", "x", ".", "size", "(", ")", "\n", "# Generate anchors throughout the image.", "\n", "anchor", "=", "_enumerate_shifted_anchor", "(", "\n", "np", ".", "array", "(", "self", ".", "anchor_base", ")", ",", "\n", "self", ".", "feat_stride", ",", "hh", ",", "ww", ")", "\n", "n_anchor", "=", "anchor", ".", "shape", "[", "0", "]", "//", "(", "hh", "*", "ww", ")", "\n", "h", "=", "F", ".", "relu", "(", "self", ".", "conv1", "(", "x", ")", ")", "# (1,512,30,40)", "\n", "h", "=", "F", ".", "relu", "(", "self", ".", "conv2", "(", "h", ")", ")", "\n", "h", "=", "F", ".", "relu", "(", "self", ".", "conv3", "(", "h", ")", ")", "\n", "rpn_locs", "=", "self", ".", "loc", "(", "h", ")", "# (1,12,30,40)", "\n", "rpn_locs", "=", "rpn_locs", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", ".", "view", "(", "n", ",", "-", "1", ",", "4", ")", "# (1,3600,4)", "\n", "rpn_scores", "=", "self", ".", "score", "(", "h", ")", "# (1,6,30,40)", "\n", "\n", "rpn_scores", "=", "rpn_scores", ".", "permute", "(", "0", ",", "2", ",", "3", ",", "1", ")", ".", "contiguous", "(", ")", "\n", "rpn_fg_scores", "=", "rpn_scores", ".", "view", "(", "n", ",", "hh", ",", "ww", ",", "n_anchor", ",", "2", ")", "[", ":", ",", ":", ",", ":", ",", ":", ",", "1", "]", ".", "contiguous", "(", ")", "# (1,30,40,3)", "\n", "rpn_fg_scores", "=", "rpn_fg_scores", ".", "view", "(", "n", ",", "-", "1", ")", "# (1,3600)", "\n", "rpn_scores", "=", "rpn_scores", ".", "view", "(", "n", ",", "-", "1", ",", "2", ")", "# (1,3600,2)", "\n", "\n", "\n", "# Map the scales and translates to the rois.", "\n", "rois", ",", "rois_scores", "=", "self", ".", "proposal_layer", "(", "\n", "rpn_locs", "[", "0", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "rpn_fg_scores", "[", "0", "]", ".", "cpu", "(", ")", ".", "data", ".", "numpy", "(", ")", ",", "\n", "anchor", ",", "img_size", ",", "\n", "scale", "=", "scale", "\n", ")", "\n", "\n", "return", "rpn_locs", ",", "rpn_scores", ",", "rois", ",", "rois_scores", ",", "anchor", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network._enumerate_shifted_anchor": [[90, 103], ["numpy.arange", "numpy.arange", "numpy.meshgrid", "numpy.stack", "anchor.reshape().astype.reshape().astype", "anchor_base.reshape", "np.stack.reshape().transpose", "np.arange.ravel", "np.arange.ravel", "np.arange.ravel", "np.arange.ravel", "anchor.reshape().astype.reshape", "np.stack.reshape"], "function", ["None"], ["", "", "def", "_enumerate_shifted_anchor", "(", "anchor_base", ",", "feat_stride", ",", "height", ",", "width", ")", ":", "\n", "    ", "shift_y", "=", "np", ".", "arange", "(", "0", ",", "height", "*", "feat_stride", ",", "feat_stride", ")", "\n", "shift_x", "=", "np", ".", "arange", "(", "0", ",", "width", "*", "feat_stride", ",", "feat_stride", ")", "\n", "shift_x", ",", "shift_y", "=", "np", ".", "meshgrid", "(", "shift_x", ",", "shift_y", ")", "\n", "shift", "=", "np", ".", "stack", "(", "(", "shift_y", ".", "ravel", "(", ")", ",", "shift_x", ".", "ravel", "(", ")", ",", "\n", "shift_y", ".", "ravel", "(", ")", ",", "shift_x", ".", "ravel", "(", ")", ")", ",", "axis", "=", "1", ")", "\n", "\n", "A", "=", "anchor_base", ".", "shape", "[", "0", "]", "\n", "K", "=", "shift", ".", "shape", "[", "0", "]", "\n", "anchor", "=", "anchor_base", ".", "reshape", "(", "(", "1", ",", "A", ",", "4", ")", ")", "+", "shift", ".", "reshape", "(", "(", "1", ",", "K", ",", "4", ")", ")", ".", "transpose", "(", "(", "1", ",", "0", ",", "2", ")", ")", "\n", "anchor", "=", "anchor", ".", "reshape", "(", "(", "K", "*", "A", ",", "4", ")", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "return", "anchor", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.region_proposal_network.normal_init": [[105, 111], ["m.weight.data.normal_().fmod_().mul_().add_", "m.weight.data.normal_", "m.bias.data.zero_", "m.weight.data.normal_().fmod_().mul_", "m.weight.data.normal_().fmod_", "m.weight.data.normal_"], "function", ["None"], ["", "def", "normal_init", "(", "m", ",", "mean", ",", "stddev", ",", "truncated", "=", "False", ")", ":", "\n", "    ", "if", "truncated", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", ")", ".", "fmod_", "(", "2", ")", ".", "mul_", "(", "stddev", ")", ".", "add_", "(", "mean", ")", "# not a perfect approximation", "\n", "", "else", ":", "\n", "        ", "m", ".", "weight", ".", "data", ".", "normal_", "(", "mean", ",", "stddev", ")", "\n", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.data.__init__": [[16, 20], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "d", ")", ":", "\n", "        ", "self", ".", "path", "=", "d", "[", "'img_path'", "]", "\n", "self", ".", "n_boxs", "=", "d", "[", "'number'", "]", "\n", "self", ".", "bboxs", "=", "d", "[", "'coordinates'", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_file_id": [[21, 23], ["os.path.splitext", "os.path.basename"], "function", ["None"], ["", "", "def", "get_file_id", "(", "filepath", ")", ":", "\n", "    ", "return", "os", ".", "path", ".", "splitext", "(", "os", ".", "path", ".", "basename", "(", "filepath", ")", ")", "[", "0", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.generate_gt_name": [[24, 26], ["str().zfill", "str"], "function", ["None"], ["", "def", "generate_gt_name", "(", "id", ")", ":", "\n", "    ", "return", "'gt_img_'", "+", "str", "(", "id", ")", ".", "zfill", "(", "6", ")", "+", "'.jpg'", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.generate_img_name": [[27, 29], ["str().zfill", "str"], "function", ["None"], ["", "def", "generate_img_name", "(", "id", ")", ":", "\n", "    ", "return", "'img_'", "+", "str", "(", "id", ")", ".", "zfill", "(", "6", ")", "+", "'.jpg'", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bounding_box_on_image_array": [[30, 37], ["PIL.fromarray().convert", "utils.draw_bounding_box_on_image", "numpy.copyto", "numpy.array", "PIL.fromarray", "numpy.uint8"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bounding_box_on_image"], ["", "def", "draw_bounding_box_on_image_array", "(", "image", ",", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", ",", "color", "=", "'red'", ",", "thickness", "=", "4", ",", "\n", "use_normalized_coordinates", "=", "False", ")", ":", "\n", "    ", "image_pil", "=", "Image", ".", "fromarray", "(", "np", ".", "uint8", "(", "image", ")", ")", ".", "convert", "(", "'RGB'", ")", "\n", "#image_pil = image", "\n", "draw_bounding_box_on_image", "(", "image_pil", ",", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", ",", "color", ",", "\n", "thickness", ",", "use_normalized_coordinates", ")", "\n", "np", ".", "copyto", "(", "image", ",", "np", ".", "array", "(", "image_pil", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bounding_box_on_image": [[39, 49], ["PIL.Draw", "ImageDraw.Draw.line"], "function", ["None"], ["", "def", "draw_bounding_box_on_image", "(", "image", ",", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", ",", "color", "=", "'red'", ",", "thickness", "=", "4", ",", "\n", "use_normalized_coordinates", "=", "False", ")", ":", "\n", "    ", "draw", "=", "ImageDraw", ".", "Draw", "(", "image", ")", "\n", "im_width", ",", "im_height", "=", "image", ".", "size", "\n", "if", "use_normalized_coordinates", ":", "\n", "        ", "(", "left", ",", "right", ",", "top", ",", "bottom", ")", "=", "(", "xmin", "*", "im_width", ",", "xmax", "*", "im_width", ",", "ymin", "*", "im_height", ",", "ymax", "*", "im_height", ")", "\n", "", "else", ":", "\n", "        ", "(", "left", ",", "right", ",", "top", ",", "bottom", ")", "=", "(", "xmin", ",", "xmax", ",", "ymin", ",", "ymax", ")", "\n", "", "draw", ".", "line", "(", "[", "(", "left", ",", "top", ")", ",", "(", "left", ",", "bottom", ")", ",", "(", "right", ",", "bottom", ")", ",", "\n", "(", "right", ",", "top", ")", ",", "(", "left", ",", "top", ")", "]", ",", "width", "=", "thickness", ",", "fill", "=", "color", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.adaptive_kernal": [[51, 64], ["range", "dist.sort", "numpy.mean", "numpy.floor", "point.reshape.reshape", "dist.append", "numpy.asarray", "numpy.sqrt", "numpy.dot"], "function", ["None"], ["", "def", "adaptive_kernal", "(", "point_i", ",", "locations", ")", ":", "\n", "    ", "dist", "=", "[", "]", "\n", "for", "j", "in", "range", "(", "locations", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "point", "=", "locations", "[", "j", ",", ":", "]", "\n", "point", "=", "point", ".", "reshape", "(", "point", ".", "shape", "[", "0", "]", ",", "1", ")", "\n", "diff", "=", "point_i", "-", "point", "\n", "dist", ".", "append", "(", "np", ".", "sqrt", "(", "np", ".", "dot", "(", "diff", ".", "T", ",", "diff", ")", ")", ")", "\n", "", "dist", ".", "sort", "(", ")", "\n", "nn_dists", "=", "dist", "[", "1", ":", "K", "+", "1", "]", "\n", "# print nn_dists", "\n", "dist_i", "=", "np", ".", "mean", "(", "np", ".", "asarray", "(", "nn_dists", ")", ")", "\n", "fz", "=", "np", ".", "floor", "(", "0.3", "*", "dist_i", ")", "\n", "return", "fz", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.save_json": [[65, 68], ["open", "json.dump"], "function", ["None"], ["", "def", "save_json", "(", "data", ",", "filepath", ")", ":", "\n", "    ", "with", "open", "(", "filepath", ",", "'w'", ")", "as", "fp", ":", "\n", "        ", "json", ".", "dump", "(", "data", ",", "fp", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.save_pickle": [[69, 73], ["fp.close", "open", "pickle.dump"], "function", ["None"], ["", "", "def", "save_pickle", "(", "data", ",", "filepath", ")", ":", "\n", "    ", "with", "open", "(", "filepath", ",", "'wb'", ")", "as", "fp", ":", "\n", "        ", "pickle", ".", "dump", "(", "data", ",", "fp", ")", "\n", "", "fp", ".", "close", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.load_annotations": [[74, 78], ["open", "pickle.load"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.None.train_or.Head_Detector_Trainer.load"], ["", "def", "load_annotations", "(", "path", ")", ":", "\n", "    ", "with", "open", "(", "path", ",", "'rb'", ")", "as", "fp", ":", "\n", "        ", "dict", "=", "pickle", ".", "load", "(", "fp", ")", "\n", "", "return", "dict", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_ground_truth_name": [[79, 82], ["utils.get_file_id", "get_file_id.split"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_file_id"], ["", "def", "get_ground_truth_name", "(", "file_path", ")", ":", "\n", "    ", "file_id", "=", "get_file_id", "(", "file_path", ")", "\n", "return", "'ground_truth_'", "+", "file_id", ".", "split", "(", "'_'", ")", "[", "1", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.data_line_parser": [[84, 116], ["line.decode.decode", "line.decode.split", "line.decode.split", "bbox_coordinates_raw.replace.replace", "bbox_coordinates_raw.replace.replace", "bbox_coordinates_raw.replace.replace", "bbox_coordinates_raw.replace.replace", "bbox_coordinates_raw.replace.split", "numpy.zeros", "range", "os.path.join", "os.path.join", "float", "len", "len", "img_path.replace", "os.path.join", "img_path.replace", "os.path.join", "img_path.replace", "img_path.replace", "int"], "function", ["None"], ["", "def", "data_line_parser", "(", "line", ",", "dataset", ")", ":", "\n", "    ", "line", "=", "line", ".", "decode", "(", ")", "\n", "if", "\":\"", "not", "in", "line", ":", "\n", "        ", "img_path", ",", "_", "=", "line", ".", "split", "(", "\";\"", ")", "\n", "if", "dataset", "==", "'brainwash'", ":", "\n", "            ", "src_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "img_path", ".", "replace", "(", "'\"'", ",", "''", ")", ")", "\n", "", "elif", "dataset", "==", "'RGBdata'", ":", "\n", "            ", "src_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "img_path", ".", "replace", "(", "'\"'", ",", "''", ")", ")", "\n", "", "num_coordinates", "=", "0", "\n", "coordinates", "=", "[", "]", "\n", "return", "{", "'img_path'", ":", "src_path", ",", "'number'", ":", "num_coordinates", ",", "'coordinates'", ":", "coordinates", "}", "\n", "", "else", ":", "\n", "        ", "img_path", ",", "bbox_coordinates_raw", "=", "line", ".", "split", "(", "\":\"", ")", "\n", "if", "dataset", "==", "'brainwash'", ":", "\n", "            ", "src_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "brainwash_dataset_root_path", ",", "img_path", ".", "replace", "(", "'\"'", ",", "''", ")", ")", "\n", "", "elif", "dataset", "==", "'RGBdata'", ":", "\n", "            ", "src_path", "=", "os", ".", "path", ".", "join", "(", "opt", ".", "RGBdata_dataset_root_path", ",", "img_path", ".", "replace", "(", "'\"'", ",", "''", ")", ")", "\n", "", "bbox_coordinates_raw", "=", "bbox_coordinates_raw", ".", "replace", "(", "\"(\"", ",", "\"\"", ")", "\n", "bbox_coordinates_raw", "=", "bbox_coordinates_raw", ".", "replace", "(", "\"),\"", ",", "\",\"", ")", "\n", "bbox_coordinates_raw", "=", "bbox_coordinates_raw", ".", "replace", "(", "\").\"", ",", "\"\"", ")", "\n", "bbox_coordinates_raw", "=", "bbox_coordinates_raw", ".", "replace", "(", "\");\"", ",", "\"\"", ")", "\n", "bbox_coordinates_str", "=", "bbox_coordinates_raw", ".", "split", "(", "\", \"", ")", "\n", "coordinates_list", "=", "[", "float", "(", "i", ")", "for", "i", "in", "bbox_coordinates_str", "]", "\n", "num_coordinates", "=", "len", "(", "coordinates_list", ")", "/", "4", "\n", "coordinates", "=", "np", ".", "zeros", "(", "shape", "=", "(", "int", "(", "num_coordinates", ")", ",", "4", ")", ",", "dtype", "=", "np", ".", "float", ")", "\n", "entry_idx", "=", "0", "\n", "for", "i", "in", "range", "(", "0", ",", "len", "(", "coordinates_list", ")", ",", "4", ")", ":", "\n", "            ", "coord", "=", "coordinates_list", "[", "i", ":", "i", "+", "4", "]", "\n", "coord", "=", "[", "coord", "[", "1", "]", ",", "coord", "[", "0", "]", ",", "coord", "[", "3", "]", ",", "coord", "[", "2", "]", "]", "\n", "coordinates", "[", "entry_idx", ",", ":", "]", "=", "coord", "\n", "entry_idx", "+=", "1", "\n", "", "", "return", "{", "'img_path'", ":", "src_path", ",", "'number'", ":", "num_coordinates", ",", "'coordinates'", ":", "coordinates", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.get_phase_data_list": [[117, 137], ["open", "fp.readlines", "utils.data_line_parser", "utils.data", "data_list.append"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.data_line_parser"], ["", "def", "get_phase_data_list", "(", "data_list_path", ",", "dataset", ")", ":", "\n", "    ", "\"\"\"Return a list of data object.\n    data object: path, n_boxs, bboxs\n    \n    Args: data_list_path: list of filenames and groundtruth information available\n            in the brainwash dataset. \n\n    Returns: A list of data objects. Where the length of the list is equal \n            to the number of images contained in the split of the dataset.\n    \"\"\"", "\n", "data_list", "=", "[", "]", "\n", "import", "os", "\n", "#os.chdir('/mnt/disk1/liup/FCHD-Fully-Convolutional-Head-Detector-master/')", "\n", "with", "open", "(", "data_list_path", ",", "'rb'", ")", "as", "fp", ":", "\n", "        ", "for", "line", "in", "fp", ".", "readlines", "(", ")", ":", "\n", "            ", "d", "=", "data_line_parser", "(", "line", ",", "dataset", ")", "\n", "if", "d", "[", "'number'", "]", "!=", "0", ":", "\n", "                ", "d_object", "=", "data", "(", "d", ")", "\n", "data_list", ".", "append", "(", "d_object", ")", "\n", "", "", "", "return", "data_list", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.check_loaded_data": [[164, 180], ["cv2.imread", "numpy.copy", "range", "cv2.imshow", "cv2.waitKey", "cv2.destroyAllWindows", "numpy.asarray", "utils.draw_bounding_box_on_image_array"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bounding_box_on_image_array"], ["", "def", "check_loaded_data", "(", "d", ")", ":", "\n", "    ", "path", "=", "d", ".", "path", "\n", "n_boxs", "=", "d", ".", "n_boxs", "\n", "bboxs", "=", "d", ".", "bboxs", "\n", "\n", "# print bboxs.shape", "\n", "image", "=", "cv2", ".", "imread", "(", "path", ")", "\n", "image_np", "=", "np", ".", "copy", "(", "np", ".", "asarray", "(", "image", ",", "dtype", "=", "np", ".", "uint8", ")", ")", "\n", "for", "i", "in", "range", "(", "n_boxs", ")", ":", "\n", "        ", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", "=", "bboxs", "[", "i", ",", ":", "]", "\n", "#xmin, ymin, xmax, ymax = bboxs[i,:]", "\n", "draw_bounding_box_on_image_array", "(", "image_np", ",", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", ")", "\n", "#plt.imshow(image_np)", "\n", "", "cv2", ".", "imshow", "(", "'image'", ",", "image_np", ")", "\n", "cv2", ".", "waitKey", "(", "0", ")", "\n", "cv2", ".", "destroyAllWindows", "(", ")", "\n", "#plt.show()", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.vis_anchors": [[182, 190], ["img_tensor.cpu.cpu", "img_tensor.cpu.data.numpy", "img_tensor.data.numpy.copy", "numpy.squeeze", "utils.draw_bboxs", "matplotlib.imshow", "matplotlib.show"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bboxs"], ["", "def", "vis_anchors", "(", "img_tensor", ",", "anchor", ")", ":", "\n", "    ", "img_tensor", "=", "img_tensor", ".", "cpu", "(", ")", "\n", "img", "=", "img_tensor", ".", "data", ".", "numpy", "(", ")", "\n", "img_cp", "=", "img", ".", "copy", "(", ")", "\n", "img_cp", "=", "np", ".", "squeeze", "(", "img_cp", ")", "\n", "img_cp", "=", "draw_bboxs", "(", "img_cp", ",", "anchor", ",", "anchor", ".", "shape", "[", "0", "]", ")", "\n", "plt", ".", "imshow", "(", "img_cp", ")", "\n", "plt", ".", "show", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bboxs": [[191, 199], ["numpy.copy", "range", "image.transpose.transpose", "numpy.asarray", "utils.draw_bounding_box_on_image_array"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.utils.draw_bounding_box_on_image_array"], ["", "def", "draw_bboxs", "(", "image", ",", "bboxs", ",", "n_boxs", ",", "is_transpose", "=", "True", ")", ":", "\n", "    ", "if", "is_transpose", ":", "\n", "        ", "image", "=", "image", ".", "transpose", "(", "(", "1", ",", "2", ",", "0", ")", ")", "\n", "", "image_np", "=", "np", ".", "copy", "(", "np", ".", "asarray", "(", "image", ",", "dtype", "=", "np", ".", "uint8", ")", ")", "\n", "for", "i", "in", "range", "(", "n_boxs", ")", ":", "\n", "        ", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", "=", "bboxs", "[", "i", ",", ":", "]", "\n", "draw_bounding_box_on_image_array", "(", "image_np", ",", "ymin", ",", "xmin", ",", "ymax", ",", "xmax", ")", "\n", "", "return", "image_np", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy": [[8, 15], ["isinstance", "isinstance", "isinstance", "data.data.cpu().numpy", "array_tool.tonumpy", "data.data.cpu"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tonumpy"], ["def", "tonumpy", "(", "data", ")", ":", "\n", "    ", "if", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "data", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "_C", ".", "_TensorBase", ")", ":", "\n", "        ", "return", "data", ".", "data", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "autograd", ".", "Variable", ")", ":", "\n", "        ", "return", "tonumpy", "(", "data", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.totensor": [[17, 27], ["isinstance", "isinstance", "isinstance", "torch.from_numpy", "tensor.cuda.cuda"], "function", ["None"], ["", "", "def", "totensor", "(", "data", ",", "cuda", "=", "True", ")", ":", "\n", "    ", "if", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "tensor", "=", "t", ".", "from_numpy", "(", "data", ")", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "_C", ".", "_TensorBase", ")", ":", "\n", "        ", "tensor", "=", "data", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "autograd", ".", "Variable", ")", ":", "\n", "        ", "tensor", "=", "data", ".", "data", "\n", "", "if", "cuda", ":", "\n", "        ", "tensor", "=", "tensor", ".", "cuda", "(", ")", "\n", "", "return", "tensor", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable": [[29, 38], ["isinstance", "isinstance", "isinstance", "array_tool.tovariable", "torch.autograd.Variable", "ValueError", "array_tool.totensor", "type"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.tovariable", "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.totensor"], ["", "def", "tovariable", "(", "data", ")", ":", "\n", "    ", "if", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "tovariable", "(", "totensor", "(", "data", ")", ")", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "_C", ".", "_TensorBase", ")", ":", "\n", "        ", "return", "t", ".", "autograd", ".", "Variable", "(", "data", ")", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "autograd", ".", "Variable", ")", ":", "\n", "        ", "return", "data", "\n", "", "else", ":", "\n", "        ", "raise", "ValueError", "(", "\"UnKnow data type: %s, input should be {np.ndarray,Tensor,Variable}\"", "%", "type", "(", "data", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.src.array_tool.scalar": [[40, 47], ["isinstance", "isinstance", "isinstance", "data.reshape", "data.view", "data.data.view"], "function", ["None"], ["", "", "def", "scalar", "(", "data", ")", ":", "\n", "    ", "if", "isinstance", "(", "data", ",", "np", ".", "ndarray", ")", ":", "\n", "        ", "return", "data", ".", "reshape", "(", "1", ")", "[", "0", "]", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "_C", ".", "_TensorBase", ")", ":", "\n", "        ", "return", "data", ".", "view", "(", "1", ")", "[", "0", "]", "\n", "", "if", "isinstance", "(", "data", ",", "t", ".", "autograd", ".", "Variable", ")", ":", "\n", "        ", "return", "data", ".", "data", ".", "view", "(", "1", ")", "[", "0", "]", "\n", "", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression._load_kernel": [[18, 24], ["cupy._util.memoize", "cupy.cuda.runtime.free", "isinstance", "cupy.cuda.compile_with_cache", "cp.cuda.compile_with_cache.get_function"], "function", ["None"], ["", "@", "cp", ".", "_util", ".", "memoize", "(", "for_each_device", "=", "True", ")", "\n", "def", "_load_kernel", "(", "kernel_name", ",", "code", ",", "options", "=", "(", ")", ")", ":", "\n", "    ", "cp", ".", "cuda", ".", "runtime", ".", "free", "(", "0", ")", "\n", "assert", "isinstance", "(", "options", ",", "tuple", ")", "\n", "kernel_code", "=", "cp", ".", "cuda", ".", "compile_with_cache", "(", "code", ",", "options", "=", "options", ")", "\n", "return", "kernel_code", ".", "get_function", "(", "kernel_name", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression.non_maximum_suppression": [[26, 73], ["non_maximum_suppression._non_maximum_suppression_gpu"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression._non_maximum_suppression_gpu"], ["", "def", "non_maximum_suppression", "(", "bbox", ",", "thresh", ",", "score", "=", "None", ",", "\n", "limit", "=", "None", ")", ":", "\n", "    ", "\"\"\"Suppress bounding boxes according to their IoUs.\n\n    This method checks each bounding box sequentially and selects the bounding\n    box if the Intersection over Unions (IoUs) between the bounding box and the\n    previously selected bounding boxes is less than :obj:`thresh`. This method\n    is mainly used as postprocessing of object detection.\n    The bounding boxes are selected from ones with higher scores.\n    If :obj:`score` is not provided as an argument, the bounding box\n    is ordered by its index in ascending order.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    :obj:`score` is a float array of shape :math:`(R,)`. Each score indicates\n    confidence of prediction.\n\n    This function accepts both :obj:`numpy.ndarray` and :obj:`cupy.ndarray` as\n    an input. Please note that both :obj:`bbox` and :obj:`score` need to be\n    the same type.\n    The type of the output is the same as the input.\n\n    Args:\n        bbox (array): Bounding boxes to be transformed. The shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n        thresh (float): Threshold of IoUs.\n        score (array): An array of confidences whose shape is :math:`(R,)`.\n        limit (int): The upper bound of the number of the output bounding\n            boxes. If it is not specified, this method selects as many\n            bounding boxes as possible.\n\n    Returns:\n        array:\n        An array with indices of bounding boxes that are selected. \\\n        They are sorted by the scores of bounding boxes in descending \\\n        order. \\\n        The shape of this array is :math:`(K,)` and its dtype is\\\n        :obj:`numpy.int32`. Note that :math:`K \\\\leq R`.\n\n    \"\"\"", "\n", "\n", "return", "_non_maximum_suppression_gpu", "(", "bbox", ",", "thresh", ",", "score", ",", "limit", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression._non_maximum_suppression_gpu": [[75, 94], ["non_maximum_suppression._call_nms_kernel", "cupy.asnumpy", "len", "cupy.zeros", "[].astype", "cupy.arange", "score.argsort"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression._call_nms_kernel"], ["", "def", "_non_maximum_suppression_gpu", "(", "bbox", ",", "thresh", ",", "score", "=", "None", ",", "limit", "=", "None", ")", ":", "\n", "    ", "if", "len", "(", "bbox", ")", "==", "0", ":", "\n", "        ", "return", "cp", ".", "zeros", "(", "(", "0", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "", "n_bbox", "=", "bbox", ".", "shape", "[", "0", "]", "\n", "\n", "if", "score", "is", "not", "None", ":", "\n", "        ", "order", "=", "score", ".", "argsort", "(", ")", "[", ":", ":", "-", "1", "]", ".", "astype", "(", "np", ".", "int32", ")", "\n", "", "else", ":", "\n", "        ", "order", "=", "cp", ".", "arange", "(", "n_bbox", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "\n", "", "sorted_bbox", "=", "bbox", "[", "order", ",", ":", "]", "\n", "selec", ",", "n_selec", "=", "_call_nms_kernel", "(", "\n", "sorted_bbox", ",", "thresh", ")", "\n", "selec", "=", "selec", "[", ":", "n_selec", "]", "\n", "selec", "=", "order", "[", "selec", "]", "\n", "if", "limit", "is", "not", "None", ":", "\n", "        ", "selec", "=", "selec", "[", ":", "limit", "]", "\n", "", "return", "cp", ".", "asnumpy", "(", "selec", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression._call_nms_kernel": [[161, 181], ["numpy.ceil().astype", "cupy.zeros", "cupy.ascontiguousarray", "non_maximum_suppression._load_kernel", "_load_kernel.", "cp.zeros.get", "_nms_gpu_post", "numpy.ceil", "cupy.int32", "cupy.float32"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.nms.non_maximum_suppression._load_kernel", "home.repos.pwc.inspect_result.pl-share_mpsn.nms._nms_gpu_post_py._nms_gpu_post"], ["def", "_call_nms_kernel", "(", "bbox", ",", "thresh", ")", ":", "\n", "# PyTorch does not support unsigned long Tensor.", "\n", "# Doesn't matter,since it returns ndarray finally.", "\n", "# So I'll keep it unmodified.", "\n", "    ", "n_bbox", "=", "bbox", ".", "shape", "[", "0", "]", "\n", "threads_per_block", "=", "64", "\n", "col_blocks", "=", "np", ".", "ceil", "(", "n_bbox", "/", "threads_per_block", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "blocks", "=", "(", "col_blocks", ",", "col_blocks", ",", "1", ")", "\n", "threads", "=", "(", "threads_per_block", ",", "1", ",", "1", ")", "\n", "\n", "mask_dev", "=", "cp", ".", "zeros", "(", "(", "n_bbox", "*", "col_blocks", ",", ")", ",", "dtype", "=", "np", ".", "uint64", ")", "\n", "bbox", "=", "cp", ".", "ascontiguousarray", "(", "bbox", ",", "dtype", "=", "np", ".", "float32", ")", "# NOTE: \u53d8\u6210\u8fde\u7eed\u7684", "\n", "kern", "=", "_load_kernel", "(", "'nms_kernel'", ",", "_nms_gpu_code", ")", "\n", "kern", "(", "blocks", ",", "threads", ",", "args", "=", "(", "cp", ".", "int32", "(", "n_bbox", ")", ",", "cp", ".", "float32", "(", "thresh", ")", ",", "\n", "bbox", ",", "mask_dev", ")", ")", "\n", "\n", "mask_host", "=", "mask_dev", ".", "get", "(", ")", "\n", "selection", ",", "n_selec", "=", "_nms_gpu_post", "(", "\n", "mask_host", ",", "n_bbox", ",", "threads_per_block", ",", "col_blocks", ")", "\n", "return", "selection", ",", "n_selec", "\n", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.nms._nms_gpu_post_py._nms_gpu_post": [[4, 26], ["numpy.array", "numpy.zeros", "numpy.zeros", "range", "range"], "function", ["None"], ["def", "_nms_gpu_post", "(", "mask", ",", "\n", "n_bbox", ",", "\n", "threads_per_block", ",", "\n", "col_blocks", "\n", ")", ":", "\n", "    ", "n_selection", "=", "0", "\n", "one_ull", "=", "np", ".", "array", "(", "[", "1", "]", ",", "dtype", "=", "np", ".", "uint64", ")", "\n", "selection", "=", "np", ".", "zeros", "(", "(", "n_bbox", ",", ")", ",", "dtype", "=", "np", ".", "int32", ")", "\n", "remv", "=", "np", ".", "zeros", "(", "(", "col_blocks", ",", ")", ",", "dtype", "=", "np", ".", "uint64", ")", "\n", "\n", "for", "i", "in", "range", "(", "n_bbox", ")", ":", "\n", "        ", "nblock", "=", "i", "//", "threads_per_block", "\n", "inblock", "=", "i", "%", "threads_per_block", "\n", "\n", "if", "not", "(", "remv", "[", "nblock", "]", "&", "one_ull", "<<", "inblock", ")", ":", "\n", "            ", "selection", "[", "n_selection", "]", "=", "i", "\n", "n_selection", "+=", "1", "\n", "\n", "index", "=", "i", "*", "col_blocks", "\n", "for", "j", "in", "range", "(", "nblock", ",", "col_blocks", ")", ":", "\n", "                ", "remv", "[", "j", "]", "|=", "mask", "[", "index", "+", "j", "]", "\n", "", "", "", "return", "selection", ",", "n_selection", "\n", "", ""]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Transform.__init__": [[60, 63], ["None"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "min_size", "=", "600", ",", "max_size", "=", "1000", ")", ":", "\n", "        ", "self", ".", "min_size", "=", "min_size", "\n", "self", ".", "max_size", "=", "max_size", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Transform.__call__": [[64, 74], ["dataset.preprocess", "util.resize_bbox"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.preprocess", "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.resize_bbox"], ["", "def", "__call__", "(", "self", ",", "in_data", ")", ":", "\n", "        ", "img", ",", "bboxs", ",", "_", "=", "in_data", "\n", "_", ",", "H", ",", "W", "=", "img", ".", "shape", "\n", "img", "=", "preprocess", "(", "img", ",", "self", ".", "min_size", ",", "self", ".", "max_size", ")", "\n", "_", ",", "o_H", ",", "o_W", "=", "img", ".", "shape", "\n", "scale", "=", "o_H", "/", "H", "\n", "bboxs", "=", "util", ".", "resize_bbox", "(", "bboxs", ",", "(", "H", ",", "W", ")", ",", "(", "o_H", ",", "o_W", ")", ")", "\n", "\n", "\n", "return", "img", ",", "bboxs", ",", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.HeadDataset.__init__": [[78, 80], ["None"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "dl", ")", ":", "\n", "        ", "self", ".", "datalist", "=", "dl", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.HeadDataset.get_example": [[81, 101], ["dataset.HeadDataset.read_image", "dataset.HeadDataset.read_image"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.util.read_image", "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.read_image"], ["", "def", "get_example", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\" Read the image from the image path, specific to the idx given \n            argument to the function. \n\n        Args: \n            idx: idx of the image to be read. \n        \n        Returns: \n            img: image after reading from the path\n            bboxs: ground-truth corresponding to the image. \n            n_bboxs: number of heads in the image. \n        \"\"\"", "\n", "data_obj", "=", "self", ".", "datalist", "[", "idx", "]", "\n", "img_path", "=", "data_obj", ".", "path", "\n", "n_boxs", "=", "data_obj", ".", "n_boxs", "\n", "bboxs", "=", "data_obj", ".", "bboxs", "\n", "img", "=", "self", ".", "read_image", "(", "img_path", ")", "\n", "img2_path", "=", "img_path", "[", "0", ":", "-", "4", "]", "+", "'-diff'", "+", "img_path", "[", "-", "4", ":", "]", "\n", "img2", "=", "self", ".", "read_image", "(", "img2_path", ")", "\n", "return", "img_path", ",", "img", ",", "img2", ",", "bboxs", ",", "n_boxs", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.HeadDataset.read_image": [[102, 111], ["PIL.Image.open", "PIL.Image.open.convert", "numpy.asarray", "numpy.asarray.transpose"], "methods", ["None"], ["", "def", "read_image", "(", "self", ",", "path", ",", "dtype", "=", "np", ".", "float32", ")", ":", "\n", "        ", "f", "=", "Image", ".", "open", "(", "path", ")", "\n", "\n", "# Convert to RGB", "\n", "f", ".", "convert", "(", "'RGB'", ")", "\n", "# Convert to a numpy array", "\n", "img", "=", "np", ".", "asarray", "(", "f", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "# Transpose the final image array i.e. C, H, W", "\n", "return", "img", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__init__": [[130, 134], ["dataset.HeadDataset", "dataset.Transform"], "methods", ["None"], ["def", "__init__", "(", "self", ",", "datalist", ")", ":", "\n", "        ", "self", ".", "datalist", "=", "datalist", "\n", "self", ".", "db", "=", "HeadDataset", "(", "datalist", ")", "\n", "self", ".", "tsf", "=", "Transform", "(", "opt", ".", "min_size", ",", "opt", ".", "max_size", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__getitem__": [[135, 152], ["dataset.Dataset.db.get_example", "dataset.Dataset.tsf", "dataset.Dataset.tsf", "img.copy", "img2.copy", "bboxs.copy"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.HeadDataset.get_example"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "\"\"\"__getitem__ function that reads the input image corresponding \n            to a idx. After reading the input image, transforms the image\n            with the pre-defined set of operations. \n\n        Args: \n            idx: Index of the image to be read from the data list. \n        \n        Returns: \n            img: The transform (normalized) image. \n            bboxs: The ground-truth annotations. \n            scale: scale used to rescale the image.\n        \"\"\"", "\n", "img_path", ",", "ori_img", ",", "img2", ",", "bboxs", ",", "n_boxs", "=", "self", ".", "db", ".", "get_example", "(", "idx", ")", "\n", "img", ",", "bboxs", ",", "scale", "=", "self", ".", "tsf", "(", "(", "ori_img", ",", "bboxs", ",", "n_boxs", ")", ")", "\n", "img2", ",", "bboxs2", ",", "scale2", "=", "self", ".", "tsf", "(", "(", "img2", ",", "bboxs", ",", "n_boxs", ")", ")", "\n", "return", "img_path", ",", "img", ".", "copy", "(", ")", ",", "img2", ".", "copy", "(", ")", ",", "bboxs", ".", "copy", "(", ")", ",", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__call__": [[154, 157], ["dataset.Dataset.db.get_example"], "methods", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.HeadDataset.get_example"], ["", "def", "__call__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "img_path", ",", "ori_img", ",", "img2", ",", "bboxs", ",", "n_boxs", "=", "self", ".", "db", ".", "get_example", "(", "idx", ")", "\n", "return", "img_path", ",", "ori_img", ",", "img2", ",", "bboxs", ",", "n_boxs", "\n", "", "def", "__len__", "(", "self", ")", ":", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.Dataset.__len__": [[157, 159], ["len"], "methods", ["None"], ["", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "datalist", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.inverse_normalize": [[10, 15], ["numpy.array().reshape", "numpy.array"], "function", ["None"], ["def", "inverse_normalize", "(", "img", ")", ":", "\n", "    ", "if", "opt", ".", "caffe_pretrain", ":", "\n", "        ", "img", "=", "img", "+", "(", "np", ".", "array", "(", "[", "122.7717", ",", "115.9465", ",", "102.9801", "]", ")", ".", "reshape", "(", "3", ",", "1", ",", "1", ")", ")", "\n", "return", "img", "[", ":", ":", "-", "1", ",", ":", ",", ":", "]", "\n", "", "return", "(", "img", "*", "0.225", "+", "0.45", ")", ".", "clip", "(", "min", "=", "0", ",", "max", "=", "1", ")", "*", "255", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.pytorch_normalze": [[16, 21], ["torchvision.transforms.Normalize", "tvtsf.Normalize.", "normalize.numpy", "torch.from_numpy"], "function", ["None"], ["", "def", "pytorch_normalze", "(", "img", ")", ":", "\n", "    ", "normalize", "=", "tvtsf", ".", "Normalize", "(", "mean", "=", "[", "0.485", ",", "0.456", ",", "0.406", "]", ",", "\n", "std", "=", "[", "0.229", ",", "0.224", ",", "0.225", "]", ")", "\n", "img", "=", "normalize", "(", "t", ".", "from_numpy", "(", "img", ")", ")", "\n", "return", "img", ".", "numpy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.caffe_normalize": [[22, 28], ["numpy.array().reshape", "numpy.array"], "function", ["None"], ["", "def", "caffe_normalize", "(", "img", ")", ":", "\n", "    ", "img", "=", "img", "[", "[", "2", ",", "1", ",", "0", "]", ",", ":", ",", ":", "]", "# RGB-BGR", "\n", "img", "=", "img", "*", "255", "\n", "mean", "=", "np", ".", "array", "(", "[", "122.7717", ",", "115.9465", ",", "102.9801", "]", ")", ".", "reshape", "(", "3", ",", "1", ",", "1", ")", "\n", "img", "=", "(", "img", "-", "mean", ")", ".", "astype", "(", "np", ".", "float32", ",", "copy", "=", "True", ")", "\n", "return", "img", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.dataset.preprocess": [[29, 56], ["min", "skimage.transform.resize", "normalize", "min", "max"], "function", ["None"], ["", "def", "preprocess", "(", "img", ",", "min_size", "=", "600", ",", "max_size", "=", "1000", ")", ":", "\n", "    ", "\"\"\" Function to preprocess the input image. \n    \n    Scales the input image in such a manner that the shorter side of the \n    image is converted to the size equal to min_size. \n    Also normalizes the input image. \n\n    Args: \n        img: Input image that is to be preprocessed. \n        min_size: size to which the smaller side of the image is to be \n                    converted. \n        max_size: size to which the larger side of the image is to be \n                    converted. \n    \"\"\"", "\n", "C", ",", "H", ",", "W", "=", "img", ".", "shape", "\n", "scale1", "=", "min_size", "/", "min", "(", "H", ",", "W", ")", "\n", "scale2", "=", "max_size", "/", "max", "(", "H", ",", "W", ")", "\n", "scale", "=", "min", "(", "scale1", ",", "scale2", ")", "\n", "img", "=", "img", "/", "255.", "\n", "img", "=", "sktsf", ".", "resize", "(", "img", ",", "(", "C", ",", "H", "*", "scale", ",", "W", "*", "scale", ")", ",", "mode", "=", "'reflect'", ")", "\n", "# both the longer and shorter should be less than", "\n", "# max_size and min_size", "\n", "if", "opt", ".", "caffe_pretrain", ":", "\n", "        ", "normalize", "=", "caffe_normalize", "\n", "", "else", ":", "\n", "        ", "normalize", "=", "pytorch_normalze", "\n", "", "return", "normalize", "(", "img", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.read_image": [[6, 42], ["PIL.Image.open", "numpy.asarray", "hasattr", "f.convert.transpose", "Image.open.convert", "Image.open.convert", "Image.open.close"], "function", ["None"], ["def", "read_image", "(", "path", ",", "dtype", "=", "np", ".", "float32", ",", "color", "=", "True", ")", ":", "\n", "    ", "\"\"\"Read an image from a file.\n\n    This function reads an image from given file. The image is CHW format and\n    the range of its value is :math:`[0, 255]`. If :obj:`color = True`, the\n    order of the channels is RGB.\n\n    Args:\n        path (str): A path of image file.\n        dtype: The type of array. The default value is :obj:`~numpy.float32`.\n        color (bool): This option determines the number of channels.\n            If :obj:`True`, the number of channels is three. In this case,\n            the order of the channels is RGB. This is the default behaviour.\n            If :obj:`False`, this function returns a grayscale image.\n\n    Returns:\n        ~numpy.ndarray: An image.\n    \"\"\"", "\n", "\n", "f", "=", "Image", ".", "open", "(", "path", ")", "\n", "try", ":", "\n", "        ", "if", "color", ":", "\n", "            ", "img", "=", "f", ".", "convert", "(", "'RGB'", ")", "\n", "", "else", ":", "\n", "            ", "img", "=", "f", ".", "convert", "(", "'P'", ")", "\n", "", "img", "=", "np", ".", "asarray", "(", "img", ",", "dtype", "=", "dtype", ")", "\n", "", "finally", ":", "\n", "        ", "if", "hasattr", "(", "f", ",", "'close'", ")", ":", "\n", "            ", "f", ".", "close", "(", ")", "\n", "\n", "", "", "if", "img", ".", "ndim", "==", "2", ":", "\n", "# reshape (H, W) -> (1, H, W)", "\n", "        ", "return", "img", "[", "np", ".", "newaxis", "]", "\n", "", "else", ":", "\n", "# transpose (H, W, C) -> (C, H, W)", "\n", "        ", "return", "img", ".", "transpose", "(", "(", "2", ",", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.resize_bbox": [[44, 75], ["bbox.copy.copy", "float", "float"], "function", ["None"], ["", "", "def", "resize_bbox", "(", "bbox", ",", "in_size", ",", "out_size", ")", ":", "\n", "    ", "\"\"\"Resize bounding boxes according to image resize.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): An array whose shape is :math:`(R, 4)`.\n            :math:`R` is the number of bounding boxes.\n        in_size (tuple): A tuple of length 2. The height and the width\n            of the image before resized.\n        out_size (tuple): A tuple of length 2. The height and the width\n            of the image after resized.\n\n    Returns:\n        ~numpy.ndarray:\n        Bounding boxes rescaled according to the given image shapes.\n\n    \"\"\"", "\n", "bbox", "=", "bbox", ".", "copy", "(", ")", "\n", "y_scale", "=", "float", "(", "out_size", "[", "0", "]", ")", "/", "in_size", "[", "0", "]", "\n", "x_scale", "=", "float", "(", "out_size", "[", "1", "]", ")", "/", "in_size", "[", "1", "]", "\n", "bbox", "[", ":", ",", "0", "]", "=", "y_scale", "*", "bbox", "[", ":", ",", "0", "]", "\n", "bbox", "[", ":", ",", "2", "]", "=", "y_scale", "*", "bbox", "[", ":", ",", "2", "]", "\n", "bbox", "[", ":", ",", "1", "]", "=", "x_scale", "*", "bbox", "[", ":", ",", "1", "]", "\n", "bbox", "[", ":", ",", "3", "]", "=", "x_scale", "*", "bbox", "[", ":", ",", "3", "]", "\n", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.flip_bbox": [[77, 115], ["bbox.copy.copy"], "function", ["None"], ["", "def", "flip_bbox", "(", "bbox", ",", "size", ",", "y_flip", "=", "False", ",", "x_flip", "=", "False", ")", ":", "\n", "    ", "\"\"\"Flip bounding boxes accordingly.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): An array whose shape is :math:`(R, 4)`.\n            :math:`R` is the number of bounding boxes.\n        size (tuple): A tuple of length 2. The height and the width\n            of the image before resized.\n        y_flip (bool): Flip bounding box according to a vertical flip of\n            an image.\n        x_flip (bool): Flip bounding box according to a horizontal flip of\n            an image.\n\n    Returns:\n        ~numpy.ndarray:\n        Bounding boxes flipped according to the given flips.\n\n    \"\"\"", "\n", "H", ",", "W", "=", "size", "\n", "bbox", "=", "bbox", ".", "copy", "(", ")", "\n", "if", "y_flip", ":", "\n", "        ", "y_max", "=", "H", "-", "bbox", "[", ":", ",", "0", "]", "\n", "y_min", "=", "H", "-", "bbox", "[", ":", ",", "2", "]", "\n", "bbox", "[", ":", ",", "0", "]", "=", "y_min", "\n", "bbox", "[", ":", ",", "2", "]", "=", "y_max", "\n", "", "if", "x_flip", ":", "\n", "        ", "x_max", "=", "W", "-", "bbox", "[", ":", ",", "1", "]", "\n", "x_min", "=", "W", "-", "bbox", "[", ":", ",", "3", "]", "\n", "bbox", "[", ":", ",", "1", "]", "=", "x_min", "\n", "bbox", "[", ":", ",", "3", "]", "=", "x_max", "\n", "", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.crop_bbox": [[117, 187], ["util._slice_to_bounds", "util._slice_to_bounds", "numpy.array", "bbox.copy.copy", "numpy.maximum", "numpy.minimum", "numpy.logical_and", "numpy.ones", "numpy.logical_and().all", "numpy.logical_and", "numpy.flatnonzero"], "function", ["home.repos.pwc.inspect_result.pl-share_mpsn.data.util._slice_to_bounds", "home.repos.pwc.inspect_result.pl-share_mpsn.data.util._slice_to_bounds"], ["", "def", "crop_bbox", "(", "\n", "bbox", ",", "y_slice", "=", "None", ",", "x_slice", "=", "None", ",", "\n", "allow_outside_center", "=", "True", ",", "return_param", "=", "False", ")", ":", "\n", "    ", "\"\"\"Translate bounding boxes to fit within the cropped area of an image.\n\n    This method is mainly used together with image cropping.\n    This method translates the coordinates of bounding boxes like\n    :func:`data.util.translate_bbox`. In addition,\n    this function truncates the bounding boxes to fit within the cropped area.\n    If a bounding box does not overlap with the cropped area,\n    this bounding box will be removed.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): Bounding boxes to be transformed. The shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n        y_slice (slice): The slice of y axis.\n        x_slice (slice): The slice of x axis.\n        allow_outside_center (bool): If this argument is :obj:`False`,\n            bounding boxes whose centers are outside of the cropped area\n            are removed. The default value is :obj:`True`.\n        return_param (bool): If :obj:`True`, this function returns\n            indices of kept bounding boxes.\n\n    Returns:\n        ~numpy.ndarray or (~numpy.ndarray, dict):\n\n        If :obj:`return_param = False`, returns an array :obj:`bbox`.\n\n        If :obj:`return_param = True`,\n        returns a tuple whose elements are :obj:`bbox, param`.\n        :obj:`param` is a dictionary of intermediate parameters whose\n        contents are listed below with key, value-type and the description\n        of the value.\n\n        * **index** (*numpy.ndarray*): An array holding indices of used \\\n            bounding boxes.\n\n    \"\"\"", "\n", "\n", "t", ",", "b", "=", "_slice_to_bounds", "(", "y_slice", ")", "\n", "l", ",", "r", "=", "_slice_to_bounds", "(", "x_slice", ")", "\n", "crop_bb", "=", "np", ".", "array", "(", "(", "t", ",", "l", ",", "b", ",", "r", ")", ")", "\n", "\n", "if", "allow_outside_center", ":", "\n", "        ", "mask", "=", "np", ".", "ones", "(", "bbox", ".", "shape", "[", "0", "]", ",", "dtype", "=", "bool", ")", "\n", "", "else", ":", "\n", "        ", "center", "=", "(", "bbox", "[", ":", ",", ":", "2", "]", "+", "bbox", "[", ":", ",", "2", ":", "]", ")", "/", "2", "\n", "mask", "=", "np", ".", "logical_and", "(", "crop_bb", "[", ":", "2", "]", "<=", "center", ",", "center", "<", "crop_bb", "[", "2", ":", "]", ")", ".", "all", "(", "axis", "=", "1", ")", "\n", "\n", "", "bbox", "=", "bbox", ".", "copy", "(", ")", "\n", "bbox", "[", ":", ",", ":", "2", "]", "=", "np", ".", "maximum", "(", "bbox", "[", ":", ",", ":", "2", "]", ",", "crop_bb", "[", ":", "2", "]", ")", "\n", "bbox", "[", ":", ",", "2", ":", "]", "=", "np", ".", "minimum", "(", "bbox", "[", ":", ",", "2", ":", "]", ",", "crop_bb", "[", "2", ":", "]", ")", "\n", "bbox", "[", ":", ",", ":", "2", "]", "-=", "crop_bb", "[", ":", "2", "]", "\n", "bbox", "[", ":", ",", "2", ":", "]", "-=", "crop_bb", "[", ":", "2", "]", "\n", "\n", "mask", "=", "np", ".", "logical_and", "(", "mask", ",", "(", "bbox", "[", ":", ",", ":", "2", "]", "<", "bbox", "[", ":", ",", "2", ":", "]", ")", ".", "all", "(", "axis", "=", "1", ")", ")", "\n", "bbox", "=", "bbox", "[", "mask", "]", "\n", "\n", "if", "return_param", ":", "\n", "        ", "return", "bbox", ",", "{", "'index'", ":", "np", ".", "flatnonzero", "(", "mask", ")", "}", "\n", "", "else", ":", "\n", "        ", "return", "bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util._slice_to_bounds": [[189, 204], ["None"], "function", ["None"], ["", "", "def", "_slice_to_bounds", "(", "slice_", ")", ":", "\n", "    ", "if", "slice_", "is", "None", ":", "\n", "        ", "return", "0", ",", "np", ".", "inf", "\n", "\n", "", "if", "slice_", ".", "start", "is", "None", ":", "\n", "        ", "l", "=", "0", "\n", "", "else", ":", "\n", "        ", "l", "=", "slice_", ".", "start", "\n", "\n", "", "if", "slice_", ".", "stop", "is", "None", ":", "\n", "        ", "u", "=", "np", ".", "inf", "\n", "", "else", ":", "\n", "        ", "u", "=", "slice_", ".", "stop", "\n", "\n", "", "return", "l", ",", "u", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.translate_bbox": [[206, 238], ["bbox.copy"], "function", ["None"], ["", "def", "translate_bbox", "(", "bbox", ",", "y_offset", "=", "0", ",", "x_offset", "=", "0", ")", ":", "\n", "    ", "\"\"\"Translate bounding boxes.\n\n    This method is mainly used together with image transforms, such as padding\n    and cropping, which translates the left top point of the image from\n    coordinate :math:`(0, 0)` to coordinate\n    :math:`(y, x) = (y_{offset}, x_{offset})`.\n\n    The bounding boxes are expected to be packed into a two dimensional\n    tensor of shape :math:`(R, 4)`, where :math:`R` is the number of\n    bounding boxes in the image. The second axis represents attributes of\n    the bounding box. They are :math:`(y_{min}, x_{min}, y_{max}, x_{max})`,\n    where the four attributes are coordinates of the top left and the\n    bottom right vertices.\n\n    Args:\n        bbox (~numpy.ndarray): Bounding boxes to be transformed. The shape is\n            :math:`(R, 4)`. :math:`R` is the number of bounding boxes.\n        y_offset (int or float): The offset along y axis.\n        x_offset (int or float): The offset along x axis.\n\n    Returns:\n        ~numpy.ndarray:\n        Bounding boxes translated according to the given offsets.\n\n    \"\"\"", "\n", "\n", "out_bbox", "=", "bbox", ".", "copy", "(", ")", "\n", "out_bbox", "[", ":", ",", ":", "2", "]", "+=", "(", "y_offset", ",", "x_offset", ")", "\n", "out_bbox", "[", ":", ",", "2", ":", "]", "+=", "(", "y_offset", ",", "x_offset", ")", "\n", "\n", "return", "out_bbox", "\n", "\n"]], "home.repos.pwc.inspect_result.pl-share_mpsn.data.util.random_flip": [[240, 288], ["random.choice", "random.choice", "img.copy.copy"], "function", ["None"], ["", "def", "random_flip", "(", "img", ",", "y_random", "=", "False", ",", "x_random", "=", "False", ",", "\n", "return_param", "=", "False", ",", "copy", "=", "False", ")", ":", "\n", "    ", "\"\"\"Randomly flip an image in vertical or horizontal direction.\n\n    Args:\n        img (~numpy.ndarray): An array that gets flipped. This is in\n            CHW format.\n        y_random (bool): Randomly flip in vertical direction.\n        x_random (bool): Randomly flip in horizontal direction.\n        return_param (bool): Returns information of flip.\n        copy (bool): If False, a view of :obj:`img` will be returned.\n\n    Returns:\n        ~numpy.ndarray or (~numpy.ndarray, dict):\n\n        If :obj:`return_param = False`,\n        returns an array :obj:`out_img` that is the result of flipping.\n\n        If :obj:`return_param = True`,\n        returns a tuple whose elements are :obj:`out_img, param`.\n        :obj:`param` is a dictionary of intermediate parameters whose\n        contents are listed below with key, value-type and the description\n        of the value.\n\n        * **y_flip** (*bool*): Whether the image was flipped in the\\\n            vertical direction or not.\n        * **x_flip** (*bool*): Whether the image was flipped in the\\\n            horizontal direction or not.\n\n    \"\"\"", "\n", "y_flip", ",", "x_flip", "=", "False", ",", "False", "\n", "if", "y_random", ":", "\n", "        ", "y_flip", "=", "random", ".", "choice", "(", "[", "True", ",", "False", "]", ")", "\n", "", "if", "x_random", ":", "\n", "        ", "x_flip", "=", "random", ".", "choice", "(", "[", "True", ",", "False", "]", ")", "\n", "\n", "", "if", "y_flip", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ":", "-", "1", ",", ":", "]", "\n", "", "if", "x_flip", ":", "\n", "        ", "img", "=", "img", "[", ":", ",", ":", ",", ":", ":", "-", "1", "]", "\n", "\n", "", "if", "copy", ":", "\n", "        ", "img", "=", "img", ".", "copy", "(", ")", "\n", "\n", "", "if", "return_param", ":", "\n", "        ", "return", "img", ",", "{", "'y_flip'", ":", "y_flip", ",", "'x_flip'", ":", "x_flip", "}", "\n", "", "else", ":", "\n", "        ", "return", "img", "\n", "", "", ""]]}