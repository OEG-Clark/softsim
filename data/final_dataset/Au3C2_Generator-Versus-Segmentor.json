{"home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.None.main.train_net": [[19, 119], ["utils.dataset.BrainDataset", "torch.utils.data.DataLoader", "len", "logger.info", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.StepLR", "nn.CrossEntropyLoss", "nn.CrossEntropyLoss", "nn.MSELoss", "range", "reconstucter.parameters", "segmenter.parameters", "reconstucter.train", "segmenter.train", "logger.info", "tqdm.tqdm", "logger.info", "optim.lr_scheduler.StepLR.step", "optim.lr_scheduler.StepLR.step", "int", "int", "enumerate", "img.unsqueeze().to.unsqueeze().to", "seg_tumor.to.to", "brain_mask.to.to", "torch.zeros_like().to", "optim.Adam.zero_grad", "reconstucter", "segmenter", "loss_recer.backward", "optim.Adam.step", "optim.Adam.zero_grad", "segmenter", "torch.abs().squeeze", "torch.where", "loss_seg1.backward", "optim.Adam.step", "tqdm.tqdm.set_postfix_str", "torch.save", "logger.info", "torch.ones_like", "img[].mean", "nn.CrossEntropyLoss.", "reconstucter.detach", "[].view", "img.unsqueeze().to.unsqueeze", "torch.zeros_like", "torch.abs", "torch.ones_like", "loss_seg1.item", "loss_seg2.item", "loss_mse.item", "loss_var.item", "segmenter.state_dict", "optim.Adam.state_dict", "optim.lr_scheduler.StepLR.state_dict", "reconstucter.state_dict", "optim.Adam.state_dict", "optim.lr_scheduler.StepLR.state_dict", "nn.MSELoss.", "nn.MSELoss.squeeze", "reconstucter.detach", "torch.abs().squeeze.view().max", "nn.CrossEntropyLoss.", "nn.MSELoss.", "torch.abs().squeeze.view", "brain_avg.to"], "function", ["None"], ["def", "train_net", "(", "reconstucter", ",", "\n", "segmenter", ",", "\n", "device", ",", "\n", "epochs", "=", "5", ",", "\n", "batch_size", "=", "1", ",", "\n", "lr", "=", "0.001", ",", "\n", "percent", "=", "0.1", ",", "\n", "save_cp", "=", "True", ",", ")", ":", "\n", "\n", "    ", "train_set", "=", "BrainDataset", "(", "train_list", ",", "percent", "=", "percent", ")", "\n", "train_loader", "=", "DataLoader", "(", "train_set", ",", "batch_size", "=", "batch_size", ",", "shuffle", "=", "True", ",", "num_workers", "=", "8", ",", "pin_memory", "=", "True", ",", "drop_last", "=", "True", ")", "\n", "n_train", "=", "len", "(", "train_loader", ")", "\n", "\n", "logger", ".", "info", "(", "f'''Starting training:\n        File names        main.py\n        Starting time     {starttime_r}\n        Epochs:           {epochs}\n        Batch size:       {batch_size}\n        Learning rate:    {lr}\n        \u03bb:                {lambd}\n        Training size:    {n_train}\n        Checkpoints:      {save_cp}\n        Device:           {device.type}\n        Training percent: {percent}\n    '''", ")", "\n", "\n", "optimizer_R", "=", "optim", ".", "Adam", "(", "reconstucter", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "betas", "=", "(", "0.9", ",", "0.99", ")", ")", "\n", "optimizer_S", "=", "optim", ".", "Adam", "(", "segmenter", ".", "parameters", "(", ")", ",", "lr", "=", "lr", ",", "betas", "=", "(", "0.9", ",", "0.99", ")", ")", "\n", "scheduler_R", "=", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "optimizer_R", ",", "step_size", "=", "int", "(", "0.8", "*", "epochs", ")", ")", "\n", "scheduler_S", "=", "optim", ".", "lr_scheduler", ".", "StepLR", "(", "optimizer_S", ",", "step_size", "=", "int", "(", "0.8", "*", "epochs", ")", ")", "\n", "\n", "ce_loss", "=", "nn", ".", "CrossEntropyLoss", "(", ")", "\n", "ce_loss1", "=", "nn", ".", "CrossEntropyLoss", "(", "reduce", "=", "False", ")", "\n", "mse_loss", "=", "nn", ".", "MSELoss", "(", "reduce", "=", "False", ")", "\n", "for", "epoch", "in", "range", "(", "epochs", ")", ":", "\n", "        ", "reconstucter", ".", "train", "(", ")", "\n", "segmenter", ".", "train", "(", ")", "\n", "loss1", "=", "0", "\n", "loss2", "=", "0", "\n", "loss3", "=", "0", "\n", "loss4", "=", "0", "\n", "logger", ".", "info", "(", "\"Epoch {:2d} learning(S) rate: {:.2e}, learning(R) rate: {:.2e}, \"", ".", "format", "(", "epoch", ",", "optimizer_S", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", ",", "optimizer_R", ".", "param_groups", "[", "0", "]", "[", "'lr'", "]", ")", ")", "\n", "bar", "=", "tqdm", "(", "enumerate", "(", "train_loader", ")", ",", "total", "=", "n_train", ",", "desc", "=", "f'Epoch {epoch+1}/{epochs}'", ",", "unit", "=", "'batch'", ",", "ncols", "=", "120", ",", "ascii", "=", "True", ")", "\n", "for", "i", ",", "data", "in", "bar", ":", "\n", "            ", "[", "img", ",", "seg", ",", "seg_tumor", ",", "brain_mask", ",", "_", ",", "_", "]", "=", "data", "[", "0", ":", "6", "]", "\n", "img", "=", "img", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "seg_tumor", "=", "seg_tumor", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "brain_mask", "=", "brain_mask", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "\n", "seg_no_tumor", "=", "torch", ".", "zeros_like", "(", "seg", ")", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "torch", ".", "long", ")", "\n", "seg_tumor_neg", "=", "1", "-", "seg_tumor", "\n", "mask", "=", "(", "seg_tumor_neg", "*", "brain_mask", ")", ".", "unsqueeze", "(", "dim", "=", "1", ")", "\n", "brain_avg", "=", "torch", ".", "ones_like", "(", "img", ")", "*", "img", "[", "mask", "==", "1", "]", ".", "mean", "(", ")", "\n", "\n", "#train step 1:", "\n", "optimizer_R", ".", "zero_grad", "(", ")", "\n", "img_pred", "=", "reconstucter", "(", "img", ")", "\n", "seg_pred", "=", "segmenter", "(", "img_pred", ")", "\n", "\n", "loss_seg2", "=", "lambd", "[", "1", "]", "*", "ce_loss", "(", "seg_pred", ",", "seg_no_tumor", ")", "\n", "loss_mse", "=", "lambd", "[", "2", "]", "*", "(", "mse_loss", "(", "img_pred", ",", "img", ")", "*", "seg_tumor_neg", ")", ".", "mean", "(", ")", "\n", "loss_var", "=", "lambd", "[", "3", "]", "*", "(", "mse_loss", "(", "img_pred", ",", "brain_avg", ".", "to", "(", "dtype", "=", "torch", ".", "float", ")", ")", ".", "squeeze", "(", "1", ")", "*", "seg_tumor", ")", ".", "mean", "(", ")", "\n", "loss_recer", "=", "loss_seg2", "+", "loss_mse", "+", "loss_var", "\n", "loss_recer", ".", "backward", "(", ")", "\n", "optimizer_R", ".", "step", "(", ")", "\n", "\n", "# train step 2:", "\n", "optimizer_S", ".", "zero_grad", "(", ")", "\n", "seg_pred", "=", "segmenter", "(", "img_pred", ".", "detach", "(", ")", ")", "\n", "\n", "# Calculate weight", "\n", "diff", "=", "torch", ".", "abs", "(", "img_pred", ".", "detach", "(", ")", "-", "img", ")", ".", "squeeze", "(", ")", "\n", "diff_norm", "=", "diff", "/", "diff", ".", "view", "(", "batch_size", ",", "-", "1", ")", ".", "max", "(", "dim", "=", "-", "1", ")", "[", "0", "]", ".", "view", "(", "batch_size", ",", "1", ",", "1", ")", "\n", "weightt", "=", "1", "-", "diff_norm", "\n", "weightt", "=", "torch", ".", "where", "(", "weightt", "<", "0.1", ",", "0.1", "*", "torch", ".", "ones_like", "(", "weightt", ")", ",", "weightt", ")", "\n", "\n", "loss_seg1", "=", "lambd", "[", "0", "]", "*", "(", "ce_loss1", "(", "seg_pred", ",", "seg_tumor", ")", "*", "weightt", ")", ".", "mean", "(", ")", "\n", "loss_seg1", ".", "backward", "(", ")", "\n", "optimizer_S", ".", "step", "(", ")", "\n", "\n", "bar", ".", "set_postfix_str", "(", "'loss(batch):{:>.2e},{:>.2e},{:>.2e},{:.2e}'", ".", "format", "(", "loss_seg1", ".", "item", "(", ")", ",", "loss_seg2", ".", "item", "(", ")", ",", "loss_mse", ".", "item", "(", ")", ",", "loss_var", ".", "item", "(", ")", ")", ")", "\n", "loss1", "+=", "loss_seg1", "\n", "loss2", "+=", "loss_seg2", "\n", "loss3", "+=", "loss_mse", "\n", "loss4", "+=", "loss_var", "\n", "\n", "", "logger", ".", "info", "(", "'Epoch loss: {:.2e}, {:.2e}, {:.2e}, {:.2e}'", ".", "format", "(", "loss1", "/", "i", ",", "loss2", "/", "i", ",", "loss3", "/", "i", ",", "loss4", "/", "i", ")", ")", "\n", "scheduler_S", ".", "step", "(", ")", "\n", "scheduler_R", ".", "step", "(", ")", "\n", "\n", "if", "save_cp", "and", "(", "epoch", "+", "1", ")", "%", "5", "==", "0", ":", "\n", "            ", "torch", ".", "save", "(", "{", "'segmenter'", ":", "segmenter", ".", "state_dict", "(", ")", ",", "\n", "'optimizer_S'", ":", "optimizer_S", ".", "state_dict", "(", ")", ",", "\n", "'scheduler_S'", ":", "scheduler_S", ".", "state_dict", "(", ")", ",", "\n", "'reconstucter'", ":", "reconstucter", ".", "state_dict", "(", ")", ",", "\n", "'optimizer_R'", ":", "optimizer_R", ".", "state_dict", "(", ")", ",", "\n", "'scheduler_R'", ":", "scheduler_R", ".", "state_dict", "(", ")", ",", "\n", "'epoch'", ":", "epoch", "}", ",", "\n", "dir_checkpoint", "+", "'%s_%s.pth'", "%", "(", "starttime", ",", "epoch", "+", "1", ")", ")", "\n", "logger", ".", "info", "(", "f'Checkpoint {epoch + 1} saved !'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.None.main.get_args": [[120, 136], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["", "", "", "def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Train the UNet on images and target masks'", ",", "\n", "formatter_class", "=", "argparse", ".", "ArgumentDefaultsHelpFormatter", ")", "\n", "parser", ".", "add_argument", "(", "'-e'", ",", "'--epochs'", ",", "metavar", "=", "'E'", ",", "type", "=", "int", ",", "default", "=", "10", ",", "\n", "help", "=", "'Number of epochs'", ",", "dest", "=", "'epochs'", ")", "\n", "parser", ".", "add_argument", "(", "'-b'", ",", "'--batch_size'", ",", "metavar", "=", "'B'", ",", "type", "=", "int", ",", "nargs", "=", "'?'", ",", "default", "=", "12", ",", "\n", "help", "=", "'Batch size'", ",", "dest", "=", "'batch_size'", ")", "\n", "parser", ".", "add_argument", "(", "'-l'", ",", "'--learning-rate'", ",", "metavar", "=", "'LR'", ",", "type", "=", "float", ",", "nargs", "=", "'?'", ",", "default", "=", "1e-3", ",", "\n", "help", "=", "'Learning rate'", ",", "dest", "=", "'lr'", ")", "\n", "parser", ".", "add_argument", "(", "'-g'", ",", "'--gpu'", ",", "dest", "=", "'gpu'", ",", "default", "=", "0", ",", "type", "=", "int", ",", "help", "=", "'witch gpu to use'", ")", "\n", "parser", ".", "add_argument", "(", "'--percent'", ",", "'-p'", ",", "metavar", "=", "'PERCENT'", ",", "dest", "=", "'percent'", ",", "type", "=", "float", ",", "default", "=", "10.0", ",", "\n", "help", "=", "'Percent of the data that is used as training (0-100)'", ")", "\n", "parser", ".", "add_argument", "(", "'--lambd'", ",", "'-d'", ",", "type", "=", "str", ",", "default", "=", "'[1,1,10.0,5.0]'", ",", "dest", "=", "'lambd'", ",", "\n", "metavar", "=", "'FILE'", ",", "help", "=", "\"param of 3 losses\"", ")", "\n", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.None.test.get_args": [[16, 28], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args"], "function", ["None"], ["def", "get_args", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "description", "=", "'Predict masks from input images'", ",", "\n", "formatter_class", "=", "argparse", ".", "ArgumentDefaultsHelpFormatter", ")", "\n", "parser", ".", "add_argument", "(", "'--model'", ",", "'-m'", ",", "type", "=", "str", ",", "default", "=", "'./checkpoints/pretrain.pth'", ",", "\n", "metavar", "=", "'FILE'", ",", "\n", "help", "=", "\"Specify the file in which the model is stored\"", ")", "\n", "parser", ".", "add_argument", "(", "'-b'", ",", "'--batch_size'", ",", "metavar", "=", "'B'", ",", "type", "=", "int", ",", "nargs", "=", "'?'", ",", "default", "=", "8", ",", "\n", "help", "=", "'Batch size'", ",", "dest", "=", "'batch_size'", ")", "\n", "parser", ".", "add_argument", "(", "'--output'", ",", "'-o'", ",", "metavar", "=", "'OUTPUT'", ",", "type", "=", "str", ",", "default", "=", "'./Results/'", ",", "\n", "help", "=", "'Filenames of output images'", ",", "dest", "=", "'output'", ")", "\n", "parser", ".", "add_argument", "(", "'-g'", ",", "'--gpu'", ",", "dest", "=", "'gpu'", ",", "default", "=", "0", ",", "type", "=", "int", ",", "help", "=", "'witch gpu to use'", ")", "\n", "return", "parser", ".", "parse_args", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.None.test.predict": [[30, 103], ["str", "torch.device", "logger.info", "unet.networks.define_G", "unet.networks.define_G.to", "logger.info", "torch.load", "unet.networks.define_G.load_state_dict", "logger.info", "unet.networks.define_G.eval", "utils.dataset.BrainDataset", "torch.utils.data.DataLoader", "len", "tqdm.tqdm", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir", "enumerate", "img.unsqueeze().to.unsqueeze().to", "brain_mask.numpy().astype.numpy().astype", "img.unsqueeze().to.squeeze().cpu().numpy", "reconstucter.squeeze().cpu().numpy", "seg_tumor.numpy().astype.numpy().astype", "range", "torch.cuda.is_available", "torch.no_grad", "unet.networks.define_G.", "cv2.cvtColor.astype", "cv2.applyColorMap", "cv2.cvtColor", "cv2.cvtColor", "abs", "cv2.applyColorMap", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate", "cv2.imwrite", "img.unsqueeze().to.unsqueeze", "brain_mask.numpy().astype.numpy", "img.unsqueeze().to.squeeze().cpu", "reconstucter.squeeze().cpu", "seg_tumor.numpy().astype.numpy", "os.path.exists", "os.mkdir", "img.unsqueeze().to.squeeze", "reconstucter.squeeze", "img_ori[].min", "img_ori[].max", "img_ori[].min", "img_ori[].min", "img_ori[].max", "img_ori[].min", "cv2.applyColorMap.min", "cv2.applyColorMap.max", "cv2.applyColorMap.min"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.define_G"], ["", "def", "predict", "(", "args", ",", "logger", "=", "None", ")", ":", "\n", "    ", "os", ".", "environ", "[", "\"CUDA_VISIBLE_DEVICES\"", "]", "=", "str", "(", "args", ".", "gpu", ")", "\n", "device", "=", "torch", ".", "device", "(", "'cuda'", "if", "torch", ".", "cuda", ".", "is_available", "(", ")", "else", "'cpu'", ")", "\n", "logger", ".", "info", "(", "f'Using device {device}'", ")", "\n", "\n", "model_pth", "=", "args", ".", "model", "\n", "output", "=", "args", ".", "output", "\n", "\n", "output_img", "=", "output", "+", "'/img'", "\n", "output_npy", "=", "output", "+", "'/npy'", "\n", "output_eval", "=", "output", "+", "'/eval'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "output", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "output_img", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output_img", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "output_npy", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output_npy", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "output_eval", ")", ":", "\n", "        ", "os", ".", "mkdir", "(", "output_eval", ")", "\n", "\n", "# load model", "\n", "", "reconstucter", "=", "define_G", "(", "input_nc", "=", "1", ",", "output_nc", "=", "1", ",", "ngf", "=", "64", ",", "netG", "=", "'resnet_9blocks'", ",", "norm", "=", "'instance'", ")", "\n", "reconstucter", ".", "to", "(", "device", "=", "device", ")", "\n", "logger", ".", "info", "(", "\"Loading model {}\"", ".", "format", "(", "model_pth", ")", ")", "\n", "model_dict", "=", "torch", ".", "load", "(", "model_pth", ",", "map_location", "=", "device", ")", "\n", "reconstucter", ".", "load_state_dict", "(", "model_dict", "[", "'reconstucter'", "]", ")", "\n", "logger", ".", "info", "(", "\"Model loaded !\"", ")", "\n", "\n", "reconstucter", ".", "eval", "(", ")", "\n", "\n", "test_set", "=", "BrainDataset", "(", "'data/test_brats.txt'", ")", "\n", "test_loader", "=", "DataLoader", "(", "test_set", ",", "batch_size", "=", "args", ".", "batch_size", ",", "shuffle", "=", "True", ",", "num_workers", "=", "8", ",", "pin_memory", "=", "True", ",", "\n", "drop_last", "=", "False", ")", "\n", "n_test", "=", "len", "(", "test_loader", ")", "\n", "\n", "bar", "=", "tqdm", "(", "enumerate", "(", "test_loader", ")", ",", "total", "=", "n_test", ",", "desc", "=", "'TEST ROUND'", ",", "unit", "=", "'batch'", ",", "ncols", "=", "120", ",", "ascii", "=", "True", ")", "\n", "for", "i", ",", "data", "in", "bar", ":", "\n", "        ", "[", "img", ",", "_", ",", "seg_tumor", ",", "brain_mask", ",", "case_name", ",", "slice_idx", "]", "=", "data", "[", "0", ":", "6", "]", "\n", "img", "=", "img", ".", "unsqueeze", "(", "dim", "=", "1", ")", ".", "to", "(", "device", "=", "device", ",", "dtype", "=", "torch", ".", "float32", ")", "\n", "brain_mask", "=", "brain_mask", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "batch_size", ",", "h", ",", "w", "=", "img", ".", "shape", "[", "0", "]", ",", "img", ".", "shape", "[", "-", "2", "]", ",", "img", ".", "shape", "[", "-", "1", "]", "\n", "\n", "with", "torch", ".", "no_grad", "(", ")", ":", "\n", "            ", "img_no_tumor", "=", "reconstucter", "(", "img", ")", "# shape(batch,1,512,512)", "\n", "\n", "", "img_ori", "=", "img", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "img_rec", "=", "img_no_tumor", ".", "squeeze", "(", ")", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "seg_tumor", "=", "seg_tumor", ".", "numpy", "(", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "for", "b", "in", "range", "(", "batch_size", ")", ":", "\n", "            ", "img_1", "=", "(", "(", "(", "img_ori", "[", "b", "]", "-", "img_ori", "[", "b", "]", ".", "min", "(", ")", ")", "/", "(", "img_ori", "[", "b", "]", ".", "max", "(", ")", "-", "img_ori", "[", "b", "]", ".", "min", "(", ")", ")", "*", "255", ")", "*", "brain_mask", "[", "\n", "b", "]", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "img_2", "=", "(", "(", "(", "img_rec", "[", "b", "]", "-", "img_ori", "[", "b", "]", ".", "min", "(", ")", ")", "/", "(", "img_ori", "[", "b", "]", ".", "max", "(", ")", "-", "img_ori", "[", "b", "]", ".", "min", "(", ")", ")", "*", "255", ")", "*", "brain_mask", "[", "b", "]", ")", "\n", "img_2", "=", "img_2", "*", "(", "img_2", "<=", "255", ")", "+", "255", "*", "(", "img_2", ">", "255", ")", "\n", "img_2", "*=", "(", "img_2", ">", "0", ")", "\n", "img_2", "=", "img_2", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "label", "=", "cv2", ".", "applyColorMap", "(", "(", "seg_tumor", "[", "b", "]", "*", "255", ")", ".", "astype", "(", "np", ".", "uint8", ")", ",", "cv2", ".", "COLORMAP_JET", ")", "\n", "img_1", "=", "cv2", ".", "cvtColor", "(", "img_1", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "\n", "img_2", "=", "cv2", ".", "cvtColor", "(", "img_2", ",", "cv2", ".", "COLOR_GRAY2RGB", ")", "\n", "\n", "diff", "=", "abs", "(", "img_ori", "[", "b", "]", "-", "img_rec", "[", "b", "]", ")", "\n", "diff", "=", "(", "(", "(", "diff", "-", "diff", ".", "min", "(", ")", ")", "/", "(", "diff", ".", "max", "(", ")", "-", "diff", ".", "min", "(", ")", ")", "*", "255", ")", "*", "brain_mask", "[", "b", "]", ")", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "diff", "=", "cv2", ".", "applyColorMap", "(", "diff", ",", "cv2", ".", "COLORMAP_JET", ")", "\n", "\n", "img_up", "=", "np", ".", "concatenate", "(", "(", "img_1", ",", "img_2", ")", ",", "axis", "=", "1", ")", "\n", "img_down", "=", "np", ".", "concatenate", "(", "(", "label", ",", "diff", ")", ",", "axis", "=", "1", ")", "\n", "img_whole", "=", "np", ".", "concatenate", "(", "(", "img_up", ",", "img_down", ")", ",", "axis", "=", "0", ")", "\n", "\n", "# \u4ee5case\u4e3a\u5355\u4f4d\u521b\u5efa\u6587\u4ef6\u5939", "\n", "case_path", "=", "'%s/%s'", "%", "(", "output_eval", ",", "case_name", "[", "b", "]", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "case_path", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "case_path", ")", "\n", "", "cv2", ".", "imwrite", "(", "'{}/{}.jpg'", ".", "format", "(", "case_path", ",", "slice_idx", "[", "b", "]", ")", ",", "img_whole", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_brats.get_boundingbox": [[14, 27], ["skimage.morphology.remove_small_objects", "skimage.measure.label", "len", "list", "skimage.measure.regionprops", "skimage.measure.regionprops", "list.append"], "function", ["None"], ["def", "get_boundingbox", "(", "mask", ")", ":", "\n", "# mask.shape = [image.shape[0], image.shape[1], classnum]        ", "\n", "# \u5220\u6389\u5c0f\u4e8e10\u50cf\u7d20\u7684\u76ee\u6807", "\n", "        ", "mask_without_small", "=", "morphology", ".", "remove_small_objects", "(", "mask", ",", "min_size", "=", "10", ",", "connectivity", "=", "2", ")", "\n", "# mask_without_small = mask", "\n", "# \u8fde\u901a\u57df\u6807\u8bb0", "\n", "label_image", "=", "measure", ".", "label", "(", "mask_without_small", ")", "\n", "#\u7edf\u8ba1object\u4e2a\u6570", "\n", "object_num", "=", "len", "(", "measure", ".", "regionprops", "(", "label_image", ")", ")", "\n", "boundingbox", "=", "list", "(", ")", "\n", "for", "region", "in", "measure", ".", "regionprops", "(", "label_image", ")", ":", "# \u5faa\u73af\u5f97\u5230\u6bcf\u4e00\u4e2a\u8fde\u901a\u57dfbbox", "\n", "            ", "boundingbox", ".", "append", "(", "region", ".", "bbox", ")", "\n", "", "return", "object_num", ",", "boundingbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_brats.find995": [[28, 47], ["ArrayImage.astype.astype", "numpy.zeros", "range", "range", "range", "len", "range", "print"], "function", ["None"], ["", "def", "find995", "(", "ArrayImage", ")", ":", "\n", "\n", "#################################", "\n", "# \u968f\u673a\u6311\u900910\u4f8b\u6765\u7edf\u8ba10.995\u50cf\u7d20\u8303\u56f4 #", "\n", "################################# ", "\n", "    ", "ArrayImage", "=", "ArrayImage", ".", "astype", "(", "int", ")", "\n", "count", "=", "np", ".", "zeros", "(", "(", "50000", ")", ",", "dtype", "=", "np", ".", "float64", ")", "\n", "\n", "for", "c", "in", "range", "(", "155", ")", ":", "\n", "        ", "for", "h", "in", "range", "(", "240", ")", ":", "\n", "            ", "for", "w", "in", "range", "(", "240", ")", ":", "\n", "                ", "count", "[", "ArrayImage", "[", "c", ",", "h", ",", "w", "]", "]", "+=", "1", "\n", "", "", "", "count", "=", "count", "/", "(", "155", "*", "240", "*", "240", ")", "\n", "for", "i", "in", "range", "(", "1", ",", "len", "(", "count", ")", ",", "1", ")", ":", "\n", "        ", "count", "[", "i", "]", "=", "count", "[", "i", "-", "1", "]", "+", "count", "[", "i", "]", "\n", "if", "count", "[", "i", "]", ">", "0.995", ":", "\n", "            ", "print", "(", "i", ")", "\n", "break", "\n", "", "", "return", "i", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_brats.slice_ct": [[48, 90], ["glob.glob", "len", "tqdm.tqdm", "range", "print", "SimpleITK.ReadImage", "SimpleITK.GetArrayFromImage", "SimpleITK.ReadImage", "SimpleITK.GetArrayFromImage", "nii2npy_brats.find995", "numpy.where", "np.where.sum().sum", "range", "casepaths[].split", "numpy.mean", "numpy.std", "len", "glob.glob", "glob.glob", "np.where.sum", "numpy.save", "os.path.exists", "os.makedirs"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_brats.find995"], ["", "def", "slice_ct", "(", ")", ":", "\n", "    ", "rootpath", "=", "'/home/lx/MICCAI_BraTS_2019_Data_Training/LGG'", "\n", "outpath", "=", "'/home2/zyl/BraTS19/LGG/npy'", "\n", "casepaths", "=", "glob", "(", "rootpath", "+", "'/*'", ")", "\n", "n_case", "=", "len", "(", "casepaths", ")", "\n", "\n", "\n", "for", "i", "in", "tqdm", "(", "range", "(", "n_case", ")", ",", "ncols", "=", "120", ",", "ascii", "=", "True", ")", ":", "\n", "        ", "casename", "=", "casepaths", "[", "i", "]", ".", "split", "(", "'/'", ")", "[", "-", "1", "]", "\n", "print", "(", "casename", ")", "\n", "# print(f'processing case {casepaths[i]}')", "\n", "\n", "Image", "=", "sitk", ".", "ReadImage", "(", "glob", "(", "f'{casepaths[i]}/*t2*'", ")", "[", "0", "]", ",", "sitk", ".", "sitkFloat32", ")", "\n", "ArrayImage", "=", "sitk", ".", "GetArrayFromImage", "(", "Image", ")", "\n", "\n", "Label", "=", "sitk", ".", "ReadImage", "(", "glob", "(", "f'{casepaths[i]}/*seg*'", ")", "[", "0", "]", ",", "sitk", ".", "sitkUInt8", ")", "\n", "ArrayLabel", "=", "sitk", ".", "GetArrayFromImage", "(", "Label", ")", "\n", "\n", "# # \u5c06\u7070\u5ea6\u503c\u5728\u9608\u503c\u4e4b\u5916\u7684\u622a\u65ad", "\n", "pixel995", "=", "find995", "(", "ArrayImage", ")", "\n", "ArrayImage", "[", "ArrayImage", ">", "pixel995", "]", "=", "pixel995", "\n", "# ArrayImage[ArrayImage < -200] = -200", "\n", "brain_mask", "=", "np", ".", "where", "(", "ArrayImage", ">", "0", ",", "1", ",", "0", ")", "\n", "brain_area", "=", "brain_mask", ".", "sum", "(", "axis", "=", "-", "1", ")", ".", "sum", "(", "axis", "=", "-", "1", ")", "\n", "# ######\u8111\u90e8\u533a\u57df\u5f52\u4e00\u5316########", "\n", "brain_img", "=", "ArrayImage", "[", "ArrayImage", ">", "0", "]", "\n", "mean", ",", "std", "=", "np", ".", "mean", "(", "brain_img", ")", ",", "np", ".", "std", "(", "brain_img", ",", "ddof", "=", "1", ")", "\n", "ArrayImage", "=", "(", "ArrayImage", "-", "mean", ")", "/", "std", "*", "brain_mask", "\n", "\n", "#\u5408\u5e76\u80bf\u7624\u533a\u57df", "\n", "# label_for_tumor = np.where(ArrayLabel>0,1,0)", "\n", "\n", "for", "n", "in", "range", "(", "len", "(", "ArrayImage", ")", ")", ":", "\n", "            ", "if", "brain_area", "[", "n", "]", ">", "0", ":", "\n", "                ", "slice_dict", "=", "{", "'brain'", ":", "ArrayImage", "[", "n", "]", ",", "'seg_label'", ":", "ArrayLabel", "[", "n", "]", ",", "'mean'", ":", "mean", ",", "'std'", ":", "std", "}", "\n", "# 'mean':mean,'std':std}", "\n", "path", "=", "f'{outpath}/{casename}'", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "                    ", "os", ".", "makedirs", "(", "path", ")", "\n", "\n", "", "filename", "=", "'{}/{:0>3d}.npy'", ".", "format", "(", "path", ",", "n", ")", "\n", "np", ".", "save", "(", "filename", ",", "slice_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.MS_SSIM.__init__": [[121, 151], ["super().__init__", "ms_ssim.create_window", "ms_ssim.MS_SSIM.register_buffer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "ms_ssim.MS_SSIM.register_buffer", "torch.tensor.sum", "torch.tensor.sum", "torch.tensor.sum"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.create_window"], ["def", "__init__", "(", "self", ",", "window_size", "=", "11", ",", "window_sigma", "=", "1.5", ",", "data_range", "=", "255.", ",", "channel", "=", "3", ",", "use_padding", "=", "False", ",", "weights", "=", "None", ",", "levels", "=", "None", ",", "eps", "=", "1e-8", ")", ":", "\n", "        ", "'''\n        class for ms-ssim\n        :param window_size: the size of gauss kernel\n        :param window_sigma: sigma of normal distribution\n        :param data_range: value range of input images. (usually 1.0 or 255)\n        :param channel: input channels\n        :param use_padding: padding image before conv\n        :param weights: weights for different levels. (default [0.0448, 0.2856, 0.3001, 0.2363, 0.1333])\n        :param levels: number of downsampling\n        :param eps: Use for fix a issue. When c = a ** b and a is 0, c.backward() will cause the a.grad become inf.\n        '''", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "assert", "window_size", "%", "2", "==", "1", ",", "'Window size must be odd.'", "\n", "self", ".", "data_range", "=", "data_range", "\n", "self", ".", "use_padding", "=", "use_padding", "\n", "self", ".", "eps", "=", "eps", "\n", "\n", "window", "=", "create_window", "(", "window_size", ",", "window_sigma", ",", "channel", ")", "\n", "self", ".", "register_buffer", "(", "'window'", ",", "window", ")", "\n", "\n", "if", "weights", "is", "None", ":", "\n", "            ", "weights", "=", "[", "0.0448", ",", "0.2856", ",", "0.3001", ",", "0.2363", ",", "0.1333", "]", "\n", "", "weights", "=", "torch", ".", "tensor", "(", "weights", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "\n", "if", "levels", "is", "not", "None", ":", "\n", "            ", "weights", "=", "weights", "[", ":", "levels", "]", "\n", "weights", "=", "weights", "/", "weights", ".", "sum", "(", ")", "\n", "\n", "", "self", ".", "register_buffer", "(", "'weights'", ",", "weights", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.MS_SSIM.forward": [[153, 156], ["ms_ssim.ms_ssim"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.ms_ssim"], ["", "def", "forward", "(", "self", ",", "X", ",", "Y", ")", ":", "\n", "        ", "return", "ms_ssim", "(", "X", ",", "Y", ",", "window", "=", "self", ".", "window", ",", "data_range", "=", "self", ".", "data_range", ",", "weights", "=", "self", ".", "weights", ",", "\n", "use_padding", "=", "self", ".", "use_padding", ",", "eps", "=", "self", ".", "eps", ")", "", "", "", ""]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.create_window": [[6, 22], ["torch.arange", "torch.arange", "torch.arange", "torch.exp", "torch.exp", "torch.exp", "g.reshape().repeat.sum", "g.reshape().repeat.reshape().repeat", "g.reshape().repeat.reshape"], "function", ["None"], ["def", "create_window", "(", "window_size", ":", "int", ",", "sigma", ":", "float", ",", "channel", ":", "int", ")", ":", "\n", "    ", "'''\n    Create 1-D gauss kernel\n    :param window_size: the size of gauss kernel\n    :param sigma: sigma of normal distribution\n    :param channel: input channel\n    :return: 1D kernel\n    '''", "\n", "coords", "=", "torch", ".", "arange", "(", "window_size", ",", "dtype", "=", "torch", ".", "float", ")", "\n", "coords", "-=", "window_size", "//", "2", "\n", "\n", "g", "=", "torch", ".", "exp", "(", "-", "(", "coords", "**", "2", ")", "/", "(", "2", "*", "sigma", "**", "2", ")", ")", "\n", "g", "/=", "g", ".", "sum", "(", ")", "\n", "\n", "g", "=", "g", ".", "reshape", "(", "1", ",", "1", ",", "1", ",", "-", "1", ")", ".", "repeat", "(", "channel", ",", "1", ",", "1", ",", "1", ")", "\n", "return", "g", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim._gaussian_filter": [[25, 41], ["torch.conv2d", "torch.conv2d", "window_1d.transpose"], "function", ["None"], ["", "def", "_gaussian_filter", "(", "x", ",", "window_1d", ",", "use_padding", ":", "bool", ")", ":", "\n", "    ", "'''\n    Blur input with 1-D kernel\n    :param x: batch of tensors to be blured\n    :param window_1d: 1-D gauss kernel\n    :param use_padding: padding image before conv\n    :return: blured tensors\n    '''", "\n", "C", "=", "x", ".", "shape", "[", "1", "]", "\n", "padding", "=", "0", "\n", "if", "use_padding", ":", "\n", "        ", "window_size", "=", "window_1d", ".", "shape", "[", "3", "]", "\n", "padding", "=", "window_size", "//", "2", "\n", "", "out", "=", "F", ".", "conv2d", "(", "x", ",", "window_1d", ",", "stride", "=", "1", ",", "padding", "=", "(", "0", ",", "padding", ")", ",", "groups", "=", "C", ")", "\n", "out", "=", "F", ".", "conv2d", "(", "out", ",", "window_1d", ".", "transpose", "(", "2", ",", "3", ")", ",", "stride", "=", "1", ",", "padding", "=", "(", "padding", ",", "0", ")", ",", "groups", "=", "C", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.ssim": [[43, 84], ["ms_ssim._gaussian_filter", "ms_ssim._gaussian_filter", "ms_ssim._gaussian_filter", "ms_ssim._gaussian_filter", "ms_ssim._gaussian_filter", "_gaussian_filter.pow", "_gaussian_filter.pow", "cs_map.clamp_min.clamp_min", "ssim_map.mean", "cs_map.clamp_min.mean"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim._gaussian_filter", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim._gaussian_filter", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim._gaussian_filter", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim._gaussian_filter", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim._gaussian_filter"], ["", "def", "ssim", "(", "X", ",", "Y", ",", "window", ",", "data_range", ":", "float", ",", "use_padding", ":", "bool", "=", "False", ")", ":", "\n", "    ", "'''\n    Calculate ssim index for X and Y\n    :param X: images\n    :param Y: images\n    :param window: 1-D gauss kernel\n    :param data_range: value range of input images. (usually 1.0 or 255)\n    :param use_padding: padding image before conv\n    :return:\n    '''", "\n", "\n", "K1", "=", "0.01", "\n", "K2", "=", "0.03", "\n", "compensation", "=", "1.0", "\n", "\n", "C1", "=", "(", "K1", "*", "data_range", ")", "**", "2", "\n", "C2", "=", "(", "K2", "*", "data_range", ")", "**", "2", "\n", "\n", "mu1", "=", "_gaussian_filter", "(", "X", ",", "window", ",", "use_padding", ")", "\n", "mu2", "=", "_gaussian_filter", "(", "Y", ",", "window", ",", "use_padding", ")", "\n", "sigma1_sq", "=", "_gaussian_filter", "(", "X", "*", "X", ",", "window", ",", "use_padding", ")", "\n", "sigma2_sq", "=", "_gaussian_filter", "(", "Y", "*", "Y", ",", "window", ",", "use_padding", ")", "\n", "sigma12", "=", "_gaussian_filter", "(", "X", "*", "Y", ",", "window", ",", "use_padding", ")", "\n", "\n", "mu1_sq", "=", "mu1", ".", "pow", "(", "2", ")", "\n", "mu2_sq", "=", "mu2", ".", "pow", "(", "2", ")", "\n", "mu1_mu2", "=", "mu1", "*", "mu2", "\n", "\n", "sigma1_sq", "=", "compensation", "*", "(", "sigma1_sq", "-", "mu1_sq", ")", "\n", "sigma2_sq", "=", "compensation", "*", "(", "sigma2_sq", "-", "mu2_sq", ")", "\n", "sigma12", "=", "compensation", "*", "(", "sigma12", "-", "mu1_mu2", ")", "\n", "\n", "cs_map", "=", "(", "2", "*", "sigma12", "+", "C2", ")", "/", "(", "sigma1_sq", "+", "sigma2_sq", "+", "C2", ")", "\n", "# Fixed the issue that the negative value of cs_map caused ms_ssim to output Nan.", "\n", "cs_map", "=", "cs_map", ".", "clamp_min", "(", "0.", ")", "\n", "ssim_map", "=", "(", "(", "2", "*", "mu1_mu2", "+", "C1", ")", "/", "(", "mu1_sq", "+", "mu2_sq", "+", "C1", ")", ")", "*", "cs_map", "\n", "\n", "ssim_val", "=", "ssim_map", ".", "mean", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "# reduce along CHW", "\n", "cs", "=", "cs_map", ".", "mean", "(", "dim", "=", "(", "1", ",", "2", ",", "3", ")", ")", "\n", "\n", "return", "ssim_val", ",", "cs", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.ms_ssim": [[86, 116], ["range", "torch.stack", "torch.stack", "torch.stack", "torch.prod", "torch.prod", "torch.prod", "ms_ssim.ssim", "ssim_val.clamp_min.clamp_min", "cs.clamp_min.clamp_min", "torch.stack.append", "ssim_vals.append", "torch.avg_pool2d", "torch.avg_pool2d", "weights[].unsqueeze"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.ms_ssim.ssim"], ["", "def", "ms_ssim", "(", "X", ",", "Y", ",", "window", ",", "data_range", ":", "float", ",", "weights", ",", "use_padding", ":", "bool", "=", "False", ",", "eps", ":", "float", "=", "1e-8", ")", ":", "\n", "    ", "'''\n    interface of ms-ssim\n    :param X: a batch of images, (N,C,H,W)\n    :param Y: a batch of images, (N,C,H,W)\n    :param window: 1-D gauss kernel\n    :param data_range: value range of input images. (usually 1.0 or 255)\n    :param weights: weights for different levels\n    :param use_padding: padding image before conv\n    :param eps: use for avoid grad nan.\n    :return:\n    '''", "\n", "levels", "=", "weights", ".", "shape", "[", "0", "]", "\n", "cs_vals", "=", "[", "]", "\n", "ssim_vals", "=", "[", "]", "\n", "for", "_", "in", "range", "(", "levels", ")", ":", "\n", "        ", "ssim_val", ",", "cs", "=", "ssim", "(", "X", ",", "Y", ",", "window", "=", "window", ",", "data_range", "=", "data_range", ",", "use_padding", "=", "use_padding", ")", "\n", "# Use for fix a issue. When c = a ** b and a is 0, c.backward() will cause the a.grad become inf.", "\n", "ssim_val", "=", "ssim_val", ".", "clamp_min", "(", "eps", ")", "\n", "cs", "=", "cs", ".", "clamp_min", "(", "eps", ")", "\n", "cs_vals", ".", "append", "(", "cs", ")", "\n", "\n", "ssim_vals", ".", "append", "(", "ssim_val", ")", "\n", "padding", "=", "(", "X", ".", "shape", "[", "2", "]", "%", "2", ",", "X", ".", "shape", "[", "3", "]", "%", "2", ")", "\n", "X", "=", "F", ".", "avg_pool2d", "(", "X", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", "\n", "Y", "=", "F", ".", "avg_pool2d", "(", "Y", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ",", "padding", "=", "padding", ")", "\n", "\n", "", "cs_vals", "=", "torch", ".", "stack", "(", "cs_vals", ",", "dim", "=", "0", ")", "\n", "ms_ssim_val", "=", "torch", ".", "prod", "(", "(", "cs_vals", "[", ":", "-", "1", "]", "**", "weights", "[", ":", "-", "1", "]", ".", "unsqueeze", "(", "1", ")", ")", "*", "(", "ssim_vals", "[", "-", "1", "]", "**", "weights", "[", "-", "1", "]", ")", ",", "dim", "=", "0", ")", "\n", "return", "ms_ssim_val", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.dataset.LiverDataset.__init__": [[11, 32], ["torchvision.transforms.Compose", "range", "open", "fp.readlines", "len", "img_list[].strip", "range", "torchvision.transforms.ToTensor", "open", "fp.readlines", "len", "other_list[].strip"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "imgs_dir", ",", "other_dir", "=", "''", ",", "scale_seg", "=", "False", ")", ":", "\n", "        ", "self", ".", "imgs_dir", "=", "imgs_dir", "\n", "self", ".", "other_dir", "=", "other_dir", "\n", "self", ".", "transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "# transforms.Normalize((-99.5946,-99.5946), (126.5396,126.5396))", "\n", "]", ")", "\n", "self", ".", "scale_seg", "=", "scale_seg", "\n", "\n", "with", "open", "(", "self", ".", "imgs_dir", ",", "'r'", ")", "as", "fp", ":", "\n", "             ", "img_list", "=", "fp", ".", "readlines", "(", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "img_list", ")", ")", ":", "\n", "            ", "img_list", "[", "i", "]", "=", "img_list", "[", "i", "]", ".", "strip", "(", ")", "\n", "", "if", "self", ".", "other_dir", "!=", "''", ":", "\n", "            ", "with", "open", "(", "self", ".", "other_dir", ",", "'r'", ")", "as", "fp", ":", "\n", "                ", "other_list", "=", "fp", ".", "readlines", "(", ")", "\n", "", "for", "i", "in", "range", "(", "len", "(", "other_list", ")", ")", ":", "\n", "                ", "other_list", "[", "i", "]", "=", "other_list", "[", "i", "]", ".", "strip", "(", ")", "\n", "", "self", ".", "img_list", "=", "img_list", "+", "other_list", "\n", "", "else", ":", "\n", "            ", "self", ".", "img_list", "=", "img_list", "\n", "# self.idx = 0", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.dataset.LiverDataset.__len__": [[34, 36], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "img_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.dataset.LiverDataset.__getitem__": [[37, 61], ["numpy.load().item", "numpy.where", "numpy.where", "numpy.where", "torch.tensor.astype", "torch.tensor", "torch.tensor", "torch.tensor", "dataset.LiverDataset.img_list[].split", "os.path.basename", "os.path.basename", "os.path.basename", "os.path.basename", "torch.tensor", "numpy.ones", "cv2.dilate", "return_data.append", "numpy.load", "torch.tensor"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "data", "=", "np", ".", "load", "(", "self", ".", "img_list", "[", "idx", "]", ")", ".", "item", "(", ")", "\n", "case_name", "=", "(", "self", ".", "img_list", "[", "idx", "]", ")", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", "\n", "slice_idx", "=", "os", ".", "path", ".", "basename", "(", "self", ".", "img_list", "[", "idx", "]", ")", "[", ":", "6", "]", "\n", "img", "=", "data", "[", "'liver'", "]", "\n", "seg", "=", "data", "[", "'seg_label'", "]", "\n", "body_mask", "=", "np", ".", "where", "(", "img", "<=", "200", ",", "0", ",", "1", ")", "\n", "liver_mask", "=", "np", ".", "where", "(", "seg", ">", "0", ",", "1", ",", "0", ")", "\n", "\n", "seg_tumor", "=", "np", ".", "where", "(", "seg", "==", "2", ",", "1", ",", "0", ")", "#\u53ea\u7559\u80bf\u7624\u6807\u7b7e", "\n", "seg_tumor_np", "=", "seg_tumor", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "img", "=", "torch", ".", "tensor", "(", "img", ")", "\n", "seg", "=", "torch", ".", "tensor", "(", "seg", ")", "\n", "seg_tumor", "=", "torch", ".", "tensor", "(", "seg_tumor", ")", "\n", "\n", "return_data", "=", "[", "img", ",", "seg", ",", "seg_tumor", ",", "torch", ".", "tensor", "(", "body_mask", ")", ",", "case_name", ",", "slice_idx", "]", "\n", "\n", "if", "self", ".", "scale_seg", ":", "\n", "            ", "kernel", "=", "np", ".", "ones", "(", "(", "self", ".", "scale_seg", "*", "2", ",", "self", ".", "scale_seg", "*", "2", ")", ",", "np", ".", "uint8", ")", "\n", "seg_scale", "=", "cv2", ".", "dilate", "(", "seg_tumor_np", ",", "kernel", ",", "iterations", "=", "1", ")", "\n", "return_data", ".", "append", "(", "torch", ".", "tensor", "(", "seg_scale", "*", "liver_mask", ")", ")", "\n", "\n", "", "return", "return_data", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.dataset.BrainDataset.__init__": [[63, 81], ["torchvision.transforms.Compose", "range", "open", "fp.readlines", "int", "dataset.BrainDataset.img_list.append", "torchvision.transforms.ToTensor", "img_list[].strip", "len"], "methods", ["None"], ["    ", "def", "__init__", "(", "self", ",", "imgs_dir", ",", "has_mean", "=", "False", ",", "percent", "=", "1.0", ")", ":", "\n", "        ", "'''\n        has_mean: bool, if your npy has key of 'mean'/'std'\n        scale_seg: int, pixle you want to scale your seg\n        '''", "\n", "self", ".", "has_mean", "=", "has_mean", "\n", "self", ".", "imgs_dir", "=", "imgs_dir", "\n", "self", ".", "transform", "=", "transforms", ".", "Compose", "(", "[", "\n", "transforms", ".", "ToTensor", "(", ")", ",", "\n", "# transforms.Normalize((-99.5946,-99.5946), (126.5396,126.5396))", "\n", "]", ")", "\n", "self", ".", "percent", "=", "percent", "\n", "self", ".", "img_list", "=", "[", "]", "\n", "\n", "with", "open", "(", "self", ".", "imgs_dir", ",", "'r'", ")", "as", "fp", ":", "\n", "             ", "img_list", "=", "fp", ".", "readlines", "(", ")", "\n", "", "for", "i", "in", "range", "(", "int", "(", "len", "(", "img_list", ")", "*", "self", ".", "percent", ")", ")", ":", "\n", "            ", "self", ".", "img_list", ".", "append", "(", "img_list", "[", "i", "]", ".", "strip", "(", ")", ")", "\n", "# self.idx = 0", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.dataset.BrainDataset.__len__": [[83, 85], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "img_list", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.dataset.BrainDataset.__getitem__": [[86, 113], ["numpy.load().item", "numpy.where", "numpy.where", "torch.tensor.astype", "torch.tensor", "torch.tensor", "torch.tensor", "dataset.BrainDataset.img_list[].split", "os.path.basename", "os.path.basename", "os.path.basename", "os.path.basename", "torch.tensor", "torch.tensor", "torch.tensor", "numpy.load", "torch.tensor.min", "torch.tensor.max", "torch.tensor.min"], "methods", ["None"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "data", "=", "np", ".", "load", "(", "self", ".", "img_list", "[", "idx", "]", ")", ".", "item", "(", ")", "\n", "case_name", "=", "(", "self", ".", "img_list", "[", "idx", "]", ")", ".", "split", "(", "'/'", ")", "[", "-", "2", "]", "\n", "slice_idx", "=", "os", ".", "path", ".", "basename", "(", "self", ".", "img_list", "[", "idx", "]", ")", "[", ":", "3", "]", "\n", "img", "=", "data", "[", "'brain'", "]", "\n", "seg", "=", "data", "[", "'seg_label'", "]", "\n", "seg_tumor", "=", "np", ".", "where", "(", "seg", ">", "0", ",", "1", ",", "0", ")", "#\u53ea\u7559\u80bf\u7624\u6807\u7b7e", "\n", "brain_mask", "=", "np", ".", "where", "(", "img", "!=", "0", ",", "1", ",", "0", ")", "\n", "seg_tumor_np", "=", "seg_tumor", ".", "astype", "(", "np", ".", "uint8", ")", "\n", "\n", "img", "=", "torch", ".", "tensor", "(", "img", ")", "\n", "img", "=", "(", "(", "img", "-", "img", ".", "min", "(", ")", ")", "/", "(", "img", ".", "max", "(", ")", "-", "img", ".", "min", "(", ")", ")", "-", "0.5", ")", "*", "2", "\n", "seg", "=", "torch", ".", "tensor", "(", "seg", ")", "\n", "seg_tumor", "=", "torch", ".", "tensor", "(", "seg_tumor", ")", "\n", "\n", "return_data", "=", "[", "img", ",", "seg", ",", "seg_tumor", ",", "torch", ".", "tensor", "(", "brain_mask", ")", ",", "case_name", ",", "slice_idx", "]", "\n", "\n", "if", "self", ".", "has_mean", ":", "\n", "            ", "std", "=", "data", "[", "'std'", "]", "\n", "mean", "=", "data", "[", "'mean'", "]", "\n", "mean", "=", "mean", "*", "brain_mask", "\n", "std", "=", "std", "*", "brain_mask", "\n", "mean", "=", "torch", ".", "tensor", "(", "mean", ")", "\n", "std", "=", "torch", ".", "tensor", "(", "std", ")", "\n", "return_data", "+=", "[", "mean", ",", "std", "]", "\n", "\n", "", "return", "return_data", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_lits.get_boundingbox": [[13, 26], ["skimage.morphology.remove_small_objects", "skimage.measure.label", "len", "list", "skimage.measure.regionprops", "skimage.measure.regionprops", "list.append"], "function", ["None"], ["def", "get_boundingbox", "(", "mask", ")", ":", "\n", "# mask.shape = [image.shape[0], image.shape[1], classnum]        ", "\n", "# \u5220\u6389\u5c0f\u4e8e10\u50cf\u7d20\u7684\u76ee\u6807", "\n", "        ", "mask_without_small", "=", "morphology", ".", "remove_small_objects", "(", "mask", ",", "min_size", "=", "10", ",", "connectivity", "=", "2", ")", "\n", "# mask_without_small = mask", "\n", "# \u8fde\u901a\u57df\u6807\u8bb0", "\n", "label_image", "=", "measure", ".", "label", "(", "mask_without_small", ")", "\n", "#\u7edf\u8ba1object\u4e2a\u6570", "\n", "object_num", "=", "len", "(", "measure", ".", "regionprops", "(", "label_image", ")", ")", "\n", "boundingbox", "=", "list", "(", ")", "\n", "for", "region", "in", "measure", ".", "regionprops", "(", "label_image", ")", ":", "# \u5faa\u73af\u5f97\u5230\u6bcf\u4e00\u4e2a\u8fde\u901a\u57dfbbox", "\n", "            ", "boundingbox", ".", "append", "(", "region", ".", "bbox", ")", "\n", "", "return", "object_num", ",", "boundingbox", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_lits.slice_ct": [[27, 112], ["range", "print", "SimpleITK.ReadImage", "SimpleITK.GetArrayFromImage", "SimpleITK.ReadImage", "SimpleITK.GetArrayFromImage", "scipy.zoom", "scipy.zoom", "numpy.where", "numpy.where", "numpy.where", "numpy.where", "list", "list.sort", "numpy.where", "list", "tqdm.tqdm", "set", "set", "print", "range", "range", "range", "numpy.save", "nii2npy_lits.get_boundingbox", "nii2npy_lits.get_boundingbox", "os.path.exists", "os.mkdir", "sitk.ReadImage.GetSpacing", "sitk.ReadImage.GetSpacing"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_lits.get_boundingbox", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.nii2npy_lits.get_boundingbox"], ["", "def", "slice_ct", "(", ")", ":", "\n", "    ", "for", "i", "in", "range", "(", "131", ")", ":", "\n", "        ", "print", "(", "'processing case {:0>3d}'", ".", "format", "(", "i", ")", ")", "\n", "path", "=", "'./raw_data/'", "\n", "\n", "Image", "=", "sitk", ".", "ReadImage", "(", "path", "+", "'volume-%d'", "%", "(", "i", ")", ",", "sitk", ".", "sitkInt16", ")", "\n", "ArrayImage", "=", "sitk", ".", "GetArrayFromImage", "(", "Image", ")", "\n", "\n", "Label", "=", "sitk", ".", "ReadImage", "(", "path", "+", "'segmentation-%d'", "%", "(", "i", ")", ",", "sitk", ".", "sitkUInt8", ")", "\n", "ArrayLabel", "=", "sitk", ".", "GetArrayFromImage", "(", "Label", ")", "\n", "\n", "# \u5c06\u7070\u5ea6\u503c\u5728\u9608\u503c\u4e4b\u5916\u7684\u622a\u65ad", "\n", "ArrayImage", "[", "ArrayImage", ">", "250", "]", "=", "250", "\n", "ArrayImage", "[", "ArrayImage", "<", "-", "200", "]", "=", "-", "200", "\n", "\n", "# \u5bf9CT\u6570\u636e\u5728\u6a2a\u65ad\u9762\u4e0a\u8fdb\u884c\u964d\u91c7\u6837,\u5e76\u8fdb\u884c\u91cd\u91c7\u6837,\u5c06\u6240\u6709\u6570\u636e\u7684z\u8f74\u7684spacing\u8c03\u6574\u52301mm", "\n", "ArrayImage", "=", "ndimage", ".", "zoom", "(", "ArrayImage", ",", "(", "Image", ".", "GetSpacing", "(", ")", "[", "-", "1", "]", "/", "slice_thickness", ",", "1", ",", "1", ")", ",", "order", "=", "3", ")", "\n", "ArrayLabel", "=", "ndimage", ".", "zoom", "(", "ArrayLabel", ",", "(", "Label", ".", "GetSpacing", "(", ")", "[", "-", "1", "]", "/", "slice_thickness", ",", "1", ",", "1", ")", ",", "order", "=", "0", ")", "\n", "\n", "\n", "#\u6311\u51fa\u809d\u810f\u3001\u80bf\u7624\u533a\u57df", "\n", "label_for_liver", "=", "np", ".", "where", "(", "ArrayLabel", "==", "2", ",", "1", ",", "ArrayLabel", ")", "\n", "label_for_liver", "=", "np", ".", "where", "(", "label_for_liver", "==", "1", ",", "True", ",", "False", ")", "\n", "label_for_tumor", "=", "np", ".", "where", "(", "ArrayLabel", "==", "2", ",", "True", ",", "False", ")", "\n", "\n", "#\u809d\u810f\u8d77\u6b62\u70b9", "\n", "liver_range", "=", "np", ".", "where", "(", "label_for_liver", "==", "1", ")", "\n", "liver_range", "=", "list", "(", "set", "(", "liver_range", "[", "0", "]", ")", ")", "\n", "liver_range", ".", "sort", "(", ")", "\n", "start", ",", "end", "=", "liver_range", "[", "0", "]", "-", "20", ",", "liver_range", "[", "-", "1", "]", "+", "20", "\n", "if", "start", "<", "0", ":", "\n", "            ", "start", "=", "0", "\n", "", "if", "end", ">", "ArrayImage", ".", "shape", "[", "0", "]", ":", "\n", "            ", "end", "=", "ArrayImage", ".", "shape", "[", "0", "]", "\n", "\n", "", "tumor_range", "=", "np", ".", "where", "(", "ArrayLabel", "==", "2", ")", "\n", "tumor_range", "=", "list", "(", "set", "(", "tumor_range", "[", "0", "]", ")", ")", "\n", "if", "tumor_range", "==", "[", "]", ":", "\n", "            ", "print", "(", "'volume %d has no tumor area.'", "%", "(", "i", ")", ")", "\n", "has_tumor", "=", "False", "\n", "", "else", ":", "\n", "            ", "has_tumor", "=", "True", "\n", "\n", "", "for", "n", "in", "tqdm", "(", "range", "(", "start", ",", "end", ")", ")", ":", "\n", "            ", "slice_dict", "=", "{", "}", "\n", "#\u5207\u7247\u662f\u5426\u542b\u6709\u809d\u810f", "\n", "if", "n", "in", "liver_range", ":", "\n", "                ", "n_liver", ",", "bbox_liver", "=", "get_boundingbox", "(", "label_for_liver", "[", "n", "]", ")", "\n", "has_liver", "=", "True", "\n", "", "else", ":", "\n", "                ", "n_liver", "=", "0", "\n", "has_liver", "=", "False", "\n", "\n", "#\u5207\u7247\u662f\u5426\u542b\u6709\u80bf\u7624", "\n", "", "if", "n", "in", "tumor_range", ":", "\n", "                ", "n_tumor", ",", "bbox_tumor", "=", "get_boundingbox", "(", "label_for_tumor", "[", "n", "]", ")", "\n", "has_tumor", "=", "True", "\n", "", "else", ":", "\n", "                ", "n_tumor", "=", "0", "\n", "has_tumor", "=", "False", "\n", "\n", "", "slice_dict", "=", "{", "'liver'", ":", "ArrayImage", "[", "n", "]", ",", "'seg_label'", ":", "ArrayLabel", "[", "n", "]", ",", "\n", "'has_tumor'", ":", "has_tumor", ",", "'has_liver'", ":", "has_liver", "}", "\n", "for", "s", "in", "range", "(", "n_liver", ")", ":", "\n", "                ", "dict_name", "=", "'bbox_liver_%d'", "%", "(", "s", ")", "\n", "slice_dict", "[", "dict_name", "]", "=", "bbox_liver", "[", "s", "]", "\n", "", "for", "s", "in", "range", "(", "n_tumor", ")", ":", "\n", "                ", "dict_name", "=", "'bbox_tumor_%d'", "%", "(", "s", ")", "\n", "slice_dict", "[", "dict_name", "]", "=", "bbox_tumor", "[", "s", "]", "\n", "\n", "", "path", "=", "'./npy/case{:0>3d}/'", ".", "format", "(", "i", ")", "\n", "if", "not", "os", ".", "path", ".", "exists", "(", "path", ")", ":", "\n", "                ", "os", ".", "mkdir", "(", "path", ")", "\n", "", "if", "has_liver", ":", "\n", "                ", "if", "has_tumor", ":", "\n", "                    ", "flag", "=", "'11'", "\n", "", "else", ":", "\n", "                    ", "flag", "=", "'10'", "\n", "", "", "else", ":", "\n", "                ", "if", "has_tumor", ":", "\n", "                    ", "flag", "=", "'01'", "\n", "", "else", ":", "\n", "                    ", "flag", "=", "'00'", "\n", "", "", "filename", "=", "'{}{:0>3d}_{}.npy'", ".", "format", "(", "path", ",", "n", ",", "flag", ")", "\n", "np", ".", "save", "(", "filename", ",", "slice_dict", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.utils.init_logging.init_logging": [[12, 35], ["logging.getLogger", "logging.getLogger.setLevel", "logging.Formatter", "logging.StreamHandler", "logging.StreamHandler.setLevel", "logging.StreamHandler.setFormatter", "logging.getLogger.addHandler", "logging.FileHandler", "logging.FileHandler.setLevel", "logging.FileHandler.setFormatter", "logging.getLogger.addHandler", "os.path.exists", "os.mkdir", "os.path.exists", "os.mkdir"], "function", ["None"], ["def", "init_logging", "(", "starttime", ",", "log_file", "=", "True", ")", ":", "\n", "    ", "logger", "=", "logging", ".", "getLogger", "(", ")", "\n", "logger", ".", "setLevel", "(", "logging", ".", "INFO", ")", "# Log\u7b49\u7ea7\u603b\u5f00\u5173", "\n", "\n", "formatter", "=", "logging", ".", "Formatter", "(", "\"[%(levelname)s]%(asctime)s: %(message)s\"", ")", "\n", "date", "=", "starttime", "[", ":", "10", "]", "\n", "\n", "if", "log_file", ":", "\n", "        ", "if", "not", "os", ".", "path", ".", "exists", "(", "'./log'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "'./log'", ")", "\n", "", "if", "not", "os", ".", "path", ".", "exists", "(", "f'./log/{date}'", ")", ":", "\n", "            ", "os", ".", "mkdir", "(", "f'./log/{date}'", ")", "\n", "", "fh", "=", "logging", ".", "FileHandler", "(", "f'./log/{date}/{starttime}.txt'", ",", "mode", "=", "'w'", ")", "\n", "fh", ".", "setLevel", "(", "logging", ".", "INFO", ")", "# \u8f93\u51fa\u5230file\u7684log\u7b49\u7ea7\u7684\u5f00\u5173", "\n", "fh", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "fh", ")", "\n", "\n", "", "ch", "=", "logging", ".", "StreamHandler", "(", ")", "\n", "ch", ".", "setLevel", "(", "logging", ".", "INFO", ")", "# \u8f93\u51fa\u5230console\u7684log\u7b49\u7ea7\u7684\u5f00\u5173", "\n", "ch", ".", "setFormatter", "(", "formatter", ")", "\n", "logger", ".", "addHandler", "(", "ch", ")", "\n", "\n", "return", "logger", "", "", ""]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.Identity.forward": [[14, 16], ["None"], "methods", ["None"], ["    ", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.GANLoss.__init__": [[212, 235], ["torch.Module.__init__", "networks.GANLoss.register_buffer", "networks.GANLoss.register_buffer", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.tensor", "torch.MSELoss", "torch.MSELoss", "torch.BCEWithLogitsLoss", "torch.BCEWithLogitsLoss", "NotImplementedError"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "gan_mode", ",", "target_real_label", "=", "1.0", ",", "target_fake_label", "=", "0.0", ")", ":", "\n", "        ", "\"\"\" Initialize the GANLoss class.\n\n        Parameters:\n            gan_mode (str) - - the type of GAN objective. It currently supports vanilla, lsgan, and wgangp.\n            target_real_label (bool) - - label for a real image\n            target_fake_label (bool) - - label of a fake image\n\n        Note: Do not use sigmoid as the last layer of Discriminator.\n        LSGAN needs no sigmoid. vanilla GANs will handle it with BCEWithLogitsLoss.\n        \"\"\"", "\n", "super", "(", "GANLoss", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "register_buffer", "(", "'real_label'", ",", "torch", ".", "tensor", "(", "target_real_label", ")", ")", "\n", "self", ".", "register_buffer", "(", "'fake_label'", ",", "torch", ".", "tensor", "(", "target_fake_label", ")", ")", "\n", "self", ".", "gan_mode", "=", "gan_mode", "\n", "if", "gan_mode", "==", "'lsgan'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "MSELoss", "(", ")", "\n", "", "elif", "gan_mode", "==", "'vanilla'", ":", "\n", "            ", "self", ".", "loss", "=", "nn", ".", "BCEWithLogitsLoss", "(", ")", "\n", "", "elif", "gan_mode", "in", "[", "'wgangp'", "]", ":", "\n", "            ", "self", ".", "loss", "=", "None", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'gan mode %s not implemented'", "%", "gan_mode", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.GANLoss.get_target_tensor": [[236, 252], ["target_tensor.expand_as"], "methods", ["None"], ["", "", "def", "get_target_tensor", "(", "self", ",", "prediction", ",", "target_is_real", ")", ":", "\n", "        ", "\"\"\"Create label tensors with the same size as the input.\n\n        Parameters:\n            prediction (tensor) - - tpyically the prediction from a discriminator\n            target_is_real (bool) - - if the ground truth label is for real images or fake images\n\n        Returns:\n            A label tensor filled with ground truth label, and with the size of the input\n        \"\"\"", "\n", "\n", "if", "target_is_real", ":", "\n", "            ", "target_tensor", "=", "self", ".", "real_label", "\n", "", "else", ":", "\n", "            ", "target_tensor", "=", "self", ".", "fake_label", "\n", "", "return", "target_tensor", ".", "expand_as", "(", "prediction", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.GANLoss.__call__": [[253, 272], ["networks.GANLoss.get_target_tensor", "networks.GANLoss.loss", "prediction.mean", "prediction.mean"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.GANLoss.get_target_tensor"], ["", "def", "__call__", "(", "self", ",", "prediction", ",", "target_is_real", ")", ":", "\n", "        ", "\"\"\"Calculate loss given Discriminator's output and grount truth labels.\n\n        Parameters:\n            prediction (tensor) - - tpyically the prediction output from a discriminator\n            target_is_real (bool) - - if the ground truth label is for real images or fake images\n\n        Returns:\n            the calculated loss.\n        \"\"\"", "\n", "if", "self", ".", "gan_mode", "in", "[", "'lsgan'", ",", "'vanilla'", "]", ":", "\n", "            ", "target_tensor", "=", "self", ".", "get_target_tensor", "(", "prediction", ",", "target_is_real", ")", "\n", "loss", "=", "self", ".", "loss", "(", "prediction", ",", "target_tensor", ")", "\n", "", "elif", "self", ".", "gan_mode", "==", "'wgangp'", ":", "\n", "            ", "if", "target_is_real", ":", "\n", "                ", "loss", "=", "-", "prediction", ".", "mean", "(", ")", "\n", "", "else", ":", "\n", "                ", "loss", "=", "prediction", ".", "mean", "(", ")", "\n", "", "", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.ResnetGenerator.__init__": [[317, 366], ["torch.Module.__init__", "range", "range", "range", "torch.Sequential", "torch.Sequential", "type", "torch.ReflectionPad2d", "torch.ReflectionPad2d", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "torch.ReflectionPad2d", "torch.ReflectionPad2d", "torch.Conv2d", "torch.Conv2d", "torch.Tanh", "torch.Tanh", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "networks.ResnetBlock", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "norm_layer", "torch.ReLU", "torch.ReLU", "int", "int"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "input_nc", ",", "output_nc", ",", "ngf", "=", "64", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ",", "use_dropout", "=", "False", ",", "n_blocks", "=", "6", ",", "padding_type", "=", "'reflect'", ")", ":", "\n", "        ", "\"\"\"Construct a Resnet-based generator\n\n        Parameters:\n            input_nc (int)      -- the number of channels in input images\n            output_nc (int)     -- the number of channels in output images\n            ngf (int)           -- the number of filters in the last conv layer\n            norm_layer          -- normalization layer\n            use_dropout (bool)  -- if use dropout layers\n            n_blocks (int)      -- the number of ResNet blocks\n            padding_type (str)  -- the name of padding layer in conv layers: reflect | replicate | zero\n        \"\"\"", "\n", "assert", "(", "n_blocks", ">=", "0", ")", "\n", "super", "(", "ResnetGenerator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "type", "(", "norm_layer", ")", "==", "functools", ".", "partial", ":", "\n", "            ", "use_bias", "=", "norm_layer", ".", "func", "==", "nn", ".", "InstanceNorm2d", "\n", "", "else", ":", "\n", "            ", "use_bias", "=", "norm_layer", "==", "nn", ".", "InstanceNorm2d", "\n", "\n", "", "model", "=", "[", "nn", ".", "ReflectionPad2d", "(", "3", ")", ",", "\n", "nn", ".", "Conv2d", "(", "input_nc", ",", "ngf", ",", "kernel_size", "=", "7", ",", "padding", "=", "0", ",", "bias", "=", "use_bias", ")", ",", "\n", "norm_layer", "(", "ngf", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", "]", "\n", "\n", "n_downsampling", "=", "2", "\n", "for", "i", "in", "range", "(", "n_downsampling", ")", ":", "# add downsampling layers", "\n", "            ", "mult", "=", "2", "**", "i", "\n", "model", "+=", "[", "nn", ".", "Conv2d", "(", "ngf", "*", "mult", ",", "ngf", "*", "mult", "*", "2", ",", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "use_bias", ")", ",", "\n", "norm_layer", "(", "ngf", "*", "mult", "*", "2", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", "]", "\n", "\n", "", "mult", "=", "2", "**", "n_downsampling", "\n", "for", "i", "in", "range", "(", "n_blocks", ")", ":", "# add ResNet blocks", "\n", "\n", "            ", "model", "+=", "[", "ResnetBlock", "(", "ngf", "*", "mult", ",", "padding_type", "=", "padding_type", ",", "norm_layer", "=", "norm_layer", ",", "use_dropout", "=", "use_dropout", ",", "use_bias", "=", "use_bias", ")", "]", "\n", "\n", "", "for", "i", "in", "range", "(", "n_downsampling", ")", ":", "# add upsampling layers", "\n", "            ", "mult", "=", "2", "**", "(", "n_downsampling", "-", "i", ")", "\n", "model", "+=", "[", "nn", ".", "ConvTranspose2d", "(", "ngf", "*", "mult", ",", "int", "(", "ngf", "*", "mult", "/", "2", ")", ",", "\n", "kernel_size", "=", "3", ",", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "output_padding", "=", "1", ",", "\n", "bias", "=", "use_bias", ")", ",", "\n", "norm_layer", "(", "int", "(", "ngf", "*", "mult", "/", "2", ")", ")", ",", "\n", "nn", ".", "ReLU", "(", "True", ")", "]", "\n", "", "model", "+=", "[", "nn", ".", "ReflectionPad2d", "(", "3", ")", "]", "\n", "model", "+=", "[", "nn", ".", "Conv2d", "(", "ngf", ",", "output_nc", ",", "kernel_size", "=", "7", ",", "padding", "=", "0", ")", "]", "\n", "model", "+=", "[", "nn", ".", "Tanh", "(", ")", "]", "\n", "\n", "self", ".", "model", "=", "nn", ".", "Sequential", "(", "*", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.ResnetGenerator.forward": [[367, 370], ["networks.ResnetGenerator.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"Standard forward\"\"\"", "\n", "return", "self", ".", "model", "(", "input", ")", "+", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.ResnetBlock.__init__": [[375, 385], ["torch.Module.__init__", "networks.ResnetBlock.build_conv_block"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.ResnetBlock.build_conv_block"], ["def", "__init__", "(", "self", ",", "dim", ",", "padding_type", ",", "norm_layer", ",", "use_dropout", ",", "use_bias", ")", ":", "\n", "        ", "\"\"\"Initialize the Resnet block\n\n        A resnet block is a conv block with skip connections\n        We construct a conv block with build_conv_block function,\n        and implement skip connections in <forward> function.\n        Original Resnet paper: https://arxiv.org/pdf/1512.03385.pdf\n        \"\"\"", "\n", "super", "(", "ResnetBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv_block", "=", "self", ".", "build_conv_block", "(", "dim", ",", "padding_type", ",", "norm_layer", ",", "use_dropout", ",", "use_bias", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.ResnetBlock.build_conv_block": [[386, 425], ["torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.ReflectionPad2d", "torch.ReflectionPad2d", "torch.Dropout", "torch.Dropout", "torch.ReflectionPad2d", "torch.ReflectionPad2d", "torch.ReplicationPad2d", "torch.ReplicationPad2d", "NotImplementedError", "torch.ReplicationPad2d", "torch.ReplicationPad2d", "NotImplementedError"], "methods", ["None"], ["", "def", "build_conv_block", "(", "self", ",", "dim", ",", "padding_type", ",", "norm_layer", ",", "use_dropout", ",", "use_bias", ")", ":", "\n", "        ", "\"\"\"Construct a convolutional block.\n\n        Parameters:\n            dim (int)           -- the number of channels in the conv layer.\n            padding_type (str)  -- the name of padding layer: reflect | replicate | zero\n            norm_layer          -- normalization layer\n            use_dropout (bool)  -- if use dropout layers.\n            use_bias (bool)     -- if the conv layer uses bias or not\n\n        Returns a conv block (with a conv layer, a normalization layer, and a non-linearity layer (ReLU))\n        \"\"\"", "\n", "conv_block", "=", "[", "]", "\n", "p", "=", "0", "\n", "if", "padding_type", "==", "'reflect'", ":", "\n", "            ", "conv_block", "+=", "[", "nn", ".", "ReflectionPad2d", "(", "1", ")", "]", "\n", "", "elif", "padding_type", "==", "'replicate'", ":", "\n", "            ", "conv_block", "+=", "[", "nn", ".", "ReplicationPad2d", "(", "1", ")", "]", "\n", "", "elif", "padding_type", "==", "'zero'", ":", "\n", "            ", "p", "=", "1", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'padding [%s] is not implemented'", "%", "padding_type", ")", "\n", "\n", "", "conv_block", "+=", "[", "nn", ".", "Conv2d", "(", "dim", ",", "dim", ",", "kernel_size", "=", "3", ",", "padding", "=", "p", ",", "bias", "=", "use_bias", ")", ",", "norm_layer", "(", "dim", ")", ",", "nn", ".", "ReLU", "(", "True", ")", "]", "\n", "if", "use_dropout", ":", "\n", "            ", "conv_block", "+=", "[", "nn", ".", "Dropout", "(", "0.5", ")", "]", "\n", "\n", "", "p", "=", "0", "\n", "if", "padding_type", "==", "'reflect'", ":", "\n", "            ", "conv_block", "+=", "[", "nn", ".", "ReflectionPad2d", "(", "1", ")", "]", "\n", "", "elif", "padding_type", "==", "'replicate'", ":", "\n", "            ", "conv_block", "+=", "[", "nn", ".", "ReplicationPad2d", "(", "1", ")", "]", "\n", "", "elif", "padding_type", "==", "'zero'", ":", "\n", "            ", "p", "=", "1", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'padding [%s] is not implemented'", "%", "padding_type", ")", "\n", "", "conv_block", "+=", "[", "nn", ".", "Conv2d", "(", "dim", ",", "dim", ",", "kernel_size", "=", "3", ",", "padding", "=", "p", ",", "bias", "=", "use_bias", ")", ",", "norm_layer", "(", "dim", ")", "]", "\n", "\n", "return", "nn", ".", "Sequential", "(", "*", "conv_block", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.ResnetBlock.forward": [[426, 430], ["networks.ResnetBlock.conv_block"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "\"\"\"Forward function (with skip connections)\"\"\"", "\n", "out", "=", "x", "+", "self", ".", "conv_block", "(", "x", ")", "# add skip connections", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.UnetGenerator.__init__": [[435, 458], ["torch.Module.__init__", "networks.UnetSkipConnectionBlock", "range", "networks.UnetSkipConnectionBlock", "networks.UnetSkipConnectionBlock", "networks.UnetSkipConnectionBlock", "networks.UnetSkipConnectionBlock", "networks.UnetSkipConnectionBlock"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "input_nc", ",", "output_nc", ",", "num_downs", ",", "ngf", "=", "64", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ",", "use_dropout", "=", "False", ")", ":", "\n", "        ", "\"\"\"Construct a Unet generator\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            output_nc (int) -- the number of channels in output images\n            num_downs (int) -- the number of downsamplings in UNet. For example, # if |num_downs| == 7,\n                                image of size 128x128 will become of size 1x1 # at the bottleneck\n            ngf (int)       -- the number of filters in the last conv layer\n            norm_layer      -- normalization layer\n\n        We construct the U-Net from the innermost layer to the outermost layer.\n        It is a recursive process.\n        \"\"\"", "\n", "super", "(", "UnetGenerator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "# construct unet structure", "\n", "unet_block", "=", "UnetSkipConnectionBlock", "(", "ngf", "*", "8", ",", "ngf", "*", "8", ",", "input_nc", "=", "None", ",", "submodule", "=", "None", ",", "norm_layer", "=", "norm_layer", ",", "innermost", "=", "True", ")", "# add the innermost layer", "\n", "for", "i", "in", "range", "(", "num_downs", "-", "5", ")", ":", "# add intermediate layers with ngf * 8 filters", "\n", "            ", "unet_block", "=", "UnetSkipConnectionBlock", "(", "ngf", "*", "8", ",", "ngf", "*", "8", ",", "input_nc", "=", "None", ",", "submodule", "=", "unet_block", ",", "norm_layer", "=", "norm_layer", ",", "use_dropout", "=", "use_dropout", ")", "\n", "# gradually reduce the number of filters from ngf * 8 to ngf", "\n", "", "unet_block", "=", "UnetSkipConnectionBlock", "(", "ngf", "*", "4", ",", "ngf", "*", "8", ",", "input_nc", "=", "None", ",", "submodule", "=", "unet_block", ",", "norm_layer", "=", "norm_layer", ")", "\n", "unet_block", "=", "UnetSkipConnectionBlock", "(", "ngf", "*", "2", ",", "ngf", "*", "4", ",", "input_nc", "=", "None", ",", "submodule", "=", "unet_block", ",", "norm_layer", "=", "norm_layer", ")", "\n", "unet_block", "=", "UnetSkipConnectionBlock", "(", "ngf", ",", "ngf", "*", "2", ",", "input_nc", "=", "None", ",", "submodule", "=", "unet_block", ",", "norm_layer", "=", "norm_layer", ")", "\n", "self", ".", "model", "=", "UnetSkipConnectionBlock", "(", "output_nc", ",", "ngf", ",", "input_nc", "=", "input_nc", ",", "submodule", "=", "unet_block", ",", "outermost", "=", "True", ",", "norm_layer", "=", "norm_layer", ")", "# add the outermost layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.UnetGenerator.forward": [[459, 462], ["networks.UnetGenerator.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"Standard forward\"\"\"", "\n", "return", "self", ".", "model", "(", "input", ")", "+", "input", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.UnetSkipConnectionBlock.__init__": [[470, 526], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "norm_layer", "torch.ReLU", "torch.ReLU", "norm_layer", "torch.Sequential", "torch.Sequential", "type", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.Tanh", "torch.Tanh", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.Dropout", "torch.Dropout"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "outer_nc", ",", "inner_nc", ",", "input_nc", "=", "None", ",", "\n", "submodule", "=", "None", ",", "outermost", "=", "False", ",", "innermost", "=", "False", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ",", "use_dropout", "=", "False", ")", ":", "\n", "        ", "\"\"\"Construct a Unet submodule with skip connections.\n\n        Parameters:\n            outer_nc (int) -- the number of filters in the outer conv layer\n            inner_nc (int) -- the number of filters in the inner conv layer\n            input_nc (int) -- the number of channels in input images/features\n            submodule (UnetSkipConnectionBlock) -- previously defined submodules\n            outermost (bool)    -- if this module is the outermost module\n            innermost (bool)    -- if this module is the innermost module\n            norm_layer          -- normalization layer\n            use_dropout (bool)  -- if use dropout layers.\n        \"\"\"", "\n", "super", "(", "UnetSkipConnectionBlock", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "outermost", "=", "outermost", "\n", "if", "type", "(", "norm_layer", ")", "==", "functools", ".", "partial", ":", "\n", "            ", "use_bias", "=", "norm_layer", ".", "func", "==", "nn", ".", "InstanceNorm2d", "\n", "", "else", ":", "\n", "            ", "use_bias", "=", "norm_layer", "==", "nn", ".", "InstanceNorm2d", "\n", "", "if", "input_nc", "is", "None", ":", "\n", "            ", "input_nc", "=", "outer_nc", "\n", "", "downconv", "=", "nn", ".", "Conv2d", "(", "input_nc", ",", "inner_nc", ",", "kernel_size", "=", "4", ",", "\n", "stride", "=", "2", ",", "padding", "=", "1", ",", "bias", "=", "use_bias", ")", "\n", "downrelu", "=", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "\n", "downnorm", "=", "norm_layer", "(", "inner_nc", ")", "\n", "uprelu", "=", "nn", ".", "ReLU", "(", "True", ")", "\n", "upnorm", "=", "norm_layer", "(", "outer_nc", ")", "\n", "\n", "if", "outermost", ":", "\n", "            ", "upconv", "=", "nn", ".", "ConvTranspose2d", "(", "inner_nc", "*", "2", ",", "outer_nc", ",", "\n", "kernel_size", "=", "4", ",", "stride", "=", "2", ",", "\n", "padding", "=", "1", ")", "\n", "down", "=", "[", "downconv", "]", "\n", "up", "=", "[", "uprelu", ",", "upconv", ",", "nn", ".", "Tanh", "(", ")", "]", "\n", "model", "=", "down", "+", "[", "submodule", "]", "+", "up", "\n", "", "elif", "innermost", ":", "\n", "            ", "upconv", "=", "nn", ".", "ConvTranspose2d", "(", "inner_nc", ",", "outer_nc", ",", "\n", "kernel_size", "=", "4", ",", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "bias", "=", "use_bias", ")", "\n", "down", "=", "[", "downrelu", ",", "downconv", "]", "\n", "up", "=", "[", "uprelu", ",", "upconv", ",", "upnorm", "]", "\n", "model", "=", "down", "+", "up", "\n", "", "else", ":", "\n", "            ", "upconv", "=", "nn", ".", "ConvTranspose2d", "(", "inner_nc", "*", "2", ",", "outer_nc", ",", "\n", "kernel_size", "=", "4", ",", "stride", "=", "2", ",", "\n", "padding", "=", "1", ",", "bias", "=", "use_bias", ")", "\n", "down", "=", "[", "downrelu", ",", "downconv", ",", "downnorm", "]", "\n", "up", "=", "[", "uprelu", ",", "upconv", ",", "upnorm", "]", "\n", "\n", "if", "use_dropout", ":", "\n", "                ", "model", "=", "down", "+", "[", "submodule", "]", "+", "up", "+", "[", "nn", ".", "Dropout", "(", "0.5", ")", "]", "\n", "", "else", ":", "\n", "                ", "model", "=", "down", "+", "[", "submodule", "]", "+", "up", "\n", "\n", "", "", "self", ".", "model", "=", "nn", ".", "Sequential", "(", "*", "model", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.UnetSkipConnectionBlock.forward": [[527, 532], ["networks.UnetSkipConnectionBlock.model", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "networks.UnetSkipConnectionBlock.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "outermost", ":", "\n", "            ", "return", "self", ".", "model", "(", "x", ")", "\n", "", "else", ":", "# add skip connections", "\n", "            ", "return", "torch", ".", "cat", "(", "[", "x", ",", "self", ".", "model", "(", "x", ")", "]", ",", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.NLayerDiscriminator.__init__": [[537, 576], ["torch.Module.__init__", "range", "min", "torch.Sequential", "torch.Sequential", "type", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "min", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.LeakyReLU", "torch.LeakyReLU"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "input_nc", ",", "ndf", "=", "64", ",", "n_layers", "=", "3", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ")", ":", "\n", "        ", "\"\"\"Construct a PatchGAN discriminator\n\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            ndf (int)       -- the number of filters in the last conv layer\n            n_layers (int)  -- the number of conv layers in the discriminator\n            norm_layer      -- normalization layer\n        \"\"\"", "\n", "super", "(", "NLayerDiscriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "type", "(", "norm_layer", ")", "==", "functools", ".", "partial", ":", "# no need to use bias as BatchNorm2d has affine parameters", "\n", "            ", "use_bias", "=", "norm_layer", ".", "func", "==", "nn", ".", "InstanceNorm2d", "\n", "", "else", ":", "\n", "            ", "use_bias", "=", "norm_layer", "==", "nn", ".", "InstanceNorm2d", "\n", "\n", "", "kw", "=", "4", "\n", "padw", "=", "1", "\n", "sequence", "=", "[", "nn", ".", "Conv2d", "(", "input_nc", ",", "ndf", ",", "kernel_size", "=", "kw", ",", "stride", "=", "2", ",", "padding", "=", "padw", ")", ",", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "]", "\n", "nf_mult", "=", "1", "\n", "nf_mult_prev", "=", "1", "\n", "for", "n", "in", "range", "(", "1", ",", "n_layers", ")", ":", "# gradually increase the number of filters", "\n", "            ", "nf_mult_prev", "=", "nf_mult", "\n", "nf_mult", "=", "min", "(", "2", "**", "n", ",", "8", ")", "\n", "sequence", "+=", "[", "\n", "nn", ".", "Conv2d", "(", "ndf", "*", "nf_mult_prev", ",", "ndf", "*", "nf_mult", ",", "kernel_size", "=", "kw", ",", "stride", "=", "2", ",", "padding", "=", "padw", ",", "bias", "=", "use_bias", ")", ",", "\n", "norm_layer", "(", "ndf", "*", "nf_mult", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "\n", "]", "\n", "\n", "", "nf_mult_prev", "=", "nf_mult", "\n", "nf_mult", "=", "min", "(", "2", "**", "n_layers", ",", "8", ")", "\n", "sequence", "+=", "[", "\n", "nn", ".", "Conv2d", "(", "ndf", "*", "nf_mult_prev", ",", "ndf", "*", "nf_mult", ",", "kernel_size", "=", "kw", ",", "stride", "=", "1", ",", "padding", "=", "padw", ",", "bias", "=", "use_bias", ")", ",", "\n", "norm_layer", "(", "ndf", "*", "nf_mult", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", "\n", "]", "\n", "\n", "sequence", "+=", "[", "nn", ".", "Conv2d", "(", "ndf", "*", "nf_mult", ",", "1", ",", "kernel_size", "=", "kw", ",", "stride", "=", "1", ",", "padding", "=", "padw", ")", "]", "# output 1 channel prediction map", "\n", "self", ".", "model", "=", "nn", ".", "Sequential", "(", "*", "sequence", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.NLayerDiscriminator.forward": [[577, 580], ["networks.NLayerDiscriminator.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"Standard forward.\"\"\"", "\n", "return", "self", ".", "model", "(", "input", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.PixelDiscriminator.__init__": [[585, 608], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "type", "torch.Conv2d", "torch.Conv2d", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d", "norm_layer", "torch.LeakyReLU", "torch.LeakyReLU", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "input_nc", ",", "ndf", "=", "64", ",", "norm_layer", "=", "nn", ".", "BatchNorm2d", ")", ":", "\n", "        ", "\"\"\"Construct a 1x1 PatchGAN discriminator\n\n        Parameters:\n            input_nc (int)  -- the number of channels in input images\n            ndf (int)       -- the number of filters in the last conv layer\n            norm_layer      -- normalization layer\n        \"\"\"", "\n", "super", "(", "PixelDiscriminator", ",", "self", ")", ".", "__init__", "(", ")", "\n", "if", "type", "(", "norm_layer", ")", "==", "functools", ".", "partial", ":", "# no need to use bias as BatchNorm2d has affine parameters", "\n", "            ", "use_bias", "=", "norm_layer", ".", "func", "==", "nn", ".", "InstanceNorm2d", "\n", "", "else", ":", "\n", "            ", "use_bias", "=", "norm_layer", "==", "nn", ".", "InstanceNorm2d", "\n", "\n", "", "self", ".", "net", "=", "[", "\n", "nn", ".", "Conv2d", "(", "input_nc", ",", "ndf", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "ndf", ",", "ndf", "*", "2", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "use_bias", ")", ",", "\n", "norm_layer", "(", "ndf", "*", "2", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", "0.2", ",", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "ndf", "*", "2", ",", "1", ",", "kernel_size", "=", "1", ",", "stride", "=", "1", ",", "padding", "=", "0", ",", "bias", "=", "use_bias", ")", "]", "\n", "\n", "self", ".", "net", "=", "nn", ".", "Sequential", "(", "*", "self", ".", "net", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.PixelDiscriminator.forward": [[609, 612], ["networks.PixelDiscriminator.net"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "input", ")", ":", "\n", "        ", "\"\"\"Standard forward.\"\"\"", "\n", "return", "self", ".", "net", "(", "input", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.get_norm_layer": [[18, 36], ["functools.partial", "functools.partial", "NotImplementedError", "networks.Identity"], "function", ["None"], ["", "", "def", "get_norm_layer", "(", "norm_type", "=", "'instance'", ")", ":", "\n", "    ", "\"\"\"Return a normalization layer\n\n    Parameters:\n        norm_type (str) -- the name of the normalization layer: batch | instance | none\n\n    For BatchNorm, we use learnable affine parameters and track running statistics (mean/stddev).\n    For InstanceNorm, we do not use learnable affine parameters. We do not track running statistics.\n    \"\"\"", "\n", "if", "norm_type", "==", "'batch'", ":", "\n", "        ", "norm_layer", "=", "functools", ".", "partial", "(", "nn", ".", "BatchNorm2d", ",", "affine", "=", "True", ",", "track_running_stats", "=", "True", ")", "\n", "", "elif", "norm_type", "==", "'instance'", ":", "\n", "        ", "norm_layer", "=", "functools", ".", "partial", "(", "nn", ".", "InstanceNorm2d", ",", "affine", "=", "False", ",", "track_running_stats", "=", "False", ")", "\n", "", "elif", "norm_type", "==", "'none'", ":", "\n", "        ", "def", "norm_layer", "(", "x", ")", ":", "return", "Identity", "(", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'normalization layer [%s] is not found'", "%", "norm_type", ")", "\n", "", "return", "norm_layer", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.get_scheduler": [[38, 65], ["torch.optim.lr_scheduler.LambdaLR", "torch.optim.lr_scheduler.StepLR", "torch.optim.lr_scheduler.ReduceLROnPlateau", "max", "float", "torch.optim.lr_scheduler.CosineAnnealingLR", "NotImplementedError"], "function", ["None"], ["", "def", "get_scheduler", "(", "optimizer", ",", "opt", ")", ":", "\n", "    ", "\"\"\"Return a learning rate scheduler\n\n    Parameters:\n        optimizer          -- the optimizer of the network\n        opt (option class) -- stores all the experiment flags; needs to be a subclass of BaseOptions\uff0e\u3000\n                              opt.lr_policy is the name of learning rate policy: linear | step | plateau | cosine\n\n    For 'linear', we keep the same learning rate for the first <opt.n_epochs> epochs\n    and linearly decay the rate to zero over the next <opt.n_epochs_decay> epochs.\n    For other schedulers (step, plateau, and cosine), we use the default PyTorch schedulers.\n    See https://pytorch.org/docs/stable/optim.html for more details.\n    \"\"\"", "\n", "if", "opt", ".", "lr_policy", "==", "'linear'", ":", "\n", "        ", "def", "lambda_rule", "(", "epoch", ")", ":", "\n", "            ", "lr_l", "=", "1.0", "-", "max", "(", "0", ",", "epoch", "+", "opt", ".", "epoch_count", "-", "opt", ".", "n_epochs", ")", "/", "float", "(", "opt", ".", "n_epochs_decay", "+", "1", ")", "\n", "return", "lr_l", "\n", "", "scheduler", "=", "lr_scheduler", ".", "LambdaLR", "(", "optimizer", ",", "lr_lambda", "=", "lambda_rule", ")", "\n", "", "elif", "opt", ".", "lr_policy", "==", "'step'", ":", "\n", "        ", "scheduler", "=", "lr_scheduler", ".", "StepLR", "(", "optimizer", ",", "step_size", "=", "opt", ".", "lr_decay_iters", ",", "gamma", "=", "0.1", ")", "\n", "", "elif", "opt", ".", "lr_policy", "==", "'plateau'", ":", "\n", "        ", "scheduler", "=", "lr_scheduler", ".", "ReduceLROnPlateau", "(", "optimizer", ",", "mode", "=", "'min'", ",", "factor", "=", "0.2", ",", "threshold", "=", "0.01", ",", "patience", "=", "5", ")", "\n", "", "elif", "opt", ".", "lr_policy", "==", "'cosine'", ":", "\n", "        ", "scheduler", "=", "lr_scheduler", ".", "CosineAnnealingLR", "(", "optimizer", ",", "T_max", "=", "opt", ".", "n_epochs", ",", "eta_min", "=", "0", ")", "\n", "", "else", ":", "\n", "        ", "return", "NotImplementedError", "(", "'learning rate policy [%s] is not implemented'", ",", "opt", ".", "lr_policy", ")", "\n", "", "return", "scheduler", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.init_weights": [[67, 99], ["print", "net.apply", "hasattr", "torch.nn.init.normal_", "hasattr", "torch.nn.init.constant_", "classname.find", "torch.nn.init.normal_", "torch.nn.init.constant_", "classname.find", "classname.find", "torch.nn.init.xavier_normal_", "torch.nn.init.kaiming_normal_", "torch.nn.init.orthogonal_", "NotImplementedError"], "function", ["None"], ["", "def", "init_weights", "(", "net", ",", "init_type", "=", "'normal'", ",", "init_gain", "=", "0.02", ")", ":", "\n", "    ", "\"\"\"Initialize network weights.\n\n    Parameters:\n        net (network)   -- network to be initialized\n        init_type (str) -- the name of an initialization method: normal | xavier | kaiming | orthogonal\n        init_gain (float)    -- scaling factor for normal, xavier and orthogonal.\n\n    We use 'normal' in the original pix2pix and CycleGAN paper. But xavier and kaiming might\n    work better for some applications. Feel free to try yourself.\n    \"\"\"", "\n", "def", "init_func", "(", "m", ")", ":", "# define the initialization function", "\n", "        ", "classname", "=", "m", ".", "__class__", ".", "__name__", "\n", "if", "hasattr", "(", "m", ",", "'weight'", ")", "and", "(", "classname", ".", "find", "(", "'Conv'", ")", "!=", "-", "1", "or", "classname", ".", "find", "(", "'Linear'", ")", "!=", "-", "1", ")", ":", "\n", "            ", "if", "init_type", "==", "'normal'", ":", "\n", "                ", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "0.0", ",", "init_gain", ")", "\n", "", "elif", "init_type", "==", "'xavier'", ":", "\n", "                ", "init", ".", "xavier_normal_", "(", "m", ".", "weight", ".", "data", ",", "gain", "=", "init_gain", ")", "\n", "", "elif", "init_type", "==", "'kaiming'", ":", "\n", "                ", "init", ".", "kaiming_normal_", "(", "m", ".", "weight", ".", "data", ",", "a", "=", "0", ",", "mode", "=", "'fan_in'", ")", "\n", "", "elif", "init_type", "==", "'orthogonal'", ":", "\n", "                ", "init", ".", "orthogonal_", "(", "m", ".", "weight", ".", "data", ",", "gain", "=", "init_gain", ")", "\n", "", "else", ":", "\n", "                ", "raise", "NotImplementedError", "(", "'initialization method [%s] is not implemented'", "%", "init_type", ")", "\n", "", "if", "hasattr", "(", "m", ",", "'bias'", ")", "and", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "init", ".", "constant_", "(", "m", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "", "", "elif", "classname", ".", "find", "(", "'BatchNorm2d'", ")", "!=", "-", "1", ":", "# BatchNorm Layer's weight is not a matrix; only normal distribution applies.", "\n", "            ", "init", ".", "normal_", "(", "m", ".", "weight", ".", "data", ",", "1.0", ",", "init_gain", ")", "\n", "init", ".", "constant_", "(", "m", ".", "bias", ".", "data", ",", "0.0", ")", "\n", "\n", "", "", "print", "(", "'initialize network with %s'", "%", "init_type", ")", "\n", "net", ".", "apply", "(", "init_func", ")", "# apply the initialization function <init_func>", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.init_net": [[101, 114], ["net.cuda", "networks.init_weights"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.init_weights"], ["", "def", "init_net", "(", "net", ",", "init_type", "=", "'normal'", ",", "init_gain", "=", "0.02", ")", ":", "\n", "    ", "\"\"\"Initialize a network: 1. register CPU/GPU device (with multi-GPU support); 2. initialize the network weights\n    Parameters:\n        net (network)      -- the network to be initialized\n        init_type (str)    -- the name of an initialization method: normal | xavier | kaiming | orthogonal\n        gain (float)       -- scaling factor for normal, xavier and orthogonal.\n        gpu_ids (int list) -- which GPUs the network runs on: e.g., 0,1,2\n\n    Return an initialized network.\n    \"\"\"", "\n", "net", ".", "cuda", "(", ")", "\n", "init_weights", "(", "net", ",", "init_type", ",", "init_gain", "=", "init_gain", ")", "\n", "return", "net", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.define_G": [[116, 156], ["networks.get_norm_layer", "networks.init_net", "networks.ResnetGenerator", "networks.ResnetGenerator", "networks.UnetGenerator", "networks.UnetGenerator", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.get_norm_layer", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.init_net"], ["", "def", "define_G", "(", "input_nc", ",", "output_nc", ",", "ngf", ",", "netG", ",", "norm", "=", "'batch'", ",", "use_dropout", "=", "False", ",", "init_type", "=", "'normal'", ",", "init_gain", "=", "0.02", ")", ":", "\n", "    ", "\"\"\"Create a generator\n\n    Parameters:\n        input_nc (int) -- the number of channels in input images\n        output_nc (int) -- the number of channels in output images\n        ngf (int) -- the number of filters in the last conv layer\n        netG (str) -- the architecture's name: resnet_9blocks | resnet_6blocks | unet_256 | unet_128\n        norm (str) -- the name of normalization layers used in the network: batch | instance | none\n        use_dropout (bool) -- if use dropout layers.\n        init_type (str)    -- the name of our initialization method.\n        init_gain (float)  -- scaling factor for normal, xavier and orthogonal.\n\n    Returns a generator\n\n    Our current implementation provides two types of generators:\n        U-Net: [unet_128] (for 128x128 input images) and [unet_256] (for 256x256 input images)\n        The original U-Net paper: https://arxiv.org/abs/1505.04597\n\n        Resnet-based generator: [resnet_6blocks] (with 6 Resnet blocks) and [resnet_9blocks] (with 9 Resnet blocks)\n        Resnet-based generator consists of several Resnet blocks between a few downsampling/upsampling operations.\n        We adapt Torch code from Justin Johnson's neural style transfer project (https://github.com/jcjohnson/fast-neural-style).\n\n\n    The generator has been initialized by <init_net>. It uses RELU for non-linearity.\n    \"\"\"", "\n", "net", "=", "None", "\n", "norm_layer", "=", "get_norm_layer", "(", "norm_type", "=", "norm", ")", "\n", "\n", "if", "netG", "==", "'resnet_9blocks'", ":", "\n", "        ", "net", "=", "ResnetGenerator", "(", "input_nc", ",", "output_nc", ",", "ngf", ",", "norm_layer", "=", "norm_layer", ",", "use_dropout", "=", "use_dropout", ",", "n_blocks", "=", "9", ")", "\n", "", "elif", "netG", "==", "'resnet_6blocks'", ":", "\n", "        ", "net", "=", "ResnetGenerator", "(", "input_nc", ",", "output_nc", ",", "ngf", ",", "norm_layer", "=", "norm_layer", ",", "use_dropout", "=", "use_dropout", ",", "n_blocks", "=", "6", ")", "\n", "", "elif", "netG", "==", "'unet_128'", ":", "\n", "        ", "net", "=", "UnetGenerator", "(", "input_nc", ",", "output_nc", ",", "7", ",", "ngf", ",", "norm_layer", "=", "norm_layer", ",", "use_dropout", "=", "use_dropout", ")", "\n", "", "elif", "netG", "==", "'unet_256'", ":", "\n", "        ", "net", "=", "UnetGenerator", "(", "input_nc", ",", "output_nc", ",", "8", ",", "ngf", ",", "norm_layer", "=", "norm_layer", ",", "use_dropout", "=", "use_dropout", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Generator model name [%s] is not recognized'", "%", "netG", ")", "\n", "", "return", "init_net", "(", "net", ",", "init_type", ",", "init_gain", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.define_D": [[158, 200], ["networks.get_norm_layer", "networks.init_net", "networks.NLayerDiscriminator", "networks.NLayerDiscriminator", "networks.PixelDiscriminator", "NotImplementedError"], "function", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.get_norm_layer", "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.init_net"], ["", "def", "define_D", "(", "input_nc", ",", "ndf", ",", "netD", ",", "n_layers_D", "=", "3", ",", "norm", "=", "'batch'", ",", "init_type", "=", "'normal'", ",", "init_gain", "=", "0.02", ",", "gpu_ids", "=", "[", "]", ")", ":", "\n", "    ", "\"\"\"Create a discriminator\n\n    Parameters:\n        input_nc (int)     -- the number of channels in input images\n        ndf (int)          -- the number of filters in the first conv layer\n        netD (str)         -- the architecture's name: basic | n_layers | pixel\n        n_layers_D (int)   -- the number of conv layers in the discriminator; effective when netD=='n_layers'\n        norm (str)         -- the type of normalization layers used in the network.\n        init_type (str)    -- the name of the initialization method.\n        init_gain (float)  -- scaling factor for normal, xavier and orthogonal.\n        gpu_ids (int list) -- which GPUs the network runs on: e.g., 0,1,2\n\n    Returns a discriminator\n\n    Our current implementation provides three types of discriminators:\n        [basic]: 'PatchGAN' classifier described in the original pix2pix paper.\n        It can classify whether 70\u00d770 overlapping patches are real or fake.\n        Such a patch-level discriminator architecture has fewer parameters\n        than a full-image discriminator and can work on arbitrarily-sized images\n        in a fully convolutional fashion.\n\n        [n_layers]: With this mode, you can specify the number of conv layers in the discriminator\n        with the parameter <n_layers_D> (default=3 as used in [basic] (PatchGAN).)\n\n        [pixel]: 1x1 PixelGAN discriminator can classify whether a pixel is real or not.\n        It encourages greater color diversity but has no effect on spatial statistics.\n\n    The discriminator has been initialized by <init_net>. It uses Leakly RELU for non-linearity.\n    \"\"\"", "\n", "net", "=", "None", "\n", "norm_layer", "=", "get_norm_layer", "(", "norm_type", "=", "norm", ")", "\n", "\n", "if", "netD", "==", "'basic'", ":", "# default PatchGAN classifier", "\n", "        ", "net", "=", "NLayerDiscriminator", "(", "input_nc", ",", "ndf", ",", "n_layers", "=", "3", ",", "norm_layer", "=", "norm_layer", ")", "\n", "", "elif", "netD", "==", "'n_layers'", ":", "# more options", "\n", "        ", "net", "=", "NLayerDiscriminator", "(", "input_nc", ",", "ndf", ",", "n_layers_D", ",", "norm_layer", "=", "norm_layer", ")", "\n", "", "elif", "netD", "==", "'pixel'", ":", "# classify if each pixel is real or fake", "\n", "        ", "net", "=", "PixelDiscriminator", "(", "input_nc", ",", "ndf", ",", "norm_layer", "=", "norm_layer", ")", "\n", "", "else", ":", "\n", "        ", "raise", "NotImplementedError", "(", "'Discriminator model name [%s] is not recognized'", "%", "netD", ")", "\n", "", "return", "init_net", "(", "net", ",", "init_type", ",", "init_gain", ",", "gpu_ids", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.networks.cal_gradient_penalty": [[274, 309], ["interpolatesv.requires_grad_", "netD", "torch.autograd.grad", "torch.autograd.grad", "gradients[].view", "real_data.size", "torch.ones().to", "torch.ones().to", "torch.rand", "torch.rand", "alpha.expand().contiguous().view.expand().contiguous().view", "NotImplementedError", "torch.ones", "torch.ones", "alpha.expand().contiguous().view.expand().contiguous", "netD.size", "alpha.expand().contiguous().view.expand", "real_data.nelement"], "function", ["None"], ["", "", "def", "cal_gradient_penalty", "(", "netD", ",", "real_data", ",", "fake_data", ",", "device", ",", "type", "=", "'mixed'", ",", "constant", "=", "1.0", ",", "lambda_gp", "=", "10.0", ")", ":", "\n", "    ", "\"\"\"Calculate the gradient penalty loss, used in WGAN-GP paper https://arxiv.org/abs/1704.00028\n\n    Arguments:\n        netD (network)              -- discriminator network\n        real_data (tensor array)    -- real images\n        fake_data (tensor array)    -- generated images from the generator\n        device (str)                -- GPU / CPU: from torch.device('cuda:{}'.format(self.gpu_ids[0])) if self.gpu_ids else torch.device('cpu')\n        type (str)                  -- if we mix real and fake data or not [real | fake | mixed].\n        constant (float)            -- the constant used in formula ( ||gradient||_2 - constant)^2\n        lambda_gp (float)           -- weight for this loss\n\n    Returns the gradient penalty loss\n    \"\"\"", "\n", "if", "lambda_gp", ">", "0.0", ":", "\n", "        ", "if", "type", "==", "'real'", ":", "# either use real images, fake images, or a linear interpolation of two.", "\n", "            ", "interpolatesv", "=", "real_data", "\n", "", "elif", "type", "==", "'fake'", ":", "\n", "            ", "interpolatesv", "=", "fake_data", "\n", "", "elif", "type", "==", "'mixed'", ":", "\n", "            ", "alpha", "=", "torch", ".", "rand", "(", "real_data", ".", "shape", "[", "0", "]", ",", "1", ",", "device", "=", "device", ")", "\n", "alpha", "=", "alpha", ".", "expand", "(", "real_data", ".", "shape", "[", "0", "]", ",", "real_data", ".", "nelement", "(", ")", "//", "real_data", ".", "shape", "[", "0", "]", ")", ".", "contiguous", "(", ")", ".", "view", "(", "*", "real_data", ".", "shape", ")", "\n", "interpolatesv", "=", "alpha", "*", "real_data", "+", "(", "(", "1", "-", "alpha", ")", "*", "fake_data", ")", "\n", "", "else", ":", "\n", "            ", "raise", "NotImplementedError", "(", "'{} not implemented'", ".", "format", "(", "type", ")", ")", "\n", "", "interpolatesv", ".", "requires_grad_", "(", "True", ")", "\n", "disc_interpolates", "=", "netD", "(", "interpolatesv", ")", "\n", "gradients", "=", "torch", ".", "autograd", ".", "grad", "(", "outputs", "=", "disc_interpolates", ",", "inputs", "=", "interpolatesv", ",", "\n", "grad_outputs", "=", "torch", ".", "ones", "(", "disc_interpolates", ".", "size", "(", ")", ")", ".", "to", "(", "device", ")", ",", "\n", "create_graph", "=", "True", ",", "retain_graph", "=", "True", ",", "only_inputs", "=", "True", ")", "\n", "gradients", "=", "gradients", "[", "0", "]", ".", "view", "(", "real_data", ".", "size", "(", "0", ")", ",", "-", "1", ")", "# flat the data", "\n", "gradient_penalty", "=", "(", "(", "(", "gradients", "+", "1e-16", ")", ".", "norm", "(", "2", ",", "dim", "=", "1", ")", "-", "constant", ")", "**", "2", ")", ".", "mean", "(", ")", "*", "lambda_gp", "# added eps", "\n", "return", "gradient_penalty", ",", "gradients", "\n", "", "else", ":", "\n", "        ", "return", "0.0", ",", "None", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.DoubleConv_rec.__init__": [[11, 20], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "mid_channels", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "not", "mid_channels", ":", "\n", "            ", "mid_channels", "=", "out_channels", "\n", "", "self", ".", "double_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "mid_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "mid_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.DoubleConv_rec.forward": [[22, 24], ["unet_parts.DoubleConv_rec.double_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "double_conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Down_rec.__init__": [[29, 34], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "unet_parts.DoubleConv_rec"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "maxpool_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "MaxPool2d", "(", "2", ")", ",", "\n", "DoubleConv_rec", "(", "in_channels", ",", "out_channels", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Down_rec.forward": [[36, 38], ["unet_parts.Down_rec.maxpool_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "maxpool_conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Up_rec.__init__": [[43, 53], ["torch.Module.__init__", "torch.Upsample", "torch.Upsample", "torch.Upsample", "unet_parts.DoubleConv_rec", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "unet_parts.DoubleConv_rec"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# if bilinear, use the normal convolutions to reduce the number of channels", "\n", "if", "bilinear", ":", "\n", "            ", "self", ".", "up", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "self", ".", "conv", "=", "DoubleConv_rec", "(", "in_channels", ",", "out_channels", ",", "in_channels", "//", "2", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "up", "=", "nn", ".", "ConvTranspose2d", "(", "in_channels", ",", "in_channels", "//", "2", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "conv", "=", "DoubleConv_rec", "(", "in_channels", ",", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Up_rec.forward": [[55, 68], ["unet_parts.Up_rec.up", "torch.pad", "torch.pad", "torch.pad", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "unet_parts.Up_rec.conv", "x2.size", "torch.pad.size", "x2.size", "torch.pad.size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "x1", "=", "self", ".", "up", "(", "x1", ")", "\n", "# input is CHW", "\n", "diffY", "=", "x2", ".", "size", "(", ")", "[", "2", "]", "-", "x1", ".", "size", "(", ")", "[", "2", "]", "\n", "diffX", "=", "x2", ".", "size", "(", ")", "[", "3", "]", "-", "x1", ".", "size", "(", ")", "[", "3", "]", "\n", "\n", "x1", "=", "F", ".", "pad", "(", "x1", ",", "[", "diffX", "//", "2", ",", "diffX", "-", "diffX", "//", "2", ",", "\n", "diffY", "//", "2", ",", "diffY", "-", "diffY", "//", "2", "]", ")", "\n", "# if you have padding issues, see", "\n", "# https://github.com/HaiyongJiang/U-Net-Pytorch-Unstructured-Buggy/commit/0e854509c2cea854e247a9c615f175f76fbb2e3a", "\n", "# https://github.com/xiaopeng-liao/Pytorch-UNet/commit/8ebac70e633bac59fc22bb5195e513d5832fb3bd", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x2", ",", "x1", "]", ",", "dim", "=", "1", ")", "\n", "return", "self", ".", "conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.DoubleConv.__init__": [[72, 83], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.BatchNorm2d", "torch.ReLU", "torch.ReLU", "torch.ReLU"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "mid_channels", "=", "None", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "if", "not", "mid_channels", ":", "\n", "            ", "mid_channels", "=", "out_channels", "\n", "", "self", ".", "double_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "in_channels", ",", "mid_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "mid_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", ",", "\n", "nn", ".", "Conv2d", "(", "mid_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ",", "\n", "nn", ".", "ReLU", "(", "inplace", "=", "True", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.DoubleConv.forward": [[85, 87], ["unet_parts.DoubleConv.double_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "double_conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Down.__init__": [[92, 97], ["torch.Module.__init__", "torch.Sequential", "torch.Sequential", "torch.Sequential", "torch.MaxPool2d", "torch.MaxPool2d", "torch.MaxPool2d", "unet_parts.DoubleConv"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "maxpool_conv", "=", "nn", ".", "Sequential", "(", "\n", "nn", ".", "MaxPool2d", "(", "2", ")", ",", "\n", "DoubleConv", "(", "in_channels", ",", "out_channels", ")", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Down.forward": [[99, 101], ["unet_parts.Down.maxpool_conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "maxpool_conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Up.__init__": [[106, 116], ["torch.Module.__init__", "torch.Upsample", "torch.Upsample", "torch.Upsample", "unet_parts.DoubleConv", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "torch.ConvTranspose2d", "unet_parts.DoubleConv"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", ")", ".", "__init__", "(", ")", "\n", "\n", "# if bilinear, use the normal convolutions to reduce the number of channels", "\n", "if", "bilinear", ":", "\n", "            ", "self", ".", "up", "=", "nn", ".", "Upsample", "(", "scale_factor", "=", "2", ",", "mode", "=", "'bilinear'", ",", "align_corners", "=", "True", ")", "\n", "self", ".", "conv", "=", "DoubleConv", "(", "in_channels", ",", "out_channels", ",", "in_channels", "//", "2", ")", "\n", "", "else", ":", "\n", "            ", "self", ".", "up", "=", "nn", ".", "ConvTranspose2d", "(", "in_channels", ",", "in_channels", "//", "2", ",", "kernel_size", "=", "2", ",", "stride", "=", "2", ")", "\n", "self", ".", "conv", "=", "DoubleConv", "(", "in_channels", ",", "out_channels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.Up.forward": [[118, 131], ["unet_parts.Up.up", "torch.pad", "torch.pad", "torch.pad", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "unet_parts.Up.conv", "x2.size", "torch.pad.size", "x2.size", "torch.pad.size"], "methods", ["None"], ["", "", "def", "forward", "(", "self", ",", "x1", ",", "x2", ")", ":", "\n", "        ", "x1", "=", "self", ".", "up", "(", "x1", ")", "\n", "# input is CHW", "\n", "diffY", "=", "x2", ".", "size", "(", ")", "[", "2", "]", "-", "x1", ".", "size", "(", ")", "[", "2", "]", "\n", "diffX", "=", "x2", ".", "size", "(", ")", "[", "3", "]", "-", "x1", ".", "size", "(", ")", "[", "3", "]", "\n", "\n", "x1", "=", "F", ".", "pad", "(", "x1", ",", "[", "diffX", "//", "2", ",", "diffX", "-", "diffX", "//", "2", ",", "\n", "diffY", "//", "2", ",", "diffY", "-", "diffY", "//", "2", "]", ")", "\n", "# if you have padding issues, see", "\n", "# https://github.com/HaiyongJiang/U-Net-Pytorch-Unstructured-Buggy/commit/0e854509c2cea854e247a9c615f175f76fbb2e3a", "\n", "# https://github.com/xiaopeng-liao/Pytorch-UNet/commit/8ebac70e633bac59fc22bb5195e513d5832fb3bd", "\n", "x", "=", "torch", ".", "cat", "(", "[", "x2", ",", "x1", "]", ",", "dim", "=", "1", ")", "\n", "return", "self", ".", "conv", "(", "x", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.OutConv.__init__": [[134, 137], ["torch.Module.__init__", "torch.Conv2d", "torch.Conv2d", "torch.Conv2d"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", ",", "out_channels", ")", ":", "\n", "        ", "super", "(", "OutConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "conv", "=", "nn", ".", "Conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "1", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_parts.OutConv.forward": [[138, 140], ["unet_parts.OutConv.conv"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "return", "self", ".", "conv", "(", "x", ")", "\n", "", "", ""]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Reconstucter.__init__": [[9, 33], ["nn.Module.__init__", "unet_parts.DoubleConv_rec", "unet_parts.Down_rec", "unet_parts.Down_rec", "unet_parts.Down_rec", "unet_parts.Down_rec", "unet_parts.Up_rec", "unet_parts.Up_rec", "unet_parts.Up_rec", "unet_parts.Up_rec", "unet_parts.OutConv", "unet_model.Reconstucter.modules", "isinstance", "isinstance", "m.bias.data.zero_", "nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ",", "n_classes", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", "Reconstucter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "bilinear", "=", "bilinear", "\n", "\n", "self", ".", "inc", "=", "DoubleConv_rec", "(", "n_channels", ",", "16", ")", "\n", "self", ".", "down1", "=", "Down_rec", "(", "16", ",", "32", ")", "\n", "self", ".", "down2", "=", "Down_rec", "(", "32", ",", "64", ")", "\n", "self", ".", "down3", "=", "Down_rec", "(", "64", ",", "128", ")", "\n", "factor", "=", "2", "if", "bilinear", "else", "1", "\n", "self", ".", "down4", "=", "Down_rec", "(", "128", ",", "256", "//", "factor", ")", "\n", "self", ".", "up1", "=", "Up_rec", "(", "256", ",", "128", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up2", "=", "Up_rec", "(", "128", ",", "64", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up3", "=", "Up_rec", "(", "64", ",", "32", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up4", "=", "Up_rec", "(", "32", ",", "16", ",", "bilinear", ")", "\n", "self", ".", "outc", "=", "OutConv", "(", "16", ",", "n_classes", ")", "\n", "# initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Reconstucter.forward": [[34, 46], ["unet_model.Reconstucter.inc", "unet_model.Reconstucter.down1", "unet_model.Reconstucter.down2", "unet_model.Reconstucter.down3", "unet_model.Reconstucter.down4", "unet_model.Reconstucter.up1", "unet_model.Reconstucter.up2", "unet_model.Reconstucter.up3", "unet_model.Reconstucter.up4", "unet_model.Reconstucter.outc"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "self", ".", "inc", "(", "x", ")", "\n", "x2", "=", "self", ".", "down1", "(", "x1", ")", "\n", "x3", "=", "self", ".", "down2", "(", "x2", ")", "\n", "x4", "=", "self", ".", "down3", "(", "x3", ")", "\n", "x5", "=", "self", ".", "down4", "(", "x4", ")", "\n", "x", "=", "self", ".", "up1", "(", "x5", ",", "x4", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ",", "x3", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ",", "x2", ")", "\n", "x", "=", "self", ".", "up4", "(", "x", ",", "x1", ")", "\n", "logits", "=", "self", ".", "outc", "(", "x", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter.__init__": [[48, 72], ["nn.Module.__init__", "unet_parts.DoubleConv", "unet_parts.Down", "unet_parts.Down", "unet_parts.Down", "unet_parts.Down", "unet_parts.Up", "unet_parts.Up", "unet_parts.Up", "unet_parts.Up", "unet_parts.OutConv", "unet_model.Segmenter.modules", "isinstance", "isinstance", "m.bias.data.zero_", "nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ",", "n_classes", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", "Segmenter", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "bilinear", "=", "bilinear", "\n", "\n", "self", ".", "inc", "=", "DoubleConv", "(", "n_channels", ",", "64", ")", "\n", "self", ".", "down1", "=", "Down", "(", "64", ",", "128", ")", "\n", "self", ".", "down2", "=", "Down", "(", "128", ",", "256", ")", "\n", "self", ".", "down3", "=", "Down", "(", "256", ",", "512", ")", "\n", "factor", "=", "2", "if", "bilinear", "else", "1", "\n", "self", ".", "down4", "=", "Down", "(", "512", ",", "1024", "//", "factor", ")", "\n", "self", ".", "up1", "=", "Up", "(", "1024", ",", "512", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up2", "=", "Up", "(", "512", ",", "256", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up3", "=", "Up", "(", "256", ",", "128", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up4", "=", "Up", "(", "128", ",", "64", ",", "bilinear", ")", "\n", "self", ".", "outc", "=", "OutConv", "(", "64", ",", "n_classes", ")", "\n", "# initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter.forward": [[73, 85], ["unet_model.Segmenter.inc", "unet_model.Segmenter.down1", "unet_model.Segmenter.down2", "unet_model.Segmenter.down3", "unet_model.Segmenter.down4", "unet_model.Segmenter.up1", "unet_model.Segmenter.up2", "unet_model.Segmenter.up3", "unet_model.Segmenter.up4", "unet_model.Segmenter.outc"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "self", ".", "inc", "(", "x", ")", "\n", "x2", "=", "self", ".", "down1", "(", "x1", ")", "\n", "x3", "=", "self", ".", "down2", "(", "x2", ")", "\n", "x4", "=", "self", ".", "down3", "(", "x3", ")", "\n", "x5", "=", "self", ".", "down4", "(", "x4", ")", "\n", "x", "=", "self", ".", "up1", "(", "x5", ",", "x4", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ",", "x3", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ",", "x2", ")", "\n", "x", "=", "self", ".", "up4", "(", "x", ",", "x1", ")", "\n", "logits", "=", "self", ".", "outc", "(", "x", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_32channel.__init__": [[87, 111], ["nn.Module.__init__", "unet_parts.DoubleConv", "unet_parts.Down", "unet_parts.Down", "unet_parts.Down", "unet_parts.Down", "unet_parts.Up", "unet_parts.Up", "unet_parts.Up", "unet_parts.Up", "unet_parts.OutConv", "unet_model.Segmenter_32channel.modules", "isinstance", "isinstance", "m.bias.data.zero_", "nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ",", "n_classes", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", "Segmenter_32channel", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "bilinear", "=", "bilinear", "\n", "\n", "self", ".", "inc", "=", "DoubleConv", "(", "n_channels", ",", "32", ")", "\n", "self", ".", "down1", "=", "Down", "(", "32", ",", "64", ")", "\n", "self", ".", "down2", "=", "Down", "(", "64", ",", "128", ")", "\n", "self", ".", "down3", "=", "Down", "(", "128", ",", "256", ")", "\n", "factor", "=", "2", "if", "bilinear", "else", "1", "\n", "self", ".", "down4", "=", "Down", "(", "256", ",", "512", "//", "factor", ")", "\n", "self", ".", "up1", "=", "Up", "(", "512", ",", "256", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up2", "=", "Up", "(", "256", ",", "128", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up3", "=", "Up", "(", "128", ",", "64", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up4", "=", "Up", "(", "64", ",", "32", ",", "bilinear", ")", "\n", "self", ".", "outc", "=", "OutConv", "(", "32", ",", "n_classes", ")", "\n", "# initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_32channel.forward": [[112, 124], ["unet_model.Segmenter_32channel.inc", "unet_model.Segmenter_32channel.down1", "unet_model.Segmenter_32channel.down2", "unet_model.Segmenter_32channel.down3", "unet_model.Segmenter_32channel.down4", "unet_model.Segmenter_32channel.up1", "unet_model.Segmenter_32channel.up2", "unet_model.Segmenter_32channel.up3", "unet_model.Segmenter_32channel.up4", "unet_model.Segmenter_32channel.outc"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "self", ".", "inc", "(", "x", ")", "\n", "x2", "=", "self", ".", "down1", "(", "x1", ")", "\n", "x3", "=", "self", ".", "down2", "(", "x2", ")", "\n", "x4", "=", "self", ".", "down3", "(", "x3", ")", "\n", "x5", "=", "self", ".", "down4", "(", "x4", ")", "\n", "x", "=", "self", ".", "up1", "(", "x5", ",", "x4", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ",", "x3", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ",", "x2", ")", "\n", "x", "=", "self", ".", "up4", "(", "x", ",", "x1", ")", "\n", "logits", "=", "self", ".", "outc", "(", "x", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_3layer.__init__": [[127, 149], ["nn.Module.__init__", "unet_parts.DoubleConv", "unet_parts.Down", "unet_parts.Down", "unet_parts.Down", "unet_parts.Up", "unet_parts.Up", "unet_parts.Up", "unet_parts.OutConv", "unet_model.Segmenter_3layer.modules", "isinstance", "isinstance", "m.bias.data.zero_", "nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ",", "n_classes", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", "Segmenter_3layer", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "bilinear", "=", "bilinear", "\n", "\n", "self", ".", "inc", "=", "DoubleConv", "(", "n_channels", ",", "64", ")", "\n", "self", ".", "down1", "=", "Down", "(", "64", ",", "128", ")", "\n", "self", ".", "down2", "=", "Down", "(", "128", ",", "256", ")", "\n", "factor", "=", "2", "if", "bilinear", "else", "1", "\n", "self", ".", "down3", "=", "Down", "(", "256", ",", "512", "//", "factor", ")", "\n", "self", ".", "up1", "=", "Up", "(", "512", ",", "256", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up2", "=", "Up", "(", "256", ",", "128", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up3", "=", "Up", "(", "128", ",", "64", ",", "bilinear", ")", "\n", "self", ".", "outc", "=", "OutConv", "(", "64", ",", "n_classes", ")", "\n", "# initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_3layer.forward": [[150, 160], ["unet_model.Segmenter_3layer.inc", "unet_model.Segmenter_3layer.down1", "unet_model.Segmenter_3layer.down2", "unet_model.Segmenter_3layer.down3", "unet_model.Segmenter_3layer.up1", "unet_model.Segmenter_3layer.up2", "unet_model.Segmenter_3layer.up3", "unet_model.Segmenter_3layer.outc"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "self", ".", "inc", "(", "x", ")", "\n", "x2", "=", "self", ".", "down1", "(", "x1", ")", "\n", "x3", "=", "self", ".", "down2", "(", "x2", ")", "\n", "x4", "=", "self", ".", "down3", "(", "x3", ")", "\n", "x", "=", "self", ".", "up1", "(", "x4", ",", "x3", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ",", "x2", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ",", "x1", ")", "\n", "logits", "=", "self", ".", "outc", "(", "x", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__": [[162, 185], ["nn.Module.__init__", "unet_parts.DoubleConv", "unet_parts.Down", "unet_parts.Down", "unet_parts.Down", "unet_parts.Up", "unet_parts.Up", "unet_parts.Up", "unet_parts.OutConv", "unet_model.Segmenter_lite.modules", "isinstance", "isinstance", "m.bias.data.zero_", "nn.init.kaiming_uniform_"], "methods", ["home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.__init__"], ["    ", "def", "__init__", "(", "self", ",", "n_channels", ",", "n_classes", ",", "bilinear", "=", "True", ")", ":", "\n", "        ", "super", "(", "Segmenter_lite", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "n_channels", "=", "n_channels", "\n", "self", ".", "n_classes", "=", "n_classes", "\n", "self", ".", "bilinear", "=", "bilinear", "\n", "self", ".", "base_channel", "=", "32", "\n", "\n", "self", ".", "inc", "=", "DoubleConv", "(", "n_channels", ",", "self", ".", "base_channel", ")", "\n", "self", ".", "down1", "=", "Down", "(", "self", ".", "base_channel", ",", "self", ".", "base_channel", "*", "2", ")", "\n", "self", ".", "down2", "=", "Down", "(", "self", ".", "base_channel", "*", "2", ",", "self", ".", "base_channel", "*", "4", ")", "\n", "factor", "=", "2", "if", "bilinear", "else", "1", "\n", "self", ".", "down3", "=", "Down", "(", "self", ".", "base_channel", "*", "4", ",", "self", ".", "base_channel", "*", "8", "//", "factor", ")", "\n", "self", ".", "up1", "=", "Up", "(", "self", ".", "base_channel", "*", "8", ",", "self", ".", "base_channel", "*", "4", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up2", "=", "Up", "(", "self", ".", "base_channel", "*", "4", ",", "self", ".", "base_channel", "*", "2", "//", "factor", ",", "bilinear", ")", "\n", "self", ".", "up3", "=", "Up", "(", "self", ".", "base_channel", "*", "2", ",", "self", ".", "base_channel", ",", "bilinear", ")", "\n", "self", ".", "outc", "=", "OutConv", "(", "self", ".", "base_channel", ",", "n_classes", ")", "\n", "# initialization", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "if", "isinstance", "(", "m", ",", "nn", ".", "Conv2d", ")", "or", "isinstance", "(", "m", ",", "nn", ".", "ConvTranspose2d", ")", ":", "\n", "                ", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "m", ".", "bias", ".", "data", ".", "zero_", "(", ")", "\n", "", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                    ", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ",", "mode", "=", "'fan_out'", ",", "nonlinearity", "=", "'relu'", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.Au3C2_Generator-Versus-Segmentor.unet.unet_model.Segmenter_lite.forward": [[186, 196], ["unet_model.Segmenter_lite.inc", "unet_model.Segmenter_lite.down1", "unet_model.Segmenter_lite.down2", "unet_model.Segmenter_lite.down3", "unet_model.Segmenter_lite.up1", "unet_model.Segmenter_lite.up2", "unet_model.Segmenter_lite.up3", "unet_model.Segmenter_lite.outc"], "methods", ["None"], ["", "", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "x1", "=", "self", ".", "inc", "(", "x", ")", "\n", "x2", "=", "self", ".", "down1", "(", "x1", ")", "\n", "x3", "=", "self", ".", "down2", "(", "x2", ")", "\n", "x4", "=", "self", ".", "down3", "(", "x3", ")", "\n", "x", "=", "self", ".", "up1", "(", "x4", ",", "x3", ")", "\n", "x", "=", "self", ".", "up2", "(", "x", ",", "x2", ")", "\n", "x", "=", "self", ".", "up3", "(", "x", ",", "x1", ")", "\n", "logits", "=", "self", ".", "outc", "(", "x", ")", "\n", "return", "logits", "", "", "", ""]]}