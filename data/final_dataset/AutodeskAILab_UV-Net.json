{"home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.num_classes": [[11, 15], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "@", "abstractmethod", "\n", "def", "num_classes", "(", ")", ":", "\n", "        ", "pass", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.load_graphs": [[16, 31], ["tqdm.tqdm.tqdm", "base.BaseDataset.convert_to_float32", "base.BaseDataset.load_one_graph", "base.BaseDataset.data.append", "base.BaseDataset.center_and_scale", "fn.exists", "sample[].edata[].size"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.convert_to_float32", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.load_one_graph", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.center_and_scale"], ["", "def", "load_graphs", "(", "self", ",", "file_paths", ",", "center_and_scale", "=", "True", ")", ":", "\n", "        ", "self", ".", "data", "=", "[", "]", "\n", "for", "fn", "in", "tqdm", "(", "file_paths", ")", ":", "\n", "            ", "if", "not", "fn", ".", "exists", "(", ")", ":", "\n", "                ", "continue", "\n", "", "sample", "=", "self", ".", "load_one_graph", "(", "fn", ")", "\n", "if", "sample", "is", "None", ":", "\n", "                ", "continue", "\n", "", "if", "sample", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", ".", "size", "(", "0", ")", "==", "0", ":", "\n", "# Catch the case of graphs with no edges", "\n", "                ", "continue", "\n", "", "self", ".", "data", ".", "append", "(", "sample", ")", "\n", "", "if", "center_and_scale", ":", "\n", "            ", "self", ".", "center_and_scale", "(", ")", "\n", "", "self", ".", "convert_to_float32", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.load_one_graph": [[32, 36], ["dgl.data.utils.load_graphs", "str"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.load_graphs"], ["", "def", "load_one_graph", "(", "self", ",", "file_path", ")", ":", "\n", "        ", "graph", "=", "load_graphs", "(", "str", "(", "file_path", ")", ")", "[", "0", "]", "[", "0", "]", "\n", "sample", "=", "{", "\"graph\"", ":", "graph", ",", "\"filename\"", ":", "file_path", ".", "stem", "}", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.center_and_scale": [[37, 44], ["range", "len", "datasets.util.center_and_scale_uvgrid"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.center_and_scale_uvgrid"], ["", "def", "center_and_scale", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "data", ")", ")", ":", "\n", "            ", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "ndata", "[", "\"x\"", "]", ",", "center", ",", "scale", "=", "util", ".", "center_and_scale_uvgrid", "(", "\n", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "ndata", "[", "\"x\"", "]", ",", "return_center_scale", "=", "True", "\n", ")", "\n", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", "[", "...", ",", ":", "3", "]", "-=", "center", "\n", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", "[", "...", ",", ":", "3", "]", "*=", "scale", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.convert_to_float32": [[45, 49], ["range", "len", "[].ndata[].type", "[].edata[].type"], "methods", ["None"], ["", "", "def", "convert_to_float32", "(", "self", ")", ":", "\n", "        ", "for", "i", "in", "range", "(", "len", "(", "self", ".", "data", ")", ")", ":", "\n", "            ", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "ndata", "[", "\"x\"", "]", "=", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "ndata", "[", "\"x\"", "]", ".", "type", "(", "FloatTensor", ")", "\n", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", "=", "self", ".", "data", "[", "i", "]", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", ".", "type", "(", "FloatTensor", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.__len__": [[50, 52], ["len"], "methods", ["None"], ["", "", "def", "__len__", "(", "self", ")", ":", "\n", "        ", "return", "len", "(", "self", ".", "data", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.__getitem__": [[53, 60], ["datasets.util.get_random_rotation", "datasets.util.rotate_uvgrid", "datasets.util.rotate_uvgrid"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.get_random_rotation", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.rotate_uvgrid", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.rotate_uvgrid"], ["", "def", "__getitem__", "(", "self", ",", "idx", ")", ":", "\n", "        ", "sample", "=", "self", ".", "data", "[", "idx", "]", "\n", "if", "self", ".", "random_rotate", ":", "\n", "            ", "rotation", "=", "util", ".", "get_random_rotation", "(", ")", "\n", "sample", "[", "\"graph\"", "]", ".", "ndata", "[", "\"x\"", "]", "=", "util", ".", "rotate_uvgrid", "(", "sample", "[", "\"graph\"", "]", ".", "ndata", "[", "\"x\"", "]", ",", "rotation", ")", "\n", "sample", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", "=", "util", ".", "rotate_uvgrid", "(", "sample", "[", "\"graph\"", "]", ".", "edata", "[", "\"x\"", "]", ",", "rotation", ")", "\n", "", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset._collate": [[61, 65], ["dgl.batch"], "methods", ["None"], ["", "def", "_collate", "(", "self", ",", "batch", ")", ":", "\n", "        ", "batched_graph", "=", "dgl", ".", "batch", "(", "[", "sample", "[", "\"graph\"", "]", "for", "sample", "in", "batch", "]", ")", "\n", "batched_filenames", "=", "[", "sample", "[", "\"filename\"", "]", "for", "sample", "in", "batch", "]", "\n", "return", "{", "\"graph\"", ":", "batched_graph", ",", "\"filename\"", ":", "batched_filenames", "}", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.get_dataloader": [[66, 74], ["torch.utils.data.DataLoader"], "methods", ["None"], ["", "def", "get_dataloader", "(", "self", ",", "batch_size", "=", "128", ",", "shuffle", "=", "True", ",", "num_workers", "=", "0", ")", ":", "\n", "        ", "return", "DataLoader", "(", "\n", "self", ",", "\n", "batch_size", "=", "batch_size", ",", "\n", "shuffle", "=", "shuffle", ",", "\n", "collate_fn", "=", "self", ".", "_collate", ",", "\n", "num_workers", "=", "num_workers", ",", "# Can be set to non-zero on Linux", "\n", "drop_last", "=", "True", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters.SolidLetters.num_classes": [[31, 34], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "num_classes", "(", ")", ":", "\n", "        ", "return", "26", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters.SolidLetters.__init__": [[35, 73], ["pathlib.Path", "print", "solidletters.SolidLetters.load_graphs", "print", "solidletters._get_filenames", "sklearn.model_selection.train_test_split", "solidletters._char_to_label", "solidletters._get_filenames", "len"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.load_graphs", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters._get_filenames", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters._char_to_label", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters._get_filenames"], ["", "def", "__init__", "(", "\n", "self", ",", "\n", "root_dir", ",", "\n", "split", "=", "\"train\"", ",", "\n", "center_and_scale", "=", "True", ",", "\n", "random_rotate", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Load the SolidLetters dataset\n\n        Args:\n            root_dir (str): Root path to the dataset\n            split (str, optional): Split (train, val, or test) to load. Defaults to \"train\".\n            center_and_scale (bool, optional): Whether to center and scale the solid. Defaults to True.\n            random_rotate (bool, optional): Whether to apply random rotations to the solid in 90 degree increments. Defaults to False.\n        \"\"\"", "\n", "assert", "split", "in", "(", "\"train\"", ",", "\"val\"", ",", "\"test\"", ")", "\n", "path", "=", "pathlib", ".", "Path", "(", "root_dir", ")", "\n", "\n", "self", ".", "random_rotate", "=", "random_rotate", "\n", "\n", "if", "split", "in", "(", "\"train\"", ",", "\"val\"", ")", ":", "\n", "            ", "file_paths", "=", "_get_filenames", "(", "path", ",", "filelist", "=", "\"train.txt\"", ")", "\n", "# The first character of filename must be the alphabet", "\n", "labels", "=", "[", "_char_to_label", "(", "fn", ".", "stem", "[", "0", "]", ")", "for", "fn", "in", "file_paths", "]", "\n", "train_files", ",", "val_files", "=", "train_test_split", "(", "\n", "file_paths", ",", "test_size", "=", "0.2", ",", "random_state", "=", "42", ",", "stratify", "=", "labels", ",", "\n", ")", "\n", "if", "split", "==", "\"train\"", ":", "\n", "                ", "file_paths", "=", "train_files", "\n", "", "elif", "split", "==", "\"val\"", ":", "\n", "                ", "file_paths", "=", "val_files", "\n", "", "", "elif", "split", "==", "\"test\"", ":", "\n", "            ", "file_paths", "=", "_get_filenames", "(", "path", ",", "filelist", "=", "\"test.txt\"", ")", "\n", "\n", "", "print", "(", "f\"Loading {split} data...\"", ")", "\n", "self", ".", "load_graphs", "(", "file_paths", ",", "center_and_scale", ")", "\n", "print", "(", "\"Done loading {} files\"", ".", "format", "(", "len", "(", "self", ".", "data", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters.SolidLetters.load_one_graph": [[74, 80], ["super().load_one_graph", "torch.tensor().long", "torch.tensor", "solidletters._char_to_label"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.load_one_graph", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters._char_to_label"], ["", "def", "load_one_graph", "(", "self", ",", "file_path", ")", ":", "\n", "# Load the graph using base class method", "\n", "        ", "sample", "=", "super", "(", ")", ".", "load_one_graph", "(", "file_path", ")", "\n", "# Additionally get the label from the filename and store it in the sample dict", "\n", "sample", "[", "\"label\"", "]", "=", "torch", ".", "tensor", "(", "[", "_char_to_label", "(", "file_path", ".", "stem", "[", "0", "]", ")", "]", ")", ".", "long", "(", ")", "\n", "return", "sample", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters.SolidLetters._collate": [[81, 85], ["super()._collate", "torch.cat"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters.SolidLetters._collate"], ["", "def", "_collate", "(", "self", ",", "batch", ")", ":", "\n", "        ", "collated", "=", "super", "(", ")", ".", "_collate", "(", "batch", ")", "\n", "collated", "[", "\"label\"", "]", "=", "torch", ".", "cat", "(", "[", "x", "[", "\"label\"", "]", "for", "x", "in", "batch", "]", ",", "dim", "=", "0", ")", "\n", "return", "collated", "\n", "", "", ""]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters._get_filenames": [[10, 21], ["list", "open", "str", "x.strip", "f.readlines", "root_dir.rglob"], "function", ["None"], ["def", "_get_filenames", "(", "root_dir", ",", "filelist", ")", ":", "\n", "    ", "with", "open", "(", "str", "(", "root_dir", "/", "f\"{filelist}\"", ")", ",", "\"r\"", ")", "as", "f", ":", "\n", "        ", "file_list", "=", "[", "x", ".", "strip", "(", ")", "for", "x", "in", "f", ".", "readlines", "(", ")", "]", "\n", "\n", "", "files", "=", "list", "(", "\n", "x", "\n", "for", "x", "in", "root_dir", ".", "rglob", "(", "f\"*.bin\"", ")", "\n", "if", "x", ".", "stem", "in", "file_list", "\n", "#if util.valid_font(x) and x.stem in file_list", "\n", ")", "\n", "return", "files", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.solidletters._char_to_label": [[26, 28], ["char.lower"], "function", ["None"], ["def", "_char_to_label", "(", "char", ")", ":", "\n", "    ", "return", "CHAR2LABEL", "[", "char", ".", "lower", "(", ")", "]", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.bounding_box_uvgrid": [[8, 14], ["inp[].reshape", "inp[].reshape", "util.bounding_box_pointcloud"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.bounding_box_pointcloud"], ["def", "bounding_box_uvgrid", "(", "inp", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "pts", "=", "inp", "[", "...", ",", ":", "3", "]", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "mask", "=", "inp", "[", "...", ",", "6", "]", ".", "reshape", "(", "-", "1", ")", "\n", "point_indices_inside_faces", "=", "mask", "==", "1", "\n", "pts", "=", "pts", "[", "point_indices_inside_faces", ",", ":", "]", "\n", "return", "bounding_box_pointcloud", "(", "pts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.bounding_box_pointcloud": [[16, 22], ["torch.tensor", "x.min", "y.min", "z.min", "x.max", "y.max", "z.max"], "function", ["None"], ["", "def", "bounding_box_pointcloud", "(", "pts", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "x", "=", "pts", "[", ":", ",", "0", "]", "\n", "y", "=", "pts", "[", ":", ",", "1", "]", "\n", "z", "=", "pts", "[", ":", ",", "2", "]", "\n", "box", "=", "[", "[", "x", ".", "min", "(", ")", ",", "y", ".", "min", "(", ")", ",", "z", ".", "min", "(", ")", "]", ",", "[", "x", ".", "max", "(", ")", ",", "y", ".", "max", "(", ")", ",", "z", ".", "max", "(", ")", "]", "]", "\n", "return", "torch", ".", "tensor", "(", "box", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.center_and_scale_uvgrid": [[24, 34], ["util.bounding_box_uvgrid", "max"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.bounding_box_uvgrid"], ["", "def", "center_and_scale_uvgrid", "(", "inp", ":", "torch", ".", "Tensor", ",", "return_center_scale", "=", "False", ")", ":", "\n", "    ", "bbox", "=", "bounding_box_uvgrid", "(", "inp", ")", "\n", "diag", "=", "bbox", "[", "1", "]", "-", "bbox", "[", "0", "]", "\n", "scale", "=", "2.0", "/", "max", "(", "diag", "[", "0", "]", ",", "diag", "[", "1", "]", ",", "diag", "[", "2", "]", ")", "\n", "center", "=", "0.5", "*", "(", "bbox", "[", "0", "]", "+", "bbox", "[", "1", "]", ")", "\n", "inp", "[", "...", ",", ":", "3", "]", "-=", "center", "\n", "inp", "[", "...", ",", ":", "3", "]", "*=", "scale", "\n", "if", "return_center_scale", ":", "\n", "        ", "return", "inp", ",", "center", ",", "scale", "\n", "", "return", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.get_random_rotation": [[36, 47], ["random.choice", "numpy.radians", "scipy.spatial.transform.Rotation.from_rotvec", "numpy.array", "numpy.array", "numpy.array", "random.choice"], "function", ["None"], ["", "def", "get_random_rotation", "(", ")", ":", "\n", "    ", "\"\"\"Get a random rotation in 90 degree increments along the canonical axes\"\"\"", "\n", "axes", "=", "[", "\n", "np", ".", "array", "(", "[", "1", ",", "0", ",", "0", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "0", ",", "1", ",", "0", "]", ")", ",", "\n", "np", ".", "array", "(", "[", "0", ",", "0", ",", "1", "]", ")", ",", "\n", "]", "\n", "angles", "=", "[", "0.0", ",", "90.0", ",", "180.0", ",", "270.0", "]", "\n", "axis", "=", "random", ".", "choice", "(", "axes", ")", "\n", "angle_radians", "=", "np", ".", "radians", "(", "random", ".", "choice", "(", "angles", ")", ")", "\n", "return", "Rotation", ".", "from_rotvec", "(", "angle_radians", "*", "axis", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.rotate_uvgrid": [[49, 60], ["torch.tensor().float", "inp[].size", "torch.mm().view", "torch.mm().view", "torch.tensor", "torch.mm", "torch.mm", "rotation.as_matrix", "inp[].view", "inp[].view"], "function", ["None"], ["", "def", "rotate_uvgrid", "(", "inp", ",", "rotation", ")", ":", "\n", "    ", "\"\"\"Rotate the node features in the graph by a given rotation\"\"\"", "\n", "Rmat", "=", "torch", ".", "tensor", "(", "rotation", ".", "as_matrix", "(", ")", ")", ".", "float", "(", ")", "\n", "orig_size", "=", "inp", "[", "...", ",", ":", "3", "]", ".", "size", "(", ")", "\n", "inp", "[", "...", ",", ":", "3", "]", "=", "torch", ".", "mm", "(", "inp", "[", "...", ",", ":", "3", "]", ".", "view", "(", "-", "1", ",", "3", ")", ",", "Rmat", ")", ".", "view", "(", "\n", "orig_size", "\n", ")", "# Points", "\n", "inp", "[", "...", ",", "3", ":", "6", "]", "=", "torch", ".", "mm", "(", "inp", "[", "...", ",", "3", ":", "6", "]", ".", "view", "(", "-", "1", ",", "3", ")", ",", "Rmat", ")", ".", "view", "(", "\n", "orig_size", "\n", ")", "# Normals/tangents", "\n", "return", "inp", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.util.valid_font": [[147, 152], ["name.lower", "str().lower", "str"], "function", ["None"], ["def", "valid_font", "(", "filename", ")", ":", "\n", "    ", "for", "name", "in", "INVALID_FONTS", ":", "\n", "        ", "if", "name", ".", "lower", "(", ")", "in", "str", "(", "filename", ")", ".", "lower", "(", ")", ":", "\n", "            ", "return", "False", "\n", "", "", "return", "True", "\n", "", ""]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.mfcad.MFCADDataset.num_classes": [[8, 11], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "num_classes", "(", ")", ":", "\n", "        ", "return", "16", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.mfcad.MFCADDataset.__init__": [[12, 55], ["pathlib.Path", "print", "mfcad.MFCADDataset.load_graphs", "print", "open", "json.load", "all_files.append", "str", "pathlib.Path.joinpath().joinpath", "len", "str", "pathlib.Path.joinpath", "pathlib.Path.joinpath"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.load_graphs"], ["", "def", "__init__", "(", "\n", "self", ",", "root_dir", ",", "split", "=", "\"train\"", ",", "center_and_scale", "=", "True", ",", "random_rotate", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Load the MFCAD dataset from:\n        Weijuan Cao, Trevor Robinson, Yang Hua, Flavien Boussuge,\n        Andrew R. Colligan, and Wanbin Pan. \"Graph representation\n        of 3d cad models for machining feature recognition with deep\n        learning.\" In Proceedings of the ASME 2020 International\n        Design Engineering Technical Conferences and Computers\n        and Information in Engineering Conference, IDETC-CIE.\n        ASME, 2020.\n\n        Args:\n            root_dir (str): Root path of dataset\n            split (str, optional): Data split to load. Defaults to \"train\".\n            center_and_scale (bool, optional): Whether to center and scale the solid. Defaults to True.\n            random_rotate (bool, optional): Whether to apply random rotations to the solid in 90 degree increments. Defaults to False.\n        \"\"\"", "\n", "path", "=", "pathlib", ".", "Path", "(", "root_dir", ")", "\n", "self", ".", "path", "=", "path", "\n", "assert", "split", "in", "(", "\"train\"", ",", "\"val\"", ",", "\"test\"", ")", "\n", "\n", "with", "open", "(", "str", "(", "str", "(", "path", ".", "joinpath", "(", "\"split.json\"", ")", ")", ")", ",", "\"r\"", ")", "as", "read_file", ":", "\n", "            ", "filelist", "=", "json", ".", "load", "(", "read_file", ")", "\n", "\n", "", "if", "split", "==", "\"train\"", ":", "\n", "            ", "split_filelist", "=", "filelist", "[", "\"train\"", "]", "\n", "", "elif", "split", "==", "\"val\"", ":", "\n", "            ", "split_filelist", "=", "filelist", "[", "\"validation\"", "]", "\n", "", "else", ":", "\n", "            ", "split_filelist", "=", "filelist", "[", "\"test\"", "]", "\n", "\n", "", "self", ".", "random_rotate", "=", "random_rotate", "\n", "\n", "all_files", "=", "[", "]", "\n", "for", "fn", "in", "split_filelist", ":", "\n", "            ", "all_files", ".", "append", "(", "path", ".", "joinpath", "(", "\"graph\"", ")", ".", "joinpath", "(", "fn", "+", "\".bin\"", ")", ")", "\n", "\n", "# Load graphs", "\n", "", "print", "(", "f\"Loading {split} data...\"", ")", "\n", "self", ".", "load_graphs", "(", "all_files", ",", "center_and_scale", ")", "\n", "print", "(", "\"Done loading {} files\"", ".", "format", "(", "len", "(", "self", ".", "data", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.mfcad.MFCADDataset.load_one_graph": [[56, 69], ["super().load_one_graph", "mfcad.MFCADDataset.path.joinpath().joinpath", "torch.tensor().long", "open", "json.load", "label.append", "mfcad.MFCADDataset.path.joinpath", "str", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.load_one_graph"], ["", "def", "load_one_graph", "(", "self", ",", "file_path", ")", ":", "\n", "# Load the graph using base class method", "\n", "        ", "sample", "=", "super", "(", ")", ".", "load_one_graph", "(", "file_path", ")", "\n", "# Additionally load the label and store it as node data", "\n", "label_file", "=", "self", ".", "path", ".", "joinpath", "(", "\"labels\"", ")", ".", "joinpath", "(", "file_path", ".", "stem", "+", "\"_ids.json\"", ")", "\n", "with", "open", "(", "str", "(", "label_file", ")", ",", "\"r\"", ")", "as", "read_file", ":", "\n", "            ", "labels_data", "=", "json", ".", "load", "(", "read_file", ")", "\n", "", "label", "=", "[", "]", "\n", "for", "face", "in", "labels_data", "[", "\"body\"", "]", "[", "\"faces\"", "]", ":", "\n", "            ", "index", "=", "face", "[", "\"segment\"", "]", "[", "\"index\"", "]", "\n", "label", ".", "append", "(", "index", ")", "\n", "", "sample", "[", "\"graph\"", "]", ".", "ndata", "[", "\"y\"", "]", "=", "torch", ".", "tensor", "(", "label", ")", ".", "long", "(", ")", "\n", "return", "sample", "\n", "", "", ""]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.num_classes": [[10, 13], ["None"], "methods", ["None"], ["    ", "@", "staticmethod", "\n", "def", "num_classes", "(", ")", ":", "\n", "        ", "return", "8", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.__init__": [[14, 65], ["pathlib.Path", "print", "fusiongallery.FusionGalleryDataset.load_graphs", "print", "fusiongallery.FusionGalleryDataset.seg_path.exists", "open", "json.load", "sklearn.model_selection.train_test_split", "pathlib.Path.joinpath().joinpath", "str", "len", "pathlib.Path.joinpath", "pathlib.Path.joinpath"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.base.BaseDataset.load_graphs"], ["", "def", "__init__", "(", "\n", "self", ",", "root_dir", ",", "split", "=", "\"train\"", ",", "center_and_scale", "=", "True", ",", "random_rotate", "=", "False", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Load the Fusion Gallery dataset from:\n        Joseph G. Lambourne, Karl D. D. Willis, Pradeep Kumar Jayaraman, Aditya Sanghi,\n        Peter Meltzer, Hooman Shayani. \"BRepNet: A topological message passing system\n        for solid models,\" CVPR 2021.\n\n        Args:\n            root_dir (str): Root path of dataset\n            split (str, optional): Data split to load. Defaults to \"train\".\n            center_and_scale (bool, optional): Whether to center and scale the solid. Defaults to True.\n            random_rotate (bool, optional): Whether to apply random rotations to the solid in 90 degree increments. Defaults to False.\n        \"\"\"", "\n", "path", "=", "pathlib", ".", "Path", "(", "root_dir", ")", "\n", "self", ".", "path", "=", "path", "\n", "\n", "# Locate the labels directory.  In s1.0.0 this would be  self.path / \"breps\"", "\n", "# but in s2.0.0 this is self.path / \"breps/seg\"", "\n", "self", ".", "seg_path", "=", "self", ".", "path", "/", "\"breps/seg\"", "\n", "if", "not", "self", ".", "seg_path", ".", "exists", "(", ")", ":", "\n", "            ", "self", ".", "seg_path", "=", "self", ".", "path", "/", "\"breps\"", "\n", "\n", "", "assert", "split", "in", "(", "\"train\"", ",", "\"val\"", ",", "\"test\"", ")", "\n", "\n", "with", "open", "(", "str", "(", "path", ".", "joinpath", "(", "\"train_test.json\"", ")", ")", ",", "\"r\"", ")", "as", "read_file", ":", "\n", "            ", "filelist", "=", "json", ".", "load", "(", "read_file", ")", "\n", "\n", "# NOTE: Using a held out validation set may be better.", "\n", "# But it's not easy to perform stratified sampling on some rare classes", "\n", "# which only show up on a few solids.", "\n", "", "if", "split", "in", "(", "\"train\"", ",", "\"val\"", ")", ":", "\n", "            ", "full_train_filelist", "=", "filelist", "[", "\"train\"", "]", "\n", "train_filesplit", ",", "val_filesplit", "=", "train_test_split", "(", "\n", "full_train_filelist", ",", "test_size", "=", "0.2", ",", "random_state", "=", "42", "\n", ")", "\n", "if", "split", "==", "\"train\"", ":", "\n", "                ", "split_filelist", "=", "train_filesplit", "\n", "", "else", ":", "\n", "                ", "split_filelist", "=", "val_filesplit", "\n", "", "", "else", ":", "\n", "            ", "split_filelist", "=", "filelist", "[", "\"test\"", "]", "\n", "\n", "", "self", ".", "random_rotate", "=", "random_rotate", "\n", "\n", "# Call base class method to load all graphs", "\n", "print", "(", "f\"Loading {split} data...\"", ")", "\n", "all_files", "=", "[", "path", ".", "joinpath", "(", "\"graph\"", ")", ".", "joinpath", "(", "fn", "+", "\".bin\"", ")", "for", "fn", "in", "split_filelist", "]", "\n", "self", ".", "load_graphs", "(", "all_files", ",", "center_and_scale", ")", "\n", "print", "(", "\"Done loading {} files\"", ".", "format", "(", "len", "(", "self", ".", "data", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.load_one_graph": [[66, 77], ["super().load_one_graph", "numpy.loadtxt", "torch.tensor().long", "fusiongallery.FusionGalleryDataset.seg_path.joinpath", "sample[].number_of_nodes", "torch.tensor"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.datasets.fusiongallery.FusionGalleryDataset.load_one_graph"], ["", "def", "load_one_graph", "(", "self", ",", "file_path", ")", ":", "\n", "# Load the graph using base class method", "\n", "        ", "sample", "=", "super", "(", ")", ".", "load_one_graph", "(", "file_path", ")", "\n", "# Additionally load the label and store it as node data", "\n", "label", "=", "np", ".", "loadtxt", "(", "\n", "self", ".", "seg_path", ".", "joinpath", "(", "file_path", ".", "stem", "+", "\".seg\"", ")", ",", "dtype", "=", "np", ".", "int", ",", "ndmin", "=", "1", "\n", ")", "\n", "if", "sample", "[", "\"graph\"", "]", ".", "number_of_nodes", "(", ")", "!=", "label", ".", "shape", "[", "0", "]", ":", "\n", "            ", "return", "None", "\n", "", "sample", "[", "\"graph\"", "]", ".", "ndata", "[", "\"y\"", "]", "=", "torch", ".", "tensor", "(", "label", ")", ".", "long", "(", ")", "\n", "return", "sample", "\n", "", "", ""]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_pointcloud.process_one_file": [[15, 56], ["pathlib.Path", "process.solid_to_rendermesh.triangulate_with_face_mapping", "trimesh.Trimesh", "trimesh.sample.sample_surface", "numpy.savez", "pathlib.Path.exists", "pathlib.Path.mkdir", "occwl.compound.Compound.load_from_step", "str", "fn.stat", "print", "pathlib.Path.joinpath"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.triangulate_with_face_mapping"], ["def", "process_one_file", "(", "arguments", ")", ":", "\n", "    ", "fn", ",", "args", "=", "arguments", "\n", "if", "fn", ".", "stat", "(", ")", ".", "st_size", "==", "0", ":", "\n", "        ", "return", "None", "\n", "", "fn_stem", "=", "fn", ".", "stem", "\n", "output_path", "=", "pathlib", ".", "Path", "(", "args", ".", "output", ")", "\n", "if", "not", "output_path", ".", "exists", "(", ")", ":", "\n", "        ", "output_path", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "try", ":", "\n", "        ", "solid", "=", "Compound", ".", "load_from_step", "(", "fn", ")", "\n", "", "except", "Exception", "as", "e", ":", "\n", "        ", "print", "(", "e", ")", "\n", "return", "\n", "\n", "", "verts", ",", "tris", ",", "tri_mapping", "=", "triangulate_with_face_mapping", "(", "solid", ")", "\n", "\n", "mesh", "=", "trimesh", ".", "Trimesh", "(", "vertices", "=", "verts", ",", "faces", "=", "tris", ")", "\n", "points", ",", "face_indices", "=", "trimesh", ".", "sample", ".", "sample_surface", "(", "mesh", ",", "args", ".", "num_points", ")", "\n", "points_to_face_mapping", "=", "tri_mapping", "[", "face_indices", "]", "\n", "\n", "# import matplotlib.pyplot as plt", "\n", "# from matplotlib.colors import Normalize", "\n", "# from matplotlib.cm import tab20", "\n", "# from mpl_toolkits.mplot3d import Axes3D", "\n", "\n", "# fig = plt.figure()", "\n", "# ax = fig.gca(projection=\"3d\")", "\n", "# colors = tab20(points_to_face_mapping)", "\n", "# norm = Normalize(", "\n", "#     vmin=np.amin(points_to_face_mapping), vmax=np.amax(points_to_face_mapping)", "\n", "# )", "\n", "# ax.scatter(", "\n", "#     points[:, 0], points[:, 1], points[:, 2], c=colors, norm=norm,", "\n", "# )", "\n", "# plt.show()", "\n", "\n", "# Write to numpy compressed archive", "\n", "np", ".", "savez", "(", "\n", "str", "(", "output_path", ".", "joinpath", "(", "fn_stem", "+", "\".npz\"", ")", ")", ",", "\n", "points", "=", "points", ",", "\n", "point_mapping", "=", "points_to_face_mapping", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_pointcloud.initializer": [[59, 62], ["signal.signal"], "function", ["None"], ["", "def", "initializer", "(", ")", ":", "\n", "    ", "\"\"\"Ignore CTRL+C in the worker process.\"\"\"", "\n", "signal", ".", "signal", "(", "signal", ".", "SIGINT", ",", "signal", ".", "SIG_IGN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_pointcloud.process": [[64, 79], ["pathlib.Path", "pathlib.Path", "list", "multiprocessing.pool.Pool", "print", "pathlib.Path.exists", "pathlib.Path.mkdir", "pathlib.Path.glob", "list", "tqdm.tqdm", "multiprocessing.pool.Pool.terminate", "multiprocessing.pool.Pool.join", "multiprocessing.pool.Pool.imap", "len", "zip", "len", "itertools.repeat"], "function", ["None"], ["", "def", "process", "(", "args", ")", ":", "\n", "    ", "input_path", "=", "pathlib", ".", "Path", "(", "args", ".", "input", ")", "\n", "output_path", "=", "pathlib", ".", "Path", "(", "args", ".", "output", ")", "\n", "if", "not", "output_path", ".", "exists", "(", ")", ":", "\n", "        ", "output_path", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "step_files", "=", "list", "(", "input_path", ".", "glob", "(", "\"*.st*p\"", ")", ")", "\n", "# for fn in tqdm(step_files):", "\n", "#     process_one_file(fn, args)", "\n", "pool", "=", "Pool", "(", "processes", "=", "args", ".", "num_processes", ",", "initializer", "=", "initializer", ")", "\n", "try", ":", "\n", "        ", "results", "=", "list", "(", "tqdm", "(", "pool", ".", "imap", "(", "process_one_file", ",", "zip", "(", "step_files", ",", "repeat", "(", "args", ")", ")", ")", ",", "total", "=", "len", "(", "step_files", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "pool", ".", "terminate", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "", "print", "(", "f\"Processed {len(results)} files.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_pointcloud.main": [[81, 101], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "solid_to_pointcloud.process"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\"Convert solid models to point clouds\"", ")", "\n", "parser", ".", "add_argument", "(", "\"input\"", ",", "type", "=", "str", ",", "help", "=", "\"Input folder of STEP files\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"output\"", ",", "type", "=", "str", ",", "help", "=", "\"Output folder of NPZ point cloud files\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num_points\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "2048", ",", "\n", "help", "=", "\"Number of points in the point cloud\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num_processes\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "8", ",", "\n", "help", "=", "\"Number of processes to use\"", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "process", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_graph.build_graph": [[16, 65], ["occwl.graph.face_adjacency", "numpy.asarray", "numpy.asarray", "list", "dgl.graph", "torch.from_numpy", "torch.from_numpy", "occwl.uvgrid.uvgrid", "occwl.uvgrid.uvgrid", "occwl.uvgrid.uvgrid", "numpy.logical_or", "numpy.concatenate", "np.asarray.append", "occwl.uvgrid.ugrid", "occwl.uvgrid.ugrid", "numpy.concatenate", "np.asarray.append", "edge.has_curve", "len"], "function", ["None"], ["def", "build_graph", "(", "solid", ",", "curv_num_u_samples", ",", "surf_num_u_samples", ",", "surf_num_v_samples", ")", ":", "\n", "# Build face adjacency graph with B-rep entities as node and edge features", "\n", "    ", "graph", "=", "face_adjacency", "(", "solid", ")", "\n", "\n", "# Compute the UV-grids for faces", "\n", "graph_face_feat", "=", "[", "]", "\n", "for", "face_idx", "in", "graph", ".", "nodes", ":", "\n", "# Get the B-rep face", "\n", "        ", "face", "=", "graph", ".", "nodes", "[", "face_idx", "]", "[", "\"face\"", "]", "\n", "# Compute UV-grids", "\n", "points", "=", "uvgrid", "(", "\n", "face", ",", "method", "=", "\"point\"", ",", "num_u", "=", "surf_num_u_samples", ",", "num_v", "=", "surf_num_v_samples", "\n", ")", "\n", "normals", "=", "uvgrid", "(", "\n", "face", ",", "method", "=", "\"normal\"", ",", "num_u", "=", "surf_num_u_samples", ",", "num_v", "=", "surf_num_v_samples", "\n", ")", "\n", "visibility_status", "=", "uvgrid", "(", "\n", "face", ",", "method", "=", "\"visibility_status\"", ",", "num_u", "=", "surf_num_u_samples", ",", "num_v", "=", "surf_num_v_samples", "\n", ")", "\n", "mask", "=", "np", ".", "logical_or", "(", "visibility_status", "==", "0", ",", "visibility_status", "==", "2", ")", "# 0: Inside, 1: Outside, 2: On boundary", "\n", "# Concatenate channel-wise to form face feature tensor", "\n", "face_feat", "=", "np", ".", "concatenate", "(", "(", "points", ",", "normals", ",", "mask", ")", ",", "axis", "=", "-", "1", ")", "\n", "graph_face_feat", ".", "append", "(", "face_feat", ")", "\n", "", "graph_face_feat", "=", "np", ".", "asarray", "(", "graph_face_feat", ")", "\n", "\n", "# Compute the U-grids for edges", "\n", "graph_edge_feat", "=", "[", "]", "\n", "for", "edge_idx", "in", "graph", ".", "edges", ":", "\n", "# Get the B-rep edge", "\n", "        ", "edge", "=", "graph", ".", "edges", "[", "edge_idx", "]", "[", "\"edge\"", "]", "\n", "# Ignore dgenerate edges, e.g. at apex of cone", "\n", "if", "not", "edge", ".", "has_curve", "(", ")", ":", "\n", "            ", "continue", "\n", "# Compute U-grids", "\n", "", "points", "=", "ugrid", "(", "edge", ",", "method", "=", "\"point\"", ",", "num_u", "=", "curv_num_u_samples", ")", "\n", "tangents", "=", "ugrid", "(", "edge", ",", "method", "=", "\"tangent\"", ",", "num_u", "=", "curv_num_u_samples", ")", "\n", "# Concatenate channel-wise to form edge feature tensor", "\n", "edge_feat", "=", "np", ".", "concatenate", "(", "(", "points", ",", "tangents", ")", ",", "axis", "=", "-", "1", ")", "\n", "graph_edge_feat", ".", "append", "(", "edge_feat", ")", "\n", "", "graph_edge_feat", "=", "np", ".", "asarray", "(", "graph_edge_feat", ")", "\n", "\n", "# Convert face-adj graph to DGL format", "\n", "edges", "=", "list", "(", "graph", ".", "edges", ")", "\n", "src", "=", "[", "e", "[", "0", "]", "for", "e", "in", "edges", "]", "\n", "dst", "=", "[", "e", "[", "1", "]", "for", "e", "in", "edges", "]", "\n", "dgl_graph", "=", "dgl", ".", "graph", "(", "(", "src", ",", "dst", ")", ",", "num_nodes", "=", "len", "(", "graph", ".", "nodes", ")", ")", "\n", "dgl_graph", ".", "ndata", "[", "\"x\"", "]", "=", "torch", ".", "from_numpy", "(", "graph_face_feat", ")", "\n", "dgl_graph", ".", "edata", "[", "\"x\"", "]", "=", "torch", ".", "from_numpy", "(", "graph_edge_feat", ")", "\n", "return", "dgl_graph", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_graph.process_one_file": [[67, 76], ["pathlib.Path", "solid_to_graph.build_graph", "dgl.data.utils.save_graphs", "occwl.io.load_step", "str", "pathlib.Path.joinpath"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_graph.build_graph"], ["", "def", "process_one_file", "(", "arguments", ")", ":", "\n", "    ", "fn", ",", "args", "=", "arguments", "\n", "fn_stem", "=", "fn", ".", "stem", "\n", "output_path", "=", "pathlib", ".", "Path", "(", "args", ".", "output", ")", "\n", "solid", "=", "load_step", "(", "fn", ")", "[", "0", "]", "# Assume there's one solid per file", "\n", "graph", "=", "build_graph", "(", "\n", "solid", ",", "args", ".", "curv_u_samples", ",", "args", ".", "surf_u_samples", ",", "args", ".", "surf_v_samples", "\n", ")", "\n", "dgl", ".", "data", ".", "utils", ".", "save_graphs", "(", "str", "(", "output_path", ".", "joinpath", "(", "fn_stem", "+", "\".bin\"", ")", ")", ",", "[", "graph", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_graph.initializer": [[78, 81], ["signal.signal"], "function", ["None"], ["", "def", "initializer", "(", ")", ":", "\n", "    ", "\"\"\"Ignore CTRL+C in the worker process.\"\"\"", "\n", "signal", ".", "signal", "(", "signal", ".", "SIGINT", ",", "signal", ".", "SIG_IGN", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_graph.process": [[83, 98], ["pathlib.Path", "pathlib.Path", "list", "multiprocessing.pool.Pool", "print", "pathlib.Path.exists", "pathlib.Path.mkdir", "pathlib.Path.glob", "list", "tqdm.tqdm", "multiprocessing.pool.Pool.terminate", "multiprocessing.pool.Pool.join", "multiprocessing.pool.Pool.imap", "len", "zip", "len", "itertools.repeat"], "function", ["None"], ["", "def", "process", "(", "args", ")", ":", "\n", "    ", "input_path", "=", "pathlib", ".", "Path", "(", "args", ".", "input", ")", "\n", "output_path", "=", "pathlib", ".", "Path", "(", "args", ".", "output", ")", "\n", "if", "not", "output_path", ".", "exists", "(", ")", ":", "\n", "        ", "output_path", ".", "mkdir", "(", "parents", "=", "True", ",", "exist_ok", "=", "True", ")", "\n", "", "step_files", "=", "list", "(", "input_path", ".", "glob", "(", "\"*.st*p\"", ")", ")", "\n", "# for fn in tqdm(step_files):", "\n", "#     process_one_file(fn, args)", "\n", "pool", "=", "Pool", "(", "processes", "=", "args", ".", "num_processes", ",", "initializer", "=", "initializer", ")", "\n", "try", ":", "\n", "        ", "results", "=", "list", "(", "tqdm", "(", "pool", ".", "imap", "(", "process_one_file", ",", "zip", "(", "step_files", ",", "repeat", "(", "args", ")", ")", ")", ",", "total", "=", "len", "(", "step_files", ")", ")", ")", "\n", "", "except", "KeyboardInterrupt", ":", "\n", "        ", "pool", ".", "terminate", "(", ")", "\n", "pool", ".", "join", "(", ")", "\n", "", "print", "(", "f\"Processed {len(results)} files.\"", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_graph.main": [[100, 129], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "solid_to_graph.process"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.process"], ["", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "\"Convert solid models to face-adjacency graphs with UV-grid features\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"input\"", ",", "type", "=", "str", ",", "help", "=", "\"Input folder of STEP files\"", ")", "\n", "parser", ".", "add_argument", "(", "\"output\"", ",", "type", "=", "str", ",", "help", "=", "\"Output folder of DGL graph BIN files\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--curv_u_samples\"", ",", "type", "=", "int", ",", "default", "=", "10", ",", "help", "=", "\"Number of samples on each curve\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--surf_u_samples\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "10", ",", "\n", "help", "=", "\"Number of samples on each surface along the u-direction\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--surf_v_samples\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "10", ",", "\n", "help", "=", "\"Number of samples on each surface along the v-direction\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--num_processes\"", ",", "\n", "type", "=", "int", ",", "\n", "default", "=", "8", ",", "\n", "help", "=", "\"Number of processes to use\"", ",", "\n", ")", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "process", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.triangulate_with_face_mapping": [[11, 42], ["solid.triangulate_all_faces", "occwl.entity_mapper.EntityMapper", "solid.faces", "numpy.concatenate().astype", "numpy.concatenate().astype", "numpy.concatenate().astype", "occwl.entity_mapper.EntityMapper.face_index", "face.get_triangles", "np.concatenate().astype.append", "np.concatenate().astype.append", "np.concatenate().astype.append", "len", "len", "len", "numpy.ones", "numpy.concatenate", "numpy.concatenate", "numpy.concatenate"], "function", ["None"], ["def", "triangulate_with_face_mapping", "(", "solid", ",", "triangle_face_tol", "=", "0.01", ",", "angle_tol_rads", "=", "0.1", ")", ":", "\n", "# Triangulate faces", "\n", "    ", "solid", ".", "triangulate_all_faces", "(", "\n", "triangle_face_tol", "=", "triangle_face_tol", ",", "angle_tol_rads", "=", "angle_tol_rads", "\n", ")", "\n", "\n", "verts", "=", "[", "]", "\n", "tris", "=", "[", "]", "\n", "# Store B-rep face index along with triangles", "\n", "mapper", "=", "EntityMapper", "(", "solid", ")", "\n", "tri_mapping", "=", "[", "]", "\n", "vert_counter", "=", "0", "\n", "for", "face", "in", "solid", ".", "faces", "(", ")", ":", "\n", "        ", "face_index", "=", "mapper", ".", "face_index", "(", "face", ")", "\n", "face_verts", ",", "face_tris", "=", "face", ".", "get_triangles", "(", ")", "\n", "if", "len", "(", "face_tris", ")", "==", "0", ":", "\n", "            ", "continue", "\n", "", "face_tris", "+=", "vert_counter", "\n", "vert_counter", "+=", "face_verts", ".", "shape", "[", "0", "]", "\n", "face_mapping", "=", "np", ".", "ones", "(", "face_tris", ".", "shape", "[", "0", "]", ")", "*", "face_index", "\n", "verts", ".", "append", "(", "face_verts", ")", "\n", "tris", ".", "append", "(", "face_tris", ")", "\n", "tri_mapping", ".", "append", "(", "face_mapping", ")", "\n", "", "if", "len", "(", "verts", ")", "==", "0", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "", "verts", "=", "np", ".", "concatenate", "(", "verts", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "float32", ")", "\n", "if", "len", "(", "tris", ")", "==", "0", ":", "\n", "        ", "return", "None", ",", "None", ",", "None", "\n", "", "tris", "=", "np", ".", "concatenate", "(", "tris", ",", "axis", "=", "0", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "tri_mapping", "=", "np", ".", "concatenate", "(", "tri_mapping", ",", "axis", "=", "-", "1", ")", ".", "astype", "(", "np", ".", "int32", ")", "\n", "return", "verts", ",", "tris", ",", "tri_mapping", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.process_one_file": [[44, 71], ["pathlib.Path", "pathlib.Path.joinpath", "output_path.joinpath.exists", "occwl.compound.Compound.load_from_step", "solid_to_rendermesh.triangulate_with_face_mapping", "trimesh.Trimesh().export", "str", "trimesh.Trimesh"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.triangulate_with_face_mapping"], ["", "def", "process_one_file", "(", "fn", ",", "args", ")", ":", "\n", "    ", "fn_stem", "=", "fn", ".", "stem", "\n", "output_path", "=", "pathlib", ".", "Path", "(", "args", ".", "output", ")", "\n", "output_filename", "=", "output_path", ".", "joinpath", "(", "fn_stem", "+", "\".stl\"", ")", "\n", "if", "output_filename", ".", "exists", "(", ")", ":", "\n", "        ", "return", "\n", "", "solid", "=", "Compound", ".", "load_from_step", "(", "fn", ")", "\n", "\n", "verts", ",", "tris", ",", "tri_mapping", "=", "triangulate_with_face_mapping", "(", "\n", "solid", ",", "args", ".", "triangle_face_tol", ",", "args", ".", "angle_tol_rads", "\n", ")", "\n", "\n", "# from mpl_toolkits.mplot3d import Axes3D", "\n", "# import matplotlib.pyplot as plt", "\n", "# fig = plt.figure()", "\n", "# ax = fig.gca(projection='3d')", "\n", "# ax.plot_trisurf(verts[:,0], verts[:,1], verts[:,2], triangles = tris, alpha=0.8)", "\n", "# plt.show()", "\n", "\n", "# Write to numpy compressed archive", "\n", "# np.savez(", "\n", "#     str(output_path.joinpath(fn_stem + \".npz\")),", "\n", "#     vertices=verts,", "\n", "#     triangles=tris,", "\n", "#     triangle_mapping=tri_mapping,", "\n", "# )", "\n", "trimesh", ".", "Trimesh", "(", "vertices", "=", "verts", ",", "faces", "=", "tris", ")", ".", "export", "(", "str", "(", "output_filename", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.process": [[73, 78], ["pathlib.Path", "list", "tqdm.tqdm", "pathlib.Path.glob", "solid_to_rendermesh.process_one_file"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.process_one_file"], ["", "def", "process", "(", "args", ")", ":", "\n", "    ", "input_path", "=", "pathlib", ".", "Path", "(", "args", ".", "input", ")", "\n", "step_files", "=", "list", "(", "input_path", ".", "glob", "(", "f\"{args.filename_pattern}.st*p\"", ")", ")", "\n", "for", "fn", "in", "tqdm", "(", "step_files", ")", ":", "\n", "        ", "process_one_file", "(", "fn", ",", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.main": [[80, 107], ["argparse.ArgumentParser", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.add_argument", "argparse.ArgumentParser.parse_args", "solid_to_rendermesh.process"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.solid_to_rendermesh.process"], ["", "", "def", "main", "(", ")", ":", "\n", "    ", "parser", "=", "argparse", ".", "ArgumentParser", "(", "\n", "\"Convert solid models to render (non-watertight) meshes\"", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\"input\"", ",", "type", "=", "str", ",", "help", "=", "\"Input folder of STEP files\"", ")", "\n", "parser", ".", "add_argument", "(", "\"output\"", ",", "type", "=", "str", ",", "help", "=", "\"Output folder of NPZ mesh files\"", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--triangle_face_tol\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.01", ",", "\n", "help", "=", "\"Tolerance between triangle and surface relative to each B-rep face\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--angle_tol_rads\"", ",", "\n", "type", "=", "float", ",", "\n", "default", "=", "0.1", ",", "\n", "help", "=", "\"Tolerance angle between normals/tangents at triangle vertices (in radians)\"", ",", "\n", ")", "\n", "parser", ".", "add_argument", "(", "\n", "\"--filename_pattern\"", ",", "\n", "type", "=", "str", ",", "\n", "default", "=", "\"*\"", ",", "\n", "help", "=", "\"Filename regex pattern to filter input files. Defaults to '*'\"", ",", "\n", ")", "\n", "\n", "args", "=", "parser", ".", "parse_args", "(", ")", "\n", "process", "(", "args", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.bounding_box_pointcloud": [[16, 22], ["torch.tensor", "x.min", "y.min", "z.min", "x.max", "y.max", "z.max"], "function", ["None"], ["def", "bounding_box_pointcloud", "(", "pts", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "x", "=", "pts", "[", ":", ",", "0", "]", "\n", "y", "=", "pts", "[", ":", ",", "1", "]", "\n", "z", "=", "pts", "[", ":", ",", "2", "]", "\n", "box", "=", "[", "[", "x", ".", "min", "(", ")", ",", "y", ".", "min", "(", ")", ",", "z", ".", "min", "(", ")", "]", ",", "[", "x", ".", "max", "(", ")", ",", "y", ".", "max", "(", ")", ",", "z", ".", "max", "(", ")", "]", "]", "\n", "return", "torch", ".", "tensor", "(", "box", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.bounding_box_uvsolid": [[24, 30], ["inp[].reshape", "inp[].reshape", "visualize_uvgrid_graph.bounding_box_pointcloud"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.bounding_box_pointcloud"], ["", "def", "bounding_box_uvsolid", "(", "inp", ":", "torch", ".", "Tensor", ")", ":", "\n", "    ", "pts", "=", "inp", "[", ":", ",", ":", ",", ":", ",", ":", "3", "]", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "mask", "=", "inp", "[", ":", ",", ":", ",", ":", ",", "6", "]", ".", "reshape", "(", "-", "1", ")", "\n", "point_indices_inside_faces", "=", "mask", "==", "1", "\n", "pts", "=", "pts", "[", "point_indices_inside_faces", ",", ":", "]", "\n", "return", "bounding_box_pointcloud", "(", "pts", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.plot_uvsolid": [[32, 60], ["visualize_uvgrid_graph.bounding_box_uvsolid", "torch.norm().item", "uvsolid.size", "range", "len", "uvsolid[].cpu().detach().numpy().reshape", "uvsolid[].cpu().detach().numpy().reshape", "uvsolid[].cpu().detach().numpy().reshape", "ax.scatter", "torch.norm", "ax.quiver", "uvsolid[].cpu().detach().numpy", "uvsolid[].cpu().detach().numpy", "uvsolid[].cpu().detach().numpy", "uvsolid[].cpu().detach", "uvsolid[].cpu().detach", "uvsolid[].cpu().detach", "uvsolid[].cpu", "uvsolid[].cpu", "uvsolid[].cpu"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.bounding_box_uvsolid"], ["", "def", "plot_uvsolid", "(", "uvsolid", ":", "torch", ".", "Tensor", ",", "ax", ",", "normals", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Plot the loaded UV solid features to a MPL 3D Axes\n    :param uvsolid torch.Tensor: Features loaded from *.feat file of shape [#faces, #u, #v, 10]\n    :param ax matplotlib Axes3D: 3D Axes object for plotting\n    \"\"\"", "\n", "assert", "len", "(", "uvsolid", ".", "shape", ")", "==", "4", "# faces x #u x #v x 10", "\n", "bbox", "=", "bounding_box_uvsolid", "(", "uvsolid", ")", "\n", "bbox_diag", "=", "torch", ".", "norm", "(", "bbox", "[", "1", "]", "-", "bbox", "[", "0", "]", ")", ".", "item", "(", ")", "\n", "num_faces", "=", "uvsolid", ".", "size", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "num_faces", ")", ":", "\n", "        ", "pts", "=", "uvsolid", "[", "i", ",", ":", ",", ":", ",", ":", "3", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "nor", "=", "uvsolid", "[", "i", ",", ":", ",", ":", ",", "3", ":", "6", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "mask", "=", "uvsolid", "[", "i", ",", ":", ",", ":", ",", "6", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "-", "1", ")", "\n", "point_indices_inside_faces", "=", "mask", "==", "1", "\n", "pts", "=", "pts", "[", "point_indices_inside_faces", ",", ":", "]", "\n", "if", "normals", ":", "\n", "            ", "nor", "=", "nor", "[", "point_indices_inside_faces", ",", ":", "]", "\n", "ax", ".", "quiver", "(", "\n", "pts", "[", ":", ",", "0", "]", ",", "\n", "pts", "[", ":", ",", "1", "]", ",", "\n", "pts", "[", ":", ",", "2", "]", ",", "\n", "nor", "[", ":", ",", "0", "]", ",", "\n", "nor", "[", ":", ",", "1", "]", ",", "\n", "nor", "[", ":", ",", "2", "]", ",", "\n", "length", "=", "0.075", "*", "bbox_diag", ",", "\n", ")", "\n", "", "ax", ".", "scatter", "(", "pts", "[", ":", ",", "0", "]", ",", "pts", "[", ":", ",", "1", "]", ",", "pts", "[", ":", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.plot_uvsolid_edges": [[62, 93], ["visualize_uvgrid_graph.bounding_box_uvsolid", "torch.norm().item", "graph.edata[].size", "range", "graph.edata.get", "print", "[].cpu().detach().numpy().reshape", "ax.scatter", "torch.norm", "[].cpu().detach().numpy().reshape", "ax.quiver", "[].cpu().detach().numpy", "[].cpu().detach().numpy", "[].cpu().detach", "[].cpu().detach", "[].cpu", "[].cpu"], "function", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.bounding_box_uvsolid"], ["", "", "def", "plot_uvsolid_edges", "(", "graph", ":", "dgl", ".", "DGLGraph", ",", "ax", ",", "tangents", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Plot the loaded UV solid's edge features to a MPL 3D Axes\n    :param graph: dgl.DGLGraph: DGL Graph containing the graph with UV-grids as node features and 1D UV-grids as edge features\n    :param ax matplotlib Axes3D: 3D Axes object for plotting\n    \"\"\"", "\n", "face_feat", "=", "graph", ".", "ndata", "[", "\"x\"", "]", "\n", "if", "graph", ".", "edata", ".", "get", "(", "\"x\"", ")", "is", "None", ":", "\n", "        ", "print", "(", "\"Edge features not found\"", ")", "\n", "return", "\n", "", "edge_feat", "=", "graph", ".", "edata", "[", "\"x\"", "]", "\n", "if", "edge_feat", ".", "shape", "[", "0", "]", "==", "0", ":", "\n", "        ", "return", "\n", "", "assert", "edge_feat", ".", "shape", "[", "2", "]", "in", "(", "3", ",", "6", ")", ",", "edge_feat", ".", "shape", "# edges x #u x 3/6", "\n", "bbox", "=", "bounding_box_uvsolid", "(", "face_feat", ")", "\n", "bbox_diag", "=", "torch", ".", "norm", "(", "bbox", "[", "1", "]", "-", "bbox", "[", "0", "]", ")", ".", "item", "(", ")", "\n", "num_edges", "=", "graph", ".", "edata", "[", "\"x\"", "]", ".", "size", "(", "0", ")", "\n", "for", "i", "in", "range", "(", "num_edges", ")", ":", "\n", "        ", "pts", "=", "graph", ".", "edata", "[", "\"x\"", "]", "[", "i", ",", ":", ",", ":", "3", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "if", "tangents", ":", "\n", "            ", "tgt", "=", "graph", ".", "edata", "[", "\"x\"", "]", "[", "i", ",", ":", ",", "3", ":", "6", "]", ".", "cpu", "(", ")", ".", "detach", "(", ")", ".", "numpy", "(", ")", ".", "reshape", "(", "(", "-", "1", ",", "3", ")", ")", "\n", "ax", ".", "quiver", "(", "\n", "pts", "[", ":", ",", "0", "]", ",", "\n", "pts", "[", ":", ",", "1", "]", ",", "\n", "pts", "[", ":", ",", "2", "]", ",", "\n", "tgt", "[", ":", ",", "0", "]", ",", "\n", "tgt", "[", ":", ",", "1", "]", ",", "\n", "tgt", "[", ":", ",", "2", "]", ",", "\n", "length", "=", "0.075", "*", "bbox_diag", ",", "\n", ")", "\n", "", "ax", ".", "scatter", "(", "pts", "[", ":", ",", "0", "]", ",", "pts", "[", ":", ",", "1", "]", ",", "pts", "[", ":", ",", "2", "]", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize_uvgrid_graph.plot_faceadj_graph": [[95, 114], ["graph.edges", "range", "len", "src.size", "ax.plot", "graph.ndata[].size"], "function", ["None"], ["", "", "def", "plot_faceadj_graph", "(", "graph", ":", "dgl", ".", "DGLGraph", ",", "ax", ")", ":", "\n", "    ", "\"\"\"\n    Plot the face-adj graph to a MPL 3D Axes\n    :param graph: dgl.DGLGraph: DGL Graph containing the graph with UV-grids as node features\n    :param ax matplotlib Axes3D: 3D Axes object for plotting\n    \"\"\"", "\n", "assert", "len", "(", "graph", ".", "ndata", "[", "\"x\"", "]", ".", "shape", ")", "==", "4", "# faces x #u x #v x 10", "\n", "src", ",", "dst", "=", "graph", ".", "edges", "(", ")", "\n", "for", "i", "in", "range", "(", "src", ".", "size", "(", "0", ")", ")", ":", "\n", "        ", "center_idx", "=", "graph", ".", "ndata", "[", "\"x\"", "]", ".", "size", "(", "1", ")", "//", "2", "\n", "src_pt", "=", "graph", ".", "ndata", "[", "\"x\"", "]", "[", "src", "[", "i", "]", ",", "center_idx", ",", "center_idx", ",", ":", "3", "]", "\n", "dst_pt", "=", "graph", ".", "ndata", "[", "\"x\"", "]", "[", "dst", "[", "i", "]", ",", "center_idx", ",", "center_idx", ",", ":", "3", "]", "\n", "ax", ".", "plot", "(", "\n", "(", "src_pt", "[", "0", "]", ",", "dst_pt", "[", "0", "]", ")", ",", "\n", "(", "src_pt", "[", "1", "]", ",", "dst_pt", "[", "1", "]", ")", ",", "\n", "zs", "=", "(", "src_pt", "[", "2", "]", ",", "dst_pt", "[", "2", "]", ")", ",", "\n", "color", "=", "\"k\"", ",", "\n", "linewidth", "=", "2", ",", "\n", "marker", "=", "\"o\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize.draw_face_uvgrids": [[13, 38], ["graph.ndata[].view", "range", "numpy.asarray", "numpy.asarray", "solid.box", "max", "viewer.display_points", "zip", "np.asarray.append", "np.asarray.append", "solid.box.x_length", "solid.box.y_length", "solid.box.z_length", "viewer.display", "face_uvgrids[].cpu().numpy", "face_uvgrids[].cpu().numpy", "occwl.edge.Edge.make_line_from_points", "face_uvgrids[].cpu", "face_uvgrids[].cpu"], "function", ["None"], ["def", "draw_face_uvgrids", "(", "solid", ",", "graph", ",", "viewer", ")", ":", "\n", "    ", "face_uvgrids", "=", "graph", ".", "ndata", "[", "\"x\"", "]", ".", "view", "(", "-", "1", ",", "7", ")", "\n", "points", "=", "[", "]", "\n", "normals", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "face_uvgrids", ".", "shape", "[", "0", "]", ")", ":", "\n", "# Don't draw points outside trimming loop", "\n", "        ", "if", "face_uvgrids", "[", "idx", ",", "-", "1", "]", "==", "0", ":", "\n", "            ", "continue", "\n", "", "points", ".", "append", "(", "face_uvgrids", "[", "idx", ",", ":", "3", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "normals", ".", "append", "(", "face_uvgrids", "[", "idx", ",", "3", ":", "6", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "", "points", "=", "np", ".", "asarray", "(", "points", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "normals", "=", "np", ".", "asarray", "(", "normals", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "bbox", "=", "solid", ".", "box", "(", ")", "\n", "max_length", "=", "max", "(", "bbox", ".", "x_length", "(", ")", ",", "bbox", ".", "y_length", "(", ")", ",", "bbox", ".", "z_length", "(", ")", ")", "\n", "\n", "# Draw the points", "\n", "viewer", ".", "display_points", "(", "\n", "points", ",", "color", "=", "(", "51.0", "/", "255.0", ",", "0", ",", "1", ")", ",", "marker", "=", "\"point\"", ",", "scale", "=", "2", "*", "max_length", "\n", ")", "\n", "\n", "# Draw the normals", "\n", "for", "pt", ",", "nor", "in", "zip", "(", "points", ",", "normals", ")", ":", "\n", "        ", "viewer", ".", "display", "(", "Edge", ".", "make_line_from_points", "(", "pt", ",", "pt", "+", "nor", "*", "0.05", "*", "max_length", ")", ",", "color", "=", "(", "51.0", "/", "255.0", ",", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize.draw_edge_uvgrids": [[40, 60], ["graph.edata[].view", "range", "numpy.asarray", "numpy.asarray", "solid.box", "max", "viewer.display_points", "zip", "np.asarray.append", "np.asarray.append", "solid.box.x_length", "solid.box.y_length", "solid.box.z_length", "viewer.display", "edge_uvgrids[].cpu().numpy", "edge_uvgrids[].cpu().numpy", "occwl.edge.Edge.make_line_from_points", "edge_uvgrids[].cpu", "edge_uvgrids[].cpu"], "function", ["None"], ["", "", "def", "draw_edge_uvgrids", "(", "solid", ",", "graph", ",", "viewer", ")", ":", "\n", "    ", "edge_uvgrids", "=", "graph", ".", "edata", "[", "\"x\"", "]", ".", "view", "(", "-", "1", ",", "6", ")", "\n", "points", "=", "[", "]", "\n", "tangents", "=", "[", "]", "\n", "for", "idx", "in", "range", "(", "edge_uvgrids", ".", "shape", "[", "0", "]", ")", ":", "\n", "        ", "points", ".", "append", "(", "edge_uvgrids", "[", "idx", ",", ":", "3", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "tangents", ".", "append", "(", "edge_uvgrids", "[", "idx", ",", "3", ":", "6", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", ")", "\n", "\n", "", "points", "=", "np", ".", "asarray", "(", "points", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "tangents", "=", "np", ".", "asarray", "(", "tangents", ",", "dtype", "=", "np", ".", "float32", ")", "\n", "\n", "bbox", "=", "solid", ".", "box", "(", ")", "\n", "max_length", "=", "max", "(", "bbox", ".", "x_length", "(", ")", ",", "bbox", ".", "y_length", "(", ")", ",", "bbox", ".", "z_length", "(", ")", ")", "\n", "\n", "# Draw the points", "\n", "viewer", ".", "display_points", "(", "points", ",", "color", "=", "(", "1", ",", "0", ",", "1", ")", ",", "marker", "=", "\"point\"", ",", "scale", "=", "2", "*", "max_length", ")", "\n", "\n", "# Draw the tangents", "\n", "for", "pt", ",", "tgt", "in", "zip", "(", "points", ",", "tangents", ")", ":", "\n", "        ", "viewer", ".", "display", "(", "Edge", ".", "make_line_from_points", "(", "pt", ",", "pt", "+", "tgt", "*", "0.1", "*", "max_length", ")", ",", "color", "=", "(", "1", ",", "0", ",", "1", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.process.visualize.draw_graph_edges": [[62, 81], ["graph.edges", "solid.box", "max", "zip", "solid.box.x_length", "solid.box.y_length", "solid.box.z_length", "[].cpu().numpy", "[].cpu().numpy", "numpy.linalg.norm", "v.display", "[].cpu", "[].cpu", "occwl.solid.Solid.make_cylinder"], "function", ["None"], ["", "", "def", "draw_graph_edges", "(", "solid", ",", "graph", ",", "viewer", ")", ":", "\n", "    ", "src", ",", "dst", "=", "graph", ".", "edges", "(", ")", "\n", "num_u", "=", "graph", ".", "ndata", "[", "\"x\"", "]", ".", "shape", "[", "1", "]", "\n", "num_v", "=", "graph", ".", "ndata", "[", "\"x\"", "]", ".", "shape", "[", "2", "]", "\n", "bbox", "=", "solid", ".", "box", "(", ")", "\n", "max_length", "=", "max", "(", "bbox", ".", "x_length", "(", ")", ",", "bbox", ".", "y_length", "(", ")", ",", "bbox", ".", "z_length", "(", ")", ")", "\n", "\n", "for", "s", ",", "d", "in", "zip", "(", "src", ",", "dst", ")", ":", "\n", "        ", "src_pt", "=", "graph", ".", "ndata", "[", "\"x\"", "]", "[", "s", ",", "num_u", "//", "2", ",", "num_v", "//", "2", ",", ":", "3", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "dst_pt", "=", "graph", ".", "ndata", "[", "\"x\"", "]", "[", "d", ",", "num_u", "//", "2", ",", "num_v", "//", "2", ",", ":", "3", "]", ".", "cpu", "(", ")", ".", "numpy", "(", ")", "\n", "# Make a cylinder for each edge connecting a pair of faces", "\n", "up_dir", "=", "dst_pt", "-", "src_pt", "\n", "height", "=", "np", ".", "linalg", ".", "norm", "(", "up_dir", ")", "\n", "if", "height", ">", "1e-3", ":", "\n", "            ", "v", ".", "display", "(", "\n", "Solid", ".", "make_cylinder", "(", "\n", "radius", "=", "0.01", "*", "max_length", ",", "height", "=", "height", ",", "base_point", "=", "src_pt", ",", "up_dir", "=", "up_dir", "\n", ")", ",", "\n", "color", "=", "\"BLACK\"", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models._NonLinearClassifier.__init__": [[10, 30], ["torch.nn.Module.__init__", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Linear", "torch.nn.Linear", "models._NonLinearClassifier.modules", "models._NonLinearClassifier.weights_init"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetSurfaceEncoder.weights_init"], ["    ", "def", "__init__", "(", "self", ",", "input_dim", ",", "num_classes", ",", "dropout", "=", "0.3", ")", ":", "\n", "        ", "\"\"\"\n        A 3-layer MLP with linear outputs\n\n        Args:\n            input_dim (int): Dimension of the input tensor \n            num_classes (int): Dimension of the output logits\n            dropout (float, optional): Dropout used after each linear layer. Defaults to 0.3.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear1", "=", "nn", ".", "Linear", "(", "input_dim", ",", "512", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn1", "=", "nn", ".", "BatchNorm1d", "(", "512", ")", "\n", "self", ".", "dp1", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "self", ".", "linear2", "=", "nn", ".", "Linear", "(", "512", ",", "256", ",", "bias", "=", "False", ")", "\n", "self", ".", "bn2", "=", "nn", ".", "BatchNorm1d", "(", "256", ")", "\n", "self", ".", "dp2", "=", "nn", ".", "Dropout", "(", "p", "=", "dropout", ")", "\n", "self", ".", "linear3", "=", "nn", ".", "Linear", "(", "256", ",", "num_classes", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "self", ".", "weights_init", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models._NonLinearClassifier.weights_init": [[31, 36], ["isinstance", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "m.bias.data.fill_"], "methods", ["None"], ["", "", "def", "weights_init", "(", "self", ",", "m", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "nn", ".", "Linear", ")", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ".", "data", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models._NonLinearClassifier.forward": [[37, 54], ["torch.relu", "torch.relu", "models._NonLinearClassifier.dp1", "torch.relu", "torch.relu", "models._NonLinearClassifier.dp2", "models._NonLinearClassifier.linear3", "models._NonLinearClassifier.bn1", "models._NonLinearClassifier.bn2", "models._NonLinearClassifier.linear1", "models._NonLinearClassifier.linear2"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "inp", ")", ":", "\n", "        ", "\"\"\"\n        Forward pass\n\n        Args:\n            inp (torch.tensor): Inputs features to be mapped to logits\n                                (batch_size x input_dim)\n\n        Returns:\n            torch.tensor: Logits (batch_size x num_classes)\n        \"\"\"", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn1", "(", "self", ".", "linear1", "(", "inp", ")", ")", ")", "\n", "x", "=", "self", ".", "dp1", "(", "x", ")", "\n", "x", "=", "F", ".", "relu", "(", "self", ".", "bn2", "(", "self", ".", "linear2", "(", "x", ")", ")", ")", "\n", "x", "=", "self", ".", "dp2", "(", "x", ")", "\n", "x", "=", "self", ".", "linear3", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.UVNetClassifier.__init__": [[66, 95], ["torch.nn.Module.__init__", "uvnet.encoders.UVNetCurveEncoder", "uvnet.encoders.UVNetSurfaceEncoder", "uvnet.encoders.UVNetGraphEncoder", "models._NonLinearClassifier"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_classes", ",", "\n", "crv_emb_dim", "=", "64", ",", "\n", "srf_emb_dim", "=", "64", ",", "\n", "graph_emb_dim", "=", "128", ",", "\n", "dropout", "=", "0.3", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the UV-Net solid classification model\n        \n        Args:\n            num_classes (int): Number of classes to output\n            crv_emb_dim (int, optional): Embedding dimension for the 1D edge UV-grids. Defaults to 64.\n            srf_emb_dim (int, optional): Embedding dimension for the 2D face UV-grids. Defaults to 64.\n            graph_emb_dim (int, optional): Embedding dimension for the graph. Defaults to 128.\n            dropout (float, optional): Dropout for the final non-linear classifier. Defaults to 0.3.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "curv_encoder", "=", "uvnet", ".", "encoders", ".", "UVNetCurveEncoder", "(", "\n", "in_channels", "=", "6", ",", "output_dims", "=", "crv_emb_dim", "\n", ")", "\n", "self", ".", "surf_encoder", "=", "uvnet", ".", "encoders", ".", "UVNetSurfaceEncoder", "(", "\n", "in_channels", "=", "7", ",", "output_dims", "=", "srf_emb_dim", "\n", ")", "\n", "self", ".", "graph_encoder", "=", "uvnet", ".", "encoders", ".", "UVNetGraphEncoder", "(", "\n", "srf_emb_dim", ",", "crv_emb_dim", ",", "graph_emb_dim", ",", "\n", ")", "\n", "self", ".", "clf", "=", "_NonLinearClassifier", "(", "graph_emb_dim", ",", "num_classes", ",", "dropout", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.UVNetClassifier.forward": [[96, 121], ["models.UVNetClassifier.curv_encoder", "models.UVNetClassifier.surf_encoder", "models.UVNetClassifier.graph_encoder", "models.UVNetClassifier.clf"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batched_graph", ")", ":", "\n", "        ", "\"\"\"\n        Forward pass\n\n        Args:\n            batched_graph (dgl.Graph): A batched DGL graph containing the face 2D UV-grids in node features\n                                       (ndata['x']) and 1D edge UV-grids in the edge features (edata['x']).\n\n        Returns:\n            torch.tensor: Logits (batch_size x num_classes)\n        \"\"\"", "\n", "# Input features", "\n", "input_crv_feat", "=", "batched_graph", ".", "edata", "[", "\"x\"", "]", "\n", "input_srf_feat", "=", "batched_graph", ".", "ndata", "[", "\"x\"", "]", "\n", "# Compute hidden edge and face features", "\n", "hidden_crv_feat", "=", "self", ".", "curv_encoder", "(", "input_crv_feat", ")", "\n", "hidden_srf_feat", "=", "self", ".", "surf_encoder", "(", "input_srf_feat", ")", "\n", "# Message pass and compute per-face(node) and global embeddings", "\n", "# Per-face embeddings are ignored during solid classification", "\n", "_", ",", "graph_emb", "=", "self", ".", "graph_encoder", "(", "\n", "batched_graph", ",", "hidden_srf_feat", ",", "hidden_crv_feat", "\n", ")", "\n", "# Map to logits", "\n", "out", "=", "self", ".", "clf", "(", "graph_emb", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Classification.__init__": [[128, 139], ["pytorch_lightning.LightningModule.__init__", "models.Classification.save_hyperparameters", "models.UVNetClassifier", "torchmetrics.Accuracy", "torchmetrics.Accuracy", "torchmetrics.Accuracy"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["def", "__init__", "(", "self", ",", "num_classes", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            num_classes (int): Number of per-solid classes in the dataset\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "save_hyperparameters", "(", ")", "\n", "self", ".", "model", "=", "UVNetClassifier", "(", "num_classes", "=", "num_classes", ")", "\n", "self", ".", "train_acc", "=", "torchmetrics", ".", "Accuracy", "(", ")", "\n", "self", ".", "val_acc", "=", "torchmetrics", ".", "Accuracy", "(", ")", "\n", "self", ".", "test_acc", "=", "torchmetrics", ".", "Accuracy", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Classification.forward": [[140, 143], ["models.Classification.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batched_graph", ")", ":", "\n", "        ", "logits", "=", "self", ".", "model", "(", "batched_graph", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Classification.training_step": [[144, 155], ["batch[].to", "batch[].to", "batch[].to.ndata[].permute", "batch[].to.edata[].permute", "models.Classification.model", "torch.cross_entropy", "torch.cross_entropy", "models.Classification.log", "torch.softmax", "torch.softmax", "models.Classification.log", "models.Classification.train_acc"], "methods", ["None"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "inputs", "=", "batch", "[", "\"graph\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "batch", "[", "\"label\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "inputs", ".", "ndata", "[", "\"x\"", "]", "=", "inputs", ".", "ndata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "inputs", ".", "edata", "[", "\"x\"", "]", "=", "inputs", ".", "edata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "logits", "=", "self", ".", "model", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "\"mean\"", ")", "\n", "self", ".", "log", "(", "\"train_loss\"", ",", "loss", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "log", "(", "\"train_acc\"", ",", "self", ".", "train_acc", "(", "preds", ",", "labels", ")", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Classification.validation_step": [[156, 167], ["batch[].to", "batch[].to", "batch[].to.ndata[].permute", "batch[].to.edata[].permute", "models.Classification.model", "torch.cross_entropy", "torch.cross_entropy", "models.Classification.log", "torch.softmax", "torch.softmax", "models.Classification.log", "models.Classification.val_acc"], "methods", ["None"], ["", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "inputs", "=", "batch", "[", "\"graph\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "batch", "[", "\"label\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "inputs", ".", "ndata", "[", "\"x\"", "]", "=", "inputs", ".", "ndata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "inputs", ".", "edata", "[", "\"x\"", "]", "=", "inputs", ".", "edata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "logits", "=", "self", ".", "model", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "\"mean\"", ")", "\n", "self", ".", "log", "(", "\"val_loss\"", ",", "loss", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "log", "(", "\"val_acc\"", ",", "self", ".", "val_acc", "(", "preds", ",", "labels", ")", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Classification.test_step": [[168, 178], ["batch[].to", "batch[].to", "batch[].to.ndata[].permute", "batch[].to.edata[].permute", "models.Classification.model", "torch.cross_entropy", "torch.cross_entropy", "models.Classification.log", "torch.softmax", "torch.softmax", "models.Classification.log", "models.Classification.test_acc"], "methods", ["None"], ["", "def", "test_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "inputs", "=", "batch", "[", "\"graph\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "labels", "=", "batch", "[", "\"label\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "inputs", ".", "ndata", "[", "\"x\"", "]", "=", "inputs", ".", "ndata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "inputs", ".", "edata", "[", "\"x\"", "]", "=", "inputs", ".", "edata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "logits", "=", "self", ".", "model", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "\"mean\"", ")", "\n", "self", ".", "log", "(", "\"test_loss\"", ",", "loss", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "log", "(", "\"test_acc\"", ",", "self", ".", "test_acc", "(", "preds", ",", "labels", ")", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Classification.configure_optimizers": [[179, 182], ["torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "models.Classification.parameters"], "methods", ["None"], ["", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ")", "\n", "return", "optimizer", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.UVNetSegmenter.__init__": [[194, 230], ["torch.nn.Module.__init__", "uvnet.encoders.UVNetCurveEncoder", "uvnet.encoders.UVNetSurfaceEncoder", "uvnet.encoders.UVNetGraphEncoder", "models._NonLinearClassifier"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["def", "__init__", "(", "\n", "self", ",", "\n", "num_classes", ",", "\n", "crv_in_channels", "=", "6", ",", "\n", "crv_emb_dim", "=", "64", ",", "\n", "srf_emb_dim", "=", "64", ",", "\n", "graph_emb_dim", "=", "128", ",", "\n", "dropout", "=", "0.3", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        Initialize the UV-Net solid face segmentation model\n\n        Args:\n            num_classes (int): Number of classes to output per-face\n            crv_in_channels (int, optional): Number of input channels for the 1D edge UV-grids\n            crv_emb_dim (int, optional): Embedding dimension for the 1D edge UV-grids. Defaults to 64.\n            srf_emb_dim (int, optional): Embedding dimension for the 2D face UV-grids. Defaults to 64.\n            graph_emb_dim (int, optional): Embedding dimension for the graph. Defaults to 128.\n            dropout (float, optional): Dropout for the final non-linear classifier. Defaults to 0.3.\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "# A 1D convolutional network to encode B-rep edge geometry represented as 1D UV-grids", "\n", "self", ".", "curv_encoder", "=", "uvnet", ".", "encoders", ".", "UVNetCurveEncoder", "(", "\n", "in_channels", "=", "crv_in_channels", ",", "output_dims", "=", "crv_emb_dim", "\n", ")", "\n", "# A 2D convolutional network to encode B-rep face geometry represented as 2D UV-grids", "\n", "self", ".", "surf_encoder", "=", "uvnet", ".", "encoders", ".", "UVNetSurfaceEncoder", "(", "\n", "in_channels", "=", "7", ",", "output_dims", "=", "srf_emb_dim", "\n", ")", "\n", "# A graph neural network that message passes face and edge features", "\n", "self", ".", "graph_encoder", "=", "uvnet", ".", "encoders", ".", "UVNetGraphEncoder", "(", "\n", "srf_emb_dim", ",", "crv_emb_dim", ",", "graph_emb_dim", ",", "\n", ")", "\n", "# A non-linear classifier that maps face embeddings to face logits", "\n", "self", ".", "seg", "=", "_NonLinearClassifier", "(", "\n", "graph_emb_dim", "+", "srf_emb_dim", ",", "num_classes", ",", "dropout", "=", "dropout", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.UVNetSegmenter.forward": [[232, 261], ["models.UVNetSegmenter.curv_encoder", "models.UVNetSegmenter.surf_encoder", "models.UVNetSegmenter.graph_encoder", "batched_graph.batch_num_nodes().to", "graph_emb.repeat_interleave().to.repeat_interleave().to.repeat_interleave().to", "torch.cat", "torch.cat", "torch.cat", "torch.cat", "models.UVNetSegmenter.seg", "batched_graph.batch_num_nodes", "graph_emb.repeat_interleave().to.repeat_interleave().to.repeat_interleave"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batched_graph", ")", ":", "\n", "        ", "\"\"\"\n        Forward pass\n\n        Args:\n            batched_graph (dgl.Graph): A batched DGL graph containing the face 2D UV-grids in node features\n                                       (ndata['x']) and 1D edge UV-grids in the edge features (edata['x']).\n\n        Returns:\n            torch.tensor: Logits (total_nodes_in_batch x num_classes)\n        \"\"\"", "\n", "# Input features", "\n", "input_crv_feat", "=", "batched_graph", ".", "edata", "[", "\"x\"", "]", "\n", "input_srf_feat", "=", "batched_graph", ".", "ndata", "[", "\"x\"", "]", "\n", "# Compute hidden edge and face features", "\n", "hidden_crv_feat", "=", "self", ".", "curv_encoder", "(", "input_crv_feat", ")", "\n", "hidden_srf_feat", "=", "self", ".", "surf_encoder", "(", "input_srf_feat", ")", "\n", "# Message pass and compute per-face(node) and global embeddings", "\n", "node_emb", ",", "graph_emb", "=", "self", ".", "graph_encoder", "(", "\n", "batched_graph", ",", "hidden_srf_feat", ",", "hidden_crv_feat", "\n", ")", "\n", "# Repeat the global graph embedding so that it can be", "\n", "# concatenated to the per-node embeddings", "\n", "num_nodes_per_graph", "=", "batched_graph", ".", "batch_num_nodes", "(", ")", ".", "to", "(", "graph_emb", ".", "device", ")", "\n", "graph_emb", "=", "graph_emb", ".", "repeat_interleave", "(", "num_nodes_per_graph", ",", "dim", "=", "0", ")", ".", "to", "(", "graph_emb", ".", "device", ")", "\n", "local_global_feat", "=", "torch", ".", "cat", "(", "(", "node_emb", ",", "graph_emb", ")", ",", "dim", "=", "1", ")", "\n", "# Map to logits", "\n", "out", "=", "self", ".", "seg", "(", "local_global_feat", ")", "\n", "return", "out", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.__init__": [[268, 293], ["pytorch_lightning.LightningModule.__init__", "models.Segmentation.save_hyperparameters", "models.UVNetSegmenter", "torchmetrics.IoU", "torchmetrics.IoU", "torchmetrics.IoU", "torchmetrics.Accuracy", "torchmetrics.Accuracy", "torchmetrics.Accuracy"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["def", "__init__", "(", "self", ",", "num_classes", ",", "crv_in_channels", "=", "6", ")", ":", "\n", "        ", "\"\"\"\n        Args:\n            num_classes (int): Number of per-face classes in the dataset\n        \"\"\"", "\n", "super", "(", ")", ".", "__init__", "(", ")", "\n", "self", ".", "save_hyperparameters", "(", ")", "\n", "self", ".", "model", "=", "UVNetSegmenter", "(", "num_classes", ",", "crv_in_channels", "=", "crv_in_channels", ")", "\n", "# Setting compute_on_step = False to compute \"part IoU\"", "\n", "# This is because we want to compute the IoU on the entire dataset", "\n", "# at the end to account for rare classes, rather than within each batch", "\n", "self", ".", "train_iou", "=", "torchmetrics", ".", "IoU", "(", "\n", "num_classes", "=", "num_classes", ",", "compute_on_step", "=", "False", "\n", ")", "\n", "self", ".", "val_iou", "=", "torchmetrics", ".", "IoU", "(", "num_classes", "=", "num_classes", ",", "compute_on_step", "=", "False", ")", "\n", "self", ".", "test_iou", "=", "torchmetrics", ".", "IoU", "(", "num_classes", "=", "num_classes", ",", "compute_on_step", "=", "False", ")", "\n", "\n", "self", ".", "train_accuracy", "=", "torchmetrics", ".", "Accuracy", "(", "\n", "num_classes", "=", "num_classes", ",", "compute_on_step", "=", "False", "\n", ")", "\n", "self", ".", "val_accuracy", "=", "torchmetrics", ".", "Accuracy", "(", "\n", "num_classes", "=", "num_classes", ",", "compute_on_step", "=", "False", "\n", ")", "\n", "self", ".", "test_accuracy", "=", "torchmetrics", ".", "Accuracy", "(", "\n", "num_classes", "=", "num_classes", ",", "compute_on_step", "=", "False", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.forward": [[295, 298], ["models.Segmentation.model"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "batched_graph", ")", ":", "\n", "        ", "logits", "=", "self", ".", "model", "(", "batched_graph", ")", "\n", "return", "logits", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.training_step": [[299, 311], ["batch[].to", "batch[].to.ndata[].permute", "batch[].to.edata[].permute", "models.Segmentation.model", "torch.cross_entropy", "torch.cross_entropy", "models.Segmentation.log", "torch.softmax", "torch.softmax", "models.Segmentation.train_iou", "models.Segmentation.train_accuracy"], "methods", ["None"], ["", "def", "training_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "inputs", "=", "batch", "[", "\"graph\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "inputs", ".", "ndata", "[", "\"x\"", "]", "=", "inputs", ".", "ndata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "inputs", ".", "edata", "[", "\"x\"", "]", "=", "inputs", ".", "edata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "labels", "=", "inputs", ".", "ndata", "[", "\"y\"", "]", "\n", "logits", "=", "self", ".", "model", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "\"mean\"", ")", "\n", "self", ".", "log", "(", "\"train_loss\"", ",", "loss", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "train_iou", "(", "preds", ",", "labels", ")", "\n", "self", ".", "train_accuracy", "(", "preds", ",", "labels", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.training_epoch_end": [[312, 315], ["models.Segmentation.log", "models.Segmentation.log", "models.Segmentation.train_iou.compute", "models.Segmentation.train_accuracy.compute"], "methods", ["None"], ["", "def", "training_epoch_end", "(", "self", ",", "outs", ")", ":", "\n", "        ", "self", ".", "log", "(", "\"train_iou\"", ",", "self", ".", "train_iou", ".", "compute", "(", ")", ")", "\n", "self", ".", "log", "(", "\"train_accuracy\"", ",", "self", ".", "train_accuracy", ".", "compute", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.validation_step": [[316, 328], ["batch[].to", "batch[].to.ndata[].permute", "batch[].to.edata[].permute", "models.Segmentation.model", "torch.cross_entropy", "torch.cross_entropy", "models.Segmentation.log", "torch.softmax", "torch.softmax", "models.Segmentation.val_iou", "models.Segmentation.val_accuracy"], "methods", ["None"], ["", "def", "validation_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "inputs", "=", "batch", "[", "\"graph\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "inputs", ".", "ndata", "[", "\"x\"", "]", "=", "inputs", ".", "ndata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "inputs", ".", "edata", "[", "\"x\"", "]", "=", "inputs", ".", "edata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "labels", "=", "inputs", ".", "ndata", "[", "\"y\"", "]", "\n", "logits", "=", "self", ".", "model", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "\"mean\"", ")", "\n", "self", ".", "log", "(", "\"val_loss\"", ",", "loss", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "val_iou", "(", "preds", ",", "labels", ")", "\n", "self", ".", "val_accuracy", "(", "preds", ",", "labels", ")", "\n", "return", "loss", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.validation_epoch_end": [[329, 332], ["models.Segmentation.log", "models.Segmentation.log", "models.Segmentation.val_iou.compute", "models.Segmentation.val_accuracy.compute"], "methods", ["None"], ["", "def", "validation_epoch_end", "(", "self", ",", "outs", ")", ":", "\n", "        ", "self", ".", "log", "(", "\"val_iou\"", ",", "self", ".", "val_iou", ".", "compute", "(", ")", ")", "\n", "self", ".", "log", "(", "\"val_accuracy\"", ",", "self", ".", "val_accuracy", ".", "compute", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.test_step": [[333, 344], ["batch[].to", "batch[].to.ndata[].permute", "batch[].to.edata[].permute", "models.Segmentation.model", "torch.cross_entropy", "torch.cross_entropy", "models.Segmentation.log", "torch.softmax", "torch.softmax", "models.Segmentation.test_iou", "models.Segmentation.test_accuracy"], "methods", ["None"], ["", "def", "test_step", "(", "self", ",", "batch", ",", "batch_idx", ")", ":", "\n", "        ", "inputs", "=", "batch", "[", "\"graph\"", "]", ".", "to", "(", "self", ".", "device", ")", "\n", "inputs", ".", "ndata", "[", "\"x\"", "]", "=", "inputs", ".", "ndata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "3", ",", "1", ",", "2", ")", "\n", "inputs", ".", "edata", "[", "\"x\"", "]", "=", "inputs", ".", "edata", "[", "\"x\"", "]", ".", "permute", "(", "0", ",", "2", ",", "1", ")", "\n", "labels", "=", "inputs", ".", "ndata", "[", "\"y\"", "]", "\n", "logits", "=", "self", ".", "model", "(", "inputs", ")", "\n", "loss", "=", "F", ".", "cross_entropy", "(", "logits", ",", "labels", ",", "reduction", "=", "\"mean\"", ")", "\n", "self", ".", "log", "(", "\"test_loss\"", ",", "loss", ",", "on_step", "=", "False", ",", "on_epoch", "=", "True", ",", "sync_dist", "=", "True", ")", "\n", "preds", "=", "F", ".", "softmax", "(", "logits", ",", "dim", "=", "-", "1", ")", "\n", "self", ".", "test_iou", "(", "preds", ",", "labels", ")", "\n", "self", ".", "test_accuracy", "(", "preds", ",", "labels", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.test_epoch_end": [[345, 348], ["models.Segmentation.log", "models.Segmentation.log", "models.Segmentation.test_iou.compute", "models.Segmentation.test_accuracy.compute"], "methods", ["None"], ["", "def", "test_epoch_end", "(", "self", ",", "outs", ")", ":", "\n", "        ", "self", ".", "log", "(", "\"test_iou\"", ",", "self", ".", "test_iou", ".", "compute", "(", ")", ")", "\n", "self", ".", "log", "(", "\"test_accuracy\"", ",", "self", ".", "test_accuracy", ".", "compute", "(", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.models.Segmentation.configure_optimizers": [[349, 352], ["torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "torch.optim.Adam", "models.Segmentation.parameters"], "methods", ["None"], ["", "def", "configure_optimizers", "(", "self", ")", ":", "\n", "        ", "optimizer", "=", "torch", ".", "optim", ".", "Adam", "(", "self", ".", "parameters", "(", ")", ")", "\n", "return", "optimizer", "\n", "", "", ""]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._MLP.__init__": [[68, 104], ["torch.nn.Module.__init__", "ValueError", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "encoders._MLP.linears.append", "range", "encoders._MLP.linears.append", "range", "torch.nn.Linear", "torch.nn.Linear", "encoders._MLP.linears.append", "torch.nn.Linear", "torch.nn.Linear", "encoders._MLP.batch_norms.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["def", "__init__", "(", "self", ",", "num_layers", ",", "input_dim", ",", "hidden_dim", ",", "output_dim", ")", ":", "\n", "        ", "\"\"\"\n        MLP with linear output\n        Args:\n            num_layers (int): The number of linear layers in the MLP\n            input_dim (int): Input feature dimension\n            hidden_dim (int): Hidden feature dimensions for all hidden layers\n            output_dim (int): Output feature dimension\n\n        Raises:\n            ValueError: If the given number of layers is <1\n        \"\"\"", "\n", "super", "(", "_MLP", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "linear_or_not", "=", "True", "# default is linear model", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "output_dim", "=", "output_dim", "\n", "\n", "if", "num_layers", "<", "1", ":", "\n", "            ", "raise", "ValueError", "(", "\"Number of layers should be positive!\"", ")", "\n", "", "elif", "num_layers", "==", "1", ":", "\n", "# Linear model", "\n", "            ", "self", ".", "linear", "=", "nn", ".", "Linear", "(", "input_dim", ",", "output_dim", ")", "\n", "", "else", ":", "\n", "# Multi-layer model", "\n", "            ", "self", ".", "linear_or_not", "=", "False", "\n", "self", ".", "linears", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "batch_norms", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "self", ".", "linears", ".", "append", "(", "nn", ".", "Linear", "(", "input_dim", ",", "hidden_dim", ")", ")", "\n", "for", "layer", "in", "range", "(", "num_layers", "-", "2", ")", ":", "\n", "                ", "self", ".", "linears", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_dim", ",", "hidden_dim", ")", ")", "\n", "", "self", ".", "linears", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_dim", ",", "output_dim", ")", ")", "\n", "\n", "# TODO: this could move inside the above loop", "\n", "for", "layer", "in", "range", "(", "num_layers", "-", "1", ")", ":", "\n", "                ", "self", ".", "batch_norms", ".", "append", "(", "nn", ".", "BatchNorm1d", "(", "(", "hidden_dim", ")", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._MLP.forward": [[105, 115], ["encoders._MLP.linear", "range", "torch.relu", "torch.relu"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "if", "self", ".", "linear_or_not", ":", "\n", "# If linear model", "\n", "            ", "return", "self", ".", "linear", "(", "x", ")", "\n", "", "else", ":", "\n", "# If MLP", "\n", "            ", "h", "=", "x", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "                ", "h", "=", "F", ".", "relu", "(", "self", ".", "batch_norms", "[", "i", "]", "(", "self", ".", "linears", "[", "i", "]", "(", "h", ")", ")", ")", "\n", "", "return", "self", ".", "linears", "[", "-", "1", "]", "(", "h", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetCurveEncoder.__init__": [[118, 140], ["torch.nn.Module.__init__", "encoders._conv1d", "encoders._conv1d", "encoders._conv1d", "torch.nn.AdaptiveAvgPool1d", "torch.nn.AdaptiveAvgPool1d", "encoders._fc", "encoders.UVNetCurveEncoder.modules", "encoders.UVNetCurveEncoder.weights_init"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv1d", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv1d", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv1d", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._fc", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetSurfaceEncoder.weights_init"], ["    ", "def", "__init__", "(", "self", ",", "in_channels", "=", "6", ",", "output_dims", "=", "64", ")", ":", "\n", "        ", "\"\"\"\n        This is the 1D convolutional network that extracts features from the B-rep edge\n        geometry described as 1D UV-grids (see Section 3.2, Curve & surface convolution\n        in paper)\n\n        Args:\n            in_channels (int, optional): Number of channels in the edge UV-grids. By default\n                                         we expect 3 channels for point coordinates and 3 for\n                                         curve tangents. Defaults to 6.\n            output_dims (int, optional): Output curve embedding dimension. Defaults to 64.\n        \"\"\"", "\n", "super", "(", "UVNetCurveEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv1", "=", "_conv1d", "(", "in_channels", ",", "64", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv2", "=", "_conv1d", "(", "64", ",", "128", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv3", "=", "_conv1d", "(", "128", ",", "256", ",", "kernel_size", "=", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "final_pool", "=", "nn", ".", "AdaptiveAvgPool1d", "(", "1", ")", "\n", "self", ".", "fc", "=", "_fc", "(", "256", ",", "output_dims", ",", "bias", "=", "False", ")", "\n", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "self", ".", "weights_init", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetCurveEncoder.weights_init": [[141, 146], ["isinstance", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "m.bias.data.fill_"], "methods", ["None"], ["", "", "def", "weights_init", "(", "self", ",", "m", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv1d", ")", ")", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ".", "data", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetCurveEncoder.forward": [[147, 157], ["encoders.UVNetCurveEncoder.size", "encoders.UVNetCurveEncoder.conv1", "encoders.UVNetCurveEncoder.conv2", "encoders.UVNetCurveEncoder.conv3", "encoders.UVNetCurveEncoder.final_pool", "encoders.UVNetCurveEncoder.view", "encoders.UVNetCurveEncoder.fc", "encoders.UVNetCurveEncoder.size"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "size", "(", "1", ")", "==", "self", ".", "in_channels", "\n", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "final_pool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetSurfaceEncoder.__init__": [[160, 186], ["torch.nn.Module.__init__", "encoders._conv2d", "encoders._conv2d", "encoders._conv2d", "torch.nn.AdaptiveAvgPool2d", "torch.nn.AdaptiveAvgPool2d", "encoders._fc", "encoders.UVNetSurfaceEncoder.modules", "encoders.UVNetSurfaceEncoder.weights_init"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv2d", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv2d", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv2d", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._fc", "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetSurfaceEncoder.weights_init"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "in_channels", "=", "7", ",", "\n", "output_dims", "=", "64", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        This is the 2D convolutional network that extracts features from the B-rep face\n        geometry described as 2D UV-grids (see Section 3.2, Curve & surface convolution\n        in paper)\n\n        Args:\n            in_channels (int, optional): Number of channels in the edge UV-grids. By default\n                                         we expect 3 channels for point coordinates and 3 for\n                                         surface normals and 1 for the trimming mask. Defaults\n                                         to 7.\n            output_dims (int, optional): Output surface embedding dimension. Defaults to 64.\n        \"\"\"", "\n", "super", "(", "UVNetSurfaceEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "in_channels", "=", "in_channels", "\n", "self", ".", "conv1", "=", "_conv2d", "(", "in_channels", ",", "64", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv2", "=", "_conv2d", "(", "64", ",", "128", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "conv3", "=", "_conv2d", "(", "128", ",", "256", ",", "3", ",", "padding", "=", "1", ",", "bias", "=", "False", ")", "\n", "self", ".", "final_pool", "=", "nn", ".", "AdaptiveAvgPool2d", "(", "1", ")", "\n", "self", ".", "fc", "=", "_fc", "(", "256", ",", "output_dims", ",", "bias", "=", "False", ")", "\n", "for", "m", "in", "self", ".", "modules", "(", ")", ":", "\n", "            ", "self", ".", "weights_init", "(", "m", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetSurfaceEncoder.weights_init": [[187, 192], ["isinstance", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "torch.nn.init.kaiming_uniform_", "m.bias.data.fill_"], "methods", ["None"], ["", "", "def", "weights_init", "(", "self", ",", "m", ")", ":", "\n", "        ", "if", "isinstance", "(", "m", ",", "(", "nn", ".", "Linear", ",", "nn", ".", "Conv2d", ")", ")", ":", "\n", "            ", "torch", ".", "nn", ".", "init", ".", "kaiming_uniform_", "(", "m", ".", "weight", ".", "data", ")", "\n", "if", "m", ".", "bias", "is", "not", "None", ":", "\n", "                ", "m", ".", "bias", ".", "data", ".", "fill_", "(", "0.0", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetSurfaceEncoder.forward": [[193, 203], ["encoders.UVNetSurfaceEncoder.size", "encoders.UVNetSurfaceEncoder.conv1", "encoders.UVNetSurfaceEncoder.conv2", "encoders.UVNetSurfaceEncoder.conv3", "encoders.UVNetSurfaceEncoder.final_pool", "encoders.UVNetSurfaceEncoder.view", "encoders.UVNetSurfaceEncoder.fc", "encoders.UVNetSurfaceEncoder.size"], "methods", ["None"], ["", "", "", "def", "forward", "(", "self", ",", "x", ")", ":", "\n", "        ", "assert", "x", ".", "size", "(", "1", ")", "==", "self", ".", "in_channels", "\n", "batch_size", "=", "x", ".", "size", "(", "0", ")", "\n", "x", "=", "self", ".", "conv1", "(", "x", ")", "\n", "x", "=", "self", ".", "conv2", "(", "x", ")", "\n", "x", "=", "self", ".", "conv3", "(", "x", ")", "\n", "x", "=", "self", ".", "final_pool", "(", "x", ")", "\n", "x", "=", "x", ".", "view", "(", "batch_size", ",", "-", "1", ")", "\n", "x", "=", "self", ".", "fc", "(", "x", ")", "\n", "return", "x", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._EdgeConv.__init__": [[207, 231], ["torch.nn.Module.__init__", "encoders._MLP", "encoders._MLP", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "edge_feats", ",", "\n", "out_feats", ",", "\n", "node_feats", ",", "\n", "num_mlp_layers", "=", "2", ",", "\n", "hidden_mlp_dim", "=", "64", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        This module implements Eq. 2 from the paper where the edge features are\n        updated using the node features at the endpoints.\n\n        Args:\n            edge_feats (int): Input edge feature dimension\n            out_feats (int): Output feature deimension\n            node_feats (int): Input node feature dimension\n            num_mlp_layers (int, optional): Number of layers used in the MLP. Defaults to 2.\n            hidden_mlp_dim (int, optional): Hidden feature dimension in the MLP. Defaults to 64.\n        \"\"\"", "\n", "super", "(", "_EdgeConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "proj", "=", "_MLP", "(", "1", ",", "node_feats", ",", "hidden_mlp_dim", ",", "edge_feats", ")", "\n", "self", ".", "mlp", "=", "_MLP", "(", "num_mlp_layers", ",", "edge_feats", ",", "hidden_mlp_dim", ",", "out_feats", ")", "\n", "self", ".", "batchnorm", "=", "nn", ".", "BatchNorm1d", "(", "out_feats", ")", "\n", "self", ".", "eps", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "[", "0.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._EdgeConv.forward": [[232, 239], ["graph.edges", "encoders._EdgeConv.mlp", "torch.leaky_relu", "torch.leaky_relu", "encoders._EdgeConv.proj", "encoders._EdgeConv.proj", "encoders._EdgeConv.batchnorm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "graph", ",", "nfeat", ",", "efeat", ")", ":", "\n", "        ", "src", ",", "dst", "=", "graph", ".", "edges", "(", ")", "\n", "proj1", ",", "proj2", "=", "self", ".", "proj", "(", "nfeat", "[", "src", "]", ")", ",", "self", ".", "proj", "(", "nfeat", "[", "dst", "]", ")", "\n", "agg", "=", "proj1", "+", "proj2", "\n", "h", "=", "self", ".", "mlp", "(", "(", "1", "+", "self", ".", "eps", ")", "*", "efeat", "+", "agg", ")", "\n", "h", "=", "F", ".", "leaky_relu", "(", "self", ".", "batchnorm", "(", "h", ")", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._NodeConv.__init__": [[242, 272], ["torch.nn.Module.__init__", "dgl.nn.pytorch.conv.NNConv", "torch.nn.BatchNorm1d", "torch.nn.BatchNorm1d", "encoders._MLP", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.nn.Parameter", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.FloatTensor", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "node_feats", ",", "\n", "out_feats", ",", "\n", "edge_feats", ",", "\n", "num_mlp_layers", "=", "2", ",", "\n", "hidden_mlp_dim", "=", "64", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        This module implements Eq. 1 from the paper where the node features are\n        updated using the neighboring node and edge features.\n\n        Args:\n            node_feats (int): Input edge feature dimension\n            out_feats (int): Output feature deimension\n            node_feats (int): Input node feature dimension\n            num_mlp_layers (int, optional): Number of layers used in the MLP. Defaults to 2.\n            hidden_mlp_dim (int, optional): Hidden feature dimension in the MLP. Defaults to 64.\n        \"\"\"", "\n", "super", "(", "_NodeConv", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "gconv", "=", "NNConv", "(", "\n", "in_feats", "=", "node_feats", ",", "\n", "out_feats", "=", "out_feats", ",", "\n", "edge_func", "=", "nn", ".", "Linear", "(", "edge_feats", ",", "node_feats", "*", "out_feats", ")", ",", "\n", "aggregator_type", "=", "\"sum\"", ",", "\n", "bias", "=", "False", ",", "\n", ")", "\n", "self", ".", "batchnorm", "=", "nn", ".", "BatchNorm1d", "(", "out_feats", ")", "\n", "self", ".", "mlp", "=", "_MLP", "(", "num_mlp_layers", ",", "node_feats", ",", "hidden_mlp_dim", ",", "out_feats", ")", "\n", "self", ".", "eps", "=", "torch", ".", "nn", ".", "Parameter", "(", "torch", ".", "FloatTensor", "(", "[", "0.0", "]", ")", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._NodeConv.forward": [[273, 279], ["encoders._NodeConv.gconv", "encoders._NodeConv.mlp", "torch.leaky_relu", "torch.leaky_relu", "encoders._NodeConv.batchnorm"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "graph", ",", "nfeat", ",", "efeat", ")", ":", "\n", "        ", "h", "=", "(", "1", "+", "self", ".", "eps", ")", "*", "nfeat", "\n", "h", "=", "self", ".", "gconv", "(", "graph", ",", "h", ",", "efeat", ")", "\n", "h", "=", "self", ".", "mlp", "(", "h", ")", "\n", "h", "=", "F", ".", "leaky_relu", "(", "self", ".", "batchnorm", "(", "h", ")", ")", "\n", "return", "h", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__": [[282, 348], ["torch.nn.Module.__init__", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "torch.nn.ModuleList", "range", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "torch.nn.Dropout", "dgl.nn.pytorch.glob.MaxPooling", "encoders.UVNetGraphEncoder.node_conv_layers.append", "encoders.UVNetGraphEncoder.edge_conv_layers.append", "encoders._NodeConv", "encoders._EdgeConv", "encoders.UVNetGraphEncoder.linears_prediction.append", "encoders.UVNetGraphEncoder.linears_prediction.append", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear", "torch.nn.Linear"], "methods", ["home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.__init__"], ["    ", "def", "__init__", "(", "\n", "self", ",", "\n", "input_dim", ",", "\n", "input_edge_dim", ",", "\n", "output_dim", ",", "\n", "hidden_dim", "=", "64", ",", "\n", "learn_eps", "=", "True", ",", "\n", "num_layers", "=", "3", ",", "\n", "num_mlp_layers", "=", "2", ",", "\n", ")", ":", "\n", "        ", "\"\"\"\n        This is the graph neural network used for message-passing features in the\n        face-adjacency graph.  (see Section 3.2, Message passing in paper)\n\n        Args:\n            input_dim ([type]): [description]\n            input_edge_dim ([type]): [description]\n            output_dim ([type]): [description]\n            hidden_dim (int, optional): [description]. Defaults to 64.\n            learn_eps (bool, optional): [description]. Defaults to True.\n            num_layers (int, optional): [description]. Defaults to 3.\n            num_mlp_layers (int, optional): [description]. Defaults to 2.\n        \"\"\"", "\n", "super", "(", "UVNetGraphEncoder", ",", "self", ")", ".", "__init__", "(", ")", "\n", "self", ".", "num_layers", "=", "num_layers", "\n", "self", ".", "learn_eps", "=", "learn_eps", "\n", "\n", "# List of layers for node and edge feature message passing", "\n", "self", ".", "node_conv_layers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "self", ".", "edge_conv_layers", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "layer", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "            ", "node_feats", "=", "input_dim", "if", "layer", "==", "0", "else", "hidden_dim", "\n", "edge_feats", "=", "input_edge_dim", "if", "layer", "==", "0", "else", "hidden_dim", "\n", "self", ".", "node_conv_layers", ".", "append", "(", "\n", "_NodeConv", "(", "\n", "node_feats", "=", "node_feats", ",", "\n", "out_feats", "=", "hidden_dim", ",", "\n", "edge_feats", "=", "edge_feats", ",", "\n", "num_mlp_layers", "=", "num_mlp_layers", ",", "\n", "hidden_mlp_dim", "=", "hidden_dim", ",", "\n", ")", ",", "\n", ")", "\n", "self", ".", "edge_conv_layers", ".", "append", "(", "\n", "_EdgeConv", "(", "\n", "edge_feats", "=", "edge_feats", ",", "\n", "out_feats", "=", "hidden_dim", ",", "\n", "node_feats", "=", "node_feats", ",", "\n", "num_mlp_layers", "=", "num_mlp_layers", ",", "\n", "hidden_mlp_dim", "=", "hidden_dim", ",", "\n", ")", "\n", ")", "\n", "\n", "# Linear function for graph poolings of output of each layer", "\n", "# which maps the output of different layers into a prediction score", "\n", "", "self", ".", "linears_prediction", "=", "torch", ".", "nn", ".", "ModuleList", "(", ")", "\n", "\n", "for", "layer", "in", "range", "(", "num_layers", ")", ":", "\n", "            ", "if", "layer", "==", "0", ":", "\n", "                ", "self", ".", "linears_prediction", ".", "append", "(", "nn", ".", "Linear", "(", "input_dim", ",", "output_dim", ")", ")", "\n", "", "else", ":", "\n", "                ", "self", ".", "linears_prediction", ".", "append", "(", "nn", ".", "Linear", "(", "hidden_dim", ",", "output_dim", ")", ")", "\n", "\n", "", "", "self", ".", "drop1", "=", "nn", ".", "Dropout", "(", "0.3", ")", "\n", "self", ".", "drop", "=", "nn", ".", "Dropout", "(", "0.5", ")", "\n", "self", ".", "pool", "=", "MaxPooling", "(", ")", "\n", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders.UVNetGraphEncoder.forward": [[349, 370], ["range", "encoders.UVNetGraphEncoder.drop1", "enumerate", "hidden_rep.append", "encoders.UVNetGraphEncoder.pool", "encoders.UVNetGraphEncoder.drop"], "methods", ["None"], ["", "def", "forward", "(", "self", ",", "g", ",", "h", ",", "efeat", ")", ":", "\n", "        ", "hidden_rep", "=", "[", "h", "]", "\n", "he", "=", "efeat", "\n", "\n", "for", "i", "in", "range", "(", "self", ".", "num_layers", "-", "1", ")", ":", "\n", "# Update node features", "\n", "            ", "h", "=", "self", ".", "node_conv_layers", "[", "i", "]", "(", "g", ",", "h", ",", "he", ")", "\n", "# Update edge features", "\n", "he", "=", "self", ".", "edge_conv_layers", "[", "i", "]", "(", "g", ",", "h", ",", "he", ")", "\n", "hidden_rep", ".", "append", "(", "h", ")", "\n", "\n", "", "out", "=", "hidden_rep", "[", "-", "1", "]", "\n", "out", "=", "self", ".", "drop1", "(", "out", ")", "\n", "score_over_layer", "=", "0", "\n", "\n", "# Perform pooling over all nodes in each graph in every layer", "\n", "for", "i", ",", "h", "in", "enumerate", "(", "hidden_rep", ")", ":", "\n", "            ", "pooled_h", "=", "self", ".", "pool", "(", "g", ",", "h", ")", "\n", "score_over_layer", "+=", "self", ".", "drop", "(", "self", ".", "linears_prediction", "[", "i", "]", "(", "pooled_h", ")", ")", "\n", "\n", "", "return", "out", ",", "score_over_layer", "\n", "", "", ""]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv1d": [[7, 27], ["torch.nn.Sequential", "torch.nn.Conv1d", "torch.nn.BatchNorm1d", "torch.nn.LeakyReLU"], "function", ["None"], ["def", "_conv1d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "3", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to create a 1D convolutional layer with batchnorm and LeakyReLU activation\n\n    Args:\n        in_channels (int): Input channels\n        out_channels (int): Output channels\n        kernel_size (int, optional): Size of the convolutional kernel. Defaults to 3.\n        padding (int, optional): Padding size on each side. Defaults to 0.\n        bias (bool, optional): Whether bias is used. Defaults to False.\n\n    Returns:\n        nn.Sequential: Sequential contained the Conv1d, BatchNorm1d and LeakyReLU layers\n    \"\"\"", "\n", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv1d", "(", "\n", "in_channels", ",", "out_channels", ",", "kernel_size", "=", "kernel_size", ",", "padding", "=", "padding", ",", "bias", "=", "bias", "\n", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "out_channels", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._conv2d": [[30, 54], ["torch.nn.Sequential", "torch.nn.Conv2d", "torch.nn.BatchNorm2d", "torch.nn.LeakyReLU"], "function", ["None"], ["", "def", "_conv2d", "(", "in_channels", ",", "out_channels", ",", "kernel_size", ",", "padding", "=", "0", ",", "bias", "=", "False", ")", ":", "\n", "    ", "\"\"\"\n    Helper function to create a 2D convolutional layer with batchnorm and LeakyReLU activation\n\n    Args:\n        in_channels (int): Input channels\n        out_channels (int): Output channels\n        kernel_size (int, optional): Size of the convolutional kernel. Defaults to 3.\n        padding (int, optional): Padding size on each side. Defaults to 0.\n        bias (bool, optional): Whether bias is used. Defaults to False.\n\n    Returns:\n        nn.Sequential: Sequential contained the Conv2d, BatchNorm2d and LeakyReLU layers\n    \"\"\"", "\n", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Conv2d", "(", "\n", "in_channels", ",", "\n", "out_channels", ",", "\n", "kernel_size", "=", "kernel_size", ",", "\n", "padding", "=", "padding", ",", "\n", "bias", "=", "bias", ",", "\n", ")", ",", "\n", "nn", ".", "BatchNorm2d", "(", "out_channels", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", ")", "\n"]], "home.repos.pwc.inspect_result.AutodeskAILab_UV-Net.uvnet.encoders._fc": [[57, 62], ["torch.nn.Sequential", "torch.nn.Linear", "torch.nn.BatchNorm1d", "torch.nn.LeakyReLU"], "function", ["None"], ["", "def", "_fc", "(", "in_features", ",", "out_features", ",", "bias", "=", "False", ")", ":", "\n", "    ", "return", "nn", ".", "Sequential", "(", "\n", "nn", ".", "Linear", "(", "in_features", ",", "out_features", ",", "bias", "=", "bias", ")", ",", "\n", "nn", ".", "BatchNorm1d", "(", "out_features", ")", ",", "\n", "nn", ".", "LeakyReLU", "(", ")", ",", "\n", ")", "\n"]]}